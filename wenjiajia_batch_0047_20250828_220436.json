{
  "metadata": {
    "batch_number": 47,
    "total_batches": 73,
    "problems_in_batch": 100,
    "total_problems": 7261,
    "created_at": "2025-08-28T22:04:41.651890",
    "format": "wenjiajia_v1.0"
  },
  "problems": [
    {
      "problem_id": "493/B",
      "title": "B. Вася и борьба",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест2 секунды",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеВ первой строке дается число n — количество приемов, произведённых бойцами (1 ≤ n ≤ 2·105).В следующих n строках даны целые числа ai (|ai| ≤ 109, ai ≠ 0). Если ai положительное, то это означает, что первый борец произвёл приём, оцененный в ai очков. Если же ai отрицательное, то это означает, что второй борец произвёл приём, оцененный в ( - ai) очков.Приемы записаны в порядке проведения.",
      "output_spec": "Выходные данныеЕсли победителем является первый боец, выведите строку «first», иначе — «second».",
      "sample_tests": "ПримерыВходные данныеСкопировать512-3-43Выходные данныеСкопироватьsecondВходные данныеСкопировать3-1-23Выходные данныеСкопироватьfirstВходные данныеСкопировать24-4Выходные данныеСкопироватьsecond",
      "description": "B. Вася и борьба\n\nограничение по времени на тест2 секунды\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвыводstdout\n\nВходные данныеВ первой строке дается число n — количество приемов, произведённых бойцами (1 ≤ n ≤ 2·105).В следующих n строках даны целые числа ai (|ai| ≤ 109, ai ≠ 0). Если ai положительное, то это означает, что первый борец произвёл приём, оцененный в ai очков. Если же ai отрицательное, то это означает, что второй борец произвёл приём, оцененный в ( - ai) очков.Приемы записаны в порядке проведения.\n\nВходные данные\n\nВыходные данныеЕсли победителем является первый боец, выведите строку «first», иначе — «second».\n\nВыходные данные\n\nВходные данныеСкопировать512-3-43Выходные данныеСкопироватьsecondВходные данныеСкопировать3-1-23Выходные данныеСкопироватьfirstВходные данныеСкопировать24-4Выходные данныеСкопироватьsecond\n\nВходные данныеСкопировать512-3-43\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопироватьsecond\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать3-1-23\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопироватьfirst\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать24-4\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопироватьsecond\n\nВыходные данныеСкопировать\n\nСкопировать\n\nПримечаниеПоследовательность x  =  x1x2... x|x| лексикографически больше последовательности y  =  y1y2... y|y|, если либо |x|  >  |y| и x1  =  y1,  x2  =  y2, ... ,  x|y|  =  y|y|, либо существует такое число r (r  <  |x|, r  <  |y|), что x1  =  y1,  x2  =  y2,  ... ,  xr  =  yr и xr  +  1  >  yr  +  1.В этом определении |a| обозначает длину последовательности a.",
      "solutions": [
        {
          "title": "Codeforces Round #281 (Div. 2) - Codeforces",
          "content": "Здравствуйте!Третьего декабря, в 18:00 по Москве состоится Codeforces Round #281 для Див. 2 участников. Традиционно Див. 1 участники могут участвовать вне конкурса.Это мой первый Codeforces Round и надеюсь, что не последний :)Большое спасибо Максиму Ахмедову (Zlobober) за помощь при подготовке раунда и MikeMirzayanov-у за платформы Codeforces и Polygon.UPD1: Разбалловка будет динамической.UPD2: Контест завершен. Спасибо всем, кто участвовал. Надеюсь, что контест всем нравилось.UPD3: Разбор задачUPD4: Top-5 участники. Поздравляю ShiXingxing15 ganar27 Tim_LinYd coolwyj gaoyihan Еще раз поздравляю gaoyihan — он единственный, кто решил задачу Е.UPD5: Статистика взломов",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/14959",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 673
        },
        {
          "title": "Codeforces Round #281 (Div. 2) Разбор - Codeforces",
          "content": "493A - Вася и футболНам придется хранить два массива — для игроков хозяев и гостей. В каждом из них мы должны сохранять статусы игроков \"чист\", \"желтая карточка\" или статус \"игрок удален\". И с каждом вводом просто проверить — если игрок удален, то ничего не предпринимать, иначе менять его статус в зависимости от того какую карточку он получает и от его статуса. При получении красной карточки в любом статусе, или желтой, находясь в статусе \"желтая карточка\" игрок удаляется с поля, и печатается строка в стандартный вывод.493B - Вася и борьбаНадо делать то, что сказано в условии. Хранить двe vector-ы, в одном из них очки первого борца, а во втором — очки второго. Еще две переменные — в первом сумма всех очков, что дано в вводе, а во втором — кто выполнил последний прием. Если Sum всех не 0, то выводить номер борца, иначе пройти над векторами и проверить — имеются ли неравные элементы. При равенстве выводить ответ зависимо от того, кто выполнял последний прием.493C - Вася и баскетболХраним один большой массив pair-ов — дистанция бросков и кто это выполнил. Сортируем весь этот массив, потом предлагаем, что все броски — трехочковые. Потом пройдем над массивом, и зависимо от второго элемента на одно уменьшаем наши очки на единицу и сравниваем с наилучшим ответом и при необходимости меняем. В самом конце выводим ответ.493D - Вася и шахматыЗаметим, что если n — нечетное, то черные могут сделать симметричные шаги относительно центральной линии — победив таким образом. А если n — четное, то белые могут ставить ферзь на поле (1;2) (что лексикографически наименьший возможный ход), никогда не входить в первую строку, и победить.493E - Вася и многочленРассмотрим две случая. 1) t!=1 и 2) t=1.1) Если наша функция — разная от константа, то а больше всех коэффициентов, и в ответ может быть только представление числа b в а-ичной системе счисления. Еще и надо проверить — является ли константа решением?2) при t=1 надо быть осторожнее:при 1 1 1: ответ inf,при 1 1 n: ответ 0при 1 а, а^x(x-натуральное): ответ 1при других случаях P(1) больше всех коэффициентов.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/14985",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 493\\s*B"
          },
          "content_length": 2071
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #281 (Div. 2) - Codeforces - Code 1",
          "code": "1! + 3! + 4! + 5! + ... + 281!",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14959",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #281 (Div. 2) - Codeforces - Code 2",
          "code": "281 = 9*8 + 7*6 + 5*4 + 3*2 + 1 + 2*3 + 4*5 + 6*7 + 8*9",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14959",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #281 (Div. 2) - Codeforces - Code 3",
          "code": "281 = 9*8 + 7*6 + 5*4 + 3*2 + 1 + 2*3 + 4*5 + 6*7 + 8*9",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14959",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #281 (Div. 2) - Codeforces - Code 4",
          "code": "a[j][m][k] ++;\nif( a[j][m][0] == 2 || a[j][m][1] == 1 )\n    cout << s[j] << \" \" << m << \" \" << t << endl;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14959",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #281 (Div. 2) - Codeforces - Code 5",
          "code": "a[j][m][k] ++;\nif( a[j][m][0] == 2 || a[j][m][1] == 1 )\n    cout << s[j] << \" \" << m << \" \" << t << endl;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14959",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #281 (Div. 2) - Codeforces - Code 6",
          "code": "3\n1000000000\n1000000000\n1000000000",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14959",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #281 (Div. 2) - Codeforces - Code 7",
          "code": "3\n1000000000\n1000000000\n1000000000",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14959",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #281 (Div. 2) - Codeforces - Code 8",
          "code": "4\n1\n5\n-2\n-4",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14959",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #281 (Div. 2) - Codeforces - Code 9",
          "code": "4\n1\n5\n-2\n-4",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14959",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #281 (Div. 2) - Codeforces - Code 10",
          "code": "4\n11\n1\n-9\n-3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14959",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #281 (Div. 2) - Codeforces - Code 11",
          "code": "4\n11\n1\n-9\n-3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14959",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #281 (Div. 2) - Codeforces - Code 12",
          "code": "11 > 9 => true",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14959",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #281 (Div. 2) - Codeforces - Code 13",
          "code": "111 gt 93 => false",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14959",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #281 (Div. 2) - Codeforces - Code 14",
          "code": "if(n%2) cout<<\"black\\n\";  else cout<<\"white\\n1 2\\n\";",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14959",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #281 (Div. 2) - Codeforces - Code 15",
          "code": "if ( (n & 1) == 1 ) {\n        System.out.println(\"black\");\n    } else {\n        System.out.println(\"white\\n1 2\");\n    }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14959",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #281 (Div. 2) - Codeforces - Code 16",
          "code": "if ( (n & 1) == 1 ) {\n        System.out.println(\"black\");\n    } else {\n        System.out.println(\"white\\n1 2\");\n    }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14959",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #281 (Div. 2) - Codeforces - Code 17",
          "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\nusing namespace std;\n#define ll long long \nll dp[6000];\nint main()\n{\n\tcout<<200000<<endl;\n\tfor(int i=0;i<200000;i++)\n\t\tcout<<1999999999<<\" \";\n\tcout<<1<<endl;\n\tcout<<2000000000;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/14959",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #281 (Div. 2) - Codeforces - Code 18",
          "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\nusing namespace std;\n#define ll long long \nll dp[6000];\nint main()\n{\n\tcout<<200000<<endl;\n\tfor(int i=0;i<200000;i++)\n\t\tcout<<1999999999<<\" \";\n\tcout<<1<<endl;\n\tcout<<2000000000;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/14959",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #281 (Div. 2) - Codeforces - Code 19",
          "code": "cout<<1<<endl;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14959",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #281 (Div. 2) - Codeforces - Code 20",
          "code": "cout<<endl<<1<<endl;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14959",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #281 (Div. 2) - Codeforces - Code 21",
          "code": "int a;\nscanf(\"%c\",&a);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14959",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #281 (Div. 2) - Codeforces - Code 22",
          "code": "int a;\nscanf(\"%c\",&a);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14959",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #281 (Div. 2) Разбор - Codeforces - Code 1",
          "code": "Задача D - скажем так, не очень-то.  Я ее сдал не очень-то задумываясь, исходя из двух соображений. Во-первых - все ее сдают, почему бы и мне не сдать. Во-вторых, явно что-то связанное с четностью n, и тогда остается 2-3 варианта с учетом разбора в условии задачи. Мне еще не повезло, только третий вариант оказался правильным. В общем, полагаю, подобные задачи на угадывание правильного ответа из не очень-то большого количества возможных вариантов далеко не самый лучший жанр на олимпиадах.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14985",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #281 (Div. 2) Разбор - Codeforces - Code 2",
          "code": "wrong answer 1st words differ - expected: '6:8', found: '0:0'",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14985",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #281 (Div. 2) Разбор - Codeforces - Code 3",
          "code": "ll AA, BB;\nAA = BB == -1;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14985",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #281 (Div. 2) Разбор - Codeforces - Code 4",
          "code": "ll AA, BB;\nAA = BB == -1;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14985",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #281 (Div. 2) Разбор - Codeforces - Code 5",
          "code": "5\n6 7 8 9 10\n5\n1 2 3 4 5",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14985",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #281 (Div. 2) Разбор - Codeforces - Code 6",
          "code": "5\n6 7 8 9 10\n5\n1 2 3 4 5",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14985",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #281 (Div. 2) Разбор - Codeforces - Code 7",
          "code": "5\n1 2 3 4 5\n5\n6 7 8 9 10",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14985",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #281 (Div. 2) Разбор - Codeforces - Code 8",
          "code": "5\n1 2 3 4 5\n5\n6 7 8 9 10",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14985",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #281 (Div. 2) Разбор - Codeforces - Code 9",
          "code": "TANC\n XNCOR\n 2\n 15 h 27 r\n 28 h 27 r",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14985",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #281 (Div. 2) Разбор - Codeforces - Code 10",
          "code": "TANC\n XNCOR\n 2\n 15 h 27 r\n 28 h 27 r",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14985",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #281 (Div. 2) Разбор - Codeforces - Code 11",
          "code": "for(j = 0; j < 2; j++)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14985",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #281 (Div. 2) Разбор - Codeforces - Code 12",
          "code": "for(j = 0; j <= 2; j++)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14985",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 200000, \"n\");\n    inf.readEoln();\n    for(int i = 0; i < n; i++) {\n        int ai = inf.readInt(-1000000000, 1000000000, \"ai\");\n        ensuref(ai != 0, \"ai[%d] is zero\", i+1);\n        inf.readEoln();\n    }\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 200000, \"n\");\n    inf.readEoln();\n    for(int i = 0; i < n; i++) {\n        int ai = inf.readInt(-1000000000, 1000000000, \"ai\");\n        ensuref(ai != 0, \"ai[%d] is zero\", i+1);\n        inf.readEoln();\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 200000, \"n\");\n    inf.readEoln();\n    for(int i = 0; i < n; i++) {\n        int ai = inf.readInt(-1000000000, 1000000000, \"ai\");\n        ensuref(ai != 0, \"ai[%d] is zero\", i+1);\n        inf.readEoln();\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare sequences of tokens\");\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string j, p;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n\r\n        ans.readWordTo(j);\r\n        ouf.readWordTo(p);\r\n\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s words differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  compress(j).c_str(), compress(p).c_str());\r\n    }\r\n\r\n    if (ans.seekEof() && ouf.seekEof()) {\r\n        if (n == 1)\r\n            quitf(_ok, \"\\\"%s\\\"\", compress(j).c_str());\r\n        else\r\n            quitf(_ok, \"%d tokens\", n);\r\n    } else {\r\n        if (ans.seekEof())\r\n            quitf(_wa, \"Participant output contains extra tokens\");\r\n        else\r\n            quitf(_wa, \"Unexpected EOF in the participants output\");\r\n    }\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<long long> techniques;\n\n    if (type == \"first_wins_by_points\") {\n        // First wrestler has higher total points\n        long long total1 = 0, total2 = 0;\n        for (int i = 0; i < n; ++i) {\n            if (rnd.next(2)) {\n                // First wrestler's move\n                long long x = rnd.next(1, 1'000'000'000);\n                techniques.push_back(x);\n                total1 += x;\n            } else {\n                // Second wrestler's move\n                long long x = rnd.next(1, 1'000'000'000);\n                techniques.push_back(-x);\n                total2 += x;\n            }\n        }\n        // Ensure first wrestler has more points\n        if (total1 <= total2) {\n            long long diff = total2 - total1 + 1;\n            long long x = min(diff, 1'000'000'000LL);\n            techniques.push_back(x);\n            total1 += x;\n            ++n;\n        }\n    } else if (type == \"second_wins_by_points\") {\n        // Second wrestler has higher total points\n        long long total1 = 0, total2 = 0;\n        for (int i = 0; i < n; ++i) {\n            if (rnd.next(2)) {\n                // First wrestler's move\n                long long x = rnd.next(1, 1'000'000'000);\n                techniques.push_back(x);\n                total1 += x;\n            } else {\n                // Second wrestler's move\n                long long x = rnd.next(1, 1'000'000'000);\n                techniques.push_back(-x);\n                total2 += x;\n            }\n        }\n        // Ensure second wrestler has more points\n        if (total2 <= total1) {\n            long long diff = total1 - total2 + 1;\n            long long x = min(diff, 1'000'000'000LL);\n            techniques.push_back(-x);\n            total2 += x;\n            ++n;\n        }\n    } else if (type == \"first_wins_by_sequence\") {\n        // Total points equal, first wrestler's sequence is lex greater\n        vector<long long> seq1, seq2;\n        long long total1 = 0, total2 = 0;\n        int m = n / 2;\n        for (int i = 0; i < m; ++i) {\n            long long x = rnd.next(1, 1'000'000'000);\n            techniques.push_back(x);\n            seq1.push_back(x);\n            total1 += x;\n\n            techniques.push_back(-x);\n            seq2.push_back(x);\n            total2 += x;\n        }\n        if (n % 2 != 0) {\n            // First wrestler gets an extra move with higher point\n            long long x = rnd.next(1'000'000'001LL, 1'000'000'009LL);\n            techniques.push_back(x);\n            seq1.push_back(x);\n            total1 += x;\n        } else {\n            // Adjust sequences to make first's sequence lex greater\n            long long x = rnd.next(1'000'000'001LL, 1'000'000'009LL);\n            techniques.push_back(x);\n            seq1.push_back(x);\n            total1 += x;\n\n            techniques.push_back(-x);\n            seq2.push_back(x);\n            total2 += x;\n        }\n        // Ensure total points are equal\n        if (total1 != total2) {\n            long long diff = total1 - total2;\n            techniques.push_back(-diff);\n            total2 += diff;\n            ++n;\n        }\n    } else if (type == \"second_wins_by_sequence\") {\n        // Total points equal, second wrestler's sequence is lex greater\n        vector<long long> seq1, seq2;\n        long long total1 = 0, total2 = 0;\n        int m = n / 2;\n        for (int i = 0; i < m; ++i) {\n            long long x = rnd.next(1, 1'000'000'000);\n            techniques.push_back(x);\n            seq1.push_back(x);\n            total1 += x;\n\n            techniques.push_back(-x);\n            seq2.push_back(x);\n            total2 += x;\n        }\n        if (n % 2 != 0) {\n            // Second wrestler gets an extra move with higher point\n            long long x = rnd.next(1'000'000'001LL, 1'000'000'009LL);\n            techniques.push_back(-x);\n            seq2.push_back(x);\n            total2 += x;\n        } else {\n            // Adjust sequences to make second's sequence lex greater\n            long long x = rnd.next(1'000'000'001LL, 1'000'000'009LL);\n            techniques.push_back(-x);\n            seq2.push_back(x);\n            total2 += x;\n\n            techniques.push_back(x);\n            seq1.push_back(x);\n            total1 += x;\n        }\n        // Ensure total points are equal\n        if (total1 != total2) {\n            long long diff = total2 - total1;\n            techniques.push_back(diff);\n            total1 += diff;\n            ++n;\n        }\n    } else if (type == \"first_wins_by_last_move\") {\n        // Total points and sequences equal, first wrestler moves last\n        long long total1 = 0, total2 = 0;\n        for (int i = 0; i < n - 1; i += 2) {\n            long long x = rnd.next(1, 1'000'000'000);\n            techniques.push_back(x);\n            total1 += x;\n\n            techniques.push_back(-x);\n            total2 += x;\n        }\n        if (n % 2 != 0) {\n            long long x = rnd.next(1, 1'000'000'000);\n            techniques.push_back(x);\n            total1 += x;\n        }\n        // Ensure total points and sequences are equal\n        if (total1 != total2) {\n            long long diff = total1 - total2;\n            techniques.push_back(-diff);\n            total2 += diff;\n            ++n;\n        }\n    } else if (type == \"second_wins_by_last_move\") {\n        // Total points and sequences equal, second wrestler moves last\n        long long total1 = 0, total2 = 0;\n        for (int i = 0; i < n - 1; i += 2) {\n            long long x = rnd.next(1, 1'000'000'000);\n            techniques.push_back(x);\n            total1 += x;\n\n            techniques.push_back(-x);\n            total2 += x;\n        }\n        if (n % 2 != 0) {\n            long long x = rnd.next(1, 1'000'000'000);\n            techniques.push_back(-x);\n            total2 += x;\n        }\n        // Ensure total points and sequences are equal\n        if (total1 != total2) {\n            long long diff = total2 - total1;\n            techniques.push_back(diff);\n            total1 += diff;\n            ++n;\n        }\n    } else if (type == \"alternating\") {\n        // Techniques alternate between wrestlers\n        for (int i = 0; i < n; ++i) {\n            long long x = rnd.next(1, 1'000'000'000);\n            if (i % 2 == 0) {\n                techniques.push_back(x);\n            } else {\n                techniques.push_back(-x);\n            }\n        }\n    } else if (type == \"max_points\") {\n        // Techniques have maximum possible points\n        for (int i = 0; i < n; ++i) {\n            long long x = 1'000'000'000;\n            if (rnd.next(2)) {\n                techniques.push_back(x);\n            } else {\n                techniques.push_back(-x);\n            }\n        }\n    } else {\n        // Random test case\n        for (int i = 0; i < n; ++i) {\n            long long x = rnd.next(1, 1'000'000'000);\n            if (rnd.next(2)) {\n                techniques.push_back(x);\n            } else {\n                techniques.push_back(-x);\n            }\n        }\n    }\n\n    // Output n and techniques\n    printf(\"%d\\n\", n);\n    for (long long ai : techniques) {\n        printf(\"%lld\\n\", ai);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<long long> techniques;\n\n    if (type == \"first_wins_by_points\") {\n        // First wrestler has higher total points\n        long long total1 = 0, total2 = 0;\n        for (int i = 0; i < n; ++i) {\n            if (rnd.next(2)) {\n                // First wrestler's move\n                long long x = rnd.next(1, 1'000'000'000);\n                techniques.push_back(x);\n                total1 += x;\n            } else {\n                // Second wrestler's move\n                long long x = rnd.next(1, 1'000'000'000);\n                techniques.push_back(-x);\n                total2 += x;\n            }\n        }\n        // Ensure first wrestler has more points\n        if (total1 <= total2) {\n            long long diff = total2 - total1 + 1;\n            long long x = min(diff, 1'000'000'000LL);\n            techniques.push_back(x);\n            total1 += x;\n            ++n;\n        }\n    } else if (type == \"second_wins_by_points\") {\n        // Second wrestler has higher total points\n        long long total1 = 0, total2 = 0;\n        for (int i = 0; i < n; ++i) {\n            if (rnd.next(2)) {\n                // First wrestler's move\n                long long x = rnd.next(1, 1'000'000'000);\n                techniques.push_back(x);\n                total1 += x;\n            } else {\n                // Second wrestler's move\n                long long x = rnd.next(1, 1'000'000'000);\n                techniques.push_back(-x);\n                total2 += x;\n            }\n        }\n        // Ensure second wrestler has more points\n        if (total2 <= total1) {\n            long long diff = total1 - total2 + 1;\n            long long x = min(diff, 1'000'000'000LL);\n            techniques.push_back(-x);\n            total2 += x;\n            ++n;\n        }\n    } else if (type == \"first_wins_by_sequence\") {\n        // Total points equal, first wrestler's sequence is lex greater\n        vector<long long> seq1, seq2;\n        long long total1 = 0, total2 = 0;\n        int m = n / 2;\n        for (int i = 0; i < m; ++i) {\n            long long x = rnd.next(1, 1'000'000'000);\n            techniques.push_back(x);\n            seq1.push_back(x);\n            total1 += x;\n\n            techniques.push_back(-x);\n            seq2.push_back(x);\n            total2 += x;\n        }\n        if (n % 2 != 0) {\n            // First wrestler gets an extra move with higher point\n            long long x = rnd.next(1'000'000'001LL, 1'000'000'009LL);\n            techniques.push_back(x);\n            seq1.push_back(x);\n            total1 += x;\n        } else {\n            // Adjust sequences to make first's sequence lex greater\n            long long x = rnd.next(1'000'000'001LL, 1'000'000'009LL);\n            techniques.push_back(x);\n            seq1.push_back(x);\n            total1 += x;\n\n            techniques.push_back(-x);\n            seq2.push_back(x);\n            total2 += x;\n        }\n        // Ensure total points are equal\n        if (total1 != total2) {\n            long long diff = total1 - total2;\n            techniques.push_back(-diff);\n            total2 += diff;\n            ++n;\n        }\n    } else if (type == \"second_wins_by_sequence\") {\n        // Total points equal, second wrestler's sequence is lex greater\n        vector<long long> seq1, seq2;\n        long long total1 = 0, total2 = 0;\n        int m = n / 2;\n        for (int i = 0; i < m; ++i) {\n            long long x = rnd.next(1, 1'000'000'000);\n            techniques.push_back(x);\n            seq1.push_back(x);\n            total1 += x;\n\n            techniques.push_back(-x);\n            seq2.push_back(x);\n            total2 += x;\n        }\n        if (n % 2 != 0) {\n            // Second wrestler gets an extra move with higher point\n            long long x = rnd.next(1'000'000'001LL, 1'000'000'009LL);\n            techniques.push_back(-x);\n            seq2.push_back(x);\n            total2 += x;\n        } else {\n            // Adjust sequences to make second's sequence lex greater\n            long long x = rnd.next(1'000'000'001LL, 1'000'000'009LL);\n            techniques.push_back(-x);\n            seq2.push_back(x);\n            total2 += x;\n\n            techniques.push_back(x);\n            seq1.push_back(x);\n            total1 += x;\n        }\n        // Ensure total points are equal\n        if (total1 != total2) {\n            long long diff = total2 - total1;\n            techniques.push_back(diff);\n            total1 += diff;\n            ++n;\n        }\n    } else if (type == \"first_wins_by_last_move\") {\n        // Total points and sequences equal, first wrestler moves last\n        long long total1 = 0, total2 = 0;\n        for (int i = 0; i < n - 1; i += 2) {\n            long long x = rnd.next(1, 1'000'000'000);\n            techniques.push_back(x);\n            total1 += x;\n\n            techniques.push_back(-x);\n            total2 += x;\n        }\n        if (n % 2 != 0) {\n            long long x = rnd.next(1, 1'000'000'000);\n            techniques.push_back(x);\n            total1 += x;\n        }\n        // Ensure total points and sequences are equal\n        if (total1 != total2) {\n            long long diff = total1 - total2;\n            techniques.push_back(-diff);\n            total2 += diff;\n            ++n;\n        }\n    } else if (type == \"second_wins_by_last_move\") {\n        // Total points and sequences equal, second wrestler moves last\n        long long total1 = 0, total2 = 0;\n        for (int i = 0; i < n - 1; i += 2) {\n            long long x = rnd.next(1, 1'000'000'000);\n            techniques.push_back(x);\n            total1 += x;\n\n            techniques.push_back(-x);\n            total2 += x;\n        }\n        if (n % 2 != 0) {\n            long long x = rnd.next(1, 1'000'000'000);\n            techniques.push_back(-x);\n            total2 += x;\n        }\n        // Ensure total points and sequences are equal\n        if (total1 != total2) {\n            long long diff = total2 - total1;\n            techniques.push_back(diff);\n            total1 += diff;\n            ++n;\n        }\n    } else if (type == \"alternating\") {\n        // Techniques alternate between wrestlers\n        for (int i = 0; i < n; ++i) {\n            long long x = rnd.next(1, 1'000'000'000);\n            if (i % 2 == 0) {\n                techniques.push_back(x);\n            } else {\n                techniques.push_back(-x);\n            }\n        }\n    } else if (type == \"max_points\") {\n        // Techniques have maximum possible points\n        for (int i = 0; i < n; ++i) {\n            long long x = 1'000'000'000;\n            if (rnd.next(2)) {\n                techniques.push_back(x);\n            } else {\n                techniques.push_back(-x);\n            }\n        }\n    } else {\n        // Random test case\n        for (int i = 0; i < n; ++i) {\n            long long x = rnd.next(1, 1'000'000'000);\n            if (rnd.next(2)) {\n                techniques.push_back(x);\n            } else {\n                techniques.push_back(-x);\n            }\n        }\n    }\n\n    // Output n and techniques\n    printf(\"%d\\n\", n);\n    for (long long ai : techniques) {\n        printf(\"%lld\\n\", ai);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Random test cases\n./gen -n 10 -type random\n./gen -n 100 -type random\n./gen -n 1000 -type random\n./gen -n 100000 -type random\n./gen -n 200000 -type random\n\n# First wrestler wins by higher total points\n./gen -n 10 -type first_wins_by_points\n./gen -n 100 -type first_wins_by_points\n./gen -n 1000 -type first_wins_by_points\n./gen -n 100000 -type first_wins_by_points\n./gen -n 200000 -type first_wins_by_points\n\n# Second wrestler wins by higher total points\n./gen -n 10 -type second_wins_by_points\n./gen -n 100 -type second_wins_by_points\n./gen -n 1000 -type second_wins_by_points\n./gen -n 100000 -type second_wins_by_points\n./gen -n 200000 -type second_wins_by_points\n\n# First wrestler wins by lexicographically greater sequence\n./gen -n 10 -type first_wins_by_sequence\n./gen -n 100 -type first_wins_by_sequence\n./gen -n 1000 -type first_wins_by_sequence\n./gen -n 100000 -type first_wins_by_sequence\n./gen -n 200000 -type first_wins_by_sequence\n\n# Second wrestler wins by lexicographically greater sequence\n./gen -n 10 -type second_wins_by_sequence\n./gen -n 100 -type second_wins_by_sequence\n./gen -n 1000 -type second_wins_by_sequence\n./gen -n 100000 -type second_wins_by_sequence\n./gen -n 200000 -type second_wins_by_sequence\n\n# First wrestler wins by performing the last technique\n./gen -n 1 -type first_wins_by_last_move\n./gen -n 10 -type first_wins_by_last_move\n./gen -n 100 -type first_wins_by_last_move\n./gen -n 99999 -type first_wins_by_last_move\n./gen -n 199999 -type first_wins_by_last_move\n\n# Second wrestler wins by performing the last technique\n./gen -n 1 -type second_wins_by_last_move\n./gen -n 10 -type second_wins_by_last_move\n./gen -n 100 -type second_wins_by_last_move\n./gen -n 100000 -type second_wins_by_last_move\n./gen -n 200000 -type second_wins_by_last_move\n\n# Alternating techniques\n./gen -n 10 -type alternating\n./gen -n 100 -type alternating\n./gen -n 1000 -type alternating\n./gen -n 100000 -type alternating\n./gen -n 200000 -type alternating\n\n# Max points\n./gen -n 2 -type max_points\n./gen -n 10 -type max_points\n./gen -n 100 -type max_points\n./gen -n 100000 -type max_points\n\n# Edge cases: n = 1\n./gen -n 1 -type random\n./gen -n 1 -type first_wins_by_points\n./gen -n 1 -type second_wins_by_points\n./gen -n 1 -type first_wins_by_sequence\n./gen -n 1 -type second_wins_by_sequence\n./gen -n 1 -type first_wins_by_last_move\n./gen -n 1 -type second_wins_by_last_move\n\n# Maximum size test case\n./gen -n 200000 -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:38:33.667057",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "493/C",
      "title": "C. Vasya and Basketball",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains integer n (1 ≤ n ≤ 2·105) — the number of throws of the first team. Then follow n integer numbers — the distances of throws ai (1 ≤ ai ≤ 2·109). Then follows number m (1 ≤ m ≤ 2·105) — the number of the throws of the second team. Then follow m integer numbers — the distances of throws of bi (1 ≤ bi ≤ 2·109).",
      "output_spec": "OutputPrint two numbers in the format a:b — the score that is possible considering the problem conditions where the result of subtraction a - b is maximum. If there are several such scores, find the one in which number a is maximum.",
      "sample_tests": "ExamplesInputCopy31 2 325 6OutputCopy9:6InputCopy56 7 8 9 1051 2 3 4 5OutputCopy15:10",
      "description": "C. Vasya and Basketball\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains integer n (1 ≤ n ≤ 2·105) — the number of throws of the first team. Then follow n integer numbers — the distances of throws ai (1 ≤ ai ≤ 2·109). Then follows number m (1 ≤ m ≤ 2·105) — the number of the throws of the second team. Then follow m integer numbers — the distances of throws of bi (1 ≤ bi ≤ 2·109).\n\nOutputPrint two numbers in the format a:b — the score that is possible considering the problem conditions where the result of subtraction a - b is maximum. If there are several such scores, find the one in which number a is maximum.\n\nInputCopy31 2 325 6OutputCopy9:6InputCopy56 7 8 9 1051 2 3 4 5OutputCopy15:10\n\nInputCopy31 2 325 6\n\nOutputCopy9:6\n\nInputCopy56 7 8 9 1051 2 3 4 5\n\nOutputCopy15:10",
      "solutions": [
        {
          "title": "Codeforces Round #281 (Div. 2) - Codeforces",
          "content": "Hi!On 3rd December, 18:00 at Moscow will be Codeforces Round #281 (Div. 2). As usual Div. 1 contestants can take part out of contest.This is my first Codeforces Round and I hope that this isn't the last one :)Thanks to Maksim Akhmedov (Zlobober) for the help in making contest and MikeMirzayanov for Codeforces and Polygon platforms.UPD1: The scoring will be dynamic.UPD2: Contest is over. Thank to all participants. I hope you liked my contest.UPD3: EditorialUPD4 Top-5 contestants, congrats ShiXingxing15 ganar27 Tim_LinYd coolwyj gaoyihan Also congrats to gaoyihan, who solved problem E.UPD5 Hack stats by kostka.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/14959",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 616
        },
        {
          "title": "Codeforces Round #281 (Div. 2) Editorial - Codeforces",
          "content": "493A - Vasya and FootballWe need 2 arrays — for the first and second team, in which we must save \"status\" of the player — is he \"clear\", yellow carded or sent off. Then while inputing we must output the players name if he wasn't sent off, and after the event he must be sent off.493B - Vasya and WrestlingWe need to vectors in which we will save points of first and second wrestlers, and two int-s, where we will save who made the last technique and what is the sum of all the numbers in the input. If the sum is not zero, we know the answer. Else we pass by the vectors, checking are there respective elements which are not equal. If yes — then we know the answer, else everything depends on who made the last technique.493C - Vasya and BasketballWe need an array of pairs — in each pair we save the distance and the number of team. Then we sort the array. Then we assume that all the throws bring 3 points. Then we pass by the array and one of our numbers we decrease on 1 (which one — it depends on the second element of array). Then we compare it with our answer. In the end — we print our answer. 493D - Vasya and ChessIf n is odd, then black can win white doing all the moves symetric by the central line. Else white can win putting his queen on (1,2) (which is the lexicographicly smallest place) and play symetricly — never using the first row.493E - Vasya and PolynomialLet's discuss 2 case. 1) t!=1 и 2) t=1.1) If our function is not constant (n>=1) than a is greater all the coefficients, so the only polynom can be the number b — in the a-ary counting system. We must only check that one and constant function.2)if t=1 must be careful:in case 1 1 1: the answer is inf,in case 1 1 n: the answer is 0in case 1 а а^x(x-integer, x>0): the answer is 1in the other cases P(1) is greater than other coefficients.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/14985",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 493\\s*C"
          },
          "content_length": 1817
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #281 (Div. 2) - Codeforces - Code 1",
          "code": "1! + 3! + 4! + 5! + ... + 281!",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14959",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #281 (Div. 2) - Codeforces - Code 2",
          "code": "281 = 9*8 + 7*6 + 5*4 + 3*2 + 1 + 2*3 + 4*5 + 6*7 + 8*9",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14959",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #281 (Div. 2) - Codeforces - Code 3",
          "code": "281 = 9*8 + 7*6 + 5*4 + 3*2 + 1 + 2*3 + 4*5 + 6*7 + 8*9",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14959",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #281 (Div. 2) - Codeforces - Code 4",
          "code": "3\n1000000000\n1000000000\n1000000000",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14959",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #281 (Div. 2) - Codeforces - Code 5",
          "code": "3\n1000000000\n1000000000\n1000000000",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14959",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #281 (Div. 2) - Codeforces - Code 6",
          "code": "4\n1\n5\n-2\n-4",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14959",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #281 (Div. 2) - Codeforces - Code 7",
          "code": "4\n1\n5\n-2\n-4",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14959",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #281 (Div. 2) - Codeforces - Code 8",
          "code": "4\n11\n1\n-9\n-3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14959",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #281 (Div. 2) - Codeforces - Code 9",
          "code": "4\n11\n1\n-9\n-3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14959",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #281 (Div. 2) - Codeforces - Code 10",
          "code": "11 > 9 => true",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14959",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #281 (Div. 2) - Codeforces - Code 11",
          "code": "111 gt 93 => false",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14959",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #281 (Div. 2) - Codeforces - Code 12",
          "code": "if(n%2) cout<<\"black\\n\";  else cout<<\"white\\n1 2\\n\";",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14959",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #281 (Div. 2) - Codeforces - Code 13",
          "code": "if ( (n & 1) == 1 ) {\n        System.out.println(\"black\");\n    } else {\n        System.out.println(\"white\\n1 2\");\n    }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14959",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #281 (Div. 2) - Codeforces - Code 14",
          "code": "if ( (n & 1) == 1 ) {\n        System.out.println(\"black\");\n    } else {\n        System.out.println(\"white\\n1 2\");\n    }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14959",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #281 (Div. 2) - Codeforces - Code 15",
          "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\nusing namespace std;\n#define ll long long \nll dp[6000];\nint main()\n{\n\tcout<<200000<<endl;\n\tfor(int i=0;i<200000;i++)\n\t\tcout<<1999999999<<\" \";\n\tcout<<1<<endl;\n\tcout<<2000000000;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/14959",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #281 (Div. 2) - Codeforces - Code 16",
          "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\nusing namespace std;\n#define ll long long \nll dp[6000];\nint main()\n{\n\tcout<<200000<<endl;\n\tfor(int i=0;i<200000;i++)\n\t\tcout<<1999999999<<\" \";\n\tcout<<1<<endl;\n\tcout<<2000000000;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/14959",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #281 (Div. 2) - Codeforces - Code 17",
          "code": "cout<<1<<endl;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14959",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #281 (Div. 2) - Codeforces - Code 18",
          "code": "cout<<endl<<1<<endl;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14959",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #281 (Div. 2) - Codeforces - Code 19",
          "code": "int a;\nscanf(\"%c\",&a);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14959",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #281 (Div. 2) - Codeforces - Code 20",
          "code": "int a;\nscanf(\"%c\",&a);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14959",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #281 (Div. 2) Editorial - Codeforces - Code 1",
          "code": "wrong answer 1st words differ - expected: '6:8', found: '0:0'",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14985",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #281 (Div. 2) Editorial - Codeforces - Code 2",
          "code": "ll AA, BB;\nAA = BB == -1;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14985",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #281 (Div. 2) Editorial - Codeforces - Code 3",
          "code": "ll AA, BB;\nAA = BB == -1;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14985",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #281 (Div. 2) Editorial - Codeforces - Code 4",
          "code": "5\n6 7 8 9 10\n5\n1 2 3 4 5",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14985",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #281 (Div. 2) Editorial - Codeforces - Code 5",
          "code": "5\n6 7 8 9 10\n5\n1 2 3 4 5",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14985",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #281 (Div. 2) Editorial - Codeforces - Code 6",
          "code": "5\n1 2 3 4 5\n5\n6 7 8 9 10",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14985",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #281 (Div. 2) Editorial - Codeforces - Code 7",
          "code": "5\n1 2 3 4 5\n5\n6 7 8 9 10",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14985",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #281 (Div. 2) Editorial - Codeforces - Code 8",
          "code": "TANC\n XNCOR\n 2\n 15 h 27 r\n 28 h 27 r",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14985",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #281 (Div. 2) Editorial - Codeforces - Code 9",
          "code": "TANC\n XNCOR\n 2\n 15 h 27 r\n 28 h 27 r",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14985",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #281 (Div. 2) Editorial - Codeforces - Code 10",
          "code": "for(j = 0; j < 2; j++)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14985",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #281 (Div. 2) Editorial - Codeforces - Code 11",
          "code": "for(j = 0; j <= 2; j++)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14985",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 200000, \"n\"); \n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, 1, 2000000000, \"ai\");\n    inf.readEoln();\n\n    int m = inf.readInt(1, 200000, \"m\");\n    inf.readEoln();\n\n    vector<int> b = inf.readInts(m, 1, 2000000000, \"bi\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 200000, \"n\"); \n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, 1, 2000000000, \"ai\");\n    inf.readEoln();\n\n    int m = inf.readInt(1, 200000, \"m\");\n    inf.readEoln();\n\n    vector<int> b = inf.readInts(m, 1, 2000000000, \"bi\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 200000, \"n\"); \n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, 1, 2000000000, \"ai\");\n    inf.readEoln();\n\n    int m = inf.readInt(1, 200000, \"m\");\n    inf.readEoln();\n\n    vector<int> b = inf.readInts(m, 1, 2000000000, \"bi\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n#include <string>\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare files as sequence of lines\");\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    std::string strAnswer;\r\n\r\n    int n = 0;\r\n    while (!ans.eof()) {\r\n        std::string j = ans.readString();\r\n\r\n        if (j.empty() && ans.eof())\r\n            break;\r\n\r\n        strAnswer = j;\r\n        std::string p = ouf.readString();\r\n\r\n        n++;\r\n\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s lines differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  compress(j).c_str(), compress(p).c_str());\r\n    }\r\n\r\n    if (n == 1)\r\n        quitf(_ok, \"single line: '%s'\", compress(strAnswer).c_str());\r\n\r\n    quitf(_ok, \"%d lines\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\", n); // default m = n if not specified\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> a(n);\n    vector<int> b(m);\n\n    if (type == \"random\") {\n        // Generate random distances between 1 and 2e9\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, 2000000000);\n        }\n        for (int i = 0; i < m; ++i) {\n            b[i] = rnd.next(1, 2000000000);\n        }\n    }\n    else if (type == \"minimum\") {\n        // All distances are 1\n        for (int i = 0; i < n; ++i) {\n            a[i] = 1;\n        }\n        for (int i = 0; i < m; ++i) {\n            b[i] = 1;\n        }\n    }\n    else if (type == \"maximum\") {\n        // All distances are 2e9\n        for (int i = 0; i < n; ++i) {\n            a[i] = 2000000000;\n        }\n        for (int i = 0; i < m; ++i) {\n            b[i] = 2000000000;\n        }\n    }\n    else if (type == \"extremed\") {\n        // Distances designed to make max difference at extreme d values\n        string extremed_type = opt<string>(\"subtype\", \"d0\");\n        if (extremed_type == \"d0\") {\n            // Max difference at d = 0\n            // First team: distances > 0, get 3 points at d = 0\n            for (int i = 0; i < n; ++i) {\n                a[i] = rnd.next(2, 2000000000); // Distances > 1\n            }\n            // Second team: distances = 1, get 2 points at d = 0\n            for (int i = 0; i < m; ++i) {\n                b[i] = 1;\n            }\n        }\n        else if (extremed_type == \"dmax\") {\n            // Max difference at d = 2e9\n            // First team: distances = 1, get 2 points at any d ≥1\n            for (int i = 0; i < n; ++i) {\n                a[i] = 1;\n            }\n            // Second team: distances = 2e9, get 2 points at d ≥2e9\n            for (int i = 0; i < m; ++i) {\n                b[i] = 2000000000;\n            }\n        }\n        else {\n            // Default to d=0\n            for (int i = 0; i < n; ++i) {\n                a[i] = rnd.next(2, 2000000000);\n            }\n            for (int i = 0; i < m; ++i) {\n                b[i] = 1;\n            }\n        }\n    }\n    else if (type == \"opposed\") {\n        // All first team distances less than D, all second team distances greater than D\n        int D = opt<int>(\"D\", 1000000000); // default D = 1e9\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, D - 1);\n        }\n        for (int i = 0; i < m; ++i) {\n            b[i] = rnd.next(D + 1, 2000000000);\n        }\n    }\n    else if (type == \"sequence\") {\n        // Distances are sequential, starting from 1\n        for (int i = 0; i < n; ++i) {\n            a[i] = 1 + i % 2000000000; // Ensure distances do not exceed 2e9\n        }\n        for (int i = 0; i < m; ++i) {\n            b[i] = 1 + i % 2000000000;\n        }\n    }\n    else if (type == \"constant\") {\n        // All distances are the same\n        int value = opt<int>(\"value\", 1); // default value 1\n        value = max(1, min(value, 2000000000)); // Ensure within bounds\n        for (int i = 0; i < n; ++i) {\n            a[i] = value;\n        }\n        for (int i = 0; i < m; ++i) {\n            b[i] = value;\n        }\n    }\n    else if (type == \"equald\") {\n        // Distances designed such that multiple d lead to the same maximum difference\n        int perTypeA = n / 2;\n        for (int i = 0; i < n; ++i) {\n            if (i < perTypeA)\n                a[i] = 1; // Distances ≤ d\n            else\n                a[i] = 2000000000; // Distances > d\n        }\n        int perTypeB = m / 2;\n        for (int i = 0; i < m; ++i) {\n            if (i < perTypeB)\n                b[i] = 1; // Distances ≤ d\n            else\n                b[i] = 2000000000; // Distances > d\n        }\n    }\n    else {\n        // Default random\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, 2000000000);\n        }\n        for (int i = 0; i < m; ++i) {\n            b[i] = rnd.next(1, 2000000000);\n        }\n    }\n\n    // Output\n    printf(\"%d\\n\", n);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d%c\", a[i], i + 1 < n ? ' ' : '\\n');\n    }\n    printf(\"%d\\n\", m);\n    for (int i = 0; i < m; ++i) {\n        printf(\"%d%c\", b[i], i + 1 < m ? ' ' : '\\n');\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\", n); // default m = n if not specified\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> a(n);\n    vector<int> b(m);\n\n    if (type == \"random\") {\n        // Generate random distances between 1 and 2e9\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, 2000000000);\n        }\n        for (int i = 0; i < m; ++i) {\n            b[i] = rnd.next(1, 2000000000);\n        }\n    }\n    else if (type == \"minimum\") {\n        // All distances are 1\n        for (int i = 0; i < n; ++i) {\n            a[i] = 1;\n        }\n        for (int i = 0; i < m; ++i) {\n            b[i] = 1;\n        }\n    }\n    else if (type == \"maximum\") {\n        // All distances are 2e9\n        for (int i = 0; i < n; ++i) {\n            a[i] = 2000000000;\n        }\n        for (int i = 0; i < m; ++i) {\n            b[i] = 2000000000;\n        }\n    }\n    else if (type == \"extremed\") {\n        // Distances designed to make max difference at extreme d values\n        string extremed_type = opt<string>(\"subtype\", \"d0\");\n        if (extremed_type == \"d0\") {\n            // Max difference at d = 0\n            // First team: distances > 0, get 3 points at d = 0\n            for (int i = 0; i < n; ++i) {\n                a[i] = rnd.next(2, 2000000000); // Distances > 1\n            }\n            // Second team: distances = 1, get 2 points at d = 0\n            for (int i = 0; i < m; ++i) {\n                b[i] = 1;\n            }\n        }\n        else if (extremed_type == \"dmax\") {\n            // Max difference at d = 2e9\n            // First team: distances = 1, get 2 points at any d ≥1\n            for (int i = 0; i < n; ++i) {\n                a[i] = 1;\n            }\n            // Second team: distances = 2e9, get 2 points at d ≥2e9\n            for (int i = 0; i < m; ++i) {\n                b[i] = 2000000000;\n            }\n        }\n        else {\n            // Default to d=0\n            for (int i = 0; i < n; ++i) {\n                a[i] = rnd.next(2, 2000000000);\n            }\n            for (int i = 0; i < m; ++i) {\n                b[i] = 1;\n            }\n        }\n    }\n    else if (type == \"opposed\") {\n        // All first team distances less than D, all second team distances greater than D\n        int D = opt<int>(\"D\", 1000000000); // default D = 1e9\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, D - 1);\n        }\n        for (int i = 0; i < m; ++i) {\n            b[i] = rnd.next(D + 1, 2000000000);\n        }\n    }\n    else if (type == \"sequence\") {\n        // Distances are sequential, starting from 1\n        for (int i = 0; i < n; ++i) {\n            a[i] = 1 + i % 2000000000; // Ensure distances do not exceed 2e9\n        }\n        for (int i = 0; i < m; ++i) {\n            b[i] = 1 + i % 2000000000;\n        }\n    }\n    else if (type == \"constant\") {\n        // All distances are the same\n        int value = opt<int>(\"value\", 1); // default value 1\n        value = max(1, min(value, 2000000000)); // Ensure within bounds\n        for (int i = 0; i < n; ++i) {\n            a[i] = value;\n        }\n        for (int i = 0; i < m; ++i) {\n            b[i] = value;\n        }\n    }\n    else if (type == \"equald\") {\n        // Distances designed such that multiple d lead to the same maximum difference\n        int perTypeA = n / 2;\n        for (int i = 0; i < n; ++i) {\n            if (i < perTypeA)\n                a[i] = 1; // Distances ≤ d\n            else\n                a[i] = 2000000000; // Distances > d\n        }\n        int perTypeB = m / 2;\n        for (int i = 0; i < m; ++i) {\n            if (i < perTypeB)\n                b[i] = 1; // Distances ≤ d\n            else\n                b[i] = 2000000000; // Distances > d\n        }\n    }\n    else {\n        // Default random\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, 2000000000);\n        }\n        for (int i = 0; i < m; ++i) {\n            b[i] = rnd.next(1, 2000000000);\n        }\n    }\n\n    // Output\n    printf(\"%d\\n\", n);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d%c\", a[i], i + 1 < n ? ' ' : '\\n');\n    }\n    printf(\"%d\\n\", m);\n    for (int i = 0; i < m; ++i) {\n        printf(\"%d%c\", b[i], i + 1 < m ? ' ' : '\\n');\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 5 -m 5 -type random\n./gen -n 10 -m 10 -type random\n\n./gen -n 1000 -m 1000 -type random\n./gen -n 200000 -m 200000 -type random\n\n./gen -n 5 -m 5 -type minimum\n./gen -n 200000 -m 200000 -type minimum\n\n./gen -n 200000 -m 200000 -type maximum\n\n./gen -n 1000 -m 1000 -type extremed -subtype d0\n./gen -n 1000 -m 1000 -type extremed -subtype dmax\n./gen -n 200000 -m 200000 -type extremed -subtype d0\n./gen -n 200000 -m 200000 -type extremed -subtype dmax\n\n./gen -n 1000 -m 1000 -type opposed -D 1000000000\n./gen -n 200000 -m 200000 -type opposed -D 1000000000\n./gen -n 50000 -m 150000 -type opposed -D 1500000000\n\n./gen -n 10000 -m 10000 -type sequence\n\n./gen -n 1000 -m 1000 -type constant -value 1\n./gen -n 1000 -m 1000 -type constant -value 2000000000\n./gen -n 200000 -m 200000 -type constant -value 123456789\n\n./gen -n 1000 -m 1000 -type equald\n./gen -n 200000 -m 200000 -type equald\n\n./gen -n 1 -m 1 -type random\n./gen -n 2 -m 2 -type random\n\n./gen -n 200000 -m 1 -type random\n./gen -n 1 -m 200000 -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:38:35.473871",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "493/D",
      "title": "D. Vasya and Chess",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe input contains a single number n (2 ≤ n ≤ 109) — the size of the board.",
      "output_spec": "OutputOn the first line print the answer to problem — string \"white\" or string \"black\", depending on who wins if the both players play optimally. If the answer is \"white\", then you should also print two integers r and c representing the cell (r, c), where the first player should make his first move to win. If there are multiple such cells, print the one with the minimum r. If there are still multiple squares, print the one with the minimum c.",
      "sample_tests": "ExamplesInputCopy2OutputCopywhite1 2InputCopy3OutputCopyblack",
      "description": "D. Vasya and Chess\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe input contains a single number n (2 ≤ n ≤ 109) — the size of the board.\n\nOutputOn the first line print the answer to problem — string \"white\" or string \"black\", depending on who wins if the both players play optimally. If the answer is \"white\", then you should also print two integers r and c representing the cell (r, c), where the first player should make his first move to win. If there are multiple such cells, print the one with the minimum r. If there are still multiple squares, print the one with the minimum c.\n\nInputCopy2OutputCopywhite1 2InputCopy3OutputCopyblack\n\nOutputCopywhite1 2\n\nOutputCopyblack\n\nNoteIn the first sample test the white queen can capture the black queen at the first move, so the white player wins.In the second test from the statement if the white queen captures the green pawn located on the central vertical line, then it will be captured by the black queen during the next move. So the only move for the white player is to capture the green pawn located at (2, 1). Similarly, the black queen doesn't have any other options but to capture the green pawn located at (2, 3), otherwise if it goes to the middle vertical line, it will be captured by the white queen.During the next move the same thing happens — neither the white, nor the black queen has other options rather than to capture green pawns situated above them. Thus, the white queen ends up on square (3, 1), and the black queen ends up on square (3, 3). In this situation the white queen has to capture any of the green pawns located on the middle vertical line, after that it will be captured by the black queen. Thus, the player who plays for the black queen wins.",
      "solutions": [
        {
          "title": "Codeforces Round #281 (Div. 2) - Codeforces",
          "content": "Hi!On 3rd December, 18:00 at Moscow will be Codeforces Round #281 (Div. 2). As usual Div. 1 contestants can take part out of contest.This is my first Codeforces Round and I hope that this isn't the last one :)Thanks to Maksim Akhmedov (Zlobober) for the help in making contest and MikeMirzayanov for Codeforces and Polygon platforms.UPD1: The scoring will be dynamic.UPD2: Contest is over. Thank to all participants. I hope you liked my contest.UPD3: EditorialUPD4 Top-5 contestants, congrats ShiXingxing15 ganar27 Tim_LinYd coolwyj gaoyihan Also congrats to gaoyihan, who solved problem E.UPD5 Hack stats by kostka.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/14959",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 616
        },
        {
          "title": "Codeforces Round #281 (Div. 2) Editorial - Codeforces",
          "content": "493A - Vasya and FootballWe need 2 arrays — for the first and second team, in which we must save \"status\" of the player — is he \"clear\", yellow carded or sent off. Then while inputing we must output the players name if he wasn't sent off, and after the event he must be sent off.493B - Vasya and WrestlingWe need to vectors in which we will save points of first and second wrestlers, and two int-s, where we will save who made the last technique and what is the sum of all the numbers in the input. If the sum is not zero, we know the answer. Else we pass by the vectors, checking are there respective elements which are not equal. If yes — then we know the answer, else everything depends on who made the last technique.493C - Vasya and BasketballWe need an array of pairs — in each pair we save the distance and the number of team. Then we sort the array. Then we assume that all the throws bring 3 points. Then we pass by the array and one of our numbers we decrease on 1 (which one — it depends on the second element of array). Then we compare it with our answer. In the end — we print our answer. 493D - Vasya and ChessIf n is odd, then black can win white doing all the moves symetric by the central line. Else white can win putting his queen on (1,2) (which is the lexicographicly smallest place) and play symetricly — never using the first row.493E - Vasya and PolynomialLet's discuss 2 case. 1) t!=1 и 2) t=1.1) If our function is not constant (n>=1) than a is greater all the coefficients, so the only polynom can be the number b — in the a-ary counting system. We must only check that one and constant function.2)if t=1 must be careful:in case 1 1 1: the answer is inf,in case 1 1 n: the answer is 0in case 1 а а^x(x-integer, x>0): the answer is 1in the other cases P(1) is greater than other coefficients.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/14985",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 493\\s*D"
          },
          "content_length": 1817
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #281 (Div. 2) - Codeforces - Code 1",
          "code": "1! + 3! + 4! + 5! + ... + 281!",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14959",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #281 (Div. 2) - Codeforces - Code 2",
          "code": "281 = 9*8 + 7*6 + 5*4 + 3*2 + 1 + 2*3 + 4*5 + 6*7 + 8*9",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14959",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #281 (Div. 2) - Codeforces - Code 3",
          "code": "281 = 9*8 + 7*6 + 5*4 + 3*2 + 1 + 2*3 + 4*5 + 6*7 + 8*9",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14959",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #281 (Div. 2) - Codeforces - Code 4",
          "code": "3\n1000000000\n1000000000\n1000000000",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14959",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #281 (Div. 2) - Codeforces - Code 5",
          "code": "3\n1000000000\n1000000000\n1000000000",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14959",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #281 (Div. 2) - Codeforces - Code 6",
          "code": "4\n1\n5\n-2\n-4",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14959",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #281 (Div. 2) - Codeforces - Code 7",
          "code": "4\n1\n5\n-2\n-4",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14959",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #281 (Div. 2) - Codeforces - Code 8",
          "code": "4\n11\n1\n-9\n-3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14959",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #281 (Div. 2) - Codeforces - Code 9",
          "code": "4\n11\n1\n-9\n-3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14959",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #281 (Div. 2) - Codeforces - Code 10",
          "code": "11 > 9 => true",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14959",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #281 (Div. 2) - Codeforces - Code 11",
          "code": "111 gt 93 => false",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14959",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #281 (Div. 2) - Codeforces - Code 12",
          "code": "if(n%2) cout<<\"black\\n\";  else cout<<\"white\\n1 2\\n\";",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14959",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #281 (Div. 2) - Codeforces - Code 13",
          "code": "if ( (n & 1) == 1 ) {\n        System.out.println(\"black\");\n    } else {\n        System.out.println(\"white\\n1 2\");\n    }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14959",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #281 (Div. 2) - Codeforces - Code 14",
          "code": "if ( (n & 1) == 1 ) {\n        System.out.println(\"black\");\n    } else {\n        System.out.println(\"white\\n1 2\");\n    }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14959",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #281 (Div. 2) - Codeforces - Code 15",
          "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\nusing namespace std;\n#define ll long long \nll dp[6000];\nint main()\n{\n\tcout<<200000<<endl;\n\tfor(int i=0;i<200000;i++)\n\t\tcout<<1999999999<<\" \";\n\tcout<<1<<endl;\n\tcout<<2000000000;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/14959",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #281 (Div. 2) - Codeforces - Code 16",
          "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\nusing namespace std;\n#define ll long long \nll dp[6000];\nint main()\n{\n\tcout<<200000<<endl;\n\tfor(int i=0;i<200000;i++)\n\t\tcout<<1999999999<<\" \";\n\tcout<<1<<endl;\n\tcout<<2000000000;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/14959",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #281 (Div. 2) - Codeforces - Code 17",
          "code": "cout<<1<<endl;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14959",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #281 (Div. 2) - Codeforces - Code 18",
          "code": "cout<<endl<<1<<endl;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14959",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #281 (Div. 2) - Codeforces - Code 19",
          "code": "int a;\nscanf(\"%c\",&a);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14959",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #281 (Div. 2) - Codeforces - Code 20",
          "code": "int a;\nscanf(\"%c\",&a);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14959",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #281 (Div. 2) Editorial - Codeforces - Code 1",
          "code": "wrong answer 1st words differ - expected: '6:8', found: '0:0'",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14985",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #281 (Div. 2) Editorial - Codeforces - Code 2",
          "code": "ll AA, BB;\nAA = BB == -1;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14985",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #281 (Div. 2) Editorial - Codeforces - Code 3",
          "code": "ll AA, BB;\nAA = BB == -1;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14985",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #281 (Div. 2) Editorial - Codeforces - Code 4",
          "code": "5\n6 7 8 9 10\n5\n1 2 3 4 5",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14985",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #281 (Div. 2) Editorial - Codeforces - Code 5",
          "code": "5\n6 7 8 9 10\n5\n1 2 3 4 5",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14985",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #281 (Div. 2) Editorial - Codeforces - Code 6",
          "code": "5\n1 2 3 4 5\n5\n6 7 8 9 10",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14985",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #281 (Div. 2) Editorial - Codeforces - Code 7",
          "code": "5\n1 2 3 4 5\n5\n6 7 8 9 10",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14985",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #281 (Div. 2) Editorial - Codeforces - Code 8",
          "code": "TANC\n XNCOR\n 2\n 15 h 27 r\n 28 h 27 r",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14985",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #281 (Div. 2) Editorial - Codeforces - Code 9",
          "code": "TANC\n XNCOR\n 2\n 15 h 27 r\n 28 h 27 r",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14985",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #281 (Div. 2) Editorial - Codeforces - Code 10",
          "code": "for(j = 0; j < 2; j++)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14985",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #281 (Div. 2) Editorial - Codeforces - Code 11",
          "code": "for(j = 0; j <= 2; j++)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/14985",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(2, 1000000000, \"n\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(2, 1000000000, \"n\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(2, 1000000000, \"n\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare sequences of tokens\");\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string j, p;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n\r\n        ans.readWordTo(j);\r\n        ouf.readWordTo(p);\r\n\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s words differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  compress(j).c_str(), compress(p).c_str());\r\n    }\r\n\r\n    if (ans.seekEof() && ouf.seekEof()) {\r\n        if (n == 1)\r\n            quitf(_ok, \"\\\"%s\\\"\", compress(j).c_str());\r\n        else\r\n            quitf(_ok, \"%d tokens\", n);\r\n    } else {\r\n        if (ans.seekEof())\r\n            quitf(_wa, \"Participant output contains extra tokens\");\r\n        else\r\n            quitf(_wa, \"Unexpected EOF in the participants output\");\r\n    }\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n \nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\", -1);\n    string type = opt<string>(\"type\", \"default\");\n\n    if (type == \"max\") {\n        n = 1000000000;\n    } else if (type == \"min\") {\n        n = 2;\n    } else if (type == \"even\") {\n        if (n == -1) n = 1000000000;\n        if (n % 2 != 0) n++; // make n even\n        if (n < 2) n = 2; // ensure n >= 2\n        if (n > 1000000000) n = 1000000000;\n    } else if (type == \"odd\") {\n        if (n == -1) n = 1000000000 - 1;\n        if (n % 2 == 0) n++; // make n odd\n        if (n < 2) n = 3; // ensure n >= 2\n        if (n > 1000000000) n = 1000000000;\n    } else if (type == \"random\") {\n        int min_n = opt<int>(\"min_n\", 2);\n        int max_n = opt<int>(\"max_n\", 1000000000);\n        n = rnd.next(min_n, max_n);\n        if (n < 2) n = 2;\n        if (n > 1000000000) n = 1000000000;\n    } else if (type == \"small_even\") {\n        n = 2;\n    } else if (type == \"small_odd\") {\n        n = 3;\n    } else {\n        // default\n        if (n == -1) n = 2;\n        if (n < 2) n = 2;\n        if (n > 1000000000) n = 1000000000;\n    }\n\n    printf(\"%d\\n\", n);\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n \nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\", -1);\n    string type = opt<string>(\"type\", \"default\");\n\n    if (type == \"max\") {\n        n = 1000000000;\n    } else if (type == \"min\") {\n        n = 2;\n    } else if (type == \"even\") {\n        if (n == -1) n = 1000000000;\n        if (n % 2 != 0) n++; // make n even\n        if (n < 2) n = 2; // ensure n >= 2\n        if (n > 1000000000) n = 1000000000;\n    } else if (type == \"odd\") {\n        if (n == -1) n = 1000000000 - 1;\n        if (n % 2 == 0) n++; // make n odd\n        if (n < 2) n = 3; // ensure n >= 2\n        if (n > 1000000000) n = 1000000000;\n    } else if (type == \"random\") {\n        int min_n = opt<int>(\"min_n\", 2);\n        int max_n = opt<int>(\"max_n\", 1000000000);\n        n = rnd.next(min_n, max_n);\n        if (n < 2) n = 2;\n        if (n > 1000000000) n = 1000000000;\n    } else if (type == \"small_even\") {\n        n = 2;\n    } else if (type == \"small_odd\") {\n        n = 3;\n    } else {\n        // default\n        if (n == -1) n = 2;\n        if (n < 2) n = 2;\n        if (n > 1000000000) n = 1000000000;\n    }\n\n    printf(\"%d\\n\", n);\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Small even n\n./gen -type small_even\n./gen -n 4 -type even\n./gen -n 6 -type even\n./gen -n 8 -type even\n\n# Small odd n\n./gen -type small_odd\n./gen -n 5 -type odd\n./gen -n 7 -type odd\n./gen -n 9 -type odd\n\n# Medium n\n./gen -n 100 -type even\n./gen -n 101 -type odd\n./gen -n 1000 -type even\n./gen -n 1001 -type odd\n\n# Large even n\n./gen -n 999999998 -type even\n./gen -n 999999999 -type even\n./gen -n 1000000000 -type max\n\n# Large odd n\n./gen -n 999999999 -type odd\n./gen -n 1000000000 -type odd\n\n# Random n within small range\n./gen -type random -min_n 2 -max_n 10\n./gen -type random -min_n 2 -max_n 10\n./gen -type random -min_n 2 -max_n 10\n\n# Random n within medium range\n./gen -type random -min_n 11 -max_n 100\n./gen -type random -min_n 11 -max_n 100\n./gen -type random -min_n 11 -max_n 100\n\n# Random n within large range\n./gen -type random -min_n 100000000 -max_n 1000000000\n./gen -type random -min_n 100000000 -max_n 1000000000\n./gen -type random -min_n 100000000 -max_n 1000000000\n\n# Edge cases\n./gen -type min\n./gen -type max\n\n# Even and odd near boundaries\n./gen -n 999999999 -type even\n./gen -n 999999998 -type odd\n./gen -n 2 -type odd\n./gen -n 3 -type even\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:38:37.431133",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "493/E",
      "title": "Problem 493/E",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "",
      "memory_limit": "",
      "input_spec": "",
      "output_spec": "",
      "sample_tests": "",
      "description": "",
      "solutions": [],
      "code_examples": [],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    long long a = inf.readLong(1, 1000000000000000000LL, \"a\");\n    inf.readSpace();\n    long long b = inf.readLong(1, 1000000000000000000LL, \"b\");\n    inf.readSpace();\n    long long c = inf.readLong(1, 1000000000000000000LL, \"c\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    long long a = inf.readLong(1, 1000000000000000000LL, \"a\");\n    inf.readSpace();\n    long long b = inf.readLong(1, 1000000000000000000LL, \"b\");\n    inf.readSpace();\n    long long c = inf.readLong(1, 1000000000000000000LL, \"c\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    long long a = inf.readLong(1, 1000000000000000000LL, \"a\");\n    inf.readSpace();\n    long long b = inf.readLong(1, 1000000000000000000LL, \"b\");\n    inf.readSpace();\n    long long c = inf.readLong(1, 1000000000000000000LL, \"c\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare sequences of tokens\");\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string j, p;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n\r\n        ans.readWordTo(j);\r\n        ouf.readWordTo(p);\r\n\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s words differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  compress(j).c_str(), compress(p).c_str());\r\n    }\r\n\r\n    if (ans.seekEof() && ouf.seekEof()) {\r\n        if (n == 1)\r\n            quitf(_ok, \"\\\"%s\\\"\", compress(j).c_str());\r\n        else\r\n            quitf(_ok, \"%d tokens\", n);\r\n    } else {\r\n        if (ans.seekEof())\r\n            quitf(_wa, \"Participant output contains extra tokens\");\r\n        else\r\n            quitf(_wa, \"Unexpected EOF in the participants output\");\r\n    }\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    // Parse parameters\n    long long max_value = opt<long long>(\"max_value\", (long long)1e18);\n    string type = opt<string>(\"type\", \"random\");\n\n    long long a, b, c;\n\n    if (type == \"random\") {\n        a = rnd.next(1LL, max_value);\n        b = rnd.next(1LL, max_value);\n        c = rnd.next(1LL, max_value);\n    } else if (type == \"equal_a_c\") {\n        a = rnd.next(1LL, max_value);\n        b = rnd.next(1LL, max_value);\n        c = a;\n    } else if (type == \"a_not_equal_c\") {\n        a = rnd.next(1LL, max_value);\n        do {\n            c = rnd.next(1LL, max_value);\n        } while (c == a);\n        b = rnd.next(1LL, max_value);\n    } else if (type == \"min_values\") {\n        a = 1;\n        b = 1;\n        c = 1;\n    } else if (type == \"max_values\") {\n        a = max_value;\n        b = max_value;\n        c = max_value;\n    } else if (type == \"infinite_solution\") {\n        // We are making an assumption that when a = c and b = 0, there may be infinite polynomials\n        a = rnd.next(1LL, max_value);\n        c = a;\n        b = 0; // Assuming that when b = 0, infinite solutions may exist\n    } else if (type == \"large_b\") {\n        a = rnd.next(1LL, max_value);\n        c = rnd.next(1LL, max_value);\n        b = max_value;\n    } else if (type == \"small_b\") {\n        a = rnd.next(1LL, max_value);\n        c = rnd.next(1LL, max_value);\n        b = 1;\n    } else if (type == \"a_equals_b\") {\n        a = rnd.next(1LL, max_value);\n        b = a;\n        c = rnd.next(1LL, max_value);\n    } else if (type == \"c_equals_b\") {\n        c = rnd.next(1LL, max_value);\n        b = c;\n        a = rnd.next(1LL, max_value);\n    } else {\n        // default random\n        a = rnd.next(1LL, max_value);\n        b = rnd.next(1LL, max_value);\n        c = rnd.next(1LL, max_value);\n    }\n\n    // Ensure that all numbers are within [1, 1e18]\n    a = max(1LL, min(a, (long long)1e18));\n    b = max(1LL, min(b, (long long)1e18));\n    c = max(1LL, min(c, (long long)1e18));\n\n    printf(\"%lld %lld %lld\\n\", a, b, c);\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    // Parse parameters\n    long long max_value = opt<long long>(\"max_value\", (long long)1e18);\n    string type = opt<string>(\"type\", \"random\");\n\n    long long a, b, c;\n\n    if (type == \"random\") {\n        a = rnd.next(1LL, max_value);\n        b = rnd.next(1LL, max_value);\n        c = rnd.next(1LL, max_value);\n    } else if (type == \"equal_a_c\") {\n        a = rnd.next(1LL, max_value);\n        b = rnd.next(1LL, max_value);\n        c = a;\n    } else if (type == \"a_not_equal_c\") {\n        a = rnd.next(1LL, max_value);\n        do {\n            c = rnd.next(1LL, max_value);\n        } while (c == a);\n        b = rnd.next(1LL, max_value);\n    } else if (type == \"min_values\") {\n        a = 1;\n        b = 1;\n        c = 1;\n    } else if (type == \"max_values\") {\n        a = max_value;\n        b = max_value;\n        c = max_value;\n    } else if (type == \"infinite_solution\") {\n        // We are making an assumption that when a = c and b = 0, there may be infinite polynomials\n        a = rnd.next(1LL, max_value);\n        c = a;\n        b = 0; // Assuming that when b = 0, infinite solutions may exist\n    } else if (type == \"large_b\") {\n        a = rnd.next(1LL, max_value);\n        c = rnd.next(1LL, max_value);\n        b = max_value;\n    } else if (type == \"small_b\") {\n        a = rnd.next(1LL, max_value);\n        c = rnd.next(1LL, max_value);\n        b = 1;\n    } else if (type == \"a_equals_b\") {\n        a = rnd.next(1LL, max_value);\n        b = a;\n        c = rnd.next(1LL, max_value);\n    } else if (type == \"c_equals_b\") {\n        c = rnd.next(1LL, max_value);\n        b = c;\n        a = rnd.next(1LL, max_value);\n    } else {\n        // default random\n        a = rnd.next(1LL, max_value);\n        b = rnd.next(1LL, max_value);\n        c = rnd.next(1LL, max_value);\n    }\n\n    // Ensure that all numbers are within [1, 1e18]\n    a = max(1LL, min(a, (long long)1e18));\n    b = max(1LL, min(b, (long long)1e18));\n    c = max(1LL, min(c, (long long)1e18));\n\n    printf(\"%lld %lld %lld\\n\", a, b, c);\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -max_value 10 -type min_values\n./gen -max_value 10 -type max_values\n./gen -max_value 10 -type equal_a_c\n./gen -max_value 10 -type a_not_equal_c\n./gen -max_value 10 -type infinite_solution\n./gen -max_value 10 -type large_b\n./gen -max_value 10 -type small_b\n./gen -max_value 10 -type a_equals_b\n./gen -max_value 10 -type c_equals_b\n./gen -max_value 1000 -type min_values\n./gen -max_value 1000 -type max_values\n./gen -max_value 1000 -type equal_a_c\n./gen -max_value 1000 -type a_not_equal_c\n./gen -max_value 1000 -type infinite_solution\n./gen -max_value 1000 -type large_b\n./gen -max_value 1000 -type small_b\n./gen -max_value 1000 -type a_equals_b\n./gen -max_value 1000 -type c_equals_b\n./gen -max_value 1000000 -type min_values\n./gen -max_value 1000000 -type max_values\n./gen -max_value 1000000 -type equal_a_c\n./gen -max_value 1000000 -type a_not_equal_c\n./gen -max_value 1000000 -type infinite_solution\n./gen -max_value 1000000 -type large_b\n./gen -max_value 1000000 -type small_b\n./gen -max_value 1000000 -type a_equals_b\n./gen -max_value 1000000 -type c_equals_b\n./gen -max_value 1000000000 -type min_values\n./gen -max_value 1000000000 -type max_values\n./gen -max_value 1000000000 -type equal_a_c\n./gen -max_value 1000000000 -type a_not_equal_c\n./gen -max_value 1000000000 -type infinite_solution\n./gen -max_value 1000000000 -type large_b\n./gen -max_value 1000000000 -type small_b\n./gen -max_value 1000000000 -type a_equals_b\n./gen -max_value 1000000000 -type c_equals_b\n./gen -max_value 1000000000000000000 -type min_values\n./gen -max_value 1000000000000000000 -type max_values\n./gen -max_value 1000000000000000000 -type equal_a_c\n./gen -max_value 1000000000000000000 -type a_not_equal_c\n./gen -max_value 1000000000000000000 -type infinite_solution\n./gen -max_value 1000000000000000000 -type large_b\n./gen -max_value 1000000000000000000 -type small_b\n./gen -max_value 1000000000000000000 -type a_equals_b\n./gen -max_value 1000000000000000000 -type c_equals_b\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:38:39.057479",
        "total_tutorials": 0,
        "has_ai_judgment": false,
        "has_code_files": true
      }
    },
    {
      "problem_id": "494/A",
      "title": "Problem 494/A",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "",
      "memory_limit": "",
      "input_spec": "",
      "output_spec": "",
      "sample_tests": "",
      "description": "",
      "solutions": [],
      "code_examples": [],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[])\n{\n    registerValidation(argc, argv);\n\n    string s = inf.readLine();\n    int n = s.length();\n    ensuref(1 <= n && n <= 100000, \"Length of s must be between 1 and 100000, but is %d\", n);\n\n    bool has_hash = false;\n    for (char c : s) {\n        ensuref(c == '(' || c == ')' || c == '#', \"Invalid character '%c' in s\", c);\n        if (c == '#')\n            has_hash = true;\n    }\n    ensuref(has_hash, \"s must contain at least one '#' character\");\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[])\n{\n    registerValidation(argc, argv);\n\n    string s = inf.readLine();\n    int n = s.length();\n    ensuref(1 <= n && n <= 100000, \"Length of s must be between 1 and 100000, but is %d\", n);\n\n    bool has_hash = false;\n    for (char c : s) {\n        ensuref(c == '(' || c == ')' || c == '#', \"Invalid character '%c' in s\", c);\n        if (c == '#')\n            has_hash = true;\n    }\n    ensuref(has_hash, \"s must contain at least one '#' character\");\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[])\n{\n    registerValidation(argc, argv);\n\n    string s = inf.readLine();\n    int n = s.length();\n    ensuref(1 <= n && n <= 100000, \"Length of s must be between 1 and 100000, but is %d\", n);\n\n    bool has_hash = false;\n    for (char c : s) {\n        ensuref(c == '(' || c == ')' || c == '#', \"Invalid character '%c' in s\", c);\n        if (c == '#')\n            has_hash = true;\n    }\n    ensuref(has_hash, \"s must contain at least one '#' character\");\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring s;\nint numSharps;\n\n// Function to check if the string is beautiful\nbool isBeautiful(const string& str) {\n    int balance = 0;\n    for (char c : str) {\n        if (c == '(') {\n            balance++;\n        } else if (c == ')') {\n            balance--;\n        }\n        if (balance < 0)\n            return false;\n    }\n    return balance == 0;\n}\n\nint main(int argc, char* argv[]) {\n    registerTestlibCmd(argc, argv);\n\n    // Read the input string s\n    s = inf.readString();\n\n    // Count the number of '#' characters in s\n    numSharps = count(s.begin(), s.end(), '#');\n\n    // Read judge's output\n    bool ansIsNegative = false;\n    bool ansEof = false;\n    string ansFirstToken;\n    if (!ans.seekEof()) {\n        ansFirstToken = ans.readToken();\n    } else {\n        ansEof = true;\n    }\n\n    if (ansEof || ansFirstToken == \"-1\") {\n        ansIsNegative = true;\n    }\n\n    // Read participant's output\n    bool participantIsNegative = false;\n    bool participantEof = false;\n    string participantFirstToken;\n    if (!ouf.seekEof()) {\n        participantFirstToken = ouf.readToken();\n    } else {\n        participantEof = true;\n    }\n\n    if (participantEof) {\n        quitf(_pe, \"Unexpected EOF in participant's output\");\n    }\n\n    if (participantFirstToken == \"-1\") {\n        participantIsNegative = true;\n    }\n\n    if (participantIsNegative) {\n        if (ansIsNegative) {\n            quitf(_ok, \"Correctly outputted -1\");\n        } else {\n            quitf(_wa, \"Participant outputs -1 but a solution exists\");\n        }\n    } else {\n        // Participant outputs numbers\n        vector<long long> participantNumbers;\n        // Try to parse participantFirstToken as a positive integer\n        long long num1;\n        try {\n            num1 = stoll(participantFirstToken);\n        } catch (exception&) {\n            quitf(_pe, \"First token is not an integer\");\n        }\n        if (num1 < 1) {\n            quitf(_wa, \"First number is less than 1\");\n        }\n        participantNumbers.push_back(num1);\n\n        // Read the remaining numbers\n        if (numSharps - 1 > 0) {\n            vector<long long> restNumbers = ouf.readLongs(numSharps - 1, 1, LONG_LONG_MAX);\n            participantNumbers.insert(participantNumbers.end(), restNumbers.begin(), restNumbers.end());\n        }\n\n        if (!ouf.seekEof()) {\n            quitf(_pe, \"Participant's output contains extra data\");\n        }\n\n        if ((int)participantNumbers.size() != numSharps) {\n            quitf(_wa, \"Expected %d numbers, but found %d numbers\", numSharps, (int)participantNumbers.size());\n        }\n\n        // Build the final string\n        string res;\n        int idx = 0;\n        for (char c : s) {\n            if (c == '(' || c == ')') {\n                res += c;\n            } else if (c == '#') {\n                res += string(participantNumbers[idx], ')');\n                idx++;\n            }\n        }\n\n        // Check if the final string is beautiful\n        if (!isBeautiful(res)) {\n            quitf(_wa, \"The resulting string is not beautiful\");\n        } else {\n            quitf(_ok, \"The answer is correct\");\n        }\n    }\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    // Ensure that n is within the constraints\n    n = min(n, 100000);\n    n = max(n, 1);\n\n    string s;\n    if (type == \"random\") {\n        // Generate a random string with '(', ')', '#' randomly placed.\n        // Ensure there is at least one '#' character.\n        int num_hash = rnd.next(1, max(1, n / 10));\n        vector<int> positions(n);\n        for (int i = 0; i < n; ++i) positions[i] = i;\n        shuffle(positions.begin(), positions.end());\n        set<int> hash_positions;\n        for (int i = 0; i < num_hash; ++i)\n            hash_positions.insert(positions[i]);\n        s.resize(n);\n        for (int i = 0; i < n; ++i) {\n            if (hash_positions.count(i))\n                s[i] = '#';\n            else {\n                int c = rnd.next(2); // 0 or 1\n                s[i] = (c == 0) ? '(' : ')';\n            }\n        }\n    } else if (type == \"no_solution\") {\n        // Generate a string where no solution exists.\n        s = \"\";\n        for (int i = 0; i < n - 1; ++i)\n            s += '(';\n        s += ')';\n        s[n / 2] = '#'; // Ensure at least one '#'\n    } else if (type == \"only_open\") {\n        // Generate a string with only '(' and '#'.\n        s = string(n - 1, '(') + '#'; // Last character is '#'\n    } else if (type == \"only_close\") {\n        // Generate a string that causes immediate imbalance.\n        s = '#' + string(n - 1, ')'); // First character is '#'\n    } else if (type == \"alternating\") {\n        // Generate an alternating pattern of '(' and ')', ending with '#'.\n        s = \"\";\n        for (int i = 0; i < n - 1; ++i)\n            s += (i % 2 == 0) ? '(' : ')';\n        s += '#'; // Ensure at least one '#'\n    } else if (type == \"deep_nesting\") {\n        // Generate a deeply nested structure with one '#'.\n        s = string(n - 1, '(') + '#';\n    } else {\n        // Default to random if type is unrecognized.\n        int num_hash = rnd.next(1, max(1, n / 10));\n        vector<int> positions(n);\n        for (int i = 0; i < n; ++i) positions[i] = i;\n        shuffle(positions.begin(), positions.end());\n        set<int> hash_positions;\n        for (int i = 0; i < num_hash; ++i)\n            hash_positions.insert(positions[i]);\n        s.resize(n);\n        for (int i = 0; i < n; ++i) {\n            if (hash_positions.count(i))\n                s[i] = '#';\n            else {\n                int c = rnd.next(2);\n                s[i] = (c == 0) ? '(' : ')';\n            }\n        }\n    }\n\n    // Output the generated string\n    printf(\"%s\\n\", s.c_str());\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    // Ensure that n is within the constraints\n    n = min(n, 100000);\n    n = max(n, 1);\n\n    string s;\n    if (type == \"random\") {\n        // Generate a random string with '(', ')', '#' randomly placed.\n        // Ensure there is at least one '#' character.\n        int num_hash = rnd.next(1, max(1, n / 10));\n        vector<int> positions(n);\n        for (int i = 0; i < n; ++i) positions[i] = i;\n        shuffle(positions.begin(), positions.end());\n        set<int> hash_positions;\n        for (int i = 0; i < num_hash; ++i)\n            hash_positions.insert(positions[i]);\n        s.resize(n);\n        for (int i = 0; i < n; ++i) {\n            if (hash_positions.count(i))\n                s[i] = '#';\n            else {\n                int c = rnd.next(2); // 0 or 1\n                s[i] = (c == 0) ? '(' : ')';\n            }\n        }\n    } else if (type == \"no_solution\") {\n        // Generate a string where no solution exists.\n        s = \"\";\n        for (int i = 0; i < n - 1; ++i)\n            s += '(';\n        s += ')';\n        s[n / 2] = '#'; // Ensure at least one '#'\n    } else if (type == \"only_open\") {\n        // Generate a string with only '(' and '#'.\n        s = string(n - 1, '(') + '#'; // Last character is '#'\n    } else if (type == \"only_close\") {\n        // Generate a string that causes immediate imbalance.\n        s = '#' + string(n - 1, ')'); // First character is '#'\n    } else if (type == \"alternating\") {\n        // Generate an alternating pattern of '(' and ')', ending with '#'.\n        s = \"\";\n        for (int i = 0; i < n - 1; ++i)\n            s += (i % 2 == 0) ? '(' : ')';\n        s += '#'; // Ensure at least one '#'\n    } else if (type == \"deep_nesting\") {\n        // Generate a deeply nested structure with one '#'.\n        s = string(n - 1, '(') + '#';\n    } else {\n        // Default to random if type is unrecognized.\n        int num_hash = rnd.next(1, max(1, n / 10));\n        vector<int> positions(n);\n        for (int i = 0; i < n; ++i) positions[i] = i;\n        shuffle(positions.begin(), positions.end());\n        set<int> hash_positions;\n        for (int i = 0; i < num_hash; ++i)\n            hash_positions.insert(positions[i]);\n        s.resize(n);\n        for (int i = 0; i < n; ++i) {\n            if (hash_positions.count(i))\n                s[i] = '#';\n            else {\n                int c = rnd.next(2);\n                s[i] = (c == 0) ? '(' : ')';\n            }\n        }\n    }\n\n    // Output the generated string\n    printf(\"%s\\n\", s.c_str());\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 10 -type random\n./gen -n 10 -type no_solution\n./gen -n 10 -type only_open\n./gen -n 10 -type only_close\n./gen -n 10 -type alternating\n\n./gen -n 100 -type random\n./gen -n 100 -type no_solution\n./gen -n 100 -type only_open\n./gen -n 100 -type only_close\n./gen -n 100 -type alternating\n\n./gen -n 1000 -type random\n./gen -n 1000 -type no_solution\n./gen -n 1000 -type only_open\n./gen -n 1000 -type only_close\n./gen -n 1000 -type alternating\n\n./gen -n 10000 -type random\n./gen -n 10000 -type no_solution\n./gen -n 10000 -type only_open\n./gen -n 10000 -type only_close\n./gen -n 10000 -type alternating\n\n./gen -n 100000 -type random\n./gen -n 100000 -type no_solution\n./gen -n 100000 -type only_open\n./gen -n 100000 -type only_close\n./gen -n 100000 -type alternating\n\n./gen -n 100000 -type deep_nesting\n./gen -n 100000 -type random\n./gen -n 50000 -type only_open\n./gen -n 50000 -type only_close\n./gen -n 50000 -type alternating\n\n./gen -n 99999 -type random\n./gen -n 1 -type random\n./gen -n 2 -type no_solution\n./gen -n 3 -type only_open\n./gen -n 4 -type only_close\n./gen -n 5 -type alternating\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:38:40.741240",
        "total_tutorials": 0,
        "has_ai_judgment": false,
        "has_code_files": true
      }
    },
    {
      "problem_id": "494/B",
      "title": "B. Obsessive String",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputInput consists of two lines containing strings s and t (1 ≤ |s|, |t| ≤ 105). Each string consists of lowercase Latin letters.",
      "output_spec": "OutputPrint the answer in a single line.",
      "sample_tests": "ExamplesInputCopyababaabaOutputCopy5InputCopywelcometoroundtwohundredandeightytwodOutputCopy274201InputCopyddddOutputCopy12",
      "description": "B. Obsessive String\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputInput consists of two lines containing strings s and t (1 ≤ |s|, |t| ≤ 105). Each string consists of lowercase Latin letters.\n\nOutputPrint the answer in a single line.\n\nInputCopyababaabaOutputCopy5InputCopywelcometoroundtwohundredandeightytwodOutputCopy274201InputCopyddddOutputCopy12\n\nInputCopyababaaba\n\nOutputCopy5\n\nInputCopywelcometoroundtwohundredandeightytwod\n\nOutputCopy274201\n\nInputCopydddd\n\nOutputCopy12",
      "solutions": [
        {
          "title": "Codeforces Round #282 - Codeforces",
          "content": "Hi, Codeforces Round #282 will be held at 13th of December, 19:30 MSK. Please don't note anything since the time is the usual time of contests.The round is prepared by FarbodY, Haghani and Me(matrix). We'd like to thank Zlobober who helped us a LOT for preparing the problems, MikeMirzayanov for the Polygon and Codeforces platforms and Delinur for helping us in preparing statements and translating them.Our special thanks goes to mruxim for testing the round.The problems will be sorted according to the estimated order of difficulty according to our opinion but we strongly recommend you to read all of the problems.As always the update regarding score distribution will be posted just before the round starts. :)UPD: It was written that contest starts at 20:00 MSK. it was a mistake and is fixed now. The round starts at usual time 19:30 MSK.UPD2: We also thank niyaznigmatul for testing our round.UPD3: Score distribution:Div1: 500-1000-1750-1750-2500Div2: 500-1000-1500-2000-2750As you might have noticed, the scores can now be multiples of 250 as well. Let's thank Codeforces team for adding this feature!Good luck and Have fun!UPD4: Congratulations to the winners of both divisions:Div1: tourist winger sankear uwi Egor Div2: Ginger88895 pwild arthurpd konmaj ezkatka The editorial for all problems except D and E Div1 are ready and can be found here. It'll be completed soon.We thank you all for participating and hope you had a good time.UPD5: The editorial is now complete and can be found here.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/15134",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1506
        },
        {
          "title": "Codeforces Round #282 Editorial - Codeforces",
          "content": "495A - Digital CounterFor each digit x you can count the number of digits y that because of some broken sticks x is shown instead of y by hand. for example when x = 3, y can be 3, 8 and 9. Let's denote this number by ax. Then if the input is xy (the first digit shown in the counter is x and the second is y) the answer will be ax × ay.495B - Modular Equations If a < b then there is no answer since . If a = b then x can be any integer larger than a. so there are infinite number of answers to the equation. The only remaining case is when a > b. Suppose x is an answer to our equation. Then x|a - b. Also since then b < x. These conditions are necessary and sufficient as well. So the answer is number of divisors of a - b which are strictly greater than b which can be solved in . 494A - TreasureConsider a string consisting of '(' and ')' characters. Let's build the following sequence from this string: a0 = 0 for each 1 ≤ i ≤ |s| ai = ai - 1 + 1 if si = '(' and ai = ai - 1 - 1 otherwise. (The string is considered as 1-based index). It can be proven that a string is beautiful if the following conditions are satisfied: for each 0 ≤ i ≤ |s| ai ≥ 0. a|s| = 0 Using the above fact we can prove that if in a beautiful string we remove a ')' character and put it further toward the end of the string the resulting string is beautiful as well. These facts leads us to the following fact: if we can move a ')' character further toward the end of string it is better if we'd do it. This yields the following greedy solution:We'll first put exactly one ')' character at each '#' character. Then we'll build the sequence we described above. if the first condition isn't satisfied then there is no way that leads to a beautiful string. So the answer is -1. Otherwise we must put exactly a|s| more ')' characters in the place of last '#' character. Then if this string is beautiful we'll print it otherwise the answer is -1.494B - Obsessive StringWe call an index i(1 ≤ i ≤ |s|) good if t equals si - |t| + 1si - |t| + 2... si. To find all good indexes let's define qi as the length of longest prefix of t which is a suffix of s1s2... si. A good index is an index with qi = |t|. Calculating qi can be done using Knuth-Morris-Pratt algorithm. Let's define ai as the number of ways to choose some(at least one) non-overlapping substrings of the prefix of s with length i (s1s2... si) so t is a substring of each one of them and si is in one the chosen substrings(So it must actually be the last character of last chosen substring). Then the answer will be .Also let's define two additional sequence q1 and q2 which will help us in calculating a.The sequence a can then be calculated in O(n) as described below:If i is not a good index ai = ai - 1 since in each way counted in ai the substring containing si also contains si - 1 so for each of these ways removing si from the substring containing it leads to a way counted in ai - 1 and vice-versa thus these two numbers are equal. If i is a good index then ai = q2i - |t| + i - |t| + 1. To prove this let's consider a way of choosing substring counted in ai. We call such a way valid. The substring containing si can be any of the substrings sjsj + 1... si (1 ≤ j ≤ i - |t| + 1). There are i - |t| + 1 valid ways in which this substring is the only substring we've chosen. Number of valid ways in which substring containing si starts at sj equals to q1j - 1. So the total number of valid ways in which we've chosen at least two substrings are equal to which is equal to q2j - 1. So ai = q2i - |t| + i - |t| + 1.494C - Helping PeopleWe'll first create a rooted tree from the given segments which each node represents a segment. We'll solve the problem using dynamic programming on this tree. First of all let's add a segment [1, n] with probability of being chosen by Malek equal to 0. The node representing this segment will be the root of the tree. Please note by adding this segment the rules described in the statements are still in place.Let's sort the rest of segments according to their starting point increasing and in case of equality according to their finishing point decreasing. Then we'll put the segment we added in the beginning. A segment's father is the right-most segment which comes before that segment and contains it. Please note that since we added segment [1, n] to the beginning every segment except the added segment has a father. We build the tree by putting a segment's node child of its father's node. In this tree for each two nodes u and v which none of them are in the subtree on another the segments representing these two nodes will not overlap. Also for each two nodes u and v which u is in subtree of v segment representing node u will be inside(not necessarily strictly) segment representing node v. We define mxi as the maximum money a person in the segment i initially has. mxi can be calculated using RMQ. Let's define ai, j as the probability of that after Malek finishes giving his money the maximum in the segment i is at most {mx}i + j. The properties of the tree we built allows us to calculate ai, j for every i and j in O(q2) (since 1 ≤ i, j ≤ q). If number of the segment we added is k then the answer will be . Calculating ai, j is described below:Suppose f is a child of i and suppose Malek doesn't accept the i-th recommendation. Then since we want the maximum number after money spreading to be at most mxi + j in segment i and since f is inside i we want the maximum number after money spreading to be at most mxi - mxf + j. If Malek accepts the recommendation then we want it to be at most mxi - mxf + j - 1. So if probability of i-th recommendation being accepted by Malek be equal to pi then . Using this formula we can calculate ak, j recursively and calculate the answer from it in O(q2). The overall complexity will be O(nlgn + q2). nlgn for creating RMQ used for calculating the array mx and q2 for the rest of the algorithm.494D - BirthdayWe solve this problem by answering queries offline. We'll first store in each vertex v number of vertices such as x for which we must calculate f(v, x) . starting from the root. We'll keep two arrays a and b. Suppose we're at vertex v right now then ai equals d(i, v)2 and bi equal d(i, v). Having these two arrays when moving from vertex v to a child with an edge with weight k one can note that bi for all is inside subtree of v decreases by k and all other bis gets increased by k. Knowing this fact one can also update array a as well. To calculate f(v, x) it's enough to be able to calculate sum of ais for all i inside subtree of x. Handling each of these operations is a well known problem and is possible using a segment tree. Overall complexity is O((n + q)lgn). There is an online solution using dynamic programming as well.494E - ShartiLet's first solve this problem for another game: Suppose that we've an n × n table. Each cell have some(possibly zero) marbles on it. During each move the player chooses a square with side-length at most k which its lower-right cell has at least one marble, he removes one marble from it and puts one marble in every other cell of this square. One can notice that in such game each marble is independent of the others and doesn't affect other marbles. So one can see this game as some separate games played on some tables. More formally for each marble placed in a cell such as (i, j) consider the game when played on a i × j table which the only marble placed on it is at its lower-right cell. Let's denote the Grundy number of this game by gi, j. Then according to Grundy theorem the first player has a winning strategy if and only if the xor of gi, j for every cell (i, j) having odd number of marbles on it is positive. To calculate gi, j note that the first move in such game must be choosing a square with its lower-right cell being the lower-right cell of table. So the only thing to decide is the side-length of chosen square at the first move. Let's say we choose the first square width side length l. Grundy number of the next state will be equal to xor of gc, d for every i - l < c ≤ i, j - l < d ≤ j. Using this fact one can calculate gi, j for all (1 ≤ i, j ≤ a) (a being an arbitrary integers) in O(a3).If we calculated the first values of gi, j one can see a pattern in the Grundy numbers. Then one can prove that gi, j = min(lowest_bit(i), lowest_bit(j), greatest_bit(k)) where lowest_bit(x) =  the maximum power of 2 which is a divisor of x and greatest_bit(x) =  the maximum power of 2 which is not greater than x. Now let's prove that our first game(the game described in the statement) is actually the same as this game. Suppose that a player has a winning strategy in the first game. Consider a table containing one marble at every cell which is white in the table of the first game. We'll prove that the same player has winning strategy in this game as well. Note that a cell is white in the first game if and only if the parity of marbles in the second game is odd so there is at least one marble on it. So as long as the other player chooses a square with its lower-right cell having odd number of marbles in the second game, his move corresponds to a move in the first game so the player having winning strategy can counter his move. If the other player chooses a square with its lower-right cell having even number of marbles, it means the cell had at least 2 marbles on it so the player can counter it by choosing the same square which makes the parity of every cell to be the same after these 2 moves. And since it can be proven that both of the game will end at some point then the player has winning strategy in this game as well. The reverse of this fact can also be proven the same since if a player has a winning strategy there is also a winning strategy in which this player always chooses squares with lower-right cell having odd number of marbles(since otherwise the other player can counter it as described above) and counters the moves of the other player at which he chose a square with lower-right cell having even number of marbles by choosing the same square(since the Grundy number by countering in this way won't change the Grundy number and thus won't change the player with winning strategy).So if we consider a table having one marble at each of the cells which are in at least one of the rectangles given in the input we only need to calculate the Grundy number of this state and check whether it's positive or not to determine the winner. To do this for each i(1 ≤ i ≤ greatest_bit(k)) lets define ai as the number of cells (x, y) which are contained in at least one of the given rectangles, 2i|x and 2i|y. Lets also define agreatest_bit(k) + 1 = 0. Then according the fact we described above about gi, j the number of 2is which are xored equals ai - ai + 1. Knowing this calculating the Grundy number of the initial state is easy. Calculating ai is identical to a very well-known problem which is given some rectangles count the number of cells in at least one of them and can be solved in O(mlgm) (m being number of rectangles). So overall complexity will be O(mlgmlgk).If there is any problem in the editorial please feel free to note that to us.Thank you.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/15148",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 494\\s*B"
          },
          "content_length": 11197
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #282 - Codeforces - Code 1",
          "code": "(#(\nAnswer: -1\nWA: 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15134",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #282 - Codeforces - Code 2",
          "code": "(#(\nAnswer: -1\nWA: 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15134",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #282 Editorial - Codeforces - Code 1",
          "code": "divisors of (a-b) greater than b",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15148",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #282 Editorial - Codeforces - Code 2",
          "code": "1 to sqrt(a-b)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15148",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #282 Editorial - Codeforces - Code 3",
          "code": "O(sqrt(a-b))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15148",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #282 Editorial - Codeforces - Code 4",
          "code": "input\n3 5\n1 2 3\n1 3 0.500\n2 2 0.250\n1 2 0.800\n1 1 0.120\n2 2 0.900\noutput\n4.465000000",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15148",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #282 Editorial - Codeforces - Code 5",
          "code": "input\n3 5\n1 2 3\n1 3 0.500\n2 2 0.250\n1 2 0.800\n1 1 0.120\n2 2 0.900\noutput\n4.465000000",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15148",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #282 Editorial - Codeforces - Code 6",
          "code": "using std::",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15148",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #282 Editorial - Codeforces - Code 7",
          "code": "using namespace std",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15148",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #282 Editorial - Codeforces - Code 8",
          "code": "#define next ____next\n#define prev ____prev\n#define y1   ____y1\n#define left ____left\n#define hash ____hash",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15148",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #282 Editorial - Codeforces - Code 9",
          "code": "#define next ____next\n#define prev ____prev\n#define y1   ____y1\n#define left ____left\n#define hash ____hash",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15148",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #282 Editorial - Codeforces - Code 10",
          "code": "#define max max<long long>",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15148",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #282 Editorial - Codeforces - Code 11",
          "code": "long long max(int a, long long b) { return max((long long)a, b); }\nlong long max(long long b, int a) { return max(a, (long long)b); }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15148",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #282 Editorial - Codeforces - Code 12",
          "code": "long long max(int a, long long b) { return max((long long)a, b); }\nlong long max(long long b, int a) { return max(a, (long long)b); }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15148",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #282 Editorial - Codeforces - Code 13",
          "code": "#define MAX(a,b) ((a)>(b)?(a):(b))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15148",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #282 Editorial - Codeforces - Code 14",
          "code": "#define MAX(a,b) ((a)>(b)?(a):(b))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15148",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #282 Editorial - Codeforces - Code 15",
          "code": "final string becomes beautiful",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15148",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #282 Editorial - Codeforces - Code 16",
          "code": "Node v = root",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15148",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #282 Editorial - Codeforces - Code 17",
          "code": "v = v.parent",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15148",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #282 Editorial - Codeforces - Code 18",
          "code": "input:\nddd\nd\noutput:\n12",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15148",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #282 Editorial - Codeforces - Code 19",
          "code": "input:\nddd\nd\noutput:\n12",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15148",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    // Read the first line: string s\n    string s = inf.readLine();\n    // Check that length of s is between 1 and 100000\n    ensuref(1 <= int(s.length()) && int(s.length()) <= 100000, \"Length of s must be between 1 and 1e5, but s.length()=%d\", int(s.length()));\n    // Check that s consists only of lowercase Latin letters\n    for (char c : s)\n        ensuref('a' <= c && c <= 'z', \"String s must consist of lowercase letters, found '%c'\", c);\n\n    // Read the second line: string t\n    string t = inf.readLine();\n    // Check that length of t is between 1 and 100000\n    ensuref(1 <= int(t.length()) && int(t.length()) <= 100000, \"Length of t must be between 1 and 1e5, but t.length()=%d\", int(t.length()));\n    // Check that t consists only of lowercase Latin letters\n    for (char c : t)\n        ensuref('a' <= c && c <= 'z', \"String t must consist of lowercase letters, found '%c'\", c);\n\n    // Ensure there is no extra input\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    // Read the first line: string s\n    string s = inf.readLine();\n    // Check that length of s is between 1 and 100000\n    ensuref(1 <= int(s.length()) && int(s.length()) <= 100000, \"Length of s must be between 1 and 1e5, but s.length()=%d\", int(s.length()));\n    // Check that s consists only of lowercase Latin letters\n    for (char c : s)\n        ensuref('a' <= c && c <= 'z', \"String s must consist of lowercase letters, found '%c'\", c);\n\n    // Read the second line: string t\n    string t = inf.readLine();\n    // Check that length of t is between 1 and 100000\n    ensuref(1 <= int(t.length()) && int(t.length()) <= 100000, \"Length of t must be between 1 and 1e5, but t.length()=%d\", int(t.length()));\n    // Check that t consists only of lowercase Latin letters\n    for (char c : t)\n        ensuref('a' <= c && c <= 'z', \"String t must consist of lowercase letters, found '%c'\", c);\n\n    // Ensure there is no extra input\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    // Read the first line: string s\n    string s = inf.readLine();\n    // Check that length of s is between 1 and 100000\n    ensuref(1 <= int(s.length()) && int(s.length()) <= 100000, \"Length of s must be between 1 and 1e5, but s.length()=%d\", int(s.length()));\n    // Check that s consists only of lowercase Latin letters\n    for (char c : s)\n        ensuref('a' <= c && c <= 'z', \"String s must consist of lowercase letters, found '%c'\", c);\n\n    // Read the second line: string t\n    string t = inf.readLine();\n    // Check that length of t is between 1 and 100000\n    ensuref(1 <= int(t.length()) && int(t.length()) <= 100000, \"Length of t must be between 1 and 1e5, but t.length()=%d\", int(t.length()));\n    // Check that t consists only of lowercase Latin letters\n    for (char c : t)\n        ensuref('a' <= c && c <= 'z', \"String t must consist of lowercase letters, found '%c'\", c);\n\n    // Ensure there is no extra input\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAX_N = 100000;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string type = opt<string>(\"type\", \"random\");\n\n    // Ensure that n and m are within constraints\n    n = min(n, MAX_N);\n    n = max(n, 1);\n    m = min(m, MAX_N);\n    m = max(m, 1);\n\n    // Adjust n and m if necessary\n    if (n < m) {\n        if (type == \"same_strings\" || type == \"single_occurrence\") {\n            n = m;\n        } else {\n            m = n;\n        }\n    }\n\n    string s, t;\n\n    if (type == \"random\") {\n        // Generate random s and t\n        s.resize(n);\n        t.resize(m);\n        for(int i = 0; i < n; ++i)\n            s[i] = rnd.next('a', 'z');\n        for(int i = 0; i < m; ++i)\n            t[i] = rnd.next('a', 'z');\n\n    } else if (type == \"same_letters\") {\n        // Generate s and t consisting of the same letter\n        char c = rnd.next('a', 'z');\n        s = string(n, c);\n        t = string(m, c);\n\n    } else if (type == \"same_strings\") {\n        // s and t are the same\n        n = m;\n        t.resize(m);\n        for(int i = 0; i < m; ++i)\n            t[i] = rnd.next('a', 'z');\n        s = t;\n\n    } else if (type == \"no_match\") {\n        // t does not occur in s at all\n        s.resize(n);\n        t.resize(m);\n        do {\n            for(int i = 0; i < n; ++i)\n                s[i] = rnd.next('a', 'z');\n            for(int i = 0; i < m; ++i)\n                t[i] = rnd.next('a', 'z');\n        } while(s.find(t) != string::npos);\n\n    } else if (type == \"maximal_overlap\") {\n        // s is constructed to have maximum overlapping occurrences of t\n        if (m > n) {\n            m = n;\n        }\n        t = string(m, 'a');\n        s = string(n, 'a');\n    } else if (type == \"single_occurrence\") {\n        // t occurs exactly once in s\n        if (n < m) {\n            n = m;\n        }\n        s.resize(n);\n        for(int i = 0; i < n; ++i)\n            s[i] = rnd.next('a', 'z');\n        int pos = rnd.next(0, n - m);\n        t.resize(m);\n        for(int i = 0; i < m; ++i)\n            t[i] = rnd.next('a', 'z');\n        for(int i = 0; i < m; ++i)\n            s[pos + i] = t[i];\n        // Modify s to prevent t from occurring elsewhere\n        for(int i = 0; i + m <= n; ++i) {\n            if (i != pos) {\n                bool match = true;\n                for(int j = 0; j < m; ++j) {\n                    if (s[i + j] != t[j]) {\n                        match = false;\n                        break;\n                    }\n                }\n                if (match) {\n                    s[i + m / 2] = (s[i + m / 2] - 'a' + 1) % 26 + 'a';\n                }\n            }\n        }\n    } else {\n        // default to random\n        s.resize(n);\n        t.resize(m);\n        for(int i = 0; i < n; ++i)\n            s[i] = rnd.next('a', 'z');\n        for(int i = 0; i < m; ++i)\n            t[i] = rnd.next('a', 'z');\n    }\n\n    // Output s and t\n    cout << s << endl;\n    cout << t << endl;\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAX_N = 100000;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string type = opt<string>(\"type\", \"random\");\n\n    // Ensure that n and m are within constraints\n    n = min(n, MAX_N);\n    n = max(n, 1);\n    m = min(m, MAX_N);\n    m = max(m, 1);\n\n    // Adjust n and m if necessary\n    if (n < m) {\n        if (type == \"same_strings\" || type == \"single_occurrence\") {\n            n = m;\n        } else {\n            m = n;\n        }\n    }\n\n    string s, t;\n\n    if (type == \"random\") {\n        // Generate random s and t\n        s.resize(n);\n        t.resize(m);\n        for(int i = 0; i < n; ++i)\n            s[i] = rnd.next('a', 'z');\n        for(int i = 0; i < m; ++i)\n            t[i] = rnd.next('a', 'z');\n\n    } else if (type == \"same_letters\") {\n        // Generate s and t consisting of the same letter\n        char c = rnd.next('a', 'z');\n        s = string(n, c);\n        t = string(m, c);\n\n    } else if (type == \"same_strings\") {\n        // s and t are the same\n        n = m;\n        t.resize(m);\n        for(int i = 0; i < m; ++i)\n            t[i] = rnd.next('a', 'z');\n        s = t;\n\n    } else if (type == \"no_match\") {\n        // t does not occur in s at all\n        s.resize(n);\n        t.resize(m);\n        do {\n            for(int i = 0; i < n; ++i)\n                s[i] = rnd.next('a', 'z');\n            for(int i = 0; i < m; ++i)\n                t[i] = rnd.next('a', 'z');\n        } while(s.find(t) != string::npos);\n\n    } else if (type == \"maximal_overlap\") {\n        // s is constructed to have maximum overlapping occurrences of t\n        if (m > n) {\n            m = n;\n        }\n        t = string(m, 'a');\n        s = string(n, 'a');\n    } else if (type == \"single_occurrence\") {\n        // t occurs exactly once in s\n        if (n < m) {\n            n = m;\n        }\n        s.resize(n);\n        for(int i = 0; i < n; ++i)\n            s[i] = rnd.next('a', 'z');\n        int pos = rnd.next(0, n - m);\n        t.resize(m);\n        for(int i = 0; i < m; ++i)\n            t[i] = rnd.next('a', 'z');\n        for(int i = 0; i < m; ++i)\n            s[pos + i] = t[i];\n        // Modify s to prevent t from occurring elsewhere\n        for(int i = 0; i + m <= n; ++i) {\n            if (i != pos) {\n                bool match = true;\n                for(int j = 0; j < m; ++j) {\n                    if (s[i + j] != t[j]) {\n                        match = false;\n                        break;\n                    }\n                }\n                if (match) {\n                    s[i + m / 2] = (s[i + m / 2] - 'a' + 1) % 26 + 'a';\n                }\n            }\n        }\n    } else {\n        // default to random\n        s.resize(n);\n        t.resize(m);\n        for(int i = 0; i < n; ++i)\n            s[i] = rnd.next('a', 'z');\n        for(int i = 0; i < m; ++i)\n            t[i] = rnd.next('a', 'z');\n    }\n\n    // Output s and t\n    cout << s << endl;\n    cout << t << endl;\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -m 1 -type random\n./gen -n 1 -m 1 -type same_letters\n./gen -n 1 -m 1 -type same_strings\n./gen -n 1 -m 1 -type no_match\n./gen -n 1 -m 1 -type maximal_overlap\n./gen -n 1 -m 1 -type single_occurrence\n\n./gen -n 2 -m 1 -type random\n./gen -n 2 -m 1 -type same_letters\n./gen -n 2 -m 1 -type same_strings\n./gen -n 2 -m 1 -type no_match\n./gen -n 2 -m 1 -type maximal_overlap\n./gen -n 2 -m 1 -type single_occurrence\n\n./gen -n 10 -m 5 -type random\n./gen -n 10 -m 5 -type same_letters\n./gen -n 10 -m 5 -type same_strings\n./gen -n 10 -m 5 -type no_match\n./gen -n 10 -m 5 -type maximal_overlap\n./gen -n 10 -m 5 -type single_occurrence\n\n./gen -n 100 -m 50 -type random\n./gen -n 100 -m 50 -type same_letters\n./gen -n 100 -m 50 -type same_strings\n./gen -n 100 -m 50 -type no_match\n./gen -n 100 -m 50 -type maximal_overlap\n./gen -n 100 -m 50 -type single_occurrence\n\n./gen -n 1000 -m 500 -type random\n./gen -n 1000 -m 500 -type same_letters\n./gen -n 1000 -m 500 -type same_strings\n./gen -n 1000 -m 500 -type no_match\n./gen -n 1000 -m 500 -type maximal_overlap\n./gen -n 1000 -m 500 -type single_occurrence\n\n./gen -n 10000 -m 5000 -type random\n./gen -n 10000 -m 5000 -type same_letters\n./gen -n 10000 -m 5000 -type same_strings\n./gen -n 10000 -m 5000 -type no_match\n./gen -n 10000 -m 5000 -type maximal_overlap\n./gen -n 10000 -m 5000 -type single_occurrence\n\n./gen -n 100000 -m 50000 -type random\n./gen -n 100000 -m 50000 -type same_letters\n./gen -n 100000 -m 50000 -type same_strings\n./gen -n 100000 -m 50000 -type no_match\n./gen -n 100000 -m 50000 -type maximal_overlap\n./gen -n 100000 -m 50000 -type single_occurrence\n\n./gen -n 100000 -m 99999 -type maximal_overlap\n./gen -n 100000 -m 1 -type maximal_overlap\n\n./gen -n 100000 -m 99999 -type single_occurrence\n./gen -n 100000 -m 100000 -type same_strings\n\n./gen -n 100000 -m 1 -type same_letters\n./gen -n 100000 -m 1 -type single_occurrence\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:38:42.894291",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "494/C",
      "title": "C. Helping People",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test512 megabytes",
      "input_spec": "InputIn the first line two space-separated integers n, q (1 ≤ n ≤ 105, 1 ≤ q ≤ 5000) are given.In the second line n space-separated integers a1, a2, ..., an (0 ≤ ai ≤ 109) are given meaning that person number i initially has ai dollars. Each of the next q lines contains three space-separated numbers li, ri, pi (1 ≤ li ≤ ri ≤ n, 0 ≤ p ≤ 1) where li and ri are two integers describing the segment of recommendation and pi is a real number given with exactly three digits after decimal point which is equal to probability of Malek accepting this recommendation.Note that a segment may appear several times in recommendations.",
      "output_spec": "OutputOutput the sought value. Your answer will be considered correct if its absolute or relative error is less than 10 - 6.",
      "sample_tests": "ExamplesInputCopy5 21 7 2 4 31 3 0.5002 2 0.500OutputCopy8.000000000InputCopy5 2281 280 279 278 2821 4 1.0001 4 0.000OutputCopy282.000000000InputCopy3 51 2 31 3 0.5002 2 0.2501 2 0.8001 1 0.1202 2 0.900OutputCopy4.465000000",
      "description": "C. Helping People\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test512 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputIn the first line two space-separated integers n, q (1 ≤ n ≤ 105, 1 ≤ q ≤ 5000) are given.In the second line n space-separated integers a1, a2, ..., an (0 ≤ ai ≤ 109) are given meaning that person number i initially has ai dollars. Each of the next q lines contains three space-separated numbers li, ri, pi (1 ≤ li ≤ ri ≤ n, 0 ≤ p ≤ 1) where li and ri are two integers describing the segment of recommendation and pi is a real number given with exactly three digits after decimal point which is equal to probability of Malek accepting this recommendation.Note that a segment may appear several times in recommendations.\n\nOutputOutput the sought value. Your answer will be considered correct if its absolute or relative error is less than 10 - 6.\n\nInputCopy5 21 7 2 4 31 3 0.5002 2 0.500OutputCopy8.000000000InputCopy5 2281 280 279 278 2821 4 1.0001 4 0.000OutputCopy282.000000000InputCopy3 51 2 31 3 0.5002 2 0.2501 2 0.8001 1 0.1202 2 0.900OutputCopy4.465000000\n\nInputCopy5 21 7 2 4 31 3 0.5002 2 0.500\n\nOutputCopy8.000000000\n\nInputCopy5 2281 280 279 278 2821 4 1.0001 4 0.000\n\nOutputCopy282.000000000\n\nInputCopy3 51 2 31 3 0.5002 2 0.2501 2 0.8001 1 0.1202 2 0.900\n\nOutputCopy4.465000000",
      "solutions": [
        {
          "title": "Codeforces Round #282 - Codeforces",
          "content": "Hi, Codeforces Round #282 will be held at 13th of December, 19:30 MSK. Please don't note anything since the time is the usual time of contests.The round is prepared by FarbodY, Haghani and Me(matrix). We'd like to thank Zlobober who helped us a LOT for preparing the problems, MikeMirzayanov for the Polygon and Codeforces platforms and Delinur for helping us in preparing statements and translating them.Our special thanks goes to mruxim for testing the round.The problems will be sorted according to the estimated order of difficulty according to our opinion but we strongly recommend you to read all of the problems.As always the update regarding score distribution will be posted just before the round starts. :)UPD: It was written that contest starts at 20:00 MSK. it was a mistake and is fixed now. The round starts at usual time 19:30 MSK.UPD2: We also thank niyaznigmatul for testing our round.UPD3: Score distribution:Div1: 500-1000-1750-1750-2500Div2: 500-1000-1500-2000-2750As you might have noticed, the scores can now be multiples of 250 as well. Let's thank Codeforces team for adding this feature!Good luck and Have fun!UPD4: Congratulations to the winners of both divisions:Div1: tourist winger sankear uwi Egor Div2: Ginger88895 pwild arthurpd konmaj ezkatka The editorial for all problems except D and E Div1 are ready and can be found here. It'll be completed soon.We thank you all for participating and hope you had a good time.UPD5: The editorial is now complete and can be found here.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/15134",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1506
        },
        {
          "title": "Codeforces Round #282 Editorial - Codeforces",
          "content": "495A - Digital CounterFor each digit x you can count the number of digits y that because of some broken sticks x is shown instead of y by hand. for example when x = 3, y can be 3, 8 and 9. Let's denote this number by ax. Then if the input is xy (the first digit shown in the counter is x and the second is y) the answer will be ax × ay.495B - Modular Equations If a < b then there is no answer since . If a = b then x can be any integer larger than a. so there are infinite number of answers to the equation. The only remaining case is when a > b. Suppose x is an answer to our equation. Then x|a - b. Also since then b < x. These conditions are necessary and sufficient as well. So the answer is number of divisors of a - b which are strictly greater than b which can be solved in . 494A - TreasureConsider a string consisting of '(' and ')' characters. Let's build the following sequence from this string: a0 = 0 for each 1 ≤ i ≤ |s| ai = ai - 1 + 1 if si = '(' and ai = ai - 1 - 1 otherwise. (The string is considered as 1-based index). It can be proven that a string is beautiful if the following conditions are satisfied: for each 0 ≤ i ≤ |s| ai ≥ 0. a|s| = 0 Using the above fact we can prove that if in a beautiful string we remove a ')' character and put it further toward the end of the string the resulting string is beautiful as well. These facts leads us to the following fact: if we can move a ')' character further toward the end of string it is better if we'd do it. This yields the following greedy solution:We'll first put exactly one ')' character at each '#' character. Then we'll build the sequence we described above. if the first condition isn't satisfied then there is no way that leads to a beautiful string. So the answer is -1. Otherwise we must put exactly a|s| more ')' characters in the place of last '#' character. Then if this string is beautiful we'll print it otherwise the answer is -1.494B - Obsessive StringWe call an index i(1 ≤ i ≤ |s|) good if t equals si - |t| + 1si - |t| + 2... si. To find all good indexes let's define qi as the length of longest prefix of t which is a suffix of s1s2... si. A good index is an index with qi = |t|. Calculating qi can be done using Knuth-Morris-Pratt algorithm. Let's define ai as the number of ways to choose some(at least one) non-overlapping substrings of the prefix of s with length i (s1s2... si) so t is a substring of each one of them and si is in one the chosen substrings(So it must actually be the last character of last chosen substring). Then the answer will be .Also let's define two additional sequence q1 and q2 which will help us in calculating a.The sequence a can then be calculated in O(n) as described below:If i is not a good index ai = ai - 1 since in each way counted in ai the substring containing si also contains si - 1 so for each of these ways removing si from the substring containing it leads to a way counted in ai - 1 and vice-versa thus these two numbers are equal. If i is a good index then ai = q2i - |t| + i - |t| + 1. To prove this let's consider a way of choosing substring counted in ai. We call such a way valid. The substring containing si can be any of the substrings sjsj + 1... si (1 ≤ j ≤ i - |t| + 1). There are i - |t| + 1 valid ways in which this substring is the only substring we've chosen. Number of valid ways in which substring containing si starts at sj equals to q1j - 1. So the total number of valid ways in which we've chosen at least two substrings are equal to which is equal to q2j - 1. So ai = q2i - |t| + i - |t| + 1.494C - Helping PeopleWe'll first create a rooted tree from the given segments which each node represents a segment. We'll solve the problem using dynamic programming on this tree. First of all let's add a segment [1, n] with probability of being chosen by Malek equal to 0. The node representing this segment will be the root of the tree. Please note by adding this segment the rules described in the statements are still in place.Let's sort the rest of segments according to their starting point increasing and in case of equality according to their finishing point decreasing. Then we'll put the segment we added in the beginning. A segment's father is the right-most segment which comes before that segment and contains it. Please note that since we added segment [1, n] to the beginning every segment except the added segment has a father. We build the tree by putting a segment's node child of its father's node. In this tree for each two nodes u and v which none of them are in the subtree on another the segments representing these two nodes will not overlap. Also for each two nodes u and v which u is in subtree of v segment representing node u will be inside(not necessarily strictly) segment representing node v. We define mxi as the maximum money a person in the segment i initially has. mxi can be calculated using RMQ. Let's define ai, j as the probability of that after Malek finishes giving his money the maximum in the segment i is at most {mx}i + j. The properties of the tree we built allows us to calculate ai, j for every i and j in O(q2) (since 1 ≤ i, j ≤ q). If number of the segment we added is k then the answer will be . Calculating ai, j is described below:Suppose f is a child of i and suppose Malek doesn't accept the i-th recommendation. Then since we want the maximum number after money spreading to be at most mxi + j in segment i and since f is inside i we want the maximum number after money spreading to be at most mxi - mxf + j. If Malek accepts the recommendation then we want it to be at most mxi - mxf + j - 1. So if probability of i-th recommendation being accepted by Malek be equal to pi then . Using this formula we can calculate ak, j recursively and calculate the answer from it in O(q2). The overall complexity will be O(nlgn + q2). nlgn for creating RMQ used for calculating the array mx and q2 for the rest of the algorithm.494D - BirthdayWe solve this problem by answering queries offline. We'll first store in each vertex v number of vertices such as x for which we must calculate f(v, x) . starting from the root. We'll keep two arrays a and b. Suppose we're at vertex v right now then ai equals d(i, v)2 and bi equal d(i, v). Having these two arrays when moving from vertex v to a child with an edge with weight k one can note that bi for all is inside subtree of v decreases by k and all other bis gets increased by k. Knowing this fact one can also update array a as well. To calculate f(v, x) it's enough to be able to calculate sum of ais for all i inside subtree of x. Handling each of these operations is a well known problem and is possible using a segment tree. Overall complexity is O((n + q)lgn). There is an online solution using dynamic programming as well.494E - ShartiLet's first solve this problem for another game: Suppose that we've an n × n table. Each cell have some(possibly zero) marbles on it. During each move the player chooses a square with side-length at most k which its lower-right cell has at least one marble, he removes one marble from it and puts one marble in every other cell of this square. One can notice that in such game each marble is independent of the others and doesn't affect other marbles. So one can see this game as some separate games played on some tables. More formally for each marble placed in a cell such as (i, j) consider the game when played on a i × j table which the only marble placed on it is at its lower-right cell. Let's denote the Grundy number of this game by gi, j. Then according to Grundy theorem the first player has a winning strategy if and only if the xor of gi, j for every cell (i, j) having odd number of marbles on it is positive. To calculate gi, j note that the first move in such game must be choosing a square with its lower-right cell being the lower-right cell of table. So the only thing to decide is the side-length of chosen square at the first move. Let's say we choose the first square width side length l. Grundy number of the next state will be equal to xor of gc, d for every i - l < c ≤ i, j - l < d ≤ j. Using this fact one can calculate gi, j for all (1 ≤ i, j ≤ a) (a being an arbitrary integers) in O(a3).If we calculated the first values of gi, j one can see a pattern in the Grundy numbers. Then one can prove that gi, j = min(lowest_bit(i), lowest_bit(j), greatest_bit(k)) where lowest_bit(x) =  the maximum power of 2 which is a divisor of x and greatest_bit(x) =  the maximum power of 2 which is not greater than x. Now let's prove that our first game(the game described in the statement) is actually the same as this game. Suppose that a player has a winning strategy in the first game. Consider a table containing one marble at every cell which is white in the table of the first game. We'll prove that the same player has winning strategy in this game as well. Note that a cell is white in the first game if and only if the parity of marbles in the second game is odd so there is at least one marble on it. So as long as the other player chooses a square with its lower-right cell having odd number of marbles in the second game, his move corresponds to a move in the first game so the player having winning strategy can counter his move. If the other player chooses a square with its lower-right cell having even number of marbles, it means the cell had at least 2 marbles on it so the player can counter it by choosing the same square which makes the parity of every cell to be the same after these 2 moves. And since it can be proven that both of the game will end at some point then the player has winning strategy in this game as well. The reverse of this fact can also be proven the same since if a player has a winning strategy there is also a winning strategy in which this player always chooses squares with lower-right cell having odd number of marbles(since otherwise the other player can counter it as described above) and counters the moves of the other player at which he chose a square with lower-right cell having even number of marbles by choosing the same square(since the Grundy number by countering in this way won't change the Grundy number and thus won't change the player with winning strategy).So if we consider a table having one marble at each of the cells which are in at least one of the rectangles given in the input we only need to calculate the Grundy number of this state and check whether it's positive or not to determine the winner. To do this for each i(1 ≤ i ≤ greatest_bit(k)) lets define ai as the number of cells (x, y) which are contained in at least one of the given rectangles, 2i|x and 2i|y. Lets also define agreatest_bit(k) + 1 = 0. Then according the fact we described above about gi, j the number of 2is which are xored equals ai - ai + 1. Knowing this calculating the Grundy number of the initial state is easy. Calculating ai is identical to a very well-known problem which is given some rectangles count the number of cells in at least one of them and can be solved in O(mlgm) (m being number of rectangles). So overall complexity will be O(mlgmlgk).If there is any problem in the editorial please feel free to note that to us.Thank you.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/15148",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 494\\s*C"
          },
          "content_length": 11197
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #282 - Codeforces - Code 1",
          "code": "(#(\nAnswer: -1\nWA: 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15134",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #282 - Codeforces - Code 2",
          "code": "(#(\nAnswer: -1\nWA: 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15134",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #282 Editorial - Codeforces - Code 1",
          "code": "divisors of (a-b) greater than b",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15148",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #282 Editorial - Codeforces - Code 2",
          "code": "1 to sqrt(a-b)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15148",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #282 Editorial - Codeforces - Code 3",
          "code": "O(sqrt(a-b))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15148",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #282 Editorial - Codeforces - Code 4",
          "code": "input\n3 5\n1 2 3\n1 3 0.500\n2 2 0.250\n1 2 0.800\n1 1 0.120\n2 2 0.900\noutput\n4.465000000",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15148",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #282 Editorial - Codeforces - Code 5",
          "code": "input\n3 5\n1 2 3\n1 3 0.500\n2 2 0.250\n1 2 0.800\n1 1 0.120\n2 2 0.900\noutput\n4.465000000",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15148",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #282 Editorial - Codeforces - Code 6",
          "code": "using std::",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15148",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #282 Editorial - Codeforces - Code 7",
          "code": "using namespace std",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15148",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #282 Editorial - Codeforces - Code 8",
          "code": "#define next ____next\n#define prev ____prev\n#define y1   ____y1\n#define left ____left\n#define hash ____hash",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15148",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #282 Editorial - Codeforces - Code 9",
          "code": "#define next ____next\n#define prev ____prev\n#define y1   ____y1\n#define left ____left\n#define hash ____hash",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15148",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #282 Editorial - Codeforces - Code 10",
          "code": "#define max max<long long>",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15148",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #282 Editorial - Codeforces - Code 11",
          "code": "long long max(int a, long long b) { return max((long long)a, b); }\nlong long max(long long b, int a) { return max(a, (long long)b); }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15148",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #282 Editorial - Codeforces - Code 12",
          "code": "long long max(int a, long long b) { return max((long long)a, b); }\nlong long max(long long b, int a) { return max(a, (long long)b); }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15148",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #282 Editorial - Codeforces - Code 13",
          "code": "#define MAX(a,b) ((a)>(b)?(a):(b))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15148",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #282 Editorial - Codeforces - Code 14",
          "code": "#define MAX(a,b) ((a)>(b)?(a):(b))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15148",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #282 Editorial - Codeforces - Code 15",
          "code": "final string becomes beautiful",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15148",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #282 Editorial - Codeforces - Code 16",
          "code": "Node v = root",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15148",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #282 Editorial - Codeforces - Code 17",
          "code": "v = v.parent",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15148",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #282 Editorial - Codeforces - Code 18",
          "code": "input:\nddd\nd\noutput:\n12",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15148",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #282 Editorial - Codeforces - Code 19",
          "code": "input:\nddd\nd\noutput:\n12",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15148",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int q = inf.readInt(1, 5000, \"q\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, 0, 1000000000, \"a_i\");\n    inf.readEoln();\n\n    vector<int> L(q), R(q);\n    for (int i = 0; i < q; i++) {\n        int li = inf.readInt(1, n, \"l_i\");\n        inf.readSpace();\n        int ri = inf.readInt(li, n, \"r_i\");\n        inf.readSpace();\n\n        string pi_str = inf.readToken(\"(0\\\\.[0-9]{3}|1\\\\.000)\", \"p_i\");\n        inf.readEoln();\n\n        L[i] = li;\n        R[i] = ri;\n    }\n\n    for (int i = 0; i < q; i++) {\n        for (int j = i + 1; j < q; j++) {\n            int l1 = L[i];\n            int r1 = R[i];\n            int l2 = L[j];\n            int r2 = R[j];\n            if (r1 < l2 || r2 < l1) {\n                // Segments are completely disjoint\n                continue;\n            } else if ((l1 <= l2 && r2 <= r1) || (l2 <= l1 && r1 <= r2)) {\n                // One segment is inside another\n                continue;\n            } else {\n                quitf(_fail, \"Segments %d [%d, %d] and %d [%d, %d] violate the constraints\", i+1, l1, r1, j+1, l2, r2);\n            }\n        }\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int q = inf.readInt(1, 5000, \"q\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, 0, 1000000000, \"a_i\");\n    inf.readEoln();\n\n    vector<int> L(q), R(q);\n    for (int i = 0; i < q; i++) {\n        int li = inf.readInt(1, n, \"l_i\");\n        inf.readSpace();\n        int ri = inf.readInt(li, n, \"r_i\");\n        inf.readSpace();\n\n        string pi_str = inf.readToken(\"(0\\\\.[0-9]{3}|1\\\\.000)\", \"p_i\");\n        inf.readEoln();\n\n        L[i] = li;\n        R[i] = ri;\n    }\n\n    for (int i = 0; i < q; i++) {\n        for (int j = i + 1; j < q; j++) {\n            int l1 = L[i];\n            int r1 = R[i];\n            int l2 = L[j];\n            int r2 = R[j];\n            if (r1 < l2 || r2 < l1) {\n                // Segments are completely disjoint\n                continue;\n            } else if ((l1 <= l2 && r2 <= r1) || (l2 <= l1 && r1 <= r2)) {\n                // One segment is inside another\n                continue;\n            } else {\n                quitf(_fail, \"Segments %d [%d, %d] and %d [%d, %d] violate the constraints\", i+1, l1, r1, j+1, l2, r2);\n            }\n        }\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int q = inf.readInt(1, 5000, \"q\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, 0, 1000000000, \"a_i\");\n    inf.readEoln();\n\n    vector<int> L(q), R(q);\n    for (int i = 0; i < q; i++) {\n        int li = inf.readInt(1, n, \"l_i\");\n        inf.readSpace();\n        int ri = inf.readInt(li, n, \"r_i\");\n        inf.readSpace();\n\n        string pi_str = inf.readToken(\"(0\\\\.[0-9]{3}|1\\\\.000)\", \"p_i\");\n        inf.readEoln();\n\n        L[i] = li;\n        R[i] = ri;\n    }\n\n    for (int i = 0; i < q; i++) {\n        for (int j = i + 1; j < q; j++) {\n            int l1 = L[i];\n            int r1 = R[i];\n            int l2 = L[j];\n            int r2 = R[j];\n            if (r1 < l2 || r2 < l1) {\n                // Segments are completely disjoint\n                continue;\n            } else if ((l1 <= l2 && r2 <= r1) || (l2 <= l1 && r1 <= r2)) {\n                // One segment is inside another\n                continue;\n            } else {\n                quitf(_fail, \"Segments %d [%d, %d] and %d [%d, %d] violate the constraints\", i+1, l1, r1, j+1, l2, r2);\n            }\n        }\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nconst double EPS = 1E-6;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare two sequences of doubles, max absolute or relative  error = %.7f\", EPS);\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    double j = 0, p = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        n++;\r\n        j = ans.readDouble();\r\n        p = ouf.readDouble();\r\n        if (!doubleCompare(j, p, EPS)) {\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%.7f', found: '%.7f', error = '%.7f'\",\r\n                  n, englishEnding(n).c_str(), j, p, doubleDelta(j, p));\r\n        }\r\n    }\r\n\r\n    if (n == 1)\r\n        quitf(_ok, \"found '%.7f', expected '%.7f', error '%.7f'\", p, j, doubleDelta(j, p));\r\n\r\n    quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    int n = opt<int>(\"n\");\n    int q = opt<int>(\"q\");\n    string type = opt<string>(\"type\", \"random\");\n    string initial_amount = opt<string>(\"initial_amount\", \"random\");\n    string prob_type = opt<string>(\"prob_type\", \"random\");\n    \n    ensure(q <= n);\n\n    vector<int> ai(n);\n    if (initial_amount == \"zero\") {\n        for (int i = 0; i < n; ++i)\n            ai[i] = 0;\n    } else if (initial_amount == \"max\") {\n        for (int i = 0; i < n; ++i)\n            ai[i] = 1000000000;\n    } else if (initial_amount == \"random\") {\n        for (int i = 0; i < n; ++i)\n            ai[i] = rnd.next(0, 1000000000);\n    }\n\n    vector<pair<int, int>> segments;\n    if (type == \"nested\") {\n        int l = 1, r = n;\n        segments.push_back({l, r});\n        for (int i = 1; i < q; ++i) {\n            if (l < r) {\n                int nl = rnd.next(l, r);\n                int nr = rnd.next(nl, r);\n                l = nl;\n                r = nr;\n            }\n            segments.push_back({l, r});\n        }\n    } else if (type == \"disjoint\") {\n        // Divide the range 1..n into q disjoint positions\n        ensure(q <= n);\n        vector<int> positions(n);\n        for (int i = 0; i < n; ++i)\n            positions[i] = i + 1;\n        shuffle(positions.begin(), positions.end());\n        sort(positions.begin(), positions.begin() + q);\n        for (int i = 0; i < q; ++i) {\n            int p = positions[i];\n            segments.push_back({p, p});\n        }\n    } else {\n        // default to nested segments\n        int l = rnd.next(1, n);\n        int r = rnd.next(l, n);\n        segments.push_back({l, r});\n        for (int i = 1; i < q; ++i) {\n            if (l < r) {\n                int nl = rnd.next(l, r);\n                int nr = rnd.next(nl, r);\n                l = nl;\n                r = nr;\n            }\n            segments.push_back({l, r});\n        }\n    }\n\n    // Now generate probabilities\n\n    vector<double> probs(q);\n    if (prob_type == \"zero_one\") {\n        for (int i = 0; i < q; ++i) {\n            probs[i] = rnd.next(0, 1) == 0 ? 0.000 : 1.000;\n        }\n    } else if (prob_type == \"max_precision\") {\n        for (int i = 0; i < q; ++i) {\n            probs[i] = rnd.next(0, 1000) / 1000.0;\n        }\n    } else {\n        for (int i = 0; i < q; ++i) {\n            probs[i] = rnd.next(0, 1000) / 1000.0;\n        }\n    }\n\n    // Output n and q\n    printf(\"%d %d\\n\", n, q);\n    // Output ai\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d%c\", ai[i], i == n - 1 ? '\\n' : ' ');\n    }\n    // Output recommendations\n    for (int i = 0; i < q; ++i) {\n        printf(\"%d %d %.3f\\n\", segments[i].first, segments[i].second, probs[i]);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    int n = opt<int>(\"n\");\n    int q = opt<int>(\"q\");\n    string type = opt<string>(\"type\", \"random\");\n    string initial_amount = opt<string>(\"initial_amount\", \"random\");\n    string prob_type = opt<string>(\"prob_type\", \"random\");\n    \n    ensure(q <= n);\n\n    vector<int> ai(n);\n    if (initial_amount == \"zero\") {\n        for (int i = 0; i < n; ++i)\n            ai[i] = 0;\n    } else if (initial_amount == \"max\") {\n        for (int i = 0; i < n; ++i)\n            ai[i] = 1000000000;\n    } else if (initial_amount == \"random\") {\n        for (int i = 0; i < n; ++i)\n            ai[i] = rnd.next(0, 1000000000);\n    }\n\n    vector<pair<int, int>> segments;\n    if (type == \"nested\") {\n        int l = 1, r = n;\n        segments.push_back({l, r});\n        for (int i = 1; i < q; ++i) {\n            if (l < r) {\n                int nl = rnd.next(l, r);\n                int nr = rnd.next(nl, r);\n                l = nl;\n                r = nr;\n            }\n            segments.push_back({l, r});\n        }\n    } else if (type == \"disjoint\") {\n        // Divide the range 1..n into q disjoint positions\n        ensure(q <= n);\n        vector<int> positions(n);\n        for (int i = 0; i < n; ++i)\n            positions[i] = i + 1;\n        shuffle(positions.begin(), positions.end());\n        sort(positions.begin(), positions.begin() + q);\n        for (int i = 0; i < q; ++i) {\n            int p = positions[i];\n            segments.push_back({p, p});\n        }\n    } else {\n        // default to nested segments\n        int l = rnd.next(1, n);\n        int r = rnd.next(l, n);\n        segments.push_back({l, r});\n        for (int i = 1; i < q; ++i) {\n            if (l < r) {\n                int nl = rnd.next(l, r);\n                int nr = rnd.next(nl, r);\n                l = nl;\n                r = nr;\n            }\n            segments.push_back({l, r});\n        }\n    }\n\n    // Now generate probabilities\n\n    vector<double> probs(q);\n    if (prob_type == \"zero_one\") {\n        for (int i = 0; i < q; ++i) {\n            probs[i] = rnd.next(0, 1) == 0 ? 0.000 : 1.000;\n        }\n    } else if (prob_type == \"max_precision\") {\n        for (int i = 0; i < q; ++i) {\n            probs[i] = rnd.next(0, 1000) / 1000.0;\n        }\n    } else {\n        for (int i = 0; i < q; ++i) {\n            probs[i] = rnd.next(0, 1000) / 1000.0;\n        }\n    }\n\n    // Output n and q\n    printf(\"%d %d\\n\", n, q);\n    // Output ai\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d%c\", ai[i], i == n - 1 ? '\\n' : ' ');\n    }\n    // Output recommendations\n    for (int i = 0; i < q; ++i) {\n        printf(\"%d %d %.3f\\n\", segments[i].first, segments[i].second, probs[i]);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -q 1 -type nested -initial_amount zero -prob_type zero_one\n./gen -n 1 -q 1 -type disjoint -initial_amount max -prob_type zero_one\n./gen -n 10 -q 5 -type nested -initial_amount zero -prob_type zero_one\n./gen -n 10 -q 5 -type disjoint -initial_amount random -prob_type random\n./gen -n 100 -q 50 -type nested -initial_amount random -prob_type zero_one\n./gen -n 100 -q 50 -type disjoint -initial_amount zero -prob_type max_precision\n./gen -n 1000 -q 100 -type nested -initial_amount max -prob_type random\n./gen -n 1000 -q 100 -type disjoint -initial_amount zero -prob_type zero_one\n./gen -n 10000 -q 500 -type nested -initial_amount random -prob_type max_precision\n./gen -n 10000 -q 500 -type disjoint -initial_amount max -prob_type zero_one\n./gen -n 50000 -q 1000 -type nested -initial_amount max -prob_type random\n./gen -n 50000 -q 1000 -type disjoint -initial_amount random -prob_type random\n./gen -n 99999 -q 5000 -type nested -initial_amount random -prob_type random\n./gen -n 99999 -q 5000 -type disjoint -initial_amount random -prob_type random\n./gen -n 100000 -q 5000 -type nested -initial_amount max -prob_type random\n./gen -n 100000 -q 5000 -type disjoint -initial_amount max -prob_type zero_one\n./gen -n 100000 -q 1 -type nested -initial_amount random -prob_type zero_one\n./gen -n 50000 -q 1 -type nested -initial_amount zero -prob_type max_precision\n./gen -n 5000 -q 5000 -type nested -initial_amount max -prob_type zero_one\n./gen -n 5000 -q 5000 -type disjoint -initial_amount random -prob_type random\n./gen -n 100000 -q 5000 -type nested -initial_amount zero -prob_type max_precision\n./gen -n 100000 -q 5000 -type disjoint -initial_amount zero -prob_type zero_one\n./gen -n 1 -q 1 -type nested -initial_amount random -prob_type random\n./gen -n 2 -q 2 -type disjoint -initial_amount zero -prob_type zero_one\n./gen -n 3 -q 2 -type nested -initial_amount max -prob_type max_precision\n./gen -n 4 -q 3 -type disjoint -initial_amount random -prob_type random\n./gen -n 100000 -q 5000 -type nested -initial_amount random -prob_type random\n./gen -n 100000 -q 5000 -type disjoint -initial_amount random -prob_type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:38:44.862668",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "494/D",
      "title": "D. Birthday",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputIn the first line of input an integer n (1 ≤ n ≤ 105), number of vertices of the tree is given.In each of the next n - 1 lines three space-separated integers ai, bi, ci (1 ≤ ai, bi ≤ n, 1 ≤ ci ≤ 109) are given indicating an edge between ai and bi with weight equal to ci.In the next line an integer q (1 ≤ q ≤ 105), number of vertex pairs, is given.In each of the next q lines two space-separated integers ui, vi (1 ≤ ui, vi ≤ n) are given meaning that you must calculate f(ui, vi).It is guaranteed that the given edges form a tree.",
      "output_spec": "OutputOutput q lines. In the i-th line print the value of f(ui, vi) modulo 109 + 7.",
      "sample_tests": "ExamplesInputCopy51 2 14 3 13 5 11 3 151 11 52 42 13 5OutputCopy1010000000051000000002231000000002InputCopy81 2 1001 3 202 4 22 5 13 6 13 7 26 8 561 82 35 82 64 76 1OutputCopy9999687534979699996127199999123599995856945130",
      "description": "D. Birthday\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputIn the first line of input an integer n (1 ≤ n ≤ 105), number of vertices of the tree is given.In each of the next n - 1 lines three space-separated integers ai, bi, ci (1 ≤ ai, bi ≤ n, 1 ≤ ci ≤ 109) are given indicating an edge between ai and bi with weight equal to ci.In the next line an integer q (1 ≤ q ≤ 105), number of vertex pairs, is given.In each of the next q lines two space-separated integers ui, vi (1 ≤ ui, vi ≤ n) are given meaning that you must calculate f(ui, vi).It is guaranteed that the given edges form a tree.\n\nOutputOutput q lines. In the i-th line print the value of f(ui, vi) modulo 109 + 7.\n\nInputCopy51 2 14 3 13 5 11 3 151 11 52 42 13 5OutputCopy1010000000051000000002231000000002InputCopy81 2 1001 3 202 4 22 5 13 6 13 7 26 8 561 82 35 82 64 76 1OutputCopy9999687534979699996127199999123599995856945130\n\nInputCopy51 2 14 3 13 5 11 3 151 11 52 42 13 5\n\nOutputCopy1010000000051000000002231000000002\n\nInputCopy81 2 1001 3 202 4 22 5 13 6 13 7 26 8 561 82 35 82 64 76 1\n\nOutputCopy9999687534979699996127199999123599995856945130",
      "solutions": [
        {
          "title": "Codeforces Round #282 - Codeforces",
          "content": "Hi, Codeforces Round #282 will be held at 13th of December, 19:30 MSK. Please don't note anything since the time is the usual time of contests.The round is prepared by FarbodY, Haghani and Me(matrix). We'd like to thank Zlobober who helped us a LOT for preparing the problems, MikeMirzayanov for the Polygon and Codeforces platforms and Delinur for helping us in preparing statements and translating them.Our special thanks goes to mruxim for testing the round.The problems will be sorted according to the estimated order of difficulty according to our opinion but we strongly recommend you to read all of the problems.As always the update regarding score distribution will be posted just before the round starts. :)UPD: It was written that contest starts at 20:00 MSK. it was a mistake and is fixed now. The round starts at usual time 19:30 MSK.UPD2: We also thank niyaznigmatul for testing our round.UPD3: Score distribution:Div1: 500-1000-1750-1750-2500Div2: 500-1000-1500-2000-2750As you might have noticed, the scores can now be multiples of 250 as well. Let's thank Codeforces team for adding this feature!Good luck and Have fun!UPD4: Congratulations to the winners of both divisions:Div1: tourist winger sankear uwi Egor Div2: Ginger88895 pwild arthurpd konmaj ezkatka The editorial for all problems except D and E Div1 are ready and can be found here. It'll be completed soon.We thank you all for participating and hope you had a good time.UPD5: The editorial is now complete and can be found here.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/15134",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1506
        },
        {
          "title": "Codeforces Round #282 Editorial - Codeforces",
          "content": "495A - Digital CounterFor each digit x you can count the number of digits y that because of some broken sticks x is shown instead of y by hand. for example when x = 3, y can be 3, 8 and 9. Let's denote this number by ax. Then if the input is xy (the first digit shown in the counter is x and the second is y) the answer will be ax × ay.495B - Modular Equations If a < b then there is no answer since . If a = b then x can be any integer larger than a. so there are infinite number of answers to the equation. The only remaining case is when a > b. Suppose x is an answer to our equation. Then x|a - b. Also since then b < x. These conditions are necessary and sufficient as well. So the answer is number of divisors of a - b which are strictly greater than b which can be solved in . 494A - TreasureConsider a string consisting of '(' and ')' characters. Let's build the following sequence from this string: a0 = 0 for each 1 ≤ i ≤ |s| ai = ai - 1 + 1 if si = '(' and ai = ai - 1 - 1 otherwise. (The string is considered as 1-based index). It can be proven that a string is beautiful if the following conditions are satisfied: for each 0 ≤ i ≤ |s| ai ≥ 0. a|s| = 0 Using the above fact we can prove that if in a beautiful string we remove a ')' character and put it further toward the end of the string the resulting string is beautiful as well. These facts leads us to the following fact: if we can move a ')' character further toward the end of string it is better if we'd do it. This yields the following greedy solution:We'll first put exactly one ')' character at each '#' character. Then we'll build the sequence we described above. if the first condition isn't satisfied then there is no way that leads to a beautiful string. So the answer is -1. Otherwise we must put exactly a|s| more ')' characters in the place of last '#' character. Then if this string is beautiful we'll print it otherwise the answer is -1.494B - Obsessive StringWe call an index i(1 ≤ i ≤ |s|) good if t equals si - |t| + 1si - |t| + 2... si. To find all good indexes let's define qi as the length of longest prefix of t which is a suffix of s1s2... si. A good index is an index with qi = |t|. Calculating qi can be done using Knuth-Morris-Pratt algorithm. Let's define ai as the number of ways to choose some(at least one) non-overlapping substrings of the prefix of s with length i (s1s2... si) so t is a substring of each one of them and si is in one the chosen substrings(So it must actually be the last character of last chosen substring). Then the answer will be .Also let's define two additional sequence q1 and q2 which will help us in calculating a.The sequence a can then be calculated in O(n) as described below:If i is not a good index ai = ai - 1 since in each way counted in ai the substring containing si also contains si - 1 so for each of these ways removing si from the substring containing it leads to a way counted in ai - 1 and vice-versa thus these two numbers are equal. If i is a good index then ai = q2i - |t| + i - |t| + 1. To prove this let's consider a way of choosing substring counted in ai. We call such a way valid. The substring containing si can be any of the substrings sjsj + 1... si (1 ≤ j ≤ i - |t| + 1). There are i - |t| + 1 valid ways in which this substring is the only substring we've chosen. Number of valid ways in which substring containing si starts at sj equals to q1j - 1. So the total number of valid ways in which we've chosen at least two substrings are equal to which is equal to q2j - 1. So ai = q2i - |t| + i - |t| + 1.494C - Helping PeopleWe'll first create a rooted tree from the given segments which each node represents a segment. We'll solve the problem using dynamic programming on this tree. First of all let's add a segment [1, n] with probability of being chosen by Malek equal to 0. The node representing this segment will be the root of the tree. Please note by adding this segment the rules described in the statements are still in place.Let's sort the rest of segments according to their starting point increasing and in case of equality according to their finishing point decreasing. Then we'll put the segment we added in the beginning. A segment's father is the right-most segment which comes before that segment and contains it. Please note that since we added segment [1, n] to the beginning every segment except the added segment has a father. We build the tree by putting a segment's node child of its father's node. In this tree for each two nodes u and v which none of them are in the subtree on another the segments representing these two nodes will not overlap. Also for each two nodes u and v which u is in subtree of v segment representing node u will be inside(not necessarily strictly) segment representing node v. We define mxi as the maximum money a person in the segment i initially has. mxi can be calculated using RMQ. Let's define ai, j as the probability of that after Malek finishes giving his money the maximum in the segment i is at most {mx}i + j. The properties of the tree we built allows us to calculate ai, j for every i and j in O(q2) (since 1 ≤ i, j ≤ q). If number of the segment we added is k then the answer will be . Calculating ai, j is described below:Suppose f is a child of i and suppose Malek doesn't accept the i-th recommendation. Then since we want the maximum number after money spreading to be at most mxi + j in segment i and since f is inside i we want the maximum number after money spreading to be at most mxi - mxf + j. If Malek accepts the recommendation then we want it to be at most mxi - mxf + j - 1. So if probability of i-th recommendation being accepted by Malek be equal to pi then . Using this formula we can calculate ak, j recursively and calculate the answer from it in O(q2). The overall complexity will be O(nlgn + q2). nlgn for creating RMQ used for calculating the array mx and q2 for the rest of the algorithm.494D - BirthdayWe solve this problem by answering queries offline. We'll first store in each vertex v number of vertices such as x for which we must calculate f(v, x) . starting from the root. We'll keep two arrays a and b. Suppose we're at vertex v right now then ai equals d(i, v)2 and bi equal d(i, v). Having these two arrays when moving from vertex v to a child with an edge with weight k one can note that bi for all is inside subtree of v decreases by k and all other bis gets increased by k. Knowing this fact one can also update array a as well. To calculate f(v, x) it's enough to be able to calculate sum of ais for all i inside subtree of x. Handling each of these operations is a well known problem and is possible using a segment tree. Overall complexity is O((n + q)lgn). There is an online solution using dynamic programming as well.494E - ShartiLet's first solve this problem for another game: Suppose that we've an n × n table. Each cell have some(possibly zero) marbles on it. During each move the player chooses a square with side-length at most k which its lower-right cell has at least one marble, he removes one marble from it and puts one marble in every other cell of this square. One can notice that in such game each marble is independent of the others and doesn't affect other marbles. So one can see this game as some separate games played on some tables. More formally for each marble placed in a cell such as (i, j) consider the game when played on a i × j table which the only marble placed on it is at its lower-right cell. Let's denote the Grundy number of this game by gi, j. Then according to Grundy theorem the first player has a winning strategy if and only if the xor of gi, j for every cell (i, j) having odd number of marbles on it is positive. To calculate gi, j note that the first move in such game must be choosing a square with its lower-right cell being the lower-right cell of table. So the only thing to decide is the side-length of chosen square at the first move. Let's say we choose the first square width side length l. Grundy number of the next state will be equal to xor of gc, d for every i - l < c ≤ i, j - l < d ≤ j. Using this fact one can calculate gi, j for all (1 ≤ i, j ≤ a) (a being an arbitrary integers) in O(a3).If we calculated the first values of gi, j one can see a pattern in the Grundy numbers. Then one can prove that gi, j = min(lowest_bit(i), lowest_bit(j), greatest_bit(k)) where lowest_bit(x) =  the maximum power of 2 which is a divisor of x and greatest_bit(x) =  the maximum power of 2 which is not greater than x. Now let's prove that our first game(the game described in the statement) is actually the same as this game. Suppose that a player has a winning strategy in the first game. Consider a table containing one marble at every cell which is white in the table of the first game. We'll prove that the same player has winning strategy in this game as well. Note that a cell is white in the first game if and only if the parity of marbles in the second game is odd so there is at least one marble on it. So as long as the other player chooses a square with its lower-right cell having odd number of marbles in the second game, his move corresponds to a move in the first game so the player having winning strategy can counter his move. If the other player chooses a square with its lower-right cell having even number of marbles, it means the cell had at least 2 marbles on it so the player can counter it by choosing the same square which makes the parity of every cell to be the same after these 2 moves. And since it can be proven that both of the game will end at some point then the player has winning strategy in this game as well. The reverse of this fact can also be proven the same since if a player has a winning strategy there is also a winning strategy in which this player always chooses squares with lower-right cell having odd number of marbles(since otherwise the other player can counter it as described above) and counters the moves of the other player at which he chose a square with lower-right cell having even number of marbles by choosing the same square(since the Grundy number by countering in this way won't change the Grundy number and thus won't change the player with winning strategy).So if we consider a table having one marble at each of the cells which are in at least one of the rectangles given in the input we only need to calculate the Grundy number of this state and check whether it's positive or not to determine the winner. To do this for each i(1 ≤ i ≤ greatest_bit(k)) lets define ai as the number of cells (x, y) which are contained in at least one of the given rectangles, 2i|x and 2i|y. Lets also define agreatest_bit(k) + 1 = 0. Then according the fact we described above about gi, j the number of 2is which are xored equals ai - ai + 1. Knowing this calculating the Grundy number of the initial state is easy. Calculating ai is identical to a very well-known problem which is given some rectangles count the number of cells in at least one of them and can be solved in O(mlgm) (m being number of rectangles). So overall complexity will be O(mlgmlgk).If there is any problem in the editorial please feel free to note that to us.Thank you.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/15148",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 494\\s*D"
          },
          "content_length": 11197
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #282 - Codeforces - Code 1",
          "code": "(#(\nAnswer: -1\nWA: 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15134",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #282 - Codeforces - Code 2",
          "code": "(#(\nAnswer: -1\nWA: 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15134",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #282 Editorial - Codeforces - Code 1",
          "code": "divisors of (a-b) greater than b",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15148",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #282 Editorial - Codeforces - Code 2",
          "code": "1 to sqrt(a-b)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15148",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #282 Editorial - Codeforces - Code 3",
          "code": "O(sqrt(a-b))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15148",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #282 Editorial - Codeforces - Code 4",
          "code": "input\n3 5\n1 2 3\n1 3 0.500\n2 2 0.250\n1 2 0.800\n1 1 0.120\n2 2 0.900\noutput\n4.465000000",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15148",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #282 Editorial - Codeforces - Code 5",
          "code": "input\n3 5\n1 2 3\n1 3 0.500\n2 2 0.250\n1 2 0.800\n1 1 0.120\n2 2 0.900\noutput\n4.465000000",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15148",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #282 Editorial - Codeforces - Code 6",
          "code": "using std::",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15148",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #282 Editorial - Codeforces - Code 7",
          "code": "using namespace std",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15148",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #282 Editorial - Codeforces - Code 8",
          "code": "#define next ____next\n#define prev ____prev\n#define y1   ____y1\n#define left ____left\n#define hash ____hash",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15148",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #282 Editorial - Codeforces - Code 9",
          "code": "#define next ____next\n#define prev ____prev\n#define y1   ____y1\n#define left ____left\n#define hash ____hash",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15148",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #282 Editorial - Codeforces - Code 10",
          "code": "#define max max<long long>",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15148",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #282 Editorial - Codeforces - Code 11",
          "code": "long long max(int a, long long b) { return max((long long)a, b); }\nlong long max(long long b, int a) { return max(a, (long long)b); }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15148",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #282 Editorial - Codeforces - Code 12",
          "code": "long long max(int a, long long b) { return max((long long)a, b); }\nlong long max(long long b, int a) { return max(a, (long long)b); }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15148",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #282 Editorial - Codeforces - Code 13",
          "code": "#define MAX(a,b) ((a)>(b)?(a):(b))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15148",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #282 Editorial - Codeforces - Code 14",
          "code": "#define MAX(a,b) ((a)>(b)?(a):(b))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15148",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #282 Editorial - Codeforces - Code 15",
          "code": "final string becomes beautiful",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15148",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #282 Editorial - Codeforces - Code 16",
          "code": "Node v = root",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15148",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #282 Editorial - Codeforces - Code 17",
          "code": "v = v.parent",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15148",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #282 Editorial - Codeforces - Code 18",
          "code": "input:\nddd\nd\noutput:\n12",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15148",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #282 Editorial - Codeforces - Code 19",
          "code": "input:\nddd\nd\noutput:\n12",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15148",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int MAXN = 100000;\n\nint parent[MAXN + 1];\n\nint find_set(int v) {\n    if (parent[v] == v)\n        return v;\n    return parent[v] = find_set(parent[v]);\n}\n\nbool union_sets(int a, int b) {\n    a = find_set(a);\n    b = find_set(b);\n    if (a == b)\n        return false; // there is a cycle\n    parent[b] = a;\n    return true;\n}\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    \n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n    \n    for (int i = 1; i <= n; ++i)\n        parent[i] = i;\n    \n    for (int i = 0; i < n - 1; ++i) {\n        int a = inf.readInt(1, n, \"ai\");\n        inf.readSpace();\n        int b = inf.readInt(1, n, \"bi\");\n        inf.readSpace();\n        int c = inf.readInt(1, 1000000000, \"ci\");\n        inf.readEoln();\n        \n        ensuref(a != b, \"Edge %d is a self-loop: %d %d\", i+1, a, b);\n        \n        bool ok = union_sets(a, b);\n        ensuref(ok, \"Edge %d creates a cycle: %d %d\", i+1, a, b);\n    }\n    \n    // After processing all edges, check that the graph is connected\n    int root = find_set(1);\n    for (int i = 2; i <= n; ++i) {\n        ensuref(find_set(i) == root, \"Graph is not connected\");\n    }\n    \n    int q = inf.readInt(1, 100000, \"q\");\n    inf.readEoln();\n    \n    for (int i = 0; i < q; ++i) {\n        int u = inf.readInt(1, n, \"ui\");\n        inf.readSpace();\n        int v = inf.readInt(1, n, \"vi\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int MAXN = 100000;\n\nint parent[MAXN + 1];\n\nint find_set(int v) {\n    if (parent[v] == v)\n        return v;\n    return parent[v] = find_set(parent[v]);\n}\n\nbool union_sets(int a, int b) {\n    a = find_set(a);\n    b = find_set(b);\n    if (a == b)\n        return false; // there is a cycle\n    parent[b] = a;\n    return true;\n}\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    \n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n    \n    for (int i = 1; i <= n; ++i)\n        parent[i] = i;\n    \n    for (int i = 0; i < n - 1; ++i) {\n        int a = inf.readInt(1, n, \"ai\");\n        inf.readSpace();\n        int b = inf.readInt(1, n, \"bi\");\n        inf.readSpace();\n        int c = inf.readInt(1, 1000000000, \"ci\");\n        inf.readEoln();\n        \n        ensuref(a != b, \"Edge %d is a self-loop: %d %d\", i+1, a, b);\n        \n        bool ok = union_sets(a, b);\n        ensuref(ok, \"Edge %d creates a cycle: %d %d\", i+1, a, b);\n    }\n    \n    // After processing all edges, check that the graph is connected\n    int root = find_set(1);\n    for (int i = 2; i <= n; ++i) {\n        ensuref(find_set(i) == root, \"Graph is not connected\");\n    }\n    \n    int q = inf.readInt(1, 100000, \"q\");\n    inf.readEoln();\n    \n    for (int i = 0; i < q; ++i) {\n        int u = inf.readInt(1, n, \"ui\");\n        inf.readSpace();\n        int v = inf.readInt(1, n, \"vi\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int MAXN = 100000;\n\nint parent[MAXN + 1];\n\nint find_set(int v) {\n    if (parent[v] == v)\n        return v;\n    return parent[v] = find_set(parent[v]);\n}\n\nbool union_sets(int a, int b) {\n    a = find_set(a);\n    b = find_set(b);\n    if (a == b)\n        return false; // there is a cycle\n    parent[b] = a;\n    return true;\n}\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    \n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n    \n    for (int i = 1; i <= n; ++i)\n        parent[i] = i;\n    \n    for (int i = 0; i < n - 1; ++i) {\n        int a = inf.readInt(1, n, \"ai\");\n        inf.readSpace();\n        int b = inf.readInt(1, n, \"bi\");\n        inf.readSpace();\n        int c = inf.readInt(1, 1000000000, \"ci\");\n        inf.readEoln();\n        \n        ensuref(a != b, \"Edge %d is a self-loop: %d %d\", i+1, a, b);\n        \n        bool ok = union_sets(a, b);\n        ensuref(ok, \"Edge %d creates a cycle: %d %d\", i+1, a, b);\n    }\n    \n    // After processing all edges, check that the graph is connected\n    int root = find_set(1);\n    for (int i = 2; i <= n; ++i) {\n        ensuref(find_set(i) == root, \"Graph is not connected\");\n    }\n    \n    int q = inf.readInt(1, 100000, \"q\");\n    inf.readEoln();\n    \n    for (int i = 0; i < q; ++i) {\n        int u = inf.readInt(1, n, \"ui\");\n        inf.readSpace();\n        int v = inf.readInt(1, n, \"vi\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    // Parse options\n    int n = opt<int>(\"n\");\n    int q = opt<int>(\"q\", n); // By default, set q = n\n    string tree_type = opt<string>(\"tree_type\", \"random\");\n    string weight_type = opt<string>(\"weight_type\", \"random\");\n    int min_weight = opt<int>(\"min_weight\", 1);\n    int max_weight = opt<int>(\"max_weight\", (int)1e9);\n    string query_type = opt<string>(\"query_type\", \"random\");\n\n    // Generate tree according to tree_type\n    vector<int> p(n + 1); // Parent array\n    vector<pair<int, int>> edges;\n    p[1] = 0; // Root node has no parent\n\n    if (tree_type == \"chain\") {\n        for (int i = 2; i <= n; ++i) {\n            p[i] = i - 1;\n        }\n    } else if (tree_type == \"star\") {\n        for (int i = 2; i <= n; ++i) {\n            p[i] = 1;\n        }\n    } else if (tree_type == \"skewed\") {\n        int current = 1;\n        for (int i = 2; i <= n; ++i) {\n            p[i] = current;\n            current = i;\n        }\n    } else {\n        // Random tree\n        for (int i = 2; i <= n; ++i) {\n            p[i] = rnd.next(1, i - 1);\n        }\n    }\n\n    // Now generate edge list\n    for (int i = 2; i <= n; ++i) {\n        edges.push_back({p[i], i});\n    }\n\n    // Generate weights\n    vector<int> weights(n - 1);\n    if (weight_type == \"constant\") {\n        int w = min_weight;\n        for (int i = 0; i < n - 1; ++i) {\n            weights[i] = w;\n        }\n    } else if (weight_type == \"heavy\") {\n        int w = max_weight;\n        for (int i = 0; i < n - 1; ++i) {\n            weights[i] = w;\n        }\n    } else if (weight_type == \"random\") {\n        for (int i = 0; i < n - 1; ++i) {\n            weights[i] = rnd.next(min_weight, max_weight);\n        }\n    }\n\n    // Shuffle the node labels\n    vector<int> perm(n + 1);\n    for (int i = 1; i <= n; ++i) {\n        perm[i] = i;\n    }\n    shuffle(perm.begin() + 1, perm.end());\n\n    // Adjust edges and parents according to permutation\n    vector<tuple<int, int, int>> output_edges;\n    for (int i = 0; i < edges.size(); ++i) {\n        int u = perm[edges[i].first];\n        int v = perm[edges[i].second];\n        int w = weights[i];\n        output_edges.push_back(make_tuple(u, v, w));\n    }\n\n    // Shuffle the edges if desired\n    shuffle(output_edges.begin(), output_edges.end());\n\n    // Output the tree\n    printf(\"%d\\n\", n);\n    for (const auto& e : output_edges) {\n        int u, v, w;\n        tie(u, v, w) = e;\n        printf(\"%d %d %d\\n\", u, v, w);\n    }\n\n    // Generate q queries\n    vector<pair<int, int>> queries;\n    queries.resize(q);\n\n    if (query_type == \"random\") {\n        for (int i = 0; i < q; ++i) {\n            int u = rnd.next(1, n);\n            int v = rnd.next(1, n);\n            queries[i] = make_pair(u, v);\n        }\n    } else if (query_type == \"same_node\") {\n        for (int i = 0; i < q; ++i) {\n            int u = rnd.next(1, n);\n            queries[i] = make_pair(u, u);\n        }\n    } else if (query_type == \"root_node\") {\n        int u = perm[1];\n        for (int i = 0; i < q; ++i) {\n            int v = rnd.next(1, n);\n            queries[i] = make_pair(u, v);\n        }\n    } else if (query_type == \"parent_child\") {\n        // Use the parent array\n        for (int i = 0; i < q; ++i) {\n            int idx = rnd.next(2, n);\n            int u = perm[p[idx]];\n            int v = perm[idx];\n            queries[i] = make_pair(u, v);\n        }\n    } else if (query_type == \"far_apart\") {\n        // Find leaves\n        vector<int> degrees(n + 1, 0);\n        for (auto e : output_edges) {\n            int u, v, w;\n            tie(u, v, w) = e;\n            degrees[u]++;\n            degrees[v]++;\n        }\n        vector<int> leaves;\n        for (int i = 1; i <= n; ++i) {\n            if (degrees[i] == 1 && i != perm[1]) {\n                leaves.push_back(i);\n            }\n        }\n        if (leaves.size() < 2) {\n            // Not enough leaves, use random nodes\n            for (int i = 1; i <= n; ++i) {\n                if (i != perm[1])\n                    leaves.push_back(i);\n            }\n        }\n        for (int i = 0; i < q; ++i) {\n            int idx1 = rnd.next(0, (int)leaves.size() - 1);\n            int idx2 = rnd.next(0, (int)leaves.size() - 1);\n            int u = leaves[idx1];\n            int v = leaves[idx2];\n            queries[i] = make_pair(u, v);\n        }\n    } else {\n        // Default to random\n        for (int i = 0; i < q; ++i) {\n            int u = rnd.next(1, n);\n            int v = rnd.next(1, n);\n            queries[i] = make_pair(u, v);\n        }\n    }\n\n    // Output queries\n    printf(\"%d\\n\", q);\n    for (int i = 0; i < q; ++i) {\n        printf(\"%d %d\\n\", queries[i].first, queries[i].second);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    // Parse options\n    int n = opt<int>(\"n\");\n    int q = opt<int>(\"q\", n); // By default, set q = n\n    string tree_type = opt<string>(\"tree_type\", \"random\");\n    string weight_type = opt<string>(\"weight_type\", \"random\");\n    int min_weight = opt<int>(\"min_weight\", 1);\n    int max_weight = opt<int>(\"max_weight\", (int)1e9);\n    string query_type = opt<string>(\"query_type\", \"random\");\n\n    // Generate tree according to tree_type\n    vector<int> p(n + 1); // Parent array\n    vector<pair<int, int>> edges;\n    p[1] = 0; // Root node has no parent\n\n    if (tree_type == \"chain\") {\n        for (int i = 2; i <= n; ++i) {\n            p[i] = i - 1;\n        }\n    } else if (tree_type == \"star\") {\n        for (int i = 2; i <= n; ++i) {\n            p[i] = 1;\n        }\n    } else if (tree_type == \"skewed\") {\n        int current = 1;\n        for (int i = 2; i <= n; ++i) {\n            p[i] = current;\n            current = i;\n        }\n    } else {\n        // Random tree\n        for (int i = 2; i <= n; ++i) {\n            p[i] = rnd.next(1, i - 1);\n        }\n    }\n\n    // Now generate edge list\n    for (int i = 2; i <= n; ++i) {\n        edges.push_back({p[i], i});\n    }\n\n    // Generate weights\n    vector<int> weights(n - 1);\n    if (weight_type == \"constant\") {\n        int w = min_weight;\n        for (int i = 0; i < n - 1; ++i) {\n            weights[i] = w;\n        }\n    } else if (weight_type == \"heavy\") {\n        int w = max_weight;\n        for (int i = 0; i < n - 1; ++i) {\n            weights[i] = w;\n        }\n    } else if (weight_type == \"random\") {\n        for (int i = 0; i < n - 1; ++i) {\n            weights[i] = rnd.next(min_weight, max_weight);\n        }\n    }\n\n    // Shuffle the node labels\n    vector<int> perm(n + 1);\n    for (int i = 1; i <= n; ++i) {\n        perm[i] = i;\n    }\n    shuffle(perm.begin() + 1, perm.end());\n\n    // Adjust edges and parents according to permutation\n    vector<tuple<int, int, int>> output_edges;\n    for (int i = 0; i < edges.size(); ++i) {\n        int u = perm[edges[i].first];\n        int v = perm[edges[i].second];\n        int w = weights[i];\n        output_edges.push_back(make_tuple(u, v, w));\n    }\n\n    // Shuffle the edges if desired\n    shuffle(output_edges.begin(), output_edges.end());\n\n    // Output the tree\n    printf(\"%d\\n\", n);\n    for (const auto& e : output_edges) {\n        int u, v, w;\n        tie(u, v, w) = e;\n        printf(\"%d %d %d\\n\", u, v, w);\n    }\n\n    // Generate q queries\n    vector<pair<int, int>> queries;\n    queries.resize(q);\n\n    if (query_type == \"random\") {\n        for (int i = 0; i < q; ++i) {\n            int u = rnd.next(1, n);\n            int v = rnd.next(1, n);\n            queries[i] = make_pair(u, v);\n        }\n    } else if (query_type == \"same_node\") {\n        for (int i = 0; i < q; ++i) {\n            int u = rnd.next(1, n);\n            queries[i] = make_pair(u, u);\n        }\n    } else if (query_type == \"root_node\") {\n        int u = perm[1];\n        for (int i = 0; i < q; ++i) {\n            int v = rnd.next(1, n);\n            queries[i] = make_pair(u, v);\n        }\n    } else if (query_type == \"parent_child\") {\n        // Use the parent array\n        for (int i = 0; i < q; ++i) {\n            int idx = rnd.next(2, n);\n            int u = perm[p[idx]];\n            int v = perm[idx];\n            queries[i] = make_pair(u, v);\n        }\n    } else if (query_type == \"far_apart\") {\n        // Find leaves\n        vector<int> degrees(n + 1, 0);\n        for (auto e : output_edges) {\n            int u, v, w;\n            tie(u, v, w) = e;\n            degrees[u]++;\n            degrees[v]++;\n        }\n        vector<int> leaves;\n        for (int i = 1; i <= n; ++i) {\n            if (degrees[i] == 1 && i != perm[1]) {\n                leaves.push_back(i);\n            }\n        }\n        if (leaves.size() < 2) {\n            // Not enough leaves, use random nodes\n            for (int i = 1; i <= n; ++i) {\n                if (i != perm[1])\n                    leaves.push_back(i);\n            }\n        }\n        for (int i = 0; i < q; ++i) {\n            int idx1 = rnd.next(0, (int)leaves.size() - 1);\n            int idx2 = rnd.next(0, (int)leaves.size() - 1);\n            int u = leaves[idx1];\n            int v = leaves[idx2];\n            queries[i] = make_pair(u, v);\n        }\n    } else {\n        // Default to random\n        for (int i = 0; i < q; ++i) {\n            int u = rnd.next(1, n);\n            int v = rnd.next(1, n);\n            queries[i] = make_pair(u, v);\n        }\n    }\n\n    // Output queries\n    printf(\"%d\\n\", q);\n    for (int i = 0; i < q; ++i) {\n        printf(\"%d %d\\n\", queries[i].first, queries[i].second);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Small n and q, chain tree, constant weights, same_node queries\n./gen -n 5 -q 5 -tree_type chain -weight_type constant -min_weight 1 -max_weight 1 -query_type same_node\n\n# Small n and q, star tree, heavy weights, root_node queries\n./gen -n 5 -q 5 -tree_type star -weight_type heavy -min_weight 1000000000 -max_weight 1000000000 -query_type root_node\n\n# Small n and q, random tree, random weights, random queries\n./gen -n 5 -q 5 -tree_type random -weight_type random -min_weight 1 -max_weight 10 -query_type random\n\n# Medium n and q, skewed tree, constant weights, parent_child queries\n./gen -n 1000 -q 1000 -tree_type skewed -weight_type constant -min_weight 1 -max_weight 1 -query_type parent_child\n\n# Medium n and q, chain tree, random weights, far_apart queries\n./gen -n 1000 -q 1000 -tree_type chain -weight_type random -min_weight 1 -max_weight 1000 -query_type far_apart\n\n# Medium n and q, star tree, random weights, random queries\n./gen -n 1000 -q 1000 -tree_type star -weight_type random -min_weight 1 -max_weight 1000 -query_type random\n\n# Large n and q, random tree, constant weights, random queries\n./gen -n 100000 -q 100000 -tree_type random -weight_type constant -min_weight 1 -max_weight 1 -query_type random\n\n# Large n and q, skewed tree, heavy weights, same_node queries\n./gen -n 100000 -q 100000 -tree_type skewed -weight_type heavy -min_weight 1000000000 -max_weight 1000000000 -query_type same_node\n\n# Large n and q, chain tree, random weights, root_node queries\n./gen -n 100000 -q 100000 -tree_type chain -weight_type random -min_weight 1 -max_weight 1000000000 -query_type root_node\n\n# Large n and q, star tree, constant weights, far_apart queries\n./gen -n 100000 -q 100000 -tree_type star -weight_type constant -min_weight 1 -max_weight 1 -query_type far_apart\n\n# Random n and q, random tree, random weights, random queries\n./gen -n 50000 -q 50000 -tree_type random -weight_type random -min_weight 1 -max_weight 1000000000 -query_type random\n\n# Max n and q, random tree, random weights, random queries\n./gen -n 100000 -q 100000 -tree_type random -weight_type random -min_weight 1 -max_weight 1000000000 -query_type random\n\n# Max n and q, chain tree, heavy weights, parent_child queries\n./gen -n 100000 -q 100000 -tree_type chain -weight_type heavy -min_weight 1000000000 -max_weight 1000000000 -query_type parent_child\n\n# Max n and q, skewed tree, constant weights, root_node queries\n./gen -n 100000 -q 100000 -tree_type skewed -weight_type constant -min_weight 1 -max_weight 1 -query_type root_node\n\n# Max n and q, star tree, random weights, same_node queries\n./gen -n 100000 -q 100000 -tree_type star -weight_type random -min_weight 1 -max_weight 1000000000 -query_type same_node\n\n# Small n and q, random tree, random weights, random queries\n./gen -n 10 -q 10 -tree_type random -weight_type random -min_weight 1 -max_weight 100 -query_type random\n\n# Medium n and q, random tree, random weights, random queries\n./gen -n 1000 -q 1000 -tree_type random -weight_type random -min_weight 1 -max_weight 1000 -query_type random\n\n# Medium n and q, random tree, heavy weights, random queries\n./gen -n 1000 -q 1000 -tree_type random -weight_type heavy -min_weight 1000000000 -max_weight 1000000000 -query_type random\n\n# Medium n and q, random tree, constant weights, random queries\n./gen -n 1000 -q 1000 -tree_type random -weight_type constant -min_weight 1 -max_weight 1 -query_type random\n\n# Small n and q, skewed tree, random weights, far_apart queries\n./gen -n 10 -q 10 -tree_type skewed -weight_type random -min_weight 1 -max_weight 100 -query_type far_apart\n\n# Medium n and q, skewed tree, random weights, far_apart queries\n./gen -n 1000 -q 1000 -tree_type skewed -weight_type random -min_weight 1 -max_weight 1000 -query_type far_apart\n\n# Large n and q, skewed tree, random weights, far_apart queries\n./gen -n 100000 -q 100000 -tree_type skewed -weight_type random -min_weight 1 -max_weight 1000000000 -query_type far_apart\n\n# Small n and q, chain tree, constant weights, same_node queries\n./gen -n 10 -q 10 -tree_type chain -weight_type constant -min_weight 1 -max_weight 1 -query_type same_node\n\n# Medium n and q, chain tree, constant weights, same_node queries\n./gen -n 1000 -q 1000 -tree_type chain -weight_type constant -min_weight 1 -max_weight 1 -query_type same_node\n\n# Large n and q, chain tree, constant weights, same_node queries\n./gen -n 100000 -q 100000 -tree_type chain -weight_type constant -min_weight 1 -max_weight 1 -query_type same_node\n\n# Max n and q, random tree, heavy weights, random queries\n./gen -n 100000 -q 100000 -tree_type random -weight_type heavy -min_weight 1000000000 -max_weight 1000000000 -query_type random\n\n# Max n and q, star tree, heavy weights, random queries\n./gen -n 100000 -q 100000 -tree_type star -weight_type heavy -min_weight 1000000000 -max_weight 1000000000 -query_type random\n\n# Max n and q, skewed tree, heavy weights, random queries\n./gen -n 100000 -q 100000 -tree_type skewed -weight_type heavy -min_weight 1000000000 -max_weight 1000000000 -query_type random\n\n# Max n and q, chain tree, heavy weights, random queries\n./gen -n 100000 -q 100000 -tree_type chain -weight_type heavy -min_weight 1000000000 -max_weight 1000000000 -query_type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:38:46.909433",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "494/E",
      "title": "E. Sharti",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test5 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputIn this problem the initial board is specified as a set of m rectangles. All cells that lie inside at least one of these rectangles are colored white and the rest are colored black.In the first line of input three space-spereated integers n, m, k (1 ≤ k ≤ n ≤ 109, 1 ≤ m ≤ 5·104) follow, denoting size of the board, number of rectangles and maximum size of the turn square during the game, respectively.In i-th line of the next m lines four space-seperated integers ai, bi, ci, di (1 ≤ ai ≤ ci ≤ n, 1 ≤ bi ≤ di ≤ n) are given meaning that i-th rectangle determining the initial board is a rectangle with upper-left cell at (ai, bi) and lower-right cell at (ci, di).",
      "output_spec": "OutputIf Hamed wins, print \"Hamed\", otherwise print \"Malek\" (without the quotes).",
      "sample_tests": "ExamplesInputCopy5 2 11 1 3 32 2 4 4OutputCopyMalekInputCopy12 5 73 4 5 61 2 1 24 5 9 98 6 12 1012 4 12 4OutputCopyHamed",
      "description": "time limit per test5 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputIn this problem the initial board is specified as a set of m rectangles. All cells that lie inside at least one of these rectangles are colored white and the rest are colored black.In the first line of input three space-spereated integers n, m, k (1 ≤ k ≤ n ≤ 109, 1 ≤ m ≤ 5·104) follow, denoting size of the board, number of rectangles and maximum size of the turn square during the game, respectively.In i-th line of the next m lines four space-seperated integers ai, bi, ci, di (1 ≤ ai ≤ ci ≤ n, 1 ≤ bi ≤ di ≤ n) are given meaning that i-th rectangle determining the initial board is a rectangle with upper-left cell at (ai, bi) and lower-right cell at (ci, di).\n\nOutputIf Hamed wins, print \"Hamed\", otherwise print \"Malek\" (without the quotes).\n\nInputCopy5 2 11 1 3 32 2 4 4OutputCopyMalekInputCopy12 5 73 4 5 61 2 1 24 5 9 98 6 12 1012 4 12 4OutputCopyHamed\n\nInputCopy5 2 11 1 3 32 2 4 4\n\nOutputCopyMalek\n\nInputCopy12 5 73 4 5 61 2 1 24 5 9 98 6 12 1012 4 12 4\n\nOutputCopyHamed",
      "solutions": [
        {
          "title": "Codeforces Round #282 - Codeforces",
          "content": "Hi, Codeforces Round #282 will be held at 13th of December, 19:30 MSK. Please don't note anything since the time is the usual time of contests.The round is prepared by FarbodY, Haghani and Me(matrix). We'd like to thank Zlobober who helped us a LOT for preparing the problems, MikeMirzayanov for the Polygon and Codeforces platforms and Delinur for helping us in preparing statements and translating them.Our special thanks goes to mruxim for testing the round.The problems will be sorted according to the estimated order of difficulty according to our opinion but we strongly recommend you to read all of the problems.As always the update regarding score distribution will be posted just before the round starts. :)UPD: It was written that contest starts at 20:00 MSK. it was a mistake and is fixed now. The round starts at usual time 19:30 MSK.UPD2: We also thank niyaznigmatul for testing our round.UPD3: Score distribution:Div1: 500-1000-1750-1750-2500Div2: 500-1000-1500-2000-2750As you might have noticed, the scores can now be multiples of 250 as well. Let's thank Codeforces team for adding this feature!Good luck and Have fun!UPD4: Congratulations to the winners of both divisions:Div1: tourist winger sankear uwi Egor Div2: Ginger88895 pwild arthurpd konmaj ezkatka The editorial for all problems except D and E Div1 are ready and can be found here. It'll be completed soon.We thank you all for participating and hope you had a good time.UPD5: The editorial is now complete and can be found here.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/15134",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1506
        },
        {
          "title": "Codeforces Round #282 Editorial - Codeforces",
          "content": "495A - Digital CounterFor each digit x you can count the number of digits y that because of some broken sticks x is shown instead of y by hand. for example when x = 3, y can be 3, 8 and 9. Let's denote this number by ax. Then if the input is xy (the first digit shown in the counter is x and the second is y) the answer will be ax × ay.495B - Modular Equations If a < b then there is no answer since . If a = b then x can be any integer larger than a. so there are infinite number of answers to the equation. The only remaining case is when a > b. Suppose x is an answer to our equation. Then x|a - b. Also since then b < x. These conditions are necessary and sufficient as well. So the answer is number of divisors of a - b which are strictly greater than b which can be solved in . 494A - TreasureConsider a string consisting of '(' and ')' characters. Let's build the following sequence from this string: a0 = 0 for each 1 ≤ i ≤ |s| ai = ai - 1 + 1 if si = '(' and ai = ai - 1 - 1 otherwise. (The string is considered as 1-based index). It can be proven that a string is beautiful if the following conditions are satisfied: for each 0 ≤ i ≤ |s| ai ≥ 0. a|s| = 0 Using the above fact we can prove that if in a beautiful string we remove a ')' character and put it further toward the end of the string the resulting string is beautiful as well. These facts leads us to the following fact: if we can move a ')' character further toward the end of string it is better if we'd do it. This yields the following greedy solution:We'll first put exactly one ')' character at each '#' character. Then we'll build the sequence we described above. if the first condition isn't satisfied then there is no way that leads to a beautiful string. So the answer is -1. Otherwise we must put exactly a|s| more ')' characters in the place of last '#' character. Then if this string is beautiful we'll print it otherwise the answer is -1.494B - Obsessive StringWe call an index i(1 ≤ i ≤ |s|) good if t equals si - |t| + 1si - |t| + 2... si. To find all good indexes let's define qi as the length of longest prefix of t which is a suffix of s1s2... si. A good index is an index with qi = |t|. Calculating qi can be done using Knuth-Morris-Pratt algorithm. Let's define ai as the number of ways to choose some(at least one) non-overlapping substrings of the prefix of s with length i (s1s2... si) so t is a substring of each one of them and si is in one the chosen substrings(So it must actually be the last character of last chosen substring). Then the answer will be .Also let's define two additional sequence q1 and q2 which will help us in calculating a.The sequence a can then be calculated in O(n) as described below:If i is not a good index ai = ai - 1 since in each way counted in ai the substring containing si also contains si - 1 so for each of these ways removing si from the substring containing it leads to a way counted in ai - 1 and vice-versa thus these two numbers are equal. If i is a good index then ai = q2i - |t| + i - |t| + 1. To prove this let's consider a way of choosing substring counted in ai. We call such a way valid. The substring containing si can be any of the substrings sjsj + 1... si (1 ≤ j ≤ i - |t| + 1). There are i - |t| + 1 valid ways in which this substring is the only substring we've chosen. Number of valid ways in which substring containing si starts at sj equals to q1j - 1. So the total number of valid ways in which we've chosen at least two substrings are equal to which is equal to q2j - 1. So ai = q2i - |t| + i - |t| + 1.494C - Helping PeopleWe'll first create a rooted tree from the given segments which each node represents a segment. We'll solve the problem using dynamic programming on this tree. First of all let's add a segment [1, n] with probability of being chosen by Malek equal to 0. The node representing this segment will be the root of the tree. Please note by adding this segment the rules described in the statements are still in place.Let's sort the rest of segments according to their starting point increasing and in case of equality according to their finishing point decreasing. Then we'll put the segment we added in the beginning. A segment's father is the right-most segment which comes before that segment and contains it. Please note that since we added segment [1, n] to the beginning every segment except the added segment has a father. We build the tree by putting a segment's node child of its father's node. In this tree for each two nodes u and v which none of them are in the subtree on another the segments representing these two nodes will not overlap. Also for each two nodes u and v which u is in subtree of v segment representing node u will be inside(not necessarily strictly) segment representing node v. We define mxi as the maximum money a person in the segment i initially has. mxi can be calculated using RMQ. Let's define ai, j as the probability of that after Malek finishes giving his money the maximum in the segment i is at most {mx}i + j. The properties of the tree we built allows us to calculate ai, j for every i and j in O(q2) (since 1 ≤ i, j ≤ q). If number of the segment we added is k then the answer will be . Calculating ai, j is described below:Suppose f is a child of i and suppose Malek doesn't accept the i-th recommendation. Then since we want the maximum number after money spreading to be at most mxi + j in segment i and since f is inside i we want the maximum number after money spreading to be at most mxi - mxf + j. If Malek accepts the recommendation then we want it to be at most mxi - mxf + j - 1. So if probability of i-th recommendation being accepted by Malek be equal to pi then . Using this formula we can calculate ak, j recursively and calculate the answer from it in O(q2). The overall complexity will be O(nlgn + q2). nlgn for creating RMQ used for calculating the array mx and q2 for the rest of the algorithm.494D - BirthdayWe solve this problem by answering queries offline. We'll first store in each vertex v number of vertices such as x for which we must calculate f(v, x) . starting from the root. We'll keep two arrays a and b. Suppose we're at vertex v right now then ai equals d(i, v)2 and bi equal d(i, v). Having these two arrays when moving from vertex v to a child with an edge with weight k one can note that bi for all is inside subtree of v decreases by k and all other bis gets increased by k. Knowing this fact one can also update array a as well. To calculate f(v, x) it's enough to be able to calculate sum of ais for all i inside subtree of x. Handling each of these operations is a well known problem and is possible using a segment tree. Overall complexity is O((n + q)lgn). There is an online solution using dynamic programming as well.494E - ShartiLet's first solve this problem for another game: Suppose that we've an n × n table. Each cell have some(possibly zero) marbles on it. During each move the player chooses a square with side-length at most k which its lower-right cell has at least one marble, he removes one marble from it and puts one marble in every other cell of this square. One can notice that in such game each marble is independent of the others and doesn't affect other marbles. So one can see this game as some separate games played on some tables. More formally for each marble placed in a cell such as (i, j) consider the game when played on a i × j table which the only marble placed on it is at its lower-right cell. Let's denote the Grundy number of this game by gi, j. Then according to Grundy theorem the first player has a winning strategy if and only if the xor of gi, j for every cell (i, j) having odd number of marbles on it is positive. To calculate gi, j note that the first move in such game must be choosing a square with its lower-right cell being the lower-right cell of table. So the only thing to decide is the side-length of chosen square at the first move. Let's say we choose the first square width side length l. Grundy number of the next state will be equal to xor of gc, d for every i - l < c ≤ i, j - l < d ≤ j. Using this fact one can calculate gi, j for all (1 ≤ i, j ≤ a) (a being an arbitrary integers) in O(a3).If we calculated the first values of gi, j one can see a pattern in the Grundy numbers. Then one can prove that gi, j = min(lowest_bit(i), lowest_bit(j), greatest_bit(k)) where lowest_bit(x) =  the maximum power of 2 which is a divisor of x and greatest_bit(x) =  the maximum power of 2 which is not greater than x. Now let's prove that our first game(the game described in the statement) is actually the same as this game. Suppose that a player has a winning strategy in the first game. Consider a table containing one marble at every cell which is white in the table of the first game. We'll prove that the same player has winning strategy in this game as well. Note that a cell is white in the first game if and only if the parity of marbles in the second game is odd so there is at least one marble on it. So as long as the other player chooses a square with its lower-right cell having odd number of marbles in the second game, his move corresponds to a move in the first game so the player having winning strategy can counter his move. If the other player chooses a square with its lower-right cell having even number of marbles, it means the cell had at least 2 marbles on it so the player can counter it by choosing the same square which makes the parity of every cell to be the same after these 2 moves. And since it can be proven that both of the game will end at some point then the player has winning strategy in this game as well. The reverse of this fact can also be proven the same since if a player has a winning strategy there is also a winning strategy in which this player always chooses squares with lower-right cell having odd number of marbles(since otherwise the other player can counter it as described above) and counters the moves of the other player at which he chose a square with lower-right cell having even number of marbles by choosing the same square(since the Grundy number by countering in this way won't change the Grundy number and thus won't change the player with winning strategy).So if we consider a table having one marble at each of the cells which are in at least one of the rectangles given in the input we only need to calculate the Grundy number of this state and check whether it's positive or not to determine the winner. To do this for each i(1 ≤ i ≤ greatest_bit(k)) lets define ai as the number of cells (x, y) which are contained in at least one of the given rectangles, 2i|x and 2i|y. Lets also define agreatest_bit(k) + 1 = 0. Then according the fact we described above about gi, j the number of 2is which are xored equals ai - ai + 1. Knowing this calculating the Grundy number of the initial state is easy. Calculating ai is identical to a very well-known problem which is given some rectangles count the number of cells in at least one of them and can be solved in O(mlgm) (m being number of rectangles). So overall complexity will be O(mlgmlgk).If there is any problem in the editorial please feel free to note that to us.Thank you.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/15148",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 494\\s*E"
          },
          "content_length": 11197
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #282 - Codeforces - Code 1",
          "code": "(#(\nAnswer: -1\nWA: 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15134",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #282 - Codeforces - Code 2",
          "code": "(#(\nAnswer: -1\nWA: 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15134",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #282 Editorial - Codeforces - Code 1",
          "code": "divisors of (a-b) greater than b",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15148",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #282 Editorial - Codeforces - Code 2",
          "code": "1 to sqrt(a-b)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15148",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #282 Editorial - Codeforces - Code 3",
          "code": "O(sqrt(a-b))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15148",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #282 Editorial - Codeforces - Code 4",
          "code": "input\n3 5\n1 2 3\n1 3 0.500\n2 2 0.250\n1 2 0.800\n1 1 0.120\n2 2 0.900\noutput\n4.465000000",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15148",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #282 Editorial - Codeforces - Code 5",
          "code": "input\n3 5\n1 2 3\n1 3 0.500\n2 2 0.250\n1 2 0.800\n1 1 0.120\n2 2 0.900\noutput\n4.465000000",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15148",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #282 Editorial - Codeforces - Code 6",
          "code": "using std::",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15148",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #282 Editorial - Codeforces - Code 7",
          "code": "using namespace std",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15148",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #282 Editorial - Codeforces - Code 8",
          "code": "#define next ____next\n#define prev ____prev\n#define y1   ____y1\n#define left ____left\n#define hash ____hash",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15148",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #282 Editorial - Codeforces - Code 9",
          "code": "#define next ____next\n#define prev ____prev\n#define y1   ____y1\n#define left ____left\n#define hash ____hash",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15148",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #282 Editorial - Codeforces - Code 10",
          "code": "#define max max<long long>",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15148",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #282 Editorial - Codeforces - Code 11",
          "code": "long long max(int a, long long b) { return max((long long)a, b); }\nlong long max(long long b, int a) { return max(a, (long long)b); }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15148",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #282 Editorial - Codeforces - Code 12",
          "code": "long long max(int a, long long b) { return max((long long)a, b); }\nlong long max(long long b, int a) { return max(a, (long long)b); }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15148",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #282 Editorial - Codeforces - Code 13",
          "code": "#define MAX(a,b) ((a)>(b)?(a):(b))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15148",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #282 Editorial - Codeforces - Code 14",
          "code": "#define MAX(a,b) ((a)>(b)?(a):(b))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15148",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #282 Editorial - Codeforces - Code 15",
          "code": "final string becomes beautiful",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15148",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #282 Editorial - Codeforces - Code 16",
          "code": "Node v = root",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15148",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #282 Editorial - Codeforces - Code 17",
          "code": "v = v.parent",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15148",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #282 Editorial - Codeforces - Code 18",
          "code": "input:\nddd\nd\noutput:\n12",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15148",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #282 Editorial - Codeforces - Code 19",
          "code": "input:\nddd\nd\noutput:\n12",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15148",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 1000000000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 50000, \"m\");\n    inf.readSpace();\n    int k = inf.readInt(1, n, \"k\");\n    inf.readEoln();\n\n    for (int i = 0; i < m; ++i) {\n        int ai = inf.readInt(1, n, \"ai\");\n        inf.readSpace();\n        int bi = inf.readInt(1, n, \"bi\");\n        inf.readSpace();\n        int ci = inf.readInt(ai, n, \"ci\");\n        inf.readSpace();\n        int di = inf.readInt(bi, n, \"di\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 1000000000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 50000, \"m\");\n    inf.readSpace();\n    int k = inf.readInt(1, n, \"k\");\n    inf.readEoln();\n\n    for (int i = 0; i < m; ++i) {\n        int ai = inf.readInt(1, n, \"ai\");\n        inf.readSpace();\n        int bi = inf.readInt(1, n, \"bi\");\n        inf.readSpace();\n        int ci = inf.readInt(ai, n, \"ci\");\n        inf.readSpace();\n        int di = inf.readInt(bi, n, \"di\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 1000000000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 50000, \"m\");\n    inf.readSpace();\n    int k = inf.readInt(1, n, \"k\");\n    inf.readEoln();\n\n    for (int i = 0; i < m; ++i) {\n        int ai = inf.readInt(1, n, \"ai\");\n        inf.readSpace();\n        int bi = inf.readInt(1, n, \"bi\");\n        inf.readSpace();\n        int ci = inf.readInt(ai, n, \"ci\");\n        inf.readSpace();\n        int di = inf.readInt(bi, n, \"di\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare sequences of tokens\");\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string j, p;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n\r\n        ans.readWordTo(j);\r\n        ouf.readWordTo(p);\r\n\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s words differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  compress(j).c_str(), compress(p).c_str());\r\n    }\r\n\r\n    if (ans.seekEof() && ouf.seekEof()) {\r\n        if (n == 1)\r\n            quitf(_ok, \"\\\"%s\\\"\", compress(j).c_str());\r\n        else\r\n            quitf(_ok, \"%d tokens\", n);\r\n    } else {\r\n        if (ans.seekEof())\r\n            quitf(_wa, \"Participant output contains extra tokens\");\r\n        else\r\n            quitf(_wa, \"Unexpected EOF in the participants output\");\r\n    }\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    int k = opt<int>(\"k\");\n    string type = opt<string>(\"type\", \"random\");\n\n    // Adjust parameters based on the type\n    if (type == \"full_white\") {\n        m = 1;\n    } else if (type == \"full_black\") {\n        m = 0;\n    } else if (type == \"single_rectangle\") {\n        m = 1;\n    }\n\n    // Ensure that k does not exceed n\n    k = min(k, n);\n\n    // Output n, m, k\n    printf(\"%d %d %d\\n\", n, m, k);\n\n    if (type == \"random\") {\n        // Generate random rectangles\n        for (int i = 0; i < m; ++i) {\n            int ai = rnd.next(1, n);\n            int ci = rnd.next(ai, n);\n            int bi = rnd.next(1, n);\n            int di = rnd.next(bi, n);\n            printf(\"%d %d %d %d\\n\", ai, bi, ci, di);\n        }\n    } else if (type == \"full_white\") {\n        // Single rectangle covering the entire board\n        printf(\"1 1 %d %d\\n\", n, n);\n    } else if (type == \"full_black\") {\n        // No rectangles to output\n    } else if (type == \"overlapping\") {\n        // Generate overlapping rectangles centered in the board\n        int center = n / 2;\n        int size = max(1, n / 10);\n        for (int i = 0; i < m; ++i) {\n            int delta_ai = rnd.next(0, size);\n            int delta_bi = rnd.next(0, size);\n            int ai = max(1, center - delta_ai);\n            int bi = max(1, center - delta_bi);\n            int ci = min(n, center + delta_ai);\n            int di = min(n, center + delta_bi);\n            printf(\"%d %d %d %d\\n\", ai, bi, ci, di);\n        }\n    } else if (type == \"single_cell_rectangles\") {\n        // Rectangles covering single cells\n        for (int i = 0; i < m; ++i) {\n            int ai = rnd.next(1, n);\n            int bi = rnd.next(1, n);\n            printf(\"%d %d %d %d\\n\", ai, bi, ai, bi);\n        }\n    } else if (type == \"edge_rectangles\") {\n        // Rectangles along the edges of the board\n        for (int i = 0; i < m; ++i) {\n            int side = rnd.next(1, 4);\n            int ai, bi, ci, di;\n            if (side == 1) {\n                // Top edge\n                ai = 1;\n                ci = 1;\n                bi = rnd.next(1, n);\n                di = rnd.next(bi, n);\n            } else if (side == 2) {\n                // Bottom edge\n                ai = n;\n                ci = n;\n                bi = rnd.next(1, n);\n                di = rnd.next(bi, n);\n            } else if (side == 3) {\n                // Left edge\n                bi = 1;\n                di = 1;\n                ai = rnd.next(1, n);\n                ci = rnd.next(ai, n);\n            } else {\n                // Right edge\n                bi = n;\n                di = n;\n                ai = rnd.next(1, n);\n                ci = rnd.next(ai, n);\n            }\n            printf(\"%d %d %d %d\\n\", ai, bi, ci, di);\n        }\n    } else if (type == \"single_rectangle\") {\n        // Single rectangle anywhere on the board\n        int ai = rnd.next(1, n);\n        int ci = rnd.next(ai, n);\n        int bi = rnd.next(1, n);\n        int di = rnd.next(bi, n);\n        printf(\"%d %d %d %d\\n\", ai, bi, ci, di);\n    } else {\n        // Default to random type\n        for (int i = 0; i < m; ++i) {\n            int ai = rnd.next(1, n);\n            int ci = rnd.next(ai, n);\n            int bi = rnd.next(1, n);\n            int di = rnd.next(bi, n);\n            printf(\"%d %d %d %d\\n\", ai, bi, ci, di);\n        }\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    int k = opt<int>(\"k\");\n    string type = opt<string>(\"type\", \"random\");\n\n    // Adjust parameters based on the type\n    if (type == \"full_white\") {\n        m = 1;\n    } else if (type == \"full_black\") {\n        m = 0;\n    } else if (type == \"single_rectangle\") {\n        m = 1;\n    }\n\n    // Ensure that k does not exceed n\n    k = min(k, n);\n\n    // Output n, m, k\n    printf(\"%d %d %d\\n\", n, m, k);\n\n    if (type == \"random\") {\n        // Generate random rectangles\n        for (int i = 0; i < m; ++i) {\n            int ai = rnd.next(1, n);\n            int ci = rnd.next(ai, n);\n            int bi = rnd.next(1, n);\n            int di = rnd.next(bi, n);\n            printf(\"%d %d %d %d\\n\", ai, bi, ci, di);\n        }\n    } else if (type == \"full_white\") {\n        // Single rectangle covering the entire board\n        printf(\"1 1 %d %d\\n\", n, n);\n    } else if (type == \"full_black\") {\n        // No rectangles to output\n    } else if (type == \"overlapping\") {\n        // Generate overlapping rectangles centered in the board\n        int center = n / 2;\n        int size = max(1, n / 10);\n        for (int i = 0; i < m; ++i) {\n            int delta_ai = rnd.next(0, size);\n            int delta_bi = rnd.next(0, size);\n            int ai = max(1, center - delta_ai);\n            int bi = max(1, center - delta_bi);\n            int ci = min(n, center + delta_ai);\n            int di = min(n, center + delta_bi);\n            printf(\"%d %d %d %d\\n\", ai, bi, ci, di);\n        }\n    } else if (type == \"single_cell_rectangles\") {\n        // Rectangles covering single cells\n        for (int i = 0; i < m; ++i) {\n            int ai = rnd.next(1, n);\n            int bi = rnd.next(1, n);\n            printf(\"%d %d %d %d\\n\", ai, bi, ai, bi);\n        }\n    } else if (type == \"edge_rectangles\") {\n        // Rectangles along the edges of the board\n        for (int i = 0; i < m; ++i) {\n            int side = rnd.next(1, 4);\n            int ai, bi, ci, di;\n            if (side == 1) {\n                // Top edge\n                ai = 1;\n                ci = 1;\n                bi = rnd.next(1, n);\n                di = rnd.next(bi, n);\n            } else if (side == 2) {\n                // Bottom edge\n                ai = n;\n                ci = n;\n                bi = rnd.next(1, n);\n                di = rnd.next(bi, n);\n            } else if (side == 3) {\n                // Left edge\n                bi = 1;\n                di = 1;\n                ai = rnd.next(1, n);\n                ci = rnd.next(ai, n);\n            } else {\n                // Right edge\n                bi = n;\n                di = n;\n                ai = rnd.next(1, n);\n                ci = rnd.next(ai, n);\n            }\n            printf(\"%d %d %d %d\\n\", ai, bi, ci, di);\n        }\n    } else if (type == \"single_rectangle\") {\n        // Single rectangle anywhere on the board\n        int ai = rnd.next(1, n);\n        int ci = rnd.next(ai, n);\n        int bi = rnd.next(1, n);\n        int di = rnd.next(bi, n);\n        printf(\"%d %d %d %d\\n\", ai, bi, ci, di);\n    } else {\n        // Default to random type\n        for (int i = 0; i < m; ++i) {\n            int ai = rnd.next(1, n);\n            int ci = rnd.next(ai, n);\n            int bi = rnd.next(1, n);\n            int di = rnd.next(bi, n);\n            printf(\"%d %d %d %d\\n\", ai, bi, ci, di);\n        }\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -k 1 -m 0 -type full_black\n./gen -n 1 -k 1 -m 1 -type full_white\n./gen -n 1 -k 1 -m 1 -type single_rectangle\n\n./gen -n 2 -k 1 -m 1 -type random\n./gen -n 10 -k 1 -m 2 -type random\n./gen -n 10 -k 5 -m 5 -type random\n./gen -n 10 -k 10 -m 10 -type random\n\n./gen -n 1000 -k 1000 -m 1 -type single_rectangle\n./gen -n 1000 -k 1000 -m 1000 -type overlapping\n./gen -n 1000 -k 1000 -m 5000 -type overlapping\n\n./gen -n 1000 -k 1000 -m 5000 -type single_cell_rectangles\n./gen -n 1000 -k 1 -m 5000 -type single_cell_rectangles\n\n./gen -n 10000 -k 10000 -m 10000 -type random\n./gen -n 10000 -k 1000 -m 5000 -type overlapping\n./gen -n 10000 -k 1000 -m 5000 -type edge_rectangles\n\n./gen -n 100000 -k 10000 -m 50000 -type random\n\n./gen -n 500000000 -k 250000000 -m 50000 -type random\n./gen -n 500000000 -k 1 -m 50000 -type edge_rectangles\n\n./gen -n 999999999 -k 500000000 -m 50000 -type random\n\n./gen -n 1000000000 -k 1 -m 50000 -type random\n./gen -n 1000000000 -k 1 -m 50000 -type edge_rectangles\n./gen -n 1000000000 -k 1000 -m 50000 -type single_cell_rectangles\n./gen -n 1000000000 -k 1000000000 -m 1 -type full_white\n./gen -n 1000000000 -k 1000000000 -m 0 -type full_black\n./gen -n 1000000000 -k 1000000000 -m 50000 -type overlapping\n./gen -n 1000000000 -k 1000000000 -m 50000 -type random\n./gen -n 1000000000 -k 1000000000 -m 1 -type single_rectangle\n\n./gen -n 1000000000 -k 1 -m 1 -type single_rectangle\n\n# Repeat some minimal cases\n./gen -n 1 -k 1 -m 0 -type full_black\n./gen -n 1 -k 1 -m 1 -type full_white\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:38:48.871503",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "495/A",
      "title": "A. Digital Counter",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe only line of input contains exactly two digits representing number n (0 ≤ n ≤ 99). Note that n may have a leading zero.",
      "output_spec": "OutputIn the only line of the output print the number of good integers.",
      "sample_tests": "ExamplesInputCopy89OutputCopy2InputCopy00OutputCopy4InputCopy73OutputCopy15",
      "description": "A. Digital Counter\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe only line of input contains exactly two digits representing number n (0 ≤ n ≤ 99). Note that n may have a leading zero.\n\nOutputIn the only line of the output print the number of good integers.\n\nInputCopy89OutputCopy2InputCopy00OutputCopy4InputCopy73OutputCopy15\n\nInputCopy89\n\nOutputCopy2\n\nInputCopy00\n\nOutputCopy4\n\nInputCopy73\n\nOutputCopy15\n\nNoteIn the first sample the counter may be supposed to show 88 or 89.In the second sample the good integers are 00, 08, 80 and 88.In the third sample the good integers are 03, 08, 09, 33, 38, 39, 73, 78, 79, 83, 88, 89, 93, 98, 99.",
      "solutions": [
        {
          "title": "Codeforces Round #282 - Codeforces",
          "content": "Hi, Codeforces Round #282 will be held at 13th of December, 19:30 MSK. Please don't note anything since the time is the usual time of contests.The round is prepared by FarbodY, Haghani and Me(matrix). We'd like to thank Zlobober who helped us a LOT for preparing the problems, MikeMirzayanov for the Polygon and Codeforces platforms and Delinur for helping us in preparing statements and translating them.Our special thanks goes to mruxim for testing the round.The problems will be sorted according to the estimated order of difficulty according to our opinion but we strongly recommend you to read all of the problems.As always the update regarding score distribution will be posted just before the round starts. :)UPD: It was written that contest starts at 20:00 MSK. it was a mistake and is fixed now. The round starts at usual time 19:30 MSK.UPD2: We also thank niyaznigmatul for testing our round.UPD3: Score distribution:Div1: 500-1000-1750-1750-2500Div2: 500-1000-1500-2000-2750As you might have noticed, the scores can now be multiples of 250 as well. Let's thank Codeforces team for adding this feature!Good luck and Have fun!UPD4: Congratulations to the winners of both divisions:Div1: tourist winger sankear uwi Egor Div2: Ginger88895 pwild arthurpd konmaj ezkatka The editorial for all problems except D and E Div1 are ready and can be found here. It'll be completed soon.We thank you all for participating and hope you had a good time.UPD5: The editorial is now complete and can be found here.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/15134",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1506
        },
        {
          "title": "Codeforces Round #282 Editorial - Codeforces",
          "content": "495A - Digital CounterFor each digit x you can count the number of digits y that because of some broken sticks x is shown instead of y by hand. for example when x = 3, y can be 3, 8 and 9. Let's denote this number by ax. Then if the input is xy (the first digit shown in the counter is x and the second is y) the answer will be ax × ay.495B - Modular Equations If a < b then there is no answer since . If a = b then x can be any integer larger than a. so there are infinite number of answers to the equation. The only remaining case is when a > b. Suppose x is an answer to our equation. Then x|a - b. Also since then b < x. These conditions are necessary and sufficient as well. So the answer is number of divisors of a - b which are strictly greater than b which can be solved in . 494A - TreasureConsider a string consisting of '(' and ')' characters. Let's build the following sequence from this string: a0 = 0 for each 1 ≤ i ≤ |s| ai = ai - 1 + 1 if si = '(' and ai = ai - 1 - 1 otherwise. (The string is considered as 1-based index). It can be proven that a string is beautiful if the following conditions are satisfied: for each 0 ≤ i ≤ |s| ai ≥ 0. a|s| = 0 Using the above fact we can prove that if in a beautiful string we remove a ')' character and put it further toward the end of the string the resulting string is beautiful as well. These facts leads us to the following fact: if we can move a ')' character further toward the end of string it is better if we'd do it. This yields the following greedy solution:We'll first put exactly one ')' character at each '#' character. Then we'll build the sequence we described above. if the first condition isn't satisfied then there is no way that leads to a beautiful string. So the answer is -1. Otherwise we must put exactly a|s| more ')' characters in the place of last '#' character. Then if this string is beautiful we'll print it otherwise the answer is -1.494B - Obsessive StringWe call an index i(1 ≤ i ≤ |s|) good if t equals si - |t| + 1si - |t| + 2... si. To find all good indexes let's define qi as the length of longest prefix of t which is a suffix of s1s2... si. A good index is an index with qi = |t|. Calculating qi can be done using Knuth-Morris-Pratt algorithm. Let's define ai as the number of ways to choose some(at least one) non-overlapping substrings of the prefix of s with length i (s1s2... si) so t is a substring of each one of them and si is in one the chosen substrings(So it must actually be the last character of last chosen substring). Then the answer will be .Also let's define two additional sequence q1 and q2 which will help us in calculating a.The sequence a can then be calculated in O(n) as described below:If i is not a good index ai = ai - 1 since in each way counted in ai the substring containing si also contains si - 1 so for each of these ways removing si from the substring containing it leads to a way counted in ai - 1 and vice-versa thus these two numbers are equal. If i is a good index then ai = q2i - |t| + i - |t| + 1. To prove this let's consider a way of choosing substring counted in ai. We call such a way valid. The substring containing si can be any of the substrings sjsj + 1... si (1 ≤ j ≤ i - |t| + 1). There are i - |t| + 1 valid ways in which this substring is the only substring we've chosen. Number of valid ways in which substring containing si starts at sj equals to q1j - 1. So the total number of valid ways in which we've chosen at least two substrings are equal to which is equal to q2j - 1. So ai = q2i - |t| + i - |t| + 1.494C - Helping PeopleWe'll first create a rooted tree from the given segments which each node represents a segment. We'll solve the problem using dynamic programming on this tree. First of all let's add a segment [1, n] with probability of being chosen by Malek equal to 0. The node representing this segment will be the root of the tree. Please note by adding this segment the rules described in the statements are still in place.Let's sort the rest of segments according to their starting point increasing and in case of equality according to their finishing point decreasing. Then we'll put the segment we added in the beginning. A segment's father is the right-most segment which comes before that segment and contains it. Please note that since we added segment [1, n] to the beginning every segment except the added segment has a father. We build the tree by putting a segment's node child of its father's node. In this tree for each two nodes u and v which none of them are in the subtree on another the segments representing these two nodes will not overlap. Also for each two nodes u and v which u is in subtree of v segment representing node u will be inside(not necessarily strictly) segment representing node v. We define mxi as the maximum money a person in the segment i initially has. mxi can be calculated using RMQ. Let's define ai, j as the probability of that after Malek finishes giving his money the maximum in the segment i is at most {mx}i + j. The properties of the tree we built allows us to calculate ai, j for every i and j in O(q2) (since 1 ≤ i, j ≤ q). If number of the segment we added is k then the answer will be . Calculating ai, j is described below:Suppose f is a child of i and suppose Malek doesn't accept the i-th recommendation. Then since we want the maximum number after money spreading to be at most mxi + j in segment i and since f is inside i we want the maximum number after money spreading to be at most mxi - mxf + j. If Malek accepts the recommendation then we want it to be at most mxi - mxf + j - 1. So if probability of i-th recommendation being accepted by Malek be equal to pi then . Using this formula we can calculate ak, j recursively and calculate the answer from it in O(q2). The overall complexity will be O(nlgn + q2). nlgn for creating RMQ used for calculating the array mx and q2 for the rest of the algorithm.494D - BirthdayWe solve this problem by answering queries offline. We'll first store in each vertex v number of vertices such as x for which we must calculate f(v, x) . starting from the root. We'll keep two arrays a and b. Suppose we're at vertex v right now then ai equals d(i, v)2 and bi equal d(i, v). Having these two arrays when moving from vertex v to a child with an edge with weight k one can note that bi for all is inside subtree of v decreases by k and all other bis gets increased by k. Knowing this fact one can also update array a as well. To calculate f(v, x) it's enough to be able to calculate sum of ais for all i inside subtree of x. Handling each of these operations is a well known problem and is possible using a segment tree. Overall complexity is O((n + q)lgn). There is an online solution using dynamic programming as well.494E - ShartiLet's first solve this problem for another game: Suppose that we've an n × n table. Each cell have some(possibly zero) marbles on it. During each move the player chooses a square with side-length at most k which its lower-right cell has at least one marble, he removes one marble from it and puts one marble in every other cell of this square. One can notice that in such game each marble is independent of the others and doesn't affect other marbles. So one can see this game as some separate games played on some tables. More formally for each marble placed in a cell such as (i, j) consider the game when played on a i × j table which the only marble placed on it is at its lower-right cell. Let's denote the Grundy number of this game by gi, j. Then according to Grundy theorem the first player has a winning strategy if and only if the xor of gi, j for every cell (i, j) having odd number of marbles on it is positive. To calculate gi, j note that the first move in such game must be choosing a square with its lower-right cell being the lower-right cell of table. So the only thing to decide is the side-length of chosen square at the first move. Let's say we choose the first square width side length l. Grundy number of the next state will be equal to xor of gc, d for every i - l < c ≤ i, j - l < d ≤ j. Using this fact one can calculate gi, j for all (1 ≤ i, j ≤ a) (a being an arbitrary integers) in O(a3).If we calculated the first values of gi, j one can see a pattern in the Grundy numbers. Then one can prove that gi, j = min(lowest_bit(i), lowest_bit(j), greatest_bit(k)) where lowest_bit(x) =  the maximum power of 2 which is a divisor of x and greatest_bit(x) =  the maximum power of 2 which is not greater than x. Now let's prove that our first game(the game described in the statement) is actually the same as this game. Suppose that a player has a winning strategy in the first game. Consider a table containing one marble at every cell which is white in the table of the first game. We'll prove that the same player has winning strategy in this game as well. Note that a cell is white in the first game if and only if the parity of marbles in the second game is odd so there is at least one marble on it. So as long as the other player chooses a square with its lower-right cell having odd number of marbles in the second game, his move corresponds to a move in the first game so the player having winning strategy can counter his move. If the other player chooses a square with its lower-right cell having even number of marbles, it means the cell had at least 2 marbles on it so the player can counter it by choosing the same square which makes the parity of every cell to be the same after these 2 moves. And since it can be proven that both of the game will end at some point then the player has winning strategy in this game as well. The reverse of this fact can also be proven the same since if a player has a winning strategy there is also a winning strategy in which this player always chooses squares with lower-right cell having odd number of marbles(since otherwise the other player can counter it as described above) and counters the moves of the other player at which he chose a square with lower-right cell having even number of marbles by choosing the same square(since the Grundy number by countering in this way won't change the Grundy number and thus won't change the player with winning strategy).So if we consider a table having one marble at each of the cells which are in at least one of the rectangles given in the input we only need to calculate the Grundy number of this state and check whether it's positive or not to determine the winner. To do this for each i(1 ≤ i ≤ greatest_bit(k)) lets define ai as the number of cells (x, y) which are contained in at least one of the given rectangles, 2i|x and 2i|y. Lets also define agreatest_bit(k) + 1 = 0. Then according the fact we described above about gi, j the number of 2is which are xored equals ai - ai + 1. Knowing this calculating the Grundy number of the initial state is easy. Calculating ai is identical to a very well-known problem which is given some rectangles count the number of cells in at least one of them and can be solved in O(mlgm) (m being number of rectangles). So overall complexity will be O(mlgmlgk).If there is any problem in the editorial please feel free to note that to us.Thank you.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/15148",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 495\\s*A"
          },
          "content_length": 11197
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #282 - Codeforces - Code 1",
          "code": "(#(\nAnswer: -1\nWA: 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15134",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #282 - Codeforces - Code 2",
          "code": "(#(\nAnswer: -1\nWA: 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15134",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #282 Editorial - Codeforces - Code 1",
          "code": "divisors of (a-b) greater than b",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15148",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #282 Editorial - Codeforces - Code 2",
          "code": "1 to sqrt(a-b)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15148",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #282 Editorial - Codeforces - Code 3",
          "code": "O(sqrt(a-b))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15148",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #282 Editorial - Codeforces - Code 4",
          "code": "input\n3 5\n1 2 3\n1 3 0.500\n2 2 0.250\n1 2 0.800\n1 1 0.120\n2 2 0.900\noutput\n4.465000000",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15148",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #282 Editorial - Codeforces - Code 5",
          "code": "input\n3 5\n1 2 3\n1 3 0.500\n2 2 0.250\n1 2 0.800\n1 1 0.120\n2 2 0.900\noutput\n4.465000000",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15148",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #282 Editorial - Codeforces - Code 6",
          "code": "using std::",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15148",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #282 Editorial - Codeforces - Code 7",
          "code": "using namespace std",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15148",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #282 Editorial - Codeforces - Code 8",
          "code": "#define next ____next\n#define prev ____prev\n#define y1   ____y1\n#define left ____left\n#define hash ____hash",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15148",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #282 Editorial - Codeforces - Code 9",
          "code": "#define next ____next\n#define prev ____prev\n#define y1   ____y1\n#define left ____left\n#define hash ____hash",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15148",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #282 Editorial - Codeforces - Code 10",
          "code": "#define max max<long long>",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15148",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #282 Editorial - Codeforces - Code 11",
          "code": "long long max(int a, long long b) { return max((long long)a, b); }\nlong long max(long long b, int a) { return max(a, (long long)b); }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15148",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #282 Editorial - Codeforces - Code 12",
          "code": "long long max(int a, long long b) { return max((long long)a, b); }\nlong long max(long long b, int a) { return max(a, (long long)b); }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15148",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #282 Editorial - Codeforces - Code 13",
          "code": "#define MAX(a,b) ((a)>(b)?(a):(b))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15148",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #282 Editorial - Codeforces - Code 14",
          "code": "#define MAX(a,b) ((a)>(b)?(a):(b))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15148",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #282 Editorial - Codeforces - Code 15",
          "code": "final string becomes beautiful",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15148",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #282 Editorial - Codeforces - Code 16",
          "code": "Node v = root",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15148",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #282 Editorial - Codeforces - Code 17",
          "code": "v = v.parent",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15148",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #282 Editorial - Codeforces - Code 18",
          "code": "input:\nddd\nd\noutput:\n12",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15148",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #282 Editorial - Codeforces - Code 19",
          "code": "input:\nddd\nd\noutput:\n12",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15148",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    string n_str = inf.readLine(\"[0-9]{2}\", \"n\");\n    int n = (n_str[0] - '0') * 10 + (n_str[1] - '0');\n    ensuref(0 <= n && n <= 99, \"n = %d is out of bounds\", n);\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    string n_str = inf.readLine(\"[0-9]{2}\", \"n\");\n    int n = (n_str[0] - '0') * 10 + (n_str[1] - '0');\n    ensuref(0 <= n && n <= 99, \"n = %d is out of bounds\", n);\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    string n_str = inf.readLine(\"[0-9]{2}\", \"n\");\n    int n = (n_str[0] - '0') * 10 + (n_str[1] - '0');\n    ensuref(0 <= n && n <= 99, \"n = %d is out of bounds\", n);\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    string type = opt<string>(\"type\", \"random\");\n\n    string n_str;\n    int n;\n\n    if (type == \"random\") {\n        n = rnd.next(0, 99);\n        if (n < 10)\n            n_str = \"0\" + to_string(n);\n        else\n            n_str = to_string(n);\n    } else if (type == \"leading_zero\") {\n        n = rnd.next(0, 9);\n        n_str = \"0\" + to_string(n);\n    } else if (type == \"max_good\") {\n        // Generating a number n that potentially has the maximum number of good integers\n        n_str = \"88\";\n    } else if (type == \"min_good\") {\n        // Generating a number n that potentially has the minimum number of good integers\n        n_str = \"89\";\n    } else if (type == \"sample1\") {\n        // First sample input\n        n_str = \"89\";\n    } else if (type == \"sample2\") {\n        // Second sample input\n        n_str = \"00\";\n    } else if (type == \"sample3\") {\n        // Third sample input\n        n_str = \"73\";\n    } else if (type == \"specific\") {\n        n = opt<int>(\"n\");\n        ensuref(n >= 0 && n <= 99, \"n must be between 0 and 99\");\n        if (n < 10)\n            n_str = \"0\" + to_string(n);\n        else\n            n_str = to_string(n);\n    } else if (type == \"all_same\") {\n        int d = rnd.next(0, 9);\n        n_str = to_string(d) + to_string(d);\n    } else if (type == \"near_zero\") {\n        n = rnd.next(0, 5);\n        n_str = \"0\" + to_string(n);\n    } else if (type == \"near_ninety_nine\") {\n        n = rnd.next(95, 99);\n        n_str = to_string(n);\n    } else {\n        // Default to random\n        n = rnd.next(0, 99);\n        if (n < 10)\n            n_str = \"0\" + to_string(n);\n        else\n            n_str = to_string(n);\n    }\n\n    cout << n_str << endl;\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    string type = opt<string>(\"type\", \"random\");\n\n    string n_str;\n    int n;\n\n    if (type == \"random\") {\n        n = rnd.next(0, 99);\n        if (n < 10)\n            n_str = \"0\" + to_string(n);\n        else\n            n_str = to_string(n);\n    } else if (type == \"leading_zero\") {\n        n = rnd.next(0, 9);\n        n_str = \"0\" + to_string(n);\n    } else if (type == \"max_good\") {\n        // Generating a number n that potentially has the maximum number of good integers\n        n_str = \"88\";\n    } else if (type == \"min_good\") {\n        // Generating a number n that potentially has the minimum number of good integers\n        n_str = \"89\";\n    } else if (type == \"sample1\") {\n        // First sample input\n        n_str = \"89\";\n    } else if (type == \"sample2\") {\n        // Second sample input\n        n_str = \"00\";\n    } else if (type == \"sample3\") {\n        // Third sample input\n        n_str = \"73\";\n    } else if (type == \"specific\") {\n        n = opt<int>(\"n\");\n        ensuref(n >= 0 && n <= 99, \"n must be between 0 and 99\");\n        if (n < 10)\n            n_str = \"0\" + to_string(n);\n        else\n            n_str = to_string(n);\n    } else if (type == \"all_same\") {\n        int d = rnd.next(0, 9);\n        n_str = to_string(d) + to_string(d);\n    } else if (type == \"near_zero\") {\n        n = rnd.next(0, 5);\n        n_str = \"0\" + to_string(n);\n    } else if (type == \"near_ninety_nine\") {\n        n = rnd.next(95, 99);\n        n_str = to_string(n);\n    } else {\n        // Default to random\n        n = rnd.next(0, 99);\n        if (n < 10)\n            n_str = \"0\" + to_string(n);\n        else\n            n_str = to_string(n);\n    }\n\n    cout << n_str << endl;\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -type sample1\n./gen -type sample2\n./gen -type sample3\n./gen -type random\n./gen -type random\n./gen -type random\n./gen -type random\n./gen -type leading_zero\n./gen -type leading_zero\n./gen -type leading_zero\n./gen -type max_good\n./gen -type min_good\n./gen -type all_same\n./gen -type all_same\n./gen -type specific -n 0\n./gen -type specific -n 99\n./gen -type specific -n 88\n./gen -type specific -n 11\n./gen -type specific -n 22\n./gen -type near_zero\n./gen -type near_zero\n./gen -type near_zero\n./gen -type near_ninety_nine\n./gen -type near_ninety_nine\n./gen -type near_ninety_nine\n./gen -type random\n./gen -type random\n./gen -type random\n./gen -type random\n./gen -type specific -n 13\n./gen -type specific -n 42\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:38:50.969378",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "495/B",
      "title": "B. Модулярные уравнения",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест1 секунда",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеВ единственной строке ввода даны два целых числа, a и b (0 ≤ a, b ≤ 109).",
      "output_spec": "Выходные данныеЕсли существует бесконечное количество решений данного уравнения, выведите «infinity» (без кавычек). В противном случае, выведите количество решений модулярного уравнения .",
      "sample_tests": "ПримерыВходные данныеСкопировать21 5Выходные данныеСкопировать2Входные данныеСкопировать9435152 272Выходные данныеСкопировать282Входные данныеСкопировать10 10Выходные данныеСкопироватьinfinity",
      "description": "B. Модулярные уравнения\n\nограничение по времени на тест1 секунда\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвыводstdout\n\nВходные данныеВ единственной строке ввода даны два целых числа, a и b (0 ≤ a, b ≤ 109).\n\nВходные данные\n\nВыходные данныеЕсли существует бесконечное количество решений данного уравнения, выведите «infinity» (без кавычек). В противном случае, выведите количество решений модулярного уравнения .\n\nВыходные данные\n\nВходные данныеСкопировать21 5Выходные данныеСкопировать2Входные данныеСкопировать9435152 272Выходные данныеСкопировать282Входные данныеСкопировать10 10Выходные данныеСкопироватьinfinity\n\nВходные данныеСкопировать21 5\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать2\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать9435152 272\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать282\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать10 10\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопироватьinfinity\n\nВыходные данныеСкопировать\n\nСкопировать\n\nПримечаниеВ первом примере решения модулярного уравнения — 8 и 16, так как",
      "solutions": [
        {
          "title": "Codeforces Round #282 - Codeforces",
          "content": "Hi, Codeforces Round #282 will be held at 13th of December, 19:30 MSK. Please don't note anything since the time is the usual time of contests.The round is prepared by FarbodY, Haghani and Me(matrix). We'd like to thank Zlobober who helped us a LOT for preparing the problems, MikeMirzayanov for the Polygon and Codeforces platforms and Delinur for helping us in preparing statements and translating them.Our special thanks goes to mruxim for testing the round.The problems will be sorted according to the estimated order of difficulty according to our opinion but we strongly recommend you to read all of the problems.As always the update regarding score distribution will be posted just before the round starts. :)UPD: It was written that contest starts at 20:00 MSK. it was a mistake and is fixed now. The round starts at usual time 19:30 MSK.UPD2: We also thank niyaznigmatul for testing our round.UPD3: Score distribution:Div1: 500-1000-1750-1750-2500Div2: 500-1000-1500-2000-2750As you might have noticed, the scores can now be multiples of 250 as well. Let's thank Codeforces team for adding this feature!Good luck and Have fun!UPD4: Congratulations to the winners of both divisions:Div1: tourist winger sankear uwi Egor Div2: Ginger88895 pwild arthurpd konmaj ezkatka The editorial for all problems except D and E Div1 are ready and can be found here. It'll be completed soon.We thank you all for participating and hope you had a good time.UPD5: The editorial is now complete and can be found here.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/15134",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1506
        },
        {
          "title": "Codeforces Round #282 Editorial - Codeforces",
          "content": "495A - Digital CounterFor each digit x you can count the number of digits y that because of some broken sticks x is shown instead of y by hand. for example when x = 3, y can be 3, 8 and 9. Let's denote this number by ax. Then if the input is xy (the first digit shown in the counter is x and the second is y) the answer will be ax × ay.495B - Modular Equations If a < b then there is no answer since . If a = b then x can be any integer larger than a. so there are infinite number of answers to the equation. The only remaining case is when a > b. Suppose x is an answer to our equation. Then x|a - b. Also since then b < x. These conditions are necessary and sufficient as well. So the answer is number of divisors of a - b which are strictly greater than b which can be solved in . 494A - TreasureConsider a string consisting of '(' and ')' characters. Let's build the following sequence from this string: a0 = 0 for each 1 ≤ i ≤ |s| ai = ai - 1 + 1 if si = '(' and ai = ai - 1 - 1 otherwise. (The string is considered as 1-based index). It can be proven that a string is beautiful if the following conditions are satisfied: for each 0 ≤ i ≤ |s| ai ≥ 0. a|s| = 0 Using the above fact we can prove that if in a beautiful string we remove a ')' character and put it further toward the end of the string the resulting string is beautiful as well. These facts leads us to the following fact: if we can move a ')' character further toward the end of string it is better if we'd do it. This yields the following greedy solution:We'll first put exactly one ')' character at each '#' character. Then we'll build the sequence we described above. if the first condition isn't satisfied then there is no way that leads to a beautiful string. So the answer is -1. Otherwise we must put exactly a|s| more ')' characters in the place of last '#' character. Then if this string is beautiful we'll print it otherwise the answer is -1.494B - Obsessive StringWe call an index i(1 ≤ i ≤ |s|) good if t equals si - |t| + 1si - |t| + 2... si. To find all good indexes let's define qi as the length of longest prefix of t which is a suffix of s1s2... si. A good index is an index with qi = |t|. Calculating qi can be done using Knuth-Morris-Pratt algorithm. Let's define ai as the number of ways to choose some(at least one) non-overlapping substrings of the prefix of s with length i (s1s2... si) so t is a substring of each one of them and si is in one the chosen substrings(So it must actually be the last character of last chosen substring). Then the answer will be .Also let's define two additional sequence q1 and q2 which will help us in calculating a.The sequence a can then be calculated in O(n) as described below:If i is not a good index ai = ai - 1 since in each way counted in ai the substring containing si also contains si - 1 so for each of these ways removing si from the substring containing it leads to a way counted in ai - 1 and vice-versa thus these two numbers are equal. If i is a good index then ai = q2i - |t| + i - |t| + 1. To prove this let's consider a way of choosing substring counted in ai. We call such a way valid. The substring containing si can be any of the substrings sjsj + 1... si (1 ≤ j ≤ i - |t| + 1). There are i - |t| + 1 valid ways in which this substring is the only substring we've chosen. Number of valid ways in which substring containing si starts at sj equals to q1j - 1. So the total number of valid ways in which we've chosen at least two substrings are equal to which is equal to q2j - 1. So ai = q2i - |t| + i - |t| + 1.494C - Helping PeopleWe'll first create a rooted tree from the given segments which each node represents a segment. We'll solve the problem using dynamic programming on this tree. First of all let's add a segment [1, n] with probability of being chosen by Malek equal to 0. The node representing this segment will be the root of the tree. Please note by adding this segment the rules described in the statements are still in place.Let's sort the rest of segments according to their starting point increasing and in case of equality according to their finishing point decreasing. Then we'll put the segment we added in the beginning. A segment's father is the right-most segment which comes before that segment and contains it. Please note that since we added segment [1, n] to the beginning every segment except the added segment has a father. We build the tree by putting a segment's node child of its father's node. In this tree for each two nodes u and v which none of them are in the subtree on another the segments representing these two nodes will not overlap. Also for each two nodes u and v which u is in subtree of v segment representing node u will be inside(not necessarily strictly) segment representing node v. We define mxi as the maximum money a person in the segment i initially has. mxi can be calculated using RMQ. Let's define ai, j as the probability of that after Malek finishes giving his money the maximum in the segment i is at most {mx}i + j. The properties of the tree we built allows us to calculate ai, j for every i and j in O(q2) (since 1 ≤ i, j ≤ q). If number of the segment we added is k then the answer will be . Calculating ai, j is described below:Suppose f is a child of i and suppose Malek doesn't accept the i-th recommendation. Then since we want the maximum number after money spreading to be at most mxi + j in segment i and since f is inside i we want the maximum number after money spreading to be at most mxi - mxf + j. If Malek accepts the recommendation then we want it to be at most mxi - mxf + j - 1. So if probability of i-th recommendation being accepted by Malek be equal to pi then . Using this formula we can calculate ak, j recursively and calculate the answer from it in O(q2). The overall complexity will be O(nlgn + q2). nlgn for creating RMQ used for calculating the array mx and q2 for the rest of the algorithm.494D - BirthdayWe solve this problem by answering queries offline. We'll first store in each vertex v number of vertices such as x for which we must calculate f(v, x) . starting from the root. We'll keep two arrays a and b. Suppose we're at vertex v right now then ai equals d(i, v)2 and bi equal d(i, v). Having these two arrays when moving from vertex v to a child with an edge with weight k one can note that bi for all is inside subtree of v decreases by k and all other bis gets increased by k. Knowing this fact one can also update array a as well. To calculate f(v, x) it's enough to be able to calculate sum of ais for all i inside subtree of x. Handling each of these operations is a well known problem and is possible using a segment tree. Overall complexity is O((n + q)lgn). There is an online solution using dynamic programming as well.494E - ShartiLet's first solve this problem for another game: Suppose that we've an n × n table. Each cell have some(possibly zero) marbles on it. During each move the player chooses a square with side-length at most k which its lower-right cell has at least one marble, he removes one marble from it and puts one marble in every other cell of this square. One can notice that in such game each marble is independent of the others and doesn't affect other marbles. So one can see this game as some separate games played on some tables. More formally for each marble placed in a cell such as (i, j) consider the game when played on a i × j table which the only marble placed on it is at its lower-right cell. Let's denote the Grundy number of this game by gi, j. Then according to Grundy theorem the first player has a winning strategy if and only if the xor of gi, j for every cell (i, j) having odd number of marbles on it is positive. To calculate gi, j note that the first move in such game must be choosing a square with its lower-right cell being the lower-right cell of table. So the only thing to decide is the side-length of chosen square at the first move. Let's say we choose the first square width side length l. Grundy number of the next state will be equal to xor of gc, d for every i - l < c ≤ i, j - l < d ≤ j. Using this fact one can calculate gi, j for all (1 ≤ i, j ≤ a) (a being an arbitrary integers) in O(a3).If we calculated the first values of gi, j one can see a pattern in the Grundy numbers. Then one can prove that gi, j = min(lowest_bit(i), lowest_bit(j), greatest_bit(k)) where lowest_bit(x) =  the maximum power of 2 which is a divisor of x and greatest_bit(x) =  the maximum power of 2 which is not greater than x. Now let's prove that our first game(the game described in the statement) is actually the same as this game. Suppose that a player has a winning strategy in the first game. Consider a table containing one marble at every cell which is white in the table of the first game. We'll prove that the same player has winning strategy in this game as well. Note that a cell is white in the first game if and only if the parity of marbles in the second game is odd so there is at least one marble on it. So as long as the other player chooses a square with its lower-right cell having odd number of marbles in the second game, his move corresponds to a move in the first game so the player having winning strategy can counter his move. If the other player chooses a square with its lower-right cell having even number of marbles, it means the cell had at least 2 marbles on it so the player can counter it by choosing the same square which makes the parity of every cell to be the same after these 2 moves. And since it can be proven that both of the game will end at some point then the player has winning strategy in this game as well. The reverse of this fact can also be proven the same since if a player has a winning strategy there is also a winning strategy in which this player always chooses squares with lower-right cell having odd number of marbles(since otherwise the other player can counter it as described above) and counters the moves of the other player at which he chose a square with lower-right cell having even number of marbles by choosing the same square(since the Grundy number by countering in this way won't change the Grundy number and thus won't change the player with winning strategy).So if we consider a table having one marble at each of the cells which are in at least one of the rectangles given in the input we only need to calculate the Grundy number of this state and check whether it's positive or not to determine the winner. To do this for each i(1 ≤ i ≤ greatest_bit(k)) lets define ai as the number of cells (x, y) which are contained in at least one of the given rectangles, 2i|x and 2i|y. Lets also define agreatest_bit(k) + 1 = 0. Then according the fact we described above about gi, j the number of 2is which are xored equals ai - ai + 1. Knowing this calculating the Grundy number of the initial state is easy. Calculating ai is identical to a very well-known problem which is given some rectangles count the number of cells in at least one of them and can be solved in O(mlgm) (m being number of rectangles). So overall complexity will be O(mlgmlgk).If there is any problem in the editorial please feel free to note that to us.Thank you.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/15148",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 495\\s*B"
          },
          "content_length": 11197
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #282 - Codeforces - Code 1",
          "code": "(#(\nAnswer: -1\nWA: 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15134",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #282 - Codeforces - Code 2",
          "code": "(#(\nAnswer: -1\nWA: 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15134",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #282 Editorial - Codeforces - Code 1",
          "code": "divisors of (a-b) greater than b",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15148",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #282 Editorial - Codeforces - Code 2",
          "code": "1 to sqrt(a-b)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15148",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #282 Editorial - Codeforces - Code 3",
          "code": "O(sqrt(a-b))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15148",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #282 Editorial - Codeforces - Code 4",
          "code": "input\n3 5\n1 2 3\n1 3 0.500\n2 2 0.250\n1 2 0.800\n1 1 0.120\n2 2 0.900\noutput\n4.465000000",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15148",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #282 Editorial - Codeforces - Code 5",
          "code": "input\n3 5\n1 2 3\n1 3 0.500\n2 2 0.250\n1 2 0.800\n1 1 0.120\n2 2 0.900\noutput\n4.465000000",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15148",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #282 Editorial - Codeforces - Code 6",
          "code": "using std::",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15148",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #282 Editorial - Codeforces - Code 7",
          "code": "using namespace std",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15148",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #282 Editorial - Codeforces - Code 8",
          "code": "#define next ____next\n#define prev ____prev\n#define y1   ____y1\n#define left ____left\n#define hash ____hash",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15148",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #282 Editorial - Codeforces - Code 9",
          "code": "#define next ____next\n#define prev ____prev\n#define y1   ____y1\n#define left ____left\n#define hash ____hash",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15148",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #282 Editorial - Codeforces - Code 10",
          "code": "#define max max<long long>",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15148",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #282 Editorial - Codeforces - Code 11",
          "code": "long long max(int a, long long b) { return max((long long)a, b); }\nlong long max(long long b, int a) { return max(a, (long long)b); }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15148",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #282 Editorial - Codeforces - Code 12",
          "code": "long long max(int a, long long b) { return max((long long)a, b); }\nlong long max(long long b, int a) { return max(a, (long long)b); }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15148",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #282 Editorial - Codeforces - Code 13",
          "code": "#define MAX(a,b) ((a)>(b)?(a):(b))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15148",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #282 Editorial - Codeforces - Code 14",
          "code": "#define MAX(a,b) ((a)>(b)?(a):(b))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15148",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #282 Editorial - Codeforces - Code 15",
          "code": "final string becomes beautiful",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15148",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #282 Editorial - Codeforces - Code 16",
          "code": "Node v = root",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15148",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #282 Editorial - Codeforces - Code 17",
          "code": "v = v.parent",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15148",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #282 Editorial - Codeforces - Code 18",
          "code": "input:\nddd\nd\noutput:\n12",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15148",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #282 Editorial - Codeforces - Code 19",
          "code": "input:\nddd\nd\noutput:\n12",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15148",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int a = inf.readInt(0, 1000000000, \"a\");\n    inf.readSpace();\n    int b = inf.readInt(0, 1000000000, \"b\");\n    inf.readEoln();\n    inf.readEof();\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int a = inf.readInt(0, 1000000000, \"a\");\n    inf.readSpace();\n    int b = inf.readInt(0, 1000000000, \"b\");\n    inf.readEoln();\n    inf.readEof();\n\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int a = inf.readInt(0, 1000000000, \"a\");\n    inf.readSpace();\n    int b = inf.readInt(0, 1000000000, \"b\");\n    inf.readEoln();\n    inf.readEof();\n\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare sequences of tokens\");\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string j, p;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n\r\n        ans.readWordTo(j);\r\n        ouf.readWordTo(p);\r\n\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s words differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  compress(j).c_str(), compress(p).c_str());\r\n    }\r\n\r\n    if (ans.seekEof() && ouf.seekEof()) {\r\n        if (n == 1)\r\n            quitf(_ok, \"\\\"%s\\\"\", compress(j).c_str());\r\n        else\r\n            quitf(_ok, \"%d tokens\", n);\r\n    } else {\r\n        if (ans.seekEof())\r\n            quitf(_wa, \"Participant output contains extra tokens\");\r\n        else\r\n            quitf(_wa, \"Unexpected EOF in the participants output\");\r\n    }\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    string type = opt<string>(\"type\", \"random\");\n    int limit = opt<int>(\"limit\", 1e9);\n\n    int a, b;\n\n    if (type == \"small\") {\n        // Generate small values\n        a = rnd.next(0, 100);\n        b = rnd.next(0, 100);\n    } else if (type == \"large\") {\n        // Generate large values\n        a = rnd.next(limit - 1000, limit);\n        b = rnd.next(limit - 1000, limit);\n    } else if (type == \"a_equal_b\") {\n        // a equals b\n        a = rnd.next(0, limit);\n        b = a;\n    } else if (type == \"a_zero\") {\n        a = 0;\n        b = rnd.next(0, limit);\n    } else if (type == \"b_zero\") {\n        a = rnd.next(0, limit);\n        b = 0;\n    } else if (type == \"both_zero\") {\n        a = 0;\n        b = 0;\n    } else if (type == \"infinite_solution\") {\n        // Generate a and b such that the number of solutions is infinite\n        a = rnd.next(0, limit);\n        b = a;\n    } else if (type == \"max_limit\") {\n        a = limit;\n        b = limit;\n    } else {\n        // Random values\n        a = rnd.next(0, limit);\n        b = rnd.next(0, limit);\n    }\n\n    printf(\"%d %d\\n\", a, b);\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    string type = opt<string>(\"type\", \"random\");\n    int limit = opt<int>(\"limit\", 1e9);\n\n    int a, b;\n\n    if (type == \"small\") {\n        // Generate small values\n        a = rnd.next(0, 100);\n        b = rnd.next(0, 100);\n    } else if (type == \"large\") {\n        // Generate large values\n        a = rnd.next(limit - 1000, limit);\n        b = rnd.next(limit - 1000, limit);\n    } else if (type == \"a_equal_b\") {\n        // a equals b\n        a = rnd.next(0, limit);\n        b = a;\n    } else if (type == \"a_zero\") {\n        a = 0;\n        b = rnd.next(0, limit);\n    } else if (type == \"b_zero\") {\n        a = rnd.next(0, limit);\n        b = 0;\n    } else if (type == \"both_zero\") {\n        a = 0;\n        b = 0;\n    } else if (type == \"infinite_solution\") {\n        // Generate a and b such that the number of solutions is infinite\n        a = rnd.next(0, limit);\n        b = a;\n    } else if (type == \"max_limit\") {\n        a = limit;\n        b = limit;\n    } else {\n        // Random values\n        a = rnd.next(0, limit);\n        b = rnd.next(0, limit);\n    }\n\n    printf(\"%d %d\\n\", a, b);\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -type small\n./gen -type small\n./gen -type small\n\n./gen -type large\n./gen -type large\n\n./gen -type random\n./gen -type random\n./gen -type random\n./gen -type random\n\n./gen -type a_equal_b\n./gen -type a_equal_b\n./gen -type a_zero\n./gen -type b_zero\n./gen -type both_zero\n\n./gen -type infinite_solution\n./gen -type infinite_solution\n./gen -type max_limit\n\n./gen -type random -limit 1000000\n./gen -type random -limit 1000000\n\n# Test with limit adjusted\n./gen -type small -limit 100\n./gen -type small -limit 1000\n./gen -type small -limit 10000\n\n# Edge cases\n./gen -type large -limit 999999999\n./gen -type a_equal_b -limit 0\n./gen -type a_equal_b -limit 1\n./gen -type a_equal_b -limit 1000000000\n\n# Random tests\n./gen -type random\n./gen -type random\n./gen -type random\n\n# More tests\n./gen -type a_zero\n./gen -type b_zero\n./gen -type both_zero\n./gen -type random -limit 0\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:38:53.044213",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "495/C",
      "title": "Problem 495/C",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "",
      "memory_limit": "",
      "input_spec": "",
      "output_spec": "",
      "sample_tests": "",
      "description": "",
      "solutions": [],
      "code_examples": [],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    string s = inf.readLine(\"[()#]{1,100000}\", \"s\");\n\n    ensuref(s.find('#') != string::npos, \"s must contain at least one '#' character\");\n\n    inf.readEof();\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    string s = inf.readLine(\"[()#]{1,100000}\", \"s\");\n\n    ensuref(s.find('#') != string::npos, \"s must contain at least one '#' character\");\n\n    inf.readEof();\n\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    string s = inf.readLine(\"[()#]{1,100000}\", \"s\");\n\n    ensuref(s.find('#') != string::npos, \"s must contain at least one '#' character\");\n\n    inf.readEof();\n\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerTestlibCmd(argc, argv);\n\n    string s = inf.readString(); // Read the input string s\n\n    string jans; // Juror's answer\n    try {\n        jans = ans.readToken();\n    } catch (...) {\n        quitf(_fail, \"Jury's answer is empty\");\n    }\n\n    string pans; // Participant's answer\n    try {\n        pans = ouf.readToken();\n    } catch (...) {\n        quitf(_pe, \"Contestant's output is empty\");\n    }\n\n    if (jans == \"-1\") {\n        // Jury says the problem is impossible\n        if (pans == \"-1\") {\n            // Accept\n            if (!ouf.seekEof())\n                quitf(_wa, \"Extra data after -1\");\n            quitf(_ok, \"Correct impossible answer\");\n        } else {\n            // Contestant outputs an answer when problem is impossible\n            quitf(_wa, \"Problem is impossible, contestant outputs an answer\");\n        }\n    } else {\n        // Jury says problem is possible\n        if (pans == \"-1\") {\n            // Contestant says problem is impossible when it's possible\n            quitf(_wa, \"Problem is possible, contestant outputs -1\");\n        } else {\n            // Validate the contestant's answer\n            ouf.reset(); // Reset ouf to read from beginning\n            vector<int> nums;\n            while (!ouf.seekEof()) {\n                int num = ouf.readInt(1, INT_MAX, \"number of ')'\");\n                nums.push_back(num);\n            }\n\n            int num_hashes = count(s.begin(), s.end(), '#');\n            if ((int)nums.size() != num_hashes) {\n                quitf(_wa, \"Expected %d numbers, but got %d numbers\", num_hashes, nums.size());\n            }\n\n            // Replace '#' in s with specified numbers of ')'\n            string t;\n            int idx = 0;\n            for (char c : s) {\n                if (c == '#') {\n                    t += string(nums[idx], ')');\n                    idx++;\n                } else {\n                    t += c;\n                }\n            }\n\n            // Check that t is beautiful\n            int balance = 0;\n            for (int i = 0; i < (int)t.size(); ++i) {\n                if (t[i] == '(') {\n                    balance++;\n                } else if (t[i] == ')') {\n                    balance--;\n                } else {\n                    quitf(_fail, \"Invalid character '%c' in transformed string\", t[i]);\n                }\n                if (balance < 0) {\n                    quitf(_wa, \"Too many ')' at position %d\", i + 1);\n                }\n            }\n            if (balance != 0) {\n                quitf(_wa, \"Unmatched number of '(' and ')' at the end\");\n            }\n\n            // All checks passed\n            quitf(_ok, \"Answer is correct\");\n        }\n    }\n    return 0;\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random_possible\");\n\n    string s;\n\n    if (type == \"minimal_impossible\") {\n        // s = '#', length must be 1\n        s = \"#\";\n        // Ensure n=1\n        n = 1;\n    } else if (type == \"maximal_impossible\") {\n        // s = '#' repeated n times\n        s = string(n, '#');\n    } else if (type == \"random_possible\") {\n        // Generate a random s that can be made beautiful\n        // First, generate a random balanced parenthesis string\n        stack<char> st;\n        s = \"\";\n        int open = 0, close = 0;\n        for (int i = 0; i < n / 2; ++i) {\n            s += '(';\n        }\n        for (int i = n / 2; i < n; ++i) {\n            s += ')';\n        }\n        shuffle(s.begin(), s.end());\n\n        // Now, replace some ')' with '#'\n        vector<int> positions;\n        for (int i = 0; i < s.size(); ++i) {\n            if (s[i] == ')') positions.push_back(i);\n        }\n        int num_hashes = max(1, min((int)positions.size(), n / 20)); // up to 5% of positions\n        shuffle(positions.begin(), positions.end());\n        for (int i = 0; i < num_hashes; ++i) {\n            s[positions[i]] = '#';\n        }\n        // Make sure there's at least one '#'\n        if (s.find('#') == string::npos) {\n            s[positions[0]] = '#';\n        }\n        // Adjust n as needed\n        if (s.size() > n) {\n            s = s.substr(0, n);\n        }\n\n    } else if (type == \"random_impossible\") {\n        // Generate random s that cannot be made beautiful\n        s = \"\";\n        int balance = 0;\n        for (int i = 0; i < n; ++i) {\n            int ch = rnd.next(3);\n            if (ch == 0) {\n                s += '(';\n                balance++;\n            } else if (ch == 1) {\n                s += ')';\n                balance--;\n            } else {\n                s += '#';\n            }\n            // Introduce imbalance\n            if (balance < -rnd.next(3)) {\n                // Break balance\n                s += string(n - i - 1, '(');\n                break;\n            }\n        }\n        if (s.find('#') == string::npos) {\n            // Ensure there's at least one '#'\n            s += '#';\n        }\n        if (s.size() > n) {\n            s = s.substr(0, n);\n        }\n    } else if (type == \"maximal_depth\") {\n        // Generate s with maximum depth, i.e., all '(' followed by a '#'\n        s = string(n - 1, '(') + '#';\n    } else if (type == \"possible_with_unique_solution\") {\n        // Generate s that can be made beautiful in exactly one way\n        s = \"(()#(\";\n        if (n > s.length()) {\n            s += string(n - s.length(), '(');\n        } else {\n            s = s.substr(0, n);\n        }\n    } else if (type == \"all_hashes\") {\n        s = string(n, '#');\n    } else if (type == \"random\") {\n        // Simply generate random s with '(', ')', '#'\n        s = \"\";\n        for (int i = 0; i < n; ++i) {\n            int ch = rnd.next(3);\n            if (ch == 0)\n                s += '(';\n            else if (ch == 1)\n                s += ')';\n            else\n                s += '#';\n        }\n        if (s.find('#') == string::npos) {\n            // Ensure there's at least one '#'\n            s[rnd.next(n)] = '#';\n        }\n    }\n\n    // Output s\n    printf(\"%s\\n\", s.c_str());\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random_possible\");\n\n    string s;\n\n    if (type == \"minimal_impossible\") {\n        // s = '#', length must be 1\n        s = \"#\";\n        // Ensure n=1\n        n = 1;\n    } else if (type == \"maximal_impossible\") {\n        // s = '#' repeated n times\n        s = string(n, '#');\n    } else if (type == \"random_possible\") {\n        // Generate a random s that can be made beautiful\n        // First, generate a random balanced parenthesis string\n        stack<char> st;\n        s = \"\";\n        int open = 0, close = 0;\n        for (int i = 0; i < n / 2; ++i) {\n            s += '(';\n        }\n        for (int i = n / 2; i < n; ++i) {\n            s += ')';\n        }\n        shuffle(s.begin(), s.end());\n\n        // Now, replace some ')' with '#'\n        vector<int> positions;\n        for (int i = 0; i < s.size(); ++i) {\n            if (s[i] == ')') positions.push_back(i);\n        }\n        int num_hashes = max(1, min((int)positions.size(), n / 20)); // up to 5% of positions\n        shuffle(positions.begin(), positions.end());\n        for (int i = 0; i < num_hashes; ++i) {\n            s[positions[i]] = '#';\n        }\n        // Make sure there's at least one '#'\n        if (s.find('#') == string::npos) {\n            s[positions[0]] = '#';\n        }\n        // Adjust n as needed\n        if (s.size() > n) {\n            s = s.substr(0, n);\n        }\n\n    } else if (type == \"random_impossible\") {\n        // Generate random s that cannot be made beautiful\n        s = \"\";\n        int balance = 0;\n        for (int i = 0; i < n; ++i) {\n            int ch = rnd.next(3);\n            if (ch == 0) {\n                s += '(';\n                balance++;\n            } else if (ch == 1) {\n                s += ')';\n                balance--;\n            } else {\n                s += '#';\n            }\n            // Introduce imbalance\n            if (balance < -rnd.next(3)) {\n                // Break balance\n                s += string(n - i - 1, '(');\n                break;\n            }\n        }\n        if (s.find('#') == string::npos) {\n            // Ensure there's at least one '#'\n            s += '#';\n        }\n        if (s.size() > n) {\n            s = s.substr(0, n);\n        }\n    } else if (type == \"maximal_depth\") {\n        // Generate s with maximum depth, i.e., all '(' followed by a '#'\n        s = string(n - 1, '(') + '#';\n    } else if (type == \"possible_with_unique_solution\") {\n        // Generate s that can be made beautiful in exactly one way\n        s = \"(()#(\";\n        if (n > s.length()) {\n            s += string(n - s.length(), '(');\n        } else {\n            s = s.substr(0, n);\n        }\n    } else if (type == \"all_hashes\") {\n        s = string(n, '#');\n    } else if (type == \"random\") {\n        // Simply generate random s with '(', ')', '#'\n        s = \"\";\n        for (int i = 0; i < n; ++i) {\n            int ch = rnd.next(3);\n            if (ch == 0)\n                s += '(';\n            else if (ch == 1)\n                s += ')';\n            else\n                s += '#';\n        }\n        if (s.find('#') == string::npos) {\n            // Ensure there's at least one '#'\n            s[rnd.next(n)] = '#';\n        }\n    }\n\n    // Output s\n    printf(\"%s\\n\", s.c_str());\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -type minimal_impossible\n./gen -n 10 -type maximal_impossible\n./gen -n 50 -type maximal_impossible\n./gen -n 100 -type random_possible\n./gen -n 1000 -type random_possible\n./gen -n 10000 -type random_possible\n./gen -n 100000 -type random_possible\n./gen -n 100000 -type random_impossible\n./gen -n 50000 -type random_impossible\n./gen -n 100000 -type maximal_depth\n./gen -n 99999 -type maximal_depth\n./gen -n 1000 -type maximal_depth\n./gen -n 50000 -type possible_with_unique_solution\n./gen -n 100000 -type possible_with_unique_solution\n./gen -n 100000 -type all_hashes\n./gen -n 50000 -type all_hashes\n./gen -n 100 -type all_hashes\n./gen -n 100000 -type random\n./gen -n 1 -type random\n./gen -n 1 -type all_hashes\n./gen -n 2 -type random_impossible\n./gen -n 10 -type random_impossible\n./gen -n 100 -type random_impossible\n./gen -n 1000 -type random_impossible\n./gen -n 100 -type minimal_impossible\n./gen -n 50 -type possible_with_unique_solution\n./gen -n 10 -type possible_with_unique_solution\n./gen -n 25 -type maximal_depth\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:38:54.922769",
        "total_tutorials": 0,
        "has_ai_judgment": false,
        "has_code_files": true
      }
    },
    {
      "problem_id": "495/D",
      "title": "D. Obsessive String",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputInput consists of two lines containing strings s and t (1 ≤ |s|, |t| ≤ 105). Each string consists of lowercase Latin letters.",
      "output_spec": "OutputPrint the answer in a single line.",
      "sample_tests": "ExamplesInputCopyababaabaOutputCopy5InputCopywelcometoroundtwohundredandeightytwodOutputCopy274201InputCopyddddOutputCopy12",
      "description": "D. Obsessive String\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputInput consists of two lines containing strings s and t (1 ≤ |s|, |t| ≤ 105). Each string consists of lowercase Latin letters.\n\nOutputPrint the answer in a single line.\n\nInputCopyababaabaOutputCopy5InputCopywelcometoroundtwohundredandeightytwodOutputCopy274201InputCopyddddOutputCopy12\n\nInputCopyababaaba\n\nOutputCopy5\n\nInputCopywelcometoroundtwohundredandeightytwod\n\nOutputCopy274201\n\nInputCopydddd\n\nOutputCopy12",
      "solutions": [
        {
          "title": "Codeforces Round #282 - Codeforces",
          "content": "Hi, Codeforces Round #282 will be held at 13th of December, 19:30 MSK. Please don't note anything since the time is the usual time of contests.The round is prepared by FarbodY, Haghani and Me(matrix). We'd like to thank Zlobober who helped us a LOT for preparing the problems, MikeMirzayanov for the Polygon and Codeforces platforms and Delinur for helping us in preparing statements and translating them.Our special thanks goes to mruxim for testing the round.The problems will be sorted according to the estimated order of difficulty according to our opinion but we strongly recommend you to read all of the problems.As always the update regarding score distribution will be posted just before the round starts. :)UPD: It was written that contest starts at 20:00 MSK. it was a mistake and is fixed now. The round starts at usual time 19:30 MSK.UPD2: We also thank niyaznigmatul for testing our round.UPD3: Score distribution:Div1: 500-1000-1750-1750-2500Div2: 500-1000-1500-2000-2750As you might have noticed, the scores can now be multiples of 250 as well. Let's thank Codeforces team for adding this feature!Good luck and Have fun!UPD4: Congratulations to the winners of both divisions:Div1: tourist winger sankear uwi Egor Div2: Ginger88895 pwild arthurpd konmaj ezkatka The editorial for all problems except D and E Div1 are ready and can be found here. It'll be completed soon.We thank you all for participating and hope you had a good time.UPD5: The editorial is now complete and can be found here.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/15134",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1506
        },
        {
          "title": "Codeforces Round #282 Editorial - Codeforces",
          "content": "495A - Digital CounterFor each digit x you can count the number of digits y that because of some broken sticks x is shown instead of y by hand. for example when x = 3, y can be 3, 8 and 9. Let's denote this number by ax. Then if the input is xy (the first digit shown in the counter is x and the second is y) the answer will be ax × ay.495B - Modular Equations If a < b then there is no answer since . If a = b then x can be any integer larger than a. so there are infinite number of answers to the equation. The only remaining case is when a > b. Suppose x is an answer to our equation. Then x|a - b. Also since then b < x. These conditions are necessary and sufficient as well. So the answer is number of divisors of a - b which are strictly greater than b which can be solved in . 494A - TreasureConsider a string consisting of '(' and ')' characters. Let's build the following sequence from this string: a0 = 0 for each 1 ≤ i ≤ |s| ai = ai - 1 + 1 if si = '(' and ai = ai - 1 - 1 otherwise. (The string is considered as 1-based index). It can be proven that a string is beautiful if the following conditions are satisfied: for each 0 ≤ i ≤ |s| ai ≥ 0. a|s| = 0 Using the above fact we can prove that if in a beautiful string we remove a ')' character and put it further toward the end of the string the resulting string is beautiful as well. These facts leads us to the following fact: if we can move a ')' character further toward the end of string it is better if we'd do it. This yields the following greedy solution:We'll first put exactly one ')' character at each '#' character. Then we'll build the sequence we described above. if the first condition isn't satisfied then there is no way that leads to a beautiful string. So the answer is -1. Otherwise we must put exactly a|s| more ')' characters in the place of last '#' character. Then if this string is beautiful we'll print it otherwise the answer is -1.494B - Obsessive StringWe call an index i(1 ≤ i ≤ |s|) good if t equals si - |t| + 1si - |t| + 2... si. To find all good indexes let's define qi as the length of longest prefix of t which is a suffix of s1s2... si. A good index is an index with qi = |t|. Calculating qi can be done using Knuth-Morris-Pratt algorithm. Let's define ai as the number of ways to choose some(at least one) non-overlapping substrings of the prefix of s with length i (s1s2... si) so t is a substring of each one of them and si is in one the chosen substrings(So it must actually be the last character of last chosen substring). Then the answer will be .Also let's define two additional sequence q1 and q2 which will help us in calculating a.The sequence a can then be calculated in O(n) as described below:If i is not a good index ai = ai - 1 since in each way counted in ai the substring containing si also contains si - 1 so for each of these ways removing si from the substring containing it leads to a way counted in ai - 1 and vice-versa thus these two numbers are equal. If i is a good index then ai = q2i - |t| + i - |t| + 1. To prove this let's consider a way of choosing substring counted in ai. We call such a way valid. The substring containing si can be any of the substrings sjsj + 1... si (1 ≤ j ≤ i - |t| + 1). There are i - |t| + 1 valid ways in which this substring is the only substring we've chosen. Number of valid ways in which substring containing si starts at sj equals to q1j - 1. So the total number of valid ways in which we've chosen at least two substrings are equal to which is equal to q2j - 1. So ai = q2i - |t| + i - |t| + 1.494C - Helping PeopleWe'll first create a rooted tree from the given segments which each node represents a segment. We'll solve the problem using dynamic programming on this tree. First of all let's add a segment [1, n] with probability of being chosen by Malek equal to 0. The node representing this segment will be the root of the tree. Please note by adding this segment the rules described in the statements are still in place.Let's sort the rest of segments according to their starting point increasing and in case of equality according to their finishing point decreasing. Then we'll put the segment we added in the beginning. A segment's father is the right-most segment which comes before that segment and contains it. Please note that since we added segment [1, n] to the beginning every segment except the added segment has a father. We build the tree by putting a segment's node child of its father's node. In this tree for each two nodes u and v which none of them are in the subtree on another the segments representing these two nodes will not overlap. Also for each two nodes u and v which u is in subtree of v segment representing node u will be inside(not necessarily strictly) segment representing node v. We define mxi as the maximum money a person in the segment i initially has. mxi can be calculated using RMQ. Let's define ai, j as the probability of that after Malek finishes giving his money the maximum in the segment i is at most {mx}i + j. The properties of the tree we built allows us to calculate ai, j for every i and j in O(q2) (since 1 ≤ i, j ≤ q). If number of the segment we added is k then the answer will be . Calculating ai, j is described below:Suppose f is a child of i and suppose Malek doesn't accept the i-th recommendation. Then since we want the maximum number after money spreading to be at most mxi + j in segment i and since f is inside i we want the maximum number after money spreading to be at most mxi - mxf + j. If Malek accepts the recommendation then we want it to be at most mxi - mxf + j - 1. So if probability of i-th recommendation being accepted by Malek be equal to pi then . Using this formula we can calculate ak, j recursively and calculate the answer from it in O(q2). The overall complexity will be O(nlgn + q2). nlgn for creating RMQ used for calculating the array mx and q2 for the rest of the algorithm.494D - BirthdayWe solve this problem by answering queries offline. We'll first store in each vertex v number of vertices such as x for which we must calculate f(v, x) . starting from the root. We'll keep two arrays a and b. Suppose we're at vertex v right now then ai equals d(i, v)2 and bi equal d(i, v). Having these two arrays when moving from vertex v to a child with an edge with weight k one can note that bi for all is inside subtree of v decreases by k and all other bis gets increased by k. Knowing this fact one can also update array a as well. To calculate f(v, x) it's enough to be able to calculate sum of ais for all i inside subtree of x. Handling each of these operations is a well known problem and is possible using a segment tree. Overall complexity is O((n + q)lgn). There is an online solution using dynamic programming as well.494E - ShartiLet's first solve this problem for another game: Suppose that we've an n × n table. Each cell have some(possibly zero) marbles on it. During each move the player chooses a square with side-length at most k which its lower-right cell has at least one marble, he removes one marble from it and puts one marble in every other cell of this square. One can notice that in such game each marble is independent of the others and doesn't affect other marbles. So one can see this game as some separate games played on some tables. More formally for each marble placed in a cell such as (i, j) consider the game when played on a i × j table which the only marble placed on it is at its lower-right cell. Let's denote the Grundy number of this game by gi, j. Then according to Grundy theorem the first player has a winning strategy if and only if the xor of gi, j for every cell (i, j) having odd number of marbles on it is positive. To calculate gi, j note that the first move in such game must be choosing a square with its lower-right cell being the lower-right cell of table. So the only thing to decide is the side-length of chosen square at the first move. Let's say we choose the first square width side length l. Grundy number of the next state will be equal to xor of gc, d for every i - l < c ≤ i, j - l < d ≤ j. Using this fact one can calculate gi, j for all (1 ≤ i, j ≤ a) (a being an arbitrary integers) in O(a3).If we calculated the first values of gi, j one can see a pattern in the Grundy numbers. Then one can prove that gi, j = min(lowest_bit(i), lowest_bit(j), greatest_bit(k)) where lowest_bit(x) =  the maximum power of 2 which is a divisor of x and greatest_bit(x) =  the maximum power of 2 which is not greater than x. Now let's prove that our first game(the game described in the statement) is actually the same as this game. Suppose that a player has a winning strategy in the first game. Consider a table containing one marble at every cell which is white in the table of the first game. We'll prove that the same player has winning strategy in this game as well. Note that a cell is white in the first game if and only if the parity of marbles in the second game is odd so there is at least one marble on it. So as long as the other player chooses a square with its lower-right cell having odd number of marbles in the second game, his move corresponds to a move in the first game so the player having winning strategy can counter his move. If the other player chooses a square with its lower-right cell having even number of marbles, it means the cell had at least 2 marbles on it so the player can counter it by choosing the same square which makes the parity of every cell to be the same after these 2 moves. And since it can be proven that both of the game will end at some point then the player has winning strategy in this game as well. The reverse of this fact can also be proven the same since if a player has a winning strategy there is also a winning strategy in which this player always chooses squares with lower-right cell having odd number of marbles(since otherwise the other player can counter it as described above) and counters the moves of the other player at which he chose a square with lower-right cell having even number of marbles by choosing the same square(since the Grundy number by countering in this way won't change the Grundy number and thus won't change the player with winning strategy).So if we consider a table having one marble at each of the cells which are in at least one of the rectangles given in the input we only need to calculate the Grundy number of this state and check whether it's positive or not to determine the winner. To do this for each i(1 ≤ i ≤ greatest_bit(k)) lets define ai as the number of cells (x, y) which are contained in at least one of the given rectangles, 2i|x and 2i|y. Lets also define agreatest_bit(k) + 1 = 0. Then according the fact we described above about gi, j the number of 2is which are xored equals ai - ai + 1. Knowing this calculating the Grundy number of the initial state is easy. Calculating ai is identical to a very well-known problem which is given some rectangles count the number of cells in at least one of them and can be solved in O(mlgm) (m being number of rectangles). So overall complexity will be O(mlgmlgk).If there is any problem in the editorial please feel free to note that to us.Thank you.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/15148",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.6,
            "reason": "宽松匹配: 包含题目编号 495 和字母"
          },
          "content_length": 11197
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #282 - Codeforces - Code 1",
          "code": "(#(\nAnswer: -1\nWA: 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15134",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #282 - Codeforces - Code 2",
          "code": "(#(\nAnswer: -1\nWA: 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15134",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #282 Editorial - Codeforces - Code 1",
          "code": "divisors of (a-b) greater than b",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15148",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #282 Editorial - Codeforces - Code 2",
          "code": "1 to sqrt(a-b)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15148",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #282 Editorial - Codeforces - Code 3",
          "code": "O(sqrt(a-b))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15148",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #282 Editorial - Codeforces - Code 4",
          "code": "input\n3 5\n1 2 3\n1 3 0.500\n2 2 0.250\n1 2 0.800\n1 1 0.120\n2 2 0.900\noutput\n4.465000000",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15148",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #282 Editorial - Codeforces - Code 5",
          "code": "input\n3 5\n1 2 3\n1 3 0.500\n2 2 0.250\n1 2 0.800\n1 1 0.120\n2 2 0.900\noutput\n4.465000000",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15148",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #282 Editorial - Codeforces - Code 6",
          "code": "using std::",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15148",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #282 Editorial - Codeforces - Code 7",
          "code": "using namespace std",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15148",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #282 Editorial - Codeforces - Code 8",
          "code": "#define next ____next\n#define prev ____prev\n#define y1   ____y1\n#define left ____left\n#define hash ____hash",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15148",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #282 Editorial - Codeforces - Code 9",
          "code": "#define next ____next\n#define prev ____prev\n#define y1   ____y1\n#define left ____left\n#define hash ____hash",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15148",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #282 Editorial - Codeforces - Code 10",
          "code": "#define max max<long long>",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15148",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #282 Editorial - Codeforces - Code 11",
          "code": "long long max(int a, long long b) { return max((long long)a, b); }\nlong long max(long long b, int a) { return max(a, (long long)b); }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15148",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #282 Editorial - Codeforces - Code 12",
          "code": "long long max(int a, long long b) { return max((long long)a, b); }\nlong long max(long long b, int a) { return max(a, (long long)b); }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15148",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #282 Editorial - Codeforces - Code 13",
          "code": "#define MAX(a,b) ((a)>(b)?(a):(b))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15148",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #282 Editorial - Codeforces - Code 14",
          "code": "#define MAX(a,b) ((a)>(b)?(a):(b))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15148",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #282 Editorial - Codeforces - Code 15",
          "code": "final string becomes beautiful",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15148",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #282 Editorial - Codeforces - Code 16",
          "code": "Node v = root",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15148",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #282 Editorial - Codeforces - Code 17",
          "code": "v = v.parent",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15148",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #282 Editorial - Codeforces - Code 18",
          "code": "input:\nddd\nd\noutput:\n12",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15148",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #282 Editorial - Codeforces - Code 19",
          "code": "input:\nddd\nd\noutput:\n12",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15148",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    string s = inf.readLine();\n    ensuref(1 <= s.length() && s.length() <= 100000, \"Length of s must be between 1 and 1e5, but is %d\", (int)s.length());\n    for (char c : s)\n        ensuref('a' <= c && c <= 'z', \"s must contain only lowercase letters\");\n\n    string t = inf.readLine();\n    ensuref(1 <= t.length() && t.length() <= 100000, \"Length of t must be between 1 and 1e5, but is %d\", (int)t.length());\n    for (char c : t)\n        ensuref('a' <= c && c <= 'z', \"t must contain only lowercase letters\");\n\n    inf.readEof();\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    string s = inf.readLine();\n    ensuref(1 <= s.length() && s.length() <= 100000, \"Length of s must be between 1 and 1e5, but is %d\", (int)s.length());\n    for (char c : s)\n        ensuref('a' <= c && c <= 'z', \"s must contain only lowercase letters\");\n\n    string t = inf.readLine();\n    ensuref(1 <= t.length() && t.length() <= 100000, \"Length of t must be between 1 and 1e5, but is %d\", (int)t.length());\n    for (char c : t)\n        ensuref('a' <= c && c <= 'z', \"t must contain only lowercase letters\");\n\n    inf.readEof();\n\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    string s = inf.readLine();\n    ensuref(1 <= s.length() && s.length() <= 100000, \"Length of s must be between 1 and 1e5, but is %d\", (int)s.length());\n    for (char c : s)\n        ensuref('a' <= c && c <= 'z', \"s must contain only lowercase letters\");\n\n    string t = inf.readLine();\n    ensuref(1 <= t.length() && t.length() <= 100000, \"Length of t must be between 1 and 1e5, but is %d\", (int)t.length());\n    for (char c : t)\n        ensuref('a' <= c && c <= 'z', \"t must contain only lowercase letters\");\n\n    inf.readEof();\n\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring randomString(int length) {\n    string s;\n    for (int i = 0; i < length; ++i) {\n        s += 'a' + rnd.next(26);\n    }\n    return s;\n}\n\nstring randomStringLetters(int length, const vector<char>& letters) {\n    string s;\n    for (int i = 0; i < length; ++i) {\n        s += letters[rnd.next(letters.size())];\n    }\n    return s;\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    // Read parameters\n    int slen = opt<int>(\"slen\");\n    int tlen = opt<int>(\"tlen\");\n    string type = opt<string>(\"type\");\n\n    assert(1 <= slen && slen <= 100000);\n    assert(1 <= tlen && tlen <= 100000);\n\n    string s, t;\n\n    if (type == \"random\") {\n        s = randomString(slen);\n        t = randomString(tlen);\n    } else if (type == \"no_t_in_s\") {\n        s = randomString(slen);\n\n        set<char> letters_in_s(s.begin(), s.end());\n        vector<char> letters_not_in_s;\n        for (char c = 'a'; c <= 'z'; ++c) {\n            if (letters_in_s.find(c) == letters_in_s.end()) {\n                letters_not_in_s.push_back(c);\n            }\n        }\n\n        if (letters_not_in_s.empty()) {\n            // All letters are in s, use 'a' for s, others for t\n            char c = 'a';\n            s = string(slen, c);\n\n            letters_not_in_s.clear();\n            for (char ch = 'b'; ch <= 'z'; ++ch) {\n                letters_not_in_s.push_back(ch);\n            }\n            if (letters_not_in_s.empty()) {\n                // Only 'a' exists\n                t = string(tlen, 'b');\n                cout << s << endl << t << endl;\n                return 0;\n            }\n        }\n        t = randomStringLetters(tlen, letters_not_in_s);\n    } else if (type == \"t_in_s_once\") {\n        t = randomString(tlen);\n\n        set<char> letters_in_t(t.begin(), t.end());\n        vector<char> letters_not_in_t;\n        for (char c = 'a'; c <= 'z'; ++c) {\n            if (letters_in_t.find(c) == letters_in_t.end()) {\n                letters_not_in_t.push_back(c);\n            }\n        }\n\n        if (letters_not_in_t.empty()) {\n            // All letters are in t\n            char c = 'a' + rnd.next(26);\n            t = string(tlen, c);\n\n            letters_not_in_t.clear();\n            for (char ch = 'a'; ch <= 'z'; ++ch) {\n                if (ch != c) letters_not_in_t.push_back(ch);\n            }\n        }\n\n        int slen_rest = slen - tlen;\n        if (slen_rest < 0) {\n            // Adjust tlen to slen\n            t = t.substr(0, slen);\n            tlen = slen;\n            slen_rest = 0;\n        }\n\n        string s_before = randomStringLetters(rnd.next(slen_rest + 1), letters_not_in_t);\n        string s_after = randomStringLetters(slen_rest - s_before.size(), letters_not_in_t);\n\n        s = s_before + t + s_after;\n    } else if (type == \"t_equals_s\") {\n        assert(slen == tlen);\n        s = randomString(slen);\n        t = s;\n    } else if (type == \"s_repeated_t\") {\n        t = randomString(tlen);\n        int repeat = slen / tlen;\n        s = \"\";\n        for (int i = 0; i < repeat; ++i) {\n            s += t;\n        }\n        int remaining = slen % tlen;\n        if (remaining > 0) {\n            s += t.substr(0, remaining);\n        }\n    } else if (type == \"s_all_same_char\") {\n        char c = 'a' + rnd.next(26);\n        s = string(slen, c);\n        t = string(tlen, c);\n    } else if (type == \"maximal_overlaps\") {\n        char c = 'a' + rnd.next(26);\n        t = string(tlen, c);\n        int repeats = (slen + tlen - 1) / tlen;\n        s = t;\n        for (int i = 1; i < repeats; ++i) {\n            s += t.substr(1);\n        }\n        s = s.substr(0, slen);\n    } else if (type == \"t_longer_than_s\") {\n        assert(tlen > slen);\n        s = randomString(slen);\n        t = randomString(tlen);\n    } else if (type == \"t_unique_chars\") {\n        s = randomString(slen);\n\n        set<char> letters_in_s(s.begin(), s.end());\n        vector<char> letters_not_in_s;\n        for (char c = 'a'; c <= 'z'; ++c) {\n            if (letters_in_s.find(c) == letters_in_s.end()) {\n                letters_not_in_s.push_back(c);\n            }\n        }\n\n        if (letters_not_in_s.empty()) {\n            // All letters are in s\n            char c = 'a' + rnd.next(26);\n            // Remove c from s\n            for (size_t i = 0; i < s.length(); ++i) {\n                if (s[i] == c) {\n                    s[i] = 'a' + rnd.next(26);\n                }\n            }\n            letters_not_in_s.push_back(c);\n        }\n\n        t = randomStringLetters(tlen, letters_not_in_s);\n    } else {\n        // Default: random\n        s = randomString(slen);\n        t = randomString(tlen);\n    }\n\n    // Output s and t\n    cout << s << endl;\n    cout << t << endl;\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring randomString(int length) {\n    string s;\n    for (int i = 0; i < length; ++i) {\n        s += 'a' + rnd.next(26);\n    }\n    return s;\n}\n\nstring randomStringLetters(int length, const vector<char>& letters) {\n    string s;\n    for (int i = 0; i < length; ++i) {\n        s += letters[rnd.next(letters.size())];\n    }\n    return s;\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    // Read parameters\n    int slen = opt<int>(\"slen\");\n    int tlen = opt<int>(\"tlen\");\n    string type = opt<string>(\"type\");\n\n    assert(1 <= slen && slen <= 100000);\n    assert(1 <= tlen && tlen <= 100000);\n\n    string s, t;\n\n    if (type == \"random\") {\n        s = randomString(slen);\n        t = randomString(tlen);\n    } else if (type == \"no_t_in_s\") {\n        s = randomString(slen);\n\n        set<char> letters_in_s(s.begin(), s.end());\n        vector<char> letters_not_in_s;\n        for (char c = 'a'; c <= 'z'; ++c) {\n            if (letters_in_s.find(c) == letters_in_s.end()) {\n                letters_not_in_s.push_back(c);\n            }\n        }\n\n        if (letters_not_in_s.empty()) {\n            // All letters are in s, use 'a' for s, others for t\n            char c = 'a';\n            s = string(slen, c);\n\n            letters_not_in_s.clear();\n            for (char ch = 'b'; ch <= 'z'; ++ch) {\n                letters_not_in_s.push_back(ch);\n            }\n            if (letters_not_in_s.empty()) {\n                // Only 'a' exists\n                t = string(tlen, 'b');\n                cout << s << endl << t << endl;\n                return 0;\n            }\n        }\n        t = randomStringLetters(tlen, letters_not_in_s);\n    } else if (type == \"t_in_s_once\") {\n        t = randomString(tlen);\n\n        set<char> letters_in_t(t.begin(), t.end());\n        vector<char> letters_not_in_t;\n        for (char c = 'a'; c <= 'z'; ++c) {\n            if (letters_in_t.find(c) == letters_in_t.end()) {\n                letters_not_in_t.push_back(c);\n            }\n        }\n\n        if (letters_not_in_t.empty()) {\n            // All letters are in t\n            char c = 'a' + rnd.next(26);\n            t = string(tlen, c);\n\n            letters_not_in_t.clear();\n            for (char ch = 'a'; ch <= 'z'; ++ch) {\n                if (ch != c) letters_not_in_t.push_back(ch);\n            }\n        }\n\n        int slen_rest = slen - tlen;\n        if (slen_rest < 0) {\n            // Adjust tlen to slen\n            t = t.substr(0, slen);\n            tlen = slen;\n            slen_rest = 0;\n        }\n\n        string s_before = randomStringLetters(rnd.next(slen_rest + 1), letters_not_in_t);\n        string s_after = randomStringLetters(slen_rest - s_before.size(), letters_not_in_t);\n\n        s = s_before + t + s_after;\n    } else if (type == \"t_equals_s\") {\n        assert(slen == tlen);\n        s = randomString(slen);\n        t = s;\n    } else if (type == \"s_repeated_t\") {\n        t = randomString(tlen);\n        int repeat = slen / tlen;\n        s = \"\";\n        for (int i = 0; i < repeat; ++i) {\n            s += t;\n        }\n        int remaining = slen % tlen;\n        if (remaining > 0) {\n            s += t.substr(0, remaining);\n        }\n    } else if (type == \"s_all_same_char\") {\n        char c = 'a' + rnd.next(26);\n        s = string(slen, c);\n        t = string(tlen, c);\n    } else if (type == \"maximal_overlaps\") {\n        char c = 'a' + rnd.next(26);\n        t = string(tlen, c);\n        int repeats = (slen + tlen - 1) / tlen;\n        s = t;\n        for (int i = 1; i < repeats; ++i) {\n            s += t.substr(1);\n        }\n        s = s.substr(0, slen);\n    } else if (type == \"t_longer_than_s\") {\n        assert(tlen > slen);\n        s = randomString(slen);\n        t = randomString(tlen);\n    } else if (type == \"t_unique_chars\") {\n        s = randomString(slen);\n\n        set<char> letters_in_s(s.begin(), s.end());\n        vector<char> letters_not_in_s;\n        for (char c = 'a'; c <= 'z'; ++c) {\n            if (letters_in_s.find(c) == letters_in_s.end()) {\n                letters_not_in_s.push_back(c);\n            }\n        }\n\n        if (letters_not_in_s.empty()) {\n            // All letters are in s\n            char c = 'a' + rnd.next(26);\n            // Remove c from s\n            for (size_t i = 0; i < s.length(); ++i) {\n                if (s[i] == c) {\n                    s[i] = 'a' + rnd.next(26);\n                }\n            }\n            letters_not_in_s.push_back(c);\n        }\n\n        t = randomStringLetters(tlen, letters_not_in_s);\n    } else {\n        // Default: random\n        s = randomString(slen);\n        t = randomString(tlen);\n    }\n\n    // Output s and t\n    cout << s << endl;\n    cout << t << endl;\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -slen 1 -tlen 1 -type random\n./gen -slen 1 -tlen 2 -type t_longer_than_s\n./gen -slen 5 -tlen 5 -type t_equals_s\n./gen -slen 5 -tlen 2 -type t_in_s_once\n./gen -slen 5 -tlen 5 -type t_in_s_once\n./gen -slen 10 -tlen 3 -type no_t_in_s\n./gen -slen 100 -tlen 50 -type t_unique_chars\n./gen -slen 20 -tlen 5 -type s_repeated_t\n./gen -slen 10 -tlen 5 -type s_all_same_char\n./gen -slen 10 -tlen 5 -type maximal_overlaps\n./gen -slen 1000 -tlen 1000 -type random\n./gen -slen 1000 -tlen 500 -type t_in_s_once\n./gen -slen 1000 -tlen 1000 -type t_equals_s\n./gen -slen 5000 -tlen 2500 -type t_unique_chars\n./gen -slen 10000 -tlen 5000 -type s_repeated_t\n./gen -slen 10000 -tlen 1 -type s_all_same_char\n./gen -slen 10000 -tlen 2 -type maximal_overlaps\n./gen -slen 99999 -tlen 100000 -type t_longer_than_s\n./gen -slen 100000 -tlen 100000 -type random\n./gen -slen 100000 -tlen 1 -type s_all_same_char\n./gen -slen 100000 -tlen 1 -type maximal_overlaps\n./gen -slen 100000 -tlen 99999 -type no_t_in_s\n./gen -slen 100000 -tlen 50000 -type t_in_s_once\n./gen -slen 100000 -tlen 50000 -type s_repeated_t\n./gen -slen 100000 -tlen 50000 -type t_unique_chars\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:38:56.726310",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "495/E",
      "title": "E. Помощь нуждающимся",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест2 секунды",
      "memory_limit": "ограничение по памяти на тест512 мегабайт",
      "input_spec": "Входные данныеВ первой строке даны два целых числа через пробел — n, q (1 ≤ n ≤ 105, 1 ≤ q ≤ 5000).Во второй строке содержатся n разделённых пробелами целых чисел a1, a2, ..., an (0 ≤ ai ≤ 109), обозначающие, что у человека i изначально есть ai долларов. В каждой из следующих q строк записано по три целых числа через пробел li, ri, pi (1 ≤ li ≤ ri ≤ n, 0 ≤ p ≤ 1), где li и ri — два числа, описывающих отрезок рекомендации, а pi — вещественное число, данное ровно с тремя знаками после десятичной точки, равное вероятности того, что Малек примет данную рекомендацию.Обратите внимание, что один и тот же отрезок может появляться в рекомендациях несколько раз.",
      "output_spec": "Выходные данныеВыведите математическое ожидание. Ответ будет засчитан, если его абсолютная или относительная погрешность будет составлять не более 10 - 6.",
      "sample_tests": "ПримерыВходные данныеСкопировать5 21 7 2 4 31 3 0.5002 2 0.500Выходные данныеСкопировать8.000000000Входные данныеСкопировать5 2281 280 279 278 2821 4 1.0001 4 0.000Выходные данныеСкопировать282.000000000Входные данныеСкопировать3 51 2 31 3 0.5002 2 0.2501 2 0.8001 1 0.1202 2 0.900Выходные данныеСкопировать4.465000000",
      "description": "E. Помощь нуждающимся\n\nограничение по времени на тест2 секунды\n\nограничение по времени на тест\n\nограничение по памяти на тест512 мегабайт\n\nограничение по памяти на тест\n\nвыводstdout\n\nВходные данныеВ первой строке даны два целых числа через пробел — n, q (1 ≤ n ≤ 105, 1 ≤ q ≤ 5000).Во второй строке содержатся n разделённых пробелами целых чисел a1, a2, ..., an (0 ≤ ai ≤ 109), обозначающие, что у человека i изначально есть ai долларов. В каждой из следующих q строк записано по три целых числа через пробел li, ri, pi (1 ≤ li ≤ ri ≤ n, 0 ≤ p ≤ 1), где li и ri — два числа, описывающих отрезок рекомендации, а pi — вещественное число, данное ровно с тремя знаками после десятичной точки, равное вероятности того, что Малек примет данную рекомендацию.Обратите внимание, что один и тот же отрезок может появляться в рекомендациях несколько раз.\n\nВходные данные\n\nВыходные данныеВыведите математическое ожидание. Ответ будет засчитан, если его абсолютная или относительная погрешность будет составлять не более 10 - 6.\n\nВыходные данные\n\nВходные данныеСкопировать5 21 7 2 4 31 3 0.5002 2 0.500Выходные данныеСкопировать8.000000000Входные данныеСкопировать5 2281 280 279 278 2821 4 1.0001 4 0.000Выходные данныеСкопировать282.000000000Входные данныеСкопировать3 51 2 31 3 0.5002 2 0.2501 2 0.8001 1 0.1202 2 0.900Выходные данныеСкопировать4.465000000\n\nВходные данныеСкопировать5 21 7 2 4 31 3 0.5002 2 0.500\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать8.000000000\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать5 2281 280 279 278 2821 4 1.0001 4 0.000\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать282.000000000\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать3 51 2 31 3 0.5002 2 0.2501 2 0.8001 1 0.1202 2 0.900\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать4.465000000\n\nВыходные данныеСкопировать\n\nСкопировать",
      "solutions": [
        {
          "title": "Codeforces Round #282 - Codeforces",
          "content": "Hi, Codeforces Round #282 will be held at 13th of December, 19:30 MSK. Please don't note anything since the time is the usual time of contests.The round is prepared by FarbodY, Haghani and Me(matrix). We'd like to thank Zlobober who helped us a LOT for preparing the problems, MikeMirzayanov for the Polygon and Codeforces platforms and Delinur for helping us in preparing statements and translating them.Our special thanks goes to mruxim for testing the round.The problems will be sorted according to the estimated order of difficulty according to our opinion but we strongly recommend you to read all of the problems.As always the update regarding score distribution will be posted just before the round starts. :)UPD: It was written that contest starts at 20:00 MSK. it was a mistake and is fixed now. The round starts at usual time 19:30 MSK.UPD2: We also thank niyaznigmatul for testing our round.UPD3: Score distribution:Div1: 500-1000-1750-1750-2500Div2: 500-1000-1500-2000-2750As you might have noticed, the scores can now be multiples of 250 as well. Let's thank Codeforces team for adding this feature!Good luck and Have fun!UPD4: Congratulations to the winners of both divisions:Div1: tourist winger sankear uwi Egor Div2: Ginger88895 pwild arthurpd konmaj ezkatka The editorial for all problems except D and E Div1 are ready and can be found here. It'll be completed soon.We thank you all for participating and hope you had a good time.UPD5: The editorial is now complete and can be found here.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/15134",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1506
        },
        {
          "title": "Codeforces Round #282 Editorial - Codeforces",
          "content": "495A - Digital CounterFor each digit x you can count the number of digits y that because of some broken sticks x is shown instead of y by hand. for example when x = 3, y can be 3, 8 and 9. Let's denote this number by ax. Then if the input is xy (the first digit shown in the counter is x and the second is y) the answer will be ax × ay.495B - Modular Equations If a < b then there is no answer since . If a = b then x can be any integer larger than a. so there are infinite number of answers to the equation. The only remaining case is when a > b. Suppose x is an answer to our equation. Then x|a - b. Also since then b < x. These conditions are necessary and sufficient as well. So the answer is number of divisors of a - b which are strictly greater than b which can be solved in . 494A - TreasureConsider a string consisting of '(' and ')' characters. Let's build the following sequence from this string: a0 = 0 for each 1 ≤ i ≤ |s| ai = ai - 1 + 1 if si = '(' and ai = ai - 1 - 1 otherwise. (The string is considered as 1-based index). It can be proven that a string is beautiful if the following conditions are satisfied: for each 0 ≤ i ≤ |s| ai ≥ 0. a|s| = 0 Using the above fact we can prove that if in a beautiful string we remove a ')' character and put it further toward the end of the string the resulting string is beautiful as well. These facts leads us to the following fact: if we can move a ')' character further toward the end of string it is better if we'd do it. This yields the following greedy solution:We'll first put exactly one ')' character at each '#' character. Then we'll build the sequence we described above. if the first condition isn't satisfied then there is no way that leads to a beautiful string. So the answer is -1. Otherwise we must put exactly a|s| more ')' characters in the place of last '#' character. Then if this string is beautiful we'll print it otherwise the answer is -1.494B - Obsessive StringWe call an index i(1 ≤ i ≤ |s|) good if t equals si - |t| + 1si - |t| + 2... si. To find all good indexes let's define qi as the length of longest prefix of t which is a suffix of s1s2... si. A good index is an index with qi = |t|. Calculating qi can be done using Knuth-Morris-Pratt algorithm. Let's define ai as the number of ways to choose some(at least one) non-overlapping substrings of the prefix of s with length i (s1s2... si) so t is a substring of each one of them and si is in one the chosen substrings(So it must actually be the last character of last chosen substring). Then the answer will be .Also let's define two additional sequence q1 and q2 which will help us in calculating a.The sequence a can then be calculated in O(n) as described below:If i is not a good index ai = ai - 1 since in each way counted in ai the substring containing si also contains si - 1 so for each of these ways removing si from the substring containing it leads to a way counted in ai - 1 and vice-versa thus these two numbers are equal. If i is a good index then ai = q2i - |t| + i - |t| + 1. To prove this let's consider a way of choosing substring counted in ai. We call such a way valid. The substring containing si can be any of the substrings sjsj + 1... si (1 ≤ j ≤ i - |t| + 1). There are i - |t| + 1 valid ways in which this substring is the only substring we've chosen. Number of valid ways in which substring containing si starts at sj equals to q1j - 1. So the total number of valid ways in which we've chosen at least two substrings are equal to which is equal to q2j - 1. So ai = q2i - |t| + i - |t| + 1.494C - Helping PeopleWe'll first create a rooted tree from the given segments which each node represents a segment. We'll solve the problem using dynamic programming on this tree. First of all let's add a segment [1, n] with probability of being chosen by Malek equal to 0. The node representing this segment will be the root of the tree. Please note by adding this segment the rules described in the statements are still in place.Let's sort the rest of segments according to their starting point increasing and in case of equality according to their finishing point decreasing. Then we'll put the segment we added in the beginning. A segment's father is the right-most segment which comes before that segment and contains it. Please note that since we added segment [1, n] to the beginning every segment except the added segment has a father. We build the tree by putting a segment's node child of its father's node. In this tree for each two nodes u and v which none of them are in the subtree on another the segments representing these two nodes will not overlap. Also for each two nodes u and v which u is in subtree of v segment representing node u will be inside(not necessarily strictly) segment representing node v. We define mxi as the maximum money a person in the segment i initially has. mxi can be calculated using RMQ. Let's define ai, j as the probability of that after Malek finishes giving his money the maximum in the segment i is at most {mx}i + j. The properties of the tree we built allows us to calculate ai, j for every i and j in O(q2) (since 1 ≤ i, j ≤ q). If number of the segment we added is k then the answer will be . Calculating ai, j is described below:Suppose f is a child of i and suppose Malek doesn't accept the i-th recommendation. Then since we want the maximum number after money spreading to be at most mxi + j in segment i and since f is inside i we want the maximum number after money spreading to be at most mxi - mxf + j. If Malek accepts the recommendation then we want it to be at most mxi - mxf + j - 1. So if probability of i-th recommendation being accepted by Malek be equal to pi then . Using this formula we can calculate ak, j recursively and calculate the answer from it in O(q2). The overall complexity will be O(nlgn + q2). nlgn for creating RMQ used for calculating the array mx and q2 for the rest of the algorithm.494D - BirthdayWe solve this problem by answering queries offline. We'll first store in each vertex v number of vertices such as x for which we must calculate f(v, x) . starting from the root. We'll keep two arrays a and b. Suppose we're at vertex v right now then ai equals d(i, v)2 and bi equal d(i, v). Having these two arrays when moving from vertex v to a child with an edge with weight k one can note that bi for all is inside subtree of v decreases by k and all other bis gets increased by k. Knowing this fact one can also update array a as well. To calculate f(v, x) it's enough to be able to calculate sum of ais for all i inside subtree of x. Handling each of these operations is a well known problem and is possible using a segment tree. Overall complexity is O((n + q)lgn). There is an online solution using dynamic programming as well.494E - ShartiLet's first solve this problem for another game: Suppose that we've an n × n table. Each cell have some(possibly zero) marbles on it. During each move the player chooses a square with side-length at most k which its lower-right cell has at least one marble, he removes one marble from it and puts one marble in every other cell of this square. One can notice that in such game each marble is independent of the others and doesn't affect other marbles. So one can see this game as some separate games played on some tables. More formally for each marble placed in a cell such as (i, j) consider the game when played on a i × j table which the only marble placed on it is at its lower-right cell. Let's denote the Grundy number of this game by gi, j. Then according to Grundy theorem the first player has a winning strategy if and only if the xor of gi, j for every cell (i, j) having odd number of marbles on it is positive. To calculate gi, j note that the first move in such game must be choosing a square with its lower-right cell being the lower-right cell of table. So the only thing to decide is the side-length of chosen square at the first move. Let's say we choose the first square width side length l. Grundy number of the next state will be equal to xor of gc, d for every i - l < c ≤ i, j - l < d ≤ j. Using this fact one can calculate gi, j for all (1 ≤ i, j ≤ a) (a being an arbitrary integers) in O(a3).If we calculated the first values of gi, j one can see a pattern in the Grundy numbers. Then one can prove that gi, j = min(lowest_bit(i), lowest_bit(j), greatest_bit(k)) where lowest_bit(x) =  the maximum power of 2 which is a divisor of x and greatest_bit(x) =  the maximum power of 2 which is not greater than x. Now let's prove that our first game(the game described in the statement) is actually the same as this game. Suppose that a player has a winning strategy in the first game. Consider a table containing one marble at every cell which is white in the table of the first game. We'll prove that the same player has winning strategy in this game as well. Note that a cell is white in the first game if and only if the parity of marbles in the second game is odd so there is at least one marble on it. So as long as the other player chooses a square with its lower-right cell having odd number of marbles in the second game, his move corresponds to a move in the first game so the player having winning strategy can counter his move. If the other player chooses a square with its lower-right cell having even number of marbles, it means the cell had at least 2 marbles on it so the player can counter it by choosing the same square which makes the parity of every cell to be the same after these 2 moves. And since it can be proven that both of the game will end at some point then the player has winning strategy in this game as well. The reverse of this fact can also be proven the same since if a player has a winning strategy there is also a winning strategy in which this player always chooses squares with lower-right cell having odd number of marbles(since otherwise the other player can counter it as described above) and counters the moves of the other player at which he chose a square with lower-right cell having even number of marbles by choosing the same square(since the Grundy number by countering in this way won't change the Grundy number and thus won't change the player with winning strategy).So if we consider a table having one marble at each of the cells which are in at least one of the rectangles given in the input we only need to calculate the Grundy number of this state and check whether it's positive or not to determine the winner. To do this for each i(1 ≤ i ≤ greatest_bit(k)) lets define ai as the number of cells (x, y) which are contained in at least one of the given rectangles, 2i|x and 2i|y. Lets also define agreatest_bit(k) + 1 = 0. Then according the fact we described above about gi, j the number of 2is which are xored equals ai - ai + 1. Knowing this calculating the Grundy number of the initial state is easy. Calculating ai is identical to a very well-known problem which is given some rectangles count the number of cells in at least one of them and can be solved in O(mlgm) (m being number of rectangles). So overall complexity will be O(mlgmlgk).If there is any problem in the editorial please feel free to note that to us.Thank you.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/15148",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.6,
            "reason": "宽松匹配: 包含题目编号 495 和字母"
          },
          "content_length": 11197
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #282 - Codeforces - Code 1",
          "code": "(#(\nAnswer: -1\nWA: 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15134",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #282 - Codeforces - Code 2",
          "code": "(#(\nAnswer: -1\nWA: 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15134",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #282 Editorial - Codeforces - Code 1",
          "code": "divisors of (a-b) greater than b",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15148",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #282 Editorial - Codeforces - Code 2",
          "code": "1 to sqrt(a-b)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15148",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #282 Editorial - Codeforces - Code 3",
          "code": "O(sqrt(a-b))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15148",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #282 Editorial - Codeforces - Code 4",
          "code": "input\n3 5\n1 2 3\n1 3 0.500\n2 2 0.250\n1 2 0.800\n1 1 0.120\n2 2 0.900\noutput\n4.465000000",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15148",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #282 Editorial - Codeforces - Code 5",
          "code": "input\n3 5\n1 2 3\n1 3 0.500\n2 2 0.250\n1 2 0.800\n1 1 0.120\n2 2 0.900\noutput\n4.465000000",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15148",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #282 Editorial - Codeforces - Code 6",
          "code": "using std::",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15148",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #282 Editorial - Codeforces - Code 7",
          "code": "using namespace std",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15148",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #282 Editorial - Codeforces - Code 8",
          "code": "#define next ____next\n#define prev ____prev\n#define y1   ____y1\n#define left ____left\n#define hash ____hash",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15148",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #282 Editorial - Codeforces - Code 9",
          "code": "#define next ____next\n#define prev ____prev\n#define y1   ____y1\n#define left ____left\n#define hash ____hash",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15148",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #282 Editorial - Codeforces - Code 10",
          "code": "#define max max<long long>",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15148",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #282 Editorial - Codeforces - Code 11",
          "code": "long long max(int a, long long b) { return max((long long)a, b); }\nlong long max(long long b, int a) { return max(a, (long long)b); }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15148",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #282 Editorial - Codeforces - Code 12",
          "code": "long long max(int a, long long b) { return max((long long)a, b); }\nlong long max(long long b, int a) { return max(a, (long long)b); }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15148",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #282 Editorial - Codeforces - Code 13",
          "code": "#define MAX(a,b) ((a)>(b)?(a):(b))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15148",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #282 Editorial - Codeforces - Code 14",
          "code": "#define MAX(a,b) ((a)>(b)?(a):(b))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15148",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #282 Editorial - Codeforces - Code 15",
          "code": "final string becomes beautiful",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15148",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #282 Editorial - Codeforces - Code 16",
          "code": "Node v = root",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15148",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #282 Editorial - Codeforces - Code 17",
          "code": "v = v.parent",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15148",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #282 Editorial - Codeforces - Code 18",
          "code": "input:\nddd\nd\noutput:\n12",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15148",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #282 Editorial - Codeforces - Code 19",
          "code": "input:\nddd\nd\noutput:\n12",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15148",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int q = inf.readInt(1, 5000, \"q\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, 0, 1000000000, \"ai\");\n    inf.readEoln();\n\n    vector<tuple<int, int, double>> recs(q);\n    for (int i = 0; i < q; ++i) {\n        int l = inf.readInt(1, n, \"li\");\n        inf.readSpace();\n        int r = inf.readInt(l, n, \"ri\");\n        inf.readSpace();\n\n        string s = inf.readToken(\"(0\\\\.[0-9]{3}|1\\\\.000)\", \"pi\");\n        double p = atof(s.c_str());\n        ensuref(0.0 <= p && p <= 1.0, \"pi must be between 0 and 1 inclusive\");\n\n        inf.readEoln();\n\n        recs[i] = make_tuple(l, r, p);\n    }\n\n    for (int i = 0; i < q; ++i) {\n        int a_start = get<0>(recs[i]);\n        int a_end = get<1>(recs[i]);\n        for (int j = i+1; j < q; ++j) {\n            int b_start = get<0>(recs[j]);\n            int b_end = get<1>(recs[j]);\n\n            bool disjoint = (a_end < b_start) || (b_end < a_start);\n            bool one_inside_other = (a_start <= b_start && b_end <= a_end) || (b_start <= a_start && a_end <= b_end);\n\n            ensuref(disjoint || one_inside_other, \"Recommendations %d and %d do not satisfy the rule\", i+1, j+1);\n        }\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int q = inf.readInt(1, 5000, \"q\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, 0, 1000000000, \"ai\");\n    inf.readEoln();\n\n    vector<tuple<int, int, double>> recs(q);\n    for (int i = 0; i < q; ++i) {\n        int l = inf.readInt(1, n, \"li\");\n        inf.readSpace();\n        int r = inf.readInt(l, n, \"ri\");\n        inf.readSpace();\n\n        string s = inf.readToken(\"(0\\\\.[0-9]{3}|1\\\\.000)\", \"pi\");\n        double p = atof(s.c_str());\n        ensuref(0.0 <= p && p <= 1.0, \"pi must be between 0 and 1 inclusive\");\n\n        inf.readEoln();\n\n        recs[i] = make_tuple(l, r, p);\n    }\n\n    for (int i = 0; i < q; ++i) {\n        int a_start = get<0>(recs[i]);\n        int a_end = get<1>(recs[i]);\n        for (int j = i+1; j < q; ++j) {\n            int b_start = get<0>(recs[j]);\n            int b_end = get<1>(recs[j]);\n\n            bool disjoint = (a_end < b_start) || (b_end < a_start);\n            bool one_inside_other = (a_start <= b_start && b_end <= a_end) || (b_start <= a_start && a_end <= b_end);\n\n            ensuref(disjoint || one_inside_other, \"Recommendations %d and %d do not satisfy the rule\", i+1, j+1);\n        }\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int q = inf.readInt(1, 5000, \"q\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, 0, 1000000000, \"ai\");\n    inf.readEoln();\n\n    vector<tuple<int, int, double>> recs(q);\n    for (int i = 0; i < q; ++i) {\n        int l = inf.readInt(1, n, \"li\");\n        inf.readSpace();\n        int r = inf.readInt(l, n, \"ri\");\n        inf.readSpace();\n\n        string s = inf.readToken(\"(0\\\\.[0-9]{3}|1\\\\.000)\", \"pi\");\n        double p = atof(s.c_str());\n        ensuref(0.0 <= p && p <= 1.0, \"pi must be between 0 and 1 inclusive\");\n\n        inf.readEoln();\n\n        recs[i] = make_tuple(l, r, p);\n    }\n\n    for (int i = 0; i < q; ++i) {\n        int a_start = get<0>(recs[i]);\n        int a_end = get<1>(recs[i]);\n        for (int j = i+1; j < q; ++j) {\n            int b_start = get<0>(recs[j]);\n            int b_end = get<1>(recs[j]);\n\n            bool disjoint = (a_end < b_start) || (b_end < a_start);\n            bool one_inside_other = (a_start <= b_start && b_end <= a_end) || (b_start <= a_start && a_end <= b_end);\n\n            ensuref(disjoint || one_inside_other, \"Recommendations %d and %d do not satisfy the rule\", i+1, j+1);\n        }\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nconst double EPS = 1E-6;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare two sequences of doubles, max absolute or relative  error = %.7f\", EPS);\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    double j = 0, p = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        n++;\r\n        j = ans.readDouble();\r\n        p = ouf.readDouble();\r\n        if (!doubleCompare(j, p, EPS)) {\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%.7f', found: '%.7f', error = '%.7f'\",\r\n                  n, englishEnding(n).c_str(), j, p, doubleDelta(j, p));\r\n        }\r\n    }\r\n\r\n    if (n == 1)\r\n        quitf(_ok, \"found '%.7f', expected '%.7f', error '%.7f'\", p, j, doubleDelta(j, p));\r\n\r\n    quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int q = opt<int>(\"q\");\n    string type = opt<string>(\"type\", \"random\");\n    string initial = opt<string>(\"initial\", \"random\");\n    string prob = opt<string>(\"prob\", \"random\");\n    int k = opt<int>(\"k\", 0); // For 'constk' initial type\n\n    // Adjust q if necessary\n    if (q > 5000) q = 5000;\n    if (q < 1) q = 1;\n    if (n < 1) n = 1;\n    if (n > 100000) n = 100000;\n\n    // Generate initial amounts\n    vector<int> a(n);\n    if (initial == \"zero\") {\n        for (int i = 0; i < n; ++i) a[i] = 0;\n    } else if (initial == \"max\") {\n        for (int i = 0; i < n; ++i) a[i] = 1000000000;\n    } else if (initial == \"constk\") {\n        for (int i = 0; i < n; ++i) a[i] = k;\n    } else { // \"random\" or default\n        for (int i = 0; i < n; ++i) a[i] = rnd.next(0, 1000000000);\n    }\n\n    // Generate probabilities\n    vector<double> p(q);\n    if (prob == \"zero\") {\n        for (int i = 0; i < q; ++i) p[i] = 0.0;\n    } else if (prob == \"one\") {\n        for (int i = 0; i < q; ++i) p[i] = 1.0;\n    } else if (prob == \"extremes\") {\n        for (int i = 0; i < q; ++i) {\n            int r = rnd.next(0, 1);\n            p[i] = r ? 1.0 : 0.0;\n        }\n    } else { // \"random\" or default\n        for (int i = 0; i < q; ++i) {\n            p[i] = rnd.next(0, 1000) / 1000.0;\n        }\n    }\n\n    // Generate recommendations\n    vector<pair<int, int>> segments;\n    if (type == \"same\") {\n        for (int i = 0; i < q; ++i) {\n            segments.push_back(make_pair(1, n));\n        }\n    } else if (type == \"disjoint\") {\n        if (q > n) q = n; // Can't have more disjoint segments than n\n        int l = 1;\n        int segment_size = n / q;\n        int remainder = n % q;\n        for (int i = 0; i < q; ++i) {\n            int len = segment_size;\n            if (remainder > 0) {\n                len += 1;\n                remainder -= 1;\n            }\n            int r = l + len - 1;\n            segments.push_back(make_pair(l, r));\n            l = r + 1;\n        }\n    } else if (type == \"nested\") {\n        int l = 1;\n        int r = n;\n        for (int i = 0; i < q; ++i) {\n            if (l > r) break;\n            segments.push_back(make_pair(l, r));\n            if (l < r) {\n                int delta_l = rnd.next(1, min(10, r - l));\n                int delta_r = rnd.next(1, min(10, r - l));\n                l = l + delta_l;\n                r = r - delta_r;\n            } else {\n                break;\n            }\n        }\n        // If we generated fewer than q segments, fill the rest with the last segment\n        while ((int)segments.size() < q) {\n            segments.push_back(make_pair(l, r));\n        }\n    } else { // \"random\" or default\n        // First, create some disjoint segments\n        int m = rnd.next(1, min(q, n / 10 + 1)); // Number of disjoint segments\n        int l = 1;\n        int total_length = n;\n        int remaining_segments = m;\n        vector<pair<int, int>> disjoint_segments;\n        for (int i = 0; i < m; ++i) {\n            if (l > n) break;\n            int max_len = (total_length - (remaining_segments - 1)) / remaining_segments;\n            int len = rnd.next(1, max_len);\n            int r = l + len - 1;\n            if (r > n) r = n;\n            disjoint_segments.push_back(make_pair(l, r));\n            l = r + 1;\n            total_length -= len;\n            remaining_segments--;\n        }\n        // Now, for each disjoint segment, create nested segments\n        for (auto &seg : disjoint_segments) {\n            segments.push_back(seg);\n        }\n        int idx = 0;\n        while ((int)segments.size() < q) {\n            if (idx >= (int)disjoint_segments.size()) idx = 0;\n            auto &parent = disjoint_segments[idx];\n            int l_p = parent.first;\n            int r_p = parent.second;\n            int l_new = rnd.next(l_p, r_p);\n            int r_new = rnd.next(l_new, r_p);\n            segments.push_back(make_pair(l_new, r_new));\n            idx++;\n        }\n    }\n\n    // Output\n    printf(\"%d %d\\n\", n, q);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d%c\", a[i], i + 1 == n ? '\\n' : ' ');\n    }\n    for (int i = 0; i < q; ++i) {\n        int l = segments[i].first;\n        int r = segments[i].second;\n        double pi = p[i];\n        printf(\"%d %d %.3f\\n\", l, r, pi);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int q = opt<int>(\"q\");\n    string type = opt<string>(\"type\", \"random\");\n    string initial = opt<string>(\"initial\", \"random\");\n    string prob = opt<string>(\"prob\", \"random\");\n    int k = opt<int>(\"k\", 0); // For 'constk' initial type\n\n    // Adjust q if necessary\n    if (q > 5000) q = 5000;\n    if (q < 1) q = 1;\n    if (n < 1) n = 1;\n    if (n > 100000) n = 100000;\n\n    // Generate initial amounts\n    vector<int> a(n);\n    if (initial == \"zero\") {\n        for (int i = 0; i < n; ++i) a[i] = 0;\n    } else if (initial == \"max\") {\n        for (int i = 0; i < n; ++i) a[i] = 1000000000;\n    } else if (initial == \"constk\") {\n        for (int i = 0; i < n; ++i) a[i] = k;\n    } else { // \"random\" or default\n        for (int i = 0; i < n; ++i) a[i] = rnd.next(0, 1000000000);\n    }\n\n    // Generate probabilities\n    vector<double> p(q);\n    if (prob == \"zero\") {\n        for (int i = 0; i < q; ++i) p[i] = 0.0;\n    } else if (prob == \"one\") {\n        for (int i = 0; i < q; ++i) p[i] = 1.0;\n    } else if (prob == \"extremes\") {\n        for (int i = 0; i < q; ++i) {\n            int r = rnd.next(0, 1);\n            p[i] = r ? 1.0 : 0.0;\n        }\n    } else { // \"random\" or default\n        for (int i = 0; i < q; ++i) {\n            p[i] = rnd.next(0, 1000) / 1000.0;\n        }\n    }\n\n    // Generate recommendations\n    vector<pair<int, int>> segments;\n    if (type == \"same\") {\n        for (int i = 0; i < q; ++i) {\n            segments.push_back(make_pair(1, n));\n        }\n    } else if (type == \"disjoint\") {\n        if (q > n) q = n; // Can't have more disjoint segments than n\n        int l = 1;\n        int segment_size = n / q;\n        int remainder = n % q;\n        for (int i = 0; i < q; ++i) {\n            int len = segment_size;\n            if (remainder > 0) {\n                len += 1;\n                remainder -= 1;\n            }\n            int r = l + len - 1;\n            segments.push_back(make_pair(l, r));\n            l = r + 1;\n        }\n    } else if (type == \"nested\") {\n        int l = 1;\n        int r = n;\n        for (int i = 0; i < q; ++i) {\n            if (l > r) break;\n            segments.push_back(make_pair(l, r));\n            if (l < r) {\n                int delta_l = rnd.next(1, min(10, r - l));\n                int delta_r = rnd.next(1, min(10, r - l));\n                l = l + delta_l;\n                r = r - delta_r;\n            } else {\n                break;\n            }\n        }\n        // If we generated fewer than q segments, fill the rest with the last segment\n        while ((int)segments.size() < q) {\n            segments.push_back(make_pair(l, r));\n        }\n    } else { // \"random\" or default\n        // First, create some disjoint segments\n        int m = rnd.next(1, min(q, n / 10 + 1)); // Number of disjoint segments\n        int l = 1;\n        int total_length = n;\n        int remaining_segments = m;\n        vector<pair<int, int>> disjoint_segments;\n        for (int i = 0; i < m; ++i) {\n            if (l > n) break;\n            int max_len = (total_length - (remaining_segments - 1)) / remaining_segments;\n            int len = rnd.next(1, max_len);\n            int r = l + len - 1;\n            if (r > n) r = n;\n            disjoint_segments.push_back(make_pair(l, r));\n            l = r + 1;\n            total_length -= len;\n            remaining_segments--;\n        }\n        // Now, for each disjoint segment, create nested segments\n        for (auto &seg : disjoint_segments) {\n            segments.push_back(seg);\n        }\n        int idx = 0;\n        while ((int)segments.size() < q) {\n            if (idx >= (int)disjoint_segments.size()) idx = 0;\n            auto &parent = disjoint_segments[idx];\n            int l_p = parent.first;\n            int r_p = parent.second;\n            int l_new = rnd.next(l_p, r_p);\n            int r_new = rnd.next(l_new, r_p);\n            segments.push_back(make_pair(l_new, r_new));\n            idx++;\n        }\n    }\n\n    // Output\n    printf(\"%d %d\\n\", n, q);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d%c\", a[i], i + 1 == n ? '\\n' : ' ');\n    }\n    for (int i = 0; i < q; ++i) {\n        int l = segments[i].first;\n        int r = segments[i].second;\n        double pi = p[i];\n        printf(\"%d %d %.3f\\n\", l, r, pi);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -q 1 -type same -initial zero -prob zero\n./gen -n 1 -q 1 -type same -initial max -prob one\n./gen -n 10 -q 5 -type nested -initial random -prob random\n./gen -n 100 -q 50 -type disjoint -initial constk -k 500 -prob extremes\n./gen -n 1000 -q 100 -type nested -initial zero -prob one\n./gen -n 10000 -q 500 -type disjoint -initial max -prob zero\n./gen -n 100000 -q 5000 -type nested -initial random -prob random\n./gen -n 100000 -q 5000 -type disjoint -initial random -prob random\n./gen -n 100000 -q 5000 -type same -initial random -prob random\n./gen -n 50000 -q 2500 -type nested -initial constk -k 1000000 -prob random\n./gen -n 50000 -q 2500 -type disjoint -initial random -prob extremes\n./gen -n 50000 -q 2500 -type random -initial random -prob random\n./gen -n 1000 -q 1000 -type same -initial zero -prob one\n./gen -n 1000 -q 1000 -type same -initial max -prob zero\n./gen -n 1000 -q 1000 -type nested -initial random -prob random\n./gen -n 1000 -q 1000 -type disjoint -initial random -prob random\n./gen -n 12345 -q 123 -type nested -initial constk -k 123456789 -prob random\n./gen -n 54321 -q 321 -type disjoint -initial constk -k 987654321 -prob random\n./gen -n 1 -q 5000 -type same -initial random -prob random\n./gen -n 100000 -q 1 -type same -initial random -prob one\n./gen -n 100000 -q 1 -type same -initial random -prob zero\n./gen -n 100000 -q 5000 -type random -initial random -prob random\n./gen -n 99999 -q 4999 -type nested -initial zero -prob extremes\n./gen -n 99999 -q 4999 -type disjoint -initial max -prob extremes\n./gen -n 60000 -q 3000 -type random -initial random -prob random\n./gen -n 60000 -q 3000 -type nested -initial random -prob random\n./gen -n 60000 -q 3000 -type disjoint -initial random -prob random\n./gen -n 1000 -q 1 -type same -initial constk -k 0 -prob one\n./gen -n 1000 -q 1 -type same -initial constk -k 1e9 -prob zero\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:38:58.562895",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "496/A",
      "title": "A. Minimum Difficulty",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains a single integer n (3 ≤ n ≤ 100) — the number of holds.The next line contains n space-separated integers ai (1 ≤ ai ≤ 1000), where ai is the height where the hold number i hangs. The sequence ai is increasing (i.e. each element except for the first one is strictly larger than the previous one).",
      "output_spec": "OutputPrint a single number — the minimum difficulty of the track after removing a single hold.",
      "sample_tests": "ExamplesInputCopy31 4 6OutputCopy5InputCopy51 2 3 4 5OutputCopy2InputCopy51 2 3 7 8OutputCopy4",
      "description": "A. Minimum Difficulty\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains a single integer n (3 ≤ n ≤ 100) — the number of holds.The next line contains n space-separated integers ai (1 ≤ ai ≤ 1000), where ai is the height where the hold number i hangs. The sequence ai is increasing (i.e. each element except for the first one is strictly larger than the previous one).\n\nOutputPrint a single number — the minimum difficulty of the track after removing a single hold.\n\nInputCopy31 4 6OutputCopy5InputCopy51 2 3 4 5OutputCopy2InputCopy51 2 3 7 8OutputCopy4\n\nInputCopy31 4 6\n\nOutputCopy5\n\nInputCopy51 2 3 4 5\n\nOutputCopy2\n\nInputCopy51 2 3 7 8\n\nOutputCopy4\n\nNoteIn the first sample you can remove only the second hold, then the sequence looks like (1, 6), the maximum difference of the neighboring elements equals 5.In the second test after removing every hold the difficulty equals 2.In the third test you can obtain sequences (1, 3, 7, 8), (1, 2, 7, 8), (1, 2, 3, 8), for which the difficulty is 4, 5 and 5, respectively. Thus, after removing the second element we obtain the optimal answer — 4.",
      "solutions": [
        {
          "title": "Codeforces Round #283 - Codeforces",
          "content": "Hi, Codeforces.Today, on December 17 at 19:30 MSK regular, 283-rd Codeforces round will take place. Problems are authored by me, Mikhail Tikhomirov. Maxim Akhmedov (Zlobober) helped me with discussing and preparing the problemset, Maria Belova (Delinur) translated problem statements in English, and Georgy Chebanov (gchebanov), Alexander Mashrabov (map) and Niyaz Nigmatullin (niyaznigmatul) tested the round and helped us with finding bugs and mistakes; let's give them a round of applause!The round will be for both divisions. The scoring is standard (not dynamic); score distribution is as follows:Div. 1: 750-1250-1250-2000-2500Div. 2: 500-1000-1750-2250-2250This is going to be my fourth round at Codeforces. I really hope it will go as good as three before it. =) Wish you all the best of luck!UPD: the round is over, thanks for participating!Grats to the winners:Div. 1: SirShokoladina Petr rowdark anta Marcin_smu Merkurev qwer1561 Ra16bit kuviman Um_nik Div. 2: SergeyMelnikov sepehr103 StarCuriosity dotato husheyn Editorial is here ( UPD: now in English!).",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/15197",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1068
        },
        {
          "title": "Codeforces Round #283: editorial (with bonuses!) - Codeforces",
          "content": "Each problem comes with a challenge — a bonus task somehow related to the problem; you may tackle at the challenges for fun and practice, also feel free to discuss them at the comments. =)496A - Minimum DifficultyFor every option of removing an element we run through the remaining elements and find the maximal difference between adjacent ones; print the smallest found answer. The solution has complexity O(n2). It can be noticed that after removing an element the difficulty either stays the same or becomes equal to the difference between the neighbours of the removed element (whatever is larger); thus, the difficulty for every option of removing an element can be found in O(1), for the total complexity of O(n). Any of these solutions (or even less efficient ones) could pass the tests.Challenge: suppose we now have to remove exactly k arbitrary elements (but the first and the last elements have to stay in their places). How small the maximal difference between adjacent elements can become? Solve this problem assuming the limitations are as follows: 1 ≤ k ≤ n - 2, n ≤ 105, ai ≤ 109.496B - Secret CombinationWe observe that the order of operations is not important: we may first perform all the shifts, and after that all the additions. Note that after n shifts the sequence returns to its original state, therefore it is sufficient to consider only the options with less than n shifts. Also, after 10 times of adding 1 to all digits the sequence does not change; we may consider only options with less than 10 additions. Thus, there are overall 10n reasonable options for performing the operations; for every option perform the operations and find the smallest answer among all the options. As performing the operations for every option and comparing two answers to choose the best takes O(n) operations, this solution performs about 10n2 elementary operations. The multiple of 10 can be get rid of, if we note that after all shifts are made the best choice is to make the first digit equal to zero, and this leaves us but a single option for the number of additions. However, implementing this optimization is not necessary to get accepted.Challenge: can you solve the problem in time? in O(n) time?496C - Removing Columns/497A - Removing ColumnsLet's look at the first column of the table. If its letters are not sorted alphabetically, then in any valid choice of removing some columns it has to be removed. However, if its letters are sorted, then for every valid choice that has this column removed it can be restored back to the table; it is clear that the new choice is valid (that is, the rows of the new table are sorted lexicographically) and the answer (that is, the number of removed columns) has just became smaller.Consider all columns from left to right. We have already chosen which columns to remove among all the columns to the left of the current one; if leaving the current column in place breaks the lexicographical order of rows, then we have to remove it; otherwise, we may leave it in place to no harm. Arguing in the way of the previous paragraph we can prove that this greedy method yields an optimal (moreover, the only optimal) solution. The complexity is O(n2).Challenge: compute how many (say, modulo 109 + 7) n × m tables are there for which the answer for this problem is k? The more efficient solution you come up with, the better.496D - Tennis Game/497B - Tennis GameChoose some t; now emulate how the match will go, ensure that the record is valid for this t and by the way find the corresponding value of s. Print all valid options for s and t. This solution works in O(n2) time, which is not good enough, but we will try to optimize it.Suppose the current set if finished and we have processed k serves by now. Let us process the next set as follows: find t-th 1 and t-th 2 after position k. If t-th 1 occurs earlier, then the first player wins the set, and the set concludes right after the t-th 1; the other case is handled symmetrically. If the match is not over yet, and in the rest of the record there are no t ones nor t twos, then the record is clearly invalid. This way, every single set in the record can be processed in time using binary search, or O(1) time using precomputed arrays of positions for each player.Now observe that for any t a match of n serves can not contain more than n / t sets, as each set contains at least t serves. If we sum up the upper limits for the number of sets for each t, we obtain the total upper limit for the number of sets we may need to process: (which is the famous harmonic sum). Using one of the approaches discussed above, one obtains a solution with complexity of or ; each of these solutions fits the limit nicely.Obviously, for every t there is no more than one valid choice for s; however, maybe a bit unexpected, for a given s there may exist more than one valid choice of t. The first test where this takes place is pretest 12. The statement requires that the pairs are printed lexicographically ordered; it is possible to make a mistake here and print the pairs with equal s by descending t (if we fill the array by increasing t and then simply reverse the array).Challenge: while preparing this problem I discovered that it's quite hard to find a test such that the number of pairs in the answer is large; in the actual tests the maximal number is 128, which is the number of divisors of the number 83160. Can you beat this record? If you have a test with n ≤ 105 that has larger number of pairs in the answer, feel free to brag in the comments; also don't hesitate to share any insights on how one could bound the maximal number analytically.496E - Distributing Parts /497C - Distributing Parts Sort all the parts and actors altogether by increasing lower bounds (if equal, actors precede parts); process all the enitities in this order. We maintain a set of actors which have already occured in the order; if we meet an entry for an actor, add it to the set. If we currently process a part, we have to assign it to an actor; from the current set of actors we have to choose one such that his di ≥ bj (the ci ≤ aj constraint is provided by the fact that the i-th actor has occured earlier than the j-th part); if there are no such actors in the set, no answer can be obtained; if there are several actors satisftying this requirement, we should choose one with minimal di (intuitively, he will be less useful in the future). Assign the chosen actor with the current part and decrement his ki; if ki is now zero, the actor can not be used anymore, thus we remove him from the set.To fit the limits we should implement the set of current actors as some efficient data structure (e.g., an std::set or a treap). The resulting complexity is .Challenge: suppose that now there are qj copies of the j-th part (1 ≤ qj ≤ 109), and each copy must be separately assigned with an actor in a valid way. Can you solve this new problem with all the old constraints (as the actual distribution now has too much entries, it is sufficient to check whether an answer exists)?497D - GearsWhen a collision happens, a vertex of one polygon lands on a side of the other polygon. Consider a reference system such that the polygon A is not moving. In this system the polygon B preserves its orientation (that is, does not rotate), and each of its vertices moves on some circle. Intersect all the circles for vertices of B with all the sides of A; if any of them intersect, then some vertex of B collides with a side of A. Symmetrically, take a reference system associated with B and check whether some vertex of A collides with a side of B. The constraints for the points' coordinates are small enough for a solution with absolute precision to be possible (using built-in integer types).Another approach (which is, in fact, basically the same) is such: suppose there is a collision in a reference system associated with A. Then the following equality for vectors holds: x + y = z; here z is a vector that starts at P and ends somewhere on the bound of A, x is a vector that starts at Q and ends somewhere on the bound of B, y is a vector that starts at P and ends somewhere on the circle centered at P that passes through Q. Rewrite the equality as y = z - x; now observe that the set of all possible values of z - x forms the Minkowski sum of A and reflection of B (up to some shift), and the set of all possible values of y is a circle with known parameters. The Minkowski sum can be represented as a union of nm parallelograms, each of which is the Minkowski sum of a pair of sides of different polygons; finally, intersect all parallelograms with the circle.Both solutions have complexity O(nm). As noted above, it is possible to solve the problem using integer arithemetics (that is, with absolute precision); however, the fact that the points' coordinates are small lets most of the solutions with floating point arithmetics pass. It was tempting to write an approximate numerical solution; we struggled hard not to let such solutions pass, and eventually none of them did. =)Many participants had troubles with pretest 8. It looks as follows (the left spiral revolves around the left point, and the right spiral revolves around the right point):Challenge: suppose we want a solution that uses floating point arithmetics to fail. In order to do that, we want to construct a test such that the polygons don't collide but pass really close to each other. How small a (positive) distance we can achieve, given the same constraints for the number of points and the points' coordinates?497E - Subsequences ReturnConsider some string; how does one count the number of its distinct subsequences? Let us append symbols to the string consequently and each time count the number of subsequences that were not present before. Let's append a symbol c to a string s; in the string s + c there are as many subsequences that end in c as there were subsequences in s overall. Add all these subsequences to the number of subsequnces of s; now each subsequence is counted once, except for the subsequences that end in c but were already present in s before; these are counted twice. Thus, the total number of subsequences in the new string is twice the total number of subsequences in the old string minus the number of subsequences in the old string which end in c.This leads us to the following solution: for each symbol c store how many subsequences end in c, denote cntc. Append symbol c; now cntc becomes equal to the sum of all cnt's plus one (for the empty subsequence), and all the other cnt's do not change.For example, consider the first few symbols of the Thue-Morse sequence: ε — (0, 0) 0 — ( 0 + 0 + 1 = 1, 0) 01 — (1, 1 + 0 + 1 = 2) 011 — (1, 1 + 2 + 1 = 4) 0110 — ( 1 + 4 + 1 = 6, 4) ... Let us put the values of cnt in the coordinates of a vector, and also append a coordinate which is always equal to 1. It is now clear that appending a symbol to the string alters the vector as a multiplication by some matrix. Let us assign a matrix for each symbol, and also for each string as a product of matrices for the symbols of the strings in that order.Now, consider the prefix of the sequence ai of length km. Divide it into k parts of length km - 1; x-th (0-based) of these parts can be obtained from the 0-th one by adding x modulo k to all elements of the part. Let us count the matrices (see above) for the prefixes of length km, and also for all strings that are obtained by adding x to all of the prefixes' elements; denote such matrix Am, x.It is easy to see that if m > 0, then . This formula allows us to count Am, x for all and all x from 0 to k - 1 in time. Now, upon having all Am, x we can multiply some of them in the right order to obtain the matrix for the prefix of the sequence ai of length n.Unfortunately, this is not quite enough as the solution doesn't fit the time limit yet. Here is one way to speed up sufficiently: note that the product in the formula can be divided as shown: Am - 1, x... Am - 1, k - 1 × Am - 1, 0... Am - 1, x - 1 (if x = 0, take the second part to be empty). Count all the \"prefixes\" and \"suffixes\" products of the set Am, x: Pm, x = Am, 0... Am, x - 1, Sm, x = Am, x... Am, k - 1. Now Am, x = Sm - 1, xPm - 1, x. Thus, the computation of Am, x for all x and a given m can be done as computing all Pm - 1, x, Sm - 1, x using O(k) matrix multiplications, and each Am, x is now can be found using one matrix multiplication. Finally, the solution now works in time, which fits the limits by a margin.Challenge: solve the problem for k ≤ 100.",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/15208",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 496\\s*A"
          },
          "content_length": 12568
        },
        {
          "title": "Codeforces Round #283: editorial (with bonuses!) - Codeforces",
          "content": "Each problem comes with a challenge — a bonus task somehow related to the problem; you may tackle at the challenges for fun and practice, also feel free to discuss them at the comments. =)496A - Minimum DifficultyFor every option of removing an element we run through the remaining elements and find the maximal difference between adjacent ones; print the smallest found answer. The solution has complexity O(n2). It can be noticed that after removing an element the difficulty either stays the same or becomes equal to the difference between the neighbours of the removed element (whatever is larger); thus, the difficulty for every option of removing an element can be found in O(1), for the total complexity of O(n). Any of these solutions (or even less efficient ones) could pass the tests.Challenge: suppose we now have to remove exactly k arbitrary elements (but the first and the last elements have to stay in their places). How small the maximal difference between adjacent elements can become? Solve this problem assuming the limitations are as follows: 1 ≤ k ≤ n - 2, n ≤ 105, ai ≤ 109.496B - Secret CombinationWe observe that the order of operations is not important: we may first perform all the shifts, and after that all the additions. Note that after n shifts the sequence returns to its original state, therefore it is sufficient to consider only the options with less than n shifts. Also, after 10 times of adding 1 to all digits the sequence does not change; we may consider only options with less than 10 additions. Thus, there are overall 10n reasonable options for performing the operations; for every option perform the operations and find the smallest answer among all the options. As performing the operations for every option and comparing two answers to choose the best takes O(n) operations, this solution performs about 10n2 elementary operations. The multiple of 10 can be get rid of, if we note that after all shifts are made the best choice is to make the first digit equal to zero, and this leaves us but a single option for the number of additions. However, implementing this optimization is not necessary to get accepted.Challenge: can you solve the problem in time? in O(n) time?496C - Removing Columns/497A - Removing ColumnsLet's look at the first column of the table. If its letters are not sorted alphabetically, then in any valid choice of removing some columns it has to be removed. However, if its letters are sorted, then for every valid choice that has this column removed it can be restored back to the table; it is clear that the new choice is valid (that is, the rows of the new table are sorted lexicographically) and the answer (that is, the number of removed columns) has just became smaller.Consider all columns from left to right. We have already chosen which columns to remove among all the columns to the left of the current one; if leaving the current column in place breaks the lexicographical order of rows, then we have to remove it; otherwise, we may leave it in place to no harm. Arguing in the way of the previous paragraph we can prove that this greedy method yields an optimal (moreover, the only optimal) solution. The complexity is O(n2).Challenge: compute how many (say, modulo 109 + 7) n × m tables are there for which the answer for this problem is k? The more efficient solution you come up with, the better.496D - Tennis Game/497B - Tennis GameChoose some t; now emulate how the match will go, ensure that the record is valid for this t and by the way find the corresponding value of s. Print all valid options for s and t. This solution works in O(n2) time, which is not good enough, but we will try to optimize it.Suppose the current set if finished and we have processed k serves by now. Let us process the next set as follows: find t-th 1 and t-th 2 after position k. If t-th 1 occurs earlier, then the first player wins the set, and the set concludes right after the t-th 1; the other case is handled symmetrically. If the match is not over yet, and in the rest of the record there are no t ones nor t twos, then the record is clearly invalid. This way, every single set in the record can be processed in time using binary search, or O(1) time using precomputed arrays of positions for each player.Now observe that for any t a match of n serves can not contain more than n / t sets, as each set contains at least t serves. If we sum up the upper limits for the number of sets for each t, we obtain the total upper limit for the number of sets we may need to process: (which is the famous harmonic sum). Using one of the approaches discussed above, one obtains a solution with complexity of or ; each of these solutions fits the limit nicely.Obviously, for every t there is no more than one valid choice for s; however, maybe a bit unexpected, for a given s there may exist more than one valid choice of t. The first test where this takes place is pretest 12. The statement requires that the pairs are printed lexicographically ordered; it is possible to make a mistake here and print the pairs with equal s by descending t (if we fill the array by increasing t and then simply reverse the array).Challenge: while preparing this problem I discovered that it's quite hard to find a test such that the number of pairs in the answer is large; in the actual tests the maximal number is 128, which is the number of divisors of the number 83160. Can you beat this record? If you have a test with n ≤ 105 that has larger number of pairs in the answer, feel free to brag in the comments; also don't hesitate to share any insights on how one could bound the maximal number analytically.496E - Distributing Parts /497C - Distributing Parts Sort all the parts and actors altogether by increasing lower bounds (if equal, actors precede parts); process all the enitities in this order. We maintain a set of actors which have already occured in the order; if we meet an entry for an actor, add it to the set. If we currently process a part, we have to assign it to an actor; from the current set of actors we have to choose one such that his di ≥ bj (the ci ≤ aj constraint is provided by the fact that the i-th actor has occured earlier than the j-th part); if there are no such actors in the set, no answer can be obtained; if there are several actors satisftying this requirement, we should choose one with minimal di (intuitively, he will be less useful in the future). Assign the chosen actor with the current part and decrement his ki; if ki is now zero, the actor can not be used anymore, thus we remove him from the set.To fit the limits we should implement the set of current actors as some efficient data structure (e.g., an std::set or a treap). The resulting complexity is .Challenge: suppose that now there are qj copies of the j-th part (1 ≤ qj ≤ 109), and each copy must be separately assigned with an actor in a valid way. Can you solve this new problem with all the old constraints (as the actual distribution now has too much entries, it is sufficient to check whether an answer exists)?497D - GearsWhen a collision happens, a vertex of one polygon lands on a side of the other polygon. Consider a reference system such that the polygon A is not moving. In this system the polygon B preserves its orientation (that is, does not rotate), and each of its vertices moves on some circle. Intersect all the circles for vertices of B with all the sides of A; if any of them intersect, then some vertex of B collides with a side of A. Symmetrically, take a reference system associated with B and check whether some vertex of A collides with a side of B. The constraints for the points' coordinates are small enough for a solution with absolute precision to be possible (using built-in integer types).Another approach (which is, in fact, basically the same) is such: suppose there is a collision in a reference system associated with A. Then the following equality for vectors holds: x + y = z; here z is a vector that starts at P and ends somewhere on the bound of A, x is a vector that starts at Q and ends somewhere on the bound of B, y is a vector that starts at P and ends somewhere on the circle centered at P that passes through Q. Rewrite the equality as y = z - x; now observe that the set of all possible values of z - x forms the Minkowski sum of A and reflection of B (up to some shift), and the set of all possible values of y is a circle with known parameters. The Minkowski sum can be represented as a union of nm parallelograms, each of which is the Minkowski sum of a pair of sides of different polygons; finally, intersect all parallelograms with the circle.Both solutions have complexity O(nm). As noted above, it is possible to solve the problem using integer arithemetics (that is, with absolute precision); however, the fact that the points' coordinates are small lets most of the solutions with floating point arithmetics pass. It was tempting to write an approximate numerical solution; we struggled hard not to let such solutions pass, and eventually none of them did. =)Many participants had troubles with pretest 8. It looks as follows (the left spiral revolves around the left point, and the right spiral revolves around the right point):Challenge: suppose we want a solution that uses floating point arithmetics to fail. In order to do that, we want to construct a test such that the polygons don't collide but pass really close to each other. How small a (positive) distance we can achieve, given the same constraints for the number of points and the points' coordinates?497E - Subsequences ReturnConsider some string; how does one count the number of its distinct subsequences? Let us append symbols to the string consequently and each time count the number of subsequences that were not present before. Let's append a symbol c to a string s; in the string s + c there are as many subsequences that end in c as there were subsequences in s overall. Add all these subsequences to the number of subsequnces of s; now each subsequence is counted once, except for the subsequences that end in c but were already present in s before; these are counted twice. Thus, the total number of subsequences in the new string is twice the total number of subsequences in the old string minus the number of subsequences in the old string which end in c.This leads us to the following solution: for each symbol c store how many subsequences end in c, denote cntc. Append symbol c; now cntc becomes equal to the sum of all cnt's plus one (for the empty subsequence), and all the other cnt's do not change.For example, consider the first few symbols of the Thue-Morse sequence: ε — (0, 0) 0 — ( 0 + 0 + 1 = 1, 0) 01 — (1, 1 + 0 + 1 = 2) 011 — (1, 1 + 2 + 1 = 4) 0110 — ( 1 + 4 + 1 = 6, 4) ... Let us put the values of cnt in the coordinates of a vector, and also append a coordinate which is always equal to 1. It is now clear that appending a symbol to the string alters the vector as a multiplication by some matrix. Let us assign a matrix for each symbol, and also for each string as a product of matrices for the symbols of the strings in that order.Now, consider the prefix of the sequence ai of length km. Divide it into k parts of length km - 1; x-th (0-based) of these parts can be obtained from the 0-th one by adding x modulo k to all elements of the part. Let us count the matrices (see above) for the prefixes of length km, and also for all strings that are obtained by adding x to all of the prefixes' elements; denote such matrix Am, x.It is easy to see that if m > 0, then . This formula allows us to count Am, x for all and all x from 0 to k - 1 in time. Now, upon having all Am, x we can multiply some of them in the right order to obtain the matrix for the prefix of the sequence ai of length n.Unfortunately, this is not quite enough as the solution doesn't fit the time limit yet. Here is one way to speed up sufficiently: note that the product in the formula can be divided as shown: Am - 1, x... Am - 1, k - 1 × Am - 1, 0... Am - 1, x - 1 (if x = 0, take the second part to be empty). Count all the \"prefixes\" and \"suffixes\" products of the set Am, x: Pm, x = Am, 0... Am, x - 1, Sm, x = Am, x... Am, k - 1. Now Am, x = Sm - 1, xPm - 1, x. Thus, the computation of Am, x for all x and a given m can be done as computing all Pm - 1, x, Sm - 1, x using O(k) matrix multiplications, and each Am, x is now can be found using one matrix multiplication. Finally, the solution now works in time, which fits the limits by a margin.Challenge: solve the problem for k ≤ 100.",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/15208",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 496\\s*A"
          },
          "content_length": 12568
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #283 - Codeforces - Code 1",
          "code": "18\n2 2   2 2   2 2   1 2 1   1 2 1   1 2 1   1 2 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15197",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #283 - Codeforces - Code 2",
          "code": "18\n2 2   2 2   2 2   1 2 1   1 2 1   1 2 1   1 2 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15197",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #283 - Codeforces - Code 3",
          "code": "ans[ac]=i;\n       ac++;\n    }\n}\nreturn ac;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15197",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #283 - Codeforces - Code 4",
          "code": "ans[ac]=i;\n       ac++;\n    }\n}\nreturn ac;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15197",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #283 - Codeforces - Code 5",
          "code": "cin>>n;\nfor (int i=0;i<n;i++) cin>>a[i];\nfor (int i=0;i<n;i++) {\n    if (a[i]==1) x++; else y++;\n    f[i]=max(x,y);\n}\nint z=fact(f[n-1]);\nif (x==y) {\n    cout<<\"0\";\n} else {\n    cout<<ac<<endl;\n    for (int i=0;i<ac;i++) {\n       cout<<ans[i]<<\" \"<<f[n-1]/ans[i]<<endl;\n    }\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15197",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #283 - Codeforces - Code 6",
          "code": "cin>>n;\nfor (int i=0;i<n;i++) cin>>a[i];\nfor (int i=0;i<n;i++) {\n    if (a[i]==1) x++; else y++;\n    f[i]=max(x,y);\n}\nint z=fact(f[n-1]);\nif (x==y) {\n    cout<<\"0\";\n} else {\n    cout<<ac<<endl;\n    for (int i=0;i<ac;i++) {\n       cout<<ans[i]<<\" \"<<f[n-1]/ans[i]<<endl;\n    }\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15197",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #283 - Codeforces - Code 7",
          "code": "ae ae et oe",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15197",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #283 - Codeforces - Code 8",
          "code": "20\n1 1 2 2 2 2 2 2 2 2 2 2 1 2 2 1 2 2 2 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15197",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #283 - Codeforces - Code 9",
          "code": "20\n1 1 2 2 2 2 2 2 2 2 2 2 1 2 2 1 2 2 2 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15197",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #283: editorial (with bonuses!) - Codeforces - Code 1",
          "code": "496D - Tennis Game",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15208",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #283: editorial (with bonuses!) - Codeforces - Code 2",
          "code": "number of valid (s,t) will be 0 if the total number of points of player who won  the last point is less than or equal to another player",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15208",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #283: editorial (with bonuses!) - Codeforces - Code 3",
          "code": "strictly more",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15208",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #283: editorial (with bonuses!) - Codeforces - Code 4",
          "code": "The Minkowski sum can be represented as a union of nm parallelograms, each of which is the Minkowski sum of a pair of sides of different polygons;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15208",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #283: editorial (with bonuses!) - Codeforces - Code 5",
          "code": "circle_segment",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15208",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #283: editorial (with bonuses!) - Codeforces - Code 6",
          "code": "ll dmax = (max((a - c) | (a - c), (a - b) | (a - b))); -> ll dmax = (max((a - c) | (a - c), (b - c) | (b - c)));",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15208",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #283: editorial (with bonuses!) - Codeforces - Code 7",
          "code": "ll dmax = (max((a - c) | (a - c), (a - b) | (a - b))); -> ll dmax = (max((a - c) | (a - c), (b - c) | (b - c)));",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15208",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #283: editorial (with bonuses!) - Codeforces - Code 1",
          "code": "496D - Tennis Game",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15208",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #283: editorial (with bonuses!) - Codeforces - Code 2",
          "code": "number of valid (s,t) will be 0 if the total number of points of player who won  the last point is less than or equal to another player",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15208",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #283: editorial (with bonuses!) - Codeforces - Code 3",
          "code": "strictly more",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15208",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #283: editorial (with bonuses!) - Codeforces - Code 4",
          "code": "The Minkowski sum can be represented as a union of nm parallelograms, each of which is the Minkowski sum of a pair of sides of different polygons;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15208",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #283: editorial (with bonuses!) - Codeforces - Code 5",
          "code": "circle_segment",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15208",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #283: editorial (with bonuses!) - Codeforces - Code 6",
          "code": "ll dmax = (max((a - c) | (a - c), (a - b) | (a - b))); -> ll dmax = (max((a - c) | (a - c), (b - c) | (b - c)));",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15208",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #283: editorial (with bonuses!) - Codeforces - Code 7",
          "code": "ll dmax = (max((a - c) | (a - c), (a - b) | (a - b))); -> ll dmax = (max((a - c) | (a - c), (b - c) | (b - c)));",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15208",
          "author": "Qingyu"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(3, 100, \"n\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, 1, 1000);\n    inf.readEoln();\n\n    for (int i = 0; i + 1 < n; ++i) {\n        ensuref(a[i] < a[i+1], \"Sequence a_i must be strictly increasing at position %d\", i+1);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(3, 100, \"n\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, 1, 1000);\n    inf.readEoln();\n\n    for (int i = 0; i + 1 < n; ++i) {\n        ensuref(a[i] < a[i+1], \"Sequence a_i must be strictly increasing at position %d\", i+1);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(3, 100, \"n\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, 1, 1000);\n    inf.readEoln();\n\n    for (int i = 0; i + 1 < n; ++i) {\n        ensuref(a[i] < a[i+1], \"Sequence a_i must be strictly increasing at position %d\", i+1);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> a(n);\n\n    if (type == \"random\") {\n        // Random increasing sequence\n        a[0] = rnd.next(1, 1000 - n + 1);\n        for (int i = 1; i < n; i++) {\n            a[i] = a[i - 1] + rnd.next(1, 10);\n        }\n    } else if (type == \"consecutive\") {\n        // Consecutive numbers\n        int start = rnd.next(1, 1000 - n + 1);\n        for (int i = 0; i < n; i++) {\n            a[i] = start + i;\n        }\n    } else if (type == \"biggap\") {\n        // Sequence with one big gap\n        a[0] = rnd.next(1, 100);\n        for (int i = 1; i < n; i++) {\n            a[i] = a[i - 1] + 1;\n        }\n        if (n > 3) {\n            int gap_pos = rnd.next(1, n - 2); // Position of big gap (not first or last)\n            int biggap = rnd.next(100, 500);\n            a[gap_pos] = a[gap_pos - 1] + biggap;\n            for (int i = gap_pos + 1; i < n; i++) {\n                a[i] = a[i - 1] + 1;\n            }\n        }\n    } else if (type == \"maxgap\") {\n        // Maximum possible gaps\n        a[0] = rnd.next(1, 10);\n        int gap = (1000 - a[0]) / n;\n        if (gap < 1) gap = 1;\n        for (int i = 1; i < n; i++) {\n            a[i] = a[i - 1] + gap;\n        }\n    } else if (type == \"minmaxgap\") {\n        // Alternate between small and large gaps\n        int D = rnd.next(50, 100);\n        a[0] = rnd.next(1, 10);\n        for (int i = 1; i < n; i++) {\n            if (i % 2 == 1)\n                a[i] = a[i - 1] + 1;\n            else\n                a[i] = a[i - 1] + D;\n        }\n    } else if (type == \"worstcase\") {\n        // All gaps are equal (could cause incorrect code to fail)\n        int gap = rnd.next(1, 10);\n        a[0] = rnd.next(1, 1000 - gap * (n - 1));\n        for (int i = 1; i < n; i++) {\n            a[i] = a[i - 1] + gap;\n        }\n    } else if (type == \"equalgaps\") {\n        // All differences are equal\n        int gap = rnd.next(1, (1000 - 1) / n);\n        a[0] = rnd.next(1, 1000 - gap * (n - 1));\n        for (int i = 1; i < n; i++) {\n            a[i] = a[i - 1] + gap;\n        }\n    } else {\n        // Default to random increasing sequence\n        a[0] = rnd.next(1, 1000 - n + 1);\n        for (int i = 1; i < n; i++) {\n            a[i] = a[i - 1] + rnd.next(1, 10);\n        }\n    }\n\n    // Output n\n    printf(\"%d\\n\", n);\n    // Output sequence\n    for (int i = 0; i < n; i++) {\n        if (i > 0) printf(\" \");\n        printf(\"%d\", a[i]);\n    }\n    printf(\"\\n\");\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> a(n);\n\n    if (type == \"random\") {\n        // Random increasing sequence\n        a[0] = rnd.next(1, 1000 - n + 1);\n        for (int i = 1; i < n; i++) {\n            a[i] = a[i - 1] + rnd.next(1, 10);\n        }\n    } else if (type == \"consecutive\") {\n        // Consecutive numbers\n        int start = rnd.next(1, 1000 - n + 1);\n        for (int i = 0; i < n; i++) {\n            a[i] = start + i;\n        }\n    } else if (type == \"biggap\") {\n        // Sequence with one big gap\n        a[0] = rnd.next(1, 100);\n        for (int i = 1; i < n; i++) {\n            a[i] = a[i - 1] + 1;\n        }\n        if (n > 3) {\n            int gap_pos = rnd.next(1, n - 2); // Position of big gap (not first or last)\n            int biggap = rnd.next(100, 500);\n            a[gap_pos] = a[gap_pos - 1] + biggap;\n            for (int i = gap_pos + 1; i < n; i++) {\n                a[i] = a[i - 1] + 1;\n            }\n        }\n    } else if (type == \"maxgap\") {\n        // Maximum possible gaps\n        a[0] = rnd.next(1, 10);\n        int gap = (1000 - a[0]) / n;\n        if (gap < 1) gap = 1;\n        for (int i = 1; i < n; i++) {\n            a[i] = a[i - 1] + gap;\n        }\n    } else if (type == \"minmaxgap\") {\n        // Alternate between small and large gaps\n        int D = rnd.next(50, 100);\n        a[0] = rnd.next(1, 10);\n        for (int i = 1; i < n; i++) {\n            if (i % 2 == 1)\n                a[i] = a[i - 1] + 1;\n            else\n                a[i] = a[i - 1] + D;\n        }\n    } else if (type == \"worstcase\") {\n        // All gaps are equal (could cause incorrect code to fail)\n        int gap = rnd.next(1, 10);\n        a[0] = rnd.next(1, 1000 - gap * (n - 1));\n        for (int i = 1; i < n; i++) {\n            a[i] = a[i - 1] + gap;\n        }\n    } else if (type == \"equalgaps\") {\n        // All differences are equal\n        int gap = rnd.next(1, (1000 - 1) / n);\n        a[0] = rnd.next(1, 1000 - gap * (n - 1));\n        for (int i = 1; i < n; i++) {\n            a[i] = a[i - 1] + gap;\n        }\n    } else {\n        // Default to random increasing sequence\n        a[0] = rnd.next(1, 1000 - n + 1);\n        for (int i = 1; i < n; i++) {\n            a[i] = a[i - 1] + rnd.next(1, 10);\n        }\n    }\n\n    // Output n\n    printf(\"%d\\n\", n);\n    // Output sequence\n    for (int i = 0; i < n; i++) {\n        if (i > 0) printf(\" \");\n        printf(\"%d\", a[i]);\n    }\n    printf(\"\\n\");\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 3 -type random\n./gen -n 10 -type random\n./gen -n 50 -type random\n./gen -n 99 -type random\n./gen -n 100 -type random\n\n./gen -n 3 -type consecutive\n./gen -n 10 -type consecutive\n./gen -n 50 -type consecutive\n./gen -n 100 -type consecutive\n\n./gen -n 3 -type biggap\n./gen -n 5 -type biggap\n./gen -n 50 -type biggap\n./gen -n 100 -type biggap\n\n./gen -n 3 -type maxgap\n./gen -n 10 -type maxgap\n./gen -n 50 -type maxgap\n./gen -n 100 -type maxgap\n\n./gen -n 3 -type minmaxgap\n./gen -n 10 -type minmaxgap\n./gen -n 50 -type minmaxgap\n./gen -n 99 -type minmaxgap\n./gen -n 100 -type minmaxgap\n\n./gen -n 3 -type worstcase\n./gen -n 10 -type worstcase\n./gen -n 50 -type worstcase\n./gen -n 100 -type worstcase\n\n./gen -n 3 -type equalgaps\n./gen -n 10 -type equalgaps\n./gen -n 50 -type equalgaps\n./gen -n 100 -type equalgaps\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:39:00.838253",
        "total_tutorials": 3,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "496/B",
      "title": "B. Secret Combination",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains a single integer n (1 ≤ n ≤ 1000) — the number of digits on the display.The second line contains n digits — the initial state of the display.",
      "output_spec": "OutputPrint a single line containing n digits — the desired state of the display containing the smallest possible number.",
      "sample_tests": "ExamplesInputCopy3579OutputCopy024InputCopy42014OutputCopy0142",
      "description": "B. Secret Combination\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains a single integer n (1 ≤ n ≤ 1000) — the number of digits on the display.The second line contains n digits — the initial state of the display.\n\nOutputPrint a single line containing n digits — the desired state of the display containing the smallest possible number.\n\nInputCopy3579OutputCopy024InputCopy42014OutputCopy0142\n\nInputCopy3579\n\nOutputCopy024\n\nInputCopy42014\n\nOutputCopy0142",
      "solutions": [
        {
          "title": "Codeforces Round #283 - Codeforces",
          "content": "Hi, Codeforces.Today, on December 17 at 19:30 MSK regular, 283-rd Codeforces round will take place. Problems are authored by me, Mikhail Tikhomirov. Maxim Akhmedov (Zlobober) helped me with discussing and preparing the problemset, Maria Belova (Delinur) translated problem statements in English, and Georgy Chebanov (gchebanov), Alexander Mashrabov (map) and Niyaz Nigmatullin (niyaznigmatul) tested the round and helped us with finding bugs and mistakes; let's give them a round of applause!The round will be for both divisions. The scoring is standard (not dynamic); score distribution is as follows:Div. 1: 750-1250-1250-2000-2500Div. 2: 500-1000-1750-2250-2250This is going to be my fourth round at Codeforces. I really hope it will go as good as three before it. =) Wish you all the best of luck!UPD: the round is over, thanks for participating!Grats to the winners:Div. 1: SirShokoladina Petr rowdark anta Marcin_smu Merkurev qwer1561 Ra16bit kuviman Um_nik Div. 2: SergeyMelnikov sepehr103 StarCuriosity dotato husheyn Editorial is here ( UPD: now in English!).",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/15197",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1068
        },
        {
          "title": "Codeforces Round #283: editorial (with bonuses!) - Codeforces",
          "content": "Each problem comes with a challenge — a bonus task somehow related to the problem; you may tackle at the challenges for fun and practice, also feel free to discuss them at the comments. =)496A - Minimum DifficultyFor every option of removing an element we run through the remaining elements and find the maximal difference between adjacent ones; print the smallest found answer. The solution has complexity O(n2). It can be noticed that after removing an element the difficulty either stays the same or becomes equal to the difference between the neighbours of the removed element (whatever is larger); thus, the difficulty for every option of removing an element can be found in O(1), for the total complexity of O(n). Any of these solutions (or even less efficient ones) could pass the tests.Challenge: suppose we now have to remove exactly k arbitrary elements (but the first and the last elements have to stay in their places). How small the maximal difference between adjacent elements can become? Solve this problem assuming the limitations are as follows: 1 ≤ k ≤ n - 2, n ≤ 105, ai ≤ 109.496B - Secret CombinationWe observe that the order of operations is not important: we may first perform all the shifts, and after that all the additions. Note that after n shifts the sequence returns to its original state, therefore it is sufficient to consider only the options with less than n shifts. Also, after 10 times of adding 1 to all digits the sequence does not change; we may consider only options with less than 10 additions. Thus, there are overall 10n reasonable options for performing the operations; for every option perform the operations and find the smallest answer among all the options. As performing the operations for every option and comparing two answers to choose the best takes O(n) operations, this solution performs about 10n2 elementary operations. The multiple of 10 can be get rid of, if we note that after all shifts are made the best choice is to make the first digit equal to zero, and this leaves us but a single option for the number of additions. However, implementing this optimization is not necessary to get accepted.Challenge: can you solve the problem in time? in O(n) time?496C - Removing Columns/497A - Removing ColumnsLet's look at the first column of the table. If its letters are not sorted alphabetically, then in any valid choice of removing some columns it has to be removed. However, if its letters are sorted, then for every valid choice that has this column removed it can be restored back to the table; it is clear that the new choice is valid (that is, the rows of the new table are sorted lexicographically) and the answer (that is, the number of removed columns) has just became smaller.Consider all columns from left to right. We have already chosen which columns to remove among all the columns to the left of the current one; if leaving the current column in place breaks the lexicographical order of rows, then we have to remove it; otherwise, we may leave it in place to no harm. Arguing in the way of the previous paragraph we can prove that this greedy method yields an optimal (moreover, the only optimal) solution. The complexity is O(n2).Challenge: compute how many (say, modulo 109 + 7) n × m tables are there for which the answer for this problem is k? The more efficient solution you come up with, the better.496D - Tennis Game/497B - Tennis GameChoose some t; now emulate how the match will go, ensure that the record is valid for this t and by the way find the corresponding value of s. Print all valid options for s and t. This solution works in O(n2) time, which is not good enough, but we will try to optimize it.Suppose the current set if finished and we have processed k serves by now. Let us process the next set as follows: find t-th 1 and t-th 2 after position k. If t-th 1 occurs earlier, then the first player wins the set, and the set concludes right after the t-th 1; the other case is handled symmetrically. If the match is not over yet, and in the rest of the record there are no t ones nor t twos, then the record is clearly invalid. This way, every single set in the record can be processed in time using binary search, or O(1) time using precomputed arrays of positions for each player.Now observe that for any t a match of n serves can not contain more than n / t sets, as each set contains at least t serves. If we sum up the upper limits for the number of sets for each t, we obtain the total upper limit for the number of sets we may need to process: (which is the famous harmonic sum). Using one of the approaches discussed above, one obtains a solution with complexity of or ; each of these solutions fits the limit nicely.Obviously, for every t there is no more than one valid choice for s; however, maybe a bit unexpected, for a given s there may exist more than one valid choice of t. The first test where this takes place is pretest 12. The statement requires that the pairs are printed lexicographically ordered; it is possible to make a mistake here and print the pairs with equal s by descending t (if we fill the array by increasing t and then simply reverse the array).Challenge: while preparing this problem I discovered that it's quite hard to find a test such that the number of pairs in the answer is large; in the actual tests the maximal number is 128, which is the number of divisors of the number 83160. Can you beat this record? If you have a test with n ≤ 105 that has larger number of pairs in the answer, feel free to brag in the comments; also don't hesitate to share any insights on how one could bound the maximal number analytically.496E - Distributing Parts /497C - Distributing Parts Sort all the parts and actors altogether by increasing lower bounds (if equal, actors precede parts); process all the enitities in this order. We maintain a set of actors which have already occured in the order; if we meet an entry for an actor, add it to the set. If we currently process a part, we have to assign it to an actor; from the current set of actors we have to choose one such that his di ≥ bj (the ci ≤ aj constraint is provided by the fact that the i-th actor has occured earlier than the j-th part); if there are no such actors in the set, no answer can be obtained; if there are several actors satisftying this requirement, we should choose one with minimal di (intuitively, he will be less useful in the future). Assign the chosen actor with the current part and decrement his ki; if ki is now zero, the actor can not be used anymore, thus we remove him from the set.To fit the limits we should implement the set of current actors as some efficient data structure (e.g., an std::set or a treap). The resulting complexity is .Challenge: suppose that now there are qj copies of the j-th part (1 ≤ qj ≤ 109), and each copy must be separately assigned with an actor in a valid way. Can you solve this new problem with all the old constraints (as the actual distribution now has too much entries, it is sufficient to check whether an answer exists)?497D - GearsWhen a collision happens, a vertex of one polygon lands on a side of the other polygon. Consider a reference system such that the polygon A is not moving. In this system the polygon B preserves its orientation (that is, does not rotate), and each of its vertices moves on some circle. Intersect all the circles for vertices of B with all the sides of A; if any of them intersect, then some vertex of B collides with a side of A. Symmetrically, take a reference system associated with B and check whether some vertex of A collides with a side of B. The constraints for the points' coordinates are small enough for a solution with absolute precision to be possible (using built-in integer types).Another approach (which is, in fact, basically the same) is such: suppose there is a collision in a reference system associated with A. Then the following equality for vectors holds: x + y = z; here z is a vector that starts at P and ends somewhere on the bound of A, x is a vector that starts at Q and ends somewhere on the bound of B, y is a vector that starts at P and ends somewhere on the circle centered at P that passes through Q. Rewrite the equality as y = z - x; now observe that the set of all possible values of z - x forms the Minkowski sum of A and reflection of B (up to some shift), and the set of all possible values of y is a circle with known parameters. The Minkowski sum can be represented as a union of nm parallelograms, each of which is the Minkowski sum of a pair of sides of different polygons; finally, intersect all parallelograms with the circle.Both solutions have complexity O(nm). As noted above, it is possible to solve the problem using integer arithemetics (that is, with absolute precision); however, the fact that the points' coordinates are small lets most of the solutions with floating point arithmetics pass. It was tempting to write an approximate numerical solution; we struggled hard not to let such solutions pass, and eventually none of them did. =)Many participants had troubles with pretest 8. It looks as follows (the left spiral revolves around the left point, and the right spiral revolves around the right point):Challenge: suppose we want a solution that uses floating point arithmetics to fail. In order to do that, we want to construct a test such that the polygons don't collide but pass really close to each other. How small a (positive) distance we can achieve, given the same constraints for the number of points and the points' coordinates?497E - Subsequences ReturnConsider some string; how does one count the number of its distinct subsequences? Let us append symbols to the string consequently and each time count the number of subsequences that were not present before. Let's append a symbol c to a string s; in the string s + c there are as many subsequences that end in c as there were subsequences in s overall. Add all these subsequences to the number of subsequnces of s; now each subsequence is counted once, except for the subsequences that end in c but were already present in s before; these are counted twice. Thus, the total number of subsequences in the new string is twice the total number of subsequences in the old string minus the number of subsequences in the old string which end in c.This leads us to the following solution: for each symbol c store how many subsequences end in c, denote cntc. Append symbol c; now cntc becomes equal to the sum of all cnt's plus one (for the empty subsequence), and all the other cnt's do not change.For example, consider the first few symbols of the Thue-Morse sequence: ε — (0, 0) 0 — ( 0 + 0 + 1 = 1, 0) 01 — (1, 1 + 0 + 1 = 2) 011 — (1, 1 + 2 + 1 = 4) 0110 — ( 1 + 4 + 1 = 6, 4) ... Let us put the values of cnt in the coordinates of a vector, and also append a coordinate which is always equal to 1. It is now clear that appending a symbol to the string alters the vector as a multiplication by some matrix. Let us assign a matrix for each symbol, and also for each string as a product of matrices for the symbols of the strings in that order.Now, consider the prefix of the sequence ai of length km. Divide it into k parts of length km - 1; x-th (0-based) of these parts can be obtained from the 0-th one by adding x modulo k to all elements of the part. Let us count the matrices (see above) for the prefixes of length km, and also for all strings that are obtained by adding x to all of the prefixes' elements; denote such matrix Am, x.It is easy to see that if m > 0, then . This formula allows us to count Am, x for all and all x from 0 to k - 1 in time. Now, upon having all Am, x we can multiply some of them in the right order to obtain the matrix for the prefix of the sequence ai of length n.Unfortunately, this is not quite enough as the solution doesn't fit the time limit yet. Here is one way to speed up sufficiently: note that the product in the formula can be divided as shown: Am - 1, x... Am - 1, k - 1 × Am - 1, 0... Am - 1, x - 1 (if x = 0, take the second part to be empty). Count all the \"prefixes\" and \"suffixes\" products of the set Am, x: Pm, x = Am, 0... Am, x - 1, Sm, x = Am, x... Am, k - 1. Now Am, x = Sm - 1, xPm - 1, x. Thus, the computation of Am, x for all x and a given m can be done as computing all Pm - 1, x, Sm - 1, x using O(k) matrix multiplications, and each Am, x is now can be found using one matrix multiplication. Finally, the solution now works in time, which fits the limits by a margin.Challenge: solve the problem for k ≤ 100.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/15208",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 496\\s*B"
          },
          "content_length": 12568
        },
        {
          "title": "Codeforces Round #283: editorial (with bonuses!) - Codeforces",
          "content": "Each problem comes with a challenge — a bonus task somehow related to the problem; you may tackle at the challenges for fun and practice, also feel free to discuss them at the comments. =)496A - Minimum DifficultyFor every option of removing an element we run through the remaining elements and find the maximal difference between adjacent ones; print the smallest found answer. The solution has complexity O(n2). It can be noticed that after removing an element the difficulty either stays the same or becomes equal to the difference between the neighbours of the removed element (whatever is larger); thus, the difficulty for every option of removing an element can be found in O(1), for the total complexity of O(n). Any of these solutions (or even less efficient ones) could pass the tests.Challenge: suppose we now have to remove exactly k arbitrary elements (but the first and the last elements have to stay in their places). How small the maximal difference between adjacent elements can become? Solve this problem assuming the limitations are as follows: 1 ≤ k ≤ n - 2, n ≤ 105, ai ≤ 109.496B - Secret CombinationWe observe that the order of operations is not important: we may first perform all the shifts, and after that all the additions. Note that after n shifts the sequence returns to its original state, therefore it is sufficient to consider only the options with less than n shifts. Also, after 10 times of adding 1 to all digits the sequence does not change; we may consider only options with less than 10 additions. Thus, there are overall 10n reasonable options for performing the operations; for every option perform the operations and find the smallest answer among all the options. As performing the operations for every option and comparing two answers to choose the best takes O(n) operations, this solution performs about 10n2 elementary operations. The multiple of 10 can be get rid of, if we note that after all shifts are made the best choice is to make the first digit equal to zero, and this leaves us but a single option for the number of additions. However, implementing this optimization is not necessary to get accepted.Challenge: can you solve the problem in time? in O(n) time?496C - Removing Columns/497A - Removing ColumnsLet's look at the first column of the table. If its letters are not sorted alphabetically, then in any valid choice of removing some columns it has to be removed. However, if its letters are sorted, then for every valid choice that has this column removed it can be restored back to the table; it is clear that the new choice is valid (that is, the rows of the new table are sorted lexicographically) and the answer (that is, the number of removed columns) has just became smaller.Consider all columns from left to right. We have already chosen which columns to remove among all the columns to the left of the current one; if leaving the current column in place breaks the lexicographical order of rows, then we have to remove it; otherwise, we may leave it in place to no harm. Arguing in the way of the previous paragraph we can prove that this greedy method yields an optimal (moreover, the only optimal) solution. The complexity is O(n2).Challenge: compute how many (say, modulo 109 + 7) n × m tables are there for which the answer for this problem is k? The more efficient solution you come up with, the better.496D - Tennis Game/497B - Tennis GameChoose some t; now emulate how the match will go, ensure that the record is valid for this t and by the way find the corresponding value of s. Print all valid options for s and t. This solution works in O(n2) time, which is not good enough, but we will try to optimize it.Suppose the current set if finished and we have processed k serves by now. Let us process the next set as follows: find t-th 1 and t-th 2 after position k. If t-th 1 occurs earlier, then the first player wins the set, and the set concludes right after the t-th 1; the other case is handled symmetrically. If the match is not over yet, and in the rest of the record there are no t ones nor t twos, then the record is clearly invalid. This way, every single set in the record can be processed in time using binary search, or O(1) time using precomputed arrays of positions for each player.Now observe that for any t a match of n serves can not contain more than n / t sets, as each set contains at least t serves. If we sum up the upper limits for the number of sets for each t, we obtain the total upper limit for the number of sets we may need to process: (which is the famous harmonic sum). Using one of the approaches discussed above, one obtains a solution with complexity of or ; each of these solutions fits the limit nicely.Obviously, for every t there is no more than one valid choice for s; however, maybe a bit unexpected, for a given s there may exist more than one valid choice of t. The first test where this takes place is pretest 12. The statement requires that the pairs are printed lexicographically ordered; it is possible to make a mistake here and print the pairs with equal s by descending t (if we fill the array by increasing t and then simply reverse the array).Challenge: while preparing this problem I discovered that it's quite hard to find a test such that the number of pairs in the answer is large; in the actual tests the maximal number is 128, which is the number of divisors of the number 83160. Can you beat this record? If you have a test with n ≤ 105 that has larger number of pairs in the answer, feel free to brag in the comments; also don't hesitate to share any insights on how one could bound the maximal number analytically.496E - Distributing Parts /497C - Distributing Parts Sort all the parts and actors altogether by increasing lower bounds (if equal, actors precede parts); process all the enitities in this order. We maintain a set of actors which have already occured in the order; if we meet an entry for an actor, add it to the set. If we currently process a part, we have to assign it to an actor; from the current set of actors we have to choose one such that his di ≥ bj (the ci ≤ aj constraint is provided by the fact that the i-th actor has occured earlier than the j-th part); if there are no such actors in the set, no answer can be obtained; if there are several actors satisftying this requirement, we should choose one with minimal di (intuitively, he will be less useful in the future). Assign the chosen actor with the current part and decrement his ki; if ki is now zero, the actor can not be used anymore, thus we remove him from the set.To fit the limits we should implement the set of current actors as some efficient data structure (e.g., an std::set or a treap). The resulting complexity is .Challenge: suppose that now there are qj copies of the j-th part (1 ≤ qj ≤ 109), and each copy must be separately assigned with an actor in a valid way. Can you solve this new problem with all the old constraints (as the actual distribution now has too much entries, it is sufficient to check whether an answer exists)?497D - GearsWhen a collision happens, a vertex of one polygon lands on a side of the other polygon. Consider a reference system such that the polygon A is not moving. In this system the polygon B preserves its orientation (that is, does not rotate), and each of its vertices moves on some circle. Intersect all the circles for vertices of B with all the sides of A; if any of them intersect, then some vertex of B collides with a side of A. Symmetrically, take a reference system associated with B and check whether some vertex of A collides with a side of B. The constraints for the points' coordinates are small enough for a solution with absolute precision to be possible (using built-in integer types).Another approach (which is, in fact, basically the same) is such: suppose there is a collision in a reference system associated with A. Then the following equality for vectors holds: x + y = z; here z is a vector that starts at P and ends somewhere on the bound of A, x is a vector that starts at Q and ends somewhere on the bound of B, y is a vector that starts at P and ends somewhere on the circle centered at P that passes through Q. Rewrite the equality as y = z - x; now observe that the set of all possible values of z - x forms the Minkowski sum of A and reflection of B (up to some shift), and the set of all possible values of y is a circle with known parameters. The Minkowski sum can be represented as a union of nm parallelograms, each of which is the Minkowski sum of a pair of sides of different polygons; finally, intersect all parallelograms with the circle.Both solutions have complexity O(nm). As noted above, it is possible to solve the problem using integer arithemetics (that is, with absolute precision); however, the fact that the points' coordinates are small lets most of the solutions with floating point arithmetics pass. It was tempting to write an approximate numerical solution; we struggled hard not to let such solutions pass, and eventually none of them did. =)Many participants had troubles with pretest 8. It looks as follows (the left spiral revolves around the left point, and the right spiral revolves around the right point):Challenge: suppose we want a solution that uses floating point arithmetics to fail. In order to do that, we want to construct a test such that the polygons don't collide but pass really close to each other. How small a (positive) distance we can achieve, given the same constraints for the number of points and the points' coordinates?497E - Subsequences ReturnConsider some string; how does one count the number of its distinct subsequences? Let us append symbols to the string consequently and each time count the number of subsequences that were not present before. Let's append a symbol c to a string s; in the string s + c there are as many subsequences that end in c as there were subsequences in s overall. Add all these subsequences to the number of subsequnces of s; now each subsequence is counted once, except for the subsequences that end in c but were already present in s before; these are counted twice. Thus, the total number of subsequences in the new string is twice the total number of subsequences in the old string minus the number of subsequences in the old string which end in c.This leads us to the following solution: for each symbol c store how many subsequences end in c, denote cntc. Append symbol c; now cntc becomes equal to the sum of all cnt's plus one (for the empty subsequence), and all the other cnt's do not change.For example, consider the first few symbols of the Thue-Morse sequence: ε — (0, 0) 0 — ( 0 + 0 + 1 = 1, 0) 01 — (1, 1 + 0 + 1 = 2) 011 — (1, 1 + 2 + 1 = 4) 0110 — ( 1 + 4 + 1 = 6, 4) ... Let us put the values of cnt in the coordinates of a vector, and also append a coordinate which is always equal to 1. It is now clear that appending a symbol to the string alters the vector as a multiplication by some matrix. Let us assign a matrix for each symbol, and also for each string as a product of matrices for the symbols of the strings in that order.Now, consider the prefix of the sequence ai of length km. Divide it into k parts of length km - 1; x-th (0-based) of these parts can be obtained from the 0-th one by adding x modulo k to all elements of the part. Let us count the matrices (see above) for the prefixes of length km, and also for all strings that are obtained by adding x to all of the prefixes' elements; denote such matrix Am, x.It is easy to see that if m > 0, then . This formula allows us to count Am, x for all and all x from 0 to k - 1 in time. Now, upon having all Am, x we can multiply some of them in the right order to obtain the matrix for the prefix of the sequence ai of length n.Unfortunately, this is not quite enough as the solution doesn't fit the time limit yet. Here is one way to speed up sufficiently: note that the product in the formula can be divided as shown: Am - 1, x... Am - 1, k - 1 × Am - 1, 0... Am - 1, x - 1 (if x = 0, take the second part to be empty). Count all the \"prefixes\" and \"suffixes\" products of the set Am, x: Pm, x = Am, 0... Am, x - 1, Sm, x = Am, x... Am, k - 1. Now Am, x = Sm - 1, xPm - 1, x. Thus, the computation of Am, x for all x and a given m can be done as computing all Pm - 1, x, Sm - 1, x using O(k) matrix multiplications, and each Am, x is now can be found using one matrix multiplication. Finally, the solution now works in time, which fits the limits by a margin.Challenge: solve the problem for k ≤ 100.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/15208",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 496\\s*B"
          },
          "content_length": 12568
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #283 - Codeforces - Code 1",
          "code": "18\n2 2   2 2   2 2   1 2 1   1 2 1   1 2 1   1 2 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15197",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #283 - Codeforces - Code 2",
          "code": "18\n2 2   2 2   2 2   1 2 1   1 2 1   1 2 1   1 2 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15197",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #283 - Codeforces - Code 3",
          "code": "ans[ac]=i;\n       ac++;\n    }\n}\nreturn ac;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15197",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #283 - Codeforces - Code 4",
          "code": "ans[ac]=i;\n       ac++;\n    }\n}\nreturn ac;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15197",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #283 - Codeforces - Code 5",
          "code": "cin>>n;\nfor (int i=0;i<n;i++) cin>>a[i];\nfor (int i=0;i<n;i++) {\n    if (a[i]==1) x++; else y++;\n    f[i]=max(x,y);\n}\nint z=fact(f[n-1]);\nif (x==y) {\n    cout<<\"0\";\n} else {\n    cout<<ac<<endl;\n    for (int i=0;i<ac;i++) {\n       cout<<ans[i]<<\" \"<<f[n-1]/ans[i]<<endl;\n    }\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15197",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #283 - Codeforces - Code 6",
          "code": "cin>>n;\nfor (int i=0;i<n;i++) cin>>a[i];\nfor (int i=0;i<n;i++) {\n    if (a[i]==1) x++; else y++;\n    f[i]=max(x,y);\n}\nint z=fact(f[n-1]);\nif (x==y) {\n    cout<<\"0\";\n} else {\n    cout<<ac<<endl;\n    for (int i=0;i<ac;i++) {\n       cout<<ans[i]<<\" \"<<f[n-1]/ans[i]<<endl;\n    }\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15197",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #283 - Codeforces - Code 7",
          "code": "ae ae et oe",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15197",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #283 - Codeforces - Code 8",
          "code": "20\n1 1 2 2 2 2 2 2 2 2 2 2 1 2 2 1 2 2 2 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15197",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #283 - Codeforces - Code 9",
          "code": "20\n1 1 2 2 2 2 2 2 2 2 2 2 1 2 2 1 2 2 2 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15197",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #283: editorial (with bonuses!) - Codeforces - Code 1",
          "code": "496D - Tennis Game",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15208",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #283: editorial (with bonuses!) - Codeforces - Code 2",
          "code": "number of valid (s,t) will be 0 if the total number of points of player who won  the last point is less than or equal to another player",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15208",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #283: editorial (with bonuses!) - Codeforces - Code 3",
          "code": "strictly more",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15208",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #283: editorial (with bonuses!) - Codeforces - Code 4",
          "code": "The Minkowski sum can be represented as a union of nm parallelograms, each of which is the Minkowski sum of a pair of sides of different polygons;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15208",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #283: editorial (with bonuses!) - Codeforces - Code 5",
          "code": "circle_segment",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15208",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #283: editorial (with bonuses!) - Codeforces - Code 6",
          "code": "ll dmax = (max((a - c) | (a - c), (a - b) | (a - b))); -> ll dmax = (max((a - c) | (a - c), (b - c) | (b - c)));",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15208",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #283: editorial (with bonuses!) - Codeforces - Code 7",
          "code": "ll dmax = (max((a - c) | (a - c), (a - b) | (a - b))); -> ll dmax = (max((a - c) | (a - c), (b - c) | (b - c)));",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15208",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #283: editorial (with bonuses!) - Codeforces - Code 1",
          "code": "496D - Tennis Game",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15208",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #283: editorial (with bonuses!) - Codeforces - Code 2",
          "code": "number of valid (s,t) will be 0 if the total number of points of player who won  the last point is less than or equal to another player",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15208",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #283: editorial (with bonuses!) - Codeforces - Code 3",
          "code": "strictly more",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15208",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #283: editorial (with bonuses!) - Codeforces - Code 4",
          "code": "The Minkowski sum can be represented as a union of nm parallelograms, each of which is the Minkowski sum of a pair of sides of different polygons;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15208",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #283: editorial (with bonuses!) - Codeforces - Code 5",
          "code": "circle_segment",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15208",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #283: editorial (with bonuses!) - Codeforces - Code 6",
          "code": "ll dmax = (max((a - c) | (a - c), (a - b) | (a - b))); -> ll dmax = (max((a - c) | (a - c), (b - c) | (b - c)));",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15208",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #283: editorial (with bonuses!) - Codeforces - Code 7",
          "code": "ll dmax = (max((a - c) | (a - c), (a - b) | (a - b))); -> ll dmax = (max((a - c) | (a - c), (b - c) | (b - c)));",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15208",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 1000, \"n\");\n    inf.readEoln();\n    string s = inf.readToken(\"[0-9]+\", \"digits\");\n    ensuref(int(s.length()) == n, \"Expected %d digits, but found %d digits\", n, int(s.length()));\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 1000, \"n\");\n    inf.readEoln();\n    string s = inf.readToken(\"[0-9]+\", \"digits\");\n    ensuref(int(s.length()) == n, \"Expected %d digits, but found %d digits\", n, int(s.length()));\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 1000, \"n\");\n    inf.readEoln();\n    string s = inf.readToken(\"[0-9]+\", \"digits\");\n    ensuref(int(s.length()) == n, \"Expected %d digits, but found %d digits\", n, int(s.length()));\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n#include <string>\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare files as sequence of lines\");\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    std::string strAnswer;\r\n\r\n    int n = 0;\r\n    while (!ans.eof()) {\r\n        std::string j = ans.readString();\r\n\r\n        if (j.empty() && ans.eof())\r\n            break;\r\n\r\n        strAnswer = j;\r\n        std::string p = ouf.readString();\r\n\r\n        n++;\r\n\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s lines differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  compress(j).c_str(), compress(p).c_str());\r\n    }\r\n\r\n    if (n == 1)\r\n        quitf(_ok, \"single line: '%s'\", compress(strAnswer).c_str());\r\n\r\n    quitf(_ok, \"%d lines\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n    vector<int> digits(n);\n\n    if (type == \"small_n\") {\n        if (n > 10) n = 10;\n        for (int i = 0; i < n; ++i)\n            digits[i] = rnd.next(0, 9);\n    } else if (type == \"large_n\") {\n        if (n < 1000) n = 1000;\n        for (int i = 0; i < n; ++i)\n            digits[i] = rnd.next(0, 9);\n    } else if (type == \"all_same\") {\n        int digit = rnd.next(0, 9);\n        fill(digits.begin(), digits.end(), digit);\n    } else if (type == \"all_nines\") {\n        fill(digits.begin(), digits.end(), 9);\n    } else if (type == \"random\") {\n        for (int i = 0; i < n; ++i)\n            digits[i] = rnd.next(0,9);\n    } else if (type == \"ascending\") {\n        for (int i = 0; i < n; ++i)\n            digits[i] = i % 10;\n    } else if (type == \"descending\") {\n        for (int i = 0; i < n; ++i)\n            digits[i] = (9 - (i % 10));\n    } else if (type == \"leading_zeros\") {\n        int num_zeros = rnd.next(1, min(n, 100)); // Limit to avoid all zeros\n        fill(digits.begin(), digits.begin() + num_zeros, 0);\n        for (int i = num_zeros; i < n; ++i)\n            digits[i] = rnd.next(1,9);\n    } else if (type == \"minimal\") {\n        // Initial digits are already the minimal possible\n        for (int i = 0; i < n; ++i)\n            digits[i] = rnd.next(0,9);\n        // Find the minimal number obtainable\n        string s;\n        for (int d : digits) s += '0' + d;\n        vector<string> candidate_numbers;\n        // Try rotations\n        for (int shift = 0; shift < n; ++shift) {\n            string t = s.substr(shift) + s.substr(0, shift);\n            candidate_numbers.push_back(t);\n        }\n        // Try additions\n        string minimal = s;\n        for (int add = 0; add < 10; ++add) {\n            for (string t : candidate_numbers) {\n                string u = t;\n                for (char &c : u) {\n                    c = '0' + (c - '0' + add) % 10;\n                }\n\n                string u_trimmed = u;\n                u_trimmed.erase(0, u_trimmed.find_first_not_of('0'));\n                if (u_trimmed.empty()) u_trimmed = \"0\";\n\n                string minimal_trimmed = minimal;\n                minimal_trimmed.erase(0, minimal_trimmed.find_first_not_of('0'));\n                if (minimal_trimmed.empty()) minimal_trimmed = \"0\";\n\n                if (u_trimmed < minimal_trimmed)\n                    minimal = u;\n            }\n        }\n        // Set the initial digits to the minimal\n        for (int i = 0; i < n; ++i)\n            digits[i] = minimal[i] - '0';\n    } else if (type == \"maximal\") {\n        // Generate digits that are the furthest from minimal\n        for (int i = 0; i < n; ++i)\n            digits[i] = rnd.next(0,9);\n    } else if (type == \"special\") {\n        if (n == 1)\n            digits[0] = 9;\n        else {\n            fill(digits.begin(), digits.end(), 0);\n            digits[n-1] = 1;\n        }\n    }\n\n    cout << n << endl;\n    for (int d : digits) cout << d;\n    cout << endl;\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n    vector<int> digits(n);\n\n    if (type == \"small_n\") {\n        if (n > 10) n = 10;\n        for (int i = 0; i < n; ++i)\n            digits[i] = rnd.next(0, 9);\n    } else if (type == \"large_n\") {\n        if (n < 1000) n = 1000;\n        for (int i = 0; i < n; ++i)\n            digits[i] = rnd.next(0, 9);\n    } else if (type == \"all_same\") {\n        int digit = rnd.next(0, 9);\n        fill(digits.begin(), digits.end(), digit);\n    } else if (type == \"all_nines\") {\n        fill(digits.begin(), digits.end(), 9);\n    } else if (type == \"random\") {\n        for (int i = 0; i < n; ++i)\n            digits[i] = rnd.next(0,9);\n    } else if (type == \"ascending\") {\n        for (int i = 0; i < n; ++i)\n            digits[i] = i % 10;\n    } else if (type == \"descending\") {\n        for (int i = 0; i < n; ++i)\n            digits[i] = (9 - (i % 10));\n    } else if (type == \"leading_zeros\") {\n        int num_zeros = rnd.next(1, min(n, 100)); // Limit to avoid all zeros\n        fill(digits.begin(), digits.begin() + num_zeros, 0);\n        for (int i = num_zeros; i < n; ++i)\n            digits[i] = rnd.next(1,9);\n    } else if (type == \"minimal\") {\n        // Initial digits are already the minimal possible\n        for (int i = 0; i < n; ++i)\n            digits[i] = rnd.next(0,9);\n        // Find the minimal number obtainable\n        string s;\n        for (int d : digits) s += '0' + d;\n        vector<string> candidate_numbers;\n        // Try rotations\n        for (int shift = 0; shift < n; ++shift) {\n            string t = s.substr(shift) + s.substr(0, shift);\n            candidate_numbers.push_back(t);\n        }\n        // Try additions\n        string minimal = s;\n        for (int add = 0; add < 10; ++add) {\n            for (string t : candidate_numbers) {\n                string u = t;\n                for (char &c : u) {\n                    c = '0' + (c - '0' + add) % 10;\n                }\n\n                string u_trimmed = u;\n                u_trimmed.erase(0, u_trimmed.find_first_not_of('0'));\n                if (u_trimmed.empty()) u_trimmed = \"0\";\n\n                string minimal_trimmed = minimal;\n                minimal_trimmed.erase(0, minimal_trimmed.find_first_not_of('0'));\n                if (minimal_trimmed.empty()) minimal_trimmed = \"0\";\n\n                if (u_trimmed < minimal_trimmed)\n                    minimal = u;\n            }\n        }\n        // Set the initial digits to the minimal\n        for (int i = 0; i < n; ++i)\n            digits[i] = minimal[i] - '0';\n    } else if (type == \"maximal\") {\n        // Generate digits that are the furthest from minimal\n        for (int i = 0; i < n; ++i)\n            digits[i] = rnd.next(0,9);\n    } else if (type == \"special\") {\n        if (n == 1)\n            digits[0] = 9;\n        else {\n            fill(digits.begin(), digits.end(), 0);\n            digits[n-1] = 1;\n        }\n    }\n\n    cout << n << endl;\n    for (int d : digits) cout << d;\n    cout << endl;\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -type small_n\n./gen -n 2 -type small_n\n./gen -n 10 -type small_n\n\n./gen -n 1000 -type large_n\n\n./gen -n 5 -type all_same\n./gen -n 500 -type all_same\n./gen -n 1000 -type all_same\n\n./gen -n 5 -type all_nines\n./gen -n 1000 -type all_nines\n\n./gen -n 10 -type random\n./gen -n 100 -type random\n./gen -n 1000 -type random\n\n./gen -n 10 -type ascending\n./gen -n 100 -type ascending\n./gen -n 1000 -type ascending\n\n./gen -n 10 -type descending\n./gen -n 100 -type descending\n./gen -n 1000 -type descending\n\n./gen -n 5 -type leading_zeros\n./gen -n 50 -type leading_zeros\n./gen -n 1000 -type leading_zeros\n\n./gen -n 5 -type minimal\n./gen -n 100 -type minimal\n\n./gen -n 5 -type maximal\n./gen -n 100 -type maximal\n\n./gen -n 1 -type special\n./gen -n 1000 -type special\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:39:02.975530",
        "total_tutorials": 3,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "496/C",
      "title": "C. Removing Columns",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains two integers  — n and m (1 ≤ n, m ≤ 100).Next n lines contain m small English letters each — the characters of the table.",
      "output_spec": "OutputPrint a single number — the minimum number of columns that you need to remove in order to make the table good.",
      "sample_tests": "ExamplesInputCopy1 10codeforcesOutputCopy0InputCopy4 4casecaretestcodeOutputCopy2InputCopy5 4codeforcescodeforcesOutputCopy4",
      "description": "C. Removing Columns\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains two integers  — n and m (1 ≤ n, m ≤ 100).Next n lines contain m small English letters each — the characters of the table.\n\nOutputPrint a single number — the minimum number of columns that you need to remove in order to make the table good.\n\nInputCopy1 10codeforcesOutputCopy0InputCopy4 4casecaretestcodeOutputCopy2InputCopy5 4codeforcescodeforcesOutputCopy4\n\nInputCopy1 10codeforces\n\nOutputCopy0\n\nInputCopy4 4casecaretestcode\n\nOutputCopy2\n\nInputCopy5 4codeforcescodeforces\n\nOutputCopy4\n\nNoteIn the first sample the table is already good.In the second sample you may remove the first and third column.In the third sample you have to remove all the columns (note that the table where all rows are empty is considered good by definition).Let strings s and t have equal length. Then, s is lexicographically larger than t if they are not equal and the character following the largest common prefix of s and t (the prefix may be empty) in s is alphabetically larger than the corresponding character of t.",
      "solutions": [
        {
          "title": "Codeforces Round #283 - Codeforces",
          "content": "Hi, Codeforces.Today, on December 17 at 19:30 MSK regular, 283-rd Codeforces round will take place. Problems are authored by me, Mikhail Tikhomirov. Maxim Akhmedov (Zlobober) helped me with discussing and preparing the problemset, Maria Belova (Delinur) translated problem statements in English, and Georgy Chebanov (gchebanov), Alexander Mashrabov (map) and Niyaz Nigmatullin (niyaznigmatul) tested the round and helped us with finding bugs and mistakes; let's give them a round of applause!The round will be for both divisions. The scoring is standard (not dynamic); score distribution is as follows:Div. 1: 750-1250-1250-2000-2500Div. 2: 500-1000-1750-2250-2250This is going to be my fourth round at Codeforces. I really hope it will go as good as three before it. =) Wish you all the best of luck!UPD: the round is over, thanks for participating!Grats to the winners:Div. 1: SirShokoladina Petr rowdark anta Marcin_smu Merkurev qwer1561 Ra16bit kuviman Um_nik Div. 2: SergeyMelnikov sepehr103 StarCuriosity dotato husheyn Editorial is here ( UPD: now in English!).",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/15197",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1068
        },
        {
          "title": "Codeforces Round #283: editorial (with bonuses!) - Codeforces",
          "content": "Each problem comes with a challenge — a bonus task somehow related to the problem; you may tackle at the challenges for fun and practice, also feel free to discuss them at the comments. =)496A - Minimum DifficultyFor every option of removing an element we run through the remaining elements and find the maximal difference between adjacent ones; print the smallest found answer. The solution has complexity O(n2). It can be noticed that after removing an element the difficulty either stays the same or becomes equal to the difference between the neighbours of the removed element (whatever is larger); thus, the difficulty for every option of removing an element can be found in O(1), for the total complexity of O(n). Any of these solutions (or even less efficient ones) could pass the tests.Challenge: suppose we now have to remove exactly k arbitrary elements (but the first and the last elements have to stay in their places). How small the maximal difference between adjacent elements can become? Solve this problem assuming the limitations are as follows: 1 ≤ k ≤ n - 2, n ≤ 105, ai ≤ 109.496B - Secret CombinationWe observe that the order of operations is not important: we may first perform all the shifts, and after that all the additions. Note that after n shifts the sequence returns to its original state, therefore it is sufficient to consider only the options with less than n shifts. Also, after 10 times of adding 1 to all digits the sequence does not change; we may consider only options with less than 10 additions. Thus, there are overall 10n reasonable options for performing the operations; for every option perform the operations and find the smallest answer among all the options. As performing the operations for every option and comparing two answers to choose the best takes O(n) operations, this solution performs about 10n2 elementary operations. The multiple of 10 can be get rid of, if we note that after all shifts are made the best choice is to make the first digit equal to zero, and this leaves us but a single option for the number of additions. However, implementing this optimization is not necessary to get accepted.Challenge: can you solve the problem in time? in O(n) time?496C - Removing Columns/497A - Removing ColumnsLet's look at the first column of the table. If its letters are not sorted alphabetically, then in any valid choice of removing some columns it has to be removed. However, if its letters are sorted, then for every valid choice that has this column removed it can be restored back to the table; it is clear that the new choice is valid (that is, the rows of the new table are sorted lexicographically) and the answer (that is, the number of removed columns) has just became smaller.Consider all columns from left to right. We have already chosen which columns to remove among all the columns to the left of the current one; if leaving the current column in place breaks the lexicographical order of rows, then we have to remove it; otherwise, we may leave it in place to no harm. Arguing in the way of the previous paragraph we can prove that this greedy method yields an optimal (moreover, the only optimal) solution. The complexity is O(n2).Challenge: compute how many (say, modulo 109 + 7) n × m tables are there for which the answer for this problem is k? The more efficient solution you come up with, the better.496D - Tennis Game/497B - Tennis GameChoose some t; now emulate how the match will go, ensure that the record is valid for this t and by the way find the corresponding value of s. Print all valid options for s and t. This solution works in O(n2) time, which is not good enough, but we will try to optimize it.Suppose the current set if finished and we have processed k serves by now. Let us process the next set as follows: find t-th 1 and t-th 2 after position k. If t-th 1 occurs earlier, then the first player wins the set, and the set concludes right after the t-th 1; the other case is handled symmetrically. If the match is not over yet, and in the rest of the record there are no t ones nor t twos, then the record is clearly invalid. This way, every single set in the record can be processed in time using binary search, or O(1) time using precomputed arrays of positions for each player.Now observe that for any t a match of n serves can not contain more than n / t sets, as each set contains at least t serves. If we sum up the upper limits for the number of sets for each t, we obtain the total upper limit for the number of sets we may need to process: (which is the famous harmonic sum). Using one of the approaches discussed above, one obtains a solution with complexity of or ; each of these solutions fits the limit nicely.Obviously, for every t there is no more than one valid choice for s; however, maybe a bit unexpected, for a given s there may exist more than one valid choice of t. The first test where this takes place is pretest 12. The statement requires that the pairs are printed lexicographically ordered; it is possible to make a mistake here and print the pairs with equal s by descending t (if we fill the array by increasing t and then simply reverse the array).Challenge: while preparing this problem I discovered that it's quite hard to find a test such that the number of pairs in the answer is large; in the actual tests the maximal number is 128, which is the number of divisors of the number 83160. Can you beat this record? If you have a test with n ≤ 105 that has larger number of pairs in the answer, feel free to brag in the comments; also don't hesitate to share any insights on how one could bound the maximal number analytically.496E - Distributing Parts /497C - Distributing Parts Sort all the parts and actors altogether by increasing lower bounds (if equal, actors precede parts); process all the enitities in this order. We maintain a set of actors which have already occured in the order; if we meet an entry for an actor, add it to the set. If we currently process a part, we have to assign it to an actor; from the current set of actors we have to choose one such that his di ≥ bj (the ci ≤ aj constraint is provided by the fact that the i-th actor has occured earlier than the j-th part); if there are no such actors in the set, no answer can be obtained; if there are several actors satisftying this requirement, we should choose one with minimal di (intuitively, he will be less useful in the future). Assign the chosen actor with the current part and decrement his ki; if ki is now zero, the actor can not be used anymore, thus we remove him from the set.To fit the limits we should implement the set of current actors as some efficient data structure (e.g., an std::set or a treap). The resulting complexity is .Challenge: suppose that now there are qj copies of the j-th part (1 ≤ qj ≤ 109), and each copy must be separately assigned with an actor in a valid way. Can you solve this new problem with all the old constraints (as the actual distribution now has too much entries, it is sufficient to check whether an answer exists)?497D - GearsWhen a collision happens, a vertex of one polygon lands on a side of the other polygon. Consider a reference system such that the polygon A is not moving. In this system the polygon B preserves its orientation (that is, does not rotate), and each of its vertices moves on some circle. Intersect all the circles for vertices of B with all the sides of A; if any of them intersect, then some vertex of B collides with a side of A. Symmetrically, take a reference system associated with B and check whether some vertex of A collides with a side of B. The constraints for the points' coordinates are small enough for a solution with absolute precision to be possible (using built-in integer types).Another approach (which is, in fact, basically the same) is such: suppose there is a collision in a reference system associated with A. Then the following equality for vectors holds: x + y = z; here z is a vector that starts at P and ends somewhere on the bound of A, x is a vector that starts at Q and ends somewhere on the bound of B, y is a vector that starts at P and ends somewhere on the circle centered at P that passes through Q. Rewrite the equality as y = z - x; now observe that the set of all possible values of z - x forms the Minkowski sum of A and reflection of B (up to some shift), and the set of all possible values of y is a circle with known parameters. The Minkowski sum can be represented as a union of nm parallelograms, each of which is the Minkowski sum of a pair of sides of different polygons; finally, intersect all parallelograms with the circle.Both solutions have complexity O(nm). As noted above, it is possible to solve the problem using integer arithemetics (that is, with absolute precision); however, the fact that the points' coordinates are small lets most of the solutions with floating point arithmetics pass. It was tempting to write an approximate numerical solution; we struggled hard not to let such solutions pass, and eventually none of them did. =)Many participants had troubles with pretest 8. It looks as follows (the left spiral revolves around the left point, and the right spiral revolves around the right point):Challenge: suppose we want a solution that uses floating point arithmetics to fail. In order to do that, we want to construct a test such that the polygons don't collide but pass really close to each other. How small a (positive) distance we can achieve, given the same constraints for the number of points and the points' coordinates?497E - Subsequences ReturnConsider some string; how does one count the number of its distinct subsequences? Let us append symbols to the string consequently and each time count the number of subsequences that were not present before. Let's append a symbol c to a string s; in the string s + c there are as many subsequences that end in c as there were subsequences in s overall. Add all these subsequences to the number of subsequnces of s; now each subsequence is counted once, except for the subsequences that end in c but were already present in s before; these are counted twice. Thus, the total number of subsequences in the new string is twice the total number of subsequences in the old string minus the number of subsequences in the old string which end in c.This leads us to the following solution: for each symbol c store how many subsequences end in c, denote cntc. Append symbol c; now cntc becomes equal to the sum of all cnt's plus one (for the empty subsequence), and all the other cnt's do not change.For example, consider the first few symbols of the Thue-Morse sequence: ε — (0, 0) 0 — ( 0 + 0 + 1 = 1, 0) 01 — (1, 1 + 0 + 1 = 2) 011 — (1, 1 + 2 + 1 = 4) 0110 — ( 1 + 4 + 1 = 6, 4) ... Let us put the values of cnt in the coordinates of a vector, and also append a coordinate which is always equal to 1. It is now clear that appending a symbol to the string alters the vector as a multiplication by some matrix. Let us assign a matrix for each symbol, and also for each string as a product of matrices for the symbols of the strings in that order.Now, consider the prefix of the sequence ai of length km. Divide it into k parts of length km - 1; x-th (0-based) of these parts can be obtained from the 0-th one by adding x modulo k to all elements of the part. Let us count the matrices (see above) for the prefixes of length km, and also for all strings that are obtained by adding x to all of the prefixes' elements; denote such matrix Am, x.It is easy to see that if m > 0, then . This formula allows us to count Am, x for all and all x from 0 to k - 1 in time. Now, upon having all Am, x we can multiply some of them in the right order to obtain the matrix for the prefix of the sequence ai of length n.Unfortunately, this is not quite enough as the solution doesn't fit the time limit yet. Here is one way to speed up sufficiently: note that the product in the formula can be divided as shown: Am - 1, x... Am - 1, k - 1 × Am - 1, 0... Am - 1, x - 1 (if x = 0, take the second part to be empty). Count all the \"prefixes\" and \"suffixes\" products of the set Am, x: Pm, x = Am, 0... Am, x - 1, Sm, x = Am, x... Am, k - 1. Now Am, x = Sm - 1, xPm - 1, x. Thus, the computation of Am, x for all x and a given m can be done as computing all Pm - 1, x, Sm - 1, x using O(k) matrix multiplications, and each Am, x is now can be found using one matrix multiplication. Finally, the solution now works in time, which fits the limits by a margin.Challenge: solve the problem for k ≤ 100.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/15208",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 496\\s*C"
          },
          "content_length": 12568
        },
        {
          "title": "Codeforces Round #283: editorial (with bonuses!) - Codeforces",
          "content": "Each problem comes with a challenge — a bonus task somehow related to the problem; you may tackle at the challenges for fun and practice, also feel free to discuss them at the comments. =)496A - Minimum DifficultyFor every option of removing an element we run through the remaining elements and find the maximal difference between adjacent ones; print the smallest found answer. The solution has complexity O(n2). It can be noticed that after removing an element the difficulty either stays the same or becomes equal to the difference between the neighbours of the removed element (whatever is larger); thus, the difficulty for every option of removing an element can be found in O(1), for the total complexity of O(n). Any of these solutions (or even less efficient ones) could pass the tests.Challenge: suppose we now have to remove exactly k arbitrary elements (but the first and the last elements have to stay in their places). How small the maximal difference between adjacent elements can become? Solve this problem assuming the limitations are as follows: 1 ≤ k ≤ n - 2, n ≤ 105, ai ≤ 109.496B - Secret CombinationWe observe that the order of operations is not important: we may first perform all the shifts, and after that all the additions. Note that after n shifts the sequence returns to its original state, therefore it is sufficient to consider only the options with less than n shifts. Also, after 10 times of adding 1 to all digits the sequence does not change; we may consider only options with less than 10 additions. Thus, there are overall 10n reasonable options for performing the operations; for every option perform the operations and find the smallest answer among all the options. As performing the operations for every option and comparing two answers to choose the best takes O(n) operations, this solution performs about 10n2 elementary operations. The multiple of 10 can be get rid of, if we note that after all shifts are made the best choice is to make the first digit equal to zero, and this leaves us but a single option for the number of additions. However, implementing this optimization is not necessary to get accepted.Challenge: can you solve the problem in time? in O(n) time?496C - Removing Columns/497A - Removing ColumnsLet's look at the first column of the table. If its letters are not sorted alphabetically, then in any valid choice of removing some columns it has to be removed. However, if its letters are sorted, then for every valid choice that has this column removed it can be restored back to the table; it is clear that the new choice is valid (that is, the rows of the new table are sorted lexicographically) and the answer (that is, the number of removed columns) has just became smaller.Consider all columns from left to right. We have already chosen which columns to remove among all the columns to the left of the current one; if leaving the current column in place breaks the lexicographical order of rows, then we have to remove it; otherwise, we may leave it in place to no harm. Arguing in the way of the previous paragraph we can prove that this greedy method yields an optimal (moreover, the only optimal) solution. The complexity is O(n2).Challenge: compute how many (say, modulo 109 + 7) n × m tables are there for which the answer for this problem is k? The more efficient solution you come up with, the better.496D - Tennis Game/497B - Tennis GameChoose some t; now emulate how the match will go, ensure that the record is valid for this t and by the way find the corresponding value of s. Print all valid options for s and t. This solution works in O(n2) time, which is not good enough, but we will try to optimize it.Suppose the current set if finished and we have processed k serves by now. Let us process the next set as follows: find t-th 1 and t-th 2 after position k. If t-th 1 occurs earlier, then the first player wins the set, and the set concludes right after the t-th 1; the other case is handled symmetrically. If the match is not over yet, and in the rest of the record there are no t ones nor t twos, then the record is clearly invalid. This way, every single set in the record can be processed in time using binary search, or O(1) time using precomputed arrays of positions for each player.Now observe that for any t a match of n serves can not contain more than n / t sets, as each set contains at least t serves. If we sum up the upper limits for the number of sets for each t, we obtain the total upper limit for the number of sets we may need to process: (which is the famous harmonic sum). Using one of the approaches discussed above, one obtains a solution with complexity of or ; each of these solutions fits the limit nicely.Obviously, for every t there is no more than one valid choice for s; however, maybe a bit unexpected, for a given s there may exist more than one valid choice of t. The first test where this takes place is pretest 12. The statement requires that the pairs are printed lexicographically ordered; it is possible to make a mistake here and print the pairs with equal s by descending t (if we fill the array by increasing t and then simply reverse the array).Challenge: while preparing this problem I discovered that it's quite hard to find a test such that the number of pairs in the answer is large; in the actual tests the maximal number is 128, which is the number of divisors of the number 83160. Can you beat this record? If you have a test with n ≤ 105 that has larger number of pairs in the answer, feel free to brag in the comments; also don't hesitate to share any insights on how one could bound the maximal number analytically.496E - Distributing Parts /497C - Distributing Parts Sort all the parts and actors altogether by increasing lower bounds (if equal, actors precede parts); process all the enitities in this order. We maintain a set of actors which have already occured in the order; if we meet an entry for an actor, add it to the set. If we currently process a part, we have to assign it to an actor; from the current set of actors we have to choose one such that his di ≥ bj (the ci ≤ aj constraint is provided by the fact that the i-th actor has occured earlier than the j-th part); if there are no such actors in the set, no answer can be obtained; if there are several actors satisftying this requirement, we should choose one with minimal di (intuitively, he will be less useful in the future). Assign the chosen actor with the current part and decrement his ki; if ki is now zero, the actor can not be used anymore, thus we remove him from the set.To fit the limits we should implement the set of current actors as some efficient data structure (e.g., an std::set or a treap). The resulting complexity is .Challenge: suppose that now there are qj copies of the j-th part (1 ≤ qj ≤ 109), and each copy must be separately assigned with an actor in a valid way. Can you solve this new problem with all the old constraints (as the actual distribution now has too much entries, it is sufficient to check whether an answer exists)?497D - GearsWhen a collision happens, a vertex of one polygon lands on a side of the other polygon. Consider a reference system such that the polygon A is not moving. In this system the polygon B preserves its orientation (that is, does not rotate), and each of its vertices moves on some circle. Intersect all the circles for vertices of B with all the sides of A; if any of them intersect, then some vertex of B collides with a side of A. Symmetrically, take a reference system associated with B and check whether some vertex of A collides with a side of B. The constraints for the points' coordinates are small enough for a solution with absolute precision to be possible (using built-in integer types).Another approach (which is, in fact, basically the same) is such: suppose there is a collision in a reference system associated with A. Then the following equality for vectors holds: x + y = z; here z is a vector that starts at P and ends somewhere on the bound of A, x is a vector that starts at Q and ends somewhere on the bound of B, y is a vector that starts at P and ends somewhere on the circle centered at P that passes through Q. Rewrite the equality as y = z - x; now observe that the set of all possible values of z - x forms the Minkowski sum of A and reflection of B (up to some shift), and the set of all possible values of y is a circle with known parameters. The Minkowski sum can be represented as a union of nm parallelograms, each of which is the Minkowski sum of a pair of sides of different polygons; finally, intersect all parallelograms with the circle.Both solutions have complexity O(nm). As noted above, it is possible to solve the problem using integer arithemetics (that is, with absolute precision); however, the fact that the points' coordinates are small lets most of the solutions with floating point arithmetics pass. It was tempting to write an approximate numerical solution; we struggled hard not to let such solutions pass, and eventually none of them did. =)Many participants had troubles with pretest 8. It looks as follows (the left spiral revolves around the left point, and the right spiral revolves around the right point):Challenge: suppose we want a solution that uses floating point arithmetics to fail. In order to do that, we want to construct a test such that the polygons don't collide but pass really close to each other. How small a (positive) distance we can achieve, given the same constraints for the number of points and the points' coordinates?497E - Subsequences ReturnConsider some string; how does one count the number of its distinct subsequences? Let us append symbols to the string consequently and each time count the number of subsequences that were not present before. Let's append a symbol c to a string s; in the string s + c there are as many subsequences that end in c as there were subsequences in s overall. Add all these subsequences to the number of subsequnces of s; now each subsequence is counted once, except for the subsequences that end in c but were already present in s before; these are counted twice. Thus, the total number of subsequences in the new string is twice the total number of subsequences in the old string minus the number of subsequences in the old string which end in c.This leads us to the following solution: for each symbol c store how many subsequences end in c, denote cntc. Append symbol c; now cntc becomes equal to the sum of all cnt's plus one (for the empty subsequence), and all the other cnt's do not change.For example, consider the first few symbols of the Thue-Morse sequence: ε — (0, 0) 0 — ( 0 + 0 + 1 = 1, 0) 01 — (1, 1 + 0 + 1 = 2) 011 — (1, 1 + 2 + 1 = 4) 0110 — ( 1 + 4 + 1 = 6, 4) ... Let us put the values of cnt in the coordinates of a vector, and also append a coordinate which is always equal to 1. It is now clear that appending a symbol to the string alters the vector as a multiplication by some matrix. Let us assign a matrix for each symbol, and also for each string as a product of matrices for the symbols of the strings in that order.Now, consider the prefix of the sequence ai of length km. Divide it into k parts of length km - 1; x-th (0-based) of these parts can be obtained from the 0-th one by adding x modulo k to all elements of the part. Let us count the matrices (see above) for the prefixes of length km, and also for all strings that are obtained by adding x to all of the prefixes' elements; denote such matrix Am, x.It is easy to see that if m > 0, then . This formula allows us to count Am, x for all and all x from 0 to k - 1 in time. Now, upon having all Am, x we can multiply some of them in the right order to obtain the matrix for the prefix of the sequence ai of length n.Unfortunately, this is not quite enough as the solution doesn't fit the time limit yet. Here is one way to speed up sufficiently: note that the product in the formula can be divided as shown: Am - 1, x... Am - 1, k - 1 × Am - 1, 0... Am - 1, x - 1 (if x = 0, take the second part to be empty). Count all the \"prefixes\" and \"suffixes\" products of the set Am, x: Pm, x = Am, 0... Am, x - 1, Sm, x = Am, x... Am, k - 1. Now Am, x = Sm - 1, xPm - 1, x. Thus, the computation of Am, x for all x and a given m can be done as computing all Pm - 1, x, Sm - 1, x using O(k) matrix multiplications, and each Am, x is now can be found using one matrix multiplication. Finally, the solution now works in time, which fits the limits by a margin.Challenge: solve the problem for k ≤ 100.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/15208",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 496\\s*C"
          },
          "content_length": 12568
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #283 - Codeforces - Code 1",
          "code": "18\n2 2   2 2   2 2   1 2 1   1 2 1   1 2 1   1 2 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15197",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #283 - Codeforces - Code 2",
          "code": "18\n2 2   2 2   2 2   1 2 1   1 2 1   1 2 1   1 2 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15197",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #283 - Codeforces - Code 3",
          "code": "ans[ac]=i;\n       ac++;\n    }\n}\nreturn ac;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15197",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #283 - Codeforces - Code 4",
          "code": "ans[ac]=i;\n       ac++;\n    }\n}\nreturn ac;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15197",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #283 - Codeforces - Code 5",
          "code": "cin>>n;\nfor (int i=0;i<n;i++) cin>>a[i];\nfor (int i=0;i<n;i++) {\n    if (a[i]==1) x++; else y++;\n    f[i]=max(x,y);\n}\nint z=fact(f[n-1]);\nif (x==y) {\n    cout<<\"0\";\n} else {\n    cout<<ac<<endl;\n    for (int i=0;i<ac;i++) {\n       cout<<ans[i]<<\" \"<<f[n-1]/ans[i]<<endl;\n    }\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15197",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #283 - Codeforces - Code 6",
          "code": "cin>>n;\nfor (int i=0;i<n;i++) cin>>a[i];\nfor (int i=0;i<n;i++) {\n    if (a[i]==1) x++; else y++;\n    f[i]=max(x,y);\n}\nint z=fact(f[n-1]);\nif (x==y) {\n    cout<<\"0\";\n} else {\n    cout<<ac<<endl;\n    for (int i=0;i<ac;i++) {\n       cout<<ans[i]<<\" \"<<f[n-1]/ans[i]<<endl;\n    }\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15197",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #283 - Codeforces - Code 7",
          "code": "ae ae et oe",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15197",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #283 - Codeforces - Code 8",
          "code": "20\n1 1 2 2 2 2 2 2 2 2 2 2 1 2 2 1 2 2 2 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15197",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #283 - Codeforces - Code 9",
          "code": "20\n1 1 2 2 2 2 2 2 2 2 2 2 1 2 2 1 2 2 2 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15197",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #283: editorial (with bonuses!) - Codeforces - Code 1",
          "code": "496D - Tennis Game",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15208",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #283: editorial (with bonuses!) - Codeforces - Code 2",
          "code": "number of valid (s,t) will be 0 if the total number of points of player who won  the last point is less than or equal to another player",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15208",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #283: editorial (with bonuses!) - Codeforces - Code 3",
          "code": "strictly more",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15208",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #283: editorial (with bonuses!) - Codeforces - Code 4",
          "code": "The Minkowski sum can be represented as a union of nm parallelograms, each of which is the Minkowski sum of a pair of sides of different polygons;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15208",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #283: editorial (with bonuses!) - Codeforces - Code 5",
          "code": "circle_segment",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15208",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #283: editorial (with bonuses!) - Codeforces - Code 6",
          "code": "ll dmax = (max((a - c) | (a - c), (a - b) | (a - b))); -> ll dmax = (max((a - c) | (a - c), (b - c) | (b - c)));",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15208",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #283: editorial (with bonuses!) - Codeforces - Code 7",
          "code": "ll dmax = (max((a - c) | (a - c), (a - b) | (a - b))); -> ll dmax = (max((a - c) | (a - c), (b - c) | (b - c)));",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15208",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #283: editorial (with bonuses!) - Codeforces - Code 1",
          "code": "496D - Tennis Game",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15208",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #283: editorial (with bonuses!) - Codeforces - Code 2",
          "code": "number of valid (s,t) will be 0 if the total number of points of player who won  the last point is less than or equal to another player",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15208",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #283: editorial (with bonuses!) - Codeforces - Code 3",
          "code": "strictly more",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15208",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #283: editorial (with bonuses!) - Codeforces - Code 4",
          "code": "The Minkowski sum can be represented as a union of nm parallelograms, each of which is the Minkowski sum of a pair of sides of different polygons;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15208",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #283: editorial (with bonuses!) - Codeforces - Code 5",
          "code": "circle_segment",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15208",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #283: editorial (with bonuses!) - Codeforces - Code 6",
          "code": "ll dmax = (max((a - c) | (a - c), (a - b) | (a - b))); -> ll dmax = (max((a - c) | (a - c), (b - c) | (b - c)));",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15208",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #283: editorial (with bonuses!) - Codeforces - Code 7",
          "code": "ll dmax = (max((a - c) | (a - c), (a - b) | (a - b))); -> ll dmax = (max((a - c) | (a - c), (b - c) | (b - c)));",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15208",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 100, \"m\");\n    inf.readEoln();\n\n    string pattern = \"[a-z]{\" + to_string(m) + \"}\";\n    for (int i = 0; i < n; ++i) {\n        string s = inf.readLine(pattern);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 100, \"m\");\n    inf.readEoln();\n\n    string pattern = \"[a-z]{\" + to_string(m) + \"}\";\n    for (int i = 0; i < n; ++i) {\n        string s = inf.readLine(pattern);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 100, \"m\");\n    inf.readEoln();\n\n    string pattern = \"[a-z]{\" + to_string(m) + \"}\";\n    for (int i = 0; i < n; ++i) {\n        string s = inf.readLine(pattern);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<string> table(n);\n\n    if (type == \"sorted\") {\n        // Generate sorted table\n        string prev(m, 'a');\n        for (int i = 0; i < n; ++i) {\n            string s = prev;\n            for (int j = 0; j < m; ++j) {\n                char c = rnd.next('a', 'z');\n                if (c >= prev[j]) {\n                    s[j] = c;\n                } else {\n                    s[j] = prev[j];\n                }\n            }\n            table[i] = s;\n            prev = s;\n        }\n    } else if (type == \"reversed\") {\n        // Generate reverse sorted table\n        vector<string> temp(n);\n        string prev(m, 'z');\n        for (int i = 0; i < n; ++i) {\n            string s = prev;\n            for (int j = 0; j < m; ++j) {\n                char c = rnd.next('a', 'z');\n                if (c <= prev[j]) {\n                    s[j] = c;\n                } else {\n                    s[j] = prev[j];\n                }\n            }\n            temp[i] = s;\n            prev = s;\n        }\n        // Reverse the table to make it in decreasing order\n        reverse(temp.begin(), temp.end());\n        table = temp;\n    } else if (type == \"identical\") {\n        // Generate n identical strings\n        string s(m, 'a');\n        for (int j = 0; j < m; ++j)\n            s[j] = rnd.next('a', 'z');\n        for (int i = 0; i < n; ++i)\n            table[i] = s;\n    } else if (type == \"need_remove_all\") {\n        // Generate strings such that we need to remove all columns to sort the table\n        vector<string> strings(n);\n        for (int i = 0; i < n; ++i) {\n            string s(m, 'a');\n            for (int j = 0; j < m; ++j) {\n                s[j] = (char)('a' + rnd.next(0, 25));\n            }\n            strings[i] = s;\n        }\n        // Sort in decreasing order to make it the worst case\n        sort(strings.rbegin(), strings.rend());\n        table = strings;\n    } else {\n        // Generate random table\n        for (int i = 0; i < n; ++i) {\n            string s(m, 'a');\n            for (int j = 0; j < m; ++j) {\n                s[j] = rnd.next('a', 'z');\n            }\n            table[i] = s;\n        }\n    }\n\n    printf(\"%d %d\\n\", n, m);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%s\\n\", table[i].c_str());\n    }\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<string> table(n);\n\n    if (type == \"sorted\") {\n        // Generate sorted table\n        string prev(m, 'a');\n        for (int i = 0; i < n; ++i) {\n            string s = prev;\n            for (int j = 0; j < m; ++j) {\n                char c = rnd.next('a', 'z');\n                if (c >= prev[j]) {\n                    s[j] = c;\n                } else {\n                    s[j] = prev[j];\n                }\n            }\n            table[i] = s;\n            prev = s;\n        }\n    } else if (type == \"reversed\") {\n        // Generate reverse sorted table\n        vector<string> temp(n);\n        string prev(m, 'z');\n        for (int i = 0; i < n; ++i) {\n            string s = prev;\n            for (int j = 0; j < m; ++j) {\n                char c = rnd.next('a', 'z');\n                if (c <= prev[j]) {\n                    s[j] = c;\n                } else {\n                    s[j] = prev[j];\n                }\n            }\n            temp[i] = s;\n            prev = s;\n        }\n        // Reverse the table to make it in decreasing order\n        reverse(temp.begin(), temp.end());\n        table = temp;\n    } else if (type == \"identical\") {\n        // Generate n identical strings\n        string s(m, 'a');\n        for (int j = 0; j < m; ++j)\n            s[j] = rnd.next('a', 'z');\n        for (int i = 0; i < n; ++i)\n            table[i] = s;\n    } else if (type == \"need_remove_all\") {\n        // Generate strings such that we need to remove all columns to sort the table\n        vector<string> strings(n);\n        for (int i = 0; i < n; ++i) {\n            string s(m, 'a');\n            for (int j = 0; j < m; ++j) {\n                s[j] = (char)('a' + rnd.next(0, 25));\n            }\n            strings[i] = s;\n        }\n        // Sort in decreasing order to make it the worst case\n        sort(strings.rbegin(), strings.rend());\n        table = strings;\n    } else {\n        // Generate random table\n        for (int i = 0; i < n; ++i) {\n            string s(m, 'a');\n            for (int j = 0; j < m; ++j) {\n                s[j] = rnd.next('a', 'z');\n            }\n            table[i] = s;\n        }\n    }\n\n    printf(\"%d %d\\n\", n, m);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%s\\n\", table[i].c_str());\n    }\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -m 1 -type sorted\n./gen -n 1 -m 100 -type sorted\n./gen -n 100 -m 1 -type sorted\n./gen -n 10 -m 10 -type sorted\n\n./gen -n 2 -m 50 -type sorted\n\n./gen -n 10 -m 10 -type random\n./gen -n 50 -m 50 -type random\n./gen -n 99 -m 99 -type random\n./gen -n 100 -m 100 -type random\n\n./gen -n 10 -m 10 -type reversed\n./gen -n 50 -m 50 -type reversed\n./gen -n 100 -m 100 -type reversed\n\n./gen -n 10 -m 10 -type identical\n./gen -n 100 -m 100 -type identical\n\n./gen -n 5 -m 5 -type need_remove_all\n./gen -n 10 -m 10 -type need_remove_all\n./gen -n 20 -m 20 -type need_remove_all\n./gen -n 50 -m 50 -type need_remove_all\n./gen -n 100 -m 100 -type need_remove_all\n\n./gen -n 1 -m 1 -type random\n./gen -n 1 -m 100 -type random\n./gen -n 100 -m 1 -type random\n\n./gen -n 50 -m 1 -type random\n\n./gen -n 2 -m 100 -type random\n./gen -n 3 -m 100 -type random\n\n./gen -n 100 -m 100 -type sorted\n./gen -n 100 -m 100 -type reversed\n\n./gen -n 50 -m 50 -type undefined\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:39:04.970232",
        "total_tutorials": 3,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "496/D",
      "title": "D. Tennis Game",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains a single integer n — the length of the sequence of games (1 ≤ n ≤ 105).The second line contains n space-separated integers ai. If ai = 1, then the i-th serve was won by Petya, if ai = 2, then the i-th serve was won by Gena.It is not guaranteed that at least one option for numbers s and t corresponds to the given record.",
      "output_spec": "OutputIn the first line print a single number k — the number of options for numbers s and t.In each of the following k lines print two integers si and ti — the option for numbers s and t. Print the options in the order of increasing si, and for equal si — in the order of increasing ti.",
      "sample_tests": "ExamplesInputCopy51 2 1 2 1OutputCopy21 33 1InputCopy41 1 1 1OutputCopy31 42 24 1InputCopy41 2 1 2OutputCopy0InputCopy82 1 2 1 1 1 1 1OutputCopy31 62 36 1",
      "description": "D. Tennis Game\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains a single integer n — the length of the sequence of games (1 ≤ n ≤ 105).The second line contains n space-separated integers ai. If ai = 1, then the i-th serve was won by Petya, if ai = 2, then the i-th serve was won by Gena.It is not guaranteed that at least one option for numbers s and t corresponds to the given record.\n\nOutputIn the first line print a single number k — the number of options for numbers s and t.In each of the following k lines print two integers si and ti — the option for numbers s and t. Print the options in the order of increasing si, and for equal si — in the order of increasing ti.\n\nInputCopy51 2 1 2 1OutputCopy21 33 1InputCopy41 1 1 1OutputCopy31 42 24 1InputCopy41 2 1 2OutputCopy0InputCopy82 1 2 1 1 1 1 1OutputCopy31 62 36 1\n\nInputCopy51 2 1 2 1\n\nOutputCopy21 33 1\n\nInputCopy41 1 1 1\n\nOutputCopy31 42 24 1\n\nInputCopy41 2 1 2\n\nOutputCopy0\n\nInputCopy82 1 2 1 1 1 1 1\n\nOutputCopy31 62 36 1",
      "solutions": [
        {
          "title": "Codeforces Round #283 - Codeforces",
          "content": "Hi, Codeforces.Today, on December 17 at 19:30 MSK regular, 283-rd Codeforces round will take place. Problems are authored by me, Mikhail Tikhomirov. Maxim Akhmedov (Zlobober) helped me with discussing and preparing the problemset, Maria Belova (Delinur) translated problem statements in English, and Georgy Chebanov (gchebanov), Alexander Mashrabov (map) and Niyaz Nigmatullin (niyaznigmatul) tested the round and helped us with finding bugs and mistakes; let's give them a round of applause!The round will be for both divisions. The scoring is standard (not dynamic); score distribution is as follows:Div. 1: 750-1250-1250-2000-2500Div. 2: 500-1000-1750-2250-2250This is going to be my fourth round at Codeforces. I really hope it will go as good as three before it. =) Wish you all the best of luck!UPD: the round is over, thanks for participating!Grats to the winners:Div. 1: SirShokoladina Petr rowdark anta Marcin_smu Merkurev qwer1561 Ra16bit kuviman Um_nik Div. 2: SergeyMelnikov sepehr103 StarCuriosity dotato husheyn Editorial is here ( UPD: now in English!).",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/15197",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1068
        },
        {
          "title": "Codeforces Round #283: editorial (with bonuses!) - Codeforces",
          "content": "Each problem comes with a challenge — a bonus task somehow related to the problem; you may tackle at the challenges for fun and practice, also feel free to discuss them at the comments. =)496A - Minimum DifficultyFor every option of removing an element we run through the remaining elements and find the maximal difference between adjacent ones; print the smallest found answer. The solution has complexity O(n2). It can be noticed that after removing an element the difficulty either stays the same or becomes equal to the difference between the neighbours of the removed element (whatever is larger); thus, the difficulty for every option of removing an element can be found in O(1), for the total complexity of O(n). Any of these solutions (or even less efficient ones) could pass the tests.Challenge: suppose we now have to remove exactly k arbitrary elements (but the first and the last elements have to stay in their places). How small the maximal difference between adjacent elements can become? Solve this problem assuming the limitations are as follows: 1 ≤ k ≤ n - 2, n ≤ 105, ai ≤ 109.496B - Secret CombinationWe observe that the order of operations is not important: we may first perform all the shifts, and after that all the additions. Note that after n shifts the sequence returns to its original state, therefore it is sufficient to consider only the options with less than n shifts. Also, after 10 times of adding 1 to all digits the sequence does not change; we may consider only options with less than 10 additions. Thus, there are overall 10n reasonable options for performing the operations; for every option perform the operations and find the smallest answer among all the options. As performing the operations for every option and comparing two answers to choose the best takes O(n) operations, this solution performs about 10n2 elementary operations. The multiple of 10 can be get rid of, if we note that after all shifts are made the best choice is to make the first digit equal to zero, and this leaves us but a single option for the number of additions. However, implementing this optimization is not necessary to get accepted.Challenge: can you solve the problem in time? in O(n) time?496C - Removing Columns/497A - Removing ColumnsLet's look at the first column of the table. If its letters are not sorted alphabetically, then in any valid choice of removing some columns it has to be removed. However, if its letters are sorted, then for every valid choice that has this column removed it can be restored back to the table; it is clear that the new choice is valid (that is, the rows of the new table are sorted lexicographically) and the answer (that is, the number of removed columns) has just became smaller.Consider all columns from left to right. We have already chosen which columns to remove among all the columns to the left of the current one; if leaving the current column in place breaks the lexicographical order of rows, then we have to remove it; otherwise, we may leave it in place to no harm. Arguing in the way of the previous paragraph we can prove that this greedy method yields an optimal (moreover, the only optimal) solution. The complexity is O(n2).Challenge: compute how many (say, modulo 109 + 7) n × m tables are there for which the answer for this problem is k? The more efficient solution you come up with, the better.496D - Tennis Game/497B - Tennis GameChoose some t; now emulate how the match will go, ensure that the record is valid for this t and by the way find the corresponding value of s. Print all valid options for s and t. This solution works in O(n2) time, which is not good enough, but we will try to optimize it.Suppose the current set if finished and we have processed k serves by now. Let us process the next set as follows: find t-th 1 and t-th 2 after position k. If t-th 1 occurs earlier, then the first player wins the set, and the set concludes right after the t-th 1; the other case is handled symmetrically. If the match is not over yet, and in the rest of the record there are no t ones nor t twos, then the record is clearly invalid. This way, every single set in the record can be processed in time using binary search, or O(1) time using precomputed arrays of positions for each player.Now observe that for any t a match of n serves can not contain more than n / t sets, as each set contains at least t serves. If we sum up the upper limits for the number of sets for each t, we obtain the total upper limit for the number of sets we may need to process: (which is the famous harmonic sum). Using one of the approaches discussed above, one obtains a solution with complexity of or ; each of these solutions fits the limit nicely.Obviously, for every t there is no more than one valid choice for s; however, maybe a bit unexpected, for a given s there may exist more than one valid choice of t. The first test where this takes place is pretest 12. The statement requires that the pairs are printed lexicographically ordered; it is possible to make a mistake here and print the pairs with equal s by descending t (if we fill the array by increasing t and then simply reverse the array).Challenge: while preparing this problem I discovered that it's quite hard to find a test such that the number of pairs in the answer is large; in the actual tests the maximal number is 128, which is the number of divisors of the number 83160. Can you beat this record? If you have a test with n ≤ 105 that has larger number of pairs in the answer, feel free to brag in the comments; also don't hesitate to share any insights on how one could bound the maximal number analytically.496E - Distributing Parts /497C - Distributing Parts Sort all the parts and actors altogether by increasing lower bounds (if equal, actors precede parts); process all the enitities in this order. We maintain a set of actors which have already occured in the order; if we meet an entry for an actor, add it to the set. If we currently process a part, we have to assign it to an actor; from the current set of actors we have to choose one such that his di ≥ bj (the ci ≤ aj constraint is provided by the fact that the i-th actor has occured earlier than the j-th part); if there are no such actors in the set, no answer can be obtained; if there are several actors satisftying this requirement, we should choose one with minimal di (intuitively, he will be less useful in the future). Assign the chosen actor with the current part and decrement his ki; if ki is now zero, the actor can not be used anymore, thus we remove him from the set.To fit the limits we should implement the set of current actors as some efficient data structure (e.g., an std::set or a treap). The resulting complexity is .Challenge: suppose that now there are qj copies of the j-th part (1 ≤ qj ≤ 109), and each copy must be separately assigned with an actor in a valid way. Can you solve this new problem with all the old constraints (as the actual distribution now has too much entries, it is sufficient to check whether an answer exists)?497D - GearsWhen a collision happens, a vertex of one polygon lands on a side of the other polygon. Consider a reference system such that the polygon A is not moving. In this system the polygon B preserves its orientation (that is, does not rotate), and each of its vertices moves on some circle. Intersect all the circles for vertices of B with all the sides of A; if any of them intersect, then some vertex of B collides with a side of A. Symmetrically, take a reference system associated with B and check whether some vertex of A collides with a side of B. The constraints for the points' coordinates are small enough for a solution with absolute precision to be possible (using built-in integer types).Another approach (which is, in fact, basically the same) is such: suppose there is a collision in a reference system associated with A. Then the following equality for vectors holds: x + y = z; here z is a vector that starts at P and ends somewhere on the bound of A, x is a vector that starts at Q and ends somewhere on the bound of B, y is a vector that starts at P and ends somewhere on the circle centered at P that passes through Q. Rewrite the equality as y = z - x; now observe that the set of all possible values of z - x forms the Minkowski sum of A and reflection of B (up to some shift), and the set of all possible values of y is a circle with known parameters. The Minkowski sum can be represented as a union of nm parallelograms, each of which is the Minkowski sum of a pair of sides of different polygons; finally, intersect all parallelograms with the circle.Both solutions have complexity O(nm). As noted above, it is possible to solve the problem using integer arithemetics (that is, with absolute precision); however, the fact that the points' coordinates are small lets most of the solutions with floating point arithmetics pass. It was tempting to write an approximate numerical solution; we struggled hard not to let such solutions pass, and eventually none of them did. =)Many participants had troubles with pretest 8. It looks as follows (the left spiral revolves around the left point, and the right spiral revolves around the right point):Challenge: suppose we want a solution that uses floating point arithmetics to fail. In order to do that, we want to construct a test such that the polygons don't collide but pass really close to each other. How small a (positive) distance we can achieve, given the same constraints for the number of points and the points' coordinates?497E - Subsequences ReturnConsider some string; how does one count the number of its distinct subsequences? Let us append symbols to the string consequently and each time count the number of subsequences that were not present before. Let's append a symbol c to a string s; in the string s + c there are as many subsequences that end in c as there were subsequences in s overall. Add all these subsequences to the number of subsequnces of s; now each subsequence is counted once, except for the subsequences that end in c but were already present in s before; these are counted twice. Thus, the total number of subsequences in the new string is twice the total number of subsequences in the old string minus the number of subsequences in the old string which end in c.This leads us to the following solution: for each symbol c store how many subsequences end in c, denote cntc. Append symbol c; now cntc becomes equal to the sum of all cnt's plus one (for the empty subsequence), and all the other cnt's do not change.For example, consider the first few symbols of the Thue-Morse sequence: ε — (0, 0) 0 — ( 0 + 0 + 1 = 1, 0) 01 — (1, 1 + 0 + 1 = 2) 011 — (1, 1 + 2 + 1 = 4) 0110 — ( 1 + 4 + 1 = 6, 4) ... Let us put the values of cnt in the coordinates of a vector, and also append a coordinate which is always equal to 1. It is now clear that appending a symbol to the string alters the vector as a multiplication by some matrix. Let us assign a matrix for each symbol, and also for each string as a product of matrices for the symbols of the strings in that order.Now, consider the prefix of the sequence ai of length km. Divide it into k parts of length km - 1; x-th (0-based) of these parts can be obtained from the 0-th one by adding x modulo k to all elements of the part. Let us count the matrices (see above) for the prefixes of length km, and also for all strings that are obtained by adding x to all of the prefixes' elements; denote such matrix Am, x.It is easy to see that if m > 0, then . This formula allows us to count Am, x for all and all x from 0 to k - 1 in time. Now, upon having all Am, x we can multiply some of them in the right order to obtain the matrix for the prefix of the sequence ai of length n.Unfortunately, this is not quite enough as the solution doesn't fit the time limit yet. Here is one way to speed up sufficiently: note that the product in the formula can be divided as shown: Am - 1, x... Am - 1, k - 1 × Am - 1, 0... Am - 1, x - 1 (if x = 0, take the second part to be empty). Count all the \"prefixes\" and \"suffixes\" products of the set Am, x: Pm, x = Am, 0... Am, x - 1, Sm, x = Am, x... Am, k - 1. Now Am, x = Sm - 1, xPm - 1, x. Thus, the computation of Am, x for all x and a given m can be done as computing all Pm - 1, x, Sm - 1, x using O(k) matrix multiplications, and each Am, x is now can be found using one matrix multiplication. Finally, the solution now works in time, which fits the limits by a margin.Challenge: solve the problem for k ≤ 100.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/15208",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 496\\s*D"
          },
          "content_length": 12568
        },
        {
          "title": "Codeforces Round #283: editorial (with bonuses!) - Codeforces",
          "content": "Each problem comes with a challenge — a bonus task somehow related to the problem; you may tackle at the challenges for fun and practice, also feel free to discuss them at the comments. =)496A - Minimum DifficultyFor every option of removing an element we run through the remaining elements and find the maximal difference between adjacent ones; print the smallest found answer. The solution has complexity O(n2). It can be noticed that after removing an element the difficulty either stays the same or becomes equal to the difference between the neighbours of the removed element (whatever is larger); thus, the difficulty for every option of removing an element can be found in O(1), for the total complexity of O(n). Any of these solutions (or even less efficient ones) could pass the tests.Challenge: suppose we now have to remove exactly k arbitrary elements (but the first and the last elements have to stay in their places). How small the maximal difference between adjacent elements can become? Solve this problem assuming the limitations are as follows: 1 ≤ k ≤ n - 2, n ≤ 105, ai ≤ 109.496B - Secret CombinationWe observe that the order of operations is not important: we may first perform all the shifts, and after that all the additions. Note that after n shifts the sequence returns to its original state, therefore it is sufficient to consider only the options with less than n shifts. Also, after 10 times of adding 1 to all digits the sequence does not change; we may consider only options with less than 10 additions. Thus, there are overall 10n reasonable options for performing the operations; for every option perform the operations and find the smallest answer among all the options. As performing the operations for every option and comparing two answers to choose the best takes O(n) operations, this solution performs about 10n2 elementary operations. The multiple of 10 can be get rid of, if we note that after all shifts are made the best choice is to make the first digit equal to zero, and this leaves us but a single option for the number of additions. However, implementing this optimization is not necessary to get accepted.Challenge: can you solve the problem in time? in O(n) time?496C - Removing Columns/497A - Removing ColumnsLet's look at the first column of the table. If its letters are not sorted alphabetically, then in any valid choice of removing some columns it has to be removed. However, if its letters are sorted, then for every valid choice that has this column removed it can be restored back to the table; it is clear that the new choice is valid (that is, the rows of the new table are sorted lexicographically) and the answer (that is, the number of removed columns) has just became smaller.Consider all columns from left to right. We have already chosen which columns to remove among all the columns to the left of the current one; if leaving the current column in place breaks the lexicographical order of rows, then we have to remove it; otherwise, we may leave it in place to no harm. Arguing in the way of the previous paragraph we can prove that this greedy method yields an optimal (moreover, the only optimal) solution. The complexity is O(n2).Challenge: compute how many (say, modulo 109 + 7) n × m tables are there for which the answer for this problem is k? The more efficient solution you come up with, the better.496D - Tennis Game/497B - Tennis GameChoose some t; now emulate how the match will go, ensure that the record is valid for this t and by the way find the corresponding value of s. Print all valid options for s and t. This solution works in O(n2) time, which is not good enough, but we will try to optimize it.Suppose the current set if finished and we have processed k serves by now. Let us process the next set as follows: find t-th 1 and t-th 2 after position k. If t-th 1 occurs earlier, then the first player wins the set, and the set concludes right after the t-th 1; the other case is handled symmetrically. If the match is not over yet, and in the rest of the record there are no t ones nor t twos, then the record is clearly invalid. This way, every single set in the record can be processed in time using binary search, or O(1) time using precomputed arrays of positions for each player.Now observe that for any t a match of n serves can not contain more than n / t sets, as each set contains at least t serves. If we sum up the upper limits for the number of sets for each t, we obtain the total upper limit for the number of sets we may need to process: (which is the famous harmonic sum). Using one of the approaches discussed above, one obtains a solution with complexity of or ; each of these solutions fits the limit nicely.Obviously, for every t there is no more than one valid choice for s; however, maybe a bit unexpected, for a given s there may exist more than one valid choice of t. The first test where this takes place is pretest 12. The statement requires that the pairs are printed lexicographically ordered; it is possible to make a mistake here and print the pairs with equal s by descending t (if we fill the array by increasing t and then simply reverse the array).Challenge: while preparing this problem I discovered that it's quite hard to find a test such that the number of pairs in the answer is large; in the actual tests the maximal number is 128, which is the number of divisors of the number 83160. Can you beat this record? If you have a test with n ≤ 105 that has larger number of pairs in the answer, feel free to brag in the comments; also don't hesitate to share any insights on how one could bound the maximal number analytically.496E - Distributing Parts /497C - Distributing Parts Sort all the parts and actors altogether by increasing lower bounds (if equal, actors precede parts); process all the enitities in this order. We maintain a set of actors which have already occured in the order; if we meet an entry for an actor, add it to the set. If we currently process a part, we have to assign it to an actor; from the current set of actors we have to choose one such that his di ≥ bj (the ci ≤ aj constraint is provided by the fact that the i-th actor has occured earlier than the j-th part); if there are no such actors in the set, no answer can be obtained; if there are several actors satisftying this requirement, we should choose one with minimal di (intuitively, he will be less useful in the future). Assign the chosen actor with the current part and decrement his ki; if ki is now zero, the actor can not be used anymore, thus we remove him from the set.To fit the limits we should implement the set of current actors as some efficient data structure (e.g., an std::set or a treap). The resulting complexity is .Challenge: suppose that now there are qj copies of the j-th part (1 ≤ qj ≤ 109), and each copy must be separately assigned with an actor in a valid way. Can you solve this new problem with all the old constraints (as the actual distribution now has too much entries, it is sufficient to check whether an answer exists)?497D - GearsWhen a collision happens, a vertex of one polygon lands on a side of the other polygon. Consider a reference system such that the polygon A is not moving. In this system the polygon B preserves its orientation (that is, does not rotate), and each of its vertices moves on some circle. Intersect all the circles for vertices of B with all the sides of A; if any of them intersect, then some vertex of B collides with a side of A. Symmetrically, take a reference system associated with B and check whether some vertex of A collides with a side of B. The constraints for the points' coordinates are small enough for a solution with absolute precision to be possible (using built-in integer types).Another approach (which is, in fact, basically the same) is such: suppose there is a collision in a reference system associated with A. Then the following equality for vectors holds: x + y = z; here z is a vector that starts at P and ends somewhere on the bound of A, x is a vector that starts at Q and ends somewhere on the bound of B, y is a vector that starts at P and ends somewhere on the circle centered at P that passes through Q. Rewrite the equality as y = z - x; now observe that the set of all possible values of z - x forms the Minkowski sum of A and reflection of B (up to some shift), and the set of all possible values of y is a circle with known parameters. The Minkowski sum can be represented as a union of nm parallelograms, each of which is the Minkowski sum of a pair of sides of different polygons; finally, intersect all parallelograms with the circle.Both solutions have complexity O(nm). As noted above, it is possible to solve the problem using integer arithemetics (that is, with absolute precision); however, the fact that the points' coordinates are small lets most of the solutions with floating point arithmetics pass. It was tempting to write an approximate numerical solution; we struggled hard not to let such solutions pass, and eventually none of them did. =)Many participants had troubles with pretest 8. It looks as follows (the left spiral revolves around the left point, and the right spiral revolves around the right point):Challenge: suppose we want a solution that uses floating point arithmetics to fail. In order to do that, we want to construct a test such that the polygons don't collide but pass really close to each other. How small a (positive) distance we can achieve, given the same constraints for the number of points and the points' coordinates?497E - Subsequences ReturnConsider some string; how does one count the number of its distinct subsequences? Let us append symbols to the string consequently and each time count the number of subsequences that were not present before. Let's append a symbol c to a string s; in the string s + c there are as many subsequences that end in c as there were subsequences in s overall. Add all these subsequences to the number of subsequnces of s; now each subsequence is counted once, except for the subsequences that end in c but were already present in s before; these are counted twice. Thus, the total number of subsequences in the new string is twice the total number of subsequences in the old string minus the number of subsequences in the old string which end in c.This leads us to the following solution: for each symbol c store how many subsequences end in c, denote cntc. Append symbol c; now cntc becomes equal to the sum of all cnt's plus one (for the empty subsequence), and all the other cnt's do not change.For example, consider the first few symbols of the Thue-Morse sequence: ε — (0, 0) 0 — ( 0 + 0 + 1 = 1, 0) 01 — (1, 1 + 0 + 1 = 2) 011 — (1, 1 + 2 + 1 = 4) 0110 — ( 1 + 4 + 1 = 6, 4) ... Let us put the values of cnt in the coordinates of a vector, and also append a coordinate which is always equal to 1. It is now clear that appending a symbol to the string alters the vector as a multiplication by some matrix. Let us assign a matrix for each symbol, and also for each string as a product of matrices for the symbols of the strings in that order.Now, consider the prefix of the sequence ai of length km. Divide it into k parts of length km - 1; x-th (0-based) of these parts can be obtained from the 0-th one by adding x modulo k to all elements of the part. Let us count the matrices (see above) for the prefixes of length km, and also for all strings that are obtained by adding x to all of the prefixes' elements; denote such matrix Am, x.It is easy to see that if m > 0, then . This formula allows us to count Am, x for all and all x from 0 to k - 1 in time. Now, upon having all Am, x we can multiply some of them in the right order to obtain the matrix for the prefix of the sequence ai of length n.Unfortunately, this is not quite enough as the solution doesn't fit the time limit yet. Here is one way to speed up sufficiently: note that the product in the formula can be divided as shown: Am - 1, x... Am - 1, k - 1 × Am - 1, 0... Am - 1, x - 1 (if x = 0, take the second part to be empty). Count all the \"prefixes\" and \"suffixes\" products of the set Am, x: Pm, x = Am, 0... Am, x - 1, Sm, x = Am, x... Am, k - 1. Now Am, x = Sm - 1, xPm - 1, x. Thus, the computation of Am, x for all x and a given m can be done as computing all Pm - 1, x, Sm - 1, x using O(k) matrix multiplications, and each Am, x is now can be found using one matrix multiplication. Finally, the solution now works in time, which fits the limits by a margin.Challenge: solve the problem for k ≤ 100.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/15208",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 496\\s*D"
          },
          "content_length": 12568
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #283 - Codeforces - Code 1",
          "code": "18\n2 2   2 2   2 2   1 2 1   1 2 1   1 2 1   1 2 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15197",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #283 - Codeforces - Code 2",
          "code": "18\n2 2   2 2   2 2   1 2 1   1 2 1   1 2 1   1 2 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15197",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #283 - Codeforces - Code 3",
          "code": "ans[ac]=i;\n       ac++;\n    }\n}\nreturn ac;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15197",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #283 - Codeforces - Code 4",
          "code": "ans[ac]=i;\n       ac++;\n    }\n}\nreturn ac;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15197",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #283 - Codeforces - Code 5",
          "code": "cin>>n;\nfor (int i=0;i<n;i++) cin>>a[i];\nfor (int i=0;i<n;i++) {\n    if (a[i]==1) x++; else y++;\n    f[i]=max(x,y);\n}\nint z=fact(f[n-1]);\nif (x==y) {\n    cout<<\"0\";\n} else {\n    cout<<ac<<endl;\n    for (int i=0;i<ac;i++) {\n       cout<<ans[i]<<\" \"<<f[n-1]/ans[i]<<endl;\n    }\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15197",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #283 - Codeforces - Code 6",
          "code": "cin>>n;\nfor (int i=0;i<n;i++) cin>>a[i];\nfor (int i=0;i<n;i++) {\n    if (a[i]==1) x++; else y++;\n    f[i]=max(x,y);\n}\nint z=fact(f[n-1]);\nif (x==y) {\n    cout<<\"0\";\n} else {\n    cout<<ac<<endl;\n    for (int i=0;i<ac;i++) {\n       cout<<ans[i]<<\" \"<<f[n-1]/ans[i]<<endl;\n    }\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15197",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #283 - Codeforces - Code 7",
          "code": "ae ae et oe",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15197",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #283 - Codeforces - Code 8",
          "code": "20\n1 1 2 2 2 2 2 2 2 2 2 2 1 2 2 1 2 2 2 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15197",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #283 - Codeforces - Code 9",
          "code": "20\n1 1 2 2 2 2 2 2 2 2 2 2 1 2 2 1 2 2 2 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15197",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #283: editorial (with bonuses!) - Codeforces - Code 1",
          "code": "496D - Tennis Game",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15208",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #283: editorial (with bonuses!) - Codeforces - Code 2",
          "code": "number of valid (s,t) will be 0 if the total number of points of player who won  the last point is less than or equal to another player",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15208",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #283: editorial (with bonuses!) - Codeforces - Code 3",
          "code": "strictly more",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15208",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #283: editorial (with bonuses!) - Codeforces - Code 4",
          "code": "The Minkowski sum can be represented as a union of nm parallelograms, each of which is the Minkowski sum of a pair of sides of different polygons;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15208",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #283: editorial (with bonuses!) - Codeforces - Code 5",
          "code": "circle_segment",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15208",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #283: editorial (with bonuses!) - Codeforces - Code 6",
          "code": "ll dmax = (max((a - c) | (a - c), (a - b) | (a - b))); -> ll dmax = (max((a - c) | (a - c), (b - c) | (b - c)));",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15208",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #283: editorial (with bonuses!) - Codeforces - Code 7",
          "code": "ll dmax = (max((a - c) | (a - c), (a - b) | (a - b))); -> ll dmax = (max((a - c) | (a - c), (b - c) | (b - c)));",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15208",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #283: editorial (with bonuses!) - Codeforces - Code 1",
          "code": "496D - Tennis Game",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15208",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #283: editorial (with bonuses!) - Codeforces - Code 2",
          "code": "number of valid (s,t) will be 0 if the total number of points of player who won  the last point is less than or equal to another player",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15208",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #283: editorial (with bonuses!) - Codeforces - Code 3",
          "code": "strictly more",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15208",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #283: editorial (with bonuses!) - Codeforces - Code 4",
          "code": "The Minkowski sum can be represented as a union of nm parallelograms, each of which is the Minkowski sum of a pair of sides of different polygons;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15208",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #283: editorial (with bonuses!) - Codeforces - Code 5",
          "code": "circle_segment",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15208",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #283: editorial (with bonuses!) - Codeforces - Code 6",
          "code": "ll dmax = (max((a - c) | (a - c), (a - b) | (a - b))); -> ll dmax = (max((a - c) | (a - c), (b - c) | (b - c)));",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15208",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #283: editorial (with bonuses!) - Codeforces - Code 7",
          "code": "ll dmax = (max((a - c) | (a - c), (a - b) | (a - b))); -> ll dmax = (max((a - c) | (a - c), (b - c) | (b - c)));",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15208",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n    vector<int> a = inf.readInts(n, 1, 2, \"ai\");\n    inf.readEoln();\n    inf.readEof();\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n    vector<int> a = inf.readInts(n, 1, 2, \"ai\");\n    inf.readEoln();\n    inf.readEof();\n\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n    vector<int> a = inf.readInts(n, 1, 2, \"ai\");\n    inf.readEoln();\n    inf.readEof();\n\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> a;\n\n    if (type == \"random\") {\n        // Generate a random sequence of 1's and 2's\n        a.resize(n);\n        for (int i = 0; i < n; ++i)\n            a[i] = rnd.next(1, 2);\n    } else if (type == \"all_ones\") {\n        // All serves won by Petya\n        a.resize(n, 1);\n    } else if (type == \"all_twos\") {\n        // All serves won by Gena\n        a.resize(n, 2);\n    } else if (type == \"alternating\") {\n        // Alternating serves between Petya and Gena\n        a.resize(n);\n        for (int i = 0; i < n; ++i)\n            a[i] = i % 2 + 1;\n    } else if (type == \"pattern\") {\n        // Repeating pattern provided by the parameter 'pattern'\n        string pattern_str = opt<string>(\"pattern\", \"1 2\");\n        vector<int> pattern;\n        stringstream ss(pattern_str);\n        int num;\n        while (ss >> num)\n            pattern.push_back(num);\n        a.resize(n);\n        for (int i = 0; i < n; ++i)\n            a[i] = pattern[i % pattern.size()];\n    } else if (type == \"zero_options\") {\n        // Generate a sequence that cannot correspond to any possible s and t\n        // Using the alternating pattern based on the third example\n        a.resize(n);\n        for (int i = 0; i < n; ++i)\n            a[i] = i % 2 + 1;\n    } else if (type == \"max_options\") {\n        // Generate a sequence that could correspond to many possible s and t\n        // All serves won by Petya to maximize the number of options\n        a.resize(n, 1);\n    } else if (type == \"small_s_t\") {\n        // Generate a sequence where the match could end with small s and t\n        int s = opt<int>(\"s\", rnd.next(1, n));\n        int t = opt<int>(\"t\", rnd.next(1, n));\n        int total_serves = s * t;\n        if (total_serves > n) total_serves = n;\n        a.resize(total_serves, 1); // Petya wins all serves\n    } else if (type == \"single_set\") {\n        // Generate a sequence that can be played as a single set\n        int t = opt<int>(\"t\", n);\n        if (t > n) t = n;\n        a.resize(t);\n        for (int i = 0; i < t; ++i)\n            a[i] = rnd.next(1, 2);\n    } else if (type == \"max_sets\") {\n        // Generate a sequence with maximum number of sets\n        int t = 1; // Each set ends after one point\n        int s = n; // Maximum number of sets\n        n = min(n, s * t);\n        a.resize(n);\n        for (int i = 0; i < n; ++i)\n            a[i] = (i % 2) + 1; // Alternate winners\n    } else {\n        // Default to random\n        a.resize(n);\n        for (int i = 0; i < n; ++i)\n            a[i] = rnd.next(1, 2);\n    }\n\n    // Output n\n    printf(\"%d\\n\", (int)a.size());\n    // Output the sequence\n    for (int i = 0; i < (int)a.size(); ++i)\n        printf(\"%d%c\", a[i], i == (int)a.size() - 1 ? '\\n' : ' ');\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> a;\n\n    if (type == \"random\") {\n        // Generate a random sequence of 1's and 2's\n        a.resize(n);\n        for (int i = 0; i < n; ++i)\n            a[i] = rnd.next(1, 2);\n    } else if (type == \"all_ones\") {\n        // All serves won by Petya\n        a.resize(n, 1);\n    } else if (type == \"all_twos\") {\n        // All serves won by Gena\n        a.resize(n, 2);\n    } else if (type == \"alternating\") {\n        // Alternating serves between Petya and Gena\n        a.resize(n);\n        for (int i = 0; i < n; ++i)\n            a[i] = i % 2 + 1;\n    } else if (type == \"pattern\") {\n        // Repeating pattern provided by the parameter 'pattern'\n        string pattern_str = opt<string>(\"pattern\", \"1 2\");\n        vector<int> pattern;\n        stringstream ss(pattern_str);\n        int num;\n        while (ss >> num)\n            pattern.push_back(num);\n        a.resize(n);\n        for (int i = 0; i < n; ++i)\n            a[i] = pattern[i % pattern.size()];\n    } else if (type == \"zero_options\") {\n        // Generate a sequence that cannot correspond to any possible s and t\n        // Using the alternating pattern based on the third example\n        a.resize(n);\n        for (int i = 0; i < n; ++i)\n            a[i] = i % 2 + 1;\n    } else if (type == \"max_options\") {\n        // Generate a sequence that could correspond to many possible s and t\n        // All serves won by Petya to maximize the number of options\n        a.resize(n, 1);\n    } else if (type == \"small_s_t\") {\n        // Generate a sequence where the match could end with small s and t\n        int s = opt<int>(\"s\", rnd.next(1, n));\n        int t = opt<int>(\"t\", rnd.next(1, n));\n        int total_serves = s * t;\n        if (total_serves > n) total_serves = n;\n        a.resize(total_serves, 1); // Petya wins all serves\n    } else if (type == \"single_set\") {\n        // Generate a sequence that can be played as a single set\n        int t = opt<int>(\"t\", n);\n        if (t > n) t = n;\n        a.resize(t);\n        for (int i = 0; i < t; ++i)\n            a[i] = rnd.next(1, 2);\n    } else if (type == \"max_sets\") {\n        // Generate a sequence with maximum number of sets\n        int t = 1; // Each set ends after one point\n        int s = n; // Maximum number of sets\n        n = min(n, s * t);\n        a.resize(n);\n        for (int i = 0; i < n; ++i)\n            a[i] = (i % 2) + 1; // Alternate winners\n    } else {\n        // Default to random\n        a.resize(n);\n        for (int i = 0; i < n; ++i)\n            a[i] = rnd.next(1, 2);\n    }\n\n    // Output n\n    printf(\"%d\\n\", (int)a.size());\n    // Output the sequence\n    for (int i = 0; i < (int)a.size(); ++i)\n        printf(\"%d%c\", a[i], i == (int)a.size() - 1 ? '\\n' : ' ');\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -type all_ones\n./gen -n 1 -type all_twos\n./gen -n 2 -type alternating\n\n./gen -n 10 -type random\n./gen -n 10 -type all_ones\n./gen -n 10 -type all_twos\n./gen -n 10 -type alternating\n./gen -n 10 -type pattern -pattern \"1 2 1\"\n./gen -n 10 -type zero_options\n\n./gen -n 100 -type random\n./gen -n 100 -type all_ones\n./gen -n 100 -type all_twos\n./gen -n 100 -type alternating\n./gen -n 100 -type pattern -pattern \"1 1 2 2\"\n\n./gen -n 1000 -type random\n./gen -n 1000 -type small_s_t -s 1 -t 1000\n\n./gen -n 1000 -type single_set -t 1000\n\n./gen -n 10000 -type zero_options\n\n./gen -n 10000 -type max_sets\n\n./gen -n 50000 -type random\n./gen -n 50000 -type alternating\n./gen -n 50000 -type zero_options\n\n./gen -n 99999 -type max_options\n\n./gen -n 100000 -type random\n./gen -n 100000 -type all_ones\n./gen -n 100000 -type all_twos\n./gen -n 100000 -type alternating\n./gen -n 100000 -type zero_options\n\n./gen -n 99999 -type pattern -pattern \"1 2 1 1 2 2\"\n./gen -n 99999 -type pattern -pattern \"1 1 1 2 2 2\"\n./gen -n 100000 -type small_s_t -s 2 -t 50000\n./gen -n 100000 -type single_set -t 100000\n./gen -n 75000 -type max_sets\n./gen -n 100000 -type pattern -pattern \"2\"\n./gen -n 100000 -type small_s_t -s 25000 -t 4\n./gen -n 100000 -type pattern -pattern \"1 1 2\"\n./gen -n 100000 -type zero_options\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:39:06.586192",
        "total_tutorials": 3,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "496/E",
      "title": "E. Distributing Parts",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains a single integer n — the number of parts in the play (1 ≤ n ≤ 105).Next n lines contain two space-separated integers each, aj and bj — the range of notes for the j-th part (1 ≤ aj ≤ bj ≤ 109).The next line contains a single integer m — the number of actors (1 ≤ m ≤ 105).Next m lines contain three space-separated integers each, ci, di and ki — the range of the i-th actor and the number of parts that he can perform (1 ≤ ci ≤ di ≤ 109, 1 ≤ ki ≤ 109).",
      "output_spec": "OutputIf there is an assignment that meets all the criteria aboce, print a single word \"YES\" (without the quotes) in the first line.In the next line print n space-separated integers. The i-th integer should be the number of the actor who should perform the i-th part. If there are multiple correct assignments, print any of them.If there is no correct assignment, print a single word \"NO\" (without the quotes).",
      "sample_tests": "ExamplesInputCopy31 32 43 521 4 22 5 1OutputCopyYES1 1 2InputCopy31 32 43 521 3 22 5 1OutputCopyNO",
      "description": "E. Distributing Parts\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains a single integer n — the number of parts in the play (1 ≤ n ≤ 105).Next n lines contain two space-separated integers each, aj and bj — the range of notes for the j-th part (1 ≤ aj ≤ bj ≤ 109).The next line contains a single integer m — the number of actors (1 ≤ m ≤ 105).Next m lines contain three space-separated integers each, ci, di and ki — the range of the i-th actor and the number of parts that he can perform (1 ≤ ci ≤ di ≤ 109, 1 ≤ ki ≤ 109).\n\nOutputIf there is an assignment that meets all the criteria aboce, print a single word \"YES\" (without the quotes) in the first line.In the next line print n space-separated integers. The i-th integer should be the number of the actor who should perform the i-th part. If there are multiple correct assignments, print any of them.If there is no correct assignment, print a single word \"NO\" (without the quotes).\n\nInputCopy31 32 43 521 4 22 5 1OutputCopyYES1 1 2InputCopy31 32 43 521 3 22 5 1OutputCopyNO\n\nInputCopy31 32 43 521 4 22 5 1\n\nOutputCopyYES1 1 2\n\nInputCopy31 32 43 521 3 22 5 1\n\nOutputCopyNO",
      "solutions": [
        {
          "title": "Codeforces Round #283 - Codeforces",
          "content": "Hi, Codeforces.Today, on December 17 at 19:30 MSK regular, 283-rd Codeforces round will take place. Problems are authored by me, Mikhail Tikhomirov. Maxim Akhmedov (Zlobober) helped me with discussing and preparing the problemset, Maria Belova (Delinur) translated problem statements in English, and Georgy Chebanov (gchebanov), Alexander Mashrabov (map) and Niyaz Nigmatullin (niyaznigmatul) tested the round and helped us with finding bugs and mistakes; let's give them a round of applause!The round will be for both divisions. The scoring is standard (not dynamic); score distribution is as follows:Div. 1: 750-1250-1250-2000-2500Div. 2: 500-1000-1750-2250-2250This is going to be my fourth round at Codeforces. I really hope it will go as good as three before it. =) Wish you all the best of luck!UPD: the round is over, thanks for participating!Grats to the winners:Div. 1: SirShokoladina Petr rowdark anta Marcin_smu Merkurev qwer1561 Ra16bit kuviman Um_nik Div. 2: SergeyMelnikov sepehr103 StarCuriosity dotato husheyn Editorial is here ( UPD: now in English!).",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/15197",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1068
        },
        {
          "title": "Codeforces Round #283: editorial (with bonuses!) - Codeforces",
          "content": "Each problem comes with a challenge — a bonus task somehow related to the problem; you may tackle at the challenges for fun and practice, also feel free to discuss them at the comments. =)496A - Minimum DifficultyFor every option of removing an element we run through the remaining elements and find the maximal difference between adjacent ones; print the smallest found answer. The solution has complexity O(n2). It can be noticed that after removing an element the difficulty either stays the same or becomes equal to the difference between the neighbours of the removed element (whatever is larger); thus, the difficulty for every option of removing an element can be found in O(1), for the total complexity of O(n). Any of these solutions (or even less efficient ones) could pass the tests.Challenge: suppose we now have to remove exactly k arbitrary elements (but the first and the last elements have to stay in their places). How small the maximal difference between adjacent elements can become? Solve this problem assuming the limitations are as follows: 1 ≤ k ≤ n - 2, n ≤ 105, ai ≤ 109.496B - Secret CombinationWe observe that the order of operations is not important: we may first perform all the shifts, and after that all the additions. Note that after n shifts the sequence returns to its original state, therefore it is sufficient to consider only the options with less than n shifts. Also, after 10 times of adding 1 to all digits the sequence does not change; we may consider only options with less than 10 additions. Thus, there are overall 10n reasonable options for performing the operations; for every option perform the operations and find the smallest answer among all the options. As performing the operations for every option and comparing two answers to choose the best takes O(n) operations, this solution performs about 10n2 elementary operations. The multiple of 10 can be get rid of, if we note that after all shifts are made the best choice is to make the first digit equal to zero, and this leaves us but a single option for the number of additions. However, implementing this optimization is not necessary to get accepted.Challenge: can you solve the problem in time? in O(n) time?496C - Removing Columns/497A - Removing ColumnsLet's look at the first column of the table. If its letters are not sorted alphabetically, then in any valid choice of removing some columns it has to be removed. However, if its letters are sorted, then for every valid choice that has this column removed it can be restored back to the table; it is clear that the new choice is valid (that is, the rows of the new table are sorted lexicographically) and the answer (that is, the number of removed columns) has just became smaller.Consider all columns from left to right. We have already chosen which columns to remove among all the columns to the left of the current one; if leaving the current column in place breaks the lexicographical order of rows, then we have to remove it; otherwise, we may leave it in place to no harm. Arguing in the way of the previous paragraph we can prove that this greedy method yields an optimal (moreover, the only optimal) solution. The complexity is O(n2).Challenge: compute how many (say, modulo 109 + 7) n × m tables are there for which the answer for this problem is k? The more efficient solution you come up with, the better.496D - Tennis Game/497B - Tennis GameChoose some t; now emulate how the match will go, ensure that the record is valid for this t and by the way find the corresponding value of s. Print all valid options for s and t. This solution works in O(n2) time, which is not good enough, but we will try to optimize it.Suppose the current set if finished and we have processed k serves by now. Let us process the next set as follows: find t-th 1 and t-th 2 after position k. If t-th 1 occurs earlier, then the first player wins the set, and the set concludes right after the t-th 1; the other case is handled symmetrically. If the match is not over yet, and in the rest of the record there are no t ones nor t twos, then the record is clearly invalid. This way, every single set in the record can be processed in time using binary search, or O(1) time using precomputed arrays of positions for each player.Now observe that for any t a match of n serves can not contain more than n / t sets, as each set contains at least t serves. If we sum up the upper limits for the number of sets for each t, we obtain the total upper limit for the number of sets we may need to process: (which is the famous harmonic sum). Using one of the approaches discussed above, one obtains a solution with complexity of or ; each of these solutions fits the limit nicely.Obviously, for every t there is no more than one valid choice for s; however, maybe a bit unexpected, for a given s there may exist more than one valid choice of t. The first test where this takes place is pretest 12. The statement requires that the pairs are printed lexicographically ordered; it is possible to make a mistake here and print the pairs with equal s by descending t (if we fill the array by increasing t and then simply reverse the array).Challenge: while preparing this problem I discovered that it's quite hard to find a test such that the number of pairs in the answer is large; in the actual tests the maximal number is 128, which is the number of divisors of the number 83160. Can you beat this record? If you have a test with n ≤ 105 that has larger number of pairs in the answer, feel free to brag in the comments; also don't hesitate to share any insights on how one could bound the maximal number analytically.496E - Distributing Parts /497C - Distributing Parts Sort all the parts and actors altogether by increasing lower bounds (if equal, actors precede parts); process all the enitities in this order. We maintain a set of actors which have already occured in the order; if we meet an entry for an actor, add it to the set. If we currently process a part, we have to assign it to an actor; from the current set of actors we have to choose one such that his di ≥ bj (the ci ≤ aj constraint is provided by the fact that the i-th actor has occured earlier than the j-th part); if there are no such actors in the set, no answer can be obtained; if there are several actors satisftying this requirement, we should choose one with minimal di (intuitively, he will be less useful in the future). Assign the chosen actor with the current part and decrement his ki; if ki is now zero, the actor can not be used anymore, thus we remove him from the set.To fit the limits we should implement the set of current actors as some efficient data structure (e.g., an std::set or a treap). The resulting complexity is .Challenge: suppose that now there are qj copies of the j-th part (1 ≤ qj ≤ 109), and each copy must be separately assigned with an actor in a valid way. Can you solve this new problem with all the old constraints (as the actual distribution now has too much entries, it is sufficient to check whether an answer exists)?497D - GearsWhen a collision happens, a vertex of one polygon lands on a side of the other polygon. Consider a reference system such that the polygon A is not moving. In this system the polygon B preserves its orientation (that is, does not rotate), and each of its vertices moves on some circle. Intersect all the circles for vertices of B with all the sides of A; if any of them intersect, then some vertex of B collides with a side of A. Symmetrically, take a reference system associated with B and check whether some vertex of A collides with a side of B. The constraints for the points' coordinates are small enough for a solution with absolute precision to be possible (using built-in integer types).Another approach (which is, in fact, basically the same) is such: suppose there is a collision in a reference system associated with A. Then the following equality for vectors holds: x + y = z; here z is a vector that starts at P and ends somewhere on the bound of A, x is a vector that starts at Q and ends somewhere on the bound of B, y is a vector that starts at P and ends somewhere on the circle centered at P that passes through Q. Rewrite the equality as y = z - x; now observe that the set of all possible values of z - x forms the Minkowski sum of A and reflection of B (up to some shift), and the set of all possible values of y is a circle with known parameters. The Minkowski sum can be represented as a union of nm parallelograms, each of which is the Minkowski sum of a pair of sides of different polygons; finally, intersect all parallelograms with the circle.Both solutions have complexity O(nm). As noted above, it is possible to solve the problem using integer arithemetics (that is, with absolute precision); however, the fact that the points' coordinates are small lets most of the solutions with floating point arithmetics pass. It was tempting to write an approximate numerical solution; we struggled hard not to let such solutions pass, and eventually none of them did. =)Many participants had troubles with pretest 8. It looks as follows (the left spiral revolves around the left point, and the right spiral revolves around the right point):Challenge: suppose we want a solution that uses floating point arithmetics to fail. In order to do that, we want to construct a test such that the polygons don't collide but pass really close to each other. How small a (positive) distance we can achieve, given the same constraints for the number of points and the points' coordinates?497E - Subsequences ReturnConsider some string; how does one count the number of its distinct subsequences? Let us append symbols to the string consequently and each time count the number of subsequences that were not present before. Let's append a symbol c to a string s; in the string s + c there are as many subsequences that end in c as there were subsequences in s overall. Add all these subsequences to the number of subsequnces of s; now each subsequence is counted once, except for the subsequences that end in c but were already present in s before; these are counted twice. Thus, the total number of subsequences in the new string is twice the total number of subsequences in the old string minus the number of subsequences in the old string which end in c.This leads us to the following solution: for each symbol c store how many subsequences end in c, denote cntc. Append symbol c; now cntc becomes equal to the sum of all cnt's plus one (for the empty subsequence), and all the other cnt's do not change.For example, consider the first few symbols of the Thue-Morse sequence: ε — (0, 0) 0 — ( 0 + 0 + 1 = 1, 0) 01 — (1, 1 + 0 + 1 = 2) 011 — (1, 1 + 2 + 1 = 4) 0110 — ( 1 + 4 + 1 = 6, 4) ... Let us put the values of cnt in the coordinates of a vector, and also append a coordinate which is always equal to 1. It is now clear that appending a symbol to the string alters the vector as a multiplication by some matrix. Let us assign a matrix for each symbol, and also for each string as a product of matrices for the symbols of the strings in that order.Now, consider the prefix of the sequence ai of length km. Divide it into k parts of length km - 1; x-th (0-based) of these parts can be obtained from the 0-th one by adding x modulo k to all elements of the part. Let us count the matrices (see above) for the prefixes of length km, and also for all strings that are obtained by adding x to all of the prefixes' elements; denote such matrix Am, x.It is easy to see that if m > 0, then . This formula allows us to count Am, x for all and all x from 0 to k - 1 in time. Now, upon having all Am, x we can multiply some of them in the right order to obtain the matrix for the prefix of the sequence ai of length n.Unfortunately, this is not quite enough as the solution doesn't fit the time limit yet. Here is one way to speed up sufficiently: note that the product in the formula can be divided as shown: Am - 1, x... Am - 1, k - 1 × Am - 1, 0... Am - 1, x - 1 (if x = 0, take the second part to be empty). Count all the \"prefixes\" and \"suffixes\" products of the set Am, x: Pm, x = Am, 0... Am, x - 1, Sm, x = Am, x... Am, k - 1. Now Am, x = Sm - 1, xPm - 1, x. Thus, the computation of Am, x for all x and a given m can be done as computing all Pm - 1, x, Sm - 1, x using O(k) matrix multiplications, and each Am, x is now can be found using one matrix multiplication. Finally, the solution now works in time, which fits the limits by a margin.Challenge: solve the problem for k ≤ 100.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/15208",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 496\\s*E"
          },
          "content_length": 12568
        },
        {
          "title": "Codeforces Round #283: editorial (with bonuses!) - Codeforces",
          "content": "Each problem comes with a challenge — a bonus task somehow related to the problem; you may tackle at the challenges for fun and practice, also feel free to discuss them at the comments. =)496A - Minimum DifficultyFor every option of removing an element we run through the remaining elements and find the maximal difference between adjacent ones; print the smallest found answer. The solution has complexity O(n2). It can be noticed that after removing an element the difficulty either stays the same or becomes equal to the difference between the neighbours of the removed element (whatever is larger); thus, the difficulty for every option of removing an element can be found in O(1), for the total complexity of O(n). Any of these solutions (or even less efficient ones) could pass the tests.Challenge: suppose we now have to remove exactly k arbitrary elements (but the first and the last elements have to stay in their places). How small the maximal difference between adjacent elements can become? Solve this problem assuming the limitations are as follows: 1 ≤ k ≤ n - 2, n ≤ 105, ai ≤ 109.496B - Secret CombinationWe observe that the order of operations is not important: we may first perform all the shifts, and after that all the additions. Note that after n shifts the sequence returns to its original state, therefore it is sufficient to consider only the options with less than n shifts. Also, after 10 times of adding 1 to all digits the sequence does not change; we may consider only options with less than 10 additions. Thus, there are overall 10n reasonable options for performing the operations; for every option perform the operations and find the smallest answer among all the options. As performing the operations for every option and comparing two answers to choose the best takes O(n) operations, this solution performs about 10n2 elementary operations. The multiple of 10 can be get rid of, if we note that after all shifts are made the best choice is to make the first digit equal to zero, and this leaves us but a single option for the number of additions. However, implementing this optimization is not necessary to get accepted.Challenge: can you solve the problem in time? in O(n) time?496C - Removing Columns/497A - Removing ColumnsLet's look at the first column of the table. If its letters are not sorted alphabetically, then in any valid choice of removing some columns it has to be removed. However, if its letters are sorted, then for every valid choice that has this column removed it can be restored back to the table; it is clear that the new choice is valid (that is, the rows of the new table are sorted lexicographically) and the answer (that is, the number of removed columns) has just became smaller.Consider all columns from left to right. We have already chosen which columns to remove among all the columns to the left of the current one; if leaving the current column in place breaks the lexicographical order of rows, then we have to remove it; otherwise, we may leave it in place to no harm. Arguing in the way of the previous paragraph we can prove that this greedy method yields an optimal (moreover, the only optimal) solution. The complexity is O(n2).Challenge: compute how many (say, modulo 109 + 7) n × m tables are there for which the answer for this problem is k? The more efficient solution you come up with, the better.496D - Tennis Game/497B - Tennis GameChoose some t; now emulate how the match will go, ensure that the record is valid for this t and by the way find the corresponding value of s. Print all valid options for s and t. This solution works in O(n2) time, which is not good enough, but we will try to optimize it.Suppose the current set if finished and we have processed k serves by now. Let us process the next set as follows: find t-th 1 and t-th 2 after position k. If t-th 1 occurs earlier, then the first player wins the set, and the set concludes right after the t-th 1; the other case is handled symmetrically. If the match is not over yet, and in the rest of the record there are no t ones nor t twos, then the record is clearly invalid. This way, every single set in the record can be processed in time using binary search, or O(1) time using precomputed arrays of positions for each player.Now observe that for any t a match of n serves can not contain more than n / t sets, as each set contains at least t serves. If we sum up the upper limits for the number of sets for each t, we obtain the total upper limit for the number of sets we may need to process: (which is the famous harmonic sum). Using one of the approaches discussed above, one obtains a solution with complexity of or ; each of these solutions fits the limit nicely.Obviously, for every t there is no more than one valid choice for s; however, maybe a bit unexpected, for a given s there may exist more than one valid choice of t. The first test where this takes place is pretest 12. The statement requires that the pairs are printed lexicographically ordered; it is possible to make a mistake here and print the pairs with equal s by descending t (if we fill the array by increasing t and then simply reverse the array).Challenge: while preparing this problem I discovered that it's quite hard to find a test such that the number of pairs in the answer is large; in the actual tests the maximal number is 128, which is the number of divisors of the number 83160. Can you beat this record? If you have a test with n ≤ 105 that has larger number of pairs in the answer, feel free to brag in the comments; also don't hesitate to share any insights on how one could bound the maximal number analytically.496E - Distributing Parts /497C - Distributing Parts Sort all the parts and actors altogether by increasing lower bounds (if equal, actors precede parts); process all the enitities in this order. We maintain a set of actors which have already occured in the order; if we meet an entry for an actor, add it to the set. If we currently process a part, we have to assign it to an actor; from the current set of actors we have to choose one such that his di ≥ bj (the ci ≤ aj constraint is provided by the fact that the i-th actor has occured earlier than the j-th part); if there are no such actors in the set, no answer can be obtained; if there are several actors satisftying this requirement, we should choose one with minimal di (intuitively, he will be less useful in the future). Assign the chosen actor with the current part and decrement his ki; if ki is now zero, the actor can not be used anymore, thus we remove him from the set.To fit the limits we should implement the set of current actors as some efficient data structure (e.g., an std::set or a treap). The resulting complexity is .Challenge: suppose that now there are qj copies of the j-th part (1 ≤ qj ≤ 109), and each copy must be separately assigned with an actor in a valid way. Can you solve this new problem with all the old constraints (as the actual distribution now has too much entries, it is sufficient to check whether an answer exists)?497D - GearsWhen a collision happens, a vertex of one polygon lands on a side of the other polygon. Consider a reference system such that the polygon A is not moving. In this system the polygon B preserves its orientation (that is, does not rotate), and each of its vertices moves on some circle. Intersect all the circles for vertices of B with all the sides of A; if any of them intersect, then some vertex of B collides with a side of A. Symmetrically, take a reference system associated with B and check whether some vertex of A collides with a side of B. The constraints for the points' coordinates are small enough for a solution with absolute precision to be possible (using built-in integer types).Another approach (which is, in fact, basically the same) is such: suppose there is a collision in a reference system associated with A. Then the following equality for vectors holds: x + y = z; here z is a vector that starts at P and ends somewhere on the bound of A, x is a vector that starts at Q and ends somewhere on the bound of B, y is a vector that starts at P and ends somewhere on the circle centered at P that passes through Q. Rewrite the equality as y = z - x; now observe that the set of all possible values of z - x forms the Minkowski sum of A and reflection of B (up to some shift), and the set of all possible values of y is a circle with known parameters. The Minkowski sum can be represented as a union of nm parallelograms, each of which is the Minkowski sum of a pair of sides of different polygons; finally, intersect all parallelograms with the circle.Both solutions have complexity O(nm). As noted above, it is possible to solve the problem using integer arithemetics (that is, with absolute precision); however, the fact that the points' coordinates are small lets most of the solutions with floating point arithmetics pass. It was tempting to write an approximate numerical solution; we struggled hard not to let such solutions pass, and eventually none of them did. =)Many participants had troubles with pretest 8. It looks as follows (the left spiral revolves around the left point, and the right spiral revolves around the right point):Challenge: suppose we want a solution that uses floating point arithmetics to fail. In order to do that, we want to construct a test such that the polygons don't collide but pass really close to each other. How small a (positive) distance we can achieve, given the same constraints for the number of points and the points' coordinates?497E - Subsequences ReturnConsider some string; how does one count the number of its distinct subsequences? Let us append symbols to the string consequently and each time count the number of subsequences that were not present before. Let's append a symbol c to a string s; in the string s + c there are as many subsequences that end in c as there were subsequences in s overall. Add all these subsequences to the number of subsequnces of s; now each subsequence is counted once, except for the subsequences that end in c but were already present in s before; these are counted twice. Thus, the total number of subsequences in the new string is twice the total number of subsequences in the old string minus the number of subsequences in the old string which end in c.This leads us to the following solution: for each symbol c store how many subsequences end in c, denote cntc. Append symbol c; now cntc becomes equal to the sum of all cnt's plus one (for the empty subsequence), and all the other cnt's do not change.For example, consider the first few symbols of the Thue-Morse sequence: ε — (0, 0) 0 — ( 0 + 0 + 1 = 1, 0) 01 — (1, 1 + 0 + 1 = 2) 011 — (1, 1 + 2 + 1 = 4) 0110 — ( 1 + 4 + 1 = 6, 4) ... Let us put the values of cnt in the coordinates of a vector, and also append a coordinate which is always equal to 1. It is now clear that appending a symbol to the string alters the vector as a multiplication by some matrix. Let us assign a matrix for each symbol, and also for each string as a product of matrices for the symbols of the strings in that order.Now, consider the prefix of the sequence ai of length km. Divide it into k parts of length km - 1; x-th (0-based) of these parts can be obtained from the 0-th one by adding x modulo k to all elements of the part. Let us count the matrices (see above) for the prefixes of length km, and also for all strings that are obtained by adding x to all of the prefixes' elements; denote such matrix Am, x.It is easy to see that if m > 0, then . This formula allows us to count Am, x for all and all x from 0 to k - 1 in time. Now, upon having all Am, x we can multiply some of them in the right order to obtain the matrix for the prefix of the sequence ai of length n.Unfortunately, this is not quite enough as the solution doesn't fit the time limit yet. Here is one way to speed up sufficiently: note that the product in the formula can be divided as shown: Am - 1, x... Am - 1, k - 1 × Am - 1, 0... Am - 1, x - 1 (if x = 0, take the second part to be empty). Count all the \"prefixes\" and \"suffixes\" products of the set Am, x: Pm, x = Am, 0... Am, x - 1, Sm, x = Am, x... Am, k - 1. Now Am, x = Sm - 1, xPm - 1, x. Thus, the computation of Am, x for all x and a given m can be done as computing all Pm - 1, x, Sm - 1, x using O(k) matrix multiplications, and each Am, x is now can be found using one matrix multiplication. Finally, the solution now works in time, which fits the limits by a margin.Challenge: solve the problem for k ≤ 100.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/15208",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 496\\s*E"
          },
          "content_length": 12568
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #283 - Codeforces - Code 1",
          "code": "18\n2 2   2 2   2 2   1 2 1   1 2 1   1 2 1   1 2 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15197",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #283 - Codeforces - Code 2",
          "code": "18\n2 2   2 2   2 2   1 2 1   1 2 1   1 2 1   1 2 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15197",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #283 - Codeforces - Code 3",
          "code": "ans[ac]=i;\n       ac++;\n    }\n}\nreturn ac;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15197",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #283 - Codeforces - Code 4",
          "code": "ans[ac]=i;\n       ac++;\n    }\n}\nreturn ac;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15197",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #283 - Codeforces - Code 5",
          "code": "cin>>n;\nfor (int i=0;i<n;i++) cin>>a[i];\nfor (int i=0;i<n;i++) {\n    if (a[i]==1) x++; else y++;\n    f[i]=max(x,y);\n}\nint z=fact(f[n-1]);\nif (x==y) {\n    cout<<\"0\";\n} else {\n    cout<<ac<<endl;\n    for (int i=0;i<ac;i++) {\n       cout<<ans[i]<<\" \"<<f[n-1]/ans[i]<<endl;\n    }\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15197",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #283 - Codeforces - Code 6",
          "code": "cin>>n;\nfor (int i=0;i<n;i++) cin>>a[i];\nfor (int i=0;i<n;i++) {\n    if (a[i]==1) x++; else y++;\n    f[i]=max(x,y);\n}\nint z=fact(f[n-1]);\nif (x==y) {\n    cout<<\"0\";\n} else {\n    cout<<ac<<endl;\n    for (int i=0;i<ac;i++) {\n       cout<<ans[i]<<\" \"<<f[n-1]/ans[i]<<endl;\n    }\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15197",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #283 - Codeforces - Code 7",
          "code": "ae ae et oe",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15197",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #283 - Codeforces - Code 8",
          "code": "20\n1 1 2 2 2 2 2 2 2 2 2 2 1 2 2 1 2 2 2 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15197",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #283 - Codeforces - Code 9",
          "code": "20\n1 1 2 2 2 2 2 2 2 2 2 2 1 2 2 1 2 2 2 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15197",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #283: editorial (with bonuses!) - Codeforces - Code 1",
          "code": "496D - Tennis Game",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15208",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #283: editorial (with bonuses!) - Codeforces - Code 2",
          "code": "number of valid (s,t) will be 0 if the total number of points of player who won  the last point is less than or equal to another player",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15208",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #283: editorial (with bonuses!) - Codeforces - Code 3",
          "code": "strictly more",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15208",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #283: editorial (with bonuses!) - Codeforces - Code 4",
          "code": "The Minkowski sum can be represented as a union of nm parallelograms, each of which is the Minkowski sum of a pair of sides of different polygons;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15208",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #283: editorial (with bonuses!) - Codeforces - Code 5",
          "code": "circle_segment",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15208",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #283: editorial (with bonuses!) - Codeforces - Code 6",
          "code": "ll dmax = (max((a - c) | (a - c), (a - b) | (a - b))); -> ll dmax = (max((a - c) | (a - c), (b - c) | (b - c)));",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15208",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #283: editorial (with bonuses!) - Codeforces - Code 7",
          "code": "ll dmax = (max((a - c) | (a - c), (a - b) | (a - b))); -> ll dmax = (max((a - c) | (a - c), (b - c) | (b - c)));",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15208",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #283: editorial (with bonuses!) - Codeforces - Code 1",
          "code": "496D - Tennis Game",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15208",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #283: editorial (with bonuses!) - Codeforces - Code 2",
          "code": "number of valid (s,t) will be 0 if the total number of points of player who won  the last point is less than or equal to another player",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15208",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #283: editorial (with bonuses!) - Codeforces - Code 3",
          "code": "strictly more",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15208",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #283: editorial (with bonuses!) - Codeforces - Code 4",
          "code": "The Minkowski sum can be represented as a union of nm parallelograms, each of which is the Minkowski sum of a pair of sides of different polygons;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15208",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #283: editorial (with bonuses!) - Codeforces - Code 5",
          "code": "circle_segment",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15208",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #283: editorial (with bonuses!) - Codeforces - Code 6",
          "code": "ll dmax = (max((a - c) | (a - c), (a - b) | (a - b))); -> ll dmax = (max((a - c) | (a - c), (b - c) | (b - c)));",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15208",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #283: editorial (with bonuses!) - Codeforces - Code 7",
          "code": "ll dmax = (max((a - c) | (a - c), (a - b) | (a - b))); -> ll dmax = (max((a - c) | (a - c), (b - c) | (b - c)));",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15208",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n    for(int i = 0; i < n; ++i) {\n        int a_j = inf.readInt(1, 1000000000, \"aj\");\n        inf.readSpace();\n        int b_j = inf.readInt(a_j, 1000000000, \"bj\");\n        inf.readEoln();\n    }\n\n    int m = inf.readInt(1, 100000, \"m\");\n    inf.readEoln();\n    for(int i = 0; i < m; ++i) {\n        int c_i = inf.readInt(1, 1000000000, \"ci\");\n        inf.readSpace();\n        int d_i = inf.readInt(c_i, 1000000000, \"di\");\n        inf.readSpace();\n        int k_i = inf.readInt(1, 1000000000, \"ki\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n    for(int i = 0; i < n; ++i) {\n        int a_j = inf.readInt(1, 1000000000, \"aj\");\n        inf.readSpace();\n        int b_j = inf.readInt(a_j, 1000000000, \"bj\");\n        inf.readEoln();\n    }\n\n    int m = inf.readInt(1, 100000, \"m\");\n    inf.readEoln();\n    for(int i = 0; i < m; ++i) {\n        int c_i = inf.readInt(1, 1000000000, \"ci\");\n        inf.readSpace();\n        int d_i = inf.readInt(c_i, 1000000000, \"di\");\n        inf.readSpace();\n        int k_i = inf.readInt(1, 1000000000, \"ki\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n    for(int i = 0; i < n; ++i) {\n        int a_j = inf.readInt(1, 1000000000, \"aj\");\n        inf.readSpace();\n        int b_j = inf.readInt(a_j, 1000000000, \"bj\");\n        inf.readEoln();\n    }\n\n    int m = inf.readInt(1, 100000, \"m\");\n    inf.readEoln();\n    for(int i = 0; i < m; ++i) {\n        int c_i = inf.readInt(1, 1000000000, \"ci\");\n        inf.readSpace();\n        int d_i = inf.readInt(c_i, 1000000000, \"di\");\n        inf.readSpace();\n        int k_i = inf.readInt(1, 1000000000, \"ki\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint n, m;\n\nvector<pair<int, int>> parts;\nvector<tuple<int, int, long long>> actors;\n\nvoid readAndCheckAssignment(InStream& in) {\n    vector<int> assignment = in.readInts(n, 1, m);\n    if (!in.seekEof()) {\n        in.quitf(_wa, \"Extra data in output after assignment\");\n    }\n    vector<long long> actorAssignedParts(m, 0);\n    for (int i = 0; i < n; ++i) {\n        int actorIndex = assignment[i] - 1;\n        int aj = parts[i].first;\n        int bj = parts[i].second;\n        int ci = get<0>(actors[actorIndex]);\n        int di = get<1>(actors[actorIndex]);\n        if (!(ci <= aj && bj <= di)) {\n            in.quitf(_wa, \"Actor %d cannot perform part %d\", actorIndex + 1, i + 1);\n        }\n        actorAssignedParts[actorIndex] += 1;\n    }\n    for (int i = 0; i < m; ++i) {\n        long long ki = get<2>(actors[i]);\n        if (actorAssignedParts[i] > ki) {\n            in.quitf(_wa, \"Actor %d is assigned %lld parts but can perform at most %lld parts\", i + 1, actorAssignedParts[i], ki);\n        }\n    }\n}\n\nint main(int argc, char* argv[]) {\n    registerTestlibCmd(argc, argv);\n\n    // Read input data\n    n = inf.readInt();\n    parts.resize(n);\n    for (int i = 0; i < n; ++i) {\n        int aj = inf.readInt();\n        int bj = inf.readInt();\n        parts[i] = make_pair(aj, bj);\n    }\n\n    m = inf.readInt();\n    actors.resize(m);\n    for (int i = 0; i < m; ++i) {\n        int ci = inf.readInt();\n        int di = inf.readInt();\n        long long ki = inf.readLong();\n        actors[i] = make_tuple(ci, di, ki);\n    }\n\n    // Read jury's answer\n    string jans = ans.readToken();\n    if (jans != \"YES\" && jans != \"NO\") {\n        quitf(_fail, \"Jury's answer is neither 'YES' nor 'NO', got '%s'\", jans.c_str());\n    }\n\n    // Read participant's answer\n    string pans = ouf.readToken();\n    if (pans != \"YES\" && pans != \"NO\") {\n        quitf(_wa, \"Contestant's answer is neither 'YES' nor 'NO', got '%s'\", pans.c_str());\n    }\n\n    if (pans == \"NO\") {\n        if (jans == \"YES\") {\n            quitf(_wa, \"Contestant says 'NO' but solution exists\");\n        } else {\n            // Both say 'NO' - accept\n            quitf(_ok, \"No solution exists\");\n        }\n    } else {\n        // Contestant says 'YES', check their assignment\n        readAndCheckAssignment(ouf);\n        // If we reach here, contestant's assignment is valid\n        quitf(_ok, \"Contestant's assignment is valid\");\n    }\n\n    // Should not reach here\n    quitf(_fail, \"Unexpected end of checker\");\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<ll> a(n), b(n);\n    vector<ll> c(m), d(m);\n    vector<ll> k(m);\n\n    if (type == \"random\") {\n        // Random actors with ki[i] = n\n        for (int i = 0; i < m; ++i) {\n            c[i] = rnd.next(1LL, 1000000000LL);\n            d[i] = rnd.next(c[i], 1000000000LL);\n            k[i] = n;\n        }\n\n        // Generate parts, each can be performed by an actor\n        for (int i = 0; i < n; ++i) {\n            int actor = rnd.next(0, m - 1);\n            ll aj = rnd.next(c[actor], d[actor]);\n            ll bj = rnd.next(aj, d[actor]);\n            a[i] = aj;\n            b[i] = bj;\n        }\n    } else if (type == \"impossible\") {\n        // Generate parts that cannot be performed by any actor\n        for (int i = 0; i < m; ++i) {\n            c[i] = rnd.next(500000000LL, 1000000000LL);\n            d[i] = rnd.next(c[i], 1000000000LL);\n            k[i] = 1;\n        }\n        for (int i = 0; i < n; ++i) {\n            ll aj = rnd.next(1LL, 499999999LL);\n            ll bj = rnd.next(aj, 499999999LL);\n            a[i] = aj;\n            b[i] = bj;\n        }\n    } else if (type == \"max_ki\") {\n        // Actors with maximum ki\n        for (int i = 0; i < m; ++i) {\n            c[i] = rnd.next(1LL, 1000000000LL);\n            d[i] = rnd.next(c[i], 1000000000LL);\n            k[i] = 1000000000LL;\n        }\n        for (int i = 0; i < n; ++i) {\n            int actor = rnd.next(0, m - 1);\n            ll aj = rnd.next(c[actor], d[actor]);\n            ll bj = rnd.next(aj, d[actor]);\n            a[i] = aj;\n            b[i] = bj;\n        }\n    } else if (type == \"min_ki\") {\n        // Actors with ki = 1\n        for (int i = 0; i < m; ++i) {\n            c[i] = rnd.next(1LL, 1000000000LL);\n            d[i] = rnd.next(c[i], 1000000000LL);\n            k[i] = 1;\n        }\n        ll total_k = m;\n        if (total_k < n) {\n            // The assignment is likely impossible\n        }\n        for (int i = 0; i < n; ++i) {\n            int actor = i % m;\n            ll aj = rnd.next(c[actor], d[actor]);\n            ll bj = rnd.next(aj, d[actor]);\n            a[i] = aj;\n            b[i] = bj;\n        }\n    } else if (type == \"single_note\") {\n        // Parts and actors have single note ranges\n        for (int i = 0; i < m; ++i) {\n            c[i] = rnd.next(1LL, 1000000000LL);\n            d[i] = c[i];\n            k[i] = rnd.next(1, n);\n        }\n        for (int i = 0; i < n; ++i) {\n            int actor = rnd.next(0, m - 1);\n            ll aj = c[actor];\n            a[i] = aj;\n            b[i] = aj;\n        }\n    } else {\n        // Default random case\n        for (int i = 0; i < m; ++i) {\n            c[i] = rnd.next(1LL, 1000000000LL);\n            d[i] = rnd.next(c[i], 1000000000LL);\n            k[i] = n;\n        }\n        for (int i = 0; i < n; ++i) {\n            int actor = rnd.next(0, m - 1);\n            ll aj = rnd.next(c[actor], d[actor]);\n            ll bj = rnd.next(aj, d[actor]);\n            a[i] = aj;\n            b[i] = bj;\n        }\n    }\n\n    // Output the test case\n    printf(\"%d\\n\", n);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%lld %lld\\n\", a[i], b[i]);\n    }\n    printf(\"%d\\n\", m);\n    for (int i = 0; i < m; ++i) {\n        printf(\"%lld %lld %lld\\n\", c[i], d[i], k[i]);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<ll> a(n), b(n);\n    vector<ll> c(m), d(m);\n    vector<ll> k(m);\n\n    if (type == \"random\") {\n        // Random actors with ki[i] = n\n        for (int i = 0; i < m; ++i) {\n            c[i] = rnd.next(1LL, 1000000000LL);\n            d[i] = rnd.next(c[i], 1000000000LL);\n            k[i] = n;\n        }\n\n        // Generate parts, each can be performed by an actor\n        for (int i = 0; i < n; ++i) {\n            int actor = rnd.next(0, m - 1);\n            ll aj = rnd.next(c[actor], d[actor]);\n            ll bj = rnd.next(aj, d[actor]);\n            a[i] = aj;\n            b[i] = bj;\n        }\n    } else if (type == \"impossible\") {\n        // Generate parts that cannot be performed by any actor\n        for (int i = 0; i < m; ++i) {\n            c[i] = rnd.next(500000000LL, 1000000000LL);\n            d[i] = rnd.next(c[i], 1000000000LL);\n            k[i] = 1;\n        }\n        for (int i = 0; i < n; ++i) {\n            ll aj = rnd.next(1LL, 499999999LL);\n            ll bj = rnd.next(aj, 499999999LL);\n            a[i] = aj;\n            b[i] = bj;\n        }\n    } else if (type == \"max_ki\") {\n        // Actors with maximum ki\n        for (int i = 0; i < m; ++i) {\n            c[i] = rnd.next(1LL, 1000000000LL);\n            d[i] = rnd.next(c[i], 1000000000LL);\n            k[i] = 1000000000LL;\n        }\n        for (int i = 0; i < n; ++i) {\n            int actor = rnd.next(0, m - 1);\n            ll aj = rnd.next(c[actor], d[actor]);\n            ll bj = rnd.next(aj, d[actor]);\n            a[i] = aj;\n            b[i] = bj;\n        }\n    } else if (type == \"min_ki\") {\n        // Actors with ki = 1\n        for (int i = 0; i < m; ++i) {\n            c[i] = rnd.next(1LL, 1000000000LL);\n            d[i] = rnd.next(c[i], 1000000000LL);\n            k[i] = 1;\n        }\n        ll total_k = m;\n        if (total_k < n) {\n            // The assignment is likely impossible\n        }\n        for (int i = 0; i < n; ++i) {\n            int actor = i % m;\n            ll aj = rnd.next(c[actor], d[actor]);\n            ll bj = rnd.next(aj, d[actor]);\n            a[i] = aj;\n            b[i] = bj;\n        }\n    } else if (type == \"single_note\") {\n        // Parts and actors have single note ranges\n        for (int i = 0; i < m; ++i) {\n            c[i] = rnd.next(1LL, 1000000000LL);\n            d[i] = c[i];\n            k[i] = rnd.next(1, n);\n        }\n        for (int i = 0; i < n; ++i) {\n            int actor = rnd.next(0, m - 1);\n            ll aj = c[actor];\n            a[i] = aj;\n            b[i] = aj;\n        }\n    } else {\n        // Default random case\n        for (int i = 0; i < m; ++i) {\n            c[i] = rnd.next(1LL, 1000000000LL);\n            d[i] = rnd.next(c[i], 1000000000LL);\n            k[i] = n;\n        }\n        for (int i = 0; i < n; ++i) {\n            int actor = rnd.next(0, m - 1);\n            ll aj = rnd.next(c[actor], d[actor]);\n            ll bj = rnd.next(aj, d[actor]);\n            a[i] = aj;\n            b[i] = bj;\n        }\n    }\n\n    // Output the test case\n    printf(\"%d\\n\", n);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%lld %lld\\n\", a[i], b[i]);\n    }\n    printf(\"%d\\n\", m);\n    for (int i = 0; i < m; ++i) {\n        printf(\"%lld %lld %lld\\n\", c[i], d[i], k[i]);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 5 -m 2 -type random\n./gen -n 10 -m 5 -type random\n./gen -n 1000 -m 1000 -type random\n./gen -n 100000 -m 100000 -type random\n\n./gen -n 5 -m 2 -type impossible\n./gen -n 10 -m 5 -type impossible\n./gen -n 1000 -m 500 -type impossible\n./gen -n 100000 -m 1000 -type impossible\n\n./gen -n 5 -m 2 -type max_ki\n./gen -n 1000 -m 100 -type max_ki\n./gen -n 100000 -m 1000 -type max_ki\n\n./gen -n 5 -m 2 -type min_ki\n./gen -n 10 -m 5 -type min_ki\n./gen -n 1000 -m 10 -type min_ki\n./gen -n 100000 -m 100 -type min_ki\n\n./gen -n 5 -m 5 -type single_note\n./gen -n 1000 -m 1000 -type single_note\n./gen -n 50000 -m 50000 -type single_note\n\n./gen -n 100000 -m 100000 -type random\n./gen -n 100000 -m 100000 -type impossible\n./gen -n 100000 -m 100000 -type max_ki\n./gen -n 100000 -m 100000 -type min_ki\n./gen -n 100000 -m 100000 -type single_note\n\n./gen -n 1 -m 1 -type random\n./gen -n 2 -m 1 -type impossible\n./gen -n 10 -m 2 -type max_ki\n./gen -n 1000 -m 1 -type min_ki\n./gen -n 100000 -m 1 -type single_note\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:39:08.204857",
        "total_tutorials": 3,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "497/A",
      "title": "A. Removing Columns",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains two integers  — n and m (1 ≤ n, m ≤ 100).Next n lines contain m small English letters each — the characters of the table.",
      "output_spec": "OutputPrint a single number — the minimum number of columns that you need to remove in order to make the table good.",
      "sample_tests": "ExamplesInputCopy1 10codeforcesOutputCopy0InputCopy4 4casecaretestcodeOutputCopy2InputCopy5 4codeforcescodeforcesOutputCopy4",
      "description": "A. Removing Columns\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains two integers  — n and m (1 ≤ n, m ≤ 100).Next n lines contain m small English letters each — the characters of the table.\n\nOutputPrint a single number — the minimum number of columns that you need to remove in order to make the table good.\n\nInputCopy1 10codeforcesOutputCopy0InputCopy4 4casecaretestcodeOutputCopy2InputCopy5 4codeforcescodeforcesOutputCopy4\n\nInputCopy1 10codeforces\n\nOutputCopy0\n\nInputCopy4 4casecaretestcode\n\nOutputCopy2\n\nInputCopy5 4codeforcescodeforces\n\nOutputCopy4\n\nNoteIn the first sample the table is already good.In the second sample you may remove the first and third column.In the third sample you have to remove all the columns (note that the table where all rows are empty is considered good by definition).Let strings s and t have equal length. Then, s is lexicographically larger than t if they are not equal and the character following the largest common prefix of s and t (the prefix may be empty) in s is alphabetically larger than the corresponding character of t.",
      "solutions": [
        {
          "title": "Codeforces Round #283 - Codeforces",
          "content": "Hi, Codeforces.Today, on December 17 at 19:30 MSK regular, 283-rd Codeforces round will take place. Problems are authored by me, Mikhail Tikhomirov. Maxim Akhmedov (Zlobober) helped me with discussing and preparing the problemset, Maria Belova (Delinur) translated problem statements in English, and Georgy Chebanov (gchebanov), Alexander Mashrabov (map) and Niyaz Nigmatullin (niyaznigmatul) tested the round and helped us with finding bugs and mistakes; let's give them a round of applause!The round will be for both divisions. The scoring is standard (not dynamic); score distribution is as follows:Div. 1: 750-1250-1250-2000-2500Div. 2: 500-1000-1750-2250-2250This is going to be my fourth round at Codeforces. I really hope it will go as good as three before it. =) Wish you all the best of luck!UPD: the round is over, thanks for participating!Grats to the winners:Div. 1: SirShokoladina Petr rowdark anta Marcin_smu Merkurev qwer1561 Ra16bit kuviman Um_nik Div. 2: SergeyMelnikov sepehr103 StarCuriosity dotato husheyn Editorial is here ( UPD: now in English!).",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/15197",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1068
        },
        {
          "title": "Codeforces Round #283: editorial (with bonuses!) - Codeforces",
          "content": "Each problem comes with a challenge — a bonus task somehow related to the problem; you may tackle at the challenges for fun and practice, also feel free to discuss them at the comments. =)496A - Minimum DifficultyFor every option of removing an element we run through the remaining elements and find the maximal difference between adjacent ones; print the smallest found answer. The solution has complexity O(n2). It can be noticed that after removing an element the difficulty either stays the same or becomes equal to the difference between the neighbours of the removed element (whatever is larger); thus, the difficulty for every option of removing an element can be found in O(1), for the total complexity of O(n). Any of these solutions (or even less efficient ones) could pass the tests.Challenge: suppose we now have to remove exactly k arbitrary elements (but the first and the last elements have to stay in their places). How small the maximal difference between adjacent elements can become? Solve this problem assuming the limitations are as follows: 1 ≤ k ≤ n - 2, n ≤ 105, ai ≤ 109.496B - Secret CombinationWe observe that the order of operations is not important: we may first perform all the shifts, and after that all the additions. Note that after n shifts the sequence returns to its original state, therefore it is sufficient to consider only the options with less than n shifts. Also, after 10 times of adding 1 to all digits the sequence does not change; we may consider only options with less than 10 additions. Thus, there are overall 10n reasonable options for performing the operations; for every option perform the operations and find the smallest answer among all the options. As performing the operations for every option and comparing two answers to choose the best takes O(n) operations, this solution performs about 10n2 elementary operations. The multiple of 10 can be get rid of, if we note that after all shifts are made the best choice is to make the first digit equal to zero, and this leaves us but a single option for the number of additions. However, implementing this optimization is not necessary to get accepted.Challenge: can you solve the problem in time? in O(n) time?496C - Removing Columns/497A - Removing ColumnsLet's look at the first column of the table. If its letters are not sorted alphabetically, then in any valid choice of removing some columns it has to be removed. However, if its letters are sorted, then for every valid choice that has this column removed it can be restored back to the table; it is clear that the new choice is valid (that is, the rows of the new table are sorted lexicographically) and the answer (that is, the number of removed columns) has just became smaller.Consider all columns from left to right. We have already chosen which columns to remove among all the columns to the left of the current one; if leaving the current column in place breaks the lexicographical order of rows, then we have to remove it; otherwise, we may leave it in place to no harm. Arguing in the way of the previous paragraph we can prove that this greedy method yields an optimal (moreover, the only optimal) solution. The complexity is O(n2).Challenge: compute how many (say, modulo 109 + 7) n × m tables are there for which the answer for this problem is k? The more efficient solution you come up with, the better.496D - Tennis Game/497B - Tennis GameChoose some t; now emulate how the match will go, ensure that the record is valid for this t and by the way find the corresponding value of s. Print all valid options for s and t. This solution works in O(n2) time, which is not good enough, but we will try to optimize it.Suppose the current set if finished and we have processed k serves by now. Let us process the next set as follows: find t-th 1 and t-th 2 after position k. If t-th 1 occurs earlier, then the first player wins the set, and the set concludes right after the t-th 1; the other case is handled symmetrically. If the match is not over yet, and in the rest of the record there are no t ones nor t twos, then the record is clearly invalid. This way, every single set in the record can be processed in time using binary search, or O(1) time using precomputed arrays of positions for each player.Now observe that for any t a match of n serves can not contain more than n / t sets, as each set contains at least t serves. If we sum up the upper limits for the number of sets for each t, we obtain the total upper limit for the number of sets we may need to process: (which is the famous harmonic sum). Using one of the approaches discussed above, one obtains a solution with complexity of or ; each of these solutions fits the limit nicely.Obviously, for every t there is no more than one valid choice for s; however, maybe a bit unexpected, for a given s there may exist more than one valid choice of t. The first test where this takes place is pretest 12. The statement requires that the pairs are printed lexicographically ordered; it is possible to make a mistake here and print the pairs with equal s by descending t (if we fill the array by increasing t and then simply reverse the array).Challenge: while preparing this problem I discovered that it's quite hard to find a test such that the number of pairs in the answer is large; in the actual tests the maximal number is 128, which is the number of divisors of the number 83160. Can you beat this record? If you have a test with n ≤ 105 that has larger number of pairs in the answer, feel free to brag in the comments; also don't hesitate to share any insights on how one could bound the maximal number analytically.496E - Distributing Parts /497C - Distributing Parts Sort all the parts and actors altogether by increasing lower bounds (if equal, actors precede parts); process all the enitities in this order. We maintain a set of actors which have already occured in the order; if we meet an entry for an actor, add it to the set. If we currently process a part, we have to assign it to an actor; from the current set of actors we have to choose one such that his di ≥ bj (the ci ≤ aj constraint is provided by the fact that the i-th actor has occured earlier than the j-th part); if there are no such actors in the set, no answer can be obtained; if there are several actors satisftying this requirement, we should choose one with minimal di (intuitively, he will be less useful in the future). Assign the chosen actor with the current part and decrement his ki; if ki is now zero, the actor can not be used anymore, thus we remove him from the set.To fit the limits we should implement the set of current actors as some efficient data structure (e.g., an std::set or a treap). The resulting complexity is .Challenge: suppose that now there are qj copies of the j-th part (1 ≤ qj ≤ 109), and each copy must be separately assigned with an actor in a valid way. Can you solve this new problem with all the old constraints (as the actual distribution now has too much entries, it is sufficient to check whether an answer exists)?497D - GearsWhen a collision happens, a vertex of one polygon lands on a side of the other polygon. Consider a reference system such that the polygon A is not moving. In this system the polygon B preserves its orientation (that is, does not rotate), and each of its vertices moves on some circle. Intersect all the circles for vertices of B with all the sides of A; if any of them intersect, then some vertex of B collides with a side of A. Symmetrically, take a reference system associated with B and check whether some vertex of A collides with a side of B. The constraints for the points' coordinates are small enough for a solution with absolute precision to be possible (using built-in integer types).Another approach (which is, in fact, basically the same) is such: suppose there is a collision in a reference system associated with A. Then the following equality for vectors holds: x + y = z; here z is a vector that starts at P and ends somewhere on the bound of A, x is a vector that starts at Q and ends somewhere on the bound of B, y is a vector that starts at P and ends somewhere on the circle centered at P that passes through Q. Rewrite the equality as y = z - x; now observe that the set of all possible values of z - x forms the Minkowski sum of A and reflection of B (up to some shift), and the set of all possible values of y is a circle with known parameters. The Minkowski sum can be represented as a union of nm parallelograms, each of which is the Minkowski sum of a pair of sides of different polygons; finally, intersect all parallelograms with the circle.Both solutions have complexity O(nm). As noted above, it is possible to solve the problem using integer arithemetics (that is, with absolute precision); however, the fact that the points' coordinates are small lets most of the solutions with floating point arithmetics pass. It was tempting to write an approximate numerical solution; we struggled hard not to let such solutions pass, and eventually none of them did. =)Many participants had troubles with pretest 8. It looks as follows (the left spiral revolves around the left point, and the right spiral revolves around the right point):Challenge: suppose we want a solution that uses floating point arithmetics to fail. In order to do that, we want to construct a test such that the polygons don't collide but pass really close to each other. How small a (positive) distance we can achieve, given the same constraints for the number of points and the points' coordinates?497E - Subsequences ReturnConsider some string; how does one count the number of its distinct subsequences? Let us append symbols to the string consequently and each time count the number of subsequences that were not present before. Let's append a symbol c to a string s; in the string s + c there are as many subsequences that end in c as there were subsequences in s overall. Add all these subsequences to the number of subsequnces of s; now each subsequence is counted once, except for the subsequences that end in c but were already present in s before; these are counted twice. Thus, the total number of subsequences in the new string is twice the total number of subsequences in the old string minus the number of subsequences in the old string which end in c.This leads us to the following solution: for each symbol c store how many subsequences end in c, denote cntc. Append symbol c; now cntc becomes equal to the sum of all cnt's plus one (for the empty subsequence), and all the other cnt's do not change.For example, consider the first few symbols of the Thue-Morse sequence: ε — (0, 0) 0 — ( 0 + 0 + 1 = 1, 0) 01 — (1, 1 + 0 + 1 = 2) 011 — (1, 1 + 2 + 1 = 4) 0110 — ( 1 + 4 + 1 = 6, 4) ... Let us put the values of cnt in the coordinates of a vector, and also append a coordinate which is always equal to 1. It is now clear that appending a symbol to the string alters the vector as a multiplication by some matrix. Let us assign a matrix for each symbol, and also for each string as a product of matrices for the symbols of the strings in that order.Now, consider the prefix of the sequence ai of length km. Divide it into k parts of length km - 1; x-th (0-based) of these parts can be obtained from the 0-th one by adding x modulo k to all elements of the part. Let us count the matrices (see above) for the prefixes of length km, and also for all strings that are obtained by adding x to all of the prefixes' elements; denote such matrix Am, x.It is easy to see that if m > 0, then . This formula allows us to count Am, x for all and all x from 0 to k - 1 in time. Now, upon having all Am, x we can multiply some of them in the right order to obtain the matrix for the prefix of the sequence ai of length n.Unfortunately, this is not quite enough as the solution doesn't fit the time limit yet. Here is one way to speed up sufficiently: note that the product in the formula can be divided as shown: Am - 1, x... Am - 1, k - 1 × Am - 1, 0... Am - 1, x - 1 (if x = 0, take the second part to be empty). Count all the \"prefixes\" and \"suffixes\" products of the set Am, x: Pm, x = Am, 0... Am, x - 1, Sm, x = Am, x... Am, k - 1. Now Am, x = Sm - 1, xPm - 1, x. Thus, the computation of Am, x for all x and a given m can be done as computing all Pm - 1, x, Sm - 1, x using O(k) matrix multiplications, and each Am, x is now can be found using one matrix multiplication. Finally, the solution now works in time, which fits the limits by a margin.Challenge: solve the problem for k ≤ 100.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/15208",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 497\\s*A"
          },
          "content_length": 12568
        },
        {
          "title": "Codeforces Round #283: editorial (with bonuses!) - Codeforces",
          "content": "Each problem comes with a challenge — a bonus task somehow related to the problem; you may tackle at the challenges for fun and practice, also feel free to discuss them at the comments. =)496A - Minimum DifficultyFor every option of removing an element we run through the remaining elements and find the maximal difference between adjacent ones; print the smallest found answer. The solution has complexity O(n2). It can be noticed that after removing an element the difficulty either stays the same or becomes equal to the difference between the neighbours of the removed element (whatever is larger); thus, the difficulty for every option of removing an element can be found in O(1), for the total complexity of O(n). Any of these solutions (or even less efficient ones) could pass the tests.Challenge: suppose we now have to remove exactly k arbitrary elements (but the first and the last elements have to stay in their places). How small the maximal difference between adjacent elements can become? Solve this problem assuming the limitations are as follows: 1 ≤ k ≤ n - 2, n ≤ 105, ai ≤ 109.496B - Secret CombinationWe observe that the order of operations is not important: we may first perform all the shifts, and after that all the additions. Note that after n shifts the sequence returns to its original state, therefore it is sufficient to consider only the options with less than n shifts. Also, after 10 times of adding 1 to all digits the sequence does not change; we may consider only options with less than 10 additions. Thus, there are overall 10n reasonable options for performing the operations; for every option perform the operations and find the smallest answer among all the options. As performing the operations for every option and comparing two answers to choose the best takes O(n) operations, this solution performs about 10n2 elementary operations. The multiple of 10 can be get rid of, if we note that after all shifts are made the best choice is to make the first digit equal to zero, and this leaves us but a single option for the number of additions. However, implementing this optimization is not necessary to get accepted.Challenge: can you solve the problem in time? in O(n) time?496C - Removing Columns/497A - Removing ColumnsLet's look at the first column of the table. If its letters are not sorted alphabetically, then in any valid choice of removing some columns it has to be removed. However, if its letters are sorted, then for every valid choice that has this column removed it can be restored back to the table; it is clear that the new choice is valid (that is, the rows of the new table are sorted lexicographically) and the answer (that is, the number of removed columns) has just became smaller.Consider all columns from left to right. We have already chosen which columns to remove among all the columns to the left of the current one; if leaving the current column in place breaks the lexicographical order of rows, then we have to remove it; otherwise, we may leave it in place to no harm. Arguing in the way of the previous paragraph we can prove that this greedy method yields an optimal (moreover, the only optimal) solution. The complexity is O(n2).Challenge: compute how many (say, modulo 109 + 7) n × m tables are there for which the answer for this problem is k? The more efficient solution you come up with, the better.496D - Tennis Game/497B - Tennis GameChoose some t; now emulate how the match will go, ensure that the record is valid for this t and by the way find the corresponding value of s. Print all valid options for s and t. This solution works in O(n2) time, which is not good enough, but we will try to optimize it.Suppose the current set if finished and we have processed k serves by now. Let us process the next set as follows: find t-th 1 and t-th 2 after position k. If t-th 1 occurs earlier, then the first player wins the set, and the set concludes right after the t-th 1; the other case is handled symmetrically. If the match is not over yet, and in the rest of the record there are no t ones nor t twos, then the record is clearly invalid. This way, every single set in the record can be processed in time using binary search, or O(1) time using precomputed arrays of positions for each player.Now observe that for any t a match of n serves can not contain more than n / t sets, as each set contains at least t serves. If we sum up the upper limits for the number of sets for each t, we obtain the total upper limit for the number of sets we may need to process: (which is the famous harmonic sum). Using one of the approaches discussed above, one obtains a solution with complexity of or ; each of these solutions fits the limit nicely.Obviously, for every t there is no more than one valid choice for s; however, maybe a bit unexpected, for a given s there may exist more than one valid choice of t. The first test where this takes place is pretest 12. The statement requires that the pairs are printed lexicographically ordered; it is possible to make a mistake here and print the pairs with equal s by descending t (if we fill the array by increasing t and then simply reverse the array).Challenge: while preparing this problem I discovered that it's quite hard to find a test such that the number of pairs in the answer is large; in the actual tests the maximal number is 128, which is the number of divisors of the number 83160. Can you beat this record? If you have a test with n ≤ 105 that has larger number of pairs in the answer, feel free to brag in the comments; also don't hesitate to share any insights on how one could bound the maximal number analytically.496E - Distributing Parts /497C - Distributing Parts Sort all the parts and actors altogether by increasing lower bounds (if equal, actors precede parts); process all the enitities in this order. We maintain a set of actors which have already occured in the order; if we meet an entry for an actor, add it to the set. If we currently process a part, we have to assign it to an actor; from the current set of actors we have to choose one such that his di ≥ bj (the ci ≤ aj constraint is provided by the fact that the i-th actor has occured earlier than the j-th part); if there are no such actors in the set, no answer can be obtained; if there are several actors satisftying this requirement, we should choose one with minimal di (intuitively, he will be less useful in the future). Assign the chosen actor with the current part and decrement his ki; if ki is now zero, the actor can not be used anymore, thus we remove him from the set.To fit the limits we should implement the set of current actors as some efficient data structure (e.g., an std::set or a treap). The resulting complexity is .Challenge: suppose that now there are qj copies of the j-th part (1 ≤ qj ≤ 109), and each copy must be separately assigned with an actor in a valid way. Can you solve this new problem with all the old constraints (as the actual distribution now has too much entries, it is sufficient to check whether an answer exists)?497D - GearsWhen a collision happens, a vertex of one polygon lands on a side of the other polygon. Consider a reference system such that the polygon A is not moving. In this system the polygon B preserves its orientation (that is, does not rotate), and each of its vertices moves on some circle. Intersect all the circles for vertices of B with all the sides of A; if any of them intersect, then some vertex of B collides with a side of A. Symmetrically, take a reference system associated with B and check whether some vertex of A collides with a side of B. The constraints for the points' coordinates are small enough for a solution with absolute precision to be possible (using built-in integer types).Another approach (which is, in fact, basically the same) is such: suppose there is a collision in a reference system associated with A. Then the following equality for vectors holds: x + y = z; here z is a vector that starts at P and ends somewhere on the bound of A, x is a vector that starts at Q and ends somewhere on the bound of B, y is a vector that starts at P and ends somewhere on the circle centered at P that passes through Q. Rewrite the equality as y = z - x; now observe that the set of all possible values of z - x forms the Minkowski sum of A and reflection of B (up to some shift), and the set of all possible values of y is a circle with known parameters. The Minkowski sum can be represented as a union of nm parallelograms, each of which is the Minkowski sum of a pair of sides of different polygons; finally, intersect all parallelograms with the circle.Both solutions have complexity O(nm). As noted above, it is possible to solve the problem using integer arithemetics (that is, with absolute precision); however, the fact that the points' coordinates are small lets most of the solutions with floating point arithmetics pass. It was tempting to write an approximate numerical solution; we struggled hard not to let such solutions pass, and eventually none of them did. =)Many participants had troubles with pretest 8. It looks as follows (the left spiral revolves around the left point, and the right spiral revolves around the right point):Challenge: suppose we want a solution that uses floating point arithmetics to fail. In order to do that, we want to construct a test such that the polygons don't collide but pass really close to each other. How small a (positive) distance we can achieve, given the same constraints for the number of points and the points' coordinates?497E - Subsequences ReturnConsider some string; how does one count the number of its distinct subsequences? Let us append symbols to the string consequently and each time count the number of subsequences that were not present before. Let's append a symbol c to a string s; in the string s + c there are as many subsequences that end in c as there were subsequences in s overall. Add all these subsequences to the number of subsequnces of s; now each subsequence is counted once, except for the subsequences that end in c but were already present in s before; these are counted twice. Thus, the total number of subsequences in the new string is twice the total number of subsequences in the old string minus the number of subsequences in the old string which end in c.This leads us to the following solution: for each symbol c store how many subsequences end in c, denote cntc. Append symbol c; now cntc becomes equal to the sum of all cnt's plus one (for the empty subsequence), and all the other cnt's do not change.For example, consider the first few symbols of the Thue-Morse sequence: ε — (0, 0) 0 — ( 0 + 0 + 1 = 1, 0) 01 — (1, 1 + 0 + 1 = 2) 011 — (1, 1 + 2 + 1 = 4) 0110 — ( 1 + 4 + 1 = 6, 4) ... Let us put the values of cnt in the coordinates of a vector, and also append a coordinate which is always equal to 1. It is now clear that appending a symbol to the string alters the vector as a multiplication by some matrix. Let us assign a matrix for each symbol, and also for each string as a product of matrices for the symbols of the strings in that order.Now, consider the prefix of the sequence ai of length km. Divide it into k parts of length km - 1; x-th (0-based) of these parts can be obtained from the 0-th one by adding x modulo k to all elements of the part. Let us count the matrices (see above) for the prefixes of length km, and also for all strings that are obtained by adding x to all of the prefixes' elements; denote such matrix Am, x.It is easy to see that if m > 0, then . This formula allows us to count Am, x for all and all x from 0 to k - 1 in time. Now, upon having all Am, x we can multiply some of them in the right order to obtain the matrix for the prefix of the sequence ai of length n.Unfortunately, this is not quite enough as the solution doesn't fit the time limit yet. Here is one way to speed up sufficiently: note that the product in the formula can be divided as shown: Am - 1, x... Am - 1, k - 1 × Am - 1, 0... Am - 1, x - 1 (if x = 0, take the second part to be empty). Count all the \"prefixes\" and \"suffixes\" products of the set Am, x: Pm, x = Am, 0... Am, x - 1, Sm, x = Am, x... Am, k - 1. Now Am, x = Sm - 1, xPm - 1, x. Thus, the computation of Am, x for all x and a given m can be done as computing all Pm - 1, x, Sm - 1, x using O(k) matrix multiplications, and each Am, x is now can be found using one matrix multiplication. Finally, the solution now works in time, which fits the limits by a margin.Challenge: solve the problem for k ≤ 100.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/15208",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 497\\s*A"
          },
          "content_length": 12568
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #283 - Codeforces - Code 1",
          "code": "18\n2 2   2 2   2 2   1 2 1   1 2 1   1 2 1   1 2 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15197",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #283 - Codeforces - Code 2",
          "code": "18\n2 2   2 2   2 2   1 2 1   1 2 1   1 2 1   1 2 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15197",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #283 - Codeforces - Code 3",
          "code": "ans[ac]=i;\n       ac++;\n    }\n}\nreturn ac;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15197",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #283 - Codeforces - Code 4",
          "code": "ans[ac]=i;\n       ac++;\n    }\n}\nreturn ac;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15197",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #283 - Codeforces - Code 5",
          "code": "cin>>n;\nfor (int i=0;i<n;i++) cin>>a[i];\nfor (int i=0;i<n;i++) {\n    if (a[i]==1) x++; else y++;\n    f[i]=max(x,y);\n}\nint z=fact(f[n-1]);\nif (x==y) {\n    cout<<\"0\";\n} else {\n    cout<<ac<<endl;\n    for (int i=0;i<ac;i++) {\n       cout<<ans[i]<<\" \"<<f[n-1]/ans[i]<<endl;\n    }\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15197",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #283 - Codeforces - Code 6",
          "code": "cin>>n;\nfor (int i=0;i<n;i++) cin>>a[i];\nfor (int i=0;i<n;i++) {\n    if (a[i]==1) x++; else y++;\n    f[i]=max(x,y);\n}\nint z=fact(f[n-1]);\nif (x==y) {\n    cout<<\"0\";\n} else {\n    cout<<ac<<endl;\n    for (int i=0;i<ac;i++) {\n       cout<<ans[i]<<\" \"<<f[n-1]/ans[i]<<endl;\n    }\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15197",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #283 - Codeforces - Code 7",
          "code": "ae ae et oe",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15197",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #283 - Codeforces - Code 8",
          "code": "20\n1 1 2 2 2 2 2 2 2 2 2 2 1 2 2 1 2 2 2 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15197",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #283 - Codeforces - Code 9",
          "code": "20\n1 1 2 2 2 2 2 2 2 2 2 2 1 2 2 1 2 2 2 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15197",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #283: editorial (with bonuses!) - Codeforces - Code 1",
          "code": "496D - Tennis Game",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15208",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #283: editorial (with bonuses!) - Codeforces - Code 2",
          "code": "number of valid (s,t) will be 0 if the total number of points of player who won  the last point is less than or equal to another player",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15208",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #283: editorial (with bonuses!) - Codeforces - Code 3",
          "code": "strictly more",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15208",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #283: editorial (with bonuses!) - Codeforces - Code 4",
          "code": "The Minkowski sum can be represented as a union of nm parallelograms, each of which is the Minkowski sum of a pair of sides of different polygons;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15208",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #283: editorial (with bonuses!) - Codeforces - Code 5",
          "code": "circle_segment",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15208",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #283: editorial (with bonuses!) - Codeforces - Code 6",
          "code": "ll dmax = (max((a - c) | (a - c), (a - b) | (a - b))); -> ll dmax = (max((a - c) | (a - c), (b - c) | (b - c)));",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15208",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #283: editorial (with bonuses!) - Codeforces - Code 7",
          "code": "ll dmax = (max((a - c) | (a - c), (a - b) | (a - b))); -> ll dmax = (max((a - c) | (a - c), (b - c) | (b - c)));",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15208",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #283: editorial (with bonuses!) - Codeforces - Code 1",
          "code": "496D - Tennis Game",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15208",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #283: editorial (with bonuses!) - Codeforces - Code 2",
          "code": "number of valid (s,t) will be 0 if the total number of points of player who won  the last point is less than or equal to another player",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15208",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #283: editorial (with bonuses!) - Codeforces - Code 3",
          "code": "strictly more",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15208",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #283: editorial (with bonuses!) - Codeforces - Code 4",
          "code": "The Minkowski sum can be represented as a union of nm parallelograms, each of which is the Minkowski sum of a pair of sides of different polygons;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15208",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #283: editorial (with bonuses!) - Codeforces - Code 5",
          "code": "circle_segment",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15208",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #283: editorial (with bonuses!) - Codeforces - Code 6",
          "code": "ll dmax = (max((a - c) | (a - c), (a - b) | (a - b))); -> ll dmax = (max((a - c) | (a - c), (b - c) | (b - c)));",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15208",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #283: editorial (with bonuses!) - Codeforces - Code 7",
          "code": "ll dmax = (max((a - c) | (a - c), (a - b) | (a - b))); -> ll dmax = (max((a - c) | (a - c), (b - c) | (b - c)));",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15208",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 100, \"m\");\n    inf.readEoln();\n\n    string pattern = \"[a-z]{\" + to_string(m) + \"}\";\n\n    for (int i = 0; i < n; ++i) {\n        inf.readLine(pattern, \"line \" + to_string(i + 1));\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 100, \"m\");\n    inf.readEoln();\n\n    string pattern = \"[a-z]{\" + to_string(m) + \"}\";\n\n    for (int i = 0; i < n; ++i) {\n        inf.readLine(pattern, \"line \" + to_string(i + 1));\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 100, \"m\");\n    inf.readEoln();\n\n    string pattern = \"[a-z]{\" + to_string(m) + \"}\";\n\n    for (int i = 0; i < n; ++i) {\n        inf.readLine(pattern, \"line \" + to_string(i + 1));\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<string> grid(n);\n\n    if (type == \"sorted\") {\n        // Generate random strings and sort them in lex order\n        for (int i = 0; i < n; ++i) {\n            string s(m, 'a');\n            for (int j = 0; j < m; ++j) {\n                s[j] = rnd.next('a', 'z');\n            }\n            grid[i] = s;\n        }\n        sort(grid.begin(), grid.end());\n    } else if (type == \"reverse\") {\n        // Generate random strings and sort them in reverse lex order\n        for (int i = 0; i < n; ++i) {\n            string s(m, 'a');\n            for (int j = 0; j < m; ++j) {\n                s[j] = rnd.next('a', 'z');\n            }\n            grid[i] = s;\n        }\n        sort(grid.begin(), grid.end(), greater<string>());\n    } else if (type == \"random\") {\n        // Generate n random strings of length m\n        for (int i = 0; i < n; ++i) {\n            string s(m, 'a');\n            for (int j = 0; j < m; ++j) {\n                s[j] = rnd.next('a', 'z');\n            }\n            grid[i] = s;\n        }\n    } else if (type == \"same\") {\n        // All rows are the same\n        string s(m, 'a');\n        for (int j = 0; j < m; ++j) {\n            s[j] = rnd.next('a', 'z');\n        }\n        for (int i = 0; i < n; ++i) {\n            grid[i] = s;\n        }\n    } else {\n        cerr << \"Unknown type: \" << type << endl;\n        return 1;\n    }\n\n    // Output\n    printf(\"%d %d\\n\", n, m);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%s\\n\", grid[i].c_str());\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<string> grid(n);\n\n    if (type == \"sorted\") {\n        // Generate random strings and sort them in lex order\n        for (int i = 0; i < n; ++i) {\n            string s(m, 'a');\n            for (int j = 0; j < m; ++j) {\n                s[j] = rnd.next('a', 'z');\n            }\n            grid[i] = s;\n        }\n        sort(grid.begin(), grid.end());\n    } else if (type == \"reverse\") {\n        // Generate random strings and sort them in reverse lex order\n        for (int i = 0; i < n; ++i) {\n            string s(m, 'a');\n            for (int j = 0; j < m; ++j) {\n                s[j] = rnd.next('a', 'z');\n            }\n            grid[i] = s;\n        }\n        sort(grid.begin(), grid.end(), greater<string>());\n    } else if (type == \"random\") {\n        // Generate n random strings of length m\n        for (int i = 0; i < n; ++i) {\n            string s(m, 'a');\n            for (int j = 0; j < m; ++j) {\n                s[j] = rnd.next('a', 'z');\n            }\n            grid[i] = s;\n        }\n    } else if (type == \"same\") {\n        // All rows are the same\n        string s(m, 'a');\n        for (int j = 0; j < m; ++j) {\n            s[j] = rnd.next('a', 'z');\n        }\n        for (int i = 0; i < n; ++i) {\n            grid[i] = s;\n        }\n    } else {\n        cerr << \"Unknown type: \" << type << endl;\n        return 1;\n    }\n\n    // Output\n    printf(\"%d %d\\n\", n, m);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%s\\n\", grid[i].c_str());\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -m 1 -type sorted\n./gen -n 1 -m 1 -type random\n./gen -n 1 -m 1 -type reverse\n./gen -n 1 -m 1 -type same\n\n./gen -n 100 -m 100 -type sorted\n./gen -n 100 -m 100 -type reverse\n./gen -n 100 -m 100 -type random\n./gen -n 100 -m 100 -type same\n\n./gen -n 50 -m 50 -type sorted\n./gen -n 50 -m 50 -type reverse\n./gen -n 50 -m 50 -type random\n./gen -n 50 -m 50 -type same\n\n./gen -n 100 -m 1 -type sorted\n./gen -n 100 -m 1 -type reverse\n./gen -n 100 -m 1 -type random\n./gen -n 100 -m 1 -type same\n\n./gen -n 1 -m 100 -type sorted\n./gen -n 1 -m 100 -type reverse\n./gen -n 1 -m 100 -type random\n./gen -n 1 -m 100 -type same\n\n./gen -n 30 -m 70 -type sorted\n./gen -n 30 -m 70 -type reverse\n./gen -n 30 -m 70 -type random\n./gen -n 30 -m 70 -type same\n\n# Edge cases with maximum size\n./gen -n 100 -m 100 -type reverse\n./gen -n 100 -m 100 -type sorted\n\n# Test cases with maximum columns to remove\n./gen -n 100 -m 100 -type reverse\n\n# Test cases with all rows the same\n./gen -n 100 -m 100 -type same\n\n# Additional random test cases\n./gen -n 99 -m 99 -type random\n./gen -n 2 -m 2 -type random\n./gen -n 2 -m 100 -type random\n./gen -n 100 -m 2 -type random\n\n# Test cases with nearly sorted data\n./gen -n 100 -m 100 -type sorted\n# Manually shuffle a few rows to make the data nearly sorted (not directly supported by the generator, but illustrative)\n\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:39:10.214032",
        "total_tutorials": 3,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "497/B",
      "title": "B. Tennis Game",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains a single integer n — the length of the sequence of games (1 ≤ n ≤ 105).The second line contains n space-separated integers ai. If ai = 1, then the i-th serve was won by Petya, if ai = 2, then the i-th serve was won by Gena.It is not guaranteed that at least one option for numbers s and t corresponds to the given record.",
      "output_spec": "OutputIn the first line print a single number k — the number of options for numbers s and t.In each of the following k lines print two integers si and ti — the option for numbers s and t. Print the options in the order of increasing si, and for equal si — in the order of increasing ti.",
      "sample_tests": "ExamplesInputCopy51 2 1 2 1OutputCopy21 33 1InputCopy41 1 1 1OutputCopy31 42 24 1InputCopy41 2 1 2OutputCopy0InputCopy82 1 2 1 1 1 1 1OutputCopy31 62 36 1",
      "description": "B. Tennis Game\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains a single integer n — the length of the sequence of games (1 ≤ n ≤ 105).The second line contains n space-separated integers ai. If ai = 1, then the i-th serve was won by Petya, if ai = 2, then the i-th serve was won by Gena.It is not guaranteed that at least one option for numbers s and t corresponds to the given record.\n\nOutputIn the first line print a single number k — the number of options for numbers s and t.In each of the following k lines print two integers si and ti — the option for numbers s and t. Print the options in the order of increasing si, and for equal si — in the order of increasing ti.\n\nInputCopy51 2 1 2 1OutputCopy21 33 1InputCopy41 1 1 1OutputCopy31 42 24 1InputCopy41 2 1 2OutputCopy0InputCopy82 1 2 1 1 1 1 1OutputCopy31 62 36 1\n\nInputCopy51 2 1 2 1\n\nOutputCopy21 33 1\n\nInputCopy41 1 1 1\n\nOutputCopy31 42 24 1\n\nInputCopy41 2 1 2\n\nOutputCopy0\n\nInputCopy82 1 2 1 1 1 1 1\n\nOutputCopy31 62 36 1",
      "solutions": [
        {
          "title": "Codeforces Round #283 - Codeforces",
          "content": "Hi, Codeforces.Today, on December 17 at 19:30 MSK regular, 283-rd Codeforces round will take place. Problems are authored by me, Mikhail Tikhomirov. Maxim Akhmedov (Zlobober) helped me with discussing and preparing the problemset, Maria Belova (Delinur) translated problem statements in English, and Georgy Chebanov (gchebanov), Alexander Mashrabov (map) and Niyaz Nigmatullin (niyaznigmatul) tested the round and helped us with finding bugs and mistakes; let's give them a round of applause!The round will be for both divisions. The scoring is standard (not dynamic); score distribution is as follows:Div. 1: 750-1250-1250-2000-2500Div. 2: 500-1000-1750-2250-2250This is going to be my fourth round at Codeforces. I really hope it will go as good as three before it. =) Wish you all the best of luck!UPD: the round is over, thanks for participating!Grats to the winners:Div. 1: SirShokoladina Petr rowdark anta Marcin_smu Merkurev qwer1561 Ra16bit kuviman Um_nik Div. 2: SergeyMelnikov sepehr103 StarCuriosity dotato husheyn Editorial is here ( UPD: now in English!).",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/15197",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1068
        },
        {
          "title": "Codeforces Round #283: editorial (with bonuses!) - Codeforces",
          "content": "Each problem comes with a challenge — a bonus task somehow related to the problem; you may tackle at the challenges for fun and practice, also feel free to discuss them at the comments. =)496A - Minimum DifficultyFor every option of removing an element we run through the remaining elements and find the maximal difference between adjacent ones; print the smallest found answer. The solution has complexity O(n2). It can be noticed that after removing an element the difficulty either stays the same or becomes equal to the difference between the neighbours of the removed element (whatever is larger); thus, the difficulty for every option of removing an element can be found in O(1), for the total complexity of O(n). Any of these solutions (or even less efficient ones) could pass the tests.Challenge: suppose we now have to remove exactly k arbitrary elements (but the first and the last elements have to stay in their places). How small the maximal difference between adjacent elements can become? Solve this problem assuming the limitations are as follows: 1 ≤ k ≤ n - 2, n ≤ 105, ai ≤ 109.496B - Secret CombinationWe observe that the order of operations is not important: we may first perform all the shifts, and after that all the additions. Note that after n shifts the sequence returns to its original state, therefore it is sufficient to consider only the options with less than n shifts. Also, after 10 times of adding 1 to all digits the sequence does not change; we may consider only options with less than 10 additions. Thus, there are overall 10n reasonable options for performing the operations; for every option perform the operations and find the smallest answer among all the options. As performing the operations for every option and comparing two answers to choose the best takes O(n) operations, this solution performs about 10n2 elementary operations. The multiple of 10 can be get rid of, if we note that after all shifts are made the best choice is to make the first digit equal to zero, and this leaves us but a single option for the number of additions. However, implementing this optimization is not necessary to get accepted.Challenge: can you solve the problem in time? in O(n) time?496C - Removing Columns/497A - Removing ColumnsLet's look at the first column of the table. If its letters are not sorted alphabetically, then in any valid choice of removing some columns it has to be removed. However, if its letters are sorted, then for every valid choice that has this column removed it can be restored back to the table; it is clear that the new choice is valid (that is, the rows of the new table are sorted lexicographically) and the answer (that is, the number of removed columns) has just became smaller.Consider all columns from left to right. We have already chosen which columns to remove among all the columns to the left of the current one; if leaving the current column in place breaks the lexicographical order of rows, then we have to remove it; otherwise, we may leave it in place to no harm. Arguing in the way of the previous paragraph we can prove that this greedy method yields an optimal (moreover, the only optimal) solution. The complexity is O(n2).Challenge: compute how many (say, modulo 109 + 7) n × m tables are there for which the answer for this problem is k? The more efficient solution you come up with, the better.496D - Tennis Game/497B - Tennis GameChoose some t; now emulate how the match will go, ensure that the record is valid for this t and by the way find the corresponding value of s. Print all valid options for s and t. This solution works in O(n2) time, which is not good enough, but we will try to optimize it.Suppose the current set if finished and we have processed k serves by now. Let us process the next set as follows: find t-th 1 and t-th 2 after position k. If t-th 1 occurs earlier, then the first player wins the set, and the set concludes right after the t-th 1; the other case is handled symmetrically. If the match is not over yet, and in the rest of the record there are no t ones nor t twos, then the record is clearly invalid. This way, every single set in the record can be processed in time using binary search, or O(1) time using precomputed arrays of positions for each player.Now observe that for any t a match of n serves can not contain more than n / t sets, as each set contains at least t serves. If we sum up the upper limits for the number of sets for each t, we obtain the total upper limit for the number of sets we may need to process: (which is the famous harmonic sum). Using one of the approaches discussed above, one obtains a solution with complexity of or ; each of these solutions fits the limit nicely.Obviously, for every t there is no more than one valid choice for s; however, maybe a bit unexpected, for a given s there may exist more than one valid choice of t. The first test where this takes place is pretest 12. The statement requires that the pairs are printed lexicographically ordered; it is possible to make a mistake here and print the pairs with equal s by descending t (if we fill the array by increasing t and then simply reverse the array).Challenge: while preparing this problem I discovered that it's quite hard to find a test such that the number of pairs in the answer is large; in the actual tests the maximal number is 128, which is the number of divisors of the number 83160. Can you beat this record? If you have a test with n ≤ 105 that has larger number of pairs in the answer, feel free to brag in the comments; also don't hesitate to share any insights on how one could bound the maximal number analytically.496E - Distributing Parts /497C - Distributing Parts Sort all the parts and actors altogether by increasing lower bounds (if equal, actors precede parts); process all the enitities in this order. We maintain a set of actors which have already occured in the order; if we meet an entry for an actor, add it to the set. If we currently process a part, we have to assign it to an actor; from the current set of actors we have to choose one such that his di ≥ bj (the ci ≤ aj constraint is provided by the fact that the i-th actor has occured earlier than the j-th part); if there are no such actors in the set, no answer can be obtained; if there are several actors satisftying this requirement, we should choose one with minimal di (intuitively, he will be less useful in the future). Assign the chosen actor with the current part and decrement his ki; if ki is now zero, the actor can not be used anymore, thus we remove him from the set.To fit the limits we should implement the set of current actors as some efficient data structure (e.g., an std::set or a treap). The resulting complexity is .Challenge: suppose that now there are qj copies of the j-th part (1 ≤ qj ≤ 109), and each copy must be separately assigned with an actor in a valid way. Can you solve this new problem with all the old constraints (as the actual distribution now has too much entries, it is sufficient to check whether an answer exists)?497D - GearsWhen a collision happens, a vertex of one polygon lands on a side of the other polygon. Consider a reference system such that the polygon A is not moving. In this system the polygon B preserves its orientation (that is, does not rotate), and each of its vertices moves on some circle. Intersect all the circles for vertices of B with all the sides of A; if any of them intersect, then some vertex of B collides with a side of A. Symmetrically, take a reference system associated with B and check whether some vertex of A collides with a side of B. The constraints for the points' coordinates are small enough for a solution with absolute precision to be possible (using built-in integer types).Another approach (which is, in fact, basically the same) is such: suppose there is a collision in a reference system associated with A. Then the following equality for vectors holds: x + y = z; here z is a vector that starts at P and ends somewhere on the bound of A, x is a vector that starts at Q and ends somewhere on the bound of B, y is a vector that starts at P and ends somewhere on the circle centered at P that passes through Q. Rewrite the equality as y = z - x; now observe that the set of all possible values of z - x forms the Minkowski sum of A and reflection of B (up to some shift), and the set of all possible values of y is a circle with known parameters. The Minkowski sum can be represented as a union of nm parallelograms, each of which is the Minkowski sum of a pair of sides of different polygons; finally, intersect all parallelograms with the circle.Both solutions have complexity O(nm). As noted above, it is possible to solve the problem using integer arithemetics (that is, with absolute precision); however, the fact that the points' coordinates are small lets most of the solutions with floating point arithmetics pass. It was tempting to write an approximate numerical solution; we struggled hard not to let such solutions pass, and eventually none of them did. =)Many participants had troubles with pretest 8. It looks as follows (the left spiral revolves around the left point, and the right spiral revolves around the right point):Challenge: suppose we want a solution that uses floating point arithmetics to fail. In order to do that, we want to construct a test such that the polygons don't collide but pass really close to each other. How small a (positive) distance we can achieve, given the same constraints for the number of points and the points' coordinates?497E - Subsequences ReturnConsider some string; how does one count the number of its distinct subsequences? Let us append symbols to the string consequently and each time count the number of subsequences that were not present before. Let's append a symbol c to a string s; in the string s + c there are as many subsequences that end in c as there were subsequences in s overall. Add all these subsequences to the number of subsequnces of s; now each subsequence is counted once, except for the subsequences that end in c but were already present in s before; these are counted twice. Thus, the total number of subsequences in the new string is twice the total number of subsequences in the old string minus the number of subsequences in the old string which end in c.This leads us to the following solution: for each symbol c store how many subsequences end in c, denote cntc. Append symbol c; now cntc becomes equal to the sum of all cnt's plus one (for the empty subsequence), and all the other cnt's do not change.For example, consider the first few symbols of the Thue-Morse sequence: ε — (0, 0) 0 — ( 0 + 0 + 1 = 1, 0) 01 — (1, 1 + 0 + 1 = 2) 011 — (1, 1 + 2 + 1 = 4) 0110 — ( 1 + 4 + 1 = 6, 4) ... Let us put the values of cnt in the coordinates of a vector, and also append a coordinate which is always equal to 1. It is now clear that appending a symbol to the string alters the vector as a multiplication by some matrix. Let us assign a matrix for each symbol, and also for each string as a product of matrices for the symbols of the strings in that order.Now, consider the prefix of the sequence ai of length km. Divide it into k parts of length km - 1; x-th (0-based) of these parts can be obtained from the 0-th one by adding x modulo k to all elements of the part. Let us count the matrices (see above) for the prefixes of length km, and also for all strings that are obtained by adding x to all of the prefixes' elements; denote such matrix Am, x.It is easy to see that if m > 0, then . This formula allows us to count Am, x for all and all x from 0 to k - 1 in time. Now, upon having all Am, x we can multiply some of them in the right order to obtain the matrix for the prefix of the sequence ai of length n.Unfortunately, this is not quite enough as the solution doesn't fit the time limit yet. Here is one way to speed up sufficiently: note that the product in the formula can be divided as shown: Am - 1, x... Am - 1, k - 1 × Am - 1, 0... Am - 1, x - 1 (if x = 0, take the second part to be empty). Count all the \"prefixes\" and \"suffixes\" products of the set Am, x: Pm, x = Am, 0... Am, x - 1, Sm, x = Am, x... Am, k - 1. Now Am, x = Sm - 1, xPm - 1, x. Thus, the computation of Am, x for all x and a given m can be done as computing all Pm - 1, x, Sm - 1, x using O(k) matrix multiplications, and each Am, x is now can be found using one matrix multiplication. Finally, the solution now works in time, which fits the limits by a margin.Challenge: solve the problem for k ≤ 100.",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/15208",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 497\\s*B"
          },
          "content_length": 12568
        },
        {
          "title": "Codeforces Round #283: editorial (with bonuses!) - Codeforces",
          "content": "Each problem comes with a challenge — a bonus task somehow related to the problem; you may tackle at the challenges for fun and practice, also feel free to discuss them at the comments. =)496A - Minimum DifficultyFor every option of removing an element we run through the remaining elements and find the maximal difference between adjacent ones; print the smallest found answer. The solution has complexity O(n2). It can be noticed that after removing an element the difficulty either stays the same or becomes equal to the difference between the neighbours of the removed element (whatever is larger); thus, the difficulty for every option of removing an element can be found in O(1), for the total complexity of O(n). Any of these solutions (or even less efficient ones) could pass the tests.Challenge: suppose we now have to remove exactly k arbitrary elements (but the first and the last elements have to stay in their places). How small the maximal difference between adjacent elements can become? Solve this problem assuming the limitations are as follows: 1 ≤ k ≤ n - 2, n ≤ 105, ai ≤ 109.496B - Secret CombinationWe observe that the order of operations is not important: we may first perform all the shifts, and after that all the additions. Note that after n shifts the sequence returns to its original state, therefore it is sufficient to consider only the options with less than n shifts. Also, after 10 times of adding 1 to all digits the sequence does not change; we may consider only options with less than 10 additions. Thus, there are overall 10n reasonable options for performing the operations; for every option perform the operations and find the smallest answer among all the options. As performing the operations for every option and comparing two answers to choose the best takes O(n) operations, this solution performs about 10n2 elementary operations. The multiple of 10 can be get rid of, if we note that after all shifts are made the best choice is to make the first digit equal to zero, and this leaves us but a single option for the number of additions. However, implementing this optimization is not necessary to get accepted.Challenge: can you solve the problem in time? in O(n) time?496C - Removing Columns/497A - Removing ColumnsLet's look at the first column of the table. If its letters are not sorted alphabetically, then in any valid choice of removing some columns it has to be removed. However, if its letters are sorted, then for every valid choice that has this column removed it can be restored back to the table; it is clear that the new choice is valid (that is, the rows of the new table are sorted lexicographically) and the answer (that is, the number of removed columns) has just became smaller.Consider all columns from left to right. We have already chosen which columns to remove among all the columns to the left of the current one; if leaving the current column in place breaks the lexicographical order of rows, then we have to remove it; otherwise, we may leave it in place to no harm. Arguing in the way of the previous paragraph we can prove that this greedy method yields an optimal (moreover, the only optimal) solution. The complexity is O(n2).Challenge: compute how many (say, modulo 109 + 7) n × m tables are there for which the answer for this problem is k? The more efficient solution you come up with, the better.496D - Tennis Game/497B - Tennis GameChoose some t; now emulate how the match will go, ensure that the record is valid for this t and by the way find the corresponding value of s. Print all valid options for s and t. This solution works in O(n2) time, which is not good enough, but we will try to optimize it.Suppose the current set if finished and we have processed k serves by now. Let us process the next set as follows: find t-th 1 and t-th 2 after position k. If t-th 1 occurs earlier, then the first player wins the set, and the set concludes right after the t-th 1; the other case is handled symmetrically. If the match is not over yet, and in the rest of the record there are no t ones nor t twos, then the record is clearly invalid. This way, every single set in the record can be processed in time using binary search, or O(1) time using precomputed arrays of positions for each player.Now observe that for any t a match of n serves can not contain more than n / t sets, as each set contains at least t serves. If we sum up the upper limits for the number of sets for each t, we obtain the total upper limit for the number of sets we may need to process: (which is the famous harmonic sum). Using one of the approaches discussed above, one obtains a solution with complexity of or ; each of these solutions fits the limit nicely.Obviously, for every t there is no more than one valid choice for s; however, maybe a bit unexpected, for a given s there may exist more than one valid choice of t. The first test where this takes place is pretest 12. The statement requires that the pairs are printed lexicographically ordered; it is possible to make a mistake here and print the pairs with equal s by descending t (if we fill the array by increasing t and then simply reverse the array).Challenge: while preparing this problem I discovered that it's quite hard to find a test such that the number of pairs in the answer is large; in the actual tests the maximal number is 128, which is the number of divisors of the number 83160. Can you beat this record? If you have a test with n ≤ 105 that has larger number of pairs in the answer, feel free to brag in the comments; also don't hesitate to share any insights on how one could bound the maximal number analytically.496E - Distributing Parts /497C - Distributing Parts Sort all the parts and actors altogether by increasing lower bounds (if equal, actors precede parts); process all the enitities in this order. We maintain a set of actors which have already occured in the order; if we meet an entry for an actor, add it to the set. If we currently process a part, we have to assign it to an actor; from the current set of actors we have to choose one such that his di ≥ bj (the ci ≤ aj constraint is provided by the fact that the i-th actor has occured earlier than the j-th part); if there are no such actors in the set, no answer can be obtained; if there are several actors satisftying this requirement, we should choose one with minimal di (intuitively, he will be less useful in the future). Assign the chosen actor with the current part and decrement his ki; if ki is now zero, the actor can not be used anymore, thus we remove him from the set.To fit the limits we should implement the set of current actors as some efficient data structure (e.g., an std::set or a treap). The resulting complexity is .Challenge: suppose that now there are qj copies of the j-th part (1 ≤ qj ≤ 109), and each copy must be separately assigned with an actor in a valid way. Can you solve this new problem with all the old constraints (as the actual distribution now has too much entries, it is sufficient to check whether an answer exists)?497D - GearsWhen a collision happens, a vertex of one polygon lands on a side of the other polygon. Consider a reference system such that the polygon A is not moving. In this system the polygon B preserves its orientation (that is, does not rotate), and each of its vertices moves on some circle. Intersect all the circles for vertices of B with all the sides of A; if any of them intersect, then some vertex of B collides with a side of A. Symmetrically, take a reference system associated with B and check whether some vertex of A collides with a side of B. The constraints for the points' coordinates are small enough for a solution with absolute precision to be possible (using built-in integer types).Another approach (which is, in fact, basically the same) is such: suppose there is a collision in a reference system associated with A. Then the following equality for vectors holds: x + y = z; here z is a vector that starts at P and ends somewhere on the bound of A, x is a vector that starts at Q and ends somewhere on the bound of B, y is a vector that starts at P and ends somewhere on the circle centered at P that passes through Q. Rewrite the equality as y = z - x; now observe that the set of all possible values of z - x forms the Minkowski sum of A and reflection of B (up to some shift), and the set of all possible values of y is a circle with known parameters. The Minkowski sum can be represented as a union of nm parallelograms, each of which is the Minkowski sum of a pair of sides of different polygons; finally, intersect all parallelograms with the circle.Both solutions have complexity O(nm). As noted above, it is possible to solve the problem using integer arithemetics (that is, with absolute precision); however, the fact that the points' coordinates are small lets most of the solutions with floating point arithmetics pass. It was tempting to write an approximate numerical solution; we struggled hard not to let such solutions pass, and eventually none of them did. =)Many participants had troubles with pretest 8. It looks as follows (the left spiral revolves around the left point, and the right spiral revolves around the right point):Challenge: suppose we want a solution that uses floating point arithmetics to fail. In order to do that, we want to construct a test such that the polygons don't collide but pass really close to each other. How small a (positive) distance we can achieve, given the same constraints for the number of points and the points' coordinates?497E - Subsequences ReturnConsider some string; how does one count the number of its distinct subsequences? Let us append symbols to the string consequently and each time count the number of subsequences that were not present before. Let's append a symbol c to a string s; in the string s + c there are as many subsequences that end in c as there were subsequences in s overall. Add all these subsequences to the number of subsequnces of s; now each subsequence is counted once, except for the subsequences that end in c but were already present in s before; these are counted twice. Thus, the total number of subsequences in the new string is twice the total number of subsequences in the old string minus the number of subsequences in the old string which end in c.This leads us to the following solution: for each symbol c store how many subsequences end in c, denote cntc. Append symbol c; now cntc becomes equal to the sum of all cnt's plus one (for the empty subsequence), and all the other cnt's do not change.For example, consider the first few symbols of the Thue-Morse sequence: ε — (0, 0) 0 — ( 0 + 0 + 1 = 1, 0) 01 — (1, 1 + 0 + 1 = 2) 011 — (1, 1 + 2 + 1 = 4) 0110 — ( 1 + 4 + 1 = 6, 4) ... Let us put the values of cnt in the coordinates of a vector, and also append a coordinate which is always equal to 1. It is now clear that appending a symbol to the string alters the vector as a multiplication by some matrix. Let us assign a matrix for each symbol, and also for each string as a product of matrices for the symbols of the strings in that order.Now, consider the prefix of the sequence ai of length km. Divide it into k parts of length km - 1; x-th (0-based) of these parts can be obtained from the 0-th one by adding x modulo k to all elements of the part. Let us count the matrices (see above) for the prefixes of length km, and also for all strings that are obtained by adding x to all of the prefixes' elements; denote such matrix Am, x.It is easy to see that if m > 0, then . This formula allows us to count Am, x for all and all x from 0 to k - 1 in time. Now, upon having all Am, x we can multiply some of them in the right order to obtain the matrix for the prefix of the sequence ai of length n.Unfortunately, this is not quite enough as the solution doesn't fit the time limit yet. Here is one way to speed up sufficiently: note that the product in the formula can be divided as shown: Am - 1, x... Am - 1, k - 1 × Am - 1, 0... Am - 1, x - 1 (if x = 0, take the second part to be empty). Count all the \"prefixes\" and \"suffixes\" products of the set Am, x: Pm, x = Am, 0... Am, x - 1, Sm, x = Am, x... Am, k - 1. Now Am, x = Sm - 1, xPm - 1, x. Thus, the computation of Am, x for all x and a given m can be done as computing all Pm - 1, x, Sm - 1, x using O(k) matrix multiplications, and each Am, x is now can be found using one matrix multiplication. Finally, the solution now works in time, which fits the limits by a margin.Challenge: solve the problem for k ≤ 100.",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/15208",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 497\\s*B"
          },
          "content_length": 12568
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #283 - Codeforces - Code 1",
          "code": "18\n2 2   2 2   2 2   1 2 1   1 2 1   1 2 1   1 2 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15197",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #283 - Codeforces - Code 2",
          "code": "18\n2 2   2 2   2 2   1 2 1   1 2 1   1 2 1   1 2 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15197",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #283 - Codeforces - Code 3",
          "code": "ans[ac]=i;\n       ac++;\n    }\n}\nreturn ac;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15197",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #283 - Codeforces - Code 4",
          "code": "ans[ac]=i;\n       ac++;\n    }\n}\nreturn ac;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15197",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #283 - Codeforces - Code 5",
          "code": "cin>>n;\nfor (int i=0;i<n;i++) cin>>a[i];\nfor (int i=0;i<n;i++) {\n    if (a[i]==1) x++; else y++;\n    f[i]=max(x,y);\n}\nint z=fact(f[n-1]);\nif (x==y) {\n    cout<<\"0\";\n} else {\n    cout<<ac<<endl;\n    for (int i=0;i<ac;i++) {\n       cout<<ans[i]<<\" \"<<f[n-1]/ans[i]<<endl;\n    }\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15197",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #283 - Codeforces - Code 6",
          "code": "cin>>n;\nfor (int i=0;i<n;i++) cin>>a[i];\nfor (int i=0;i<n;i++) {\n    if (a[i]==1) x++; else y++;\n    f[i]=max(x,y);\n}\nint z=fact(f[n-1]);\nif (x==y) {\n    cout<<\"0\";\n} else {\n    cout<<ac<<endl;\n    for (int i=0;i<ac;i++) {\n       cout<<ans[i]<<\" \"<<f[n-1]/ans[i]<<endl;\n    }\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15197",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #283 - Codeforces - Code 7",
          "code": "ae ae et oe",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15197",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #283 - Codeforces - Code 8",
          "code": "20\n1 1 2 2 2 2 2 2 2 2 2 2 1 2 2 1 2 2 2 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15197",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #283 - Codeforces - Code 9",
          "code": "20\n1 1 2 2 2 2 2 2 2 2 2 2 1 2 2 1 2 2 2 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15197",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #283: editorial (with bonuses!) - Codeforces - Code 1",
          "code": "496D - Tennis Game",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15208",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #283: editorial (with bonuses!) - Codeforces - Code 2",
          "code": "number of valid (s,t) will be 0 if the total number of points of player who won  the last point is less than or equal to another player",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15208",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #283: editorial (with bonuses!) - Codeforces - Code 3",
          "code": "strictly more",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15208",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #283: editorial (with bonuses!) - Codeforces - Code 4",
          "code": "The Minkowski sum can be represented as a union of nm parallelograms, each of which is the Minkowski sum of a pair of sides of different polygons;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15208",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #283: editorial (with bonuses!) - Codeforces - Code 5",
          "code": "circle_segment",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15208",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #283: editorial (with bonuses!) - Codeforces - Code 6",
          "code": "ll dmax = (max((a - c) | (a - c), (a - b) | (a - b))); -> ll dmax = (max((a - c) | (a - c), (b - c) | (b - c)));",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15208",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #283: editorial (with bonuses!) - Codeforces - Code 7",
          "code": "ll dmax = (max((a - c) | (a - c), (a - b) | (a - b))); -> ll dmax = (max((a - c) | (a - c), (b - c) | (b - c)));",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15208",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #283: editorial (with bonuses!) - Codeforces - Code 1",
          "code": "496D - Tennis Game",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15208",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #283: editorial (with bonuses!) - Codeforces - Code 2",
          "code": "number of valid (s,t) will be 0 if the total number of points of player who won  the last point is less than or equal to another player",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15208",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #283: editorial (with bonuses!) - Codeforces - Code 3",
          "code": "strictly more",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15208",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #283: editorial (with bonuses!) - Codeforces - Code 4",
          "code": "The Minkowski sum can be represented as a union of nm parallelograms, each of which is the Minkowski sum of a pair of sides of different polygons;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15208",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #283: editorial (with bonuses!) - Codeforces - Code 5",
          "code": "circle_segment",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15208",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #283: editorial (with bonuses!) - Codeforces - Code 6",
          "code": "ll dmax = (max((a - c) | (a - c), (a - b) | (a - b))); -> ll dmax = (max((a - c) | (a - c), (b - c) | (b - c)));",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15208",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #283: editorial (with bonuses!) - Codeforces - Code 7",
          "code": "ll dmax = (max((a - c) | (a - c), (a - b) | (a - b))); -> ll dmax = (max((a - c) | (a - c), (b - c) | (b - c)));",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15208",
          "author": "Qingyu"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    \n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n    vector<int> a = inf.readInts(n, 1, 2, \"a\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    \n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n    vector<int> a = inf.readInts(n, 1, 2, \"a\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    \n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n    vector<int> a = inf.readInts(n, 1, 2, \"a\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\n/*\n  This problem can indeed have multiple valid answers (pairs (s, t)), so we need\n  a custom checker rather than a built-in checker.\n\n  The checker below follows the common \"two-solution\" approach:\n   - First, read the jury's (correct) solution (from ans).\n   - Then, read the participant's solution (from ouf).\n   - Compare them in a lexicographical manner as sets:\n       1. If the participant has strictly fewer pairs, we report _wa.\n       2. If the participant has strictly more pairs, we report _fail.\n       3. If they have the same number of pairs, compare pair by pair:\n            - At the first mismatch, determine if the participant is missing\n              a pair the jury has (=> _wa) or has an extra pair the jury does not\n              have (=> _fail).\n       4. If there is no mismatch and the sizes match, we accept (_ok).\n\n  This matches the style demonstrated by the sample maximum-path checker,\n  where the jury and participant answers can both be correct solutions, but\n  the checker enforces that the participant’s solution must match the jury’s\n  solution exactly (in this problem, \"exactly\" means the same set of (s, t),\n  in the same sorted order, because the statement requires printing all possible\n  solutions in ascending order).\n*/\n\n/* Reads k and then k pairs from the given stream, ensuring:\n   1) They are sorted by (s_i, t_i) in ascending order,\n   2) No duplicate pairs.\n   Returns the vector of pairs. */\nvector<pair<int,int>> readSolution(InStream &stream, const string &label) {\n    int k = stream.readInt(0, 200000, (label + \": number of pairs k\").c_str());\n    // (The upper bound 200000 is arbitrary; just something reasonably large so that\n    //  we don't break on extreme participant answers. You can adjust if desired.)\n\n    vector<pair<int,int>> ans(k);\n    for(int i = 0; i < k; i++){\n        int s = stream.readInt(1, 1000000, (label + \": s_i\").c_str());\n        int t = stream.readInt(1, 1000000, (label + \": t_i\").c_str());\n        ans[i] = make_pair(s, t);\n    }\n\n    // Check sorting and no duplicates\n    for(int i = 1; i < k; i++){\n        if(ans[i] < ans[i-1]){\n            stream.quitf(_wa, \"%s is not sorted in ascending order at index %d\", label.c_str(), i);\n        }\n        if(ans[i] == ans[i-1]){\n            stream.quitf(_wa, \"%s contains duplicate pair (%d, %d) at index %d\",\n                         label.c_str(), ans[i].first, ans[i].second, i);\n        }\n    }\n\n    return ans;\n}\n\nint main(int argc, char* argv[]){\n    registerTestlibCmd(argc, argv);\n\n    // We read 'n' and the sequence from the input file,\n    // but we don't actually need them for this \"two-solution\" style checker.\n    // The official solution set is in ans, and we only compare that to ouf.\n    int n = inf.readInt();\n    for (int i = 0; i < n; i++){\n        inf.readInt(); // read and discard\n    }\n\n    // Read the full correct set of (s, t) from the jury's answer.\n    vector<pair<int,int>> jurySolution = readSolution(ans, \"jurySolution\");\n\n    // Read the participant's set of (s, t).\n    vector<pair<int,int>> partSolution = readSolution(ouf, \"participantSolution\");\n\n    // Compare sizes first.\n    if(partSolution.size() < jurySolution.size()){\n        quitf(_wa, \"participant found fewer solutions than jury\");\n    }\n    if(partSolution.size() > jurySolution.size()){\n        quitf(_fail, \"participant found more solutions than jury\");\n    }\n\n    // If sizes match, compare lexicographically.\n    for(size_t i = 0; i < jurySolution.size(); i++){\n        if(jurySolution[i] != partSolution[i]){\n            // Decide whether the participant is missing or adding something\n            if(jurySolution[i] < partSolution[i]){\n                // participant is missing a pair that jury has\n                quitf(_wa, \"mismatch at index %d: participant missing pair (%d, %d)\",\n                      (int)i, jurySolution[i].first, jurySolution[i].second);\n            } else {\n                // participant has an extra pair\n                quitf(_fail, \"mismatch at index %d: participant added pair (%d, %d)\",\n                      (int)i, partSolution[i].first, partSolution[i].second);\n            }\n        }\n    }\n\n    // If all pairs match exactly, we accept.\n    quitf(_ok, \"all solutions match\");\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> seq(n);\n\n    if (type == \"ones\") {\n        fill(seq.begin(), seq.end(), 1);\n    } else if (type == \"twos\") {\n        fill(seq.begin(), seq.end(), 2);\n    } else if (type == \"alternate\") {\n        for (int i = 0; i < n; ++i)\n            seq[i] = (i % 2) + 1;\n    } else if (type == \"more_ones\") {\n        int ones = n * 3 / 4; // 75% ones\n        int twos = n - ones;\n        vector<int> tmp;\n        for (int i = 0; i < ones; ++i) tmp.push_back(1);\n        for (int i = 0; i < twos; ++i) tmp.push_back(2);\n        shuffle(tmp.begin(), tmp.end());\n        seq = tmp;\n    } else if (type == \"more_twos\") {\n        int twos = n * 3 / 4; // 75% twos\n        int ones = n - twos;\n        vector<int> tmp;\n        for (int i = 0; i < ones; ++i) tmp.push_back(1);\n        for (int i = 0; i < twos; ++i) tmp.push_back(2);\n        shuffle(tmp.begin(), tmp.end());\n        seq = tmp;\n    } else if (type == \"random\") {\n        for (int i = 0; i < n; ++i)\n            seq[i] = rnd.next(1,2);\n    } else {\n        // Default to random if type is unrecognized\n        for (int i = 0; i < n; ++i)\n            seq[i] = rnd.next(1,2);\n    }\n\n    // Output n\n    printf(\"%d\\n\", n);\n    // Output the sequence\n    for (int i = 0; i < n; ++i) {\n        if (i > 0) printf(\" \");\n        printf(\"%d\", seq[i]);\n    }\n    printf(\"\\n\");\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> seq(n);\n\n    if (type == \"ones\") {\n        fill(seq.begin(), seq.end(), 1);\n    } else if (type == \"twos\") {\n        fill(seq.begin(), seq.end(), 2);\n    } else if (type == \"alternate\") {\n        for (int i = 0; i < n; ++i)\n            seq[i] = (i % 2) + 1;\n    } else if (type == \"more_ones\") {\n        int ones = n * 3 / 4; // 75% ones\n        int twos = n - ones;\n        vector<int> tmp;\n        for (int i = 0; i < ones; ++i) tmp.push_back(1);\n        for (int i = 0; i < twos; ++i) tmp.push_back(2);\n        shuffle(tmp.begin(), tmp.end());\n        seq = tmp;\n    } else if (type == \"more_twos\") {\n        int twos = n * 3 / 4; // 75% twos\n        int ones = n - twos;\n        vector<int> tmp;\n        for (int i = 0; i < ones; ++i) tmp.push_back(1);\n        for (int i = 0; i < twos; ++i) tmp.push_back(2);\n        shuffle(tmp.begin(), tmp.end());\n        seq = tmp;\n    } else if (type == \"random\") {\n        for (int i = 0; i < n; ++i)\n            seq[i] = rnd.next(1,2);\n    } else {\n        // Default to random if type is unrecognized\n        for (int i = 0; i < n; ++i)\n            seq[i] = rnd.next(1,2);\n    }\n\n    // Output n\n    printf(\"%d\\n\", n);\n    // Output the sequence\n    for (int i = 0; i < n; ++i) {\n        if (i > 0) printf(\" \");\n        printf(\"%d\", seq[i]);\n    }\n    printf(\"\\n\");\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -type ones\n./gen -n 1 -type twos\n./gen -n 1 -type alternate\n./gen -n 2 -type alternate\n./gen -n 2 -type random\n\n./gen -n 5 -type ones\n./gen -n 5 -type twos\n./gen -n 5 -type alternate\n./gen -n 5 -type random\n\n./gen -n 10 -type ones\n./gen -n 10 -type twos\n./gen -n 10 -type alternate\n./gen -n 10 -type random\n./gen -n 10 -type more_ones\n./gen -n 10 -type more_twos\n\n./gen -n 100 -type alternate\n./gen -n 100 -type random\n./gen -n 100 -type more_ones\n./gen -n 100 -type more_twos\n\n./gen -n 1000 -type random\n./gen -n 1000 -type more_ones\n./gen -n 1000 -type more_twos\n\n./gen -n 10000 -type alternate\n./gen -n 10000 -type random\n./gen -n 10000 -type more_ones\n./gen -n 10000 -type more_twos\n\n./gen -n 99999 -type ones\n./gen -n 99999 -type twos\n\n./gen -n 100000 -type ones\n./gen -n 100000 -type twos\n./gen -n 100000 -type alternate\n./gen -n 100000 -type random\n./gen -n 100000 -type more_ones\n./gen -n 100000 -type more_twos\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:39:12.253627",
        "total_tutorials": 3,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "497/C",
      "title": "C. Distributing Parts",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains a single integer n — the number of parts in the play (1 ≤ n ≤ 105).Next n lines contain two space-separated integers each, aj and bj — the range of notes for the j-th part (1 ≤ aj ≤ bj ≤ 109).The next line contains a single integer m — the number of actors (1 ≤ m ≤ 105).Next m lines contain three space-separated integers each, ci, di and ki — the range of the i-th actor and the number of parts that he can perform (1 ≤ ci ≤ di ≤ 109, 1 ≤ ki ≤ 109).",
      "output_spec": "OutputIf there is an assignment that meets all the criteria aboce, print a single word \"YES\" (without the quotes) in the first line.In the next line print n space-separated integers. The i-th integer should be the number of the actor who should perform the i-th part. If there are multiple correct assignments, print any of them.If there is no correct assignment, print a single word \"NO\" (without the quotes).",
      "sample_tests": "ExamplesInputCopy31 32 43 521 4 22 5 1OutputCopyYES1 1 2InputCopy31 32 43 521 3 22 5 1OutputCopyNO",
      "description": "C. Distributing Parts\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains a single integer n — the number of parts in the play (1 ≤ n ≤ 105).Next n lines contain two space-separated integers each, aj and bj — the range of notes for the j-th part (1 ≤ aj ≤ bj ≤ 109).The next line contains a single integer m — the number of actors (1 ≤ m ≤ 105).Next m lines contain three space-separated integers each, ci, di and ki — the range of the i-th actor and the number of parts that he can perform (1 ≤ ci ≤ di ≤ 109, 1 ≤ ki ≤ 109).\n\nOutputIf there is an assignment that meets all the criteria aboce, print a single word \"YES\" (without the quotes) in the first line.In the next line print n space-separated integers. The i-th integer should be the number of the actor who should perform the i-th part. If there are multiple correct assignments, print any of them.If there is no correct assignment, print a single word \"NO\" (without the quotes).\n\nInputCopy31 32 43 521 4 22 5 1OutputCopyYES1 1 2InputCopy31 32 43 521 3 22 5 1OutputCopyNO\n\nInputCopy31 32 43 521 4 22 5 1\n\nOutputCopyYES1 1 2\n\nInputCopy31 32 43 521 3 22 5 1\n\nOutputCopyNO",
      "solutions": [
        {
          "title": "Codeforces Round #283 - Codeforces",
          "content": "Hi, Codeforces.Today, on December 17 at 19:30 MSK regular, 283-rd Codeforces round will take place. Problems are authored by me, Mikhail Tikhomirov. Maxim Akhmedov (Zlobober) helped me with discussing and preparing the problemset, Maria Belova (Delinur) translated problem statements in English, and Georgy Chebanov (gchebanov), Alexander Mashrabov (map) and Niyaz Nigmatullin (niyaznigmatul) tested the round and helped us with finding bugs and mistakes; let's give them a round of applause!The round will be for both divisions. The scoring is standard (not dynamic); score distribution is as follows:Div. 1: 750-1250-1250-2000-2500Div. 2: 500-1000-1750-2250-2250This is going to be my fourth round at Codeforces. I really hope it will go as good as three before it. =) Wish you all the best of luck!UPD: the round is over, thanks for participating!Grats to the winners:Div. 1: SirShokoladina Petr rowdark anta Marcin_smu Merkurev qwer1561 Ra16bit kuviman Um_nik Div. 2: SergeyMelnikov sepehr103 StarCuriosity dotato husheyn Editorial is here ( UPD: now in English!).",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/15197",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1068
        },
        {
          "title": "Codeforces Round #283: editorial (with bonuses!) - Codeforces",
          "content": "Each problem comes with a challenge — a bonus task somehow related to the problem; you may tackle at the challenges for fun and practice, also feel free to discuss them at the comments. =)496A - Minimum DifficultyFor every option of removing an element we run through the remaining elements and find the maximal difference between adjacent ones; print the smallest found answer. The solution has complexity O(n2). It can be noticed that after removing an element the difficulty either stays the same or becomes equal to the difference between the neighbours of the removed element (whatever is larger); thus, the difficulty for every option of removing an element can be found in O(1), for the total complexity of O(n). Any of these solutions (or even less efficient ones) could pass the tests.Challenge: suppose we now have to remove exactly k arbitrary elements (but the first and the last elements have to stay in their places). How small the maximal difference between adjacent elements can become? Solve this problem assuming the limitations are as follows: 1 ≤ k ≤ n - 2, n ≤ 105, ai ≤ 109.496B - Secret CombinationWe observe that the order of operations is not important: we may first perform all the shifts, and after that all the additions. Note that after n shifts the sequence returns to its original state, therefore it is sufficient to consider only the options with less than n shifts. Also, after 10 times of adding 1 to all digits the sequence does not change; we may consider only options with less than 10 additions. Thus, there are overall 10n reasonable options for performing the operations; for every option perform the operations and find the smallest answer among all the options. As performing the operations for every option and comparing two answers to choose the best takes O(n) operations, this solution performs about 10n2 elementary operations. The multiple of 10 can be get rid of, if we note that after all shifts are made the best choice is to make the first digit equal to zero, and this leaves us but a single option for the number of additions. However, implementing this optimization is not necessary to get accepted.Challenge: can you solve the problem in time? in O(n) time?496C - Removing Columns/497A - Removing ColumnsLet's look at the first column of the table. If its letters are not sorted alphabetically, then in any valid choice of removing some columns it has to be removed. However, if its letters are sorted, then for every valid choice that has this column removed it can be restored back to the table; it is clear that the new choice is valid (that is, the rows of the new table are sorted lexicographically) and the answer (that is, the number of removed columns) has just became smaller.Consider all columns from left to right. We have already chosen which columns to remove among all the columns to the left of the current one; if leaving the current column in place breaks the lexicographical order of rows, then we have to remove it; otherwise, we may leave it in place to no harm. Arguing in the way of the previous paragraph we can prove that this greedy method yields an optimal (moreover, the only optimal) solution. The complexity is O(n2).Challenge: compute how many (say, modulo 109 + 7) n × m tables are there for which the answer for this problem is k? The more efficient solution you come up with, the better.496D - Tennis Game/497B - Tennis GameChoose some t; now emulate how the match will go, ensure that the record is valid for this t and by the way find the corresponding value of s. Print all valid options for s and t. This solution works in O(n2) time, which is not good enough, but we will try to optimize it.Suppose the current set if finished and we have processed k serves by now. Let us process the next set as follows: find t-th 1 and t-th 2 after position k. If t-th 1 occurs earlier, then the first player wins the set, and the set concludes right after the t-th 1; the other case is handled symmetrically. If the match is not over yet, and in the rest of the record there are no t ones nor t twos, then the record is clearly invalid. This way, every single set in the record can be processed in time using binary search, or O(1) time using precomputed arrays of positions for each player.Now observe that for any t a match of n serves can not contain more than n / t sets, as each set contains at least t serves. If we sum up the upper limits for the number of sets for each t, we obtain the total upper limit for the number of sets we may need to process: (which is the famous harmonic sum). Using one of the approaches discussed above, one obtains a solution with complexity of or ; each of these solutions fits the limit nicely.Obviously, for every t there is no more than one valid choice for s; however, maybe a bit unexpected, for a given s there may exist more than one valid choice of t. The first test where this takes place is pretest 12. The statement requires that the pairs are printed lexicographically ordered; it is possible to make a mistake here and print the pairs with equal s by descending t (if we fill the array by increasing t and then simply reverse the array).Challenge: while preparing this problem I discovered that it's quite hard to find a test such that the number of pairs in the answer is large; in the actual tests the maximal number is 128, which is the number of divisors of the number 83160. Can you beat this record? If you have a test with n ≤ 105 that has larger number of pairs in the answer, feel free to brag in the comments; also don't hesitate to share any insights on how one could bound the maximal number analytically.496E - Distributing Parts /497C - Distributing Parts Sort all the parts and actors altogether by increasing lower bounds (if equal, actors precede parts); process all the enitities in this order. We maintain a set of actors which have already occured in the order; if we meet an entry for an actor, add it to the set. If we currently process a part, we have to assign it to an actor; from the current set of actors we have to choose one such that his di ≥ bj (the ci ≤ aj constraint is provided by the fact that the i-th actor has occured earlier than the j-th part); if there are no such actors in the set, no answer can be obtained; if there are several actors satisftying this requirement, we should choose one with minimal di (intuitively, he will be less useful in the future). Assign the chosen actor with the current part and decrement his ki; if ki is now zero, the actor can not be used anymore, thus we remove him from the set.To fit the limits we should implement the set of current actors as some efficient data structure (e.g., an std::set or a treap). The resulting complexity is .Challenge: suppose that now there are qj copies of the j-th part (1 ≤ qj ≤ 109), and each copy must be separately assigned with an actor in a valid way. Can you solve this new problem with all the old constraints (as the actual distribution now has too much entries, it is sufficient to check whether an answer exists)?497D - GearsWhen a collision happens, a vertex of one polygon lands on a side of the other polygon. Consider a reference system such that the polygon A is not moving. In this system the polygon B preserves its orientation (that is, does not rotate), and each of its vertices moves on some circle. Intersect all the circles for vertices of B with all the sides of A; if any of them intersect, then some vertex of B collides with a side of A. Symmetrically, take a reference system associated with B and check whether some vertex of A collides with a side of B. The constraints for the points' coordinates are small enough for a solution with absolute precision to be possible (using built-in integer types).Another approach (which is, in fact, basically the same) is such: suppose there is a collision in a reference system associated with A. Then the following equality for vectors holds: x + y = z; here z is a vector that starts at P and ends somewhere on the bound of A, x is a vector that starts at Q and ends somewhere on the bound of B, y is a vector that starts at P and ends somewhere on the circle centered at P that passes through Q. Rewrite the equality as y = z - x; now observe that the set of all possible values of z - x forms the Minkowski sum of A and reflection of B (up to some shift), and the set of all possible values of y is a circle with known parameters. The Minkowski sum can be represented as a union of nm parallelograms, each of which is the Minkowski sum of a pair of sides of different polygons; finally, intersect all parallelograms with the circle.Both solutions have complexity O(nm). As noted above, it is possible to solve the problem using integer arithemetics (that is, with absolute precision); however, the fact that the points' coordinates are small lets most of the solutions with floating point arithmetics pass. It was tempting to write an approximate numerical solution; we struggled hard not to let such solutions pass, and eventually none of them did. =)Many participants had troubles with pretest 8. It looks as follows (the left spiral revolves around the left point, and the right spiral revolves around the right point):Challenge: suppose we want a solution that uses floating point arithmetics to fail. In order to do that, we want to construct a test such that the polygons don't collide but pass really close to each other. How small a (positive) distance we can achieve, given the same constraints for the number of points and the points' coordinates?497E - Subsequences ReturnConsider some string; how does one count the number of its distinct subsequences? Let us append symbols to the string consequently and each time count the number of subsequences that were not present before. Let's append a symbol c to a string s; in the string s + c there are as many subsequences that end in c as there were subsequences in s overall. Add all these subsequences to the number of subsequnces of s; now each subsequence is counted once, except for the subsequences that end in c but were already present in s before; these are counted twice. Thus, the total number of subsequences in the new string is twice the total number of subsequences in the old string minus the number of subsequences in the old string which end in c.This leads us to the following solution: for each symbol c store how many subsequences end in c, denote cntc. Append symbol c; now cntc becomes equal to the sum of all cnt's plus one (for the empty subsequence), and all the other cnt's do not change.For example, consider the first few symbols of the Thue-Morse sequence: ε — (0, 0) 0 — ( 0 + 0 + 1 = 1, 0) 01 — (1, 1 + 0 + 1 = 2) 011 — (1, 1 + 2 + 1 = 4) 0110 — ( 1 + 4 + 1 = 6, 4) ... Let us put the values of cnt in the coordinates of a vector, and also append a coordinate which is always equal to 1. It is now clear that appending a symbol to the string alters the vector as a multiplication by some matrix. Let us assign a matrix for each symbol, and also for each string as a product of matrices for the symbols of the strings in that order.Now, consider the prefix of the sequence ai of length km. Divide it into k parts of length km - 1; x-th (0-based) of these parts can be obtained from the 0-th one by adding x modulo k to all elements of the part. Let us count the matrices (see above) for the prefixes of length km, and also for all strings that are obtained by adding x to all of the prefixes' elements; denote such matrix Am, x.It is easy to see that if m > 0, then . This formula allows us to count Am, x for all and all x from 0 to k - 1 in time. Now, upon having all Am, x we can multiply some of them in the right order to obtain the matrix for the prefix of the sequence ai of length n.Unfortunately, this is not quite enough as the solution doesn't fit the time limit yet. Here is one way to speed up sufficiently: note that the product in the formula can be divided as shown: Am - 1, x... Am - 1, k - 1 × Am - 1, 0... Am - 1, x - 1 (if x = 0, take the second part to be empty). Count all the \"prefixes\" and \"suffixes\" products of the set Am, x: Pm, x = Am, 0... Am, x - 1, Sm, x = Am, x... Am, k - 1. Now Am, x = Sm - 1, xPm - 1, x. Thus, the computation of Am, x for all x and a given m can be done as computing all Pm - 1, x, Sm - 1, x using O(k) matrix multiplications, and each Am, x is now can be found using one matrix multiplication. Finally, the solution now works in time, which fits the limits by a margin.Challenge: solve the problem for k ≤ 100.",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/15208",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 497\\s*C"
          },
          "content_length": 12568
        },
        {
          "title": "Codeforces Round #283: editorial (with bonuses!) - Codeforces",
          "content": "Each problem comes with a challenge — a bonus task somehow related to the problem; you may tackle at the challenges for fun and practice, also feel free to discuss them at the comments. =)496A - Minimum DifficultyFor every option of removing an element we run through the remaining elements and find the maximal difference between adjacent ones; print the smallest found answer. The solution has complexity O(n2). It can be noticed that after removing an element the difficulty either stays the same or becomes equal to the difference between the neighbours of the removed element (whatever is larger); thus, the difficulty for every option of removing an element can be found in O(1), for the total complexity of O(n). Any of these solutions (or even less efficient ones) could pass the tests.Challenge: suppose we now have to remove exactly k arbitrary elements (but the first and the last elements have to stay in their places). How small the maximal difference between adjacent elements can become? Solve this problem assuming the limitations are as follows: 1 ≤ k ≤ n - 2, n ≤ 105, ai ≤ 109.496B - Secret CombinationWe observe that the order of operations is not important: we may first perform all the shifts, and after that all the additions. Note that after n shifts the sequence returns to its original state, therefore it is sufficient to consider only the options with less than n shifts. Also, after 10 times of adding 1 to all digits the sequence does not change; we may consider only options with less than 10 additions. Thus, there are overall 10n reasonable options for performing the operations; for every option perform the operations and find the smallest answer among all the options. As performing the operations for every option and comparing two answers to choose the best takes O(n) operations, this solution performs about 10n2 elementary operations. The multiple of 10 can be get rid of, if we note that after all shifts are made the best choice is to make the first digit equal to zero, and this leaves us but a single option for the number of additions. However, implementing this optimization is not necessary to get accepted.Challenge: can you solve the problem in time? in O(n) time?496C - Removing Columns/497A - Removing ColumnsLet's look at the first column of the table. If its letters are not sorted alphabetically, then in any valid choice of removing some columns it has to be removed. However, if its letters are sorted, then for every valid choice that has this column removed it can be restored back to the table; it is clear that the new choice is valid (that is, the rows of the new table are sorted lexicographically) and the answer (that is, the number of removed columns) has just became smaller.Consider all columns from left to right. We have already chosen which columns to remove among all the columns to the left of the current one; if leaving the current column in place breaks the lexicographical order of rows, then we have to remove it; otherwise, we may leave it in place to no harm. Arguing in the way of the previous paragraph we can prove that this greedy method yields an optimal (moreover, the only optimal) solution. The complexity is O(n2).Challenge: compute how many (say, modulo 109 + 7) n × m tables are there for which the answer for this problem is k? The more efficient solution you come up with, the better.496D - Tennis Game/497B - Tennis GameChoose some t; now emulate how the match will go, ensure that the record is valid for this t and by the way find the corresponding value of s. Print all valid options for s and t. This solution works in O(n2) time, which is not good enough, but we will try to optimize it.Suppose the current set if finished and we have processed k serves by now. Let us process the next set as follows: find t-th 1 and t-th 2 after position k. If t-th 1 occurs earlier, then the first player wins the set, and the set concludes right after the t-th 1; the other case is handled symmetrically. If the match is not over yet, and in the rest of the record there are no t ones nor t twos, then the record is clearly invalid. This way, every single set in the record can be processed in time using binary search, or O(1) time using precomputed arrays of positions for each player.Now observe that for any t a match of n serves can not contain more than n / t sets, as each set contains at least t serves. If we sum up the upper limits for the number of sets for each t, we obtain the total upper limit for the number of sets we may need to process: (which is the famous harmonic sum). Using one of the approaches discussed above, one obtains a solution with complexity of or ; each of these solutions fits the limit nicely.Obviously, for every t there is no more than one valid choice for s; however, maybe a bit unexpected, for a given s there may exist more than one valid choice of t. The first test where this takes place is pretest 12. The statement requires that the pairs are printed lexicographically ordered; it is possible to make a mistake here and print the pairs with equal s by descending t (if we fill the array by increasing t and then simply reverse the array).Challenge: while preparing this problem I discovered that it's quite hard to find a test such that the number of pairs in the answer is large; in the actual tests the maximal number is 128, which is the number of divisors of the number 83160. Can you beat this record? If you have a test with n ≤ 105 that has larger number of pairs in the answer, feel free to brag in the comments; also don't hesitate to share any insights on how one could bound the maximal number analytically.496E - Distributing Parts /497C - Distributing Parts Sort all the parts and actors altogether by increasing lower bounds (if equal, actors precede parts); process all the enitities in this order. We maintain a set of actors which have already occured in the order; if we meet an entry for an actor, add it to the set. If we currently process a part, we have to assign it to an actor; from the current set of actors we have to choose one such that his di ≥ bj (the ci ≤ aj constraint is provided by the fact that the i-th actor has occured earlier than the j-th part); if there are no such actors in the set, no answer can be obtained; if there are several actors satisftying this requirement, we should choose one with minimal di (intuitively, he will be less useful in the future). Assign the chosen actor with the current part and decrement his ki; if ki is now zero, the actor can not be used anymore, thus we remove him from the set.To fit the limits we should implement the set of current actors as some efficient data structure (e.g., an std::set or a treap). The resulting complexity is .Challenge: suppose that now there are qj copies of the j-th part (1 ≤ qj ≤ 109), and each copy must be separately assigned with an actor in a valid way. Can you solve this new problem with all the old constraints (as the actual distribution now has too much entries, it is sufficient to check whether an answer exists)?497D - GearsWhen a collision happens, a vertex of one polygon lands on a side of the other polygon. Consider a reference system such that the polygon A is not moving. In this system the polygon B preserves its orientation (that is, does not rotate), and each of its vertices moves on some circle. Intersect all the circles for vertices of B with all the sides of A; if any of them intersect, then some vertex of B collides with a side of A. Symmetrically, take a reference system associated with B and check whether some vertex of A collides with a side of B. The constraints for the points' coordinates are small enough for a solution with absolute precision to be possible (using built-in integer types).Another approach (which is, in fact, basically the same) is such: suppose there is a collision in a reference system associated with A. Then the following equality for vectors holds: x + y = z; here z is a vector that starts at P and ends somewhere on the bound of A, x is a vector that starts at Q and ends somewhere on the bound of B, y is a vector that starts at P and ends somewhere on the circle centered at P that passes through Q. Rewrite the equality as y = z - x; now observe that the set of all possible values of z - x forms the Minkowski sum of A and reflection of B (up to some shift), and the set of all possible values of y is a circle with known parameters. The Minkowski sum can be represented as a union of nm parallelograms, each of which is the Minkowski sum of a pair of sides of different polygons; finally, intersect all parallelograms with the circle.Both solutions have complexity O(nm). As noted above, it is possible to solve the problem using integer arithemetics (that is, with absolute precision); however, the fact that the points' coordinates are small lets most of the solutions with floating point arithmetics pass. It was tempting to write an approximate numerical solution; we struggled hard not to let such solutions pass, and eventually none of them did. =)Many participants had troubles with pretest 8. It looks as follows (the left spiral revolves around the left point, and the right spiral revolves around the right point):Challenge: suppose we want a solution that uses floating point arithmetics to fail. In order to do that, we want to construct a test such that the polygons don't collide but pass really close to each other. How small a (positive) distance we can achieve, given the same constraints for the number of points and the points' coordinates?497E - Subsequences ReturnConsider some string; how does one count the number of its distinct subsequences? Let us append symbols to the string consequently and each time count the number of subsequences that were not present before. Let's append a symbol c to a string s; in the string s + c there are as many subsequences that end in c as there were subsequences in s overall. Add all these subsequences to the number of subsequnces of s; now each subsequence is counted once, except for the subsequences that end in c but were already present in s before; these are counted twice. Thus, the total number of subsequences in the new string is twice the total number of subsequences in the old string minus the number of subsequences in the old string which end in c.This leads us to the following solution: for each symbol c store how many subsequences end in c, denote cntc. Append symbol c; now cntc becomes equal to the sum of all cnt's plus one (for the empty subsequence), and all the other cnt's do not change.For example, consider the first few symbols of the Thue-Morse sequence: ε — (0, 0) 0 — ( 0 + 0 + 1 = 1, 0) 01 — (1, 1 + 0 + 1 = 2) 011 — (1, 1 + 2 + 1 = 4) 0110 — ( 1 + 4 + 1 = 6, 4) ... Let us put the values of cnt in the coordinates of a vector, and also append a coordinate which is always equal to 1. It is now clear that appending a symbol to the string alters the vector as a multiplication by some matrix. Let us assign a matrix for each symbol, and also for each string as a product of matrices for the symbols of the strings in that order.Now, consider the prefix of the sequence ai of length km. Divide it into k parts of length km - 1; x-th (0-based) of these parts can be obtained from the 0-th one by adding x modulo k to all elements of the part. Let us count the matrices (see above) for the prefixes of length km, and also for all strings that are obtained by adding x to all of the prefixes' elements; denote such matrix Am, x.It is easy to see that if m > 0, then . This formula allows us to count Am, x for all and all x from 0 to k - 1 in time. Now, upon having all Am, x we can multiply some of them in the right order to obtain the matrix for the prefix of the sequence ai of length n.Unfortunately, this is not quite enough as the solution doesn't fit the time limit yet. Here is one way to speed up sufficiently: note that the product in the formula can be divided as shown: Am - 1, x... Am - 1, k - 1 × Am - 1, 0... Am - 1, x - 1 (if x = 0, take the second part to be empty). Count all the \"prefixes\" and \"suffixes\" products of the set Am, x: Pm, x = Am, 0... Am, x - 1, Sm, x = Am, x... Am, k - 1. Now Am, x = Sm - 1, xPm - 1, x. Thus, the computation of Am, x for all x and a given m can be done as computing all Pm - 1, x, Sm - 1, x using O(k) matrix multiplications, and each Am, x is now can be found using one matrix multiplication. Finally, the solution now works in time, which fits the limits by a margin.Challenge: solve the problem for k ≤ 100.",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/15208",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 497\\s*C"
          },
          "content_length": 12568
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #283 - Codeforces - Code 1",
          "code": "18\n2 2   2 2   2 2   1 2 1   1 2 1   1 2 1   1 2 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15197",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #283 - Codeforces - Code 2",
          "code": "18\n2 2   2 2   2 2   1 2 1   1 2 1   1 2 1   1 2 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15197",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #283 - Codeforces - Code 3",
          "code": "ans[ac]=i;\n       ac++;\n    }\n}\nreturn ac;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15197",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #283 - Codeforces - Code 4",
          "code": "ans[ac]=i;\n       ac++;\n    }\n}\nreturn ac;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15197",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #283 - Codeforces - Code 5",
          "code": "cin>>n;\nfor (int i=0;i<n;i++) cin>>a[i];\nfor (int i=0;i<n;i++) {\n    if (a[i]==1) x++; else y++;\n    f[i]=max(x,y);\n}\nint z=fact(f[n-1]);\nif (x==y) {\n    cout<<\"0\";\n} else {\n    cout<<ac<<endl;\n    for (int i=0;i<ac;i++) {\n       cout<<ans[i]<<\" \"<<f[n-1]/ans[i]<<endl;\n    }\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15197",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #283 - Codeforces - Code 6",
          "code": "cin>>n;\nfor (int i=0;i<n;i++) cin>>a[i];\nfor (int i=0;i<n;i++) {\n    if (a[i]==1) x++; else y++;\n    f[i]=max(x,y);\n}\nint z=fact(f[n-1]);\nif (x==y) {\n    cout<<\"0\";\n} else {\n    cout<<ac<<endl;\n    for (int i=0;i<ac;i++) {\n       cout<<ans[i]<<\" \"<<f[n-1]/ans[i]<<endl;\n    }\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15197",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #283 - Codeforces - Code 7",
          "code": "ae ae et oe",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15197",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #283 - Codeforces - Code 8",
          "code": "20\n1 1 2 2 2 2 2 2 2 2 2 2 1 2 2 1 2 2 2 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15197",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #283 - Codeforces - Code 9",
          "code": "20\n1 1 2 2 2 2 2 2 2 2 2 2 1 2 2 1 2 2 2 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15197",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #283: editorial (with bonuses!) - Codeforces - Code 1",
          "code": "496D - Tennis Game",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15208",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #283: editorial (with bonuses!) - Codeforces - Code 2",
          "code": "number of valid (s,t) will be 0 if the total number of points of player who won  the last point is less than or equal to another player",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15208",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #283: editorial (with bonuses!) - Codeforces - Code 3",
          "code": "strictly more",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15208",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #283: editorial (with bonuses!) - Codeforces - Code 4",
          "code": "The Minkowski sum can be represented as a union of nm parallelograms, each of which is the Minkowski sum of a pair of sides of different polygons;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15208",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #283: editorial (with bonuses!) - Codeforces - Code 5",
          "code": "circle_segment",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15208",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #283: editorial (with bonuses!) - Codeforces - Code 6",
          "code": "ll dmax = (max((a - c) | (a - c), (a - b) | (a - b))); -> ll dmax = (max((a - c) | (a - c), (b - c) | (b - c)));",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15208",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #283: editorial (with bonuses!) - Codeforces - Code 7",
          "code": "ll dmax = (max((a - c) | (a - c), (a - b) | (a - b))); -> ll dmax = (max((a - c) | (a - c), (b - c) | (b - c)));",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15208",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #283: editorial (with bonuses!) - Codeforces - Code 1",
          "code": "496D - Tennis Game",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15208",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #283: editorial (with bonuses!) - Codeforces - Code 2",
          "code": "number of valid (s,t) will be 0 if the total number of points of player who won  the last point is less than or equal to another player",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15208",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #283: editorial (with bonuses!) - Codeforces - Code 3",
          "code": "strictly more",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15208",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #283: editorial (with bonuses!) - Codeforces - Code 4",
          "code": "The Minkowski sum can be represented as a union of nm parallelograms, each of which is the Minkowski sum of a pair of sides of different polygons;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15208",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #283: editorial (with bonuses!) - Codeforces - Code 5",
          "code": "circle_segment",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15208",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #283: editorial (with bonuses!) - Codeforces - Code 6",
          "code": "ll dmax = (max((a - c) | (a - c), (a - b) | (a - b))); -> ll dmax = (max((a - c) | (a - c), (b - c) | (b - c)));",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15208",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #283: editorial (with bonuses!) - Codeforces - Code 7",
          "code": "ll dmax = (max((a - c) | (a - c), (a - b) | (a - b))); -> ll dmax = (max((a - c) | (a - c), (b - c) | (b - c)));",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15208",
          "author": "Qingyu"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n\n    for (int i = 0; i < n; ++i) {\n        int aj = inf.readInt(1, 1000000000, \"aj\");\n        inf.readSpace();\n        int bj = inf.readInt(1, 1000000000, \"bj\");\n        inf.readEoln();\n\n        ensuref(aj <= bj, \"For part %d, aj (=%d) should be less than or equal to bj (=%d)\", i + 1, aj, bj);\n    }\n\n    int m = inf.readInt(1, 100000, \"m\");\n    inf.readEoln();\n\n    for (int i = 0; i < m; ++i) {\n        int ci = inf.readInt(1, 1000000000, \"ci\");\n        inf.readSpace();\n        int di = inf.readInt(1, 1000000000, \"di\");\n        inf.readSpace();\n        int ki = inf.readInt(1, 1000000000, \"ki\");\n        inf.readEoln();\n\n        ensuref(ci <= di, \"For actor %d, ci (=%d) should be less than or equal to di (=%d)\", i + 1, ci, di);\n    }\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n\n    for (int i = 0; i < n; ++i) {\n        int aj = inf.readInt(1, 1000000000, \"aj\");\n        inf.readSpace();\n        int bj = inf.readInt(1, 1000000000, \"bj\");\n        inf.readEoln();\n\n        ensuref(aj <= bj, \"For part %d, aj (=%d) should be less than or equal to bj (=%d)\", i + 1, aj, bj);\n    }\n\n    int m = inf.readInt(1, 100000, \"m\");\n    inf.readEoln();\n\n    for (int i = 0; i < m; ++i) {\n        int ci = inf.readInt(1, 1000000000, \"ci\");\n        inf.readSpace();\n        int di = inf.readInt(1, 1000000000, \"di\");\n        inf.readSpace();\n        int ki = inf.readInt(1, 1000000000, \"ki\");\n        inf.readEoln();\n\n        ensuref(ci <= di, \"For actor %d, ci (=%d) should be less than or equal to di (=%d)\", i + 1, ci, di);\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n\n    for (int i = 0; i < n; ++i) {\n        int aj = inf.readInt(1, 1000000000, \"aj\");\n        inf.readSpace();\n        int bj = inf.readInt(1, 1000000000, \"bj\");\n        inf.readEoln();\n\n        ensuref(aj <= bj, \"For part %d, aj (=%d) should be less than or equal to bj (=%d)\", i + 1, aj, bj);\n    }\n\n    int m = inf.readInt(1, 100000, \"m\");\n    inf.readEoln();\n\n    for (int i = 0; i < m; ++i) {\n        int ci = inf.readInt(1, 1000000000, \"ci\");\n        inf.readSpace();\n        int di = inf.readInt(1, 1000000000, \"di\");\n        inf.readSpace();\n        int ki = inf.readInt(1, 1000000000, \"ki\");\n        inf.readEoln();\n\n        ensuref(ci <= di, \"For actor %d, ci (=%d) should be less than or equal to di (=%d)\", i + 1, ci, di);\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nstruct Part {\n    int a, b;\n};\n\nstruct Actor {\n    int c, d;\n    int k;\n};\n\nint main(int argc, char* argv[]) {\n    registerTestlibCmd(argc, argv);\n\n    int n = inf.readInt(1, 100000, \"n\");\n\n    vector<Part> parts(n);\n\n    for (int i = 0; i < n; i++) {\n        int a = inf.readInt(1, 1000000000, \"a_j\");\n        int b = inf.readInt(a, 1000000000, \"b_j\");\n        parts[i] = {a, b};\n    }\n\n    int m = inf.readInt(1, 100000, \"m\");\n\n    vector<Actor> actors(m);\n\n    for (int i = 0; i < m; i++) {\n        int c = inf.readInt(1, 1000000000, \"c_i\");\n        int d = inf.readInt(c, 1000000000, \"d_i\");\n        int k = inf.readInt(1, 1000000000, \"k_i\");\n        actors[i] = {c, d, k};\n    }\n\n    string juryFirstWord = ans.readToken();\n\n    if (juryFirstWord != \"YES\" && juryFirstWord != \"NO\") {\n        ans.quitf(_fail, \"Jury's answer is invalid: expected YES or NO but found '%s'\", juryFirstWord.c_str());\n    }\n\n    string participantFirstWord = ouf.readToken();\n\n    if (participantFirstWord != \"YES\" && participantFirstWord != \"NO\") {\n        quitf(_pe, \"Participant's answer should be YES or NO but found '%s'\", participantFirstWord.c_str());\n    }\n\n    if (participantFirstWord == \"NO\") {\n        if (juryFirstWord == \"NO\") {\n            // Participant and jury both say NO\n            // Participant is correct\n            quitf(_ok, \"Correct: NO solution exists\");\n        } else {\n            // Participant failed to find an assignment when one exists\n            quitf(_wa, \"Participant claimed NO solution exists but jury has a solution\");\n        }\n    } else { // Participant says YES\n        // Read participant's assignment\n        vector<int> participantAssignment = ouf.readInts(n, 1, m, \"participant assignment\");\n\n        vector<int> assignedPartsPerActor(m, 0);\n\n        for (int j = 0; j < n; j++) {\n            int actorIndex = participantAssignment[j] - 1; // 0-based index\n\n            assignedPartsPerActor[actorIndex]++;\n\n            if (assignedPartsPerActor[actorIndex] > actors[actorIndex].k) {\n                quitf(_wa, \"Actor %d is assigned more than k_i=%d parts\", actorIndex + 1, actors[actorIndex].k);\n            }\n\n            int c_i = actors[actorIndex].c;\n            int d_i = actors[actorIndex].d;\n            int a_j = parts[j].a;\n            int b_j = parts[j].b;\n\n            if (c_i > a_j || b_j > d_i) {\n                quitf(_wa, \"Actor %d cannot perform part %d\", actorIndex + 1, j + 1);\n            }\n        }\n\n        if (juryFirstWord == \"NO\") {\n            // Participant found an assignment when jury says none exists\n            quitf(_fail, \"Participant found an assignment when jury says none exists\");\n        } else {\n            // Participant's assignment is valid, accept\n            quitf(_ok, \"Correct solution\");\n        }\n    }\n\n    return 0;\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> aj(n), bj(n);\n    vector<int> ci(m), di(m);\n    vector<long long> ki(m);\n\n    if (type == \"random\") {\n        // Generate random ci and di for actors\n        for (int i = 0; i < m; ++i) {\n            ci[i] = rnd.next(1, int(1e9));\n            di[i] = rnd.next(ci[i], int(1e9)); // ci[i] ≤ di[i]\n        }\n\n        vector<int> parts_count(m, 0);\n\n        // For each part, assign to a random actor\n        for (int j = 0; j < n; ++j) {\n            int actor = rnd.next(0, m-1);\n            parts_count[actor]++;\n\n            // Generate aj and bj such that ci[actor] ≤ aj ≤ bj ≤ di[actor]\n            aj[j] = rnd.next(ci[actor], di[actor]);\n            bj[j] = rnd.next(aj[j], di[actor]);\n        }\n\n        // For actors, set ki ≥ parts_count[i]\n        for (int i = 0; i < m; ++i) {\n            ki[i] = parts_count[i] + rnd.next(0LL, (long long)1e9 - parts_count[i]);\n        }\n\n    } else if (type == \"no_solution\") {\n        // All actors have ranges in low half, parts have ranges in high half\n\n        int mid = int(5e8);\n\n        for (int i = 0; i < m; ++i) {\n            ci[i] = rnd.next(1, mid - 1);\n            di[i] = rnd.next(ci[i], mid - 1);\n            ki[i] = rnd.next(1LL, (long long)1e9);\n        }\n\n        for (int j = 0; j < n; ++j) {\n            aj[j] = rnd.next(mid +1, int(1e9));\n            bj[j] = rnd.next(aj[j], int(1e9));\n        }\n    } else if (type == \"max_ki\") {\n        // Random data, ki = 1e9\n\n        for (int i = 0; i < m; ++i) {\n            ci[i] = rnd.next(1, int(1e9));\n            di[i] = rnd.next(ci[i], int(1e9));\n            ki[i] = (long long)1e9;\n        }\n\n        // Generate parts randomly\n        for (int j = 0; j < n; ++j) {\n            aj[j] = rnd.next(1, int(1e9));\n            bj[j] = rnd.next(aj[j], int(1e9));\n        }\n\n    } else if (type == \"min_ki\") {\n        // Set ki = 1\n        for (int i = 0; i < m; ++i) {\n            ci[i] = rnd.next(1, int(1e9));\n            di[i] = rnd.next(ci[i], int(1e9));\n            ki[i] = 1;\n        }\n\n        // For each part, try to assign to an actor with ki = 1\n        // Ensure m ≥ n for a possible assignment\n        if (m < n) {\n            // Not enough actors to assign parts\n            printf(\"%d\\n\", n);\n            for (int j = 0; j < n; ++j)\n                printf(\"1 1\\n\"); // Dummy data\n            printf(\"%d\\n\", m);\n            for (int i = 0; i < m; ++i)\n                printf(\"1 1 1\\n\"); // Dummy data\n            return 0;\n        }\n\n        // Assign one part to each actor\n        vector<int> perm = rnd.perm(m);\n\n        for (int j = 0; j < n; ++j) {\n            int actor = perm[j];\n            // Generate aj and bj such that ci[actor] ≤ aj ≤ bj ≤ di[actor]\n            aj[j] = rnd.next(ci[actor], di[actor]);\n            bj[j] = rnd.next(aj[j], di[actor]);\n        }\n    } else if (type == \"tight_ranges\") {\n        // Each actor can only perform specific parts\n\n        // Ensure m ≥ n for assignment\n        if (m < n) {\n            printf(\"%d\\n\", n);\n            for (int j = 0; j < n; ++j)\n                printf(\"1 1\\n\"); // Dummy data\n            printf(\"%d\\n\", m);\n            for (int i = 0; i < m; ++i)\n                printf(\"1 1 1\\n\"); // Dummy data\n            return 0;\n        }\n\n        for (int i = 0; i < m; ++i) {\n            ci[i] = 1 + i * 10;\n            di[i] = ci[i] + 10;\n            ki[i] = rnd.next(1LL, (long long)1e9);\n        }\n\n        for (int j = 0; j < n; ++j) {\n            int actor = j;\n            aj[j] = ci[actor] + 5;\n            bj[j] = aj[j];\n        }\n\n    } else {\n        // Unknown type\n        fprintf(stderr, \"Unknown type: %s\\n\", type.c_str());\n        exit(1);\n    }\n\n    // Output\n    printf(\"%d\\n\", n);\n    for (int j = 0; j < n; ++j) {\n        printf(\"%d %d\\n\", aj[j], bj[j]);\n    }\n\n    printf(\"%d\\n\", m);\n    for (int i = 0; i < m; ++i) {\n        printf(\"%d %d %lld\\n\", ci[i], di[i], ki[i]);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> aj(n), bj(n);\n    vector<int> ci(m), di(m);\n    vector<long long> ki(m);\n\n    if (type == \"random\") {\n        // Generate random ci and di for actors\n        for (int i = 0; i < m; ++i) {\n            ci[i] = rnd.next(1, int(1e9));\n            di[i] = rnd.next(ci[i], int(1e9)); // ci[i] ≤ di[i]\n        }\n\n        vector<int> parts_count(m, 0);\n\n        // For each part, assign to a random actor\n        for (int j = 0; j < n; ++j) {\n            int actor = rnd.next(0, m-1);\n            parts_count[actor]++;\n\n            // Generate aj and bj such that ci[actor] ≤ aj ≤ bj ≤ di[actor]\n            aj[j] = rnd.next(ci[actor], di[actor]);\n            bj[j] = rnd.next(aj[j], di[actor]);\n        }\n\n        // For actors, set ki ≥ parts_count[i]\n        for (int i = 0; i < m; ++i) {\n            ki[i] = parts_count[i] + rnd.next(0LL, (long long)1e9 - parts_count[i]);\n        }\n\n    } else if (type == \"no_solution\") {\n        // All actors have ranges in low half, parts have ranges in high half\n\n        int mid = int(5e8);\n\n        for (int i = 0; i < m; ++i) {\n            ci[i] = rnd.next(1, mid - 1);\n            di[i] = rnd.next(ci[i], mid - 1);\n            ki[i] = rnd.next(1LL, (long long)1e9);\n        }\n\n        for (int j = 0; j < n; ++j) {\n            aj[j] = rnd.next(mid +1, int(1e9));\n            bj[j] = rnd.next(aj[j], int(1e9));\n        }\n    } else if (type == \"max_ki\") {\n        // Random data, ki = 1e9\n\n        for (int i = 0; i < m; ++i) {\n            ci[i] = rnd.next(1, int(1e9));\n            di[i] = rnd.next(ci[i], int(1e9));\n            ki[i] = (long long)1e9;\n        }\n\n        // Generate parts randomly\n        for (int j = 0; j < n; ++j) {\n            aj[j] = rnd.next(1, int(1e9));\n            bj[j] = rnd.next(aj[j], int(1e9));\n        }\n\n    } else if (type == \"min_ki\") {\n        // Set ki = 1\n        for (int i = 0; i < m; ++i) {\n            ci[i] = rnd.next(1, int(1e9));\n            di[i] = rnd.next(ci[i], int(1e9));\n            ki[i] = 1;\n        }\n\n        // For each part, try to assign to an actor with ki = 1\n        // Ensure m ≥ n for a possible assignment\n        if (m < n) {\n            // Not enough actors to assign parts\n            printf(\"%d\\n\", n);\n            for (int j = 0; j < n; ++j)\n                printf(\"1 1\\n\"); // Dummy data\n            printf(\"%d\\n\", m);\n            for (int i = 0; i < m; ++i)\n                printf(\"1 1 1\\n\"); // Dummy data\n            return 0;\n        }\n\n        // Assign one part to each actor\n        vector<int> perm = rnd.perm(m);\n\n        for (int j = 0; j < n; ++j) {\n            int actor = perm[j];\n            // Generate aj and bj such that ci[actor] ≤ aj ≤ bj ≤ di[actor]\n            aj[j] = rnd.next(ci[actor], di[actor]);\n            bj[j] = rnd.next(aj[j], di[actor]);\n        }\n    } else if (type == \"tight_ranges\") {\n        // Each actor can only perform specific parts\n\n        // Ensure m ≥ n for assignment\n        if (m < n) {\n            printf(\"%d\\n\", n);\n            for (int j = 0; j < n; ++j)\n                printf(\"1 1\\n\"); // Dummy data\n            printf(\"%d\\n\", m);\n            for (int i = 0; i < m; ++i)\n                printf(\"1 1 1\\n\"); // Dummy data\n            return 0;\n        }\n\n        for (int i = 0; i < m; ++i) {\n            ci[i] = 1 + i * 10;\n            di[i] = ci[i] + 10;\n            ki[i] = rnd.next(1LL, (long long)1e9);\n        }\n\n        for (int j = 0; j < n; ++j) {\n            int actor = j;\n            aj[j] = ci[actor] + 5;\n            bj[j] = aj[j];\n        }\n\n    } else {\n        // Unknown type\n        fprintf(stderr, \"Unknown type: %s\\n\", type.c_str());\n        exit(1);\n    }\n\n    // Output\n    printf(\"%d\\n\", n);\n    for (int j = 0; j < n; ++j) {\n        printf(\"%d %d\\n\", aj[j], bj[j]);\n    }\n\n    printf(\"%d\\n\", m);\n    for (int i = 0; i < m; ++i) {\n        printf(\"%d %d %lld\\n\", ci[i], di[i], ki[i]);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 5 -m 5 -type random\n./gen -n 100 -m 100 -type random\n./gen -n 1000 -m 1000 -type random\n./gen -n 10000 -m 10000 -type random\n./gen -n 100000 -m 100000 -type random\n\n./gen -n 5 -m 5 -type no_solution\n./gen -n 100 -m 100 -type no_solution\n./gen -n 1000 -m 1000 -type no_solution\n./gen -n 10000 -m 10000 -type no_solution\n./gen -n 100000 -m 100000 -type no_solution\n\n./gen -n 5 -m 5 -type max_ki\n./gen -n 100 -m 50 -type max_ki\n./gen -n 1000 -m 500 -type max_ki\n./gen -n 10000 -m 5000 -type max_ki\n./gen -n 100000 -m 50000 -type max_ki\n\n./gen -n 5 -m 5 -type min_ki\n./gen -n 100 -m 100 -type min_ki\n./gen -n 1000 -m 1000 -type min_ki\n./gen -n 10000 -m 10000 -type min_ki\n./gen -n 100000 -m 100000 -type min_ki\n\n./gen -n 5 -m 5 -type tight_ranges\n./gen -n 100 -m 100 -type tight_ranges\n./gen -n 1000 -m 1000 -type tight_ranges\n./gen -n 10000 -m 10000 -type tight_ranges\n./gen -n 100000 -m 100000 -type tight_ranges\n\n# Additional edge cases\n./gen -n 1 -m 1 -type random\n./gen -n 1 -m 1 -type no_solution\n./gen -n 1 -m 100000 -type random\n./gen -n 100000 -m 1 -type random\n./gen -n 100000 -m 1 -type min_ki\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:39:14.101854",
        "total_tutorials": 3,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "497/E",
      "title": "E. Подпоследовательности возвращаются",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест1 секунда",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеВ первой строке записано два целых числа, разделенных пробелом, — n и k (1 ≤ n ≤ 1018, 2 ≤ k ≤ 30).",
      "output_spec": "Выходные данныеВ единственной строке выведите остаток от деления ответа на задачу на 109 + 7.",
      "sample_tests": "ПримерыВходные данныеСкопировать4 2Выходные данныеСкопировать11Входные данныеСкопировать7 7Выходные данныеСкопировать128",
      "description": "E. Подпоследовательности возвращаются\n\nограничение по времени на тест1 секунда\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвыводstdout\n\nВходные данныеВ первой строке записано два целых числа, разделенных пробелом, — n и k (1 ≤ n ≤ 1018, 2 ≤ k ≤ 30).\n\nВходные данные\n\nВыходные данныеВ единственной строке выведите остаток от деления ответа на задачу на 109 + 7.\n\nВыходные данные\n\nВходные данныеСкопировать4 2Выходные данныеСкопировать11Входные данныеСкопировать7 7Выходные данныеСкопировать128\n\nВходные данныеСкопировать4 2\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать11\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать7 7\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать128\n\nВыходные данныеСкопировать\n\nСкопировать\n\nПримечаниеВ первом примере последовательность ai выглядит следующим образом: (0, 1, 1, 0). Все возможные подпоследовательности: (), (0), (0, 0), (0, 1), (0, 1, 0), (0, 1, 1), (0, 1, 1, 0), (1), (1, 0), (1, 1), (1, 1, 0).Во втором примере последовательность ai выглядит следующим образом: (0, 1, 2, 3, 4, 5, 6). Подпоследовательностями этой последовательности являются все возрастающие последовательности из чисел от 0 до 6 и только они. Легко видеть, что их ровно 27 = 128.",
      "solutions": [
        {
          "title": "Codeforces Round #283 - Codeforces",
          "content": "Привет, Codeforces.Сегодня, 17 декабря в 19:30 MSK состоится очередной, 283-й раунд Codeforces. Автор задач — я, Михаил Тихомиров. Макс Ахмедов (Zlobober) помог мне с обсуждением и подготовкой задач, Мария Белова (Delinur) перевела условия задач на английский, а Георгий Чебанов (gchebanov), Александр Машрабов (map) и Нияз Нигматуллин (niyaznigmatul) заранее прорешали раунд и помогли нам выловить ошибки и неточности; скажем им большое спасибо!Раунд состоится в обоих дивизионах. Разбалловка будет стандартной (не динамической); распределение баллов следующее:Div. 1: 750-1250-1250-2000-2500Div. 2: 500-1000-1750-2250-2250Это мой четвертый раунд на Codeforces. Надеюсь, он пройдет не хуже предыдущих трех. =) Желаю всем удачи!UPD: раунд завершен, всем спасибо за участие!Поздравляем победителей:Div. 1: SirShokoladina Petr rowdark anta Marcin_smu Merkurev qwer1561 Ra16bit kuviman Um_nik Div. 2: SergeyMelnikov sepehr103 StarCuriosity dotato husheyn Разбор доступен по ссылке.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/15197",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 978
        },
        {
          "title": "Codeforces Round #283: разбор (+бонусы!) - Codeforces",
          "content": "К каждой задаче присутствует challenge — бонусная задача на тему, которую можно порешать just for fun и обсудить в комментариях. =)496A - Минимальная сложностьПереберем все элементы, которые можем выкинуть, пройдем по оставшимся элементам и посчитаем максимальную разность среди соседних. Это решение имеет сложность O(n2). Можно заметить, что при удалении элемента ответ либо не поменялся, либо стал равен разности тех элементов, которые являлись соседями только что удаленного, поэтому ответ можно получить за O(1), а итоговое решение будет иметь сложность O(n). Ограничения позволяли сдать любое из этих решений или даже менее эффективное.Challenge: пусть мы удаляем не один элемент, а k любых элементов (первый и последний, как и раньше, удалять нельзя). Какую минимальную максимальную разность между соседними элементами мы можем получить? Решите задачу в ограничениях 1 ≤ k ≤ n - 2, n ≤ 105, ai ≤ 109.496B - Секретный кодЗаметим, что нам неважно, в каком порядке применяются операции: мы можем сперва выполнить все сдвиги, а затем все прибавления. После n сдвигов мы получаем исходную последовательность, поэтому достаточно рассмотреть только варианты, где сдвиги выполняются менее n раз. Аналогично, после десяти прибавлений единицы ко всем цифрам получим исходную последовательность, поэтому рассмотрим только варианты, где прибавления выполняются менее десяти раз. Для каждого из 10n вариантов определим результат применения всех операций; сохраним лучший результат и для каждого из вариантов сравним с лучшим. Сравнения осуществляются за O(n) операций, поэтому итоговое количество элементарных операций имеет порядок 10n2. От константы 10 можно избавиться, если заметить, что при фиксированном сдвиге первую цифру всегда выгодно сделать нулем, и это однозначно определяет количество прибавлений; однако, чтобы сдать задачу, эта оптимизация не требовалась.Challenge: можете ли вы решить задачу за время ? O(n)?496C - Удаление столбцов/497A - Удаление столбцовПосмотрим на первый столбец таблицы. Если буквы в нем не упорядочены по алфавиту сверху вниз, его нельзя оставить ни в каком корректном варианте оставить некоторые столбцы. С другой стороны, пусть буквы в первом столбце упорядочены, но в ответ мы его не взяли. Добавим его к ответу; несложно видеть, что в новом варианте оставить столбцы все строки также упорядочены сверху вниз по алфавиту.Будем рассматривать столбцы слева направо. Если мы попробовали добавить текущий столбец к ответу и лексикографический порядок строк где-то нарушился, мы обязаны его удалить; если же все в порядке, возьмем его в ответ. Рассуждение, аналогичное предыдущему абзацу, показывает, что такой жадный алгоритм приводит к оптимальному (и более того, единственному среди оптимальных) ответу. Итоговая сложность — O(n2).Challenge: сколько существует таблиц n × m, для которых ответ на эту задачу равен k? Придумайте как можно более оптимальное решение.496D - Игра в теннис/497B - Игра в теннисФиксируем t; теперь мы можем проэмулировать ход партии и убедиться, что запись является корректной, а также определить соответствующее s; выведем все подходящие пары s и t. Такое решение работает за O(n2), попробуем его соптимизировать.Если после окончания очередного сета мы обработали k розыгрышей, то позицию окончания следующего сета можно определить так: найти t-ую позицию после k-ой, в которой записано 1, аналогично, найдем t-ую позицию, содержащую 2. Если позиция t-ой единицы встретилась раньше, то следующий сет выигрывает первый игрок, и позиция окончания сета совпадает с позицией t-ой единицы; аналогично разбирается случай, если раньше идет t-ая двойка. Если партия еще не кончилась, но в оставшейся части и единиц, и двоек менее t, то запись некорректна. Позицию t-ой единицы или двойки после заданной позиции можно определять за бинпоиском, или за O(1) при помощи предподсчитанного массива позиций.Теперь заметим, что для данного t партия из n розыгрышей не может содержать больше n / t сетов, поскольку каждый из них содержит как минимум t розыгрышей. Если мы просуммируем количество сетов в партии по всем возможным t, мы получим не более (известная сумма гармонического ряда). В зависимости от способа обработки одного сета итоговая сложность составляет либо ; любой из этих способов с запасом укладывается в ограничение.Очевидно, что для каждого t существует не более одного варианта s; однако, для данного s может существовать более одного варианта t. Первый тест с таким случаем — претест 12. В условии требуется выводить ответ в лексикографическом порядке пар; здесь легко допустить ошибку и вывести пары с равными s по убыванию t (если в конце просто переворачивать массив).Challenge: при подготовке этой задачи я столкнулся с тем, что не могу построить тест с большим количеством пар в ответе; в тестах к задаче максимальное количество — 128 = количество делителей числа 83160. Сможете ли вы побить этот рекорд? Хвастайтесь в комментариях, сколько пар вы умеете получать при n ≤ 105; если у вас есть соображения, как оценить максимальное количество пар теоретически, тоже прошу делиться.496E - Распределение партий/497C - Распределение партийОтсортируем все партии и всех актеров вместе по возрастанию нижней границы (при равенстве сначала идут все актеры, потом все партии); пойдем в этом порядке по возрастанию нижней границы. Будем поддерживать множество актеров, которые уже <<начались>>, т.е. встретились в этом порядке раньше; если мы встретили актера, добавим его в это множество. Если мы встретили партию (aj, bj), из множества допустимых актеров нам нужно выбрать такого, у которого di ≥ bj (требование ci ≤ aj гарантируется тем, что i-ый актер встретился раньше, чем j-ая партия); если таких актеров в множестве нет, мы не можем получить ответ. Если таких актеров несколько, нам выгоднее брать того из них, у которого di минимально (интуитивно, он нам в дальнейшем меньше пригодится). Сопоставим текущую партию выбранному актеру и уменьшим его ki на единицу; если теперь ki = 0, мы больше не можем пользоваться этим актером и должны выкинуть его из множества.Чтобы уложиться в ограничения, множество текущих актеров приходится поддерживать в эффективной структуре данных (например, std::set или декартово дерево). Сложность итогового решения .Challenge: пусть каждая песня присутствует в количестве qj (1 ≤ qj ≤ 109), и каждой копии надо сопоставить своего актера. можете ли вы решить задачу в тех же ограничениях (поскольку ответ теперь очень большой, достаточно проверить его существование)?497D - ШестерниЕсли в какой-то момент произошло столкновение, это значит, что какая-то вершина одного из многоугольников попала на одну из сторон другого многоугольника. Рассмотрим систему отсчета, в которой многоугольник A неподвижен. В этой системе многоугольник B перемещается параллельно сам себе, и каждая его точка описывает окружность. Если мы пересечем все окружности, которые описывают вершины B, со всеми сторонами A, мы можем проверить, попадает ли какая-то из вершин B на границу A. Аналогично, перейдем в систему отсчета, связанную с B, и проверим, попадает ли вершина A на границу B. Ограничения на координаты позволяют выполнять проверки абсолютно точно.Другой подход к тому же самому по сути решению: пусть в системе отсчета, связанной с A, произошло столкновение. Тогда выполнено векторное равенство x + y = z, где z — вектор с началом в точке P и концом где-то на границе A, x — вектор с началом в точке Q и концом где-то на границе B, y — вектор с началом в P и концом где-то на окружности с центром в P, проходящей через Q. Если переписать это равенство как y = z - x, можно увидеть, что все возможные значения z - x пробегают сумму Минковского многоугольников A и зеркального отражения B (с точностью до сдвига), y пробегает известную окружность. Сумму Минковского можно представить в виде объединения nm параллелограммов, каждый из которых — сумма двух сторон разных многоугольников; в конечном итоге, пересечем все границы всех параллелограммов с окружностью.Сложность обоих решений — O(nm). Как указано выше, существует решение в целых числах; однако, маленькие ограничения на координаты не позволяют легко свалить решения с вещественной арифметикой. Также велик был соблазн написать неточное численное решение; мы постарались отсечь все такие решения, и в итоге ни одно из них не зашло. =)Многие имели проблемы с 8-ым претестом. Он выглядит так (левая спираль вращается вокруг левой точки, правая вокруг правой):Challenge: пусть мы хотим завалить решение с вещественной арифметикой. Построим тест, в котором многоугольники не сталкиваются, но проходят очень близко друг к другу. Какое минимальное положительное расстояние мы можем получить в заданных ограничениях на количество вершин и координаты?497E - Подпоследовательности возвращаютсяПусть дана какая-то строка. Как посчитать количество ее различных подпоследовательностей? Будем приписывать символы к концу по одному и считать, сколько новых подпоследовательностей появилось. Пусть к строке s приписали символ c; в строке s + c на символ c заканчивается столько же подпоследовательностей, сколько их было всего в строке s. Если их прибавить к количеству подпоследовательностей s, каждая подпоследовательность s + c учтется по одному разу, кроме тех, которые заканчиваются на c и присутствовали в строке s: они учтутся дважды. Это приводит к следующему решению: будем хранить, сколько последовательностей заканчивается на каждый из возможных символов — cntc, тогда при добавлении символа c значение cntc надо заменить на сумму всех cnt плюс один (за пустую последовательность); ответ для всей строки равен сумме всех cnt (плюс один, если нам надо учесть пустую последовательность). Например, рассмотрим первые несколько символов строки Туе-Морса: ε — (0, 0) 0 — ( 0 + 0 + 1 = 1, 0) 01 — (1, 1 + 0 + 1 = 2) 011 — (1, 1 + 2 + 1 = 4) 0110 — ( 1 + 4 + 1 = 6, 4) ... Легко видеть, что если значения cnt на данном шаге выписать как координаты вектора, и добавить к ним координату, тождественно равную 1, то приписывание одного символа к строке влияет на вектор как умножение на матрицу; естественным образом сопоставим каждой строке описанную матрицу.Рассмотрим префикс последовательности ai длины km. Если разделить его на k кусков длины km - 1, окажется, что i-ый из этих кусков может быть получен из 0-го прибавлением ко всем элементам i по модулю k. Будем насчитывать матрицы для префиксов длины km, а также для всех строк, получающихся из префикса прибавлением ко всем его элементам какого-то числа x; обозначим такую матрицу за Am, x.Легко видеть, что при m > 0 . Эта формула позволяет нам вычислить Am, x для всех и x от 0 до k - 1 за время . Теперь, имея все Am, x, мы легко можем перемножить некоторые из них в нужном порядке, чтобы получить матрицу для префикса ai длины n.К сожалению, пока что решение не укладывается в ограничения по времени. Один из способов получить решающее ускорение таков: заметим, что в формуле произведение можно разбить следующим образом: Am - 1, x... Am - 1, k - 1 × Am - 1, 0... Am - 1, x - 1 (если x = 0, вторая часть произведения пуста). Посчитаем для всех x произведения <<префиксов>> и <<суффиксов>> набора Am, x: Pm, x = Am, 0... Am, x - 1, Sm, x = Am, x... Am, k - 1. Теперь Am, x = Sm - 1, xPm - 1, x. Теперь вычисление Am, x для всех x при выбранном m сводится к вычислению Pm - 1, x, Sm - 1, x за O(k) умножений матриц, после чего каждый элемент Am, x вычисляется за одно перемножение. Таким образом, наше решение теперь работает за , что укладывается в ограничения с запасом.Challenge: решите задачу при k ≤ 100.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/15208",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 497\\s*E"
          },
          "content_length": 11504
        },
        {
          "title": "Codeforces Round #283: разбор (+бонусы!) - Codeforces",
          "content": "К каждой задаче присутствует challenge — бонусная задача на тему, которую можно порешать just for fun и обсудить в комментариях. =)496A - Минимальная сложностьПереберем все элементы, которые можем выкинуть, пройдем по оставшимся элементам и посчитаем максимальную разность среди соседних. Это решение имеет сложность O(n2). Можно заметить, что при удалении элемента ответ либо не поменялся, либо стал равен разности тех элементов, которые являлись соседями только что удаленного, поэтому ответ можно получить за O(1), а итоговое решение будет иметь сложность O(n). Ограничения позволяли сдать любое из этих решений или даже менее эффективное.Challenge: пусть мы удаляем не один элемент, а k любых элементов (первый и последний, как и раньше, удалять нельзя). Какую минимальную максимальную разность между соседними элементами мы можем получить? Решите задачу в ограничениях 1 ≤ k ≤ n - 2, n ≤ 105, ai ≤ 109.496B - Секретный кодЗаметим, что нам неважно, в каком порядке применяются операции: мы можем сперва выполнить все сдвиги, а затем все прибавления. После n сдвигов мы получаем исходную последовательность, поэтому достаточно рассмотреть только варианты, где сдвиги выполняются менее n раз. Аналогично, после десяти прибавлений единицы ко всем цифрам получим исходную последовательность, поэтому рассмотрим только варианты, где прибавления выполняются менее десяти раз. Для каждого из 10n вариантов определим результат применения всех операций; сохраним лучший результат и для каждого из вариантов сравним с лучшим. Сравнения осуществляются за O(n) операций, поэтому итоговое количество элементарных операций имеет порядок 10n2. От константы 10 можно избавиться, если заметить, что при фиксированном сдвиге первую цифру всегда выгодно сделать нулем, и это однозначно определяет количество прибавлений; однако, чтобы сдать задачу, эта оптимизация не требовалась.Challenge: можете ли вы решить задачу за время ? O(n)?496C - Удаление столбцов/497A - Удаление столбцовПосмотрим на первый столбец таблицы. Если буквы в нем не упорядочены по алфавиту сверху вниз, его нельзя оставить ни в каком корректном варианте оставить некоторые столбцы. С другой стороны, пусть буквы в первом столбце упорядочены, но в ответ мы его не взяли. Добавим его к ответу; несложно видеть, что в новом варианте оставить столбцы все строки также упорядочены сверху вниз по алфавиту.Будем рассматривать столбцы слева направо. Если мы попробовали добавить текущий столбец к ответу и лексикографический порядок строк где-то нарушился, мы обязаны его удалить; если же все в порядке, возьмем его в ответ. Рассуждение, аналогичное предыдущему абзацу, показывает, что такой жадный алгоритм приводит к оптимальному (и более того, единственному среди оптимальных) ответу. Итоговая сложность — O(n2).Challenge: сколько существует таблиц n × m, для которых ответ на эту задачу равен k? Придумайте как можно более оптимальное решение.496D - Игра в теннис/497B - Игра в теннисФиксируем t; теперь мы можем проэмулировать ход партии и убедиться, что запись является корректной, а также определить соответствующее s; выведем все подходящие пары s и t. Такое решение работает за O(n2), попробуем его соптимизировать.Если после окончания очередного сета мы обработали k розыгрышей, то позицию окончания следующего сета можно определить так: найти t-ую позицию после k-ой, в которой записано 1, аналогично, найдем t-ую позицию, содержащую 2. Если позиция t-ой единицы встретилась раньше, то следующий сет выигрывает первый игрок, и позиция окончания сета совпадает с позицией t-ой единицы; аналогично разбирается случай, если раньше идет t-ая двойка. Если партия еще не кончилась, но в оставшейся части и единиц, и двоек менее t, то запись некорректна. Позицию t-ой единицы или двойки после заданной позиции можно определять за бинпоиском, или за O(1) при помощи предподсчитанного массива позиций.Теперь заметим, что для данного t партия из n розыгрышей не может содержать больше n / t сетов, поскольку каждый из них содержит как минимум t розыгрышей. Если мы просуммируем количество сетов в партии по всем возможным t, мы получим не более (известная сумма гармонического ряда). В зависимости от способа обработки одного сета итоговая сложность составляет либо ; любой из этих способов с запасом укладывается в ограничение.Очевидно, что для каждого t существует не более одного варианта s; однако, для данного s может существовать более одного варианта t. Первый тест с таким случаем — претест 12. В условии требуется выводить ответ в лексикографическом порядке пар; здесь легко допустить ошибку и вывести пары с равными s по убыванию t (если в конце просто переворачивать массив).Challenge: при подготовке этой задачи я столкнулся с тем, что не могу построить тест с большим количеством пар в ответе; в тестах к задаче максимальное количество — 128 = количество делителей числа 83160. Сможете ли вы побить этот рекорд? Хвастайтесь в комментариях, сколько пар вы умеете получать при n ≤ 105; если у вас есть соображения, как оценить максимальное количество пар теоретически, тоже прошу делиться.496E - Распределение партий/497C - Распределение партийОтсортируем все партии и всех актеров вместе по возрастанию нижней границы (при равенстве сначала идут все актеры, потом все партии); пойдем в этом порядке по возрастанию нижней границы. Будем поддерживать множество актеров, которые уже <<начались>>, т.е. встретились в этом порядке раньше; если мы встретили актера, добавим его в это множество. Если мы встретили партию (aj, bj), из множества допустимых актеров нам нужно выбрать такого, у которого di ≥ bj (требование ci ≤ aj гарантируется тем, что i-ый актер встретился раньше, чем j-ая партия); если таких актеров в множестве нет, мы не можем получить ответ. Если таких актеров несколько, нам выгоднее брать того из них, у которого di минимально (интуитивно, он нам в дальнейшем меньше пригодится). Сопоставим текущую партию выбранному актеру и уменьшим его ki на единицу; если теперь ki = 0, мы больше не можем пользоваться этим актером и должны выкинуть его из множества.Чтобы уложиться в ограничения, множество текущих актеров приходится поддерживать в эффективной структуре данных (например, std::set или декартово дерево). Сложность итогового решения .Challenge: пусть каждая песня присутствует в количестве qj (1 ≤ qj ≤ 109), и каждой копии надо сопоставить своего актера. можете ли вы решить задачу в тех же ограничениях (поскольку ответ теперь очень большой, достаточно проверить его существование)?497D - ШестерниЕсли в какой-то момент произошло столкновение, это значит, что какая-то вершина одного из многоугольников попала на одну из сторон другого многоугольника. Рассмотрим систему отсчета, в которой многоугольник A неподвижен. В этой системе многоугольник B перемещается параллельно сам себе, и каждая его точка описывает окружность. Если мы пересечем все окружности, которые описывают вершины B, со всеми сторонами A, мы можем проверить, попадает ли какая-то из вершин B на границу A. Аналогично, перейдем в систему отсчета, связанную с B, и проверим, попадает ли вершина A на границу B. Ограничения на координаты позволяют выполнять проверки абсолютно точно.Другой подход к тому же самому по сути решению: пусть в системе отсчета, связанной с A, произошло столкновение. Тогда выполнено векторное равенство x + y = z, где z — вектор с началом в точке P и концом где-то на границе A, x — вектор с началом в точке Q и концом где-то на границе B, y — вектор с началом в P и концом где-то на окружности с центром в P, проходящей через Q. Если переписать это равенство как y = z - x, можно увидеть, что все возможные значения z - x пробегают сумму Минковского многоугольников A и зеркального отражения B (с точностью до сдвига), y пробегает известную окружность. Сумму Минковского можно представить в виде объединения nm параллелограммов, каждый из которых — сумма двух сторон разных многоугольников; в конечном итоге, пересечем все границы всех параллелограммов с окружностью.Сложность обоих решений — O(nm). Как указано выше, существует решение в целых числах; однако, маленькие ограничения на координаты не позволяют легко свалить решения с вещественной арифметикой. Также велик был соблазн написать неточное численное решение; мы постарались отсечь все такие решения, и в итоге ни одно из них не зашло. =)Многие имели проблемы с 8-ым претестом. Он выглядит так (левая спираль вращается вокруг левой точки, правая вокруг правой):Challenge: пусть мы хотим завалить решение с вещественной арифметикой. Построим тест, в котором многоугольники не сталкиваются, но проходят очень близко друг к другу. Какое минимальное положительное расстояние мы можем получить в заданных ограничениях на количество вершин и координаты?497E - Подпоследовательности возвращаютсяПусть дана какая-то строка. Как посчитать количество ее различных подпоследовательностей? Будем приписывать символы к концу по одному и считать, сколько новых подпоследовательностей появилось. Пусть к строке s приписали символ c; в строке s + c на символ c заканчивается столько же подпоследовательностей, сколько их было всего в строке s. Если их прибавить к количеству подпоследовательностей s, каждая подпоследовательность s + c учтется по одному разу, кроме тех, которые заканчиваются на c и присутствовали в строке s: они учтутся дважды. Это приводит к следующему решению: будем хранить, сколько последовательностей заканчивается на каждый из возможных символов — cntc, тогда при добавлении символа c значение cntc надо заменить на сумму всех cnt плюс один (за пустую последовательность); ответ для всей строки равен сумме всех cnt (плюс один, если нам надо учесть пустую последовательность). Например, рассмотрим первые несколько символов строки Туе-Морса: ε — (0, 0) 0 — ( 0 + 0 + 1 = 1, 0) 01 — (1, 1 + 0 + 1 = 2) 011 — (1, 1 + 2 + 1 = 4) 0110 — ( 1 + 4 + 1 = 6, 4) ... Легко видеть, что если значения cnt на данном шаге выписать как координаты вектора, и добавить к ним координату, тождественно равную 1, то приписывание одного символа к строке влияет на вектор как умножение на матрицу; естественным образом сопоставим каждой строке описанную матрицу.Рассмотрим префикс последовательности ai длины km. Если разделить его на k кусков длины km - 1, окажется, что i-ый из этих кусков может быть получен из 0-го прибавлением ко всем элементам i по модулю k. Будем насчитывать матрицы для префиксов длины km, а также для всех строк, получающихся из префикса прибавлением ко всем его элементам какого-то числа x; обозначим такую матрицу за Am, x.Легко видеть, что при m > 0 . Эта формула позволяет нам вычислить Am, x для всех и x от 0 до k - 1 за время . Теперь, имея все Am, x, мы легко можем перемножить некоторые из них в нужном порядке, чтобы получить матрицу для префикса ai длины n.К сожалению, пока что решение не укладывается в ограничения по времени. Один из способов получить решающее ускорение таков: заметим, что в формуле произведение можно разбить следующим образом: Am - 1, x... Am - 1, k - 1 × Am - 1, 0... Am - 1, x - 1 (если x = 0, вторая часть произведения пуста). Посчитаем для всех x произведения <<префиксов>> и <<суффиксов>> набора Am, x: Pm, x = Am, 0... Am, x - 1, Sm, x = Am, x... Am, k - 1. Теперь Am, x = Sm - 1, xPm - 1, x. Теперь вычисление Am, x для всех x при выбранном m сводится к вычислению Pm - 1, x, Sm - 1, x за O(k) умножений матриц, после чего каждый элемент Am, x вычисляется за одно перемножение. Таким образом, наше решение теперь работает за , что укладывается в ограничения с запасом.Challenge: решите задачу при k ≤ 100.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/15208",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 497\\s*E"
          },
          "content_length": 11504
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #283 - Codeforces - Code 1",
          "code": "18\n2 2   2 2   2 2   1 2 1   1 2 1   1 2 1   1 2 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15197",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #283 - Codeforces - Code 2",
          "code": "18\n2 2   2 2   2 2   1 2 1   1 2 1   1 2 1   1 2 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15197",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #283 - Codeforces - Code 3",
          "code": "ans[ac]=i;\n       ac++;\n    }\n}\nreturn ac;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15197",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #283 - Codeforces - Code 4",
          "code": "ans[ac]=i;\n       ac++;\n    }\n}\nreturn ac;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15197",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #283 - Codeforces - Code 5",
          "code": "cin>>n;\nfor (int i=0;i<n;i++) cin>>a[i];\nfor (int i=0;i<n;i++) {\n    if (a[i]==1) x++; else y++;\n    f[i]=max(x,y);\n}\nint z=fact(f[n-1]);\nif (x==y) {\n    cout<<\"0\";\n} else {\n    cout<<ac<<endl;\n    for (int i=0;i<ac;i++) {\n       cout<<ans[i]<<\" \"<<f[n-1]/ans[i]<<endl;\n    }\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15197",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #283 - Codeforces - Code 6",
          "code": "cin>>n;\nfor (int i=0;i<n;i++) cin>>a[i];\nfor (int i=0;i<n;i++) {\n    if (a[i]==1) x++; else y++;\n    f[i]=max(x,y);\n}\nint z=fact(f[n-1]);\nif (x==y) {\n    cout<<\"0\";\n} else {\n    cout<<ac<<endl;\n    for (int i=0;i<ac;i++) {\n       cout<<ans[i]<<\" \"<<f[n-1]/ans[i]<<endl;\n    }\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15197",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #283 - Codeforces - Code 7",
          "code": "memset(to_used, 0, sizeof(n));",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15197",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #283 - Codeforces - Code 8",
          "code": "memset(to_used, 0, sizeof(n));",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15197",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #283 - Codeforces - Code 9",
          "code": "ae ae et oe",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15197",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #283 - Codeforces - Code 10",
          "code": "20\n1 1 2 2 2 2 2 2 2 2 2 2 1 2 2 1 2 2 2 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15197",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #283 - Codeforces - Code 11",
          "code": "20\n1 1 2 2 2 2 2 2 2 2 2 2 1 2 2 1 2 2 2 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15197",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #283: разбор (+бонусы!) - Codeforces - Code 1",
          "code": "#include <iostream>\n#include <cstring>\n#include <stdlib.h>\n#include <stdio.h>\nusing namespace std;\n\nint main()\n{   int n;\n    cin >> n;\n    char *c = new char [n];\n    char *l = new char [n];\n    for (int i=0; i<n; i++)\n        l[i]='A';\n    cin >> c;\n    for (int k=0; k<10; k++){\n        for (int i=0; i<n; i++){\n            c[i]=((c[i]-48)+1)%10 +48;\n        }\n    for (int i=0; i<n; i++){\n        char u;\n        u=c[n-1];\n        for (int j=n-1; j>=1; j--){\n            c[j]=c[j-1];\n        }\n        c[0]=u;\n        int z=0;\n        while (c[z]==l[z]) z++;\n        if (c[z]<l[z]) {strcpy(l,c);}\n    }\n\n    }\n    cout << l;\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/15208",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #283: разбор (+бонусы!) - Codeforces - Code 2",
          "code": "#include <iostream>\n#include <cstring>\n#include <stdlib.h>\n#include <stdio.h>\nusing namespace std;\n\nint main()\n{   int n;\n    cin >> n;\n    char *c = new char [n];\n    char *l = new char [n];\n    for (int i=0; i<n; i++)\n        l[i]='A';\n    cin >> c;\n    for (int k=0; k<10; k++){\n        for (int i=0; i<n; i++){\n            c[i]=((c[i]-48)+1)%10 +48;\n        }\n    for (int i=0; i<n; i++){\n        char u;\n        u=c[n-1];\n        for (int j=n-1; j>=1; j--){\n            c[j]=c[j-1];\n        }\n        c[0]=u;\n        int z=0;\n        while (c[z]==l[z]) z++;\n        if (c[z]<l[z]) {strcpy(l,c);}\n    }\n\n    }\n    cout << l;\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/15208",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #283: разбор (+бонусы!) - Codeforces - Code 3",
          "code": "char *c = new char [n + 1];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15208",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #283: разбор (+бонусы!) - Codeforces - Code 4",
          "code": "strcpy(l, c)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15208",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #283: разбор (+бонусы!) - Codeforces - Code 5",
          "code": "strncpy(l, c, n);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15208",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #283: разбор (+бонусы!) - Codeforces - Code 6",
          "code": "std::string",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15208",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #283: разбор (+бонусы!) - Codeforces - Code 7",
          "code": "m1=b[d[k]+t];\n     m2=c[e[k]+t];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15208",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #283: разбор (+бонусы!) - Codeforces - Code 8",
          "code": "m1=b[d[k]+t];\n     m2=c[e[k]+t];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15208",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #283: разбор (+бонусы!) - Codeforces - Code 9",
          "code": "n + n/2 + n/3 + ... + n/(n - 1) + 1 == nlog(n)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15208",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #283: разбор (+бонусы!) - Codeforces - Code 10",
          "code": "n + n/2 + n/3 + ... + n/(n - 1) + 1 == nlog(n)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15208",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #283: разбор (+бонусы!) - Codeforces - Code 11",
          "code": "496D - Tennis Game",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15208",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #283: разбор (+бонусы!) - Codeforces - Code 12",
          "code": "number of valid (s,t) will be 0 if the total number of points of player who won  the last point is less than or equal to another player",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15208",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #283: разбор (+бонусы!) - Codeforces - Code 13",
          "code": "strictly more",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15208",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #283: разбор (+бонусы!) - Codeforces - Code 14",
          "code": "The Minkowski sum can be represented as a union of nm parallelograms, each of which is the Minkowski sum of a pair of sides of different polygons;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15208",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #283: разбор (+бонусы!) - Codeforces - Code 15",
          "code": "circle_segment",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15208",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #283: разбор (+бонусы!) - Codeforces - Code 16",
          "code": "ll dmax = (max((a - c) | (a - c), (a - b) | (a - b))); -> ll dmax = (max((a - c) | (a - c), (b - c) | (b - c)));",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15208",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #283: разбор (+бонусы!) - Codeforces - Code 17",
          "code": "ll dmax = (max((a - c) | (a - c), (a - b) | (a - b))); -> ll dmax = (max((a - c) | (a - c), (b - c) | (b - c)));",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15208",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #283: разбор (+бонусы!) - Codeforces - Code 1",
          "code": "#include <iostream>\n#include <cstring>\n#include <stdlib.h>\n#include <stdio.h>\nusing namespace std;\n\nint main()\n{   int n;\n    cin >> n;\n    char *c = new char [n];\n    char *l = new char [n];\n    for (int i=0; i<n; i++)\n        l[i]='A';\n    cin >> c;\n    for (int k=0; k<10; k++){\n        for (int i=0; i<n; i++){\n            c[i]=((c[i]-48)+1)%10 +48;\n        }\n    for (int i=0; i<n; i++){\n        char u;\n        u=c[n-1];\n        for (int j=n-1; j>=1; j--){\n            c[j]=c[j-1];\n        }\n        c[0]=u;\n        int z=0;\n        while (c[z]==l[z]) z++;\n        if (c[z]<l[z]) {strcpy(l,c);}\n    }\n\n    }\n    cout << l;\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/15208",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #283: разбор (+бонусы!) - Codeforces - Code 2",
          "code": "#include <iostream>\n#include <cstring>\n#include <stdlib.h>\n#include <stdio.h>\nusing namespace std;\n\nint main()\n{   int n;\n    cin >> n;\n    char *c = new char [n];\n    char *l = new char [n];\n    for (int i=0; i<n; i++)\n        l[i]='A';\n    cin >> c;\n    for (int k=0; k<10; k++){\n        for (int i=0; i<n; i++){\n            c[i]=((c[i]-48)+1)%10 +48;\n        }\n    for (int i=0; i<n; i++){\n        char u;\n        u=c[n-1];\n        for (int j=n-1; j>=1; j--){\n            c[j]=c[j-1];\n        }\n        c[0]=u;\n        int z=0;\n        while (c[z]==l[z]) z++;\n        if (c[z]<l[z]) {strcpy(l,c);}\n    }\n\n    }\n    cout << l;\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/15208",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #283: разбор (+бонусы!) - Codeforces - Code 3",
          "code": "char *c = new char [n + 1];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15208",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #283: разбор (+бонусы!) - Codeforces - Code 4",
          "code": "strcpy(l, c)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15208",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #283: разбор (+бонусы!) - Codeforces - Code 5",
          "code": "strncpy(l, c, n);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15208",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #283: разбор (+бонусы!) - Codeforces - Code 6",
          "code": "std::string",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15208",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #283: разбор (+бонусы!) - Codeforces - Code 7",
          "code": "m1=b[d[k]+t];\n     m2=c[e[k]+t];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15208",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #283: разбор (+бонусы!) - Codeforces - Code 8",
          "code": "m1=b[d[k]+t];\n     m2=c[e[k]+t];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15208",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #283: разбор (+бонусы!) - Codeforces - Code 9",
          "code": "n + n/2 + n/3 + ... + n/(n - 1) + 1 == nlog(n)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15208",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #283: разбор (+бонусы!) - Codeforces - Code 10",
          "code": "n + n/2 + n/3 + ... + n/(n - 1) + 1 == nlog(n)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15208",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #283: разбор (+бонусы!) - Codeforces - Code 11",
          "code": "496D - Tennis Game",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15208",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #283: разбор (+бонусы!) - Codeforces - Code 12",
          "code": "number of valid (s,t) will be 0 if the total number of points of player who won  the last point is less than or equal to another player",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15208",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #283: разбор (+бонусы!) - Codeforces - Code 13",
          "code": "strictly more",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15208",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #283: разбор (+бонусы!) - Codeforces - Code 14",
          "code": "The Minkowski sum can be represented as a union of nm parallelograms, each of which is the Minkowski sum of a pair of sides of different polygons;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15208",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #283: разбор (+бонусы!) - Codeforces - Code 15",
          "code": "circle_segment",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15208",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #283: разбор (+бонусы!) - Codeforces - Code 16",
          "code": "ll dmax = (max((a - c) | (a - c), (a - b) | (a - b))); -> ll dmax = (max((a - c) | (a - c), (b - c) | (b - c)));",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15208",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #283: разбор (+бонусы!) - Codeforces - Code 17",
          "code": "ll dmax = (max((a - c) | (a - c), (a - b) | (a - b))); -> ll dmax = (max((a - c) | (a - c), (b - c) | (b - c)));",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15208",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    long long n = inf.readLong(1LL, 1000000000000000000LL, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(2, 30, \"k\");\n    inf.readEoln();\n    \n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    long long n = inf.readLong(1LL, 1000000000000000000LL, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(2, 30, \"k\");\n    inf.readEoln();\n    \n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    long long n = inf.readLong(1LL, 1000000000000000000LL, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(2, 30, \"k\");\n    inf.readEoln();\n    \n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    long long n = opt<long long>(\"n\", 100);\n    int k = opt<int>(\"k\", 2);\n    string type = opt<string>(\"type\", \"random\");\n\n    if (type == \"min\") {\n        // Minimum values for n and k\n        n = 1;\n        k = 2;\n    } else if (type == \"max_n\") {\n        // Maximum value for n\n        n = (long long)1e18;\n    } else if (type == \"max_k\") {\n        // Maximum value for k\n        k = 30;\n    } else if (type == \"max_nk\") {\n        // Maximum values for both n and k\n        n = (long long)1e18;\n        k = 30;\n    } else if (type == \"small_nk\") {\n        // Small values for n and k\n        n = 10;\n        k = 5;\n    } else if (type == \"large_n_small_k\") {\n        // Large n, small k\n        n = (long long)1e18;\n        k = 2;\n    } else if (type == \"small_n_large_k\") {\n        // Small n, large k\n        n = 10;\n        k = 30;\n    } else if (type == \"n_power_of_k\") {\n        // n is a power of k\n        k = rnd.next(2, 30);\n        n = 1;\n        for (int i = 0; i < rnd.next(1, 10); ++i) {\n            n *= k;\n            if (n > (long long)1e18) {\n                n = (long long)1e18;\n                break;\n            }\n        }\n    } else if (type == \"all_ai_zero\") {\n        // All ai are zero, n = 1\n        n = 1;\n        k = rnd.next(2, 30);\n    } else if (type == \"all_ai_one\") {\n        // All ai are one, n = 1\n        n = 1;\n        k = rnd.next(2, 30);\n    } else if (type == \"increasing_ai\") {\n        // ai is increasing, n = k\n        k = rnd.next(2, 30);\n        n = k;\n    } else if (type == \"random\") {\n        // Random n and k within constraints\n        n = rnd.next(1LL, (long long)1e18);\n        k = rnd.next(2, 30);\n    }\n\n    // Output n and k\n    printf(\"%lld %d\\n\", n, k);\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    long long n = opt<long long>(\"n\", 100);\n    int k = opt<int>(\"k\", 2);\n    string type = opt<string>(\"type\", \"random\");\n\n    if (type == \"min\") {\n        // Minimum values for n and k\n        n = 1;\n        k = 2;\n    } else if (type == \"max_n\") {\n        // Maximum value for n\n        n = (long long)1e18;\n    } else if (type == \"max_k\") {\n        // Maximum value for k\n        k = 30;\n    } else if (type == \"max_nk\") {\n        // Maximum values for both n and k\n        n = (long long)1e18;\n        k = 30;\n    } else if (type == \"small_nk\") {\n        // Small values for n and k\n        n = 10;\n        k = 5;\n    } else if (type == \"large_n_small_k\") {\n        // Large n, small k\n        n = (long long)1e18;\n        k = 2;\n    } else if (type == \"small_n_large_k\") {\n        // Small n, large k\n        n = 10;\n        k = 30;\n    } else if (type == \"n_power_of_k\") {\n        // n is a power of k\n        k = rnd.next(2, 30);\n        n = 1;\n        for (int i = 0; i < rnd.next(1, 10); ++i) {\n            n *= k;\n            if (n > (long long)1e18) {\n                n = (long long)1e18;\n                break;\n            }\n        }\n    } else if (type == \"all_ai_zero\") {\n        // All ai are zero, n = 1\n        n = 1;\n        k = rnd.next(2, 30);\n    } else if (type == \"all_ai_one\") {\n        // All ai are one, n = 1\n        n = 1;\n        k = rnd.next(2, 30);\n    } else if (type == \"increasing_ai\") {\n        // ai is increasing, n = k\n        k = rnd.next(2, 30);\n        n = k;\n    } else if (type == \"random\") {\n        // Random n and k within constraints\n        n = rnd.next(1LL, (long long)1e18);\n        k = rnd.next(2, 30);\n    }\n\n    // Output n and k\n    printf(\"%lld %d\\n\", n, k);\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -type min\n./gen -type max_n\n./gen -type max_k\n./gen -type max_nk\n./gen -type small_nk\n./gen -type large_n_small_k\n./gen -type small_n_large_k\n./gen -type n_power_of_k\n./gen -type n_power_of_k\n./gen -type n_power_of_k\n./gen -type all_ai_zero\n./gen -type all_ai_one\n./gen -type increasing_ai\n./gen -type random\n./gen -type random\n./gen -type random\n./gen -n 1 -k 2\n./gen -n 1 -k 30\n./gen -n 2 -k 2\n./gen -n 2 -k 30\n./gen -n 10 -k 2\n./gen -n 10 -k 30\n./gen -n 100 -k 5\n./gen -n 1000 -k 15\n./gen -n 1000000 -k 30\n./gen -n 999999999999999999 -k 2\n./gen -n 1000000000000000000 -k 29\n./gen -n 1000000000000000000 -k 30\n./gen -n 123456789012345678 -k 7\n./gen -n 987654321098765432 -k 17\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:39:15.747466",
        "total_tutorials": 3,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "498/A",
      "title": "A. Crazy Town",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains two space-separated integers x1, y1 ( - 106 ≤ x1, y1 ≤ 106) — the coordinates of your home.The second line contains two integers separated by a space x2, y2 ( - 106 ≤ x2, y2 ≤ 106) — the coordinates of the university you are studying at.The third line contains an integer n (1 ≤ n ≤ 300) — the number of roads in the city. The following n lines contain 3 space-separated integers ( - 106 ≤ ai, bi, ci ≤ 106; |ai| + |bi| > 0) — the coefficients of the line aix + biy + ci = 0, defining the i-th road. It is guaranteed that no two roads are the same. In addition, neither your home nor the university lie on the road (i.e. they do not belong to any one of the lines).",
      "output_spec": "OutputOutput the answer to the problem.",
      "sample_tests": "ExamplesInputCopy1 1-1 -120 1 01 0 0OutputCopy2InputCopy1 1-1 -131 0 00 1 01 1 -3OutputCopy2",
      "description": "A. Crazy Town\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains two space-separated integers x1, y1 ( - 106 ≤ x1, y1 ≤ 106) — the coordinates of your home.The second line contains two integers separated by a space x2, y2 ( - 106 ≤ x2, y2 ≤ 106) — the coordinates of the university you are studying at.The third line contains an integer n (1 ≤ n ≤ 300) — the number of roads in the city. The following n lines contain 3 space-separated integers ( - 106 ≤ ai, bi, ci ≤ 106; |ai| + |bi| > 0) — the coefficients of the line aix + biy + ci = 0, defining the i-th road. It is guaranteed that no two roads are the same. In addition, neither your home nor the university lie on the road (i.e. they do not belong to any one of the lines).\n\nOutputOutput the answer to the problem.\n\nInputCopy1 1-1 -120 1 01 0 0OutputCopy2InputCopy1 1-1 -131 0 00 1 01 1 -3OutputCopy2\n\nInputCopy1 1-1 -120 1 01 0 0\n\nOutputCopy2\n\nInputCopy1 1-1 -131 0 00 1 01 1 -3\n\nOutputCopy2\n\nNotePictures to the samples are presented below (A is the point representing the house; B is the point representing the university, different blocks are filled with different colors):",
      "solutions": [
        {
          "title": "Codeforces Round #284 - Codeforces",
          "content": "Soon you are lucky to participate in Codeforces Round #284, and problems have been prepared by Vitaly Gridnev (gridnevvvit), Ilya Los (IlyaLos), Danil Sagunov (danilka.pro).We want to thank Max Akhmedov (Zlobober) for help with preparation of this round, Maria Belova (Delinur) for translation of statements and Mike Mirzayanov (MikeMirzayanov) for marvelous Codeforces and Polygon systems.Scoring system will be dynamic. Problems will be arranged in ascending expected difficulty order.Round finished, congratulations to winners!Div1: yeputons rng_58 Endagorion KADR Egor uwi mmaxio atetubou RAVEman Div2: sorry_dreamoon dreamoon_love_AA dreamoon_fan EditorialGood luck!",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/15336",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 671
        },
        {
          "title": "Codeforces Round #284 Editorial - Codeforces",
          "content": "499A - Watching a movieOne can solve the problem using greedy algorithm: if we can skip x minutes at current moment without skipping any good moment — we do that, otherwise — watch another minute of the film.499B - LectureIn this task you must find for every string in the text the pair containing that string, and from two strings of that pair output the shortest one.498A - Crazy Town / 499C - Crazy TownIt can be easily proved that, if two points from statement are placed on different sides of some line, this line will be crossed anyway. So, all we need to do is to cross all these lines, so the answer is the number of these lines.To check if two points lies on different sides of a line one can simply use its coordinates to place in line equation and check if these two values have different signs. Solution complexity — O(n).498B - Name That Tune / 499D - Name That TuneLet's numerate all the songs and seconds starting from 0.Problem will be solved using DP approach. State will be described by two integers (i, j): dp[i][j] is probability of that we named exactly i songs, and the last named song was named exactly before j'th second (after j - 1 seconds). dp[0][0] = 1 obviously.To make a move from state (i, j) to state (i + 1, j + k) (1 ≤ k < ti), we must name the song exactly after k seconds its playing — probability of that is (1 - pi)k - 1·pi. To fixed state (i + 1, j) sum of that moves can be represented as . Simple calculation of this value for each state gives O(nT2) complexity, so one must notice, that this values can be calculated using two pointers for fixed i (in common case it represent a segment with ti length) for every j in time O(T). This way calculating this type of moves takes O(nT) time.There is also a move to (i + 1, j + ti) and a move from (i, j) to (i, (j + k) = T), when we couldn't name current song in time T. This types of moves is calculated with O(nT) too.Solution complexity — O(nT).498C - Array and Operations / 499E - Array and OperationsWe will divide only by prime numbers.First, let's build a graph, where each of n numbers have own vertex group:Find all prime factors of current number. Every factor will have its own vertex in a group, furthermore, if some factor p has power of ai in current number, it will have exactly ai vertexes in group.The number of vertexes in such graph is .Now we will make edges in our graph: edge between two vertexes exists if and only if there is a good pair (given in statement) of vertexes group numbers and the prime values of a vertexes are the same. That means that we can divide that group numbers by that prime.The number of edges is .Good pairs are given the way that our graph is bipartite. After finding maximum matching in this graph we represent the way of doing operations as described in the statement.As soon as solution is using Kuhn's algorithm, its complexity is . One could notice that some of the edges are useless and reduce it to .498D - Traffic Jams in the LandThe solution of a problem — 60 (LCM of a numbers from 2 to 6) segment trees.In v'th segment tree we will hold for every segment [l, r] the next value: minimum time needed to get from l to r if we start in a moment of time equal to v modulo 60. Using these trees' values it is easy to quickly answer the questions, carefully changing the trees' values.498E - Stairs and LinesThe problem is solved using DP approach dp[i][mask] — the number of ways to paint first i blocks of a ladder the way that the last layer of vertical edges is painted as described in mask mask. This could be easily recalculated using matrix M[mask1][mask2] — the number of ways to paint horizontal edges between two neighbour vertical layers painted as represented by masks mask1 and mask2.For fixed i we have wi layers, so this matrix must be multiplied by itself wi times, which can be quickly done by binary-pow algorithm. After that this matrix is simply used in dynamic described above.Solution complexity — .",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/15353",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 498\\s*A"
          },
          "content_length": 3961
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #284 - Codeforces - Code 1",
          "code": "while(true) System.out.println(\"NOOOOOOOOOOOOOOOOOOOO\");",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15336",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #284 - Codeforces - Code 2",
          "code": "6 6\n2 2 2 2 2 2\n1 2\n1 3\n2 3\n4 5\n4 6\n5 6",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15336",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #284 - Codeforces - Code 3",
          "code": "6 6\n2 2 2 2 2 2\n1 2\n1 3\n2 3\n4 5\n4 6\n5 6",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15336",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #284 Editorial - Codeforces - Code 1",
          "code": "for (int i = 0; i <= t; ++i) {\n    dp[i] = dp1[i]; sum += dp[i]; }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15353",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #284 Editorial - Codeforces - Code 2",
          "code": "for (int i = 0; i <= t; ++i) {\n    dp[i] = dp1[i]; sum += dp[i]; }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15353",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #284 Editorial - Codeforces - Code 3",
          "code": "double *ptr, *ptr1, *tptr;\nptr = dp;\nptr1 = dp1;\n\nfor (int i = 1; i < n; ++i) {\n    // Something to do...\n\n    tptr = ptr;\n    ptr = ptr1;\n    ptr1 = tptr;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15353",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #284 Editorial - Codeforces - Code 4",
          "code": "double *ptr, *ptr1, *tptr;\nptr = dp;\nptr1 = dp1;\n\nfor (int i = 1; i < n; ++i) {\n    // Something to do...\n\n    tptr = ptr;\n    ptr = ptr1;\n    ptr1 = tptr;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15353",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #284 Editorial - Codeforces - Code 5",
          "code": "double DP(int idx, int sec) {\n    if (sec > t)\n        return idx - 1;\n    if (sec == t or idx == n)\n        return idx;\n    double &ret = memo[idx][sec], tmp = 1;\n    if (ret == ret)\n        return ret;\n    ret = 0;\n    for (int i =1 ; i < ti[idx]; ++i) {\n        double &tret = memo[idx + 1][sec + i];\n        if (tret != tret)\n            tret = DP(idx + 1, sec + i);\n        ret += pi[idx] * tmp * tret;\n        tmp *= 1 - pi[idx];\n    }\n    return (ret += tmp * DP(idx + 1, sec + ti[idx]));\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15353",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #284 Editorial - Codeforces - Code 6",
          "code": "double DP(int idx, int sec) {\n    if (sec > t)\n        return idx - 1;\n    if (sec == t or idx == n)\n        return idx;\n    double &ret = memo[idx][sec], tmp = 1;\n    if (ret == ret)\n        return ret;\n    ret = 0;\n    for (int i =1 ; i < ti[idx]; ++i) {\n        double &tret = memo[idx + 1][sec + i];\n        if (tret != tret)\n            tret = DP(idx + 1, sec + i);\n        ret += pi[idx] * tmp * tret;\n        tmp *= 1 - pi[idx];\n    }\n    return (ret += tmp * DP(idx + 1, sec + ti[idx]));\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15353",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #284 Editorial - Codeforces - Code 7",
          "code": "3 3\n50 3\n50 2\n25 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15353",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #284 Editorial - Codeforces - Code 8",
          "code": "3 3\n50 3\n50 2\n25 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15353",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #284 Editorial - Codeforces - Code 9",
          "code": "2 5\n3 8\n13 13",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15353",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #284 Editorial - Codeforces - Code 10",
          "code": "2 5\n3 8\n13 13",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15353",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nlong long gcd(long long a, long long b) { return b ? gcd(b, a % b) : a; }\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int x1 = inf.readInt(-1000000, 1000000, \"x1\");\n    inf.readSpace();\n    int y1 = inf.readInt(-1000000, 1000000, \"y1\");\n    inf.readEoln();\n\n    int x2 = inf.readInt(-1000000, 1000000, \"x2\");\n    inf.readSpace();\n    int y2 = inf.readInt(-1000000, 1000000, \"y2\");\n    inf.readEoln();\n\n    int n = inf.readInt(1, 300, \"n\");\n    inf.readEoln();\n\n    set<tuple<long long, long long, long long>> lines;\n    for (int i = 0; i < n; ++i) {\n        int ai = inf.readInt(-1000000, 1000000, \"ai\");\n        inf.readSpace();\n        int bi = inf.readInt(-1000000, 1000000, \"bi\");\n        inf.readSpace();\n        int ci = inf.readInt(-1000000, 1000000, \"ci\");\n        inf.readEoln();\n\n        ensuref(ai != 0 || bi != 0, \"ai and bi should not both be zero at line %d\", i+4);\n\n        // check that home and university are not on the line\n        {\n            long long val1 = (long long)ai * x1 + (long long)bi * y1 + ci;\n            ensuref(val1 != 0, \"Home lies on the line %d\", i+1);\n            long long val2 = (long long)ai * x2 + (long long)bi * y2 + ci;\n            ensuref(val2 != 0, \"University lies on the line %d\", i+1);\n        }\n\n        // normalize the line\n        long long ai_l = ai, bi_l = bi, ci_l = ci;\n        long long g = gcd(abs(ai_l), abs(bi_l));\n        g = gcd(g, abs(ci_l));\n        if (g != 0) {\n            ai_l /= g;\n            bi_l /= g;\n            ci_l /= g;\n        }\n\n        // make the first non-zero coefficient positive\n        int sign = 1;\n        if (ai_l != 0) {\n            if (ai_l < 0) sign = -1;\n        } else if (bi_l != 0) {\n            if (bi_l < 0) sign = -1;\n        } else if (ci_l != 0) {\n            if (ci_l < 0) sign = -1;\n        }\n        ai_l *= sign;\n        bi_l *= sign;\n        ci_l *= sign;\n\n        tuple<long long, long long, long long> line = make_tuple(ai_l, bi_l, ci_l);\n\n        ensuref(lines.count(line) == 0, \"Line %d is the same as some previous line\", i+1);\n\n        lines.insert(line);\n    }\n\n    inf.readEof();\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nlong long gcd(long long a, long long b) { return b ? gcd(b, a % b) : a; }\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int x1 = inf.readInt(-1000000, 1000000, \"x1\");\n    inf.readSpace();\n    int y1 = inf.readInt(-1000000, 1000000, \"y1\");\n    inf.readEoln();\n\n    int x2 = inf.readInt(-1000000, 1000000, \"x2\");\n    inf.readSpace();\n    int y2 = inf.readInt(-1000000, 1000000, \"y2\");\n    inf.readEoln();\n\n    int n = inf.readInt(1, 300, \"n\");\n    inf.readEoln();\n\n    set<tuple<long long, long long, long long>> lines;\n    for (int i = 0; i < n; ++i) {\n        int ai = inf.readInt(-1000000, 1000000, \"ai\");\n        inf.readSpace();\n        int bi = inf.readInt(-1000000, 1000000, \"bi\");\n        inf.readSpace();\n        int ci = inf.readInt(-1000000, 1000000, \"ci\");\n        inf.readEoln();\n\n        ensuref(ai != 0 || bi != 0, \"ai and bi should not both be zero at line %d\", i+4);\n\n        // check that home and university are not on the line\n        {\n            long long val1 = (long long)ai * x1 + (long long)bi * y1 + ci;\n            ensuref(val1 != 0, \"Home lies on the line %d\", i+1);\n            long long val2 = (long long)ai * x2 + (long long)bi * y2 + ci;\n            ensuref(val2 != 0, \"University lies on the line %d\", i+1);\n        }\n\n        // normalize the line\n        long long ai_l = ai, bi_l = bi, ci_l = ci;\n        long long g = gcd(abs(ai_l), abs(bi_l));\n        g = gcd(g, abs(ci_l));\n        if (g != 0) {\n            ai_l /= g;\n            bi_l /= g;\n            ci_l /= g;\n        }\n\n        // make the first non-zero coefficient positive\n        int sign = 1;\n        if (ai_l != 0) {\n            if (ai_l < 0) sign = -1;\n        } else if (bi_l != 0) {\n            if (bi_l < 0) sign = -1;\n        } else if (ci_l != 0) {\n            if (ci_l < 0) sign = -1;\n        }\n        ai_l *= sign;\n        bi_l *= sign;\n        ci_l *= sign;\n\n        tuple<long long, long long, long long> line = make_tuple(ai_l, bi_l, ci_l);\n\n        ensuref(lines.count(line) == 0, \"Line %d is the same as some previous line\", i+1);\n\n        lines.insert(line);\n    }\n\n    inf.readEof();\n\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nlong long gcd(long long a, long long b) { return b ? gcd(b, a % b) : a; }\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int x1 = inf.readInt(-1000000, 1000000, \"x1\");\n    inf.readSpace();\n    int y1 = inf.readInt(-1000000, 1000000, \"y1\");\n    inf.readEoln();\n\n    int x2 = inf.readInt(-1000000, 1000000, \"x2\");\n    inf.readSpace();\n    int y2 = inf.readInt(-1000000, 1000000, \"y2\");\n    inf.readEoln();\n\n    int n = inf.readInt(1, 300, \"n\");\n    inf.readEoln();\n\n    set<tuple<long long, long long, long long>> lines;\n    for (int i = 0; i < n; ++i) {\n        int ai = inf.readInt(-1000000, 1000000, \"ai\");\n        inf.readSpace();\n        int bi = inf.readInt(-1000000, 1000000, \"bi\");\n        inf.readSpace();\n        int ci = inf.readInt(-1000000, 1000000, \"ci\");\n        inf.readEoln();\n\n        ensuref(ai != 0 || bi != 0, \"ai and bi should not both be zero at line %d\", i+4);\n\n        // check that home and university are not on the line\n        {\n            long long val1 = (long long)ai * x1 + (long long)bi * y1 + ci;\n            ensuref(val1 != 0, \"Home lies on the line %d\", i+1);\n            long long val2 = (long long)ai * x2 + (long long)bi * y2 + ci;\n            ensuref(val2 != 0, \"University lies on the line %d\", i+1);\n        }\n\n        // normalize the line\n        long long ai_l = ai, bi_l = bi, ci_l = ci;\n        long long g = gcd(abs(ai_l), abs(bi_l));\n        g = gcd(g, abs(ci_l));\n        if (g != 0) {\n            ai_l /= g;\n            bi_l /= g;\n            ci_l /= g;\n        }\n\n        // make the first non-zero coefficient positive\n        int sign = 1;\n        if (ai_l != 0) {\n            if (ai_l < 0) sign = -1;\n        } else if (bi_l != 0) {\n            if (bi_l < 0) sign = -1;\n        } else if (ci_l != 0) {\n            if (ci_l < 0) sign = -1;\n        }\n        ai_l *= sign;\n        bi_l *= sign;\n        ci_l *= sign;\n\n        tuple<long long, long long, long long> line = make_tuple(ai_l, bi_l, ci_l);\n\n        ensuref(lines.count(line) == 0, \"Line %d is the same as some previous line\", i+1);\n\n        lines.insert(line);\n    }\n\n    inf.readEof();\n\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\n// Function to compute GCD of two numbers\nint gcd(int a, int b) {\n    return b == 0 ? abs(a) : gcd(b, a % b);\n}\n\n// Function to compute GCD of three numbers\nint gcd3(int a, int b, int c) {\n    return gcd(gcd(a, b), c);\n}\n\n// Function to normalize the line coefficients\nvoid normalize(int &a, int &b, int &c) {\n    int g = gcd3(a, b, c);\n    if (g != 0) {\n        a /= g;\n        b /= g;\n        c /= g;\n    }\n    if (a < 0 || (a == 0 && b < 0)) {\n        a = -a;\n        b = -b;\n        c = -c;\n    }\n}\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    const int MAX_COORD = 1000000;\n    const int MAX_COEFF = 1000000;\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    int max_coord = opt<int>(\"max_coord\", MAX_COORD);\n\n    // Generate home and university coordinates\n    int x1 = rnd.next(-max_coord, max_coord);\n    int y1 = rnd.next(-max_coord, max_coord);\n    int x2 = rnd.next(-max_coord, max_coord);\n    int y2 = rnd.next(-max_coord, max_coord);\n    while (x1 == x2 && y1 == y2) {\n        // Ensure home and university are at different locations\n        x2 = rnd.next(-max_coord, max_coord);\n        y2 = rnd.next(-max_coord, max_coord);\n    }\n\n    printf(\"%d %d\\n\", x1, y1);\n    printf(\"%d %d\\n\", x2, y2);\n    printf(\"%d\\n\", n);\n\n    set<tuple<int, int, int>> roads;\n\n    if (type == \"random\") {\n        int n_roads = 0;\n        while (n_roads < n) {\n            int ai = rnd.next(-MAX_COEFF, MAX_COEFF);\n            int bi = rnd.next(-MAX_COEFF, MAX_COEFF);\n            while (ai == 0 && bi == 0) {\n                ai = rnd.next(-MAX_COEFF, MAX_COEFF);\n                bi = rnd.next(-MAX_COEFF, MAX_COEFF);\n            }\n            int ci = rnd.next(-MAX_COEFF, MAX_COEFF);\n            int s1 = ai * x1 + bi * y1 + ci;\n            int s2 = ai * x2 + bi * y2 + ci;\n            if (s1 == 0 || s2 == 0) continue; // Home or university lies on the road\n            // Normalize the road\n            normalize(ai, bi, ci);\n            auto road = make_tuple(ai, bi, ci);\n            if (roads.count(road)) continue; // Duplicate road\n            roads.insert(road);\n            n_roads++;\n            printf(\"%d %d %d\\n\", ai, bi, ci);\n        }\n    } else if (type == \"same_block\") {\n        int n_roads = 0;\n        while (n_roads < n) {\n            int ai = rnd.next(-MAX_COEFF, MAX_COEFF);\n            int bi = rnd.next(-MAX_COEFF, MAX_COEFF);\n            while (ai == 0 && bi == 0) {\n                ai = rnd.next(-MAX_COEFF, MAX_COEFF);\n                bi = rnd.next(-MAX_COEFF, MAX_COEFF);\n            }\n            int ci = rnd.next(-MAX_COEFF, MAX_COEFF);\n            int s1 = ai * x1 + bi * y1 + ci;\n            int s2 = ai * x2 + bi * y2 + ci;\n            if (s1 == 0 || s2 == 0) continue; // Home or university lies on the road\n            if ((s1 > 0 && s2 < 0) || (s1 < 0 && s2 > 0)) continue; // Road separates home and university\n            // Normalize the road\n            normalize(ai, bi, ci);\n            auto road = make_tuple(ai, bi, ci);\n            if (roads.count(road)) continue; // Duplicate road\n            roads.insert(road);\n            n_roads++;\n            printf(\"%d %d %d\\n\", ai, bi, ci);\n        }\n    } else if (type == \"adjacent_blocks\") {\n        // Generate one road that separates home and university\n        int ai, bi, ci;\n        while (true) {\n            ai = rnd.next(-MAX_COEFF, MAX_COEFF);\n            bi = rnd.next(-MAX_COEFF, MAX_COEFF);\n            while (ai == 0 && bi == 0) {\n                ai = rnd.next(-MAX_COEFF, MAX_COEFF);\n                bi = rnd.next(-MAX_COEFF, MAX_COEFF);\n            }\n            ci = rnd.next(-MAX_COEFF, MAX_COEFF);\n            int s1 = ai * x1 + bi * y1 + ci;\n            int s2 = ai * x2 + bi * y2 + ci;\n            if (s1 == 0 || s2 == 0) continue;\n            if ((s1 > 0 && s2 < 0) || (s1 < 0 && s2 > 0)) break; // Road separates home and university\n        }\n        // Normalize the road\n        normalize(ai, bi, ci);\n        roads.insert(make_tuple(ai, bi, ci));\n        printf(\"%d %d %d\\n\", ai, bi, ci);\n        int n_roads = 1;\n        // Fill the rest with random roads that do not separate home and university\n        while (n_roads < n) {\n            int ai = rnd.next(-MAX_COEFF, MAX_COEFF);\n            int bi = rnd.next(-MAX_COEFF, MAX_COEFF);\n            while (ai == 0 && bi == 0) {\n                ai = rnd.next(-MAX_COEFF, MAX_COEFF);\n                bi = rnd.next(-MAX_COEFF, MAX_COEFF);\n            }\n            int ci = rnd.next(-MAX_COEFF, MAX_COEFF);\n            int s1 = ai * x1 + bi * y1 + ci;\n            int s2 = ai * x2 + bi * y2 + ci;\n            if (s1 == 0 || s2 == 0) continue; // Home or university lies on the road\n            if ((s1 > 0 && s2 < 0) || (s1 < 0 && s2 > 0)) continue; // Road separates home and university\n            // Normalize the road\n            normalize(ai, bi, ci);\n            auto road = make_tuple(ai, bi, ci);\n            if (roads.count(road)) continue; // Duplicate road\n            roads.insert(road);\n            n_roads++;\n            printf(\"%d %d %d\\n\", ai, bi, ci);\n        }\n    } else {\n        // Default to 'random' if unknown type\n        int n_roads = 0;\n        while (n_roads < n) {\n            int ai = rnd.next(-MAX_COEFF, MAX_COEFF);\n            int bi = rnd.next(-MAX_COEFF, MAX_COEFF);\n            while (ai == 0 && bi == 0) {\n                ai = rnd.next(-MAX_COEFF, MAX_COEFF);\n                bi = rnd.next(-MAX_COEFF, MAX_COEFF);\n            }\n            int ci = rnd.next(-MAX_COEFF, MAX_COEFF);\n            int s1 = ai * x1 + bi * y1 + ci;\n            int s2 = ai * x2 + bi * y2 + ci;\n            if (s1 == 0 || s2 == 0) continue; // Home or university lies on the road\n            // Normalize the road\n            normalize(ai, bi, ci);\n            auto road = make_tuple(ai, bi, ci);\n            if (roads.count(road)) continue; // Duplicate road\n            roads.insert(road);\n            n_roads++;\n            printf(\"%d %d %d\\n\", ai, bi, ci);\n        }\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\n// Function to compute GCD of two numbers\nint gcd(int a, int b) {\n    return b == 0 ? abs(a) : gcd(b, a % b);\n}\n\n// Function to compute GCD of three numbers\nint gcd3(int a, int b, int c) {\n    return gcd(gcd(a, b), c);\n}\n\n// Function to normalize the line coefficients\nvoid normalize(int &a, int &b, int &c) {\n    int g = gcd3(a, b, c);\n    if (g != 0) {\n        a /= g;\n        b /= g;\n        c /= g;\n    }\n    if (a < 0 || (a == 0 && b < 0)) {\n        a = -a;\n        b = -b;\n        c = -c;\n    }\n}\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    const int MAX_COORD = 1000000;\n    const int MAX_COEFF = 1000000;\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    int max_coord = opt<int>(\"max_coord\", MAX_COORD);\n\n    // Generate home and university coordinates\n    int x1 = rnd.next(-max_coord, max_coord);\n    int y1 = rnd.next(-max_coord, max_coord);\n    int x2 = rnd.next(-max_coord, max_coord);\n    int y2 = rnd.next(-max_coord, max_coord);\n    while (x1 == x2 && y1 == y2) {\n        // Ensure home and university are at different locations\n        x2 = rnd.next(-max_coord, max_coord);\n        y2 = rnd.next(-max_coord, max_coord);\n    }\n\n    printf(\"%d %d\\n\", x1, y1);\n    printf(\"%d %d\\n\", x2, y2);\n    printf(\"%d\\n\", n);\n\n    set<tuple<int, int, int>> roads;\n\n    if (type == \"random\") {\n        int n_roads = 0;\n        while (n_roads < n) {\n            int ai = rnd.next(-MAX_COEFF, MAX_COEFF);\n            int bi = rnd.next(-MAX_COEFF, MAX_COEFF);\n            while (ai == 0 && bi == 0) {\n                ai = rnd.next(-MAX_COEFF, MAX_COEFF);\n                bi = rnd.next(-MAX_COEFF, MAX_COEFF);\n            }\n            int ci = rnd.next(-MAX_COEFF, MAX_COEFF);\n            int s1 = ai * x1 + bi * y1 + ci;\n            int s2 = ai * x2 + bi * y2 + ci;\n            if (s1 == 0 || s2 == 0) continue; // Home or university lies on the road\n            // Normalize the road\n            normalize(ai, bi, ci);\n            auto road = make_tuple(ai, bi, ci);\n            if (roads.count(road)) continue; // Duplicate road\n            roads.insert(road);\n            n_roads++;\n            printf(\"%d %d %d\\n\", ai, bi, ci);\n        }\n    } else if (type == \"same_block\") {\n        int n_roads = 0;\n        while (n_roads < n) {\n            int ai = rnd.next(-MAX_COEFF, MAX_COEFF);\n            int bi = rnd.next(-MAX_COEFF, MAX_COEFF);\n            while (ai == 0 && bi == 0) {\n                ai = rnd.next(-MAX_COEFF, MAX_COEFF);\n                bi = rnd.next(-MAX_COEFF, MAX_COEFF);\n            }\n            int ci = rnd.next(-MAX_COEFF, MAX_COEFF);\n            int s1 = ai * x1 + bi * y1 + ci;\n            int s2 = ai * x2 + bi * y2 + ci;\n            if (s1 == 0 || s2 == 0) continue; // Home or university lies on the road\n            if ((s1 > 0 && s2 < 0) || (s1 < 0 && s2 > 0)) continue; // Road separates home and university\n            // Normalize the road\n            normalize(ai, bi, ci);\n            auto road = make_tuple(ai, bi, ci);\n            if (roads.count(road)) continue; // Duplicate road\n            roads.insert(road);\n            n_roads++;\n            printf(\"%d %d %d\\n\", ai, bi, ci);\n        }\n    } else if (type == \"adjacent_blocks\") {\n        // Generate one road that separates home and university\n        int ai, bi, ci;\n        while (true) {\n            ai = rnd.next(-MAX_COEFF, MAX_COEFF);\n            bi = rnd.next(-MAX_COEFF, MAX_COEFF);\n            while (ai == 0 && bi == 0) {\n                ai = rnd.next(-MAX_COEFF, MAX_COEFF);\n                bi = rnd.next(-MAX_COEFF, MAX_COEFF);\n            }\n            ci = rnd.next(-MAX_COEFF, MAX_COEFF);\n            int s1 = ai * x1 + bi * y1 + ci;\n            int s2 = ai * x2 + bi * y2 + ci;\n            if (s1 == 0 || s2 == 0) continue;\n            if ((s1 > 0 && s2 < 0) || (s1 < 0 && s2 > 0)) break; // Road separates home and university\n        }\n        // Normalize the road\n        normalize(ai, bi, ci);\n        roads.insert(make_tuple(ai, bi, ci));\n        printf(\"%d %d %d\\n\", ai, bi, ci);\n        int n_roads = 1;\n        // Fill the rest with random roads that do not separate home and university\n        while (n_roads < n) {\n            int ai = rnd.next(-MAX_COEFF, MAX_COEFF);\n            int bi = rnd.next(-MAX_COEFF, MAX_COEFF);\n            while (ai == 0 && bi == 0) {\n                ai = rnd.next(-MAX_COEFF, MAX_COEFF);\n                bi = rnd.next(-MAX_COEFF, MAX_COEFF);\n            }\n            int ci = rnd.next(-MAX_COEFF, MAX_COEFF);\n            int s1 = ai * x1 + bi * y1 + ci;\n            int s2 = ai * x2 + bi * y2 + ci;\n            if (s1 == 0 || s2 == 0) continue; // Home or university lies on the road\n            if ((s1 > 0 && s2 < 0) || (s1 < 0 && s2 > 0)) continue; // Road separates home and university\n            // Normalize the road\n            normalize(ai, bi, ci);\n            auto road = make_tuple(ai, bi, ci);\n            if (roads.count(road)) continue; // Duplicate road\n            roads.insert(road);\n            n_roads++;\n            printf(\"%d %d %d\\n\", ai, bi, ci);\n        }\n    } else {\n        // Default to 'random' if unknown type\n        int n_roads = 0;\n        while (n_roads < n) {\n            int ai = rnd.next(-MAX_COEFF, MAX_COEFF);\n            int bi = rnd.next(-MAX_COEFF, MAX_COEFF);\n            while (ai == 0 && bi == 0) {\n                ai = rnd.next(-MAX_COEFF, MAX_COEFF);\n                bi = rnd.next(-MAX_COEFF, MAX_COEFF);\n            }\n            int ci = rnd.next(-MAX_COEFF, MAX_COEFF);\n            int s1 = ai * x1 + bi * y1 + ci;\n            int s2 = ai * x2 + bi * y2 + ci;\n            if (s1 == 0 || s2 == 0) continue; // Home or university lies on the road\n            // Normalize the road\n            normalize(ai, bi, ci);\n            auto road = make_tuple(ai, bi, ci);\n            if (roads.count(road)) continue; // Duplicate road\n            roads.insert(road);\n            n_roads++;\n            printf(\"%d %d %d\\n\", ai, bi, ci);\n        }\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -type same_block\n./gen -n 1 -type adjacent_blocks\n./gen -n 1 -type random\n\n./gen -n 2 -type same_block\n./gen -n 2 -type adjacent_blocks\n./gen -n 2 -type random\n\n./gen -n 10 -type same_block\n./gen -n 10 -type adjacent_blocks\n./gen -n 10 -type random\n\n./gen -n 50 -type same_block\n./gen -n 50 -type adjacent_blocks\n./gen -n 50 -type random\n\n./gen -n 100 -type same_block\n./gen -n 100 -type adjacent_blocks\n./gen -n 100 -type random\n\n./gen -n 150 -type same_block\n./gen -n 150 -type adjacent_blocks\n./gen -n 150 -type random\n\n./gen -n 200 -type same_block\n./gen -n 200 -type adjacent_blocks\n./gen -n 200 -type random\n\n./gen -n 250 -type same_block\n./gen -n 250 -type adjacent_blocks\n./gen -n 250 -type random\n\n./gen -n 300 -type same_block\n./gen -n 300 -type adjacent_blocks\n./gen -n 300 -type random\n\n# Test with maximum coordinate values\n./gen -n 300 -type random -max_coord 1000000\n./gen -n 300 -type same_block -max_coord 1000000\n./gen -n 300 -type adjacent_blocks -max_coord 1000000\n\n# Test with small coordinate values\n./gen -n 10 -type random -max_coord 10\n./gen -n 10 -type same_block -max_coord 10\n./gen -n 10 -type adjacent_blocks -max_coord 10\n\n# Additional tests to cover edge cases\n./gen -n 3 -type random\n./gen -n 3 -type same_block\n./gen -n 3 -type adjacent_blocks\n\n# Test with home and university very close\n./gen -n 100 -type random -max_coord 5\n./gen -n 100 -type same_block -max_coord 5\n./gen -n 100 -type adjacent_blocks -max_coord 5\n\n# Test with large n and large coordinates\n./gen -n 300 -type random -max_coord 1000000\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:39:18.078351",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "498/B",
      "title": "B. Name That Tune",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line of the input contains numbers n and T (1 ≤ n ≤ 5000, 1 ≤ T ≤ 5000), separated by a space. Next n lines contain pairs of numbers pi and ti (0 ≤ pi ≤ 100, 1 ≤ ti ≤ T). The songs are given in the same order as in Petya's list.",
      "output_spec": "OutputOutput a single number — the expected number of the number of songs you will recognize in T seconds. Your answer will be considered correct if its absolute or relative error does not exceed 10 - 6.",
      "sample_tests": "ExamplesInputCopy2 250 210 1OutputCopy1.500000000InputCopy2 20 2100 2OutputCopy1.000000000InputCopy3 350 350 225 2OutputCopy1.687500000InputCopy2 20 20 2OutputCopy1.000000000",
      "description": "B. Name That Tune\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line of the input contains numbers n and T (1 ≤ n ≤ 5000, 1 ≤ T ≤ 5000), separated by a space. Next n lines contain pairs of numbers pi and ti (0 ≤ pi ≤ 100, 1 ≤ ti ≤ T). The songs are given in the same order as in Petya's list.\n\nOutputOutput a single number — the expected number of the number of songs you will recognize in T seconds. Your answer will be considered correct if its absolute or relative error does not exceed 10 - 6.\n\nInputCopy2 250 210 1OutputCopy1.500000000InputCopy2 20 2100 2OutputCopy1.000000000InputCopy3 350 350 225 2OutputCopy1.687500000InputCopy2 20 20 2OutputCopy1.000000000\n\nInputCopy2 250 210 1\n\nOutputCopy1.500000000\n\nInputCopy2 20 2100 2\n\nOutputCopy1.000000000\n\nInputCopy3 350 350 225 2\n\nOutputCopy1.687500000\n\nInputCopy2 20 20 2\n\nOutputCopy1.000000000",
      "solutions": [
        {
          "title": "Codeforces Round #284 - Codeforces",
          "content": "Soon you are lucky to participate in Codeforces Round #284, and problems have been prepared by Vitaly Gridnev (gridnevvvit), Ilya Los (IlyaLos), Danil Sagunov (danilka.pro).We want to thank Max Akhmedov (Zlobober) for help with preparation of this round, Maria Belova (Delinur) for translation of statements and Mike Mirzayanov (MikeMirzayanov) for marvelous Codeforces and Polygon systems.Scoring system will be dynamic. Problems will be arranged in ascending expected difficulty order.Round finished, congratulations to winners!Div1: yeputons rng_58 Endagorion KADR Egor uwi mmaxio atetubou RAVEman Div2: sorry_dreamoon dreamoon_love_AA dreamoon_fan EditorialGood luck!",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/15336",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 671
        },
        {
          "title": "Codeforces Round #284 Editorial - Codeforces",
          "content": "499A - Watching a movieOne can solve the problem using greedy algorithm: if we can skip x minutes at current moment without skipping any good moment — we do that, otherwise — watch another minute of the film.499B - LectureIn this task you must find for every string in the text the pair containing that string, and from two strings of that pair output the shortest one.498A - Crazy Town / 499C - Crazy TownIt can be easily proved that, if two points from statement are placed on different sides of some line, this line will be crossed anyway. So, all we need to do is to cross all these lines, so the answer is the number of these lines.To check if two points lies on different sides of a line one can simply use its coordinates to place in line equation and check if these two values have different signs. Solution complexity — O(n).498B - Name That Tune / 499D - Name That TuneLet's numerate all the songs and seconds starting from 0.Problem will be solved using DP approach. State will be described by two integers (i, j): dp[i][j] is probability of that we named exactly i songs, and the last named song was named exactly before j'th second (after j - 1 seconds). dp[0][0] = 1 obviously.To make a move from state (i, j) to state (i + 1, j + k) (1 ≤ k < ti), we must name the song exactly after k seconds its playing — probability of that is (1 - pi)k - 1·pi. To fixed state (i + 1, j) sum of that moves can be represented as . Simple calculation of this value for each state gives O(nT2) complexity, so one must notice, that this values can be calculated using two pointers for fixed i (in common case it represent a segment with ti length) for every j in time O(T). This way calculating this type of moves takes O(nT) time.There is also a move to (i + 1, j + ti) and a move from (i, j) to (i, (j + k) = T), when we couldn't name current song in time T. This types of moves is calculated with O(nT) too.Solution complexity — O(nT).498C - Array and Operations / 499E - Array and OperationsWe will divide only by prime numbers.First, let's build a graph, where each of n numbers have own vertex group:Find all prime factors of current number. Every factor will have its own vertex in a group, furthermore, if some factor p has power of ai in current number, it will have exactly ai vertexes in group.The number of vertexes in such graph is .Now we will make edges in our graph: edge between two vertexes exists if and only if there is a good pair (given in statement) of vertexes group numbers and the prime values of a vertexes are the same. That means that we can divide that group numbers by that prime.The number of edges is .Good pairs are given the way that our graph is bipartite. After finding maximum matching in this graph we represent the way of doing operations as described in the statement.As soon as solution is using Kuhn's algorithm, its complexity is . One could notice that some of the edges are useless and reduce it to .498D - Traffic Jams in the LandThe solution of a problem — 60 (LCM of a numbers from 2 to 6) segment trees.In v'th segment tree we will hold for every segment [l, r] the next value: minimum time needed to get from l to r if we start in a moment of time equal to v modulo 60. Using these trees' values it is easy to quickly answer the questions, carefully changing the trees' values.498E - Stairs and LinesThe problem is solved using DP approach dp[i][mask] — the number of ways to paint first i blocks of a ladder the way that the last layer of vertical edges is painted as described in mask mask. This could be easily recalculated using matrix M[mask1][mask2] — the number of ways to paint horizontal edges between two neighbour vertical layers painted as represented by masks mask1 and mask2.For fixed i we have wi layers, so this matrix must be multiplied by itself wi times, which can be quickly done by binary-pow algorithm. After that this matrix is simply used in dynamic described above.Solution complexity — .",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/15353",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 498\\s*B"
          },
          "content_length": 3961
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #284 - Codeforces - Code 1",
          "code": "while(true) System.out.println(\"NOOOOOOOOOOOOOOOOOOOO\");",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15336",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #284 - Codeforces - Code 2",
          "code": "6 6\n2 2 2 2 2 2\n1 2\n1 3\n2 3\n4 5\n4 6\n5 6",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15336",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #284 - Codeforces - Code 3",
          "code": "6 6\n2 2 2 2 2 2\n1 2\n1 3\n2 3\n4 5\n4 6\n5 6",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15336",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #284 Editorial - Codeforces - Code 1",
          "code": "for (int i = 0; i <= t; ++i) {\n    dp[i] = dp1[i]; sum += dp[i]; }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15353",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #284 Editorial - Codeforces - Code 2",
          "code": "for (int i = 0; i <= t; ++i) {\n    dp[i] = dp1[i]; sum += dp[i]; }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15353",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #284 Editorial - Codeforces - Code 3",
          "code": "double *ptr, *ptr1, *tptr;\nptr = dp;\nptr1 = dp1;\n\nfor (int i = 1; i < n; ++i) {\n    // Something to do...\n\n    tptr = ptr;\n    ptr = ptr1;\n    ptr1 = tptr;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15353",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #284 Editorial - Codeforces - Code 4",
          "code": "double *ptr, *ptr1, *tptr;\nptr = dp;\nptr1 = dp1;\n\nfor (int i = 1; i < n; ++i) {\n    // Something to do...\n\n    tptr = ptr;\n    ptr = ptr1;\n    ptr1 = tptr;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15353",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #284 Editorial - Codeforces - Code 5",
          "code": "double DP(int idx, int sec) {\n    if (sec > t)\n        return idx - 1;\n    if (sec == t or idx == n)\n        return idx;\n    double &ret = memo[idx][sec], tmp = 1;\n    if (ret == ret)\n        return ret;\n    ret = 0;\n    for (int i =1 ; i < ti[idx]; ++i) {\n        double &tret = memo[idx + 1][sec + i];\n        if (tret != tret)\n            tret = DP(idx + 1, sec + i);\n        ret += pi[idx] * tmp * tret;\n        tmp *= 1 - pi[idx];\n    }\n    return (ret += tmp * DP(idx + 1, sec + ti[idx]));\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15353",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #284 Editorial - Codeforces - Code 6",
          "code": "double DP(int idx, int sec) {\n    if (sec > t)\n        return idx - 1;\n    if (sec == t or idx == n)\n        return idx;\n    double &ret = memo[idx][sec], tmp = 1;\n    if (ret == ret)\n        return ret;\n    ret = 0;\n    for (int i =1 ; i < ti[idx]; ++i) {\n        double &tret = memo[idx + 1][sec + i];\n        if (tret != tret)\n            tret = DP(idx + 1, sec + i);\n        ret += pi[idx] * tmp * tret;\n        tmp *= 1 - pi[idx];\n    }\n    return (ret += tmp * DP(idx + 1, sec + ti[idx]));\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15353",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #284 Editorial - Codeforces - Code 7",
          "code": "3 3\n50 3\n50 2\n25 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15353",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #284 Editorial - Codeforces - Code 8",
          "code": "3 3\n50 3\n50 2\n25 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15353",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #284 Editorial - Codeforces - Code 9",
          "code": "2 5\n3 8\n13 13",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15353",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #284 Editorial - Codeforces - Code 10",
          "code": "2 5\n3 8\n13 13",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15353",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 5000, \"n\");\n    inf.readSpace();\n    int T = inf.readInt(1, 5000, \"T\");\n    inf.readEoln();\n    for (int i = 0; i < n; ++i) {\n        int pi = inf.readInt(0, 100, format(\"pi[%d]\", i + 1));\n        inf.readSpace();\n        int ti = inf.readInt(1, T, format(\"ti[%d]\", i + 1));\n        inf.readEoln();\n    }\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 5000, \"n\");\n    inf.readSpace();\n    int T = inf.readInt(1, 5000, \"T\");\n    inf.readEoln();\n    for (int i = 0; i < n; ++i) {\n        int pi = inf.readInt(0, 100, format(\"pi[%d]\", i + 1));\n        inf.readSpace();\n        int ti = inf.readInt(1, T, format(\"ti[%d]\", i + 1));\n        inf.readEoln();\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 5000, \"n\");\n    inf.readSpace();\n    int T = inf.readInt(1, 5000, \"T\");\n    inf.readEoln();\n    for (int i = 0; i < n; ++i) {\n        int pi = inf.readInt(0, 100, format(\"pi[%d]\", i + 1));\n        inf.readSpace();\n        int ti = inf.readInt(1, T, format(\"ti[%d]\", i + 1));\n        inf.readEoln();\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nconst double EPS = 1E-6;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare two sequences of doubles, max absolute or relative  error = %.7f\", EPS);\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    double j = 0, p = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        n++;\r\n        j = ans.readDouble();\r\n        p = ouf.readDouble();\r\n        if (!doubleCompare(j, p, EPS)) {\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%.7f', found: '%.7f', error = '%.7f'\",\r\n                  n, englishEnding(n).c_str(), j, p, doubleDelta(j, p));\r\n        }\r\n    }\r\n\r\n    if (n == 1)\r\n        quitf(_ok, \"found '%.7f', expected '%.7f', error '%.7f'\", p, j, doubleDelta(j, p));\r\n\r\n    quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int T = opt<int>(\"T\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> pi(n);\n    vector<int> ti(n);\n\n    if(type == \"random\") {\n        for(int i = 0; i < n; ++i) {\n            pi[i] = rnd.next(0, 100); // pi in [0, 100]\n            ti[i] = rnd.next(1, T); // ti in [1, T]\n        }\n    } else if(type == \"pi0\") {\n        for(int i = 0; i < n; ++i) {\n            pi[i] = 0;\n            ti[i] = rnd.next(1, T);\n        }\n    } else if(type == \"pi100\") {\n        for(int i = 0; i < n; ++i) {\n            pi[i] = 100;\n            ti[i] = rnd.next(1, T);\n        }\n    } else if(type == \"ti1\") {\n        for(int i = 0; i < n; ++i) {\n            pi[i] = rnd.next(0, 100);\n            ti[i] = 1;\n        }\n    } else if(type == \"tiT\") {\n        for(int i = 0; i < n; ++i) {\n            pi[i] = rnd.next(0, 100);\n            ti[i] = T;\n        }\n    } else if(type == \"alternatingPi\") {\n        for(int i = 0; i < n; ++i) {\n            pi[i] = (i % 2 == 0) ? 0 : 100;\n            ti[i] = rnd.next(1, T);\n        }\n    } else if(type == \"increasingTi\") {\n        int min_ti = 1;\n        for(int i = 0; i < n; ++i) {\n            ti[i] = min_ti;\n            pi[i] = rnd.next(0, 100);\n            if(min_ti < T) ++min_ti;\n        }\n    } else if(type == \"decreasingTi\") {\n        int max_ti = T;\n        for(int i = 0; i < n; ++i) {\n            ti[i] = max_ti;\n            pi[i] = rnd.next(0, 100);\n            if(max_ti > 1) --max_ti;\n        }\n    } else if(type == \"max\") {\n        for(int i = 0; i < n; ++i) {\n            pi[i] = rnd.next(0, 100);\n            ti[i] = rnd.next(1, T);\n        }\n    } else {\n        // Default case\n        for(int i = 0; i < n; ++i) {\n            pi[i] = rnd.next(0, 100);\n            ti[i] = rnd.next(1, T);\n        }\n    }\n\n    // Output n T\n    printf(\"%d %d\\n\", n, T);\n\n    // Output pi and ti\n    for(int i = 0; i < n; ++i) {\n        printf(\"%d %d\\n\", pi[i], ti[i]);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int T = opt<int>(\"T\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> pi(n);\n    vector<int> ti(n);\n\n    if(type == \"random\") {\n        for(int i = 0; i < n; ++i) {\n            pi[i] = rnd.next(0, 100); // pi in [0, 100]\n            ti[i] = rnd.next(1, T); // ti in [1, T]\n        }\n    } else if(type == \"pi0\") {\n        for(int i = 0; i < n; ++i) {\n            pi[i] = 0;\n            ti[i] = rnd.next(1, T);\n        }\n    } else if(type == \"pi100\") {\n        for(int i = 0; i < n; ++i) {\n            pi[i] = 100;\n            ti[i] = rnd.next(1, T);\n        }\n    } else if(type == \"ti1\") {\n        for(int i = 0; i < n; ++i) {\n            pi[i] = rnd.next(0, 100);\n            ti[i] = 1;\n        }\n    } else if(type == \"tiT\") {\n        for(int i = 0; i < n; ++i) {\n            pi[i] = rnd.next(0, 100);\n            ti[i] = T;\n        }\n    } else if(type == \"alternatingPi\") {\n        for(int i = 0; i < n; ++i) {\n            pi[i] = (i % 2 == 0) ? 0 : 100;\n            ti[i] = rnd.next(1, T);\n        }\n    } else if(type == \"increasingTi\") {\n        int min_ti = 1;\n        for(int i = 0; i < n; ++i) {\n            ti[i] = min_ti;\n            pi[i] = rnd.next(0, 100);\n            if(min_ti < T) ++min_ti;\n        }\n    } else if(type == \"decreasingTi\") {\n        int max_ti = T;\n        for(int i = 0; i < n; ++i) {\n            ti[i] = max_ti;\n            pi[i] = rnd.next(0, 100);\n            if(max_ti > 1) --max_ti;\n        }\n    } else if(type == \"max\") {\n        for(int i = 0; i < n; ++i) {\n            pi[i] = rnd.next(0, 100);\n            ti[i] = rnd.next(1, T);\n        }\n    } else {\n        // Default case\n        for(int i = 0; i < n; ++i) {\n            pi[i] = rnd.next(0, 100);\n            ti[i] = rnd.next(1, T);\n        }\n    }\n\n    // Output n T\n    printf(\"%d %d\\n\", n, T);\n\n    // Output pi and ti\n    for(int i = 0; i < n; ++i) {\n        printf(\"%d %d\\n\", pi[i], ti[i]);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -T 1 -type random\n./gen -n 10 -T 10 -type random\n./gen -n 100 -T 100 -type random\n./gen -n 1000 -T 1000 -type random\n./gen -n 5000 -T 5000 -type random\n\n./gen -n 10 -T 100 -type pi0\n./gen -n 10 -T 100 -type pi100\n./gen -n 100 -T 500 -type pi0\n./gen -n 100 -T 500 -type pi100\n./gen -n 5000 -T 5000 -type pi0\n./gen -n 5000 -T 5000 -type pi100\n\n./gen -n 10 -T 10 -type ti1\n./gen -n 10 -T 10 -type tiT\n./gen -n 5000 -T 5000 -type ti1\n./gen -n 5000 -T 5000 -type tiT\n\n./gen -n 1000 -T 10 -type random\n./gen -n 1000 -T 100 -type random\n./gen -n 1000 -T 1000 -type random\n\n./gen -n 5000 -T 1 -type random\n\n./gen -n 1000 -T 5000 -type alternatingPi\n./gen -n 5000 -T 5000 -type alternatingPi\n\n./gen -n 5000 -T 5000 -type increasingTi\n./gen -n 5000 -T 5000 -type decreasingTi\n\n./gen -n 5000 -T 5000 -type max\n\n./gen -n 5000 -T 5000 -type random\n\n./gen -n 2 -T 2 -type random\n./gen -n 2 -T 2 -type pi0\n./gen -n 2 -T 2 -type pi100\n./gen -n 2 -T 2 -type ti1\n./gen -n 2 -T 2 -type tiT\n./gen -n 2 -T 2 -type alternatingPi\n\n./gen -n 500 -T 500 -type random\n\n./gen -n 5000 -T 5000 -type random\n\n./gen -n 4999 -T 5000 -type random\n\n./gen -n 5000 -T 4999 -type random\n\n./gen -n 1 -T 5000 -type random\n\n./gen -n 5000 -T 1 -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:39:20.390047",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "498/C",
      "title": "C. Массив и операции",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест1 секунда",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеВ первой строке записано два целых числа через пробел n, m (2 ≤ n ≤ 100, 1 ≤ m ≤ 100).Во второй строке записано n целых чисел пробел a[1], a[2], ..., a[n] (1 ≤ a[i] ≤ 109) — описание массива.В следующих m строках задано описание хороших пар. В k-й строке содержится два целых числа через пробел ik, jk (1 ≤ ik < jk ≤ n, ik + jk — нечетное число).Гарантируется, что все хорошие пары различны.",
      "output_spec": "Выходные данныеВыведите единственное целое число — ответ на задачу.",
      "sample_tests": "ПримерыВходные данныеСкопировать3 28 3 81 22 3Выходные данныеСкопировать0Входные данныеСкопировать3 28 12 81 22 3Выходные данныеСкопировать2",
      "description": "C. Массив и операции\n\nограничение по времени на тест1 секунда\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвыводstdout\n\nВходные данныеВ первой строке записано два целых числа через пробел n, m (2 ≤ n ≤ 100, 1 ≤ m ≤ 100).Во второй строке записано n целых чисел пробел a[1], a[2], ..., a[n] (1 ≤ a[i] ≤ 109) — описание массива.В следующих m строках задано описание хороших пар. В k-й строке содержится два целых числа через пробел ik, jk (1 ≤ ik < jk ≤ n, ik + jk — нечетное число).Гарантируется, что все хорошие пары различны.\n\nВходные данные\n\nВыходные данныеВыведите единственное целое число — ответ на задачу.\n\nВыходные данные\n\nВходные данныеСкопировать3 28 3 81 22 3Выходные данныеСкопировать0Входные данныеСкопировать3 28 12 81 22 3Выходные данныеСкопировать2\n\nВходные данныеСкопировать3 28 3 81 22 3\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать0\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать3 28 12 81 22 3\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать2\n\nВыходные данныеСкопировать\n\nСкопировать",
      "solutions": [
        {
          "title": "Codeforces Round #284 - Codeforces",
          "content": "Скоро состоится очередной раунд Codeforces Round #284, задачи для которого готовили Виталий Гриднев (gridnevvvit), Илья Лось (IlyaLos), Данил Сагунов (danilka.pro).Большое спасибо Максиму Ахмедову (Zlobober) за помощь в подготовке задач, Марии Беловой (Delinur) за переводы на английский, Михаилу Мирзаянову (MikeMirzayanov) за замечательные системы Codeforces и Polygon.Будет использоваться динамическая разбалловка. Задачи расположены в порядке возрастания предполагаемой сложности.Раунд окончен, поздравляем победителей!Div1: yeputons rng_58 Endagorion KADR Egor uwi mmaxio atetubou RAVEman Div2: sorry_dreamoon dreamoon_love_AA dreamoon_fan Разбор задачУдачи!",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/15336",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 663
        },
        {
          "title": "Разбор Codeforces Round #284 - Codeforces",
          "content": "499A - Просмотр фильмаЗадача решается жадным алгоритмом — если мы на текущем моменте времени можем пропустить x минут, не пропустив при этом ни одного хорошего момента, то мы пропускаем x минут, в противном случае — смотрим очередную минуту фильма.499B - ЛекцияВ задаче требовалось для каждой строки из текста искать, в какой паре она находится, и из двух строк этой пары выводить меньшую по длине.498A - Сумасшедший город / 499C - Сумасшедший городНесложно показать, что, если две исходные точки изначально находятся по разные стороны какой-то из прямых, эту прямую в любом случае придется пересечь. Поскольку все, что нам нужно — это пересечь все такие прямые, ответ на задачу — их количество.Чтобы проверить, лежат ли точки по разные стороны прямой, достаточно подставить их координаты в ее уравнение, и проверить, что получившиеся два значения имеют разные знаки.Итоговая сложность решения — O(n).498B - Музыкальная пауза / 499D - Музыкальная паузаДля удобства будем нумеровать песни с нуля.Задачу будем решать методом динамического программирования. Состояние динамики будем описывать парой чисел i и j: dp[i][j] — вероятность того, что мы угадали ровно i песен, угадав последнюю из них ровно перед началом j-ой секунды (то есть Петя еще не включал следующую (i-ую) песню). База динамики, очевидно, dp[0][0] = 1.Чтобы из состояния (i, j) сделать переход в состояние (i + 1, j + k) (1 ≤ k < ti), нужно угадать i-ую песню ровно после k-ой секунды воспроизведения, не угадывая ее до этого — вероятность такого перехода равна (1 - pi)k - 1·pi. Для фиксированного состояния (i + 1, j) сумму таких переходов можно записать в виде суммы . Простое вычисление такой суммы для каждого состояния займет O(nT2) времени, поэтому нужно заметить, что при фиксированном i такую сумму можно поддерживать двумя указателями (в общем случае они задают отрезок длиной ti) для каждого j за O(T) времени. Таким образом, подсчет переходов такого типа займет O(nT) времени.Переход в (i + 1, j + ti) следует рассмотреть отдельно. Также существует и вариант не успеть угадать песню в отведенное время — это переход из (i, j) в (i, (j + k) = T). Переходы этих двух типов считаются за O(nT).Итоговая сложность решения — O(nT).498C - Массив и операции / 499E - Массив и операцииПрежде всего заметим, что делить на составные числа невыгодно.Теперь построим граф, где каждому числу соответствует некоторая группа вершин:Разложим каждое число на простые делители. Каждому из простых делителей будет соответствовать некоторая вершина в графе, при этом, если число p входит в i-ое число в степени ai, то ему будет соответствовать ровно ai вершин в группе i-го числа.Количество вершин в таком графе будет составлять .Теперь будем проводить ребра в получившемся графе: ребро между двумя вершинами будет существовать тогда и только тогда, когда числа, соответствующие группам эти вершин, находятся в некоторой хорошей паре, а простые, соответствующие этим вершинам, равны. Проще говоря, каждое такое ребро означает, что мы можем поделить числа, соответствующие группам вершин, на соответствующее вершинам простое.Ребер при таком построении будет .Пары заданы так, что полученный граф — двудольный. Найдя наибольшее паросочетание в полученном графе, мы однозначно получим наилучший способ выполнения операций в массиве.Итоговая асимптотика решения, использующего алгоритм Куна . Можно также заметить, что некоторые ребра лишние, и свести эту оценку к .498D - Пробки в странеРешение задачи — 60 (НОК чисел от 2 до 6) деревьев отрезков.В v-ом дереве отрезков будем поддерживать для каждого отрезка [l, r] следующую величину: минимальное количество времени, необходимое, чтобы добраться от l до r, если мы начинаем в момент времени, равный v по модулю 60. Используя значения этих деревьев, несложно быстро отвечать на запросы, аккуратно изменяя деревья.498E - Палочки и лесенкиЗадача решается динамикой dp[i][mask] — количество способов покрасить первые i ступеней лестницы так, что последний уровень вертикальных палочек соответствует маске mask. Ее значения несложно пересчитывать, если знать матрицу M[mask1][mask2] — количество способов покрасить горизонтальные палочки между двумя соседними слоями вертикальных палочек, закрашенных соответственно маскам mask1 и mask2. Поскольку вертикальных слоев для фиксированного i ровно wi, то эту матрицу нужно возвести в степень, равную этому числу. После этого матрица очень просто используется для выполнения переходов динамики (подробнее в авторском решении).Итоговая сложность решения —",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/15353",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 498\\s*C"
          },
          "content_length": 4498
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #284 - Codeforces - Code 1",
          "code": "while(true) System.out.println(\"NOOOOOOOOOOOOOOOOOOOO\");",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15336",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #284 - Codeforces - Code 2",
          "code": "6 6\n2 2 2 2 2 2\n1 2\n1 3\n2 3\n4 5\n4 6\n5 6",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15336",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #284 - Codeforces - Code 3",
          "code": "6 6\n2 2 2 2 2 2\n1 2\n1 3\n2 3\n4 5\n4 6\n5 6",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15336",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #284 - Codeforces - Code 1",
          "code": "for (int i = 0; i <= t; ++i) {\n    dp[i] = dp1[i]; sum += dp[i]; }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15353",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #284 - Codeforces - Code 2",
          "code": "for (int i = 0; i <= t; ++i) {\n    dp[i] = dp1[i]; sum += dp[i]; }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15353",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #284 - Codeforces - Code 3",
          "code": "double *ptr, *ptr1, *tptr;\nptr = dp;\nptr1 = dp1;\n\nfor (int i = 1; i < n; ++i) {\n    // Something to do...\n\n    tptr = ptr;\n    ptr = ptr1;\n    ptr1 = tptr;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15353",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #284 - Codeforces - Code 4",
          "code": "double *ptr, *ptr1, *tptr;\nptr = dp;\nptr1 = dp1;\n\nfor (int i = 1; i < n; ++i) {\n    // Something to do...\n\n    tptr = ptr;\n    ptr = ptr1;\n    ptr1 = tptr;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15353",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #284 - Codeforces - Code 5",
          "code": "double DP(int idx, int sec) {\n    if (sec > t)\n        return idx - 1;\n    if (sec == t or idx == n)\n        return idx;\n    double &ret = memo[idx][sec], tmp = 1;\n    if (ret == ret)\n        return ret;\n    ret = 0;\n    for (int i =1 ; i < ti[idx]; ++i) {\n        double &tret = memo[idx + 1][sec + i];\n        if (tret != tret)\n            tret = DP(idx + 1, sec + i);\n        ret += pi[idx] * tmp * tret;\n        tmp *= 1 - pi[idx];\n    }\n    return (ret += tmp * DP(idx + 1, sec + ti[idx]));\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15353",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #284 - Codeforces - Code 6",
          "code": "double DP(int idx, int sec) {\n    if (sec > t)\n        return idx - 1;\n    if (sec == t or idx == n)\n        return idx;\n    double &ret = memo[idx][sec], tmp = 1;\n    if (ret == ret)\n        return ret;\n    ret = 0;\n    for (int i =1 ; i < ti[idx]; ++i) {\n        double &tret = memo[idx + 1][sec + i];\n        if (tret != tret)\n            tret = DP(idx + 1, sec + i);\n        ret += pi[idx] * tmp * tret;\n        tmp *= 1 - pi[idx];\n    }\n    return (ret += tmp * DP(idx + 1, sec + ti[idx]));\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15353",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #284 - Codeforces - Code 7",
          "code": "3 3\n50 3\n50 2\n25 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15353",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #284 - Codeforces - Code 8",
          "code": "3 3\n50 3\n50 2\n25 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15353",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #284 - Codeforces - Code 9",
          "code": "2 5\n3 8\n13 13",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15353",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #284 - Codeforces - Code 10",
          "code": "2 5\n3 8\n13 13",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15353",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(2, 100, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 100, \"m\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, 1, 1000000000, \"a\");\n    inf.readEoln();\n\n    set<pair<int, int>> pairs;\n    for (int i = 0; i < m; ++i) {\n        int ik = inf.readInt(1, n - 1, \"ik\");\n        inf.readSpace();\n        int jk = inf.readInt(ik + 1, n, \"jk\");\n        inf.readEoln();\n        ensuref((ik + jk) % 2 == 1, \"Expected ik + jk is odd\");\n        ensuref(pairs.count(make_pair(ik, jk)) == 0, \"Good pairs must be distinct\");\n        pairs.insert(make_pair(ik, jk));\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(2, 100, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 100, \"m\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, 1, 1000000000, \"a\");\n    inf.readEoln();\n\n    set<pair<int, int>> pairs;\n    for (int i = 0; i < m; ++i) {\n        int ik = inf.readInt(1, n - 1, \"ik\");\n        inf.readSpace();\n        int jk = inf.readInt(ik + 1, n, \"jk\");\n        inf.readEoln();\n        ensuref((ik + jk) % 2 == 1, \"Expected ik + jk is odd\");\n        ensuref(pairs.count(make_pair(ik, jk)) == 0, \"Good pairs must be distinct\");\n        pairs.insert(make_pair(ik, jk));\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(2, 100, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 100, \"m\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, 1, 1000000000, \"a\");\n    inf.readEoln();\n\n    set<pair<int, int>> pairs;\n    for (int i = 0; i < m; ++i) {\n        int ik = inf.readInt(1, n - 1, \"ik\");\n        inf.readSpace();\n        int jk = inf.readInt(ik + 1, n, \"jk\");\n        inf.readEoln();\n        ensuref((ik + jk) % 2 == 1, \"Expected ik + jk is odd\");\n        ensuref(pairs.count(make_pair(ik, jk)) == 0, \"Good pairs must be distinct\");\n        pairs.insert(make_pair(ik, jk));\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> a(n + 1); // 1-based indexing\n\n    if (type == \"all_equal\") {\n        int val = rnd.next(2, 1000000000); // Random number between 2 and 1e9\n        for (int i = 1; i <= n; ++i)\n            a[i] = val;\n\n    } else if (type == \"co_prime\") {\n        set<int> used;\n        for (int i = 1; i <= n; ++i) {\n            int v;\n            do {\n                v = rnd.next(2, 1000000000);\n            } while (used.count(v));\n            used.insert(v);\n            a[i] = v;\n        }\n\n    } else if (type == \"powers\") {\n        // Generate a prime p between 2 and 1000\n        vector<int> primes;\n        for (int x = 2; x <= 1000; ++x) {\n            bool is_prime = true;\n            for (int y = 2; y * y <= x; ++y) {\n                if (x % y == 0) {\n                    is_prime = false;\n                    break;\n                }\n            }\n            if (is_prime) primes.push_back(x);\n        }\n        int p = primes[rnd.next(0, (int)primes.size() -1)];\n        double max_exp_d = log(1e9) / log(p);\n        int max_exp = (int)max_exp_d;\n        for (int i = 1; i <= n; ++i) {\n            int exp = rnd.next(1, max_exp);\n            long long res = 1;\n            for (int e = 0; e < exp; ++e) {\n                res *= p;\n            }\n            a[i] = (int)res; // Since res ≤ 1e9, type casting is OK\n        }\n    } else if (type == \"primes\") {\n        vector<int> primes;\n        // Generate primes up to 1e6\n        const int MAX_PRIME = 1000000;\n        vector<bool> is_prime(MAX_PRIME + 1, true);\n        is_prime[0] = is_prime[1] = false;\n        for (int i = 2; i <= MAX_PRIME; ++i) {\n            if (is_prime[i]) {\n                primes.push_back(i);\n                if (1LL * i * i <= MAX_PRIME) {\n                    for (int j = i * i; j <= MAX_PRIME; j += i)\n                        is_prime[j] = false;\n                }\n            }\n        }\n        for (int i = 1; i <= n; ++i) {\n            a[i] = primes[rnd.next(0, (int)primes.size() -1)];\n        }\n\n    } else { // Random\n        for (int i = 1; i <= n; ++i) {\n            a[i] = rnd.next(1, 1000000000);\n        }\n    }\n\n    // Now generate m good pairs (ik, jk), satisfying ik < jk, ik + jk is odd, and ik, jk in [1,n]\n\n    vector<pair<int,int>> good_pairs;\n    for (int i = 1; i < n; ++i) {\n        for (int j = i +1 ; j <= n; ++j) {\n            if ((i + j) % 2 == 1) {\n                good_pairs.push_back(make_pair(i, j));\n            }\n        }\n    }\n\n    if ((int)good_pairs.size() < m) {\n        m = good_pairs.size();\n    }\n\n    // Shuffle and pick first m pairs\n    shuffle(good_pairs.begin(), good_pairs.end());\n\n    vector<pair<int,int>> selected_pairs(good_pairs.begin(), good_pairs.begin() + m);\n\n    // Output n and m\n    printf(\"%d %d\\n\", n, m);\n    // Output a[1..n]\n    for (int i = 1; i <= n; ++i) {\n        printf(\"%d%c\", a[i], (i == n ? '\\n' : ' '));\n    }\n    // Output m pairs\n    for (int k = 0; k < m; ++k) {\n        printf(\"%d %d\\n\", selected_pairs[k].first, selected_pairs[k].second);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> a(n + 1); // 1-based indexing\n\n    if (type == \"all_equal\") {\n        int val = rnd.next(2, 1000000000); // Random number between 2 and 1e9\n        for (int i = 1; i <= n; ++i)\n            a[i] = val;\n\n    } else if (type == \"co_prime\") {\n        set<int> used;\n        for (int i = 1; i <= n; ++i) {\n            int v;\n            do {\n                v = rnd.next(2, 1000000000);\n            } while (used.count(v));\n            used.insert(v);\n            a[i] = v;\n        }\n\n    } else if (type == \"powers\") {\n        // Generate a prime p between 2 and 1000\n        vector<int> primes;\n        for (int x = 2; x <= 1000; ++x) {\n            bool is_prime = true;\n            for (int y = 2; y * y <= x; ++y) {\n                if (x % y == 0) {\n                    is_prime = false;\n                    break;\n                }\n            }\n            if (is_prime) primes.push_back(x);\n        }\n        int p = primes[rnd.next(0, (int)primes.size() -1)];\n        double max_exp_d = log(1e9) / log(p);\n        int max_exp = (int)max_exp_d;\n        for (int i = 1; i <= n; ++i) {\n            int exp = rnd.next(1, max_exp);\n            long long res = 1;\n            for (int e = 0; e < exp; ++e) {\n                res *= p;\n            }\n            a[i] = (int)res; // Since res ≤ 1e9, type casting is OK\n        }\n    } else if (type == \"primes\") {\n        vector<int> primes;\n        // Generate primes up to 1e6\n        const int MAX_PRIME = 1000000;\n        vector<bool> is_prime(MAX_PRIME + 1, true);\n        is_prime[0] = is_prime[1] = false;\n        for (int i = 2; i <= MAX_PRIME; ++i) {\n            if (is_prime[i]) {\n                primes.push_back(i);\n                if (1LL * i * i <= MAX_PRIME) {\n                    for (int j = i * i; j <= MAX_PRIME; j += i)\n                        is_prime[j] = false;\n                }\n            }\n        }\n        for (int i = 1; i <= n; ++i) {\n            a[i] = primes[rnd.next(0, (int)primes.size() -1)];\n        }\n\n    } else { // Random\n        for (int i = 1; i <= n; ++i) {\n            a[i] = rnd.next(1, 1000000000);\n        }\n    }\n\n    // Now generate m good pairs (ik, jk), satisfying ik < jk, ik + jk is odd, and ik, jk in [1,n]\n\n    vector<pair<int,int>> good_pairs;\n    for (int i = 1; i < n; ++i) {\n        for (int j = i +1 ; j <= n; ++j) {\n            if ((i + j) % 2 == 1) {\n                good_pairs.push_back(make_pair(i, j));\n            }\n        }\n    }\n\n    if ((int)good_pairs.size() < m) {\n        m = good_pairs.size();\n    }\n\n    // Shuffle and pick first m pairs\n    shuffle(good_pairs.begin(), good_pairs.end());\n\n    vector<pair<int,int>> selected_pairs(good_pairs.begin(), good_pairs.begin() + m);\n\n    // Output n and m\n    printf(\"%d %d\\n\", n, m);\n    // Output a[1..n]\n    for (int i = 1; i <= n; ++i) {\n        printf(\"%d%c\", a[i], (i == n ? '\\n' : ' '));\n    }\n    // Output m pairs\n    for (int k = 0; k < m; ++k) {\n        printf(\"%d %d\\n\", selected_pairs[k].first, selected_pairs[k].second);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 2 -m 1 -type random\n./gen -n 2 -m 1 -type all_equal\n./gen -n 2 -m 1 -type co_prime\n./gen -n 2 -m 1 -type powers\n./gen -n 2 -m 1 -type primes\n\n./gen -n 10 -m 5 -type random\n./gen -n 10 -m 5 -type all_equal\n./gen -n 10 -m 5 -type co_prime\n./gen -n 10 -m 5 -type powers\n./gen -n 10 -m 5 -type primes\n\n./gen -n 20 -m 10 -type random\n./gen -n 20 -m 10 -type all_equal\n./gen -n 20 -m 10 -type co_prime\n./gen -n 20 -m 10 -type powers\n./gen -n 20 -m 10 -type primes\n\n./gen -n 50 -m 25 -type random\n./gen -n 50 -m 25 -type all_equal\n./gen -n 50 -m 25 -type co_prime\n./gen -n 50 -m 25 -type powers\n./gen -n 50 -m 25 -type primes\n\n./gen -n 100 -m 50 -type random\n./gen -n 100 -m 50 -type all_equal\n./gen -n 100 -m 50 -type co_prime\n./gen -n 100 -m 50 -type powers\n./gen -n 100 -m 50 -type primes\n\n./gen -n 100 -m 100 -type random\n./gen -n 100 -m 100 -type all_equal\n./gen -n 100 -m 100 -type co_prime\n./gen -n 100 -m 100 -type powers\n./gen -n 100 -m 100 -type primes\n\n./gen -n 100 -m 1 -type random\n./gen -n 100 -m 1 -type all_equal\n./gen -n 100 -m 1 -type co_prime\n./gen -n 100 -m 1 -type powers\n./gen -n 100 -m 1 -type primes\n\n./gen -n 30 -m 15 -type random\n./gen -n 30 -m 15 -type all_equal\n./gen -n 30 -m 15 -type co_prime\n./gen -n 30 -m 15 -type powers\n./gen -n 30 -m 15 -type primes\n\n./gen -n 75 -m 75 -type random\n./gen -n 75 -m 75 -type all_equal\n./gen -n 75 -m 75 -type co_prime\n./gen -n 75 -m 75 -type powers\n./gen -n 75 -m 75 -type primes\n\n./gen -n 100 -m 99 -type random\n./gen -n 100 -m 99 -type all_equal\n./gen -n 100 -m 99 -type co_prime\n./gen -n 100 -m 99 -type powers\n./gen -n 100 -m 99 -type primes\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:39:22.086178",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "498/D",
      "title": "D. Traffic Jams in the Land",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains a single integer n (1 ≤ n ≤ 105) — the number of highway segments that connect the n + 1 cities.The second line contains n integers a1, a2, ..., an (2 ≤ ai ≤ 6) — the periods of traffic jams appearance on segments of the highway.The next line contains a single integer q (1 ≤ q ≤ 105) — the number of queries to process.The next q lines contain the descriptions of the queries in the format c, x, y (c — the query type). If c is character 'A', then your task is to process a query of the first type. In this case the following constraints are satisfied: 1 ≤ x < y ≤ n + 1.If c is character 'C', then you need to process a query of the second type. In such case, the following constraints are satisfied: 1 ≤ x ≤ n, 2 ≤ y ≤ 6.",
      "output_spec": "OutputFor each query of the first type output a single integer — the final value of time t after driving from city x to city y. Process the queries in the order in which they are given in the input.",
      "sample_tests": "ExamplesInputCopy102 5 3 2 3 5 3 4 2 410C 10 6A 2 6A 1 3C 3 4A 3 11A 4 9A 5 6C 7 3A 8 10A 2 5OutputCopy53146244",
      "description": "D. Traffic Jams in the Land\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains a single integer n (1 ≤ n ≤ 105) — the number of highway segments that connect the n + 1 cities.The second line contains n integers a1, a2, ..., an (2 ≤ ai ≤ 6) — the periods of traffic jams appearance on segments of the highway.The next line contains a single integer q (1 ≤ q ≤ 105) — the number of queries to process.The next q lines contain the descriptions of the queries in the format c, x, y (c — the query type). If c is character 'A', then your task is to process a query of the first type. In this case the following constraints are satisfied: 1 ≤ x < y ≤ n + 1.If c is character 'C', then you need to process a query of the second type. In such case, the following constraints are satisfied: 1 ≤ x ≤ n, 2 ≤ y ≤ 6.\n\nOutputFor each query of the first type output a single integer — the final value of time t after driving from city x to city y. Process the queries in the order in which they are given in the input.\n\nInputCopy102 5 3 2 3 5 3 4 2 410C 10 6A 2 6A 1 3C 3 4A 3 11A 4 9A 5 6C 7 3A 8 10A 2 5OutputCopy53146244\n\nInputCopy102 5 3 2 3 5 3 4 2 410C 10 6A 2 6A 1 3C 3 4A 3 11A 4 9A 5 6C 7 3A 8 10A 2 5\n\nOutputCopy53146244",
      "solutions": [
        {
          "title": "Codeforces Round #284 - Codeforces",
          "content": "Soon you are lucky to participate in Codeforces Round #284, and problems have been prepared by Vitaly Gridnev (gridnevvvit), Ilya Los (IlyaLos), Danil Sagunov (danilka.pro).We want to thank Max Akhmedov (Zlobober) for help with preparation of this round, Maria Belova (Delinur) for translation of statements and Mike Mirzayanov (MikeMirzayanov) for marvelous Codeforces and Polygon systems.Scoring system will be dynamic. Problems will be arranged in ascending expected difficulty order.Round finished, congratulations to winners!Div1: yeputons rng_58 Endagorion KADR Egor uwi mmaxio atetubou RAVEman Div2: sorry_dreamoon dreamoon_love_AA dreamoon_fan EditorialGood luck!",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/15336",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 671
        },
        {
          "title": "Codeforces Round #284 Editorial - Codeforces",
          "content": "499A - Watching a movieOne can solve the problem using greedy algorithm: if we can skip x minutes at current moment without skipping any good moment — we do that, otherwise — watch another minute of the film.499B - LectureIn this task you must find for every string in the text the pair containing that string, and from two strings of that pair output the shortest one.498A - Crazy Town / 499C - Crazy TownIt can be easily proved that, if two points from statement are placed on different sides of some line, this line will be crossed anyway. So, all we need to do is to cross all these lines, so the answer is the number of these lines.To check if two points lies on different sides of a line one can simply use its coordinates to place in line equation and check if these two values have different signs. Solution complexity — O(n).498B - Name That Tune / 499D - Name That TuneLet's numerate all the songs and seconds starting from 0.Problem will be solved using DP approach. State will be described by two integers (i, j): dp[i][j] is probability of that we named exactly i songs, and the last named song was named exactly before j'th second (after j - 1 seconds). dp[0][0] = 1 obviously.To make a move from state (i, j) to state (i + 1, j + k) (1 ≤ k < ti), we must name the song exactly after k seconds its playing — probability of that is (1 - pi)k - 1·pi. To fixed state (i + 1, j) sum of that moves can be represented as . Simple calculation of this value for each state gives O(nT2) complexity, so one must notice, that this values can be calculated using two pointers for fixed i (in common case it represent a segment with ti length) for every j in time O(T). This way calculating this type of moves takes O(nT) time.There is also a move to (i + 1, j + ti) and a move from (i, j) to (i, (j + k) = T), when we couldn't name current song in time T. This types of moves is calculated with O(nT) too.Solution complexity — O(nT).498C - Array and Operations / 499E - Array and OperationsWe will divide only by prime numbers.First, let's build a graph, where each of n numbers have own vertex group:Find all prime factors of current number. Every factor will have its own vertex in a group, furthermore, if some factor p has power of ai in current number, it will have exactly ai vertexes in group.The number of vertexes in such graph is .Now we will make edges in our graph: edge between two vertexes exists if and only if there is a good pair (given in statement) of vertexes group numbers and the prime values of a vertexes are the same. That means that we can divide that group numbers by that prime.The number of edges is .Good pairs are given the way that our graph is bipartite. After finding maximum matching in this graph we represent the way of doing operations as described in the statement.As soon as solution is using Kuhn's algorithm, its complexity is . One could notice that some of the edges are useless and reduce it to .498D - Traffic Jams in the LandThe solution of a problem — 60 (LCM of a numbers from 2 to 6) segment trees.In v'th segment tree we will hold for every segment [l, r] the next value: minimum time needed to get from l to r if we start in a moment of time equal to v modulo 60. Using these trees' values it is easy to quickly answer the questions, carefully changing the trees' values.498E - Stairs and LinesThe problem is solved using DP approach dp[i][mask] — the number of ways to paint first i blocks of a ladder the way that the last layer of vertical edges is painted as described in mask mask. This could be easily recalculated using matrix M[mask1][mask2] — the number of ways to paint horizontal edges between two neighbour vertical layers painted as represented by masks mask1 and mask2.For fixed i we have wi layers, so this matrix must be multiplied by itself wi times, which can be quickly done by binary-pow algorithm. After that this matrix is simply used in dynamic described above.Solution complexity — .",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/15353",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 498\\s*D"
          },
          "content_length": 3961
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #284 - Codeforces - Code 1",
          "code": "while(true) System.out.println(\"NOOOOOOOOOOOOOOOOOOOO\");",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15336",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #284 - Codeforces - Code 2",
          "code": "6 6\n2 2 2 2 2 2\n1 2\n1 3\n2 3\n4 5\n4 6\n5 6",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15336",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #284 - Codeforces - Code 3",
          "code": "6 6\n2 2 2 2 2 2\n1 2\n1 3\n2 3\n4 5\n4 6\n5 6",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15336",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #284 Editorial - Codeforces - Code 1",
          "code": "for (int i = 0; i <= t; ++i) {\n    dp[i] = dp1[i]; sum += dp[i]; }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15353",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #284 Editorial - Codeforces - Code 2",
          "code": "for (int i = 0; i <= t; ++i) {\n    dp[i] = dp1[i]; sum += dp[i]; }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15353",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #284 Editorial - Codeforces - Code 3",
          "code": "double *ptr, *ptr1, *tptr;\nptr = dp;\nptr1 = dp1;\n\nfor (int i = 1; i < n; ++i) {\n    // Something to do...\n\n    tptr = ptr;\n    ptr = ptr1;\n    ptr1 = tptr;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15353",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #284 Editorial - Codeforces - Code 4",
          "code": "double *ptr, *ptr1, *tptr;\nptr = dp;\nptr1 = dp1;\n\nfor (int i = 1; i < n; ++i) {\n    // Something to do...\n\n    tptr = ptr;\n    ptr = ptr1;\n    ptr1 = tptr;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15353",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #284 Editorial - Codeforces - Code 5",
          "code": "double DP(int idx, int sec) {\n    if (sec > t)\n        return idx - 1;\n    if (sec == t or idx == n)\n        return idx;\n    double &ret = memo[idx][sec], tmp = 1;\n    if (ret == ret)\n        return ret;\n    ret = 0;\n    for (int i =1 ; i < ti[idx]; ++i) {\n        double &tret = memo[idx + 1][sec + i];\n        if (tret != tret)\n            tret = DP(idx + 1, sec + i);\n        ret += pi[idx] * tmp * tret;\n        tmp *= 1 - pi[idx];\n    }\n    return (ret += tmp * DP(idx + 1, sec + ti[idx]));\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15353",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #284 Editorial - Codeforces - Code 6",
          "code": "double DP(int idx, int sec) {\n    if (sec > t)\n        return idx - 1;\n    if (sec == t or idx == n)\n        return idx;\n    double &ret = memo[idx][sec], tmp = 1;\n    if (ret == ret)\n        return ret;\n    ret = 0;\n    for (int i =1 ; i < ti[idx]; ++i) {\n        double &tret = memo[idx + 1][sec + i];\n        if (tret != tret)\n            tret = DP(idx + 1, sec + i);\n        ret += pi[idx] * tmp * tret;\n        tmp *= 1 - pi[idx];\n    }\n    return (ret += tmp * DP(idx + 1, sec + ti[idx]));\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15353",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #284 Editorial - Codeforces - Code 7",
          "code": "3 3\n50 3\n50 2\n25 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15353",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #284 Editorial - Codeforces - Code 8",
          "code": "3 3\n50 3\n50 2\n25 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15353",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #284 Editorial - Codeforces - Code 9",
          "code": "2 5\n3 8\n13 13",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15353",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #284 Editorial - Codeforces - Code 10",
          "code": "2 5\n3 8\n13 13",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15353",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    // Read n\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n\n    // Read a_i\n    vector<int> a = inf.readInts(n, 2, 6, \"a_i\");\n    inf.readEoln();\n\n    // Read q\n    int q = inf.readInt(1, 100000, \"q\");\n    inf.readEoln();\n\n    for (int i = 0; i < q; ++i) {\n        char c = inf.readChar();\n        ensuref(c == 'A' || c == 'C', \"Query type must be 'A' or 'C', but found '%c' at line %d\", c, i + 4 + i);\n\n        inf.readSpace();\n\n        if (c == 'A') {\n            // For 'A' queries: 1 ≤ x < y ≤ n + 1\n            int x = inf.readInt(1, n, \"x\");\n            inf.readSpace();\n            int y = inf.readInt(x + 1, n + 1, \"y\");\n            inf.readEoln();\n        } else {  // c == 'C'\n            // For 'C' queries: 1 ≤ x ≤ n, 2 ≤ y ≤ 6\n            int x = inf.readInt(1, n, \"x\");\n            inf.readSpace();\n            int y = inf.readInt(2, 6, \"y\");\n            inf.readEoln();\n        }\n    }\n\n    inf.readEof();\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    // Read n\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n\n    // Read a_i\n    vector<int> a = inf.readInts(n, 2, 6, \"a_i\");\n    inf.readEoln();\n\n    // Read q\n    int q = inf.readInt(1, 100000, \"q\");\n    inf.readEoln();\n\n    for (int i = 0; i < q; ++i) {\n        char c = inf.readChar();\n        ensuref(c == 'A' || c == 'C', \"Query type must be 'A' or 'C', but found '%c' at line %d\", c, i + 4 + i);\n\n        inf.readSpace();\n\n        if (c == 'A') {\n            // For 'A' queries: 1 ≤ x < y ≤ n + 1\n            int x = inf.readInt(1, n, \"x\");\n            inf.readSpace();\n            int y = inf.readInt(x + 1, n + 1, \"y\");\n            inf.readEoln();\n        } else {  // c == 'C'\n            // For 'C' queries: 1 ≤ x ≤ n, 2 ≤ y ≤ 6\n            int x = inf.readInt(1, n, \"x\");\n            inf.readSpace();\n            int y = inf.readInt(2, 6, \"y\");\n            inf.readEoln();\n        }\n    }\n\n    inf.readEof();\n\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    // Read n\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n\n    // Read a_i\n    vector<int> a = inf.readInts(n, 2, 6, \"a_i\");\n    inf.readEoln();\n\n    // Read q\n    int q = inf.readInt(1, 100000, \"q\");\n    inf.readEoln();\n\n    for (int i = 0; i < q; ++i) {\n        char c = inf.readChar();\n        ensuref(c == 'A' || c == 'C', \"Query type must be 'A' or 'C', but found '%c' at line %d\", c, i + 4 + i);\n\n        inf.readSpace();\n\n        if (c == 'A') {\n            // For 'A' queries: 1 ≤ x < y ≤ n + 1\n            int x = inf.readInt(1, n, \"x\");\n            inf.readSpace();\n            int y = inf.readInt(x + 1, n + 1, \"y\");\n            inf.readEoln();\n        } else {  // c == 'C'\n            // For 'C' queries: 1 ≤ x ≤ n, 2 ≤ y ≤ 6\n            int x = inf.readInt(1, n, \"x\");\n            inf.readSpace();\n            int y = inf.readInt(2, 6, \"y\");\n            inf.readEoln();\n        }\n    }\n\n    inf.readEof();\n\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    // Read parameters\n    int n = opt<int>(\"n\");\n    int q = opt<int>(\"q\");\n\n    string ai_type = opt<string>(\"ai_type\", \"random\");\n    int ai_const_value = opt<int>(\"ai_const_value\", 2); // default 2\n\n    string query_type = opt<string>(\"query_type\", \"mixed\");\n    int pA = opt<int>(\"pA\", 50); // percentage of 'A' queries in 'mixed' type\n\n    string x_type = opt<string>(\"x_type\", \"random\");\n\n    // Generate ai array\n    vector<int> ai(n);\n\n    if (ai_type == \"const\") {\n        for (int i = 0; i < n; ++i)\n            ai[i] = ai_const_value; // ai_const_value should be from 2 to 6\n    } else if (ai_type == \"random\") {\n        for (int i = 0; i < n; ++i)\n            ai[i] = rnd.next(2, 6);\n    } else if (ai_type == \"min\") {\n        for (int i = 0; i < n; ++i)\n            ai[i] = 2;\n    } else if (ai_type == \"max\") {\n        for (int i = 0; i < n; ++i)\n            ai[i] = 6;\n    } else if (ai_type == \"alternating\") {\n        for (int i = 0; i < n; ++i)\n            ai[i] = (i % 2 == 0) ? 2 : 6;\n    } else {\n        // default to random\n        for (int i = 0; i < n; ++i)\n            ai[i] = rnd.next(2,6);\n    }\n\n    // Generate queries\n    vector<tuple<char, int, int>> queries(q);\n\n    for (int i = 0; i < q; ++i) {\n        int prob = rnd.next(1, 100);\n        if ((query_type == \"allA\") || (query_type == \"mixed\" && prob <= pA)) {\n            // Generate 'A' query\n            int x, y;\n            if (x_type == \"min\") {\n                x = 1;\n                y = 2;\n            } else if (x_type == \"max\") {\n                x = n;\n                y = n+1;\n            } else { // x_type == \"random\"\n                x = rnd.next(1, n);\n                y = rnd.next(x + 1, n + 1);\n            }\n            queries[i] = make_tuple('A', x, y);\n        } else {\n            // Generate 'C' query\n            int x = rnd.next(1, n);\n            int y = rnd.next(2, 6);\n            queries[i] = make_tuple('C', x, y);\n        }\n    }\n\n    // Output n\n    printf(\"%d\\n\", n);\n\n    // Output ai\n    for (int i = 0; i < n; ++i) {\n        if (i > 0) printf(\" \");\n        printf(\"%d\", ai[i]);\n    }\n    printf(\"\\n\");\n\n    // Output q\n    printf(\"%d\\n\", q);\n\n    // Output queries\n    for (int i = 0; i < q; ++i) {\n        char c = get<0>(queries[i]);\n        int x = get<1>(queries[i]);\n        int y = get<2>(queries[i]);\n        printf(\"%c %d %d\\n\", c, x, y);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    // Read parameters\n    int n = opt<int>(\"n\");\n    int q = opt<int>(\"q\");\n\n    string ai_type = opt<string>(\"ai_type\", \"random\");\n    int ai_const_value = opt<int>(\"ai_const_value\", 2); // default 2\n\n    string query_type = opt<string>(\"query_type\", \"mixed\");\n    int pA = opt<int>(\"pA\", 50); // percentage of 'A' queries in 'mixed' type\n\n    string x_type = opt<string>(\"x_type\", \"random\");\n\n    // Generate ai array\n    vector<int> ai(n);\n\n    if (ai_type == \"const\") {\n        for (int i = 0; i < n; ++i)\n            ai[i] = ai_const_value; // ai_const_value should be from 2 to 6\n    } else if (ai_type == \"random\") {\n        for (int i = 0; i < n; ++i)\n            ai[i] = rnd.next(2, 6);\n    } else if (ai_type == \"min\") {\n        for (int i = 0; i < n; ++i)\n            ai[i] = 2;\n    } else if (ai_type == \"max\") {\n        for (int i = 0; i < n; ++i)\n            ai[i] = 6;\n    } else if (ai_type == \"alternating\") {\n        for (int i = 0; i < n; ++i)\n            ai[i] = (i % 2 == 0) ? 2 : 6;\n    } else {\n        // default to random\n        for (int i = 0; i < n; ++i)\n            ai[i] = rnd.next(2,6);\n    }\n\n    // Generate queries\n    vector<tuple<char, int, int>> queries(q);\n\n    for (int i = 0; i < q; ++i) {\n        int prob = rnd.next(1, 100);\n        if ((query_type == \"allA\") || (query_type == \"mixed\" && prob <= pA)) {\n            // Generate 'A' query\n            int x, y;\n            if (x_type == \"min\") {\n                x = 1;\n                y = 2;\n            } else if (x_type == \"max\") {\n                x = n;\n                y = n+1;\n            } else { // x_type == \"random\"\n                x = rnd.next(1, n);\n                y = rnd.next(x + 1, n + 1);\n            }\n            queries[i] = make_tuple('A', x, y);\n        } else {\n            // Generate 'C' query\n            int x = rnd.next(1, n);\n            int y = rnd.next(2, 6);\n            queries[i] = make_tuple('C', x, y);\n        }\n    }\n\n    // Output n\n    printf(\"%d\\n\", n);\n\n    // Output ai\n    for (int i = 0; i < n; ++i) {\n        if (i > 0) printf(\" \");\n        printf(\"%d\", ai[i]);\n    }\n    printf(\"\\n\");\n\n    // Output q\n    printf(\"%d\\n\", q);\n\n    // Output queries\n    for (int i = 0; i < q; ++i) {\n        char c = get<0>(queries[i]);\n        int x = get<1>(queries[i]);\n        int y = get<2>(queries[i]);\n        printf(\"%c %d %d\\n\", c, x, y);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Small test cases\n./gen -n 5 -q 5 -ai_type const -ai_const_value 2 -query_type allA\n./gen -n 5 -q 5 -ai_type const -ai_const_value 6 -query_type allC\n\n# Medium test cases\n./gen -n 1000 -q 1000 -ai_type random -query_type mixed -pA 70\n./gen -n 1000 -q 1000 -ai_type min -query_type allA\n./gen -n 1000 -q 1000 -ai_type max -query_type allC\n\n# Large test cases\n./gen -n 100000 -q 50000 -ai_type alternating -query_type mixed -pA 30\n./gen -n 100000 -q 100000 -ai_type random -query_type mixed -pA 50\n\n# Maximal test cases\n./gen -n 100000 -q 100000 -ai_type max -query_type allA\n./gen -n 100000 -q 100000 -ai_type min -query_type allC\n\n# Special ai_type tests\n./gen -n 100000 -q 100000 -ai_type const -ai_const_value 4 -query_type allA\n./gen -n 100000 -q 100000 -ai_type const -ai_const_value 5 -query_type allC\n./gen -n 100000 -q 100000 -ai_type const -ai_const_value 2 -query_type allA\n./gen -n 100000 -q 100000 -ai_type const -ai_const_value 6 -query_type allA\n\n# Tests with different pA (percentage of 'A' queries)\n./gen -n 100000 -q 100000 -ai_type random -query_type mixed -pA 20\n./gen -n 100000 -q 100000 -ai_type random -query_type mixed -pA 80\n\n# Tests with x_type\n./gen -n 100000 -q 100000 -ai_type random -query_type allA -x_type min\n./gen -n 100000 -q 100000 -ai_type random -query_type allA -x_type max\n./gen -n 100000 -q 100000 -ai_type random -query_type allA -x_type random\n\n# Mixed query_type tests with x_type\n./gen -n 100000 -q 100000 -ai_type random -query_type mixed -pA 60 -x_type max\n./gen -n 100000 -q 100000 -ai_type random -query_type mixed -pA 60 -x_type min\n\n# Random queries with x_type random\n./gen -n 100000 -q 100000 -ai_type random -query_type mixed -pA 50 -x_type random\n\n# Edge case test with n=1\n./gen -n 1 -q 1 -ai_type const -ai_const_value 2 -query_type allA\n\n# Edge case with minimal n and maximal q\n./gen -n 1 -q 100000 -ai_type const -ai_const_value 2 -query_type allA\n\n# Test with q=1\n./gen -n 100000 -q 1 -ai_type random -query_type allA\n\n# Test with both n and q minimal\n./gen -n 1 -q 1 -ai_type const -ai_const_value 2 -query_type allC\n\n# Tests with only 'C' queries\n./gen -n 100000 -q 100000 -ai_type random -query_type allC\n\n# Tests with 'A' queries after 'C's that change ai values\n./gen -n 100000 -q 100000 -ai_type random -query_type mixed -pA 50\n\n# Additional mixed tests with different pA values\n./gen -n 100000 -q 100000 -ai_type random -query_type mixed -pA 10\n./gen -n 100000 -q 100000 -ai_type random -query_type mixed -pA 90\n\n# Total commands: Approximately 25 commands\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:39:23.817590",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "498/E",
      "title": "E. Палочки и лесенки",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест2 секунды",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеВ единственной строке входных данных содержатся 7 чисел w1, w2, ..., w7 (0 ≤ wi ≤ 105). Гарантируется, что хотя бы одно из wi не равно нулю.",
      "output_spec": "Выходные данныеВ единственную строку выходных данных выведите единственное число — ответ на задачу по модулю 109 + 7.",
      "sample_tests": "ПримерыВходные данныеСкопировать0 1 0 0 0 0 0Выходные данныеСкопировать1Входные данныеСкопировать0 2 0 0 0 0 0Выходные данныеСкопировать7Входные данныеСкопировать1 1 1 0 0 0 0Выходные данныеСкопировать9Входные данныеСкопировать5 1 0 3 0 0 1Выходные данныеСкопировать411199181",
      "description": "E. Палочки и лесенки\n\nограничение по времени на тест2 секунды\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвыводstdout\n\nВходные данныеВ единственной строке входных данных содержатся 7 чисел w1, w2, ..., w7 (0 ≤ wi ≤ 105). Гарантируется, что хотя бы одно из wi не равно нулю.\n\nВходные данные\n\nВыходные данныеВ единственную строку выходных данных выведите единственное число — ответ на задачу по модулю 109 + 7.\n\nВыходные данные\n\nВходные данныеСкопировать0 1 0 0 0 0 0Выходные данныеСкопировать1Входные данныеСкопировать0 2 0 0 0 0 0Выходные данныеСкопировать7Входные данныеСкопировать1 1 1 0 0 0 0Выходные данныеСкопировать9Входные данныеСкопировать5 1 0 3 0 0 1Выходные данныеСкопировать411199181\n\nВходные данныеСкопировать0 1 0 0 0 0 0\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать1\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать0 2 0 0 0 0 0\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать7\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать1 1 1 0 0 0 0\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать9\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать5 1 0 3 0 0 1\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать411199181\n\nВыходные данныеСкопировать\n\nСкопировать\n\nПримечаниеВсевозможные раскраски третьего примера представлены ниже:",
      "solutions": [
        {
          "title": "Codeforces Round #284 - Codeforces",
          "content": "Скоро состоится очередной раунд Codeforces Round #284, задачи для которого готовили Виталий Гриднев (gridnevvvit), Илья Лось (IlyaLos), Данил Сагунов (danilka.pro).Большое спасибо Максиму Ахмедову (Zlobober) за помощь в подготовке задач, Марии Беловой (Delinur) за переводы на английский, Михаилу Мирзаянову (MikeMirzayanov) за замечательные системы Codeforces и Polygon.Будет использоваться динамическая разбалловка. Задачи расположены в порядке возрастания предполагаемой сложности.Раунд окончен, поздравляем победителей!Div1: yeputons rng_58 Endagorion KADR Egor uwi mmaxio atetubou RAVEman Div2: sorry_dreamoon dreamoon_love_AA dreamoon_fan Разбор задачУдачи!",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/15336",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 663
        },
        {
          "title": "Разбор Codeforces Round #284 - Codeforces",
          "content": "499A - Просмотр фильмаЗадача решается жадным алгоритмом — если мы на текущем моменте времени можем пропустить x минут, не пропустив при этом ни одного хорошего момента, то мы пропускаем x минут, в противном случае — смотрим очередную минуту фильма.499B - ЛекцияВ задаче требовалось для каждой строки из текста искать, в какой паре она находится, и из двух строк этой пары выводить меньшую по длине.498A - Сумасшедший город / 499C - Сумасшедший городНесложно показать, что, если две исходные точки изначально находятся по разные стороны какой-то из прямых, эту прямую в любом случае придется пересечь. Поскольку все, что нам нужно — это пересечь все такие прямые, ответ на задачу — их количество.Чтобы проверить, лежат ли точки по разные стороны прямой, достаточно подставить их координаты в ее уравнение, и проверить, что получившиеся два значения имеют разные знаки.Итоговая сложность решения — O(n).498B - Музыкальная пауза / 499D - Музыкальная паузаДля удобства будем нумеровать песни с нуля.Задачу будем решать методом динамического программирования. Состояние динамики будем описывать парой чисел i и j: dp[i][j] — вероятность того, что мы угадали ровно i песен, угадав последнюю из них ровно перед началом j-ой секунды (то есть Петя еще не включал следующую (i-ую) песню). База динамики, очевидно, dp[0][0] = 1.Чтобы из состояния (i, j) сделать переход в состояние (i + 1, j + k) (1 ≤ k < ti), нужно угадать i-ую песню ровно после k-ой секунды воспроизведения, не угадывая ее до этого — вероятность такого перехода равна (1 - pi)k - 1·pi. Для фиксированного состояния (i + 1, j) сумму таких переходов можно записать в виде суммы . Простое вычисление такой суммы для каждого состояния займет O(nT2) времени, поэтому нужно заметить, что при фиксированном i такую сумму можно поддерживать двумя указателями (в общем случае они задают отрезок длиной ti) для каждого j за O(T) времени. Таким образом, подсчет переходов такого типа займет O(nT) времени.Переход в (i + 1, j + ti) следует рассмотреть отдельно. Также существует и вариант не успеть угадать песню в отведенное время — это переход из (i, j) в (i, (j + k) = T). Переходы этих двух типов считаются за O(nT).Итоговая сложность решения — O(nT).498C - Массив и операции / 499E - Массив и операцииПрежде всего заметим, что делить на составные числа невыгодно.Теперь построим граф, где каждому числу соответствует некоторая группа вершин:Разложим каждое число на простые делители. Каждому из простых делителей будет соответствовать некоторая вершина в графе, при этом, если число p входит в i-ое число в степени ai, то ему будет соответствовать ровно ai вершин в группе i-го числа.Количество вершин в таком графе будет составлять .Теперь будем проводить ребра в получившемся графе: ребро между двумя вершинами будет существовать тогда и только тогда, когда числа, соответствующие группам эти вершин, находятся в некоторой хорошей паре, а простые, соответствующие этим вершинам, равны. Проще говоря, каждое такое ребро означает, что мы можем поделить числа, соответствующие группам вершин, на соответствующее вершинам простое.Ребер при таком построении будет .Пары заданы так, что полученный граф — двудольный. Найдя наибольшее паросочетание в полученном графе, мы однозначно получим наилучший способ выполнения операций в массиве.Итоговая асимптотика решения, использующего алгоритм Куна . Можно также заметить, что некоторые ребра лишние, и свести эту оценку к .498D - Пробки в странеРешение задачи — 60 (НОК чисел от 2 до 6) деревьев отрезков.В v-ом дереве отрезков будем поддерживать для каждого отрезка [l, r] следующую величину: минимальное количество времени, необходимое, чтобы добраться от l до r, если мы начинаем в момент времени, равный v по модулю 60. Используя значения этих деревьев, несложно быстро отвечать на запросы, аккуратно изменяя деревья.498E - Палочки и лесенкиЗадача решается динамикой dp[i][mask] — количество способов покрасить первые i ступеней лестницы так, что последний уровень вертикальных палочек соответствует маске mask. Ее значения несложно пересчитывать, если знать матрицу M[mask1][mask2] — количество способов покрасить горизонтальные палочки между двумя соседними слоями вертикальных палочек, закрашенных соответственно маскам mask1 и mask2. Поскольку вертикальных слоев для фиксированного i ровно wi, то эту матрицу нужно возвести в степень, равную этому числу. После этого матрица очень просто используется для выполнения переходов динамики (подробнее в авторском решении).Итоговая сложность решения —",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/15353",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 498\\s*E"
          },
          "content_length": 4498
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #284 - Codeforces - Code 1",
          "code": "while(true) System.out.println(\"NOOOOOOOOOOOOOOOOOOOO\");",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15336",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #284 - Codeforces - Code 2",
          "code": "6 6\n2 2 2 2 2 2\n1 2\n1 3\n2 3\n4 5\n4 6\n5 6",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15336",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #284 - Codeforces - Code 3",
          "code": "6 6\n2 2 2 2 2 2\n1 2\n1 3\n2 3\n4 5\n4 6\n5 6",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15336",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #284 - Codeforces - Code 1",
          "code": "for (int i = 0; i <= t; ++i) {\n    dp[i] = dp1[i]; sum += dp[i]; }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15353",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #284 - Codeforces - Code 2",
          "code": "for (int i = 0; i <= t; ++i) {\n    dp[i] = dp1[i]; sum += dp[i]; }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15353",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #284 - Codeforces - Code 3",
          "code": "double *ptr, *ptr1, *tptr;\nptr = dp;\nptr1 = dp1;\n\nfor (int i = 1; i < n; ++i) {\n    // Something to do...\n\n    tptr = ptr;\n    ptr = ptr1;\n    ptr1 = tptr;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15353",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #284 - Codeforces - Code 4",
          "code": "double *ptr, *ptr1, *tptr;\nptr = dp;\nptr1 = dp1;\n\nfor (int i = 1; i < n; ++i) {\n    // Something to do...\n\n    tptr = ptr;\n    ptr = ptr1;\n    ptr1 = tptr;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15353",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #284 - Codeforces - Code 5",
          "code": "double DP(int idx, int sec) {\n    if (sec > t)\n        return idx - 1;\n    if (sec == t or idx == n)\n        return idx;\n    double &ret = memo[idx][sec], tmp = 1;\n    if (ret == ret)\n        return ret;\n    ret = 0;\n    for (int i =1 ; i < ti[idx]; ++i) {\n        double &tret = memo[idx + 1][sec + i];\n        if (tret != tret)\n            tret = DP(idx + 1, sec + i);\n        ret += pi[idx] * tmp * tret;\n        tmp *= 1 - pi[idx];\n    }\n    return (ret += tmp * DP(idx + 1, sec + ti[idx]));\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15353",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #284 - Codeforces - Code 6",
          "code": "double DP(int idx, int sec) {\n    if (sec > t)\n        return idx - 1;\n    if (sec == t or idx == n)\n        return idx;\n    double &ret = memo[idx][sec], tmp = 1;\n    if (ret == ret)\n        return ret;\n    ret = 0;\n    for (int i =1 ; i < ti[idx]; ++i) {\n        double &tret = memo[idx + 1][sec + i];\n        if (tret != tret)\n            tret = DP(idx + 1, sec + i);\n        ret += pi[idx] * tmp * tret;\n        tmp *= 1 - pi[idx];\n    }\n    return (ret += tmp * DP(idx + 1, sec + ti[idx]));\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15353",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #284 - Codeforces - Code 7",
          "code": "3 3\n50 3\n50 2\n25 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15353",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #284 - Codeforces - Code 8",
          "code": "3 3\n50 3\n50 2\n25 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15353",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #284 - Codeforces - Code 9",
          "code": "2 5\n3 8\n13 13",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15353",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #284 - Codeforces - Code 10",
          "code": "2 5\n3 8\n13 13",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15353",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    vector<int> w = inf.readInts(7, 0, 100000, \"w\");\n    inf.readEoln();\n    ensuref(any_of(w.begin(), w.end(), [](int x){return x != 0;}), \"At least one of the wi's isn't equal to zero\");\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    vector<int> w = inf.readInts(7, 0, 100000, \"w\");\n    inf.readEoln();\n    ensuref(any_of(w.begin(), w.end(), [](int x){return x != 0;}), \"At least one of the wi's isn't equal to zero\");\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    vector<int> w = inf.readInts(7, 0, 100000, \"w\");\n    inf.readEoln();\n    ensuref(any_of(w.begin(), w.end(), [](int x){return x != 0;}), \"At least one of the wi's isn't equal to zero\");\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int maxw = opt<int>(\"maxw\", 100000);\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> w(7, 0);\n\n    if (type == \"random\") {\n        // Randomly assign values to w[i], ensuring at least one w[i] is non-zero\n        for (int i = 0; i < 7; i++) {\n            w[i] = rnd.next(0, maxw);\n        }\n        if (accumulate(w.begin(), w.end(), 0) == 0) {\n            w[rnd.next(0,6)] = rnd.next(1, maxw);\n        }\n    } else if (type == \"max\") {\n        // All w[i] are set to maxw\n        for (int i = 0; i < 7; i++) {\n            w[i] = maxw;\n        }\n    } else if (type == \"zeroes\") {\n        // Many zeros in w[i], ensuring at least one w[i] is non-zero\n        int non_zero_count = rnd.next(1, 3);\n        vector<int> indices(7);\n        iota(indices.begin(), indices.end(), 0);\n        shuffle(indices.begin(), indices.end());\n        for (int i = 0; i < non_zero_count; i++) {\n            w[indices[i]] = rnd.next(1, maxw);\n        }\n    } else if (type == \"single\") {\n        // Only one w[i] is non-zero\n        int idx = rnd.next(0,6);\n        w[idx] = rnd.next(1, maxw);\n    } else if (type == \"increasing\") {\n        // w[i] increases from w1 to w7\n        int increment = maxw / 7;\n        for (int i = 0; i < 7; i++) {\n            w[i] = increment * (i + 1);\n        }\n    } else if (type == \"decreasing\") {\n        // w[i] decreases from w1 to w7\n        int decrement = maxw / 7;\n        for (int i = 0; i < 7; i++) {\n            w[i] = decrement * (7 - i);\n        }\n    } else if (type == \"palindrome\") {\n        // w[i] forms a palindrome\n        for (int i = 0; i <= 3; i++) {\n            int val = rnd.next(0, maxw);\n            w[i] = val;\n            w[6 - i] = val;\n        }\n        if (accumulate(w.begin(), w.end(), 0) == 0) {\n            w[3] = rnd.next(1, maxw);\n        }\n    } else if (type == \"same\") {\n        // All w[i] are the same non-zero value\n        int val = rnd.next(1, maxw);\n        for (int i = 0; i < 7; i++) {\n            w[i] = val;\n        }\n    } else {\n        // Default random case\n        for (int i = 0; i < 7; i++) {\n            w[i] = rnd.next(0, maxw);\n        }\n        if (accumulate(w.begin(), w.end(), 0) == 0) {\n            w[rnd.next(0,6)] = rnd.next(1, maxw);\n        }\n    }\n\n    // Output the w[i] values\n    for (int i = 0; i < 7; i++) {\n        printf(\"%d%c\", w[i], i == 6 ? '\\n' : ' ');\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int maxw = opt<int>(\"maxw\", 100000);\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> w(7, 0);\n\n    if (type == \"random\") {\n        // Randomly assign values to w[i], ensuring at least one w[i] is non-zero\n        for (int i = 0; i < 7; i++) {\n            w[i] = rnd.next(0, maxw);\n        }\n        if (accumulate(w.begin(), w.end(), 0) == 0) {\n            w[rnd.next(0,6)] = rnd.next(1, maxw);\n        }\n    } else if (type == \"max\") {\n        // All w[i] are set to maxw\n        for (int i = 0; i < 7; i++) {\n            w[i] = maxw;\n        }\n    } else if (type == \"zeroes\") {\n        // Many zeros in w[i], ensuring at least one w[i] is non-zero\n        int non_zero_count = rnd.next(1, 3);\n        vector<int> indices(7);\n        iota(indices.begin(), indices.end(), 0);\n        shuffle(indices.begin(), indices.end());\n        for (int i = 0; i < non_zero_count; i++) {\n            w[indices[i]] = rnd.next(1, maxw);\n        }\n    } else if (type == \"single\") {\n        // Only one w[i] is non-zero\n        int idx = rnd.next(0,6);\n        w[idx] = rnd.next(1, maxw);\n    } else if (type == \"increasing\") {\n        // w[i] increases from w1 to w7\n        int increment = maxw / 7;\n        for (int i = 0; i < 7; i++) {\n            w[i] = increment * (i + 1);\n        }\n    } else if (type == \"decreasing\") {\n        // w[i] decreases from w1 to w7\n        int decrement = maxw / 7;\n        for (int i = 0; i < 7; i++) {\n            w[i] = decrement * (7 - i);\n        }\n    } else if (type == \"palindrome\") {\n        // w[i] forms a palindrome\n        for (int i = 0; i <= 3; i++) {\n            int val = rnd.next(0, maxw);\n            w[i] = val;\n            w[6 - i] = val;\n        }\n        if (accumulate(w.begin(), w.end(), 0) == 0) {\n            w[3] = rnd.next(1, maxw);\n        }\n    } else if (type == \"same\") {\n        // All w[i] are the same non-zero value\n        int val = rnd.next(1, maxw);\n        for (int i = 0; i < 7; i++) {\n            w[i] = val;\n        }\n    } else {\n        // Default random case\n        for (int i = 0; i < 7; i++) {\n            w[i] = rnd.next(0, maxw);\n        }\n        if (accumulate(w.begin(), w.end(), 0) == 0) {\n            w[rnd.next(0,6)] = rnd.next(1, maxw);\n        }\n    }\n\n    // Output the w[i] values\n    for (int i = 0; i < 7; i++) {\n        printf(\"%d%c\", w[i], i == 6 ? '\\n' : ' ');\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Random test cases with small maxw\n./gen -type random -maxw 1\n./gen -type random -maxw 10\n\n# Random test cases with moderate maxw\n./gen -type random -maxw 100\n./gen -type random -maxw 1000\n\n# Random test cases with large maxw\n./gen -type random -maxw 10000\n./gen -type random -maxw 50000\n./gen -type random -maxw 100000\n\n# Max value test cases\n./gen -type max -maxw 1\n./gen -type max -maxw 10\n./gen -type max -maxw 1000\n./gen -type max -maxw 100000\n\n# Test cases with many zeroes\n./gen -type zeroes -maxw 1\n./gen -type zeroes -maxw 10\n./gen -type zeroes -maxw 1000\n./gen -type zeroes -maxw 100000\n\n# Test cases with a single non-zero w[i]\n./gen -type single -maxw 1\n./gen -type single -maxw 10\n./gen -type single -maxw 1000\n./gen -type single -maxw 100000\n\n# Increasing w[i] values\n./gen -type increasing -maxw 1\n./gen -type increasing -maxw 10\n./gen -type increasing -maxw 1000\n./gen -type increasing -maxw 100000\n\n# Decreasing w[i] values\n./gen -type decreasing -maxw 1\n./gen -type decreasing -maxw 10\n./gen -type decreasing -maxw 1000\n./gen -type decreasing -maxw 100000\n\n# Palindrome w[i] values\n./gen -type palindrome -maxw 1\n./gen -type palindrome -maxw 10\n./gen -type palindrome -maxw 1000\n./gen -type palindrome -maxw 100000\n\n# All w[i] are the same\n./gen -type same -maxw 1\n./gen -type same -maxw 10\n./gen -type same -maxw 1000\n./gen -type same -maxw 100000\n\n# Additional random test cases with specific maxw\n./gen -type random -maxw 99999\n./gen -type random -maxw 54321\n./gen -type random -maxw 12345\n./gen -type random -maxw 98765\n\n# Edge cases with zeros and maximum values\n./gen -type zeroes -maxw 1\n./gen -type zeroes -maxw 100000\n./gen -type max -maxw 1\n./gen -type max -maxw 100000\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:39:26.080860",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "499/A",
      "title": "A. Watching a movie",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains two space-separated integers n, x (1 ≤ n ≤ 50, 1 ≤ x ≤ 105) — the number of the best moments of the movie and the value of x for the second button.The following n lines contain the descriptions of the best moments of the movie, the i-th line of the description contains two integers separated by a space li, ri (1 ≤ li ≤ ri ≤ 105).It is guaranteed that for all integers i from 2 to n the following condition holds: ri - 1 < li.",
      "output_spec": "OutputOutput a single number — the answer to the problem.",
      "sample_tests": "ExamplesInputCopy2 35 610 12OutputCopy6InputCopy1 11 100000OutputCopy100000",
      "description": "A. Watching a movie\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains two space-separated integers n, x (1 ≤ n ≤ 50, 1 ≤ x ≤ 105) — the number of the best moments of the movie and the value of x for the second button.The following n lines contain the descriptions of the best moments of the movie, the i-th line of the description contains two integers separated by a space li, ri (1 ≤ li ≤ ri ≤ 105).It is guaranteed that for all integers i from 2 to n the following condition holds: ri - 1 < li.\n\nOutputOutput a single number — the answer to the problem.\n\nInputCopy2 35 610 12OutputCopy6InputCopy1 11 100000OutputCopy100000\n\nInputCopy2 35 610 12\n\nOutputCopy6\n\nInputCopy1 11 100000\n\nOutputCopy100000\n\nNoteIn the first sample, the player was initially standing on the first minute. As the minutes from the 1-st to the 4-th one don't contain interesting moments, we press the second button. Now we can not press the second button and skip 3 more minutes, because some of them contain interesting moments. Therefore, we watch the movie from the 4-th to the 6-th minute, after that the current time is 7. Similarly, we again skip 3 minutes and then watch from the 10-th to the 12-th minute of the movie. In total, we watch 6 minutes of the movie.In the second sample, the movie is very interesting, so you'll have to watch all 100000 minutes of the movie.",
      "solutions": [
        {
          "title": "Codeforces Round #284 - Codeforces",
          "content": "Soon you are lucky to participate in Codeforces Round #284, and problems have been prepared by Vitaly Gridnev (gridnevvvit), Ilya Los (IlyaLos), Danil Sagunov (danilka.pro).We want to thank Max Akhmedov (Zlobober) for help with preparation of this round, Maria Belova (Delinur) for translation of statements and Mike Mirzayanov (MikeMirzayanov) for marvelous Codeforces and Polygon systems.Scoring system will be dynamic. Problems will be arranged in ascending expected difficulty order.Round finished, congratulations to winners!Div1: yeputons rng_58 Endagorion KADR Egor uwi mmaxio atetubou RAVEman Div2: sorry_dreamoon dreamoon_love_AA dreamoon_fan EditorialGood luck!",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/15336",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 671
        },
        {
          "title": "Codeforces Round #284 Editorial - Codeforces",
          "content": "499A - Watching a movieOne can solve the problem using greedy algorithm: if we can skip x minutes at current moment without skipping any good moment — we do that, otherwise — watch another minute of the film.499B - LectureIn this task you must find for every string in the text the pair containing that string, and from two strings of that pair output the shortest one.498A - Crazy Town / 499C - Crazy TownIt can be easily proved that, if two points from statement are placed on different sides of some line, this line will be crossed anyway. So, all we need to do is to cross all these lines, so the answer is the number of these lines.To check if two points lies on different sides of a line one can simply use its coordinates to place in line equation and check if these two values have different signs. Solution complexity — O(n).498B - Name That Tune / 499D - Name That TuneLet's numerate all the songs and seconds starting from 0.Problem will be solved using DP approach. State will be described by two integers (i, j): dp[i][j] is probability of that we named exactly i songs, and the last named song was named exactly before j'th second (after j - 1 seconds). dp[0][0] = 1 obviously.To make a move from state (i, j) to state (i + 1, j + k) (1 ≤ k < ti), we must name the song exactly after k seconds its playing — probability of that is (1 - pi)k - 1·pi. To fixed state (i + 1, j) sum of that moves can be represented as . Simple calculation of this value for each state gives O(nT2) complexity, so one must notice, that this values can be calculated using two pointers for fixed i (in common case it represent a segment with ti length) for every j in time O(T). This way calculating this type of moves takes O(nT) time.There is also a move to (i + 1, j + ti) and a move from (i, j) to (i, (j + k) = T), when we couldn't name current song in time T. This types of moves is calculated with O(nT) too.Solution complexity — O(nT).498C - Array and Operations / 499E - Array and OperationsWe will divide only by prime numbers.First, let's build a graph, where each of n numbers have own vertex group:Find all prime factors of current number. Every factor will have its own vertex in a group, furthermore, if some factor p has power of ai in current number, it will have exactly ai vertexes in group.The number of vertexes in such graph is .Now we will make edges in our graph: edge between two vertexes exists if and only if there is a good pair (given in statement) of vertexes group numbers and the prime values of a vertexes are the same. That means that we can divide that group numbers by that prime.The number of edges is .Good pairs are given the way that our graph is bipartite. After finding maximum matching in this graph we represent the way of doing operations as described in the statement.As soon as solution is using Kuhn's algorithm, its complexity is . One could notice that some of the edges are useless and reduce it to .498D - Traffic Jams in the LandThe solution of a problem — 60 (LCM of a numbers from 2 to 6) segment trees.In v'th segment tree we will hold for every segment [l, r] the next value: minimum time needed to get from l to r if we start in a moment of time equal to v modulo 60. Using these trees' values it is easy to quickly answer the questions, carefully changing the trees' values.498E - Stairs and LinesThe problem is solved using DP approach dp[i][mask] — the number of ways to paint first i blocks of a ladder the way that the last layer of vertical edges is painted as described in mask mask. This could be easily recalculated using matrix M[mask1][mask2] — the number of ways to paint horizontal edges between two neighbour vertical layers painted as represented by masks mask1 and mask2.For fixed i we have wi layers, so this matrix must be multiplied by itself wi times, which can be quickly done by binary-pow algorithm. After that this matrix is simply used in dynamic described above.Solution complexity — .",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/15353",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 499\\s*A"
          },
          "content_length": 3961
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #284 - Codeforces - Code 1",
          "code": "while(true) System.out.println(\"NOOOOOOOOOOOOOOOOOOOO\");",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15336",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #284 - Codeforces - Code 2",
          "code": "6 6\n2 2 2 2 2 2\n1 2\n1 3\n2 3\n4 5\n4 6\n5 6",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15336",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #284 - Codeforces - Code 3",
          "code": "6 6\n2 2 2 2 2 2\n1 2\n1 3\n2 3\n4 5\n4 6\n5 6",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15336",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #284 Editorial - Codeforces - Code 1",
          "code": "for (int i = 0; i <= t; ++i) {\n    dp[i] = dp1[i]; sum += dp[i]; }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15353",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #284 Editorial - Codeforces - Code 2",
          "code": "for (int i = 0; i <= t; ++i) {\n    dp[i] = dp1[i]; sum += dp[i]; }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15353",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #284 Editorial - Codeforces - Code 3",
          "code": "double *ptr, *ptr1, *tptr;\nptr = dp;\nptr1 = dp1;\n\nfor (int i = 1; i < n; ++i) {\n    // Something to do...\n\n    tptr = ptr;\n    ptr = ptr1;\n    ptr1 = tptr;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15353",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #284 Editorial - Codeforces - Code 4",
          "code": "double *ptr, *ptr1, *tptr;\nptr = dp;\nptr1 = dp1;\n\nfor (int i = 1; i < n; ++i) {\n    // Something to do...\n\n    tptr = ptr;\n    ptr = ptr1;\n    ptr1 = tptr;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15353",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #284 Editorial - Codeforces - Code 5",
          "code": "double DP(int idx, int sec) {\n    if (sec > t)\n        return idx - 1;\n    if (sec == t or idx == n)\n        return idx;\n    double &ret = memo[idx][sec], tmp = 1;\n    if (ret == ret)\n        return ret;\n    ret = 0;\n    for (int i =1 ; i < ti[idx]; ++i) {\n        double &tret = memo[idx + 1][sec + i];\n        if (tret != tret)\n            tret = DP(idx + 1, sec + i);\n        ret += pi[idx] * tmp * tret;\n        tmp *= 1 - pi[idx];\n    }\n    return (ret += tmp * DP(idx + 1, sec + ti[idx]));\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15353",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #284 Editorial - Codeforces - Code 6",
          "code": "double DP(int idx, int sec) {\n    if (sec > t)\n        return idx - 1;\n    if (sec == t or idx == n)\n        return idx;\n    double &ret = memo[idx][sec], tmp = 1;\n    if (ret == ret)\n        return ret;\n    ret = 0;\n    for (int i =1 ; i < ti[idx]; ++i) {\n        double &tret = memo[idx + 1][sec + i];\n        if (tret != tret)\n            tret = DP(idx + 1, sec + i);\n        ret += pi[idx] * tmp * tret;\n        tmp *= 1 - pi[idx];\n    }\n    return (ret += tmp * DP(idx + 1, sec + ti[idx]));\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15353",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #284 Editorial - Codeforces - Code 7",
          "code": "3 3\n50 3\n50 2\n25 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15353",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #284 Editorial - Codeforces - Code 8",
          "code": "3 3\n50 3\n50 2\n25 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15353",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #284 Editorial - Codeforces - Code 9",
          "code": "2 5\n3 8\n13 13",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15353",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #284 Editorial - Codeforces - Code 10",
          "code": "2 5\n3 8\n13 13",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15353",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 50, \"n\");\n    inf.readSpace();\n    int x = inf.readInt(1, 100000, \"x\");\n    inf.readEoln();\n\n    int prev_ri = -1;\n    for (int i = 0; i < n; ++i) {\n        int li = inf.readInt(1, 100000, \"li\");\n        inf.readSpace();\n        int ri = inf.readInt(li, 100000, \"ri\");\n        inf.readEoln();\n\n        if (i > 0) {\n            ensuref(prev_ri < li, \"Interval %d does not satisfy ri−1 < li\", i+1);\n        }\n\n        prev_ri = ri;\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 50, \"n\");\n    inf.readSpace();\n    int x = inf.readInt(1, 100000, \"x\");\n    inf.readEoln();\n\n    int prev_ri = -1;\n    for (int i = 0; i < n; ++i) {\n        int li = inf.readInt(1, 100000, \"li\");\n        inf.readSpace();\n        int ri = inf.readInt(li, 100000, \"ri\");\n        inf.readEoln();\n\n        if (i > 0) {\n            ensuref(prev_ri < li, \"Interval %d does not satisfy ri−1 < li\", i+1);\n        }\n\n        prev_ri = ri;\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 50, \"n\");\n    inf.readSpace();\n    int x = inf.readInt(1, 100000, \"x\");\n    inf.readEoln();\n\n    int prev_ri = -1;\n    for (int i = 0; i < n; ++i) {\n        int li = inf.readInt(1, 100000, \"li\");\n        inf.readSpace();\n        int ri = inf.readInt(li, 100000, \"ri\");\n        inf.readEoln();\n\n        if (i > 0) {\n            ensuref(prev_ri < li, \"Interval %d does not satisfy ri−1 < li\", i+1);\n        }\n\n        prev_ri = ri;\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int x = opt<int>(\"x\");\n    string type = opt<string>(\"type\", \"random\");\n\n    // Ensure n and x are within the constraints\n    ensure(1 <= n && n <= 50);\n    ensure(1 <= x && x <= 100000);\n\n    vector<pair<int, int>> intervals;\n\n    if (type == \"random\") {\n        int total_time = 100000;\n        int ri_prev = 0;\n\n        for (int i = 0; i < n; ++i) {\n            int remaining_intervals = n - i;\n            int min_li = ri_prev + 1; // Since ri_prev < li_i\n            int max_li = total_time - (remaining_intervals - 1); // Leave at least one minute for each remaining interval\n            if (min_li > max_li) min_li = max_li;\n\n            int li = rnd.next(min_li, max_li);\n\n            int min_ri = li;\n            int max_ri = total_time - (remaining_intervals - 1);\n            int ri = rnd.next(min_ri, max_ri);\n\n            intervals.push_back({li, ri});\n            ri_prev = ri;\n        }\n    } else if (type == \"min_n\") {\n        n = 1;\n        int li = 1;\n        int ri = rnd.next(li, 100000);\n        intervals.push_back({li, ri});\n    } else if (type == \"max_n\") {\n        n = 50;\n        int ri_prev = 0;\n        for (int i = 0; i < n; ++i) {\n            int li = ri_prev + 1;\n            int ri = li + rnd.next(0, 1000);\n            intervals.push_back({li, ri});\n            ri_prev = ri;\n        }\n    } else if (type == \"max_x\") {\n        x = 100000;\n        int ri_prev = 0;\n        for (int i = 0; i < n; ++i) {\n            int li = ri_prev + 1;\n            int ri = li + rnd.next(0, 1000);\n            intervals.push_back({li, ri});\n            ri_prev = ri;\n        }\n    } else if (type == \"min_x\") {\n        x = 1;\n        int ri_prev = 0;\n        for (int i = 0; i < n; ++i) {\n            int li = ri_prev + 1;\n            int ri = li + rnd.next(0, 1000);\n            intervals.push_back({li, ri});\n            ri_prev = ri;\n        }\n    } else if (type == \"edge_intervals\") {\n        int ri_prev = 0;\n        for (int i = 0; i < n; ++i) {\n            int li;\n            int ri;\n            if (i == 0) {\n                li = 1; // First interval starts at 1\n                ri = rnd.next(li, 1000);\n            } else if (i == n - 1) {\n                li = ri_prev + 1;\n                ri = 100000; // Last interval ends at 1e5\n            } else {\n                li = ri_prev + 1;\n                ri = li + rnd.next(0, 1000);\n            }\n            intervals.push_back({li, ri});\n            ri_prev = ri;\n        }\n    } else if (type == \"max_intervals\") {\n        int ri_prev = 0;\n        int gap = 1;\n        int total_available = 100000 - n * gap;\n        int interval_length = total_available / n;\n\n        for (int i = 0; i < n; ++i) {\n            int li = ri_prev + gap;\n            int ri = li + interval_length - 1;\n            if (i == n - 1) {\n                ri = 100000; // Ensure the last interval ends at 1e5\n            }\n            intervals.push_back({li, ri});\n            ri_prev = ri;\n        }\n    } else if (type == \"small_intervals\") {\n        int ri_prev = 0;\n        for (int i = 0; i < n; ++i) {\n            int li = ri_prev + 1;\n            int ri = li; // Intervals of minimal length\n            intervals.push_back({li, ri});\n            ri_prev = ri;\n        }\n    } else if (type == \"full_coverage\") {\n        n = 1;\n        int li = 1;\n        int ri = 100000;\n        intervals.push_back({li, ri});\n    } else if (type == \"single_point\") {\n        n = 1;\n        int li = rnd.next(1, 100000);\n        int ri = li; // Interval of length 1\n        intervals.push_back({li, ri});\n    } else {\n        // Default to random if unknown type\n        int total_time = 100000;\n        int ri_prev = 0;\n\n        for (int i = 0; i < n; ++i) {\n            int remaining_intervals = n - i;\n            int min_li = ri_prev + 1; // Since ri_prev < li_i\n            int max_li = total_time - (remaining_intervals - 1); // Leave at least one minute for each remaining interval\n            if (min_li > max_li) min_li = max_li;\n\n            int li = rnd.next(min_li, max_li);\n\n            int min_ri = li;\n            int max_ri = total_time - (remaining_intervals - 1);\n            int ri = rnd.next(min_ri, max_ri);\n\n            intervals.push_back({li, ri});\n            ri_prev = ri;\n        }\n    }\n\n    // Output n and x\n    printf(\"%d %d\\n\", n, x);\n    // Output the intervals\n    for (int i = 0; i < intervals.size(); ++i) {\n        printf(\"%d %d\\n\", intervals[i].first, intervals[i].second);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int x = opt<int>(\"x\");\n    string type = opt<string>(\"type\", \"random\");\n\n    // Ensure n and x are within the constraints\n    ensure(1 <= n && n <= 50);\n    ensure(1 <= x && x <= 100000);\n\n    vector<pair<int, int>> intervals;\n\n    if (type == \"random\") {\n        int total_time = 100000;\n        int ri_prev = 0;\n\n        for (int i = 0; i < n; ++i) {\n            int remaining_intervals = n - i;\n            int min_li = ri_prev + 1; // Since ri_prev < li_i\n            int max_li = total_time - (remaining_intervals - 1); // Leave at least one minute for each remaining interval\n            if (min_li > max_li) min_li = max_li;\n\n            int li = rnd.next(min_li, max_li);\n\n            int min_ri = li;\n            int max_ri = total_time - (remaining_intervals - 1);\n            int ri = rnd.next(min_ri, max_ri);\n\n            intervals.push_back({li, ri});\n            ri_prev = ri;\n        }\n    } else if (type == \"min_n\") {\n        n = 1;\n        int li = 1;\n        int ri = rnd.next(li, 100000);\n        intervals.push_back({li, ri});\n    } else if (type == \"max_n\") {\n        n = 50;\n        int ri_prev = 0;\n        for (int i = 0; i < n; ++i) {\n            int li = ri_prev + 1;\n            int ri = li + rnd.next(0, 1000);\n            intervals.push_back({li, ri});\n            ri_prev = ri;\n        }\n    } else if (type == \"max_x\") {\n        x = 100000;\n        int ri_prev = 0;\n        for (int i = 0; i < n; ++i) {\n            int li = ri_prev + 1;\n            int ri = li + rnd.next(0, 1000);\n            intervals.push_back({li, ri});\n            ri_prev = ri;\n        }\n    } else if (type == \"min_x\") {\n        x = 1;\n        int ri_prev = 0;\n        for (int i = 0; i < n; ++i) {\n            int li = ri_prev + 1;\n            int ri = li + rnd.next(0, 1000);\n            intervals.push_back({li, ri});\n            ri_prev = ri;\n        }\n    } else if (type == \"edge_intervals\") {\n        int ri_prev = 0;\n        for (int i = 0; i < n; ++i) {\n            int li;\n            int ri;\n            if (i == 0) {\n                li = 1; // First interval starts at 1\n                ri = rnd.next(li, 1000);\n            } else if (i == n - 1) {\n                li = ri_prev + 1;\n                ri = 100000; // Last interval ends at 1e5\n            } else {\n                li = ri_prev + 1;\n                ri = li + rnd.next(0, 1000);\n            }\n            intervals.push_back({li, ri});\n            ri_prev = ri;\n        }\n    } else if (type == \"max_intervals\") {\n        int ri_prev = 0;\n        int gap = 1;\n        int total_available = 100000 - n * gap;\n        int interval_length = total_available / n;\n\n        for (int i = 0; i < n; ++i) {\n            int li = ri_prev + gap;\n            int ri = li + interval_length - 1;\n            if (i == n - 1) {\n                ri = 100000; // Ensure the last interval ends at 1e5\n            }\n            intervals.push_back({li, ri});\n            ri_prev = ri;\n        }\n    } else if (type == \"small_intervals\") {\n        int ri_prev = 0;\n        for (int i = 0; i < n; ++i) {\n            int li = ri_prev + 1;\n            int ri = li; // Intervals of minimal length\n            intervals.push_back({li, ri});\n            ri_prev = ri;\n        }\n    } else if (type == \"full_coverage\") {\n        n = 1;\n        int li = 1;\n        int ri = 100000;\n        intervals.push_back({li, ri});\n    } else if (type == \"single_point\") {\n        n = 1;\n        int li = rnd.next(1, 100000);\n        int ri = li; // Interval of length 1\n        intervals.push_back({li, ri});\n    } else {\n        // Default to random if unknown type\n        int total_time = 100000;\n        int ri_prev = 0;\n\n        for (int i = 0; i < n; ++i) {\n            int remaining_intervals = n - i;\n            int min_li = ri_prev + 1; // Since ri_prev < li_i\n            int max_li = total_time - (remaining_intervals - 1); // Leave at least one minute for each remaining interval\n            if (min_li > max_li) min_li = max_li;\n\n            int li = rnd.next(min_li, max_li);\n\n            int min_ri = li;\n            int max_ri = total_time - (remaining_intervals - 1);\n            int ri = rnd.next(min_ri, max_ri);\n\n            intervals.push_back({li, ri});\n            ri_prev = ri;\n        }\n    }\n\n    // Output n and x\n    printf(\"%d %d\\n\", n, x);\n    // Output the intervals\n    for (int i = 0; i < intervals.size(); ++i) {\n        printf(\"%d %d\\n\", intervals[i].first, intervals[i].second);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Random test cases with varying n and x\n./gen -n 5 -x 10 -type random\n./gen -n 10 -x 100 -type random\n./gen -n 20 -x 1000 -type random\n./gen -n 30 -x 10000 -type random\n\n# Minimum n (n=1) with random x\n./gen -n 1 -x 500 -type min_n\n./gen -n 1 -x 1 -type min_n\n./gen -n 1 -x 100000 -type min_n\n\n# Maximum n (n=50) with random x\n./gen -n 50 -x 500 -type max_n\n./gen -n 50 -x 1 -type max_n\n./gen -n 50 -x 100000 -type max_n\n\n# Minimum x (x=1) with varying n\n./gen -n 10 -x 1 -type min_x\n./gen -n 20 -x 1 -type min_x\n./gen -n 50 -x 1 -type min_x\n\n# Maximum x (x=1e5) with varying n\n./gen -n 10 -x 100000 -type max_x\n./gen -n 20 -x 100000 -type max_x\n./gen -n 50 -x 100000 -type max_x\n\n# Test cases with intervals at the edges of allowed ranges\n./gen -n 5 -x 50 -type edge_intervals\n./gen -n 10 -x 1000 -type edge_intervals\n\n# Test cases with maximum interval lengths\n./gen -n 5 -x 1000 -type max_intervals\n./gen -n 10 -x 1000 -type max_intervals\n\n# Test cases with minimal interval lengths\n./gen -n 5 -x 100 -type small_intervals\n./gen -n 10 -x 1000 -type small_intervals\n\n# Test case covering the full range\n./gen -n 1 -x 1 -type full_coverage\n\n# Test case with a single-point interval\n./gen -n 1 -x 1000 -type single_point\n\n# Random test cases with maximum values\n./gen -n 50 -x 100000 -type random\n./gen -n 50 -x 99999 -type random\n\n# Test cases to check for off-by-one errors\n./gen -n 2 -x 1 -type small_intervals\n./gen -n 3 -x 2 -type small_intervals\n\n# Test cases with overlapping intervals (should not happen due to constraints, but test edge behavior)\n# Since overlapping intervals are not allowed, we simulate near-overlapping intervals\n./gen -n 50 -x 1000 -type edge_intervals\n\n# Test cases with intervals spread throughout the movie\n./gen -n 10 -x 5000 -type random\n./gen -n 20 -x 10000 -type random\n\n# Test case to test large skips\n./gen -n 5 -x 99999 -type random\n\n# Test case where x equals the total length of the movie\n./gen -n 1 -x 100000 -type full_coverage\n\n# Test cases with x being a large prime number\n./gen -n 10 -x 99991 -type random\n\n# Test cases with x being a power of two\n./gen -n 10 -x 16384 -type random\n\n# Test cases with maximum n and maximum x\n./gen -n 50 -x 100000 -type max_n\n\n# Test cases with minimum n and minimum x\n./gen -n 1 -x 1 -type min_n\n\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:39:28.360200",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "499/B",
      "title": "B. Лекция",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест1 секунда",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеВ первой строке записано два целых числа n и m (1 ≤ n ≤ 3000, 1 ≤ m ≤ 3000)— количество слов в лекции преподавателя и количество слов в каждом из языков. В следующих m строках записано описание слов. i-я строка содержит две строки ai, bi. Это означает, что слово ai принадлежит первому языку, слово bi принадлежит второму языку, и эти два слова обозначают одно и то же. Гарантируется, что никакое слово не встречается в обоих языках и каждое слово встречается ровно один раз в своем языке.В следующей строке записано n строк через пробел c1, c2, ..., cn — описание лекции. Гарантируется, что каждая из строк ci принадлежит множеству строк {a1, a2, ... am}.Все строки во входных данных непусты, каждая из них состоит из не более чем 10 маленьких латинских букв.",
      "output_spec": "Выходные данныеВыведите ровно n строк — описание того, как вы запишите лекцию в свою тетрадь. Слова лекции требуется выводить в том же порядке, что и во входных данных.",
      "sample_tests": "ПримерыВходные данныеСкопировать4 3codeforces codesecrofcontest roundletter messagecodeforces contest letter contestВыходные данныеСкопироватьcodeforces round letter roundВходные данныеСкопировать5 3joll wuqrdeuzf unhbnyiyc rsoqqvehhbnyiyc joll joll euzf jollВыходные данныеСкопироватьhbnyiyc joll joll un joll",
      "description": "ограничение по времени на тест1 секунда\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвыводstdout\n\nВходные данныеВ первой строке записано два целых числа n и m (1 ≤ n ≤ 3000, 1 ≤ m ≤ 3000)— количество слов в лекции преподавателя и количество слов в каждом из языков. В следующих m строках записано описание слов. i-я строка содержит две строки ai, bi. Это означает, что слово ai принадлежит первому языку, слово bi принадлежит второму языку, и эти два слова обозначают одно и то же. Гарантируется, что никакое слово не встречается в обоих языках и каждое слово встречается ровно один раз в своем языке.В следующей строке записано n строк через пробел c1, c2, ..., cn — описание лекции. Гарантируется, что каждая из строк ci принадлежит множеству строк {a1, a2, ... am}.Все строки во входных данных непусты, каждая из них состоит из не более чем 10 маленьких латинских букв.\n\nВходные данные\n\nВыходные данныеВыведите ровно n строк — описание того, как вы запишите лекцию в свою тетрадь. Слова лекции требуется выводить в том же порядке, что и во входных данных.\n\nВыходные данные\n\nВходные данныеСкопировать4 3codeforces codesecrofcontest roundletter messagecodeforces contest letter contestВыходные данныеСкопироватьcodeforces round letter roundВходные данныеСкопировать5 3joll wuqrdeuzf unhbnyiyc rsoqqvehhbnyiyc joll joll euzf jollВыходные данныеСкопироватьhbnyiyc joll joll un joll\n\nВходные данныеСкопировать4 3codeforces codesecrofcontest roundletter messagecodeforces contest letter contest\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопироватьcodeforces round letter round\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать5 3joll wuqrdeuzf unhbnyiyc rsoqqvehhbnyiyc joll joll euzf joll\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопироватьhbnyiyc joll joll un joll\n\nВыходные данныеСкопировать\n\nСкопировать",
      "solutions": [
        {
          "title": "Codeforces Round #284 - Codeforces",
          "content": "Скоро состоится очередной раунд Codeforces Round #284, задачи для которого готовили Виталий Гриднев (gridnevvvit), Илья Лось (IlyaLos), Данил Сагунов (danilka.pro).Большое спасибо Максиму Ахмедову (Zlobober) за помощь в подготовке задач, Марии Беловой (Delinur) за переводы на английский, Михаилу Мирзаянову (MikeMirzayanov) за замечательные системы Codeforces и Polygon.Будет использоваться динамическая разбалловка. Задачи расположены в порядке возрастания предполагаемой сложности.Раунд окончен, поздравляем победителей!Div1: yeputons rng_58 Endagorion KADR Egor uwi mmaxio atetubou RAVEman Div2: sorry_dreamoon dreamoon_love_AA dreamoon_fan Разбор задачУдачи!",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/15336",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 663
        },
        {
          "title": "Разбор Codeforces Round #284 - Codeforces",
          "content": "499A - Просмотр фильмаЗадача решается жадным алгоритмом — если мы на текущем моменте времени можем пропустить x минут, не пропустив при этом ни одного хорошего момента, то мы пропускаем x минут, в противном случае — смотрим очередную минуту фильма.499B - ЛекцияВ задаче требовалось для каждой строки из текста искать, в какой паре она находится, и из двух строк этой пары выводить меньшую по длине.498A - Сумасшедший город / 499C - Сумасшедший городНесложно показать, что, если две исходные точки изначально находятся по разные стороны какой-то из прямых, эту прямую в любом случае придется пересечь. Поскольку все, что нам нужно — это пересечь все такие прямые, ответ на задачу — их количество.Чтобы проверить, лежат ли точки по разные стороны прямой, достаточно подставить их координаты в ее уравнение, и проверить, что получившиеся два значения имеют разные знаки.Итоговая сложность решения — O(n).498B - Музыкальная пауза / 499D - Музыкальная паузаДля удобства будем нумеровать песни с нуля.Задачу будем решать методом динамического программирования. Состояние динамики будем описывать парой чисел i и j: dp[i][j] — вероятность того, что мы угадали ровно i песен, угадав последнюю из них ровно перед началом j-ой секунды (то есть Петя еще не включал следующую (i-ую) песню). База динамики, очевидно, dp[0][0] = 1.Чтобы из состояния (i, j) сделать переход в состояние (i + 1, j + k) (1 ≤ k < ti), нужно угадать i-ую песню ровно после k-ой секунды воспроизведения, не угадывая ее до этого — вероятность такого перехода равна (1 - pi)k - 1·pi. Для фиксированного состояния (i + 1, j) сумму таких переходов можно записать в виде суммы . Простое вычисление такой суммы для каждого состояния займет O(nT2) времени, поэтому нужно заметить, что при фиксированном i такую сумму можно поддерживать двумя указателями (в общем случае они задают отрезок длиной ti) для каждого j за O(T) времени. Таким образом, подсчет переходов такого типа займет O(nT) времени.Переход в (i + 1, j + ti) следует рассмотреть отдельно. Также существует и вариант не успеть угадать песню в отведенное время — это переход из (i, j) в (i, (j + k) = T). Переходы этих двух типов считаются за O(nT).Итоговая сложность решения — O(nT).498C - Массив и операции / 499E - Массив и операцииПрежде всего заметим, что делить на составные числа невыгодно.Теперь построим граф, где каждому числу соответствует некоторая группа вершин:Разложим каждое число на простые делители. Каждому из простых делителей будет соответствовать некоторая вершина в графе, при этом, если число p входит в i-ое число в степени ai, то ему будет соответствовать ровно ai вершин в группе i-го числа.Количество вершин в таком графе будет составлять .Теперь будем проводить ребра в получившемся графе: ребро между двумя вершинами будет существовать тогда и только тогда, когда числа, соответствующие группам эти вершин, находятся в некоторой хорошей паре, а простые, соответствующие этим вершинам, равны. Проще говоря, каждое такое ребро означает, что мы можем поделить числа, соответствующие группам вершин, на соответствующее вершинам простое.Ребер при таком построении будет .Пары заданы так, что полученный граф — двудольный. Найдя наибольшее паросочетание в полученном графе, мы однозначно получим наилучший способ выполнения операций в массиве.Итоговая асимптотика решения, использующего алгоритм Куна . Можно также заметить, что некоторые ребра лишние, и свести эту оценку к .498D - Пробки в странеРешение задачи — 60 (НОК чисел от 2 до 6) деревьев отрезков.В v-ом дереве отрезков будем поддерживать для каждого отрезка [l, r] следующую величину: минимальное количество времени, необходимое, чтобы добраться от l до r, если мы начинаем в момент времени, равный v по модулю 60. Используя значения этих деревьев, несложно быстро отвечать на запросы, аккуратно изменяя деревья.498E - Палочки и лесенкиЗадача решается динамикой dp[i][mask] — количество способов покрасить первые i ступеней лестницы так, что последний уровень вертикальных палочек соответствует маске mask. Ее значения несложно пересчитывать, если знать матрицу M[mask1][mask2] — количество способов покрасить горизонтальные палочки между двумя соседними слоями вертикальных палочек, закрашенных соответственно маскам mask1 и mask2. Поскольку вертикальных слоев для фиксированного i ровно wi, то эту матрицу нужно возвести в степень, равную этому числу. После этого матрица очень просто используется для выполнения переходов динамики (подробнее в авторском решении).Итоговая сложность решения —",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/15353",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 499\\s*B"
          },
          "content_length": 4498
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #284 - Codeforces - Code 1",
          "code": "while(true) System.out.println(\"NOOOOOOOOOOOOOOOOOOOO\");",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15336",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #284 - Codeforces - Code 2",
          "code": "6 6\n2 2 2 2 2 2\n1 2\n1 3\n2 3\n4 5\n4 6\n5 6",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15336",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #284 - Codeforces - Code 3",
          "code": "6 6\n2 2 2 2 2 2\n1 2\n1 3\n2 3\n4 5\n4 6\n5 6",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15336",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #284 - Codeforces - Code 1",
          "code": "for (int i = 0; i <= t; ++i) {\n    dp[i] = dp1[i]; sum += dp[i]; }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15353",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #284 - Codeforces - Code 2",
          "code": "for (int i = 0; i <= t; ++i) {\n    dp[i] = dp1[i]; sum += dp[i]; }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15353",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #284 - Codeforces - Code 3",
          "code": "double *ptr, *ptr1, *tptr;\nptr = dp;\nptr1 = dp1;\n\nfor (int i = 1; i < n; ++i) {\n    // Something to do...\n\n    tptr = ptr;\n    ptr = ptr1;\n    ptr1 = tptr;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15353",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #284 - Codeforces - Code 4",
          "code": "double *ptr, *ptr1, *tptr;\nptr = dp;\nptr1 = dp1;\n\nfor (int i = 1; i < n; ++i) {\n    // Something to do...\n\n    tptr = ptr;\n    ptr = ptr1;\n    ptr1 = tptr;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15353",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #284 - Codeforces - Code 5",
          "code": "double DP(int idx, int sec) {\n    if (sec > t)\n        return idx - 1;\n    if (sec == t or idx == n)\n        return idx;\n    double &ret = memo[idx][sec], tmp = 1;\n    if (ret == ret)\n        return ret;\n    ret = 0;\n    for (int i =1 ; i < ti[idx]; ++i) {\n        double &tret = memo[idx + 1][sec + i];\n        if (tret != tret)\n            tret = DP(idx + 1, sec + i);\n        ret += pi[idx] * tmp * tret;\n        tmp *= 1 - pi[idx];\n    }\n    return (ret += tmp * DP(idx + 1, sec + ti[idx]));\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15353",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #284 - Codeforces - Code 6",
          "code": "double DP(int idx, int sec) {\n    if (sec > t)\n        return idx - 1;\n    if (sec == t or idx == n)\n        return idx;\n    double &ret = memo[idx][sec], tmp = 1;\n    if (ret == ret)\n        return ret;\n    ret = 0;\n    for (int i =1 ; i < ti[idx]; ++i) {\n        double &tret = memo[idx + 1][sec + i];\n        if (tret != tret)\n            tret = DP(idx + 1, sec + i);\n        ret += pi[idx] * tmp * tret;\n        tmp *= 1 - pi[idx];\n    }\n    return (ret += tmp * DP(idx + 1, sec + ti[idx]));\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15353",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #284 - Codeforces - Code 7",
          "code": "3 3\n50 3\n50 2\n25 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15353",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #284 - Codeforces - Code 8",
          "code": "3 3\n50 3\n50 2\n25 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15353",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #284 - Codeforces - Code 9",
          "code": "2 5\n3 8\n13 13",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15353",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #284 - Codeforces - Code 10",
          "code": "2 5\n3 8\n13 13",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15353",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 3000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 3000, \"m\");\n    inf.readEoln();\n\n    set<string> lang1_words;\n    set<string> lang2_words;\n\n    for (int i = 0; i < m; ++i) {\n        string ai = inf.readToken(\"[a-z]{1,10}\", \"ai\");\n        inf.readSpace();\n        string bi = inf.readToken(\"[a-z]{1,10}\", \"bi\");\n        inf.readEoln();\n\n        ensuref(ai != bi, \"Word \\\"%s\\\" occurs in both languages\", ai.c_str());\n\n        ensuref(lang1_words.find(ai) == lang1_words.end(), \"Word \\\"%s\\\" occurs more than once in language 1\", ai.c_str());\n        lang1_words.insert(ai);\n\n        ensuref(lang2_words.find(bi) == lang2_words.end(), \"Word \\\"%s\\\" occurs more than once in language 2\", bi.c_str());\n        lang2_words.insert(bi);\n\n        ensuref(lang2_words.find(ai) == lang2_words.end(), \"Word \\\"%s\\\" occurs in both languages\", ai.c_str());\n        ensuref(lang1_words.find(bi) == lang1_words.end(), \"Word \\\"%s\\\" occurs in both languages\", bi.c_str());\n    }\n\n    vector<string> c = inf.readTokens(n, \"[a-z]{1,10}\", \"c\");\n    inf.readEoln();\n\n    for (int i = 0; i < n; ++i) {\n        ensuref(lang1_words.find(c[i]) != lang1_words.end(), \"Word \\\"%s\\\" is not in the first language\", c[i].c_str());\n    }\n\n    inf.readEof();\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 3000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 3000, \"m\");\n    inf.readEoln();\n\n    set<string> lang1_words;\n    set<string> lang2_words;\n\n    for (int i = 0; i < m; ++i) {\n        string ai = inf.readToken(\"[a-z]{1,10}\", \"ai\");\n        inf.readSpace();\n        string bi = inf.readToken(\"[a-z]{1,10}\", \"bi\");\n        inf.readEoln();\n\n        ensuref(ai != bi, \"Word \\\"%s\\\" occurs in both languages\", ai.c_str());\n\n        ensuref(lang1_words.find(ai) == lang1_words.end(), \"Word \\\"%s\\\" occurs more than once in language 1\", ai.c_str());\n        lang1_words.insert(ai);\n\n        ensuref(lang2_words.find(bi) == lang2_words.end(), \"Word \\\"%s\\\" occurs more than once in language 2\", bi.c_str());\n        lang2_words.insert(bi);\n\n        ensuref(lang2_words.find(ai) == lang2_words.end(), \"Word \\\"%s\\\" occurs in both languages\", ai.c_str());\n        ensuref(lang1_words.find(bi) == lang1_words.end(), \"Word \\\"%s\\\" occurs in both languages\", bi.c_str());\n    }\n\n    vector<string> c = inf.readTokens(n, \"[a-z]{1,10}\", \"c\");\n    inf.readEoln();\n\n    for (int i = 0; i < n; ++i) {\n        ensuref(lang1_words.find(c[i]) != lang1_words.end(), \"Word \\\"%s\\\" is not in the first language\", c[i].c_str());\n    }\n\n    inf.readEof();\n\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 3000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 3000, \"m\");\n    inf.readEoln();\n\n    set<string> lang1_words;\n    set<string> lang2_words;\n\n    for (int i = 0; i < m; ++i) {\n        string ai = inf.readToken(\"[a-z]{1,10}\", \"ai\");\n        inf.readSpace();\n        string bi = inf.readToken(\"[a-z]{1,10}\", \"bi\");\n        inf.readEoln();\n\n        ensuref(ai != bi, \"Word \\\"%s\\\" occurs in both languages\", ai.c_str());\n\n        ensuref(lang1_words.find(ai) == lang1_words.end(), \"Word \\\"%s\\\" occurs more than once in language 1\", ai.c_str());\n        lang1_words.insert(ai);\n\n        ensuref(lang2_words.find(bi) == lang2_words.end(), \"Word \\\"%s\\\" occurs more than once in language 2\", bi.c_str());\n        lang2_words.insert(bi);\n\n        ensuref(lang2_words.find(ai) == lang2_words.end(), \"Word \\\"%s\\\" occurs in both languages\", ai.c_str());\n        ensuref(lang1_words.find(bi) == lang1_words.end(), \"Word \\\"%s\\\" occurs in both languages\", bi.c_str());\n    }\n\n    vector<string> c = inf.readTokens(n, \"[a-z]{1,10}\", \"c\");\n    inf.readEoln();\n\n    for (int i = 0; i < n; ++i) {\n        ensuref(lang1_words.find(c[i]) != lang1_words.end(), \"Word \\\"%s\\\" is not in the first language\", c[i].c_str());\n    }\n\n    inf.readEof();\n\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare sequences of tokens\");\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string j, p;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n\r\n        ans.readWordTo(j);\r\n        ouf.readWordTo(p);\r\n\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s words differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  compress(j).c_str(), compress(p).c_str());\r\n    }\r\n\r\n    if (ans.seekEof() && ouf.seekEof()) {\r\n        if (n == 1)\r\n            quitf(_ok, \"\\\"%s\\\"\", compress(j).c_str());\r\n        else\r\n            quitf(_ok, \"%d tokens\", n);\r\n    } else {\r\n        if (ans.seekEof())\r\n            quitf(_wa, \"Participant output contains extra tokens\");\r\n        else\r\n            quitf(_wa, \"Unexpected EOF in the participants output\");\r\n    }\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nstring random_word(int min_len, int max_len) {\n    int len = rnd.next(min_len, max_len);\n    string s;\n    for(int i = 0; i < len; i++) {\n        char c = 'a' + rnd.next(26);\n        s += c;\n    }\n    return s;\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string type = opt<string>(\"type\", \"random\");\n\n    ensure(1 <= n && n <= 3000);\n    ensure(1 <= m && m <= 3000);\n    ensure(m >= n);\n\n    set<string> ai_set;\n    set<string> bi_set;\n\n    vector<string> ai(m);\n    vector<string> bi(m);\n    vector<string> ci(n);\n\n    if (type == \"random\") {\n        for(int i = 0; i < m; ++i) {\n            string s;\n            do {\n                s = random_word(1, 10);\n            } while(ai_set.count(s));\n            ai_set.insert(s);\n            ai[i] = s;\n        }\n\n        for(int i = 0; i < m; ++i) {\n            string s;\n            do {\n                s = random_word(1, 10);\n            } while(ai_set.count(s) || bi_set.count(s));\n            bi_set.insert(s);\n            bi[i] = s;\n        }\n\n        for(int i = 0; i < n; ++i) {\n            ci[i] = ai[rnd.next(0, m - 1)];\n        }\n\n    } else if (type == \"equal_length\") {\n        int len = rnd.next(1, 10);\n        for(int i = 0; i < m; ++i) {\n            string s;\n            do {\n                s = random_word(len, len);\n            } while(ai_set.count(s));\n            ai_set.insert(s);\n            ai[i] = s;\n        }\n\n        for(int i = 0; i < m; ++i) {\n            string s;\n            do {\n                s = random_word(len, len);\n            } while(ai_set.count(s) || bi_set.count(s));\n            bi_set.insert(s);\n            bi[i] = s;\n        }\n\n        for(int i = 0; i < n; ++i) {\n            ci[i] = ai[rnd.next(0, m - 1)];\n        }\n    } else if (type == \"ai_shorter\") {\n        for(int i = 0; i < m; ++i) {\n            int len_ai = rnd.next(1, 9);\n            int len_bi = rnd.next(len_ai + 1, 10);\n\n            string s;\n            do {\n                s = random_word(len_ai, len_ai);\n            } while(ai_set.count(s));\n            ai_set.insert(s);\n            ai[i] = s;\n\n            do {\n                s = random_word(len_bi, len_bi);\n            } while(ai_set.count(s) || bi_set.count(s));\n            bi_set.insert(s);\n            bi[i] = s;\n        }\n\n        for(int i = 0; i < n; ++i) {\n            ci[i] = ai[rnd.next(0, m - 1)];\n        }\n    } else if (type == \"bi_shorter\") {\n        for(int i = 0; i < m; ++i) {\n            int len_bi = rnd.next(1, 9);\n            int len_ai = rnd.next(len_bi + 1, 10);\n\n            string s;\n            do {\n                s = random_word(len_ai, len_ai);\n            } while(ai_set.count(s));\n            ai_set.insert(s);\n            ai[i] = s;\n\n            do {\n                s = random_word(len_bi, len_bi);\n            } while(ai_set.count(s) || bi_set.count(s));\n            bi_set.insert(s);\n            bi[i] = s;\n        }\n\n        for(int i = 0; i < n; ++i) {\n            ci[i] = ai[rnd.next(0, m - 1)];\n        }\n    } else if (type == \"max_length\") {\n        int len_ai = 10;\n        int len_bi = 10;\n        for(int i = 0; i < m; ++i) {\n            string s;\n            do {\n                s = random_word(len_ai, len_ai);\n            } while(ai_set.count(s));\n            ai_set.insert(s);\n            ai[i] = s;\n        }\n        for(int i = 0; i < m; ++i) {\n            string s;\n            do {\n                s = random_word(len_bi, len_bi);\n            } while(ai_set.count(s) || bi_set.count(s));\n            bi_set.insert(s);\n            bi[i] = s;\n        }\n        for(int i = 0; i < n; ++i) {\n            ci[i] = ai[rnd.next(0, m - 1)];\n        }\n    } else if (type == \"min_length\") {\n        int len_ai = 1;\n        int len_bi = 1;\n        for(int i = 0; i < m; ++i) {\n            string s;\n            do {\n                s = random_word(len_ai, len_ai);\n            } while(ai_set.count(s));\n            ai_set.insert(s);\n            ai[i] = s;\n        }\n        for(int i = 0; i < m; ++i) {\n            string s;\n            do {\n                s = random_word(len_bi, len_bi);\n            } while(ai_set.count(s) || bi_set.count(s));\n            bi_set.insert(s);\n            bi[i] = s;\n        }\n        for(int i = 0; i < n; ++i) {\n            ci[i] = ai[rnd.next(0, m - 1)];\n        }\n    } else if (type == \"repeated_words\") {\n        for(int i = 0; i < m; ++i) {\n            string s;\n            do {\n                s = random_word(1, 10);\n            } while(ai_set.count(s));\n            ai_set.insert(s);\n            ai[i] = s;\n        }\n        for(int i = 0; i < m; ++i) {\n            string s;\n            do {\n                s = random_word(1, 10);\n            } while(ai_set.count(s) || bi_set.count(s));\n            bi_set.insert(s);\n            bi[i] = s;\n        }\n\n        string repeated_word = ai[rnd.next(0, m -1)];\n\n        for(int i = 0; i < n; ++i) {\n            ci[i] = repeated_word;\n        }\n    } else if (type == \"distinct_words\") {\n        ensure(n <= m);\n\n        for(int i = 0; i < m; ++i) {\n            string s;\n            do {\n                s = random_word(1, 10);\n            } while(ai_set.count(s));\n            ai_set.insert(s);\n            ai[i] = s;\n        }\n\n        for(int i = 0; i < m; ++i) {\n            string s;\n            do {\n                s = random_word(1, 10);\n            } while(ai_set.count(s) || bi_set.count(s));\n            bi_set.insert(s);\n            bi[i] = s;\n        }\n\n        vector<int> idx(m);\n        for(int i = 0; i < m; ++i)\n            idx[i] = i;\n\n        shuffle(idx.begin(), idx.end());\n\n        for(int i = 0; i < n; ++i) {\n            ci[i] = ai[idx[i]];\n        }\n    } else {\n        ensuref(0, \"Unknown type: %s\", type.c_str());\n    }\n\n    printf(\"%d %d\\n\", n, m);\n\n    for(int i = 0; i < m; ++i) {\n        printf(\"%s %s\\n\", ai[i].c_str(), bi[i].c_str());\n    }\n\n    for(int i = 0; i < n; ++i) {\n        printf(\"%s%c\", ci[i].c_str(), (i + 1 == n ? '\\n' : ' '));\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nstring random_word(int min_len, int max_len) {\n    int len = rnd.next(min_len, max_len);\n    string s;\n    for(int i = 0; i < len; i++) {\n        char c = 'a' + rnd.next(26);\n        s += c;\n    }\n    return s;\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string type = opt<string>(\"type\", \"random\");\n\n    ensure(1 <= n && n <= 3000);\n    ensure(1 <= m && m <= 3000);\n    ensure(m >= n);\n\n    set<string> ai_set;\n    set<string> bi_set;\n\n    vector<string> ai(m);\n    vector<string> bi(m);\n    vector<string> ci(n);\n\n    if (type == \"random\") {\n        for(int i = 0; i < m; ++i) {\n            string s;\n            do {\n                s = random_word(1, 10);\n            } while(ai_set.count(s));\n            ai_set.insert(s);\n            ai[i] = s;\n        }\n\n        for(int i = 0; i < m; ++i) {\n            string s;\n            do {\n                s = random_word(1, 10);\n            } while(ai_set.count(s) || bi_set.count(s));\n            bi_set.insert(s);\n            bi[i] = s;\n        }\n\n        for(int i = 0; i < n; ++i) {\n            ci[i] = ai[rnd.next(0, m - 1)];\n        }\n\n    } else if (type == \"equal_length\") {\n        int len = rnd.next(1, 10);\n        for(int i = 0; i < m; ++i) {\n            string s;\n            do {\n                s = random_word(len, len);\n            } while(ai_set.count(s));\n            ai_set.insert(s);\n            ai[i] = s;\n        }\n\n        for(int i = 0; i < m; ++i) {\n            string s;\n            do {\n                s = random_word(len, len);\n            } while(ai_set.count(s) || bi_set.count(s));\n            bi_set.insert(s);\n            bi[i] = s;\n        }\n\n        for(int i = 0; i < n; ++i) {\n            ci[i] = ai[rnd.next(0, m - 1)];\n        }\n    } else if (type == \"ai_shorter\") {\n        for(int i = 0; i < m; ++i) {\n            int len_ai = rnd.next(1, 9);\n            int len_bi = rnd.next(len_ai + 1, 10);\n\n            string s;\n            do {\n                s = random_word(len_ai, len_ai);\n            } while(ai_set.count(s));\n            ai_set.insert(s);\n            ai[i] = s;\n\n            do {\n                s = random_word(len_bi, len_bi);\n            } while(ai_set.count(s) || bi_set.count(s));\n            bi_set.insert(s);\n            bi[i] = s;\n        }\n\n        for(int i = 0; i < n; ++i) {\n            ci[i] = ai[rnd.next(0, m - 1)];\n        }\n    } else if (type == \"bi_shorter\") {\n        for(int i = 0; i < m; ++i) {\n            int len_bi = rnd.next(1, 9);\n            int len_ai = rnd.next(len_bi + 1, 10);\n\n            string s;\n            do {\n                s = random_word(len_ai, len_ai);\n            } while(ai_set.count(s));\n            ai_set.insert(s);\n            ai[i] = s;\n\n            do {\n                s = random_word(len_bi, len_bi);\n            } while(ai_set.count(s) || bi_set.count(s));\n            bi_set.insert(s);\n            bi[i] = s;\n        }\n\n        for(int i = 0; i < n; ++i) {\n            ci[i] = ai[rnd.next(0, m - 1)];\n        }\n    } else if (type == \"max_length\") {\n        int len_ai = 10;\n        int len_bi = 10;\n        for(int i = 0; i < m; ++i) {\n            string s;\n            do {\n                s = random_word(len_ai, len_ai);\n            } while(ai_set.count(s));\n            ai_set.insert(s);\n            ai[i] = s;\n        }\n        for(int i = 0; i < m; ++i) {\n            string s;\n            do {\n                s = random_word(len_bi, len_bi);\n            } while(ai_set.count(s) || bi_set.count(s));\n            bi_set.insert(s);\n            bi[i] = s;\n        }\n        for(int i = 0; i < n; ++i) {\n            ci[i] = ai[rnd.next(0, m - 1)];\n        }\n    } else if (type == \"min_length\") {\n        int len_ai = 1;\n        int len_bi = 1;\n        for(int i = 0; i < m; ++i) {\n            string s;\n            do {\n                s = random_word(len_ai, len_ai);\n            } while(ai_set.count(s));\n            ai_set.insert(s);\n            ai[i] = s;\n        }\n        for(int i = 0; i < m; ++i) {\n            string s;\n            do {\n                s = random_word(len_bi, len_bi);\n            } while(ai_set.count(s) || bi_set.count(s));\n            bi_set.insert(s);\n            bi[i] = s;\n        }\n        for(int i = 0; i < n; ++i) {\n            ci[i] = ai[rnd.next(0, m - 1)];\n        }\n    } else if (type == \"repeated_words\") {\n        for(int i = 0; i < m; ++i) {\n            string s;\n            do {\n                s = random_word(1, 10);\n            } while(ai_set.count(s));\n            ai_set.insert(s);\n            ai[i] = s;\n        }\n        for(int i = 0; i < m; ++i) {\n            string s;\n            do {\n                s = random_word(1, 10);\n            } while(ai_set.count(s) || bi_set.count(s));\n            bi_set.insert(s);\n            bi[i] = s;\n        }\n\n        string repeated_word = ai[rnd.next(0, m -1)];\n\n        for(int i = 0; i < n; ++i) {\n            ci[i] = repeated_word;\n        }\n    } else if (type == \"distinct_words\") {\n        ensure(n <= m);\n\n        for(int i = 0; i < m; ++i) {\n            string s;\n            do {\n                s = random_word(1, 10);\n            } while(ai_set.count(s));\n            ai_set.insert(s);\n            ai[i] = s;\n        }\n\n        for(int i = 0; i < m; ++i) {\n            string s;\n            do {\n                s = random_word(1, 10);\n            } while(ai_set.count(s) || bi_set.count(s));\n            bi_set.insert(s);\n            bi[i] = s;\n        }\n\n        vector<int> idx(m);\n        for(int i = 0; i < m; ++i)\n            idx[i] = i;\n\n        shuffle(idx.begin(), idx.end());\n\n        for(int i = 0; i < n; ++i) {\n            ci[i] = ai[idx[i]];\n        }\n    } else {\n        ensuref(0, \"Unknown type: %s\", type.c_str());\n    }\n\n    printf(\"%d %d\\n\", n, m);\n\n    for(int i = 0; i < m; ++i) {\n        printf(\"%s %s\\n\", ai[i].c_str(), bi[i].c_str());\n    }\n\n    for(int i = 0; i < n; ++i) {\n        printf(\"%s%c\", ci[i].c_str(), (i + 1 == n ? '\\n' : ' '));\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -m 1 -type random\n./gen -n 1 -m 1 -type equal_length\n./gen -n 1 -m 1 -type ai_shorter\n./gen -n 1 -m 1 -type bi_shorter\n./gen -n 1 -m 1 -type max_length\n./gen -n 1 -m 1 -type min_length\n\n./gen -n 1 -m 10 -type random\n./gen -n 1 -m 10 -type equal_length\n\n./gen -n 10 -m 10 -type random\n./gen -n 10 -m 10 -type repeated_words\n\n./gen -n 10 -m 3000 -type random\n./gen -n 50 -m 3000 -type random\n\n./gen -n 100 -m 3000 -type ai_shorter\n./gen -n 100 -m 3000 -type bi_shorter\n\n./gen -n 3000 -m 3000 -type random\n./gen -n 3000 -m 3000 -type ai_shorter\n./gen -n 3000 -m 3000 -type bi_shorter\n./gen -n 3000 -m 3000 -type equal_length\n\n./gen -n 3000 -m 3000 -type max_length\n./gen -n 3000 -m 3000 -type min_length\n\n./gen -n 3000 -m 3000 -type repeated_words\n./gen -n 3000 -m 3000 -type distinct_words\n\n./gen -n 1000 -m 2000 -type random\n./gen -n 1000 -m 2000 -type repeated_words\n./gen -n 1000 -m 2000 -type distinct_words\n\n./gen -n 500 -m 500 -type max_length\n./gen -n 500 -m 500 -type min_length\n\n./gen -n 3000 -m 3000 -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:39:30.301905",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "499/C",
      "title": "C. Сумасшедший город",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест1 секунда",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеВ первой строке записано два целых чисел через пробел x1, y1 ( - 106 ≤ x1, y1 ≤ 106) — координаты вашего дома.Во второй строке записано два целых числа через пробел x2, y2 ( - 106 ≤ x2, y2 ≤ 106) — координаты университета, где вы учитесь.В третьей строке записано целое число n (1 ≤ n ≤ 300) — количество дорог в городе. В следующих n строках записаны через пробел по 3 целых числа ( - 106 ≤ ai, bi, ci ≤ 106; |ai| + |bi| > 0) — коэффициенты прямой aix + biy + ci = 0, задающей i-ю дорогу. Гарантируется, что никакие две дороги не совпадают. Кроме этого, ни ваш дом, ни университет не лежат на дороге (т. е. не принадлежат ни одной из прямых).",
      "output_spec": "Выходные данныеВ единственной строке выведите одно целое число — ответ на задачу.",
      "sample_tests": "ПримерыВходные данныеСкопировать1 1-1 -120 1 01 0 0Выходные данныеСкопировать2Входные данныеСкопировать1 1-1 -131 0 00 1 01 1 -3Выходные данныеСкопировать2",
      "description": "C. Сумасшедший город\n\nограничение по времени на тест1 секунда\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвыводstdout\n\nВходные данныеВ первой строке записано два целых чисел через пробел x1, y1 ( - 106 ≤ x1, y1 ≤ 106) — координаты вашего дома.Во второй строке записано два целых числа через пробел x2, y2 ( - 106 ≤ x2, y2 ≤ 106) — координаты университета, где вы учитесь.В третьей строке записано целое число n (1 ≤ n ≤ 300) — количество дорог в городе. В следующих n строках записаны через пробел по 3 целых числа ( - 106 ≤ ai, bi, ci ≤ 106; |ai| + |bi| > 0) — коэффициенты прямой aix + biy + ci = 0, задающей i-ю дорогу. Гарантируется, что никакие две дороги не совпадают. Кроме этого, ни ваш дом, ни университет не лежат на дороге (т. е. не принадлежат ни одной из прямых).\n\nВходные данные\n\nВыходные данныеВ единственной строке выведите одно целое число — ответ на задачу.\n\nВыходные данные\n\nВходные данныеСкопировать1 1-1 -120 1 01 0 0Выходные данныеСкопировать2Входные данныеСкопировать1 1-1 -131 0 00 1 01 1 -3Выходные данныеСкопировать2\n\nВходные данныеСкопировать1 1-1 -120 1 01 0 0\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать2\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать1 1-1 -131 0 00 1 01 1 -3\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать2\n\nВыходные данныеСкопировать\n\nСкопировать\n\nПримечаниеРисунки к примерам представлены ниже (A — точка, соответствующая дому; B — точка, соответсвующая университету; разными цветами обозначены области, соответствующие разным кварталам):",
      "solutions": [
        {
          "title": "Codeforces Round #284 - Codeforces",
          "content": "Скоро состоится очередной раунд Codeforces Round #284, задачи для которого готовили Виталий Гриднев (gridnevvvit), Илья Лось (IlyaLos), Данил Сагунов (danilka.pro).Большое спасибо Максиму Ахмедову (Zlobober) за помощь в подготовке задач, Марии Беловой (Delinur) за переводы на английский, Михаилу Мирзаянову (MikeMirzayanov) за замечательные системы Codeforces и Polygon.Будет использоваться динамическая разбалловка. Задачи расположены в порядке возрастания предполагаемой сложности.Раунд окончен, поздравляем победителей!Div1: yeputons rng_58 Endagorion KADR Egor uwi mmaxio atetubou RAVEman Div2: sorry_dreamoon dreamoon_love_AA dreamoon_fan Разбор задачУдачи!",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/15336",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 663
        },
        {
          "title": "Разбор Codeforces Round #284 - Codeforces",
          "content": "499A - Просмотр фильмаЗадача решается жадным алгоритмом — если мы на текущем моменте времени можем пропустить x минут, не пропустив при этом ни одного хорошего момента, то мы пропускаем x минут, в противном случае — смотрим очередную минуту фильма.499B - ЛекцияВ задаче требовалось для каждой строки из текста искать, в какой паре она находится, и из двух строк этой пары выводить меньшую по длине.498A - Сумасшедший город / 499C - Сумасшедший городНесложно показать, что, если две исходные точки изначально находятся по разные стороны какой-то из прямых, эту прямую в любом случае придется пересечь. Поскольку все, что нам нужно — это пересечь все такие прямые, ответ на задачу — их количество.Чтобы проверить, лежат ли точки по разные стороны прямой, достаточно подставить их координаты в ее уравнение, и проверить, что получившиеся два значения имеют разные знаки.Итоговая сложность решения — O(n).498B - Музыкальная пауза / 499D - Музыкальная паузаДля удобства будем нумеровать песни с нуля.Задачу будем решать методом динамического программирования. Состояние динамики будем описывать парой чисел i и j: dp[i][j] — вероятность того, что мы угадали ровно i песен, угадав последнюю из них ровно перед началом j-ой секунды (то есть Петя еще не включал следующую (i-ую) песню). База динамики, очевидно, dp[0][0] = 1.Чтобы из состояния (i, j) сделать переход в состояние (i + 1, j + k) (1 ≤ k < ti), нужно угадать i-ую песню ровно после k-ой секунды воспроизведения, не угадывая ее до этого — вероятность такого перехода равна (1 - pi)k - 1·pi. Для фиксированного состояния (i + 1, j) сумму таких переходов можно записать в виде суммы . Простое вычисление такой суммы для каждого состояния займет O(nT2) времени, поэтому нужно заметить, что при фиксированном i такую сумму можно поддерживать двумя указателями (в общем случае они задают отрезок длиной ti) для каждого j за O(T) времени. Таким образом, подсчет переходов такого типа займет O(nT) времени.Переход в (i + 1, j + ti) следует рассмотреть отдельно. Также существует и вариант не успеть угадать песню в отведенное время — это переход из (i, j) в (i, (j + k) = T). Переходы этих двух типов считаются за O(nT).Итоговая сложность решения — O(nT).498C - Массив и операции / 499E - Массив и операцииПрежде всего заметим, что делить на составные числа невыгодно.Теперь построим граф, где каждому числу соответствует некоторая группа вершин:Разложим каждое число на простые делители. Каждому из простых делителей будет соответствовать некоторая вершина в графе, при этом, если число p входит в i-ое число в степени ai, то ему будет соответствовать ровно ai вершин в группе i-го числа.Количество вершин в таком графе будет составлять .Теперь будем проводить ребра в получившемся графе: ребро между двумя вершинами будет существовать тогда и только тогда, когда числа, соответствующие группам эти вершин, находятся в некоторой хорошей паре, а простые, соответствующие этим вершинам, равны. Проще говоря, каждое такое ребро означает, что мы можем поделить числа, соответствующие группам вершин, на соответствующее вершинам простое.Ребер при таком построении будет .Пары заданы так, что полученный граф — двудольный. Найдя наибольшее паросочетание в полученном графе, мы однозначно получим наилучший способ выполнения операций в массиве.Итоговая асимптотика решения, использующего алгоритм Куна . Можно также заметить, что некоторые ребра лишние, и свести эту оценку к .498D - Пробки в странеРешение задачи — 60 (НОК чисел от 2 до 6) деревьев отрезков.В v-ом дереве отрезков будем поддерживать для каждого отрезка [l, r] следующую величину: минимальное количество времени, необходимое, чтобы добраться от l до r, если мы начинаем в момент времени, равный v по модулю 60. Используя значения этих деревьев, несложно быстро отвечать на запросы, аккуратно изменяя деревья.498E - Палочки и лесенкиЗадача решается динамикой dp[i][mask] — количество способов покрасить первые i ступеней лестницы так, что последний уровень вертикальных палочек соответствует маске mask. Ее значения несложно пересчитывать, если знать матрицу M[mask1][mask2] — количество способов покрасить горизонтальные палочки между двумя соседними слоями вертикальных палочек, закрашенных соответственно маскам mask1 и mask2. Поскольку вертикальных слоев для фиксированного i ровно wi, то эту матрицу нужно возвести в степень, равную этому числу. После этого матрица очень просто используется для выполнения переходов динамики (подробнее в авторском решении).Итоговая сложность решения —",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/15353",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 499\\s*C"
          },
          "content_length": 4498
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #284 - Codeforces - Code 1",
          "code": "while(true) System.out.println(\"NOOOOOOOOOOOOOOOOOOOO\");",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15336",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #284 - Codeforces - Code 2",
          "code": "6 6\n2 2 2 2 2 2\n1 2\n1 3\n2 3\n4 5\n4 6\n5 6",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15336",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #284 - Codeforces - Code 3",
          "code": "6 6\n2 2 2 2 2 2\n1 2\n1 3\n2 3\n4 5\n4 6\n5 6",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15336",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #284 - Codeforces - Code 1",
          "code": "for (int i = 0; i <= t; ++i) {\n    dp[i] = dp1[i]; sum += dp[i]; }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15353",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #284 - Codeforces - Code 2",
          "code": "for (int i = 0; i <= t; ++i) {\n    dp[i] = dp1[i]; sum += dp[i]; }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15353",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #284 - Codeforces - Code 3",
          "code": "double *ptr, *ptr1, *tptr;\nptr = dp;\nptr1 = dp1;\n\nfor (int i = 1; i < n; ++i) {\n    // Something to do...\n\n    tptr = ptr;\n    ptr = ptr1;\n    ptr1 = tptr;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15353",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #284 - Codeforces - Code 4",
          "code": "double *ptr, *ptr1, *tptr;\nptr = dp;\nptr1 = dp1;\n\nfor (int i = 1; i < n; ++i) {\n    // Something to do...\n\n    tptr = ptr;\n    ptr = ptr1;\n    ptr1 = tptr;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15353",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #284 - Codeforces - Code 5",
          "code": "double DP(int idx, int sec) {\n    if (sec > t)\n        return idx - 1;\n    if (sec == t or idx == n)\n        return idx;\n    double &ret = memo[idx][sec], tmp = 1;\n    if (ret == ret)\n        return ret;\n    ret = 0;\n    for (int i =1 ; i < ti[idx]; ++i) {\n        double &tret = memo[idx + 1][sec + i];\n        if (tret != tret)\n            tret = DP(idx + 1, sec + i);\n        ret += pi[idx] * tmp * tret;\n        tmp *= 1 - pi[idx];\n    }\n    return (ret += tmp * DP(idx + 1, sec + ti[idx]));\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15353",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #284 - Codeforces - Code 6",
          "code": "double DP(int idx, int sec) {\n    if (sec > t)\n        return idx - 1;\n    if (sec == t or idx == n)\n        return idx;\n    double &ret = memo[idx][sec], tmp = 1;\n    if (ret == ret)\n        return ret;\n    ret = 0;\n    for (int i =1 ; i < ti[idx]; ++i) {\n        double &tret = memo[idx + 1][sec + i];\n        if (tret != tret)\n            tret = DP(idx + 1, sec + i);\n        ret += pi[idx] * tmp * tret;\n        tmp *= 1 - pi[idx];\n    }\n    return (ret += tmp * DP(idx + 1, sec + ti[idx]));\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15353",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #284 - Codeforces - Code 7",
          "code": "3 3\n50 3\n50 2\n25 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15353",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #284 - Codeforces - Code 8",
          "code": "3 3\n50 3\n50 2\n25 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15353",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #284 - Codeforces - Code 9",
          "code": "2 5\n3 8\n13 13",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15353",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #284 - Codeforces - Code 10",
          "code": "2 5\n3 8\n13 13",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15353",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\ntuple<int, int, int> normalize_line(int a, int b, int c) {\n    int g = __gcd(__gcd(abs(a), abs(b)), abs(c));\n    if (g != 0) {\n        a /= g;\n        b /= g;\n        c /= g;\n    }\n\n    // Ensure the first non-zero coefficient is positive\n    if (a != 0) {\n        if (a < 0) {\n            a = -a;\n            b = -b;\n            c = -c;\n        }\n    } else if (b != 0) {\n        if (b < 0) {\n            a = -a;\n            b = -b;\n            c = -c;\n        }\n    } else {\n        // This case should not occur due to the constraint |a_i| + |b_i| > 0\n        ensuref(false, \"|a_i| + |b_i| > 0\");\n    }\n\n    return make_tuple(a, b, c);\n}\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int x1 = inf.readInt(-1000000, 1000000, \"x1\");\n    inf.readSpace();\n    int y1 = inf.readInt(-1000000, 1000000, \"y1\");\n    inf.readEoln();\n\n    int x2 = inf.readInt(-1000000, 1000000, \"x2\");\n    inf.readSpace();\n    int y2 = inf.readInt(-1000000, 1000000, \"y2\");\n    inf.readEoln();\n\n    int n = inf.readInt(1, 300, \"n\");\n    inf.readEoln();\n\n    set<tuple<int, int, int>> lines;\n\n    for (int i = 0; i < n; ++i) {\n        int a = inf.readInt(-1000000, 1000000, \"a_i\");\n        inf.readSpace();\n        int b = inf.readInt(-1000000, 1000000, \"b_i\");\n        inf.readSpace();\n        int c = inf.readInt(-1000000, 1000000, \"c_i\");\n        inf.readEoln();\n\n        ensuref(abs(a) + abs(b) > 0, \"|a_i| + |b_i| > 0 at line %d\", i + 1);\n\n        auto line = normalize_line(a, b, c);\n\n        ensuref(lines.count(line) == 0, \"Duplicate line found at line %d\", i + 1);\n        lines.insert(line);\n\n        int64_t val_home = (int64_t)a * x1 + (int64_t)b * y1 + c;\n        ensuref(val_home != 0, \"Home is on the line %d\", i + 1);\n\n        int64_t val_uni = (int64_t)a * x2 + (int64_t)b * y2 + c;\n        ensuref(val_uni != 0, \"University is on the line %d\", i + 1);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\ntuple<int, int, int> normalize_line(int a, int b, int c) {\n    int g = __gcd(__gcd(abs(a), abs(b)), abs(c));\n    if (g != 0) {\n        a /= g;\n        b /= g;\n        c /= g;\n    }\n\n    // Ensure the first non-zero coefficient is positive\n    if (a != 0) {\n        if (a < 0) {\n            a = -a;\n            b = -b;\n            c = -c;\n        }\n    } else if (b != 0) {\n        if (b < 0) {\n            a = -a;\n            b = -b;\n            c = -c;\n        }\n    } else {\n        // This case should not occur due to the constraint |a_i| + |b_i| > 0\n        ensuref(false, \"|a_i| + |b_i| > 0\");\n    }\n\n    return make_tuple(a, b, c);\n}\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int x1 = inf.readInt(-1000000, 1000000, \"x1\");\n    inf.readSpace();\n    int y1 = inf.readInt(-1000000, 1000000, \"y1\");\n    inf.readEoln();\n\n    int x2 = inf.readInt(-1000000, 1000000, \"x2\");\n    inf.readSpace();\n    int y2 = inf.readInt(-1000000, 1000000, \"y2\");\n    inf.readEoln();\n\n    int n = inf.readInt(1, 300, \"n\");\n    inf.readEoln();\n\n    set<tuple<int, int, int>> lines;\n\n    for (int i = 0; i < n; ++i) {\n        int a = inf.readInt(-1000000, 1000000, \"a_i\");\n        inf.readSpace();\n        int b = inf.readInt(-1000000, 1000000, \"b_i\");\n        inf.readSpace();\n        int c = inf.readInt(-1000000, 1000000, \"c_i\");\n        inf.readEoln();\n\n        ensuref(abs(a) + abs(b) > 0, \"|a_i| + |b_i| > 0 at line %d\", i + 1);\n\n        auto line = normalize_line(a, b, c);\n\n        ensuref(lines.count(line) == 0, \"Duplicate line found at line %d\", i + 1);\n        lines.insert(line);\n\n        int64_t val_home = (int64_t)a * x1 + (int64_t)b * y1 + c;\n        ensuref(val_home != 0, \"Home is on the line %d\", i + 1);\n\n        int64_t val_uni = (int64_t)a * x2 + (int64_t)b * y2 + c;\n        ensuref(val_uni != 0, \"University is on the line %d\", i + 1);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\ntuple<int, int, int> normalize_line(int a, int b, int c) {\n    int g = __gcd(__gcd(abs(a), abs(b)), abs(c));\n    if (g != 0) {\n        a /= g;\n        b /= g;\n        c /= g;\n    }\n\n    // Ensure the first non-zero coefficient is positive\n    if (a != 0) {\n        if (a < 0) {\n            a = -a;\n            b = -b;\n            c = -c;\n        }\n    } else if (b != 0) {\n        if (b < 0) {\n            a = -a;\n            b = -b;\n            c = -c;\n        }\n    } else {\n        // This case should not occur due to the constraint |a_i| + |b_i| > 0\n        ensuref(false, \"|a_i| + |b_i| > 0\");\n    }\n\n    return make_tuple(a, b, c);\n}\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int x1 = inf.readInt(-1000000, 1000000, \"x1\");\n    inf.readSpace();\n    int y1 = inf.readInt(-1000000, 1000000, \"y1\");\n    inf.readEoln();\n\n    int x2 = inf.readInt(-1000000, 1000000, \"x2\");\n    inf.readSpace();\n    int y2 = inf.readInt(-1000000, 1000000, \"y2\");\n    inf.readEoln();\n\n    int n = inf.readInt(1, 300, \"n\");\n    inf.readEoln();\n\n    set<tuple<int, int, int>> lines;\n\n    for (int i = 0; i < n; ++i) {\n        int a = inf.readInt(-1000000, 1000000, \"a_i\");\n        inf.readSpace();\n        int b = inf.readInt(-1000000, 1000000, \"b_i\");\n        inf.readSpace();\n        int c = inf.readInt(-1000000, 1000000, \"c_i\");\n        inf.readEoln();\n\n        ensuref(abs(a) + abs(b) > 0, \"|a_i| + |b_i| > 0 at line %d\", i + 1);\n\n        auto line = normalize_line(a, b, c);\n\n        ensuref(lines.count(line) == 0, \"Duplicate line found at line %d\", i + 1);\n        lines.insert(line);\n\n        int64_t val_home = (int64_t)a * x1 + (int64_t)b * y1 + c;\n        ensuref(val_home != 0, \"Home is on the line %d\", i + 1);\n\n        int64_t val_uni = (int64_t)a * x2 + (int64_t)b * y2 + c;\n        ensuref(val_uni != 0, \"University is on the line %d\", i + 1);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<tuple<int, int, int>> lines;\n    pair<int, int> home;\n    pair<int, int> university;\n\n    if (type == \"random\") {\n        // Generate n random unique lines\n        set<tuple<int, int, int>> lines_set;\n\n        while ((int)lines_set.size() < n) {\n            int ai = rnd.next(-1000000, 1000000);\n            int bi = rnd.next(-1000000, 1000000);\n            if (ai == 0 && bi == 0) continue; // Skip if ai == bi == 0\n            int ci = rnd.next(-1000000, 1000000);\n            tuple<int, int, int> line = make_tuple(ai, bi, ci);\n            if (lines_set.count(line)) continue;\n            lines_set.insert(line);\n        }\n\n        lines.assign(lines_set.begin(), lines_set.end());\n\n        // Generate random home and university positions not on any line\n        auto generate_point = [&]() {\n            while (true) {\n                int x = rnd.next(-1000000, 1000000);\n                int y = rnd.next(-1000000, 1000000);\n                bool on_line = false;\n                for (auto& line : lines) {\n                    int ai, bi, ci;\n                    tie(ai, bi, ci) = line;\n                    if (ai * x + bi * y + ci == 0) {\n                        on_line = true;\n                        break;\n                    }\n                }\n                if (!on_line) return make_pair(x, y);\n            }\n        };\n\n        home = generate_point();\n        university = generate_point();\n\n    } else if (type == \"same_block\") {\n        // Generate random home and university positions\n        int x1 = rnd.next(-1000000, 1000000);\n        int y1 = rnd.next(-1000000, 1000000);\n        int x2 = rnd.next(-1000000, 1000000);\n        int y2 = rnd.next(-1000000, 1000000);\n        home = make_pair(x1, y1);\n        university = make_pair(x2, y2);\n\n        for (int i = 0; i < n; ++i) {\n            // Generate lines that do not separate home and university\n            int ai = rnd.next(-1000000, 1000000);\n            int bi = rnd.next(-1000000, 1000000);\n            if (ai == 0 && bi == 0) continue;\n            int s1 = ai * x1 + bi * y1;\n            int s2 = ai * x2 + bi * y2;\n            int ci;\n            if (s1 * s2 >= 0) {\n                // They are on the same side, pick any ci\n                ci = rnd.next(-1000000, 1000000);\n            } else {\n                // Adjust ci so that they are on the same side\n                int delta = abs(s1) + abs(s2) + 1;\n                ci = rnd.next(-1000000, 1000000);\n                ci += delta;\n            }\n            lines.emplace_back(ai, bi, ci);\n        }\n\n    } else if (type == \"adjacent_blocks\") {\n        // Ensure n >= 1\n        if (n < 1) n = 1;\n\n        // Generate home and university on opposite sides of a line\n        int x1 = rnd.next(-1000000, 1000000);\n        int y1 = rnd.next(-1000000, 1000000);\n        home = make_pair(x1, y1);\n\n        int x2 = x1 + rnd.next(1, 10);\n        int y2 = y1 + rnd.next(1, 10);\n        university = make_pair(x2, y2);\n\n        int ai = rnd.next(-1000000, 1000000);\n        int bi = rnd.next(-1000000, 1000000);\n        if (ai == 0 && bi == 0) ai = 1; // Ensure the line is valid\n        int s1 = ai * x1 + bi * y1;\n        int s2 = ai * x2 + bi * y2;\n        int ci;\n        if (s1 == s2) {\n            ci = -s1 - rnd.next(1, 1000);\n        } else {\n            ci = - (s1 + s2) / 2;\n        }\n        lines.emplace_back(ai, bi, ci);\n\n        // Generate remaining lines that do not separate home and university\n        for (int i = 1; i < n; ++i) {\n            int ai2 = rnd.next(-1000000, 1000000);\n            int bi2 = rnd.next(-1000000, 1000000);\n            if (ai2 == 0 && bi2 == 0) continue;\n\n            int s1 = ai2 * x1 + bi2 * y1;\n            int s2 = ai2 * x2 + bi2 * y2;\n            int ci2;\n            if (s1 * s2 >= 0) {\n                ci2 = rnd.next(-1000000, 1000000);\n            } else {\n                int delta = abs(s1) + abs(s2) + 1;\n                ci2 = rnd.next(-1000000, 1000000);\n                ci2 += delta;\n            }\n            lines.emplace_back(ai2, bi2, ci2);\n        }\n\n    } else if (type == \"lines_parallel\") {\n        // Generate parallel lines, e.g., y + ci = 0\n        int x1 = rnd.next(-1000000, 1000000);\n        int y1 = rnd.next(-1000000, 1000000);\n        int x2 = rnd.next(-1000000, 1000000);\n        int y2 = rnd.next(-1000000, 1000000);\n        home = make_pair(x1, y1);\n        university = make_pair(x2, y2);\n\n        set<int> ci_set;\n        while ((int)ci_set.size() < n) {\n            int ci = rnd.next(-1000000, 1000000);\n            ci_set.insert(ci);\n        }\n        vector<int> c_list(ci_set.begin(), ci_set.end());\n\n        // Ensure home and university are not on any line\n        auto check_point = [&](int x, int y) {\n            for (int ci : c_list) {\n                if (y + ci == 0) {\n                    return false;\n                }\n            }\n            return true;\n        };\n\n        while (!check_point(home.first, home.second)) {\n            y1 = rnd.next(-1000000, 1000000);\n            home.second = y1;\n        }\n\n        while (!check_point(university.first, university.second)) {\n            y2 = rnd.next(-1000000, 1000000);\n            university.second = y2;\n        }\n\n        for (int ci : c_list) {\n            int ai = 0;\n            int bi = 1;\n            lines.emplace_back(ai, bi, ci);\n        }\n\n    } else if (type == \"lines_cross_at_point\") {\n        // All lines pass through (0, 0)\n        set<pair<int, int>> slopes;\n        while ((int)slopes.size() < n) {\n            int ai = rnd.next(-1000000, 1000000);\n            int bi = rnd.next(-1000000, 1000000);\n            if (ai == 0 && bi == 0) continue;\n            int gcd = __gcd(abs(ai), abs(bi));\n            ai /= gcd;\n            bi /= gcd;\n            if (ai < 0 || (ai == 0 && bi < 0)) {\n                ai = -ai;\n                bi = -bi;\n            }\n            pair<int, int> slope = make_pair(ai, bi);\n            if (slopes.count(slope)) continue;\n            slopes.insert(slope);\n        }\n\n        for (auto& slope : slopes) {\n            int ai = slope.first;\n            int bi = slope.second;\n            int ci = 0;\n            lines.emplace_back(ai, bi, ci);\n        }\n\n        auto generate_point = [&]() {\n            while (true) {\n                int x = rnd.next(-1000000, 1000000);\n                int y = rnd.next(-1000000, 1000000);\n                if (x == 0 && y == 0) continue; // Avoid (0, 0)\n                bool on_line = false;\n                for (auto& line : lines) {\n                    int ai, bi, ci;\n                    tie(ai, bi, ci) = line;\n                    if (ai * x + bi * y + ci == 0) {\n                        on_line = true;\n                        break;\n                    }\n                }\n                if (!on_line) return make_pair(x, y);\n            }\n        };\n\n        home = generate_point();\n        university = generate_point();\n\n    } else {\n        // Default case: random\n        // Same as \"random\" case\n        // ... (could copy the \"random\" case code here)\n    }\n\n    // Output the test case\n    printf(\"%d %d\\n\", home.first, home.second);\n    printf(\"%d %d\\n\", university.first, university.second);\n    printf(\"%d\\n\", n);\n    for (auto& line : lines) {\n        int ai, bi, ci;\n        tie(ai, bi, ci) = line;\n        printf(\"%d %d %d\\n\", ai, bi, ci);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<tuple<int, int, int>> lines;\n    pair<int, int> home;\n    pair<int, int> university;\n\n    if (type == \"random\") {\n        // Generate n random unique lines\n        set<tuple<int, int, int>> lines_set;\n\n        while ((int)lines_set.size() < n) {\n            int ai = rnd.next(-1000000, 1000000);\n            int bi = rnd.next(-1000000, 1000000);\n            if (ai == 0 && bi == 0) continue; // Skip if ai == bi == 0\n            int ci = rnd.next(-1000000, 1000000);\n            tuple<int, int, int> line = make_tuple(ai, bi, ci);\n            if (lines_set.count(line)) continue;\n            lines_set.insert(line);\n        }\n\n        lines.assign(lines_set.begin(), lines_set.end());\n\n        // Generate random home and university positions not on any line\n        auto generate_point = [&]() {\n            while (true) {\n                int x = rnd.next(-1000000, 1000000);\n                int y = rnd.next(-1000000, 1000000);\n                bool on_line = false;\n                for (auto& line : lines) {\n                    int ai, bi, ci;\n                    tie(ai, bi, ci) = line;\n                    if (ai * x + bi * y + ci == 0) {\n                        on_line = true;\n                        break;\n                    }\n                }\n                if (!on_line) return make_pair(x, y);\n            }\n        };\n\n        home = generate_point();\n        university = generate_point();\n\n    } else if (type == \"same_block\") {\n        // Generate random home and university positions\n        int x1 = rnd.next(-1000000, 1000000);\n        int y1 = rnd.next(-1000000, 1000000);\n        int x2 = rnd.next(-1000000, 1000000);\n        int y2 = rnd.next(-1000000, 1000000);\n        home = make_pair(x1, y1);\n        university = make_pair(x2, y2);\n\n        for (int i = 0; i < n; ++i) {\n            // Generate lines that do not separate home and university\n            int ai = rnd.next(-1000000, 1000000);\n            int bi = rnd.next(-1000000, 1000000);\n            if (ai == 0 && bi == 0) continue;\n            int s1 = ai * x1 + bi * y1;\n            int s2 = ai * x2 + bi * y2;\n            int ci;\n            if (s1 * s2 >= 0) {\n                // They are on the same side, pick any ci\n                ci = rnd.next(-1000000, 1000000);\n            } else {\n                // Adjust ci so that they are on the same side\n                int delta = abs(s1) + abs(s2) + 1;\n                ci = rnd.next(-1000000, 1000000);\n                ci += delta;\n            }\n            lines.emplace_back(ai, bi, ci);\n        }\n\n    } else if (type == \"adjacent_blocks\") {\n        // Ensure n >= 1\n        if (n < 1) n = 1;\n\n        // Generate home and university on opposite sides of a line\n        int x1 = rnd.next(-1000000, 1000000);\n        int y1 = rnd.next(-1000000, 1000000);\n        home = make_pair(x1, y1);\n\n        int x2 = x1 + rnd.next(1, 10);\n        int y2 = y1 + rnd.next(1, 10);\n        university = make_pair(x2, y2);\n\n        int ai = rnd.next(-1000000, 1000000);\n        int bi = rnd.next(-1000000, 1000000);\n        if (ai == 0 && bi == 0) ai = 1; // Ensure the line is valid\n        int s1 = ai * x1 + bi * y1;\n        int s2 = ai * x2 + bi * y2;\n        int ci;\n        if (s1 == s2) {\n            ci = -s1 - rnd.next(1, 1000);\n        } else {\n            ci = - (s1 + s2) / 2;\n        }\n        lines.emplace_back(ai, bi, ci);\n\n        // Generate remaining lines that do not separate home and university\n        for (int i = 1; i < n; ++i) {\n            int ai2 = rnd.next(-1000000, 1000000);\n            int bi2 = rnd.next(-1000000, 1000000);\n            if (ai2 == 0 && bi2 == 0) continue;\n\n            int s1 = ai2 * x1 + bi2 * y1;\n            int s2 = ai2 * x2 + bi2 * y2;\n            int ci2;\n            if (s1 * s2 >= 0) {\n                ci2 = rnd.next(-1000000, 1000000);\n            } else {\n                int delta = abs(s1) + abs(s2) + 1;\n                ci2 = rnd.next(-1000000, 1000000);\n                ci2 += delta;\n            }\n            lines.emplace_back(ai2, bi2, ci2);\n        }\n\n    } else if (type == \"lines_parallel\") {\n        // Generate parallel lines, e.g., y + ci = 0\n        int x1 = rnd.next(-1000000, 1000000);\n        int y1 = rnd.next(-1000000, 1000000);\n        int x2 = rnd.next(-1000000, 1000000);\n        int y2 = rnd.next(-1000000, 1000000);\n        home = make_pair(x1, y1);\n        university = make_pair(x2, y2);\n\n        set<int> ci_set;\n        while ((int)ci_set.size() < n) {\n            int ci = rnd.next(-1000000, 1000000);\n            ci_set.insert(ci);\n        }\n        vector<int> c_list(ci_set.begin(), ci_set.end());\n\n        // Ensure home and university are not on any line\n        auto check_point = [&](int x, int y) {\n            for (int ci : c_list) {\n                if (y + ci == 0) {\n                    return false;\n                }\n            }\n            return true;\n        };\n\n        while (!check_point(home.first, home.second)) {\n            y1 = rnd.next(-1000000, 1000000);\n            home.second = y1;\n        }\n\n        while (!check_point(university.first, university.second)) {\n            y2 = rnd.next(-1000000, 1000000);\n            university.second = y2;\n        }\n\n        for (int ci : c_list) {\n            int ai = 0;\n            int bi = 1;\n            lines.emplace_back(ai, bi, ci);\n        }\n\n    } else if (type == \"lines_cross_at_point\") {\n        // All lines pass through (0, 0)\n        set<pair<int, int>> slopes;\n        while ((int)slopes.size() < n) {\n            int ai = rnd.next(-1000000, 1000000);\n            int bi = rnd.next(-1000000, 1000000);\n            if (ai == 0 && bi == 0) continue;\n            int gcd = __gcd(abs(ai), abs(bi));\n            ai /= gcd;\n            bi /= gcd;\n            if (ai < 0 || (ai == 0 && bi < 0)) {\n                ai = -ai;\n                bi = -bi;\n            }\n            pair<int, int> slope = make_pair(ai, bi);\n            if (slopes.count(slope)) continue;\n            slopes.insert(slope);\n        }\n\n        for (auto& slope : slopes) {\n            int ai = slope.first;\n            int bi = slope.second;\n            int ci = 0;\n            lines.emplace_back(ai, bi, ci);\n        }\n\n        auto generate_point = [&]() {\n            while (true) {\n                int x = rnd.next(-1000000, 1000000);\n                int y = rnd.next(-1000000, 1000000);\n                if (x == 0 && y == 0) continue; // Avoid (0, 0)\n                bool on_line = false;\n                for (auto& line : lines) {\n                    int ai, bi, ci;\n                    tie(ai, bi, ci) = line;\n                    if (ai * x + bi * y + ci == 0) {\n                        on_line = true;\n                        break;\n                    }\n                }\n                if (!on_line) return make_pair(x, y);\n            }\n        };\n\n        home = generate_point();\n        university = generate_point();\n\n    } else {\n        // Default case: random\n        // Same as \"random\" case\n        // ... (could copy the \"random\" case code here)\n    }\n\n    // Output the test case\n    printf(\"%d %d\\n\", home.first, home.second);\n    printf(\"%d %d\\n\", university.first, university.second);\n    printf(\"%d\\n\", n);\n    for (auto& line : lines) {\n        int ai, bi, ci;\n        tie(ai, bi, ci) = line;\n        printf(\"%d %d %d\\n\", ai, bi, ci);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -type random\n./gen -n 10 -type random\n./gen -n 50 -type random\n./gen -n 100 -type random\n./gen -n 150 -type random\n./gen -n 200 -type random\n./gen -n 250 -type random\n./gen -n 300 -type random\n\n./gen -n 1 -type same_block\n./gen -n 50 -type same_block\n./gen -n 100 -type same_block\n./gen -n 150 -type same_block\n./gen -n 200 -type same_block\n./gen -n 250 -type same_block\n./gen -n 300 -type same_block\n\n./gen -n 1 -type adjacent_blocks\n./gen -n 50 -type adjacent_blocks\n./gen -n 100 -type adjacent_blocks\n./gen -n 150 -type adjacent_blocks\n./gen -n 200 -type adjacent_blocks\n./gen -n 250 -type adjacent_blocks\n./gen -n 300 -type adjacent_blocks\n\n./gen -n 10 -type lines_parallel\n./gen -n 50 -type lines_parallel\n./gen -n 100 -type lines_parallel\n./gen -n 150 -type lines_parallel\n./gen -n 200 -type lines_parallel\n./gen -n 250 -type lines_parallel\n./gen -n 300 -type lines_parallel\n\n./gen -n 10 -type lines_cross_at_point\n./gen -n 50 -type lines_cross_at_point\n./gen -n 100 -type lines_cross_at_point\n./gen -n 150 -type lines_cross_at_point\n./gen -n 200 -type lines_cross_at_point\n./gen -n 250 -type lines_cross_at_point\n./gen -n 300 -type lines_cross_at_point\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:39:32.042164",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "499/D",
      "title": "D. Name That Tune",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line of the input contains numbers n and T (1 ≤ n ≤ 5000, 1 ≤ T ≤ 5000), separated by a space. Next n lines contain pairs of numbers pi and ti (0 ≤ pi ≤ 100, 1 ≤ ti ≤ T). The songs are given in the same order as in Petya's list.",
      "output_spec": "OutputOutput a single number — the expected number of the number of songs you will recognize in T seconds. Your answer will be considered correct if its absolute or relative error does not exceed 10 - 6.",
      "sample_tests": "ExamplesInputCopy2 250 210 1OutputCopy1.500000000InputCopy2 20 2100 2OutputCopy1.000000000InputCopy3 350 350 225 2OutputCopy1.687500000InputCopy2 20 20 2OutputCopy1.000000000",
      "description": "D. Name That Tune\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line of the input contains numbers n and T (1 ≤ n ≤ 5000, 1 ≤ T ≤ 5000), separated by a space. Next n lines contain pairs of numbers pi and ti (0 ≤ pi ≤ 100, 1 ≤ ti ≤ T). The songs are given in the same order as in Petya's list.\n\nOutputOutput a single number — the expected number of the number of songs you will recognize in T seconds. Your answer will be considered correct if its absolute or relative error does not exceed 10 - 6.\n\nInputCopy2 250 210 1OutputCopy1.500000000InputCopy2 20 2100 2OutputCopy1.000000000InputCopy3 350 350 225 2OutputCopy1.687500000InputCopy2 20 20 2OutputCopy1.000000000\n\nInputCopy2 250 210 1\n\nOutputCopy1.500000000\n\nInputCopy2 20 2100 2\n\nOutputCopy1.000000000\n\nInputCopy3 350 350 225 2\n\nOutputCopy1.687500000\n\nInputCopy2 20 20 2\n\nOutputCopy1.000000000",
      "solutions": [
        {
          "title": "Codeforces Round #284 - Codeforces",
          "content": "Soon you are lucky to participate in Codeforces Round #284, and problems have been prepared by Vitaly Gridnev (gridnevvvit), Ilya Los (IlyaLos), Danil Sagunov (danilka.pro).We want to thank Max Akhmedov (Zlobober) for help with preparation of this round, Maria Belova (Delinur) for translation of statements and Mike Mirzayanov (MikeMirzayanov) for marvelous Codeforces and Polygon systems.Scoring system will be dynamic. Problems will be arranged in ascending expected difficulty order.Round finished, congratulations to winners!Div1: yeputons rng_58 Endagorion KADR Egor uwi mmaxio atetubou RAVEman Div2: sorry_dreamoon dreamoon_love_AA dreamoon_fan EditorialGood luck!",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/15336",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 671
        },
        {
          "title": "Codeforces Round #284 Editorial - Codeforces",
          "content": "499A - Watching a movieOne can solve the problem using greedy algorithm: if we can skip x minutes at current moment without skipping any good moment — we do that, otherwise — watch another minute of the film.499B - LectureIn this task you must find for every string in the text the pair containing that string, and from two strings of that pair output the shortest one.498A - Crazy Town / 499C - Crazy TownIt can be easily proved that, if two points from statement are placed on different sides of some line, this line will be crossed anyway. So, all we need to do is to cross all these lines, so the answer is the number of these lines.To check if two points lies on different sides of a line one can simply use its coordinates to place in line equation and check if these two values have different signs. Solution complexity — O(n).498B - Name That Tune / 499D - Name That TuneLet's numerate all the songs and seconds starting from 0.Problem will be solved using DP approach. State will be described by two integers (i, j): dp[i][j] is probability of that we named exactly i songs, and the last named song was named exactly before j'th second (after j - 1 seconds). dp[0][0] = 1 obviously.To make a move from state (i, j) to state (i + 1, j + k) (1 ≤ k < ti), we must name the song exactly after k seconds its playing — probability of that is (1 - pi)k - 1·pi. To fixed state (i + 1, j) sum of that moves can be represented as . Simple calculation of this value for each state gives O(nT2) complexity, so one must notice, that this values can be calculated using two pointers for fixed i (in common case it represent a segment with ti length) for every j in time O(T). This way calculating this type of moves takes O(nT) time.There is also a move to (i + 1, j + ti) and a move from (i, j) to (i, (j + k) = T), when we couldn't name current song in time T. This types of moves is calculated with O(nT) too.Solution complexity — O(nT).498C - Array and Operations / 499E - Array and OperationsWe will divide only by prime numbers.First, let's build a graph, where each of n numbers have own vertex group:Find all prime factors of current number. Every factor will have its own vertex in a group, furthermore, if some factor p has power of ai in current number, it will have exactly ai vertexes in group.The number of vertexes in such graph is .Now we will make edges in our graph: edge between two vertexes exists if and only if there is a good pair (given in statement) of vertexes group numbers and the prime values of a vertexes are the same. That means that we can divide that group numbers by that prime.The number of edges is .Good pairs are given the way that our graph is bipartite. After finding maximum matching in this graph we represent the way of doing operations as described in the statement.As soon as solution is using Kuhn's algorithm, its complexity is . One could notice that some of the edges are useless and reduce it to .498D - Traffic Jams in the LandThe solution of a problem — 60 (LCM of a numbers from 2 to 6) segment trees.In v'th segment tree we will hold for every segment [l, r] the next value: minimum time needed to get from l to r if we start in a moment of time equal to v modulo 60. Using these trees' values it is easy to quickly answer the questions, carefully changing the trees' values.498E - Stairs and LinesThe problem is solved using DP approach dp[i][mask] — the number of ways to paint first i blocks of a ladder the way that the last layer of vertical edges is painted as described in mask mask. This could be easily recalculated using matrix M[mask1][mask2] — the number of ways to paint horizontal edges between two neighbour vertical layers painted as represented by masks mask1 and mask2.For fixed i we have wi layers, so this matrix must be multiplied by itself wi times, which can be quickly done by binary-pow algorithm. After that this matrix is simply used in dynamic described above.Solution complexity — .",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/15353",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 499\\s*D"
          },
          "content_length": 3961
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #284 - Codeforces - Code 1",
          "code": "while(true) System.out.println(\"NOOOOOOOOOOOOOOOOOOOO\");",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15336",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #284 - Codeforces - Code 2",
          "code": "6 6\n2 2 2 2 2 2\n1 2\n1 3\n2 3\n4 5\n4 6\n5 6",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15336",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #284 - Codeforces - Code 3",
          "code": "6 6\n2 2 2 2 2 2\n1 2\n1 3\n2 3\n4 5\n4 6\n5 6",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15336",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #284 Editorial - Codeforces - Code 1",
          "code": "for (int i = 0; i <= t; ++i) {\n    dp[i] = dp1[i]; sum += dp[i]; }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15353",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #284 Editorial - Codeforces - Code 2",
          "code": "for (int i = 0; i <= t; ++i) {\n    dp[i] = dp1[i]; sum += dp[i]; }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15353",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #284 Editorial - Codeforces - Code 3",
          "code": "double *ptr, *ptr1, *tptr;\nptr = dp;\nptr1 = dp1;\n\nfor (int i = 1; i < n; ++i) {\n    // Something to do...\n\n    tptr = ptr;\n    ptr = ptr1;\n    ptr1 = tptr;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15353",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #284 Editorial - Codeforces - Code 4",
          "code": "double *ptr, *ptr1, *tptr;\nptr = dp;\nptr1 = dp1;\n\nfor (int i = 1; i < n; ++i) {\n    // Something to do...\n\n    tptr = ptr;\n    ptr = ptr1;\n    ptr1 = tptr;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15353",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #284 Editorial - Codeforces - Code 5",
          "code": "double DP(int idx, int sec) {\n    if (sec > t)\n        return idx - 1;\n    if (sec == t or idx == n)\n        return idx;\n    double &ret = memo[idx][sec], tmp = 1;\n    if (ret == ret)\n        return ret;\n    ret = 0;\n    for (int i =1 ; i < ti[idx]; ++i) {\n        double &tret = memo[idx + 1][sec + i];\n        if (tret != tret)\n            tret = DP(idx + 1, sec + i);\n        ret += pi[idx] * tmp * tret;\n        tmp *= 1 - pi[idx];\n    }\n    return (ret += tmp * DP(idx + 1, sec + ti[idx]));\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15353",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #284 Editorial - Codeforces - Code 6",
          "code": "double DP(int idx, int sec) {\n    if (sec > t)\n        return idx - 1;\n    if (sec == t or idx == n)\n        return idx;\n    double &ret = memo[idx][sec], tmp = 1;\n    if (ret == ret)\n        return ret;\n    ret = 0;\n    for (int i =1 ; i < ti[idx]; ++i) {\n        double &tret = memo[idx + 1][sec + i];\n        if (tret != tret)\n            tret = DP(idx + 1, sec + i);\n        ret += pi[idx] * tmp * tret;\n        tmp *= 1 - pi[idx];\n    }\n    return (ret += tmp * DP(idx + 1, sec + ti[idx]));\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15353",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #284 Editorial - Codeforces - Code 7",
          "code": "3 3\n50 3\n50 2\n25 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15353",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #284 Editorial - Codeforces - Code 8",
          "code": "3 3\n50 3\n50 2\n25 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15353",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #284 Editorial - Codeforces - Code 9",
          "code": "2 5\n3 8\n13 13",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15353",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #284 Editorial - Codeforces - Code 10",
          "code": "2 5\n3 8\n13 13",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15353",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 5000, \"n\");\n    inf.readSpace();\n    int T = inf.readInt(1, 5000, \"T\");\n    inf.readEoln();\n    for (int i = 0; i < n; ++i) {\n        double pi = inf.readDouble(0.0, 100.0, \"pi\");\n        inf.readSpace();\n        int ti = inf.readInt(1, T, \"ti\");\n        inf.readEoln();\n    }\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 5000, \"n\");\n    inf.readSpace();\n    int T = inf.readInt(1, 5000, \"T\");\n    inf.readEoln();\n    for (int i = 0; i < n; ++i) {\n        double pi = inf.readDouble(0.0, 100.0, \"pi\");\n        inf.readSpace();\n        int ti = inf.readInt(1, T, \"ti\");\n        inf.readEoln();\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 5000, \"n\");\n    inf.readSpace();\n    int T = inf.readInt(1, 5000, \"T\");\n    inf.readEoln();\n    for (int i = 0; i < n; ++i) {\n        double pi = inf.readDouble(0.0, 100.0, \"pi\");\n        inf.readSpace();\n        int ti = inf.readInt(1, T, \"ti\");\n        inf.readEoln();\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nconst double EPS = 1E-6;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare two sequences of doubles, max absolute or relative  error = %.7f\", EPS);\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    double j = 0, p = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        n++;\r\n        j = ans.readDouble();\r\n        p = ouf.readDouble();\r\n        if (!doubleCompare(j, p, EPS)) {\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%.7f', found: '%.7f', error = '%.7f'\",\r\n                  n, englishEnding(n).c_str(), j, p, doubleDelta(j, p));\r\n        }\r\n    }\r\n\r\n    if (n == 1)\r\n        quitf(_ok, \"found '%.7f', expected '%.7f', error '%.7f'\", p, j, doubleDelta(j, p));\r\n\r\n    quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int T = opt<int>(\"T\");\n    string p_type = opt<string>(\"p_type\", \"random\");\n    string t_type = opt<string>(\"t_type\", \"random\");\n    int p_zero = opt<int>(\"p_zero\", 0);\n    int p_hundred = opt<int>(\"p_hundred\", 0);\n    int p_fixed = opt<int>(\"p_fixed\", -1); // For p_type == \"fixed\"\n    int t_small = opt<int>(\"t_small\", T);\n    int t_large = opt<int>(\"t_large\", 1);\n    int t_fixed = opt<int>(\"t_fixed\", -1); // For t_type == \"fixed\"\n\n    vector<int> p(n);\n    vector<int> t(n);\n\n    // Generate p_i\n    if (p_type == \"zero\") {\n        for (int i = 0; i < n; ++i)\n            p[i] = 0;\n    } else if (p_type == \"hundred\") {\n        for (int i = 0; i < n; ++i)\n            p[i] = 100;\n    } else if (p_type == \"fixed\") {\n        // p_fixed should be in [0,100]\n        ensure(p_fixed >= 0 && p_fixed <= 100);\n        for (int i = 0; i < n; ++i)\n            p[i] = p_fixed;\n    } else if (p_type == \"mixed\") {\n        // Use p_zero and p_hundred as percentages\n        int zeros = n * p_zero / 100;\n        int hundreds = n * p_hundred / 100;\n        int remaining = n - zeros - hundreds;\n        for (int i = 0; i < zeros; ++i)\n            p[i] = 0;\n        for (int i = zeros; i < zeros + hundreds; ++i)\n            p[i] = 100;\n        for (int i = zeros + hundreds; i < n; ++i)\n            p[i] = rnd.next(0, 100);\n        // Shuffle p\n        shuffle(p.begin(), p.end());\n    } else {\n        // Default to random\n        for (int i = 0; i < n; ++i)\n            p[i] = rnd.next(0, 100);\n    }\n\n    // Generate t_i\n    if (t_type == \"one\") {\n        for (int i = 0; i < n; ++i)\n            t[i] = 1;\n    } else if (t_type == \"T\") {\n        for (int i = 0; i < n; ++i)\n            t[i] = T;\n    } else if (t_type == \"fixed\") {\n        // t_fixed should be in [1,T]\n        ensure(t_fixed >= 1 && t_fixed <= T);\n        for (int i = 0; i < n; ++i)\n            t[i] = t_fixed;\n    } else if (t_type == \"small\") {\n        for (int i = 0; i < n; ++i)\n            t[i] = rnd.next(1, min(T, t_small));\n    } else if (t_type == \"large\") {\n        for (int i = 0; i < n; ++i)\n            t[i] = rnd.next(max(1, t_large), T);\n    } else {\n        // Default to random\n        for (int i = 0; i < n; ++i)\n            t[i] = rnd.next(1, T);\n    }\n\n    // Output\n    printf(\"%d %d\\n\", n, T);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d %d\\n\", p[i], t[i]);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int T = opt<int>(\"T\");\n    string p_type = opt<string>(\"p_type\", \"random\");\n    string t_type = opt<string>(\"t_type\", \"random\");\n    int p_zero = opt<int>(\"p_zero\", 0);\n    int p_hundred = opt<int>(\"p_hundred\", 0);\n    int p_fixed = opt<int>(\"p_fixed\", -1); // For p_type == \"fixed\"\n    int t_small = opt<int>(\"t_small\", T);\n    int t_large = opt<int>(\"t_large\", 1);\n    int t_fixed = opt<int>(\"t_fixed\", -1); // For t_type == \"fixed\"\n\n    vector<int> p(n);\n    vector<int> t(n);\n\n    // Generate p_i\n    if (p_type == \"zero\") {\n        for (int i = 0; i < n; ++i)\n            p[i] = 0;\n    } else if (p_type == \"hundred\") {\n        for (int i = 0; i < n; ++i)\n            p[i] = 100;\n    } else if (p_type == \"fixed\") {\n        // p_fixed should be in [0,100]\n        ensure(p_fixed >= 0 && p_fixed <= 100);\n        for (int i = 0; i < n; ++i)\n            p[i] = p_fixed;\n    } else if (p_type == \"mixed\") {\n        // Use p_zero and p_hundred as percentages\n        int zeros = n * p_zero / 100;\n        int hundreds = n * p_hundred / 100;\n        int remaining = n - zeros - hundreds;\n        for (int i = 0; i < zeros; ++i)\n            p[i] = 0;\n        for (int i = zeros; i < zeros + hundreds; ++i)\n            p[i] = 100;\n        for (int i = zeros + hundreds; i < n; ++i)\n            p[i] = rnd.next(0, 100);\n        // Shuffle p\n        shuffle(p.begin(), p.end());\n    } else {\n        // Default to random\n        for (int i = 0; i < n; ++i)\n            p[i] = rnd.next(0, 100);\n    }\n\n    // Generate t_i\n    if (t_type == \"one\") {\n        for (int i = 0; i < n; ++i)\n            t[i] = 1;\n    } else if (t_type == \"T\") {\n        for (int i = 0; i < n; ++i)\n            t[i] = T;\n    } else if (t_type == \"fixed\") {\n        // t_fixed should be in [1,T]\n        ensure(t_fixed >= 1 && t_fixed <= T);\n        for (int i = 0; i < n; ++i)\n            t[i] = t_fixed;\n    } else if (t_type == \"small\") {\n        for (int i = 0; i < n; ++i)\n            t[i] = rnd.next(1, min(T, t_small));\n    } else if (t_type == \"large\") {\n        for (int i = 0; i < n; ++i)\n            t[i] = rnd.next(max(1, t_large), T);\n    } else {\n        // Default to random\n        for (int i = 0; i < n; ++i)\n            t[i] = rnd.next(1, T);\n    }\n\n    // Output\n    printf(\"%d %d\\n\", n, T);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d %d\\n\", p[i], t[i]);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -T 1 -p_type zero -t_type one\n./gen -n 1 -T 1 -p_type hundred -t_type T\n./gen -n 1 -T 1 -p_type random -t_type random\n\n./gen -n 10 -T 10 -p_type zero -t_type one\n./gen -n 10 -T 10 -p_type hundred -t_type T\n./gen -n 10 -T 10 -p_type random -t_type random\n\n./gen -n 100 -T 100 -p_type zero -t_type one\n./gen -n 100 -T 100 -p_type hundred -t_type T\n./gen -n 100 -T 100 -p_type random -t_type random\n\n./gen -n 500 -T 500 -p_type fixed -p_fixed 50 -t_type fixed -t_fixed 250\n./gen -n 500 -T 500 -p_type fixed -p_fixed 75 -t_type fixed -t_fixed 500\n\n./gen -n 1000 -T 1000 -p_type mixed -p_zero 50 -p_hundred 50 -t_type random\n\n./gen -n 3000 -T 500 -p_type mixed -p_zero 20 -p_hundred 20 -t_type small -t_small 10\n\n./gen -n 5000 -T 5000 -p_type mixed -p_zero 30 -p_hundred 30 -t_type large -t_large 5000\n\n./gen -n 5000 -T 5000 -p_type random -t_type random\n\n./gen -n 5000 -T 5000 -p_type zero -t_type large -t_large 4999\n\n./gen -n 5000 -T 5000 -p_type hundred -t_type small -t_small 1\n\n./gen -n 5000 -T 1 -p_type random -t_type random\n\n./gen -n 5000 -T 1 -p_type random -t_type T\n\n./gen -n 5000 -T 5000 -p_type random -t_type one\n\n./gen -n 5000 -T 5000 -p_type zero -t_type T\n\n./gen -n 5000 -T 5000 -p_type hundred -t_type one\n\n./gen -n 5000 -T 5000 -p_type mixed -p_zero 25 -p_hundred 25 -t_type mixed -t_small 1 -t_large 5000\n\n./gen -n 5000 -T 5000 -p_type fixed -p_fixed 50 -t_type random\n\n./gen -n 5000 -T 5000 -p_type random -t_type fixed -t_fixed 2500\n\n./gen -n 5000 -T 5000 -p_type fixed -p_fixed 75 -t_type fixed -t_fixed 2500\n\n./gen -n 5000 -T 5000 -p_type random -t_type random\n\n./gen -n 1 -T 5000 -p_type random -t_type random\n\n./gen -n 500 -T 1 -p_type random -t_type random\n\n./gen -n 5000 -T 1 -p_type random -t_type one\n\n./gen -n 5000 -T 5000 -p_type random -t_type T\n\n./gen -n 5000 -T 5000 -p_type random -t_type T\n\n./gen -n 5000 -T 5000 -p_type random -t_type one\n\n./gen -n 5000 -T 5000 -p_type random -t_type T\n\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:39:34.226235",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "499/E",
      "title": "E. Array and Operations",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains two space-separated integers n, m (2 ≤ n ≤ 100, 1 ≤ m ≤ 100).The second line contains n space-separated integers a[1], a[2], ..., a[n] (1 ≤ a[i] ≤ 109) — the description of the array.The following m lines contain the description of good pairs. The k-th line contains two space-separated integers ik, jk (1 ≤ ik < jk ≤ n, ik + jk is an odd number).It is guaranteed that all the good pairs are distinct.",
      "output_spec": "OutputOutput the answer for the problem.",
      "sample_tests": "ExamplesInputCopy3 28 3 81 22 3OutputCopy0InputCopy3 28 12 81 22 3OutputCopy2",
      "description": "E. Array and Operations\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains two space-separated integers n, m (2 ≤ n ≤ 100, 1 ≤ m ≤ 100).The second line contains n space-separated integers a[1], a[2], ..., a[n] (1 ≤ a[i] ≤ 109) — the description of the array.The following m lines contain the description of good pairs. The k-th line contains two space-separated integers ik, jk (1 ≤ ik < jk ≤ n, ik + jk is an odd number).It is guaranteed that all the good pairs are distinct.\n\nOutputOutput the answer for the problem.\n\nInputCopy3 28 3 81 22 3OutputCopy0InputCopy3 28 12 81 22 3OutputCopy2\n\nInputCopy3 28 3 81 22 3\n\nOutputCopy0\n\nInputCopy3 28 12 81 22 3\n\nOutputCopy2",
      "solutions": [
        {
          "title": "Codeforces Round #284 - Codeforces",
          "content": "Soon you are lucky to participate in Codeforces Round #284, and problems have been prepared by Vitaly Gridnev (gridnevvvit), Ilya Los (IlyaLos), Danil Sagunov (danilka.pro).We want to thank Max Akhmedov (Zlobober) for help with preparation of this round, Maria Belova (Delinur) for translation of statements and Mike Mirzayanov (MikeMirzayanov) for marvelous Codeforces and Polygon systems.Scoring system will be dynamic. Problems will be arranged in ascending expected difficulty order.Round finished, congratulations to winners!Div1: yeputons rng_58 Endagorion KADR Egor uwi mmaxio atetubou RAVEman Div2: sorry_dreamoon dreamoon_love_AA dreamoon_fan EditorialGood luck!",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/15336",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 671
        },
        {
          "title": "Codeforces Round #284 Editorial - Codeforces",
          "content": "499A - Watching a movieOne can solve the problem using greedy algorithm: if we can skip x minutes at current moment without skipping any good moment — we do that, otherwise — watch another minute of the film.499B - LectureIn this task you must find for every string in the text the pair containing that string, and from two strings of that pair output the shortest one.498A - Crazy Town / 499C - Crazy TownIt can be easily proved that, if two points from statement are placed on different sides of some line, this line will be crossed anyway. So, all we need to do is to cross all these lines, so the answer is the number of these lines.To check if two points lies on different sides of a line one can simply use its coordinates to place in line equation and check if these two values have different signs. Solution complexity — O(n).498B - Name That Tune / 499D - Name That TuneLet's numerate all the songs and seconds starting from 0.Problem will be solved using DP approach. State will be described by two integers (i, j): dp[i][j] is probability of that we named exactly i songs, and the last named song was named exactly before j'th second (after j - 1 seconds). dp[0][0] = 1 obviously.To make a move from state (i, j) to state (i + 1, j + k) (1 ≤ k < ti), we must name the song exactly after k seconds its playing — probability of that is (1 - pi)k - 1·pi. To fixed state (i + 1, j) sum of that moves can be represented as . Simple calculation of this value for each state gives O(nT2) complexity, so one must notice, that this values can be calculated using two pointers for fixed i (in common case it represent a segment with ti length) for every j in time O(T). This way calculating this type of moves takes O(nT) time.There is also a move to (i + 1, j + ti) and a move from (i, j) to (i, (j + k) = T), when we couldn't name current song in time T. This types of moves is calculated with O(nT) too.Solution complexity — O(nT).498C - Array and Operations / 499E - Array and OperationsWe will divide only by prime numbers.First, let's build a graph, where each of n numbers have own vertex group:Find all prime factors of current number. Every factor will have its own vertex in a group, furthermore, if some factor p has power of ai in current number, it will have exactly ai vertexes in group.The number of vertexes in such graph is .Now we will make edges in our graph: edge between two vertexes exists if and only if there is a good pair (given in statement) of vertexes group numbers and the prime values of a vertexes are the same. That means that we can divide that group numbers by that prime.The number of edges is .Good pairs are given the way that our graph is bipartite. After finding maximum matching in this graph we represent the way of doing operations as described in the statement.As soon as solution is using Kuhn's algorithm, its complexity is . One could notice that some of the edges are useless and reduce it to .498D - Traffic Jams in the LandThe solution of a problem — 60 (LCM of a numbers from 2 to 6) segment trees.In v'th segment tree we will hold for every segment [l, r] the next value: minimum time needed to get from l to r if we start in a moment of time equal to v modulo 60. Using these trees' values it is easy to quickly answer the questions, carefully changing the trees' values.498E - Stairs and LinesThe problem is solved using DP approach dp[i][mask] — the number of ways to paint first i blocks of a ladder the way that the last layer of vertical edges is painted as described in mask mask. This could be easily recalculated using matrix M[mask1][mask2] — the number of ways to paint horizontal edges between two neighbour vertical layers painted as represented by masks mask1 and mask2.For fixed i we have wi layers, so this matrix must be multiplied by itself wi times, which can be quickly done by binary-pow algorithm. After that this matrix is simply used in dynamic described above.Solution complexity — .",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/15353",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 499\\s*E"
          },
          "content_length": 3961
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #284 - Codeforces - Code 1",
          "code": "while(true) System.out.println(\"NOOOOOOOOOOOOOOOOOOOO\");",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15336",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #284 - Codeforces - Code 2",
          "code": "6 6\n2 2 2 2 2 2\n1 2\n1 3\n2 3\n4 5\n4 6\n5 6",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15336",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #284 - Codeforces - Code 3",
          "code": "6 6\n2 2 2 2 2 2\n1 2\n1 3\n2 3\n4 5\n4 6\n5 6",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15336",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #284 Editorial - Codeforces - Code 1",
          "code": "for (int i = 0; i <= t; ++i) {\n    dp[i] = dp1[i]; sum += dp[i]; }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15353",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #284 Editorial - Codeforces - Code 2",
          "code": "for (int i = 0; i <= t; ++i) {\n    dp[i] = dp1[i]; sum += dp[i]; }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15353",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #284 Editorial - Codeforces - Code 3",
          "code": "double *ptr, *ptr1, *tptr;\nptr = dp;\nptr1 = dp1;\n\nfor (int i = 1; i < n; ++i) {\n    // Something to do...\n\n    tptr = ptr;\n    ptr = ptr1;\n    ptr1 = tptr;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15353",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #284 Editorial - Codeforces - Code 4",
          "code": "double *ptr, *ptr1, *tptr;\nptr = dp;\nptr1 = dp1;\n\nfor (int i = 1; i < n; ++i) {\n    // Something to do...\n\n    tptr = ptr;\n    ptr = ptr1;\n    ptr1 = tptr;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15353",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #284 Editorial - Codeforces - Code 5",
          "code": "double DP(int idx, int sec) {\n    if (sec > t)\n        return idx - 1;\n    if (sec == t or idx == n)\n        return idx;\n    double &ret = memo[idx][sec], tmp = 1;\n    if (ret == ret)\n        return ret;\n    ret = 0;\n    for (int i =1 ; i < ti[idx]; ++i) {\n        double &tret = memo[idx + 1][sec + i];\n        if (tret != tret)\n            tret = DP(idx + 1, sec + i);\n        ret += pi[idx] * tmp * tret;\n        tmp *= 1 - pi[idx];\n    }\n    return (ret += tmp * DP(idx + 1, sec + ti[idx]));\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15353",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #284 Editorial - Codeforces - Code 6",
          "code": "double DP(int idx, int sec) {\n    if (sec > t)\n        return idx - 1;\n    if (sec == t or idx == n)\n        return idx;\n    double &ret = memo[idx][sec], tmp = 1;\n    if (ret == ret)\n        return ret;\n    ret = 0;\n    for (int i =1 ; i < ti[idx]; ++i) {\n        double &tret = memo[idx + 1][sec + i];\n        if (tret != tret)\n            tret = DP(idx + 1, sec + i);\n        ret += pi[idx] * tmp * tret;\n        tmp *= 1 - pi[idx];\n    }\n    return (ret += tmp * DP(idx + 1, sec + ti[idx]));\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15353",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #284 Editorial - Codeforces - Code 7",
          "code": "3 3\n50 3\n50 2\n25 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15353",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #284 Editorial - Codeforces - Code 8",
          "code": "3 3\n50 3\n50 2\n25 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15353",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #284 Editorial - Codeforces - Code 9",
          "code": "2 5\n3 8\n13 13",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15353",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #284 Editorial - Codeforces - Code 10",
          "code": "2 5\n3 8\n13 13",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15353",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(2, 100, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 100, \"m\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, 1, 1000000000, \"a\");\n    inf.readEoln();\n\n    set<pair<int, int>> pairs;\n    for (int k = 0; k < m; ++k) {\n        int ik = inf.readInt(1, n - 1, \"ik\");\n        inf.readSpace();\n        int jk = inf.readInt(ik + 1, n, \"jk\");\n        inf.readEoln();\n\n        ensuref((ik + jk) % 2 == 1, \"The sum ik + jk must be odd, but ik=%d, jk=%d\", ik, jk);\n\n        ensuref(pairs.count({ik, jk}) == 0, \"Duplicate pair (%d, %d) found\", ik, jk);\n        pairs.insert({ik, jk});\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(2, 100, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 100, \"m\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, 1, 1000000000, \"a\");\n    inf.readEoln();\n\n    set<pair<int, int>> pairs;\n    for (int k = 0; k < m; ++k) {\n        int ik = inf.readInt(1, n - 1, \"ik\");\n        inf.readSpace();\n        int jk = inf.readInt(ik + 1, n, \"jk\");\n        inf.readEoln();\n\n        ensuref((ik + jk) % 2 == 1, \"The sum ik + jk must be odd, but ik=%d, jk=%d\", ik, jk);\n\n        ensuref(pairs.count({ik, jk}) == 0, \"Duplicate pair (%d, %d) found\", ik, jk);\n        pairs.insert({ik, jk});\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(2, 100, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 100, \"m\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, 1, 1000000000, \"a\");\n    inf.readEoln();\n\n    set<pair<int, int>> pairs;\n    for (int k = 0; k < m; ++k) {\n        int ik = inf.readInt(1, n - 1, \"ik\");\n        inf.readSpace();\n        int jk = inf.readInt(ik + 1, n, \"jk\");\n        inf.readEoln();\n\n        ensuref((ik + jk) % 2 == 1, \"The sum ik + jk must be odd, but ik=%d, jk=%d\", ik, jk);\n\n        ensuref(pairs.count({ik, jk}) == 0, \"Duplicate pair (%d, %d) found\", ik, jk);\n        pairs.insert({ik, jk});\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\n// Function to generate a prime number within a given range\nint getPrimeInRange(int low, int high) {\n    while (true) {\n        int val = rnd.next(low, high);\n        bool isPrime = true;\n        for (int d = 2; d * d <= val; ++d) {\n            if (val % d == 0) {\n                isPrime = false;\n                break;\n            }\n        }\n        if (isPrime) return val;\n    }\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\", -1);\n    string arrType = opt<string>(\"arrType\", \"random\");\n    string pairType = opt<string>(\"pairType\", \"random\");\n    int maxA = opt<int>(\"maxA\", 1000000000);\n\n    // Generate array a[1..n]\n    vector<int> a(n);\n    if (arrType == \"ones\") {\n        for (int i = 0; i < n; ++i) a[i] = 1;\n    } else if (arrType == \"primes\") {\n        for (int i = 0; i < n; ++i)\n            a[i] = getPrimeInRange(2, min(maxA, 100000));\n    } else if (arrType == \"powers_two\") {\n        for (int i = 0; i < n; ++i) {\n            int exp = rnd.next(0, 29); // To keep a[i] within 1e9\n            a[i] = 1 << exp;\n        }\n    } else if (arrType == \"same_large\") {\n        int val = rnd.next(2, maxA);\n        for (int i = 0; i < n; ++i) a[i] = val;\n    } else if (arrType == \"common_multiple\") {\n        int common = rnd.next(2, maxA / 10);\n        for (int i = 0; i < n; ++i) {\n            int mult = rnd.next(1, 10);\n            a[i] = common * mult;\n        }\n    } else if (arrType == \"powers_two_three\") {\n        for (int i = 0; i < n; ++i) {\n            int exp2 = rnd.next(0, 15);\n            int exp3 = rnd.next(0, 10);\n            a[i] = pow(2, exp2) * pow(3, exp3);\n        }\n    } else if (arrType == \"same_large_composite\") {\n        int val = 1;\n        vector<int> primes = {2, 3, 5, 7};\n        for (int p : primes) {\n            int exp = rnd.next(1, 5);\n            val *= pow(p, exp);\n        }\n        for (int i = 0; i < n; ++i) a[i] = val;\n    } else if (arrType == \"large_primes\") {\n        for (int i = 0; i < n; ++i)\n            a[i] = getPrimeInRange(max(2, maxA - 10000), maxA);\n    } else if (arrType == \"highly_composite\") {\n        for (int i = 0; i < n; ++i) {\n            int val = 1;\n            for (int p : {2, 3, 5, 7}) {\n                int exp = rnd.next(1, 5);\n                val *= pow(p, exp);\n            }\n            a[i] = val;\n        }\n    } else {\n        // random\n        for (int i = 0; i < n; ++i) a[i] = rnd.next(1, maxA);\n    }\n\n    // Generate m good pairs\n    vector<pair<int, int>> goodPairs;\n    if (pairType == \"all\") {\n        // All valid good pairs\n        for (int i = 1; i <= n; ++i) {\n            for (int j = i + 1; j <= n; ++j) {\n                if ((i + j) % 2 == 1) {\n                    goodPairs.push_back({i, j});\n                }\n            }\n        }\n        m = goodPairs.size();\n        shuffle(goodPairs.begin(), goodPairs.end());\n    } else if (pairType == \"none\") {\n        // No good pairs\n        m = 0;\n    } else {\n        // Random pairs\n        if (m == -1) m = rnd.next(1, min(100, n * (n - 1) / 2));\n        set<pair<int, int>> used;\n        while ((int)goodPairs.size() < m) {\n            int i = rnd.next(1, n - 1);\n            int j = rnd.next(i + 1, n);\n            if ((i + j) % 2 == 1) {\n                if (!used.count({i, j})) {\n                    used.insert({i, j});\n                    goodPairs.push_back({i, j});\n                }\n            }\n        }\n    }\n\n    // Output n and m\n    printf(\"%d %d\\n\", n, m);\n    // Output a[1..n]\n    for (int i = 0; i < n; ++i) printf(\"%d%c\", a[i], i == n - 1 ? '\\n' : ' ');\n    // Output good pairs\n    for (int k = 0; k < m; ++k) {\n        printf(\"%d %d\\n\", goodPairs[k].first, goodPairs[k].second);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\n// Function to generate a prime number within a given range\nint getPrimeInRange(int low, int high) {\n    while (true) {\n        int val = rnd.next(low, high);\n        bool isPrime = true;\n        for (int d = 2; d * d <= val; ++d) {\n            if (val % d == 0) {\n                isPrime = false;\n                break;\n            }\n        }\n        if (isPrime) return val;\n    }\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\", -1);\n    string arrType = opt<string>(\"arrType\", \"random\");\n    string pairType = opt<string>(\"pairType\", \"random\");\n    int maxA = opt<int>(\"maxA\", 1000000000);\n\n    // Generate array a[1..n]\n    vector<int> a(n);\n    if (arrType == \"ones\") {\n        for (int i = 0; i < n; ++i) a[i] = 1;\n    } else if (arrType == \"primes\") {\n        for (int i = 0; i < n; ++i)\n            a[i] = getPrimeInRange(2, min(maxA, 100000));\n    } else if (arrType == \"powers_two\") {\n        for (int i = 0; i < n; ++i) {\n            int exp = rnd.next(0, 29); // To keep a[i] within 1e9\n            a[i] = 1 << exp;\n        }\n    } else if (arrType == \"same_large\") {\n        int val = rnd.next(2, maxA);\n        for (int i = 0; i < n; ++i) a[i] = val;\n    } else if (arrType == \"common_multiple\") {\n        int common = rnd.next(2, maxA / 10);\n        for (int i = 0; i < n; ++i) {\n            int mult = rnd.next(1, 10);\n            a[i] = common * mult;\n        }\n    } else if (arrType == \"powers_two_three\") {\n        for (int i = 0; i < n; ++i) {\n            int exp2 = rnd.next(0, 15);\n            int exp3 = rnd.next(0, 10);\n            a[i] = pow(2, exp2) * pow(3, exp3);\n        }\n    } else if (arrType == \"same_large_composite\") {\n        int val = 1;\n        vector<int> primes = {2, 3, 5, 7};\n        for (int p : primes) {\n            int exp = rnd.next(1, 5);\n            val *= pow(p, exp);\n        }\n        for (int i = 0; i < n; ++i) a[i] = val;\n    } else if (arrType == \"large_primes\") {\n        for (int i = 0; i < n; ++i)\n            a[i] = getPrimeInRange(max(2, maxA - 10000), maxA);\n    } else if (arrType == \"highly_composite\") {\n        for (int i = 0; i < n; ++i) {\n            int val = 1;\n            for (int p : {2, 3, 5, 7}) {\n                int exp = rnd.next(1, 5);\n                val *= pow(p, exp);\n            }\n            a[i] = val;\n        }\n    } else {\n        // random\n        for (int i = 0; i < n; ++i) a[i] = rnd.next(1, maxA);\n    }\n\n    // Generate m good pairs\n    vector<pair<int, int>> goodPairs;\n    if (pairType == \"all\") {\n        // All valid good pairs\n        for (int i = 1; i <= n; ++i) {\n            for (int j = i + 1; j <= n; ++j) {\n                if ((i + j) % 2 == 1) {\n                    goodPairs.push_back({i, j});\n                }\n            }\n        }\n        m = goodPairs.size();\n        shuffle(goodPairs.begin(), goodPairs.end());\n    } else if (pairType == \"none\") {\n        // No good pairs\n        m = 0;\n    } else {\n        // Random pairs\n        if (m == -1) m = rnd.next(1, min(100, n * (n - 1) / 2));\n        set<pair<int, int>> used;\n        while ((int)goodPairs.size() < m) {\n            int i = rnd.next(1, n - 1);\n            int j = rnd.next(i + 1, n);\n            if ((i + j) % 2 == 1) {\n                if (!used.count({i, j})) {\n                    used.insert({i, j});\n                    goodPairs.push_back({i, j});\n                }\n            }\n        }\n    }\n\n    // Output n and m\n    printf(\"%d %d\\n\", n, m);\n    // Output a[1..n]\n    for (int i = 0; i < n; ++i) printf(\"%d%c\", a[i], i == n - 1 ? '\\n' : ' ');\n    // Output good pairs\n    for (int k = 0; k < m; ++k) {\n        printf(\"%d %d\\n\", goodPairs[k].first, goodPairs[k].second);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Command 1: Smallest n and m\n./gen -n 2 -m 1 -arrType random -pairType random\n\n# Command 2: Maximum n and m\n./gen -n 100 -m 100 -arrType random -pairType random\n\n# Command 3: All ones array\n./gen -n 100 -arrType ones -pairType all\n\n# Command 4: All same large number\n./gen -n 100 -arrType same_large -pairType random -maxA 1000000000\n\n# Command 5: Primes array\n./gen -n 100 -arrType primes -pairType random\n\n# Command 6: Powers of two array\n./gen -n 100 -arrType powers_two -pairType all\n\n# Command 7: No good pairs\n./gen -n 100 -arrType random -pairType none\n\n# Command 8: All possible good pairs\n./gen -n 50 -arrType random -pairType all\n\n# Command 9: Edge case: Single operation possible\n./gen -n 2 -m 1 -arrType random -pairType random\n\n# Command 10: All pairs sum to even (no good pairs)\n./gen -n 4 -arrType random -pairType none\n\n# Command 11: Random arrays with minimal values\n./gen -n 100 -arrType random -pairType random -maxA 1\n\n# Command 12: Random arrays with maximal values\n./gen -n 100 -arrType random -pairType random -maxA 1000000000\n\n# Command 13: All numbers equal to a small prime number\n./gen -n 100 -arrType same_large -pairType all -maxA 7\n\n# Command 14: Large common multiple\n./gen -n 100 -arrType common_multiple -pairType all -maxA 1000000000\n\n# Command 15: Maximum n and m, minimal a[i]\n./gen -n 100 -arrType ones -pairType random\n\n# Command 16: Maximum n and m, maximal a[i]\n./gen -n 100 -arrType random -pairType random -maxA 1000000000\n\n# Command 17: Random arrays, powers of two and three\n./gen -n 100 -arrType powers_two_three -pairType random\n\n# Command 18: Random arrays, random pairs, small n and m\n./gen -n 10 -arrType random -pairType random\n\n# Command 19: Random arrays, random pairs, medium n and m\n./gen -n 50 -arrType random -pairType random\n\n# Command 20: All same number which is a product of primes\n./gen -n 100 -arrType same_large_composite -pairType all\n\n# Command 21: Edge case: m = 1\n./gen -n 50 -m 1 -arrType random -pairType random\n\n# Command 22: Edge case: n = 2, m = 1\n./gen -n 2 -m 1 -arrType ones -pairType all\n\n# Command 23: Edge case: m = maximum possible good pairs\n./gen -n 100 -arrType random -pairType all\n\n# Command 24: Edge case: a[i] are large prime numbers\n./gen -n 100 -arrType large_primes -pairType random\n\n# Command 25: Edge case: a[i] are multiples of numbers with many divisors\n./gen -n 100 -arrType highly_composite -pairType random\n\n# Command 26: Random array with small n and maximal m\n./gen -n 10 -arrType random -pairType all\n\n# Command 27: All numbers are powers of two, minimal n and m\n./gen -n 2 -arrType powers_two -pairType random\n\n# Command 28: All numbers are powers of two, maximum n and m\n./gen -n 100 -arrType powers_two -pairType random\n\n# Command 29: Random array, no good pairs due to constraints\n./gen -n 3 -arrType random -pairType none\n\n# Command 30: Random array, m is half of maximum possible good pairs\n./gen -n 50 -arrType random -pairType random -m 600\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:39:36.266468",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "5/A",
      "title": "A. Chat Server's Outgoing Traffic",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test64 megabytes",
      "input_spec": "InputInput file will contain not more than 100 commands, each in its own line. No line will exceed 100 characters. Formats of the commands will be the following:  +<name> for 'Add' command.  -<name> for 'Remove' command.  <sender_name>:<message_text> for 'Send' command. <name> and <sender_name> is a non-empty sequence of Latin letters and digits. <message_text> can contain letters, digits and spaces, but can't start or end with a space. <message_text> can be an empty line.It is guaranteed, that input data are correct, i.e. there will be no 'Add' command if person with such a name is already in the chat, there will be no 'Remove' command if there is no person with such a name in the chat etc.All names are case-sensitive.",
      "output_spec": "OutputPrint a single number — answer to the problem.",
      "sample_tests": "ExamplesInputCopy+MikeMike:hello+Kate+Dmitry-DmitryKate:hi-KateOutputCopy9InputCopy+Mike-Mike+MikeMike:Hi   I am here-Mike+Kate-KateOutputCopy14",
      "description": "A. Chat Server's Outgoing Traffic\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test64 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputInput file will contain not more than 100 commands, each in its own line. No line will exceed 100 characters. Formats of the commands will be the following:  +<name> for 'Add' command.  -<name> for 'Remove' command.  <sender_name>:<message_text> for 'Send' command. <name> and <sender_name> is a non-empty sequence of Latin letters and digits. <message_text> can contain letters, digits and spaces, but can't start or end with a space. <message_text> can be an empty line.It is guaranteed, that input data are correct, i.e. there will be no 'Add' command if person with such a name is already in the chat, there will be no 'Remove' command if there is no person with such a name in the chat etc.All names are case-sensitive.\n\nOutputPrint a single number — answer to the problem.\n\nInputCopy+MikeMike:hello+Kate+Dmitry-DmitryKate:hi-KateOutputCopy9InputCopy+Mike-Mike+MikeMike:Hi   I am here-Mike+Kate-KateOutputCopy14\n\nInputCopy+MikeMike:hello+Kate+Dmitry-DmitryKate:hi-Kate\n\nOutputCopy9\n\nInputCopy+Mike-Mike+MikeMike:Hi   I am here-Mike+Kate-Kate\n\nOutputCopy14",
      "solutions": [
        {
          "title": "Codeforces Beta Round #5 - Codeforces",
          "content": "Welcome and good luck on the round! I'd like to remind that if you have any questions on the problems, the best way to ask them is to use the web interface on the problems page. Later in the same post we will discuss the round. Wish you high rating,MikeMirzayanov.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/196",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 264
        },
        {
          "title": "Codeforces Beta Round #5 - Tutorial - Codeforces",
          "content": "As there is no tutorial of Codeforces Beta Round #5 in English, I have decided to write this one. Possibly, some ideas will be similar to ones, expressed in Russian tutorial made by SkidanovAlex, but I hope everybody will find some useful in this problem analysis too.Problems A and B.Both are implementation problems. The only difficult, many participants faced with - to read data correctly. It is recommended to use gets(s) or getline(cin, s) in C++, readLine() method of BufferedReader class in Java.Problem C.First of all, for each closing bracket in our string let's define 2 values:d[j] = position of corresponding open bracket, or -1 if closing bracket doesn't belong to any regular bracket sequence. c[j] = position of earliest opening bracket, such that substring s(c[j], j) (both boundaries are inclusive) is a regular bracket sequence. Let's consider c[j] to be -1 if closing bracket doesn't belong to any regular bracket sequence. It can be seen, that c[j] defines the beginning position of the longest regular bracket sequence, which will end in position j. So, having c[j] answer for the problem can be easily calculated.Both d[j] and c[j] can be found with following algorithm, which uses stack.Iterate through the characters of the string.If current character is opening bracket, put its position into the stack.If current character is closing bracket, there are 2 subcases:Stack is empty - this means that current closing bracket doesn't have corresponding open one. Hence, both d[j] and c[j] are equal to -1. Stack is not empty - we will have position of the corresponding open bracket on the top of the stack - let's put it to d[j] and remove this position from the stack. Now it is obvious, that c[j] is equal at least to d[j]. But probably, there is a better value for c[j]. To find this out, we just need to look at the position d[j] - 1. If there is a closing bracket at this position, and c[d[j] - 1] is not -1, than we have 2 regular bracket sequences s(c[d[j] - 1], d[j] - 1) and s(d[j], j), which can be concatenated into one larger regular bracket sequence. So we put c[j] to be c[d[j] - 1] for this case.Problem D.This problem can be solved by careful case handling. Let's construct O(1) solution for it.First of all, let's define 2 functions:dist(speed, time) - calculates the distance will be covered in specified time, if car's current speed is speed. This function will not take car's speed limit into account. Also it assumes, that car is always driven with maximum acceleration a. It is obvious that required distance is equal to .travelTime(distance, speed) - calculates the time, required to travel specified distance, if car have starting speed equal to speed. This function will also take care about car's speed limit.We will have the following quadratic equation for time t: . This equation will have exactly 2 different roots. Using Viete's formulas it can be concluded, that one root of the equation is non-positive and other is non-negative. Let's define the larger root of the equation as tAll. It will be the answer, if there is no car's speed limit. To take the limit into account let's find the time, required to gain car's max speed. tMax = (v - speed) / a. If tMax ≥  tAll, function should just returns tAll as a result. Otherwise result is tMax hours to achieve car's maximal speed plus (distance - dist(speed, tMax)) / v hours to cover remaining distance.Having these functions, solution will be the following:If v ≤ w, answer is travelTime(l, 0).Calculate tw = w / a -  time, required to gain speed w.Consider dw = dist(0, tw).If dw ≥ d, we will pass the point there sign is placed before we gain speed w. Answer for this case is travelTime(l, 0) as well.Otherwise, we will gain speed w before the sign. Let's consider segment of the road [dw, d]. We need to find out the best strategy to drive it. It is obvious, that we definitely should have speed w at the both ends of this segment. Also we know, that acceleration is equal to deceleration. Taking these facts into account we can see, that the speed in the optimal solution will be symmetrical with respect to the middle of the segment [dw, d]. Hence answer for this case will be tw + 2 *  travelTime(0.5 * (d - dw), w) + travelTime(l - d, w).Problem E.Let's reduce the problem from the circle to the straight line. Perform the following actions to do it:Find the hill with the maximal height (if it is not unique, choose any).Rotate all the sequence in such a way that hill with maximal height goes first. For convenience, add one more hill with maximum height to the end of the sequence. (It will represent the first hill, which goes after the last in the circle order).Now we have almost the same problem on the straight line. One exception is that now first hill is doubled.General idea of the solution:Consider there is a pair of hills, such that these hills are visible from each other. Let's define hill with lower height (if heights are equal - with lower position) as responsible for adding this pair to the answer.From this point of view, hill x will adds to the answer 3 kinds of hills as his pair:First hill to the left of the x, which is strictly higher than x. (Let's define its position as l[x])First hill to the right of the x, which is strictly higher than x. (Let's call this hill y and define it's position as r[x]).All hills that are as high as x and are located between x and y. (Let's define this count as c[x]).Arrays r[x] and c[x] can be calculated by the following piece of code:c[n] = 0;for(int i = n - 1; i >= 0; --i) {    r[i] = i + 1;    while (r[i] < n && height[i] > height[r[i]]) r[i] = r[r[i]];    if (r[i] < n && height[i] == height[r[i]]) {        c[i] = c[r[i]] + 1;        r[i] = r[r[i]];    }}I am not going to prove here, that it works for the O(N) time, but believe it does :)Pay attention, that r[x] is undefined for hills with maximum height and this algorithm will find r[x] = n for such hills.Array l[x] can be found in a similar way.Having l[x], r[x] and c[x], it's not so difficult to calculate the answer. We should just notice, that:Each hill will add c[x] pairs to the answer.Each hill, lower than maximal, will also add 2 pairs (x, l[x]) and (x, r[x]) to the answer. The only corner case here is l[x] = 0 and r[x] = n, because (x, 0) and (x, n) is the same pair of hills in the original problem, where hills are circled.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/213",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.6,
            "reason": "宽松匹配: 包含题目编号 5 和字母"
          },
          "content_length": 6377
        },
        {
          "title": "C, D и E с CBR5 - разбор - Codeforces",
          "content": "Сначала хотел написать полный разбор, но как разбирать задачи A и B я не представляю :о) Разве что можно сказать, что на C++ чтобы читать до конца надо использовать while( gets( s ) ), а если вы не любите перенаправлять файлы и вводите тест прямо в консоль, то чтобы обозначить конец файла надо нажать Ctrl+Z.Задача СДавайте введем понятие баланса некоторого префикса подстроки - на сколько открывающихся скобок больше в этом префиксе, чем закрывающихся. Понятно, что некоторая строка является правильной скобочной подпоследовательностью, если для всей строки баланс равен нулю, а для любого ее префикса не отрицателен. Посчитаем баланс для каждого префикса данной нам в задаче строки и сложим их в массив prefs. Теперь рассмотрим любую подстроку это строки - пусть она идет от символа с позицией l включительно до символа в позиции r исключительно. Эта подстрока - правильная скобочная последовательность, если prefs[l] == prefs[r] и prefs[i] >= prefs[l] для любого i в интервале [l, r). Как нам теперь, зная это, найти максимальную подстроку правильную и их количество? Будем делать примерно так: поддерживать стек пар (баланс-позиция) - на какой позиции в строке впервые был замечен такой баланс, после которой еще не встречался меньший баланс. На самом деле можно даже хранить только позиции, потому что баланс всегда очевиден - в последнем элементе в стеке всегда будет текущий баланс, в предпоследнем на единицу меньше итд. Рассмотрим теперь скажем последовательность ((()())))(()). Балансы: 1,2,3,2,3,2,1,0,-1,0,1,0,-1Будем идти слева на право и поддерживать наш стек следующим образом: добавляя открывающуюся скобку добавлять в стек позицию этой скобки, а добавляя закрывающуюся удалять последний элемент из стека, улучшая ответ. Пример с нашей последовательносью:1. Помним, что на позиции 0 (то есть до добавления любой скобки) баланс был 0. То есть сейчас стек: 02. Добавляем первую скобку. Занесем ее позицию в стек. Стек: 0,13. Добавим вторую скобку. Занесем ее позицию в стек. Стек: 0,1,24. Аналогично для третьей скобки. Стек 0,1,2,35. Четвертая скобка - закрывающаяся. Соответственно удалим последний элемент из стека, Текущий стек: 0,1,2. Запоминаем, что мы нашли последоательность длины 2 (позиция-последний элемент в стеке после удаления, 4-2=2). 6. Пятая скобка - открывающаяся, добавим ее в стек: 0,1,2,57. Шестая скобка - закрывающаяся, удалим из стека последний элемент, запомним, что мы нашли последовательность длины 4. Стек: 0,1,28. Седьма скобка - закрывающаяся, удалим из стека последний элемент, запомнив, что мы нашли последовательность длины (7-1)=6. Стек: 0,1.9. Восьмая скобка - закрывающаяся, удалим из стека последний элемент, запомнив, что мы нашли последовательность длины (8-0)=8. Стек: 010. Девятая скобка - закрывающаяся, удалим из стека последний элемент. Стек: пустой.11. 10-ая скобка закрывающаяся, но стек и так пустой - ничего не меняем.12. Скобка открывающаяся, стек: 1113. Скобка открывающаяся, стек: 11,1214. Далее две закрывающихся скобки очистят стек и еще одна ничего не изменит, ответа больше 8 найдено не будет, таким образом мы нашли ответ 8.Задача DЭто задача хитрая на рассмотрение граничных случаев.Сначала случаи до столба:1. Самый простой - мы разгоняемся до макисимальной скорости, едем на ней участок и тормозим до скорости w. Достаточно просто - считаем время t1 и расстояние s1, проехав которое мы наберем макс. скорость, время t2 и расстояние s2, проехав которой мы с макс. скорости затормозим до w, проверяем, что сумма этих расстояний меньше d, прибавляем время t3=(d-s1-s2)/v, которое мы будем ехать с макс. скоростью. На второй участок мы попадем со скоростью w.2. Вариант второй - мы не успеваем разогнаться до максимальной скорости и затормозить до скорости w к столбу, то есть s1+s2 > d. Тогда все очевидно - ищем, до какой скорости мы можем разогнаться (я делал это бинарным поиском, но не сомневаюсь что это не обязательно :о)), и считаем сколько времени уйдет чтобы разогнаться до нее и затормозить с нее до w. На второй участок выходим со скоросью w.3. Третий случай - мы вообще за интервал d не успеваем даже разогнаться до w. Тогда проезжаем весь интервал d на разгоне, на второй участок выходим со скоростью, которую успели набрать.Тут есть корнер кейс, который зачем-то поместили в первый семпл - если w > v, и третий случай рассматривается до первого, и за интервал d нельзя достичь скорости w, но можно успеть достичь скорости v. Тогда можно ошибочно на первом интервале разгоняться до скорости большей v. Но наличие первого семпла спасало от такой ошибки (и меня от лишнего штрафа :о))На второй интервал мы выходим либо со скоростью w, если мы попали в первые два случая, либо со скоростью меньшей, если в третий. Теперь тут два достаточно простых случая - мы либо разгоняемся до максимальной и проезжаем часть дороги на максимальной скорости, либо, если мы не успеваем за оставшийся фрагмент дороги достичь максимальной скорости, просто проезжаем весь участок с ускорением a.Задача E.Задача подозрительно похожа на задачу С :о)Найдем максимальный элемент в последовательности и сдвинем все так, чтобы он оказался первым (или любой из них, если их несколько). Теперь, если не учиытвать максимальные холмы, мы можем полагать, что холмы расположены на не окружности, а в ряд, что упрощает задачу. Дальше отдельно решим для пар холмов, оба из которых не максимальной длины, для пар холмов, один из которых не максимальной длины, и для пар холмов, оба из которых максимальной длины.1. Как посчитать количество пар, где оба холма ниже максимального? Будем идти слева на право, поддерживая стек высот холмов, которые теоретически еще могут быть видны, и их количеств. Разумеется, этот стек всегда будет содержать высоты, идущие по убыванию. Добавляя очередной холм:1.а) если он максимальной длины, просто очистим стек (ничто не может быть видно, он все загородил), и НЕ улучшаем ответ, и НЕ добавляем его в стек, так как сейчас считаем ответ только для пар, в которых оба холма ниже максимального.1.б) иначе, пока последний элемент в стеке содержит высоту ниже текущего холма, удаляем этот элемент, прибавляя количество таких холмов к ответу (каждый из этих холмов виден с нашего более высокого).1.в.i) если после этого высота последнего элемента в стеке равна нашей, прибавим его количество и еще единицу, если в стеке хотя бы два элемента (потому что мы видим все холмы нашей высоты и еще ровно один выше, если он существует)1.в.ii) если же после этого высота последнего элемента в стеке выше нашей, то просто прибавляем к ответу единицу (мы видим только этот самый правый холм).1.в.iii) если же стек после 1.б. остался пустой, не меняем ответ.1.г) если последний элемент в стеке равен нашему, увеличим его количество. Иначе добавим в конец стека текущий элемент с количеством=1.1.д) пройдя так по всему массиву мы посчитаем количество пар, где оба холма ниже макисимального2. Как посчитать количество пар, где один из холмов максимальный, а второй нет? Очень легко, начиная от каждого максимального холма идем влево и вправо пока не встретим другой максимальный холм, и считаем сколько холмов мы видим. Это будет линейное время, потому что каждый элемент будет пройден ровно дважды: от холма максимальной высоты слева от него и от холма максимальной высоты справа от него.3. Как посчитать количество пар, где оба холма максимальны? n*(n-1)/2 где n - количество холмов максимальной высоты.Затем суммируем ответы из 1, 2 и 3.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/204",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.6,
            "reason": "宽松匹配: 包含题目编号 5 和字母"
          },
          "content_length": 7401
        }
      ],
      "code_examples": [],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nbool isValidName(const string& s) {\n    if (s.empty()) return false;\n    for (char c : s) {\n        if (!isalnum(c))\n            return false;\n    }\n    return true;\n}\n\nbool isValidMessageText(const string& s) {\n    for (char c : s) {\n        if (!isalnum(c) && c != ' ')\n            return false;\n    }\n    return true;\n}\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    set<string> chatParticipants;\n    int numCommands = 0;\n\n    while (!inf.eof()) {\n        string line = inf.readLine();\n        numCommands++;\n        ensuref(numCommands <= 100, \"Number of commands exceeds 100\");\n\n        ensuref(line.length() <= 100, \"Line length exceeds 100 characters\");\n        ensuref(!line.empty(), \"Empty line is not allowed\");\n\n        if (line[0] == '+') {\n            // Add command\n            ensuref(line.length() >= 2, \"Add command: name is missing\");\n\n            string name = line.substr(1);\n            ensuref(isValidName(name), \"Invalid name in Add command: name=\\\"%s\\\"\", name.c_str());\n            ensuref(chatParticipants.count(name) == 0, \"Add command: person \\\"%s\\\" is already in the chat\", name.c_str());\n\n            chatParticipants.insert(name);\n        } else if (line[0] == '-') {\n            // Remove command\n            ensuref(line.length() >= 2, \"Remove command: name is missing\");\n\n            string name = line.substr(1);\n            ensuref(isValidName(name), \"Invalid name in Remove command: name=\\\"%s\\\"\", name.c_str());\n            ensuref(chatParticipants.count(name) == 1, \"Remove command: person \\\"%s\\\" is not in the chat\", name.c_str());\n\n            chatParticipants.erase(name);\n        } else {\n            // Send command\n            size_t pos = line.find(':');\n            ensuref(pos != string::npos, \"Send command: ':' not found\");\n\n            string sender_name = line.substr(0, pos);\n            ensuref(isValidName(sender_name), \"Invalid sender_name in Send command: sender_name=\\\"%s\\\"\", sender_name.c_str());\n            ensuref(chatParticipants.count(sender_name) == 1, \"Send command: sender \\\"%s\\\" is not in the chat\", sender_name.c_str());\n\n            string message_text = line.substr(pos + 1);\n            if (!message_text.empty()) {\n                ensuref(message_text.front() != ' ', \"Invalid message_text: starts with space\");\n                ensuref(message_text.back() != ' ', \"Invalid message_text: ends with space\");\n                ensuref(isValidMessageText(message_text), \"Invalid message_text: contains invalid characters\");\n            }\n        }\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nbool isValidName(const string& s) {\n    if (s.empty()) return false;\n    for (char c : s) {\n        if (!isalnum(c))\n            return false;\n    }\n    return true;\n}\n\nbool isValidMessageText(const string& s) {\n    for (char c : s) {\n        if (!isalnum(c) && c != ' ')\n            return false;\n    }\n    return true;\n}\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    set<string> chatParticipants;\n    int numCommands = 0;\n\n    while (!inf.eof()) {\n        string line = inf.readLine();\n        numCommands++;\n        ensuref(numCommands <= 100, \"Number of commands exceeds 100\");\n\n        ensuref(line.length() <= 100, \"Line length exceeds 100 characters\");\n        ensuref(!line.empty(), \"Empty line is not allowed\");\n\n        if (line[0] == '+') {\n            // Add command\n            ensuref(line.length() >= 2, \"Add command: name is missing\");\n\n            string name = line.substr(1);\n            ensuref(isValidName(name), \"Invalid name in Add command: name=\\\"%s\\\"\", name.c_str());\n            ensuref(chatParticipants.count(name) == 0, \"Add command: person \\\"%s\\\" is already in the chat\", name.c_str());\n\n            chatParticipants.insert(name);\n        } else if (line[0] == '-') {\n            // Remove command\n            ensuref(line.length() >= 2, \"Remove command: name is missing\");\n\n            string name = line.substr(1);\n            ensuref(isValidName(name), \"Invalid name in Remove command: name=\\\"%s\\\"\", name.c_str());\n            ensuref(chatParticipants.count(name) == 1, \"Remove command: person \\\"%s\\\" is not in the chat\", name.c_str());\n\n            chatParticipants.erase(name);\n        } else {\n            // Send command\n            size_t pos = line.find(':');\n            ensuref(pos != string::npos, \"Send command: ':' not found\");\n\n            string sender_name = line.substr(0, pos);\n            ensuref(isValidName(sender_name), \"Invalid sender_name in Send command: sender_name=\\\"%s\\\"\", sender_name.c_str());\n            ensuref(chatParticipants.count(sender_name) == 1, \"Send command: sender \\\"%s\\\" is not in the chat\", sender_name.c_str());\n\n            string message_text = line.substr(pos + 1);\n            if (!message_text.empty()) {\n                ensuref(message_text.front() != ' ', \"Invalid message_text: starts with space\");\n                ensuref(message_text.back() != ' ', \"Invalid message_text: ends with space\");\n                ensuref(isValidMessageText(message_text), \"Invalid message_text: contains invalid characters\");\n            }\n        }\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nbool isValidName(const string& s) {\n    if (s.empty()) return false;\n    for (char c : s) {\n        if (!isalnum(c))\n            return false;\n    }\n    return true;\n}\n\nbool isValidMessageText(const string& s) {\n    for (char c : s) {\n        if (!isalnum(c) && c != ' ')\n            return false;\n    }\n    return true;\n}\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    set<string> chatParticipants;\n    int numCommands = 0;\n\n    while (!inf.eof()) {\n        string line = inf.readLine();\n        numCommands++;\n        ensuref(numCommands <= 100, \"Number of commands exceeds 100\");\n\n        ensuref(line.length() <= 100, \"Line length exceeds 100 characters\");\n        ensuref(!line.empty(), \"Empty line is not allowed\");\n\n        if (line[0] == '+') {\n            // Add command\n            ensuref(line.length() >= 2, \"Add command: name is missing\");\n\n            string name = line.substr(1);\n            ensuref(isValidName(name), \"Invalid name in Add command: name=\\\"%s\\\"\", name.c_str());\n            ensuref(chatParticipants.count(name) == 0, \"Add command: person \\\"%s\\\" is already in the chat\", name.c_str());\n\n            chatParticipants.insert(name);\n        } else if (line[0] == '-') {\n            // Remove command\n            ensuref(line.length() >= 2, \"Remove command: name is missing\");\n\n            string name = line.substr(1);\n            ensuref(isValidName(name), \"Invalid name in Remove command: name=\\\"%s\\\"\", name.c_str());\n            ensuref(chatParticipants.count(name) == 1, \"Remove command: person \\\"%s\\\" is not in the chat\", name.c_str());\n\n            chatParticipants.erase(name);\n        } else {\n            // Send command\n            size_t pos = line.find(':');\n            ensuref(pos != string::npos, \"Send command: ':' not found\");\n\n            string sender_name = line.substr(0, pos);\n            ensuref(isValidName(sender_name), \"Invalid sender_name in Send command: sender_name=\\\"%s\\\"\", sender_name.c_str());\n            ensuref(chatParticipants.count(sender_name) == 1, \"Send command: sender \\\"%s\\\" is not in the chat\", sender_name.c_str());\n\n            string message_text = line.substr(pos + 1);\n            if (!message_text.empty()) {\n                ensuref(message_text.front() != ' ', \"Invalid message_text: starts with space\");\n                ensuref(message_text.back() != ' ', \"Invalid message_text: ends with space\");\n                ensuref(isValidMessageText(message_text), \"Invalid message_text: contains invalid characters\");\n            }\n        }\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int MAX_LINE_LENGTH = 100;\n\nstring generateName(int maxLength) {\n    int len = rnd.next(1, maxLength);\n    string s = \"\";\n    for (int i = 0; i < len; ++i) {\n        char c;\n        int type = rnd.next(3);\n        if (type == 0) {\n            c = 'a' + rnd.next(26);\n        } else if (type == 1) {\n            c = 'A' + rnd.next(26);\n        } else {\n            c = '0' + rnd.next(10);\n        }\n        s += c;\n    }\n    return s;\n}\n\nstring generateMessageText(int maxLength) {\n    int len = rnd.next(0, maxLength);\n    string s = \"\";\n    for (int i = 0; i < len; ++i) {\n        int type = rnd.next(4);\n        if (type == 0) {\n            s += 'a' + rnd.next(26);\n        } else if (type == 1) {\n            s += 'A' + rnd.next(26);\n        } else if (type == 2) {\n            s += '0' + rnd.next(10);\n        } else if (type == 3) {\n            s += ' ';\n        }\n    }\n    // Ensure that message doesn't start or end with a space\n    while (s.size() > 0 && s.front() == ' ') {\n        s.erase(s.begin());\n    }\n    while (s.size() > 0 && s.back() == ' ') {\n        s.pop_back();\n    }\n    return s;\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    if (type == \"random\") {\n        vector<string> commands;\n        set<string> participants;\n        set<string> allNames;\n\n        for (int i = 0; i < n; ++i) {\n            vector<string> possible_commands;\n\n            // Determine possible command types based on participants\n            if (participants.size() == 0) {\n                // Cannot 'Remove' or 'Send'\n                possible_commands.push_back(\"Add\");\n            } else if (participants.size() == 1000) {\n                // Maximum participants reached\n                possible_commands.push_back(\"Remove\");\n                possible_commands.push_back(\"Send\");\n            } else {\n                // Can 'Add', 'Remove', 'Send'\n                possible_commands.push_back(\"Add\");\n                possible_commands.push_back(\"Remove\");\n                possible_commands.push_back(\"Send\");\n            }\n\n            // Randomly select a command type from possible_commands\n            string command_type = possible_commands[rnd.next(possible_commands.size())];\n\n            if (command_type == \"Add\") {\n                // Need to add a name not already in participants\n                string name;\n                int maxNameLength = MAX_LINE_LENGTH - 1; // For '+' or '-'\n                do {\n                    name = generateName(min(maxNameLength, 20)); // Limit to 20 to avoid exceeding line length\n                } while (participants.count(name));\n                participants.insert(name);\n                allNames.insert(name);\n                string command = \"+\" + name;\n                commands.push_back(command);\n            } else if (command_type == \"Remove\") {\n                // Need to remove a name from participants\n                // Randomly pick a name from participants\n                int idx = rnd.next(participants.size());\n                auto it = participants.begin();\n                advance(it, idx);\n                string name = *it;\n                participants.erase(it);\n                string command = \"-\" + name;\n                commands.push_back(command);\n            } else if (command_type == \"Send\") {\n                // Need a sender from participants\n                int idx = rnd.next(participants.size());\n                auto it = participants.begin();\n                advance(it, idx);\n                string sender_name = *it;\n\n                // Now generate message text\n                int maxMessageTextLength = MAX_LINE_LENGTH - sender_name.size() - 1; // For ':'\n                if (maxMessageTextLength < 0) {\n                    // Name too long, cannot create command\n                    participants.erase(sender_name);\n                    --i;\n                    continue;\n                }\n\n                string message_text = generateMessageText(maxMessageTextLength);\n                string command = sender_name + \":\" + message_text;\n                commands.push_back(command);\n            }\n        }\n\n        // Output the commands\n        for (string cmd : commands) {\n            printf(\"%s\\n\", cmd.c_str());\n        }\n    } else if (type == \"empty_messages\") {\n        vector<string> commands;\n        set<string> participants;\n        // First, add a participant\n        string name = \"user\";\n        participants.insert(name);\n        commands.push_back(\"+\" + name);\n        // Now send messages with empty text\n        int num_sends = min(n - 1, 99);\n        string sender_name = name;\n        for (int i = 0; i < num_sends; ++i) {\n            string command = sender_name + \":\";\n            commands.push_back(command);\n        }\n        // Output the commands\n        for (string cmd : commands) {\n            printf(\"%s\\n\", cmd.c_str());\n        }\n    } else if (type == \"max_length_messages\") {\n        vector<string> commands;\n        set<string> participants;\n        // Use a short sender_name to maximize message_text length\n        string sender_name = \"u\";\n        participants.insert(sender_name);\n        commands.push_back(\"+\" + sender_name);\n\n        int num_sends = min(n - 1, 99);\n        for (int i = 0; i < num_sends; ++i) {\n            int maxMessageTextLength = MAX_LINE_LENGTH - sender_name.size() - 1;\n            string message_text = string(maxMessageTextLength, 'a'); // Message of 'a's\n            string command = sender_name + \":\" + message_text;\n            commands.push_back(command);\n        }\n        // Output the commands\n        for (string cmd : commands) {\n            printf(\"%s\\n\", cmd.c_str());\n        }\n    } else if (type == \"max_length_names\") {\n        vector<string> commands;\n        set<string> participants;\n        // Generate maximum length names\n        int name_length = MAX_LINE_LENGTH - 1; // For '+' or '-' in 'Add' and 'Remove' commands\n\n        string name(name_length, 'a');\n        participants.insert(name);\n        commands.push_back(\"+\" + name);\n\n        int num_commands = n - 1;\n        for (int i = 0; i < num_commands; ++i) {\n            // Alternate between 'Send' and 'Remove'/'Add'\n            if (i % 3 == 0) {\n                // 'Send' command\n                int maxMessageTextLength = MAX_LINE_LENGTH - name.size() - 1;\n                string message_text = \"message\";\n                if ((int)message_text.size() > maxMessageTextLength) {\n                    message_text = message_text.substr(0, maxMessageTextLength);\n                }\n                string command = name + \":\" + message_text;\n                commands.push_back(command);\n            } else if (i % 3 == 1) {\n                // Remove the participant\n                participants.erase(name);\n                string command = \"-\" + name;\n                commands.push_back(command);\n            } else {\n                // Add the participant back\n                participants.insert(name);\n                string command = \"+\" + name;\n                commands.push_back(command);\n            }\n        }\n        // Adjust the number of commands to not exceed n\n        while ((int)commands.size() > n) {\n            commands.pop_back();\n        }\n        // Output the commands\n        for (string cmd : commands) {\n            printf(\"%s\\n\", cmd.c_str());\n        }\n    } else if (type == \"only_add_remove\") {\n        vector<string> commands;\n        set<string> participants;\n        int num_commands = n;\n        for (int i = 0; i < num_commands; ++i) {\n            if (i % 2 == 0) {\n                // Add a participant\n                string name = \"user\" + to_string(i / 2);\n                participants.insert(name);\n                string command = \"+\" + name;\n                commands.push_back(command);\n            } else {\n                // Remove a participant\n                string name = \"user\" + to_string(i / 2);\n                participants.erase(name);\n                string command = \"-\" + name;\n                commands.push_back(command);\n            }\n        }\n        // Output the commands\n        for (string cmd : commands) {\n            printf(\"%s\\n\", cmd.c_str());\n        }\n    } else if (type == \"single_participant\") {\n        vector<string> commands;\n        string name = \"user\";\n        commands.push_back(\"+\" + name);\n        for (int i = 1; i < n; ++i) {\n            string message_text = \"hello\";\n            string command = name + \":\" + message_text;\n            commands.push_back(command);\n        }\n        // Output the commands\n        for (string cmd : commands) {\n            printf(\"%s\\n\", cmd.c_str());\n        }\n    } else if (type == \"no_commands\") {\n        // Do nothing\n    }\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int MAX_LINE_LENGTH = 100;\n\nstring generateName(int maxLength) {\n    int len = rnd.next(1, maxLength);\n    string s = \"\";\n    for (int i = 0; i < len; ++i) {\n        char c;\n        int type = rnd.next(3);\n        if (type == 0) {\n            c = 'a' + rnd.next(26);\n        } else if (type == 1) {\n            c = 'A' + rnd.next(26);\n        } else {\n            c = '0' + rnd.next(10);\n        }\n        s += c;\n    }\n    return s;\n}\n\nstring generateMessageText(int maxLength) {\n    int len = rnd.next(0, maxLength);\n    string s = \"\";\n    for (int i = 0; i < len; ++i) {\n        int type = rnd.next(4);\n        if (type == 0) {\n            s += 'a' + rnd.next(26);\n        } else if (type == 1) {\n            s += 'A' + rnd.next(26);\n        } else if (type == 2) {\n            s += '0' + rnd.next(10);\n        } else if (type == 3) {\n            s += ' ';\n        }\n    }\n    // Ensure that message doesn't start or end with a space\n    while (s.size() > 0 && s.front() == ' ') {\n        s.erase(s.begin());\n    }\n    while (s.size() > 0 && s.back() == ' ') {\n        s.pop_back();\n    }\n    return s;\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    if (type == \"random\") {\n        vector<string> commands;\n        set<string> participants;\n        set<string> allNames;\n\n        for (int i = 0; i < n; ++i) {\n            vector<string> possible_commands;\n\n            // Determine possible command types based on participants\n            if (participants.size() == 0) {\n                // Cannot 'Remove' or 'Send'\n                possible_commands.push_back(\"Add\");\n            } else if (participants.size() == 1000) {\n                // Maximum participants reached\n                possible_commands.push_back(\"Remove\");\n                possible_commands.push_back(\"Send\");\n            } else {\n                // Can 'Add', 'Remove', 'Send'\n                possible_commands.push_back(\"Add\");\n                possible_commands.push_back(\"Remove\");\n                possible_commands.push_back(\"Send\");\n            }\n\n            // Randomly select a command type from possible_commands\n            string command_type = possible_commands[rnd.next(possible_commands.size())];\n\n            if (command_type == \"Add\") {\n                // Need to add a name not already in participants\n                string name;\n                int maxNameLength = MAX_LINE_LENGTH - 1; // For '+' or '-'\n                do {\n                    name = generateName(min(maxNameLength, 20)); // Limit to 20 to avoid exceeding line length\n                } while (participants.count(name));\n                participants.insert(name);\n                allNames.insert(name);\n                string command = \"+\" + name;\n                commands.push_back(command);\n            } else if (command_type == \"Remove\") {\n                // Need to remove a name from participants\n                // Randomly pick a name from participants\n                int idx = rnd.next(participants.size());\n                auto it = participants.begin();\n                advance(it, idx);\n                string name = *it;\n                participants.erase(it);\n                string command = \"-\" + name;\n                commands.push_back(command);\n            } else if (command_type == \"Send\") {\n                // Need a sender from participants\n                int idx = rnd.next(participants.size());\n                auto it = participants.begin();\n                advance(it, idx);\n                string sender_name = *it;\n\n                // Now generate message text\n                int maxMessageTextLength = MAX_LINE_LENGTH - sender_name.size() - 1; // For ':'\n                if (maxMessageTextLength < 0) {\n                    // Name too long, cannot create command\n                    participants.erase(sender_name);\n                    --i;\n                    continue;\n                }\n\n                string message_text = generateMessageText(maxMessageTextLength);\n                string command = sender_name + \":\" + message_text;\n                commands.push_back(command);\n            }\n        }\n\n        // Output the commands\n        for (string cmd : commands) {\n            printf(\"%s\\n\", cmd.c_str());\n        }\n    } else if (type == \"empty_messages\") {\n        vector<string> commands;\n        set<string> participants;\n        // First, add a participant\n        string name = \"user\";\n        participants.insert(name);\n        commands.push_back(\"+\" + name);\n        // Now send messages with empty text\n        int num_sends = min(n - 1, 99);\n        string sender_name = name;\n        for (int i = 0; i < num_sends; ++i) {\n            string command = sender_name + \":\";\n            commands.push_back(command);\n        }\n        // Output the commands\n        for (string cmd : commands) {\n            printf(\"%s\\n\", cmd.c_str());\n        }\n    } else if (type == \"max_length_messages\") {\n        vector<string> commands;\n        set<string> participants;\n        // Use a short sender_name to maximize message_text length\n        string sender_name = \"u\";\n        participants.insert(sender_name);\n        commands.push_back(\"+\" + sender_name);\n\n        int num_sends = min(n - 1, 99);\n        for (int i = 0; i < num_sends; ++i) {\n            int maxMessageTextLength = MAX_LINE_LENGTH - sender_name.size() - 1;\n            string message_text = string(maxMessageTextLength, 'a'); // Message of 'a's\n            string command = sender_name + \":\" + message_text;\n            commands.push_back(command);\n        }\n        // Output the commands\n        for (string cmd : commands) {\n            printf(\"%s\\n\", cmd.c_str());\n        }\n    } else if (type == \"max_length_names\") {\n        vector<string> commands;\n        set<string> participants;\n        // Generate maximum length names\n        int name_length = MAX_LINE_LENGTH - 1; // For '+' or '-' in 'Add' and 'Remove' commands\n\n        string name(name_length, 'a');\n        participants.insert(name);\n        commands.push_back(\"+\" + name);\n\n        int num_commands = n - 1;\n        for (int i = 0; i < num_commands; ++i) {\n            // Alternate between 'Send' and 'Remove'/'Add'\n            if (i % 3 == 0) {\n                // 'Send' command\n                int maxMessageTextLength = MAX_LINE_LENGTH - name.size() - 1;\n                string message_text = \"message\";\n                if ((int)message_text.size() > maxMessageTextLength) {\n                    message_text = message_text.substr(0, maxMessageTextLength);\n                }\n                string command = name + \":\" + message_text;\n                commands.push_back(command);\n            } else if (i % 3 == 1) {\n                // Remove the participant\n                participants.erase(name);\n                string command = \"-\" + name;\n                commands.push_back(command);\n            } else {\n                // Add the participant back\n                participants.insert(name);\n                string command = \"+\" + name;\n                commands.push_back(command);\n            }\n        }\n        // Adjust the number of commands to not exceed n\n        while ((int)commands.size() > n) {\n            commands.pop_back();\n        }\n        // Output the commands\n        for (string cmd : commands) {\n            printf(\"%s\\n\", cmd.c_str());\n        }\n    } else if (type == \"only_add_remove\") {\n        vector<string> commands;\n        set<string> participants;\n        int num_commands = n;\n        for (int i = 0; i < num_commands; ++i) {\n            if (i % 2 == 0) {\n                // Add a participant\n                string name = \"user\" + to_string(i / 2);\n                participants.insert(name);\n                string command = \"+\" + name;\n                commands.push_back(command);\n            } else {\n                // Remove a participant\n                string name = \"user\" + to_string(i / 2);\n                participants.erase(name);\n                string command = \"-\" + name;\n                commands.push_back(command);\n            }\n        }\n        // Output the commands\n        for (string cmd : commands) {\n            printf(\"%s\\n\", cmd.c_str());\n        }\n    } else if (type == \"single_participant\") {\n        vector<string> commands;\n        string name = \"user\";\n        commands.push_back(\"+\" + name);\n        for (int i = 1; i < n; ++i) {\n            string message_text = \"hello\";\n            string command = name + \":\" + message_text;\n            commands.push_back(command);\n        }\n        // Output the commands\n        for (string cmd : commands) {\n            printf(\"%s\\n\", cmd.c_str());\n        }\n    } else if (type == \"no_commands\") {\n        // Do nothing\n    }\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 0 -type no_commands\n\n./gen -n 1 -type only_add_remove\n./gen -n 2 -type only_add_remove\n./gen -n 10 -type only_add_remove\n./gen -n 100 -type only_add_remove\n\n./gen -n 1 -type single_participant\n./gen -n 5 -type single_participant\n./gen -n 10 -type single_participant\n./gen -n 100 -type single_participant\n\n./gen -n 1 -type empty_messages\n./gen -n 5 -type empty_messages\n./gen -n 10 -type empty_messages\n./gen -n 100 -type empty_messages\n\n./gen -n 1 -type max_length_messages\n./gen -n 5 -type max_length_messages\n./gen -n 10 -type max_length_messages\n./gen -n 100 -type max_length_messages\n\n./gen -n 1 -type max_length_names\n./gen -n 5 -type max_length_names\n./gen -n 10 -type max_length_names\n./gen -n 100 -type max_length_names\n\n./gen -n 1 -type random\n./gen -n 5 -type random\n./gen -n 10 -type random\n./gen -n 50 -type random\n./gen -n 100 -type random\n\n# Additional random tests\n./gen -n 100 -type random\n./gen -n 100 -type random\n./gen -n 100 -type random\n./gen -n 100 -type random\n./gen -n 100 -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:39:38.423730",
        "total_tutorials": 3,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "5/B",
      "title": "B. Center Alignment",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test64 megabytes",
      "input_spec": "InputThe input file consists of one or more lines, each of the lines contains Latin letters, digits and/or spaces. The lines cannot start or end with a space. It is guaranteed that at least one of the lines has positive length. The length of each line and the total amount of the lines do not exceed 1000.",
      "output_spec": "OutputFormat the given text, aligning it center. Frame the whole text with characters «*» of the minimum size. If a line cannot be aligned perfectly (for example, the line has even length, while the width of the block is uneven), you should place such lines rounding down the distance to the left or to the right edge and bringing them closer left or right alternatively (you should start with bringing left). Study the sample tests carefully to understand the output format better.",
      "sample_tests": "ExamplesInputCopyThis  isCodeforcesBetaRound5OutputCopy************* This  is **          **Codeforces**   Beta   **  Round   **     5    *************InputCopywelcome to theCodeforcesBetaRound 5andgood luckOutputCopy*****************welcome to the**  Codeforces  **     Beta     **   Round 5    **              **      and     **  good luck   *****************",
      "description": "B. Center Alignment\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test64 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe input file consists of one or more lines, each of the lines contains Latin letters, digits and/or spaces. The lines cannot start or end with a space. It is guaranteed that at least one of the lines has positive length. The length of each line and the total amount of the lines do not exceed 1000.\n\nOutputFormat the given text, aligning it center. Frame the whole text with characters «*» of the minimum size. If a line cannot be aligned perfectly (for example, the line has even length, while the width of the block is uneven), you should place such lines rounding down the distance to the left or to the right edge and bringing them closer left or right alternatively (you should start with bringing left). Study the sample tests carefully to understand the output format better.\n\nInputCopyThis  isCodeforcesBetaRound5OutputCopy************* This  is **          **Codeforces**   Beta   **  Round   **     5    *************InputCopywelcome to theCodeforcesBetaRound 5andgood luckOutputCopy*****************welcome to the**  Codeforces  **     Beta     **   Round 5    **              **      and     **  good luck   *****************\n\nInputCopyThis  isCodeforcesBetaRound5\n\nOutputCopy************* This  is **          **Codeforces**   Beta   **  Round   **     5    *************\n\nInputCopywelcome to theCodeforcesBetaRound 5andgood luck\n\nOutputCopy*****************welcome to the**  Codeforces  **     Beta     **   Round 5    **              **      and     **  good luck   *****************",
      "solutions": [
        {
          "title": "Codeforces Beta Round #5 - Codeforces",
          "content": "Welcome and good luck on the round! I'd like to remind that if you have any questions on the problems, the best way to ask them is to use the web interface on the problems page. Later in the same post we will discuss the round. Wish you high rating,MikeMirzayanov.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/196",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 264
        },
        {
          "title": "Codeforces Beta Round #5 - Tutorial - Codeforces",
          "content": "As there is no tutorial of Codeforces Beta Round #5 in English, I have decided to write this one. Possibly, some ideas will be similar to ones, expressed in Russian tutorial made by SkidanovAlex, but I hope everybody will find some useful in this problem analysis too.Problems A and B.Both are implementation problems. The only difficult, many participants faced with - to read data correctly. It is recommended to use gets(s) or getline(cin, s) in C++, readLine() method of BufferedReader class in Java.Problem C.First of all, for each closing bracket in our string let's define 2 values:d[j] = position of corresponding open bracket, or -1 if closing bracket doesn't belong to any regular bracket sequence. c[j] = position of earliest opening bracket, such that substring s(c[j], j) (both boundaries are inclusive) is a regular bracket sequence. Let's consider c[j] to be -1 if closing bracket doesn't belong to any regular bracket sequence. It can be seen, that c[j] defines the beginning position of the longest regular bracket sequence, which will end in position j. So, having c[j] answer for the problem can be easily calculated.Both d[j] and c[j] can be found with following algorithm, which uses stack.Iterate through the characters of the string.If current character is opening bracket, put its position into the stack.If current character is closing bracket, there are 2 subcases:Stack is empty - this means that current closing bracket doesn't have corresponding open one. Hence, both d[j] and c[j] are equal to -1. Stack is not empty - we will have position of the corresponding open bracket on the top of the stack - let's put it to d[j] and remove this position from the stack. Now it is obvious, that c[j] is equal at least to d[j]. But probably, there is a better value for c[j]. To find this out, we just need to look at the position d[j] - 1. If there is a closing bracket at this position, and c[d[j] - 1] is not -1, than we have 2 regular bracket sequences s(c[d[j] - 1], d[j] - 1) and s(d[j], j), which can be concatenated into one larger regular bracket sequence. So we put c[j] to be c[d[j] - 1] for this case.Problem D.This problem can be solved by careful case handling. Let's construct O(1) solution for it.First of all, let's define 2 functions:dist(speed, time) - calculates the distance will be covered in specified time, if car's current speed is speed. This function will not take car's speed limit into account. Also it assumes, that car is always driven with maximum acceleration a. It is obvious that required distance is equal to .travelTime(distance, speed) - calculates the time, required to travel specified distance, if car have starting speed equal to speed. This function will also take care about car's speed limit.We will have the following quadratic equation for time t: . This equation will have exactly 2 different roots. Using Viete's formulas it can be concluded, that one root of the equation is non-positive and other is non-negative. Let's define the larger root of the equation as tAll. It will be the answer, if there is no car's speed limit. To take the limit into account let's find the time, required to gain car's max speed. tMax = (v - speed) / a. If tMax ≥  tAll, function should just returns tAll as a result. Otherwise result is tMax hours to achieve car's maximal speed plus (distance - dist(speed, tMax)) / v hours to cover remaining distance.Having these functions, solution will be the following:If v ≤ w, answer is travelTime(l, 0).Calculate tw = w / a -  time, required to gain speed w.Consider dw = dist(0, tw).If dw ≥ d, we will pass the point there sign is placed before we gain speed w. Answer for this case is travelTime(l, 0) as well.Otherwise, we will gain speed w before the sign. Let's consider segment of the road [dw, d]. We need to find out the best strategy to drive it. It is obvious, that we definitely should have speed w at the both ends of this segment. Also we know, that acceleration is equal to deceleration. Taking these facts into account we can see, that the speed in the optimal solution will be symmetrical with respect to the middle of the segment [dw, d]. Hence answer for this case will be tw + 2 *  travelTime(0.5 * (d - dw), w) + travelTime(l - d, w).Problem E.Let's reduce the problem from the circle to the straight line. Perform the following actions to do it:Find the hill with the maximal height (if it is not unique, choose any).Rotate all the sequence in such a way that hill with maximal height goes first. For convenience, add one more hill with maximum height to the end of the sequence. (It will represent the first hill, which goes after the last in the circle order).Now we have almost the same problem on the straight line. One exception is that now first hill is doubled.General idea of the solution:Consider there is a pair of hills, such that these hills are visible from each other. Let's define hill with lower height (if heights are equal - with lower position) as responsible for adding this pair to the answer.From this point of view, hill x will adds to the answer 3 kinds of hills as his pair:First hill to the left of the x, which is strictly higher than x. (Let's define its position as l[x])First hill to the right of the x, which is strictly higher than x. (Let's call this hill y and define it's position as r[x]).All hills that are as high as x and are located between x and y. (Let's define this count as c[x]).Arrays r[x] and c[x] can be calculated by the following piece of code:c[n] = 0;for(int i = n - 1; i >= 0; --i) {    r[i] = i + 1;    while (r[i] < n && height[i] > height[r[i]]) r[i] = r[r[i]];    if (r[i] < n && height[i] == height[r[i]]) {        c[i] = c[r[i]] + 1;        r[i] = r[r[i]];    }}I am not going to prove here, that it works for the O(N) time, but believe it does :)Pay attention, that r[x] is undefined for hills with maximum height and this algorithm will find r[x] = n for such hills.Array l[x] can be found in a similar way.Having l[x], r[x] and c[x], it's not so difficult to calculate the answer. We should just notice, that:Each hill will add c[x] pairs to the answer.Each hill, lower than maximal, will also add 2 pairs (x, l[x]) and (x, r[x]) to the answer. The only corner case here is l[x] = 0 and r[x] = n, because (x, 0) and (x, n) is the same pair of hills in the original problem, where hills are circled.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/213",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.6,
            "reason": "宽松匹配: 包含题目编号 5 和字母"
          },
          "content_length": 6377
        },
        {
          "title": "C, D и E с CBR5 - разбор - Codeforces",
          "content": "Сначала хотел написать полный разбор, но как разбирать задачи A и B я не представляю :о) Разве что можно сказать, что на C++ чтобы читать до конца надо использовать while( gets( s ) ), а если вы не любите перенаправлять файлы и вводите тест прямо в консоль, то чтобы обозначить конец файла надо нажать Ctrl+Z.Задача СДавайте введем понятие баланса некоторого префикса подстроки - на сколько открывающихся скобок больше в этом префиксе, чем закрывающихся. Понятно, что некоторая строка является правильной скобочной подпоследовательностью, если для всей строки баланс равен нулю, а для любого ее префикса не отрицателен. Посчитаем баланс для каждого префикса данной нам в задаче строки и сложим их в массив prefs. Теперь рассмотрим любую подстроку это строки - пусть она идет от символа с позицией l включительно до символа в позиции r исключительно. Эта подстрока - правильная скобочная последовательность, если prefs[l] == prefs[r] и prefs[i] >= prefs[l] для любого i в интервале [l, r). Как нам теперь, зная это, найти максимальную подстроку правильную и их количество? Будем делать примерно так: поддерживать стек пар (баланс-позиция) - на какой позиции в строке впервые был замечен такой баланс, после которой еще не встречался меньший баланс. На самом деле можно даже хранить только позиции, потому что баланс всегда очевиден - в последнем элементе в стеке всегда будет текущий баланс, в предпоследнем на единицу меньше итд. Рассмотрим теперь скажем последовательность ((()())))(()). Балансы: 1,2,3,2,3,2,1,0,-1,0,1,0,-1Будем идти слева на право и поддерживать наш стек следующим образом: добавляя открывающуюся скобку добавлять в стек позицию этой скобки, а добавляя закрывающуюся удалять последний элемент из стека, улучшая ответ. Пример с нашей последовательносью:1. Помним, что на позиции 0 (то есть до добавления любой скобки) баланс был 0. То есть сейчас стек: 02. Добавляем первую скобку. Занесем ее позицию в стек. Стек: 0,13. Добавим вторую скобку. Занесем ее позицию в стек. Стек: 0,1,24. Аналогично для третьей скобки. Стек 0,1,2,35. Четвертая скобка - закрывающаяся. Соответственно удалим последний элемент из стека, Текущий стек: 0,1,2. Запоминаем, что мы нашли последоательность длины 2 (позиция-последний элемент в стеке после удаления, 4-2=2). 6. Пятая скобка - открывающаяся, добавим ее в стек: 0,1,2,57. Шестая скобка - закрывающаяся, удалим из стека последний элемент, запомним, что мы нашли последовательность длины 4. Стек: 0,1,28. Седьма скобка - закрывающаяся, удалим из стека последний элемент, запомнив, что мы нашли последовательность длины (7-1)=6. Стек: 0,1.9. Восьмая скобка - закрывающаяся, удалим из стека последний элемент, запомнив, что мы нашли последовательность длины (8-0)=8. Стек: 010. Девятая скобка - закрывающаяся, удалим из стека последний элемент. Стек: пустой.11. 10-ая скобка закрывающаяся, но стек и так пустой - ничего не меняем.12. Скобка открывающаяся, стек: 1113. Скобка открывающаяся, стек: 11,1214. Далее две закрывающихся скобки очистят стек и еще одна ничего не изменит, ответа больше 8 найдено не будет, таким образом мы нашли ответ 8.Задача DЭто задача хитрая на рассмотрение граничных случаев.Сначала случаи до столба:1. Самый простой - мы разгоняемся до макисимальной скорости, едем на ней участок и тормозим до скорости w. Достаточно просто - считаем время t1 и расстояние s1, проехав которое мы наберем макс. скорость, время t2 и расстояние s2, проехав которой мы с макс. скорости затормозим до w, проверяем, что сумма этих расстояний меньше d, прибавляем время t3=(d-s1-s2)/v, которое мы будем ехать с макс. скоростью. На второй участок мы попадем со скоростью w.2. Вариант второй - мы не успеваем разогнаться до максимальной скорости и затормозить до скорости w к столбу, то есть s1+s2 > d. Тогда все очевидно - ищем, до какой скорости мы можем разогнаться (я делал это бинарным поиском, но не сомневаюсь что это не обязательно :о)), и считаем сколько времени уйдет чтобы разогнаться до нее и затормозить с нее до w. На второй участок выходим со скоросью w.3. Третий случай - мы вообще за интервал d не успеваем даже разогнаться до w. Тогда проезжаем весь интервал d на разгоне, на второй участок выходим со скоростью, которую успели набрать.Тут есть корнер кейс, который зачем-то поместили в первый семпл - если w > v, и третий случай рассматривается до первого, и за интервал d нельзя достичь скорости w, но можно успеть достичь скорости v. Тогда можно ошибочно на первом интервале разгоняться до скорости большей v. Но наличие первого семпла спасало от такой ошибки (и меня от лишнего штрафа :о))На второй интервал мы выходим либо со скоростью w, если мы попали в первые два случая, либо со скоростью меньшей, если в третий. Теперь тут два достаточно простых случая - мы либо разгоняемся до максимальной и проезжаем часть дороги на максимальной скорости, либо, если мы не успеваем за оставшийся фрагмент дороги достичь максимальной скорости, просто проезжаем весь участок с ускорением a.Задача E.Задача подозрительно похожа на задачу С :о)Найдем максимальный элемент в последовательности и сдвинем все так, чтобы он оказался первым (или любой из них, если их несколько). Теперь, если не учиытвать максимальные холмы, мы можем полагать, что холмы расположены на не окружности, а в ряд, что упрощает задачу. Дальше отдельно решим для пар холмов, оба из которых не максимальной длины, для пар холмов, один из которых не максимальной длины, и для пар холмов, оба из которых максимальной длины.1. Как посчитать количество пар, где оба холма ниже максимального? Будем идти слева на право, поддерживая стек высот холмов, которые теоретически еще могут быть видны, и их количеств. Разумеется, этот стек всегда будет содержать высоты, идущие по убыванию. Добавляя очередной холм:1.а) если он максимальной длины, просто очистим стек (ничто не может быть видно, он все загородил), и НЕ улучшаем ответ, и НЕ добавляем его в стек, так как сейчас считаем ответ только для пар, в которых оба холма ниже максимального.1.б) иначе, пока последний элемент в стеке содержит высоту ниже текущего холма, удаляем этот элемент, прибавляя количество таких холмов к ответу (каждый из этих холмов виден с нашего более высокого).1.в.i) если после этого высота последнего элемента в стеке равна нашей, прибавим его количество и еще единицу, если в стеке хотя бы два элемента (потому что мы видим все холмы нашей высоты и еще ровно один выше, если он существует)1.в.ii) если же после этого высота последнего элемента в стеке выше нашей, то просто прибавляем к ответу единицу (мы видим только этот самый правый холм).1.в.iii) если же стек после 1.б. остался пустой, не меняем ответ.1.г) если последний элемент в стеке равен нашему, увеличим его количество. Иначе добавим в конец стека текущий элемент с количеством=1.1.д) пройдя так по всему массиву мы посчитаем количество пар, где оба холма ниже макисимального2. Как посчитать количество пар, где один из холмов максимальный, а второй нет? Очень легко, начиная от каждого максимального холма идем влево и вправо пока не встретим другой максимальный холм, и считаем сколько холмов мы видим. Это будет линейное время, потому что каждый элемент будет пройден ровно дважды: от холма максимальной высоты слева от него и от холма максимальной высоты справа от него.3. Как посчитать количество пар, где оба холма максимальны? n*(n-1)/2 где n - количество холмов максимальной высоты.Затем суммируем ответы из 1, 2 и 3.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/204",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.6,
            "reason": "宽松匹配: 包含题目编号 5 和字母"
          },
          "content_length": 7401
        }
      ],
      "code_examples": [],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int lineCount = 0;\n    int positiveLineCount = 0;\n\n    while (!inf.eof()) {\n        string s = inf.readLine();\n\n        lineCount++;\n        ensuref(lineCount <= 1000, \"Number of lines exceeds 1000\");\n\n        ensuref(int(s.length()) <= 1000, \"Line %d is too long (%d characters), maximum allowed is 1000\", lineCount, int(s.length()));\n\n        if (s.length() > 0) {\n            positiveLineCount++;\n            ensuref(s[0] != ' ', \"Line %d starts with a space\", lineCount);\n            ensuref(s.back() != ' ', \"Line %d ends with a space\", lineCount);\n        }\n\n        for (char c : s) {\n            ensuref((c == ' ') || ('0' <= c && c <= '9') || ('a' <= c && c <= 'z') || ('A' <= c && c <= 'Z'),\n                    \"Invalid character '%c' in line %d\", c, lineCount);\n        }\n    }\n\n    ensuref(positiveLineCount >= 1, \"At least one line must have positive length\");\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int lineCount = 0;\n    int positiveLineCount = 0;\n\n    while (!inf.eof()) {\n        string s = inf.readLine();\n\n        lineCount++;\n        ensuref(lineCount <= 1000, \"Number of lines exceeds 1000\");\n\n        ensuref(int(s.length()) <= 1000, \"Line %d is too long (%d characters), maximum allowed is 1000\", lineCount, int(s.length()));\n\n        if (s.length() > 0) {\n            positiveLineCount++;\n            ensuref(s[0] != ' ', \"Line %d starts with a space\", lineCount);\n            ensuref(s.back() != ' ', \"Line %d ends with a space\", lineCount);\n        }\n\n        for (char c : s) {\n            ensuref((c == ' ') || ('0' <= c && c <= '9') || ('a' <= c && c <= 'z') || ('A' <= c && c <= 'Z'),\n                    \"Invalid character '%c' in line %d\", c, lineCount);\n        }\n    }\n\n    ensuref(positiveLineCount >= 1, \"At least one line must have positive length\");\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int lineCount = 0;\n    int positiveLineCount = 0;\n\n    while (!inf.eof()) {\n        string s = inf.readLine();\n\n        lineCount++;\n        ensuref(lineCount <= 1000, \"Number of lines exceeds 1000\");\n\n        ensuref(int(s.length()) <= 1000, \"Line %d is too long (%d characters), maximum allowed is 1000\", lineCount, int(s.length()));\n\n        if (s.length() > 0) {\n            positiveLineCount++;\n            ensuref(s[0] != ' ', \"Line %d starts with a space\", lineCount);\n            ensuref(s.back() != ' ', \"Line %d ends with a space\", lineCount);\n        }\n\n        for (char c : s) {\n            ensuref((c == ' ') || ('0' <= c && c <= '9') || ('a' <= c && c <= 'z') || ('A' <= c && c <= 'Z'),\n                    \"Invalid character '%c' in line %d\", c, lineCount);\n        }\n    }\n\n    ensuref(positiveLineCount >= 1, \"At least one line must have positive length\");\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n#include <string>\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare files as sequence of lines\");\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    std::string strAnswer;\r\n\r\n    int n = 0;\r\n    while (!ans.eof()) {\r\n        std::string j = ans.readString();\r\n\r\n        if (j.empty() && ans.eof())\r\n            break;\r\n\r\n        strAnswer = j;\r\n        std::string p = ouf.readString();\r\n\r\n        n++;\r\n\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s lines differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  compress(j).c_str(), compress(p).c_str());\r\n    }\r\n\r\n    if (n == 1)\r\n        quitf(_ok, \"single line: '%s'\", compress(strAnswer).c_str());\r\n\r\n    quitf(_ok, \"%d lines\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\n// Function to generate a line of given length\nstring generate_line(int len) {\n    if (len == 0) {\n        return \"\";\n    }\n    const string letters_digits = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789\";\n    const string letters_digits_space = letters_digits + \" \";\n\n    string s(len, ' ');\n\n    // First character cannot be space\n    s[0] = letters_digits[rnd.next(letters_digits.size())];\n\n    if (len == 1) {\n        return s;\n    }\n\n    // Last character cannot be space\n    s[len - 1] = letters_digits[rnd.next(letters_digits.size())];\n\n    // Fill in the middle characters\n    for (int i = 1; i < len - 1; ++i) {\n        s[i] = letters_digits_space[rnd.next(letters_digits_space.size())];\n    }\n\n    return s;\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    // Read parameters\n    int n = opt<int>(\"n\"); // number of lines\n    int maxlen = opt<int>(\"maxlen\", 1000); // maximum line length\n    int empties = opt<int>(\"empties\", 0); // number of empty lines\n    string mode = opt<string>(\"mode\", \"random\"); // test case type\n\n    vector<string> lines;\n\n    if (mode == \"random\") {\n        // Generate random lines\n        int non_empty_lines = n - empties;\n        if (non_empty_lines <= 0) {\n            non_empty_lines = 1;\n            empties = n -1;\n        }\n        // Now generate non_empty_lines\n        vector<int> lengths(non_empty_lines);\n        for (int i = 0; i < non_empty_lines; ++i) {\n            lengths[i] = rnd.next(1, maxlen);\n        }\n        // Generate empty lines\n        for (int i = 0; i < empties; ++i) {\n            lines.push_back(\"\");\n        }\n        // Generate non-empty lines\n        for (int i = 0; i < non_empty_lines; ++i) {\n            lines.push_back(generate_line(lengths[i]));\n        }\n        // Shuffle lines\n        shuffle(lines.begin(), lines.end());\n    } else if (mode == \"maxline\") {\n        // Generate one line of maximum allowed length\n        if (n < 1) n = 1;\n        lines.resize(n, \"\");\n        lines[0] = generate_line(1000);\n    } else if (mode == \"empty\") {\n        // Generate empty lines, but ensure at least one line has positive length\n        if (n < 1) n = 1;\n        lines.resize(n, \"\");\n        lines[0] = generate_line(1); // Ensure at least one line has length > 0\n    } else if (mode == \"alternating\") {\n        // Generate lines alternating between minimum and maximum length\n        for (int i = 0; i < n; ++i) {\n            int len = (i % 2 == 0) ? 1 : maxlen;\n            lines.push_back(generate_line(len));\n        }\n    } else if (mode == \"maxlines\") {\n        // Generate maximum number of lines (1000)\n        n = 1000;\n        for (int i = 0; i < n; ++i) {\n            lines.push_back(generate_line(1));\n        }\n    } else if (mode == \"spaces\") {\n        // Generate lines with spaces inside, starting and ending with non-space\n        for (int i = 0; i < n; ++i) {\n            int len = rnd.next(1, maxlen);\n            string s = \"\";\n            s += generate_line(1); // First character\n            for (int j = 1; j < len - 1; ++j) {\n                s += ' ';\n            }\n            if (len > 1) {\n                s += generate_line(1); // Last character\n            }\n            lines.push_back(s);\n        }\n    } else if (mode == \"edgecases\") {\n        // Generate lines that test padding computation\n        // For example, lines with lengths that cause total padding to be odd\n        int half_n = n / 2;\n        for (int i = 0; i < half_n; ++i) {\n            lines.push_back(generate_line(maxlen));\n        }\n        for (int i = half_n; i < n; ++i) {\n            lines.push_back(generate_line(maxlen - 1));\n        }\n    } else {\n        // Default to random\n        int non_empty_lines = n - empties;\n        if (non_empty_lines <= 0) {\n            non_empty_lines = 1;\n            empties = n -1;\n        }\n        // Now generate non_empty_lines\n        vector<int> lengths(non_empty_lines);\n        for (int i = 0; i < non_empty_lines; ++i) {\n            lengths[i] = rnd.next(1, maxlen);\n        }\n        // Generate empty lines\n        for (int i = 0; i < empties; ++i) {\n            lines.push_back(\"\");\n        }\n        // Generate non-empty lines\n        for (int i = 0; i < non_empty_lines; ++i) {\n            lines.push_back(generate_line(lengths[i]));\n        }\n        // Shuffle lines\n        shuffle(lines.begin(), lines.end());\n    }\n\n    // Output lines\n    for (const string& s : lines) {\n        printf(\"%s\\n\", s.c_str());\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\n// Function to generate a line of given length\nstring generate_line(int len) {\n    if (len == 0) {\n        return \"\";\n    }\n    const string letters_digits = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789\";\n    const string letters_digits_space = letters_digits + \" \";\n\n    string s(len, ' ');\n\n    // First character cannot be space\n    s[0] = letters_digits[rnd.next(letters_digits.size())];\n\n    if (len == 1) {\n        return s;\n    }\n\n    // Last character cannot be space\n    s[len - 1] = letters_digits[rnd.next(letters_digits.size())];\n\n    // Fill in the middle characters\n    for (int i = 1; i < len - 1; ++i) {\n        s[i] = letters_digits_space[rnd.next(letters_digits_space.size())];\n    }\n\n    return s;\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    // Read parameters\n    int n = opt<int>(\"n\"); // number of lines\n    int maxlen = opt<int>(\"maxlen\", 1000); // maximum line length\n    int empties = opt<int>(\"empties\", 0); // number of empty lines\n    string mode = opt<string>(\"mode\", \"random\"); // test case type\n\n    vector<string> lines;\n\n    if (mode == \"random\") {\n        // Generate random lines\n        int non_empty_lines = n - empties;\n        if (non_empty_lines <= 0) {\n            non_empty_lines = 1;\n            empties = n -1;\n        }\n        // Now generate non_empty_lines\n        vector<int> lengths(non_empty_lines);\n        for (int i = 0; i < non_empty_lines; ++i) {\n            lengths[i] = rnd.next(1, maxlen);\n        }\n        // Generate empty lines\n        for (int i = 0; i < empties; ++i) {\n            lines.push_back(\"\");\n        }\n        // Generate non-empty lines\n        for (int i = 0; i < non_empty_lines; ++i) {\n            lines.push_back(generate_line(lengths[i]));\n        }\n        // Shuffle lines\n        shuffle(lines.begin(), lines.end());\n    } else if (mode == \"maxline\") {\n        // Generate one line of maximum allowed length\n        if (n < 1) n = 1;\n        lines.resize(n, \"\");\n        lines[0] = generate_line(1000);\n    } else if (mode == \"empty\") {\n        // Generate empty lines, but ensure at least one line has positive length\n        if (n < 1) n = 1;\n        lines.resize(n, \"\");\n        lines[0] = generate_line(1); // Ensure at least one line has length > 0\n    } else if (mode == \"alternating\") {\n        // Generate lines alternating between minimum and maximum length\n        for (int i = 0; i < n; ++i) {\n            int len = (i % 2 == 0) ? 1 : maxlen;\n            lines.push_back(generate_line(len));\n        }\n    } else if (mode == \"maxlines\") {\n        // Generate maximum number of lines (1000)\n        n = 1000;\n        for (int i = 0; i < n; ++i) {\n            lines.push_back(generate_line(1));\n        }\n    } else if (mode == \"spaces\") {\n        // Generate lines with spaces inside, starting and ending with non-space\n        for (int i = 0; i < n; ++i) {\n            int len = rnd.next(1, maxlen);\n            string s = \"\";\n            s += generate_line(1); // First character\n            for (int j = 1; j < len - 1; ++j) {\n                s += ' ';\n            }\n            if (len > 1) {\n                s += generate_line(1); // Last character\n            }\n            lines.push_back(s);\n        }\n    } else if (mode == \"edgecases\") {\n        // Generate lines that test padding computation\n        // For example, lines with lengths that cause total padding to be odd\n        int half_n = n / 2;\n        for (int i = 0; i < half_n; ++i) {\n            lines.push_back(generate_line(maxlen));\n        }\n        for (int i = half_n; i < n; ++i) {\n            lines.push_back(generate_line(maxlen - 1));\n        }\n    } else {\n        // Default to random\n        int non_empty_lines = n - empties;\n        if (non_empty_lines <= 0) {\n            non_empty_lines = 1;\n            empties = n -1;\n        }\n        // Now generate non_empty_lines\n        vector<int> lengths(non_empty_lines);\n        for (int i = 0; i < non_empty_lines; ++i) {\n            lengths[i] = rnd.next(1, maxlen);\n        }\n        // Generate empty lines\n        for (int i = 0; i < empties; ++i) {\n            lines.push_back(\"\");\n        }\n        // Generate non-empty lines\n        for (int i = 0; i < non_empty_lines; ++i) {\n            lines.push_back(generate_line(lengths[i]));\n        }\n        // Shuffle lines\n        shuffle(lines.begin(), lines.end());\n    }\n\n    // Output lines\n    for (const string& s : lines) {\n        printf(\"%s\\n\", s.c_str());\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Random inputs with varying sizes\n./gen -n 1 -maxlen 1 -mode random\n./gen -n 10 -maxlen 10 -mode random\n./gen -n 100 -maxlen 50 -mode random\n./gen -n 500 -maxlen 100 -mode random\n./gen -n 1000 -maxlen 1000 -mode random\n\n# Test maximum line length\n./gen -n 1 -mode maxline\n./gen -n 10 -mode maxline\n./gen -n 100 -mode maxline\n\n# Test maximum number of lines\n./gen -n 1000 -mode maxlines\n\n# Test with many empty lines, but at least one non-empty line\n./gen -n 10 -empties 9 -mode random\n./gen -n 100 -empties 99 -mode random\n\n# Test with only empty lines (except one)\n./gen -n 1000 -empties 999 -mode random\n\n# Test with empty mode\n./gen -n 10 -mode empty\n./gen -n 100 -mode empty\n./gen -n 1000 -mode empty\n\n# Test alternating line lengths\n./gen -n 10 -maxlen 50 -mode alternating\n./gen -n 100 -maxlen 1000 -mode alternating\n\n# Test with lines containing spaces\n./gen -n 10 -maxlen 30 -mode spaces\n./gen -n 100 -maxlen 100 -mode spaces\n\n# Test edge cases for padding\n./gen -n 10 -maxlen 50 -mode edgecases\n./gen -n 100 -maxlen 100 -mode edgecases\n\n# Test minimal input (only one line with length one)\n./gen -n 1 -maxlen 1 -mode random\n\n# Test inputs with varying numbers of empty lines\n./gen -n 20 -empties 10 -mode random\n./gen -n 30 -empties 15 -mode random\n\n# Test inputs with maximum values\n./gen -n 1000 -maxlen 1000 -mode random\n\n# Test inputs with maximum number of lines and maximum line length\n./gen -n 1000 -maxlen 1000 -mode maxline\n\n# Test inputs with many empty lines and alternating lengths\n./gen -n 1000 -empties 500 -mode alternating\n\n# Test inputs with empty lines only (except one)\n./gen -n 1000 -empties 999 -mode empty\n\n# Test with maximum number of lines and random lengths\n./gen -n 1000 -maxlen 1000 -mode random\n\n# Test with maximum line length and empty lines\n./gen -n 1000 -maxlen 1000 -empties 500 -mode random\n\n# Test with lines that have maximum and one less than maximum length\n./gen -n 1000 -maxlen 1000 -mode edgecases\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:39:40.173377",
        "total_tutorials": 3,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "5/C",
      "title": "C. Longest Regular Bracket Sequence",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line of the input file contains a non-empty string, consisting of «(» and «)» characters. Its length does not exceed 106.",
      "output_spec": "OutputPrint the length of the longest substring that is a regular bracket sequence, and the number of such substrings. If there are no such substrings, write the only line containing \"0 1\".",
      "sample_tests": "ExamplesInputCopy)((())))(()())OutputCopy6 2InputCopy))(OutputCopy0 1",
      "description": "C. Longest Regular Bracket Sequence\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line of the input file contains a non-empty string, consisting of «(» and «)» characters. Its length does not exceed 106.\n\nOutputPrint the length of the longest substring that is a regular bracket sequence, and the number of such substrings. If there are no such substrings, write the only line containing \"0 1\".\n\nInputCopy)((())))(()())OutputCopy6 2InputCopy))(OutputCopy0 1\n\nInputCopy)((())))(()())\n\nOutputCopy6 2\n\nInputCopy))(\n\nOutputCopy0 1",
      "solutions": [
        {
          "title": "Codeforces Beta Round #5 - Codeforces",
          "content": "Welcome and good luck on the round! I'd like to remind that if you have any questions on the problems, the best way to ask them is to use the web interface on the problems page. Later in the same post we will discuss the round. Wish you high rating,MikeMirzayanov.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/196",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 264
        },
        {
          "title": "Codeforces Beta Round #5 - Tutorial - Codeforces",
          "content": "As there is no tutorial of Codeforces Beta Round #5 in English, I have decided to write this one. Possibly, some ideas will be similar to ones, expressed in Russian tutorial made by SkidanovAlex, but I hope everybody will find some useful in this problem analysis too.Problems A and B.Both are implementation problems. The only difficult, many participants faced with - to read data correctly. It is recommended to use gets(s) or getline(cin, s) in C++, readLine() method of BufferedReader class in Java.Problem C.First of all, for each closing bracket in our string let's define 2 values:d[j] = position of corresponding open bracket, or -1 if closing bracket doesn't belong to any regular bracket sequence. c[j] = position of earliest opening bracket, such that substring s(c[j], j) (both boundaries are inclusive) is a regular bracket sequence. Let's consider c[j] to be -1 if closing bracket doesn't belong to any regular bracket sequence. It can be seen, that c[j] defines the beginning position of the longest regular bracket sequence, which will end in position j. So, having c[j] answer for the problem can be easily calculated.Both d[j] and c[j] can be found with following algorithm, which uses stack.Iterate through the characters of the string.If current character is opening bracket, put its position into the stack.If current character is closing bracket, there are 2 subcases:Stack is empty - this means that current closing bracket doesn't have corresponding open one. Hence, both d[j] and c[j] are equal to -1. Stack is not empty - we will have position of the corresponding open bracket on the top of the stack - let's put it to d[j] and remove this position from the stack. Now it is obvious, that c[j] is equal at least to d[j]. But probably, there is a better value for c[j]. To find this out, we just need to look at the position d[j] - 1. If there is a closing bracket at this position, and c[d[j] - 1] is not -1, than we have 2 regular bracket sequences s(c[d[j] - 1], d[j] - 1) and s(d[j], j), which can be concatenated into one larger regular bracket sequence. So we put c[j] to be c[d[j] - 1] for this case.Problem D.This problem can be solved by careful case handling. Let's construct O(1) solution for it.First of all, let's define 2 functions:dist(speed, time) - calculates the distance will be covered in specified time, if car's current speed is speed. This function will not take car's speed limit into account. Also it assumes, that car is always driven with maximum acceleration a. It is obvious that required distance is equal to .travelTime(distance, speed) - calculates the time, required to travel specified distance, if car have starting speed equal to speed. This function will also take care about car's speed limit.We will have the following quadratic equation for time t: . This equation will have exactly 2 different roots. Using Viete's formulas it can be concluded, that one root of the equation is non-positive and other is non-negative. Let's define the larger root of the equation as tAll. It will be the answer, if there is no car's speed limit. To take the limit into account let's find the time, required to gain car's max speed. tMax = (v - speed) / a. If tMax ≥  tAll, function should just returns tAll as a result. Otherwise result is tMax hours to achieve car's maximal speed plus (distance - dist(speed, tMax)) / v hours to cover remaining distance.Having these functions, solution will be the following:If v ≤ w, answer is travelTime(l, 0).Calculate tw = w / a -  time, required to gain speed w.Consider dw = dist(0, tw).If dw ≥ d, we will pass the point there sign is placed before we gain speed w. Answer for this case is travelTime(l, 0) as well.Otherwise, we will gain speed w before the sign. Let's consider segment of the road [dw, d]. We need to find out the best strategy to drive it. It is obvious, that we definitely should have speed w at the both ends of this segment. Also we know, that acceleration is equal to deceleration. Taking these facts into account we can see, that the speed in the optimal solution will be symmetrical with respect to the middle of the segment [dw, d]. Hence answer for this case will be tw + 2 *  travelTime(0.5 * (d - dw), w) + travelTime(l - d, w).Problem E.Let's reduce the problem from the circle to the straight line. Perform the following actions to do it:Find the hill with the maximal height (if it is not unique, choose any).Rotate all the sequence in such a way that hill with maximal height goes first. For convenience, add one more hill with maximum height to the end of the sequence. (It will represent the first hill, which goes after the last in the circle order).Now we have almost the same problem on the straight line. One exception is that now first hill is doubled.General idea of the solution:Consider there is a pair of hills, such that these hills are visible from each other. Let's define hill with lower height (if heights are equal - with lower position) as responsible for adding this pair to the answer.From this point of view, hill x will adds to the answer 3 kinds of hills as his pair:First hill to the left of the x, which is strictly higher than x. (Let's define its position as l[x])First hill to the right of the x, which is strictly higher than x. (Let's call this hill y and define it's position as r[x]).All hills that are as high as x and are located between x and y. (Let's define this count as c[x]).Arrays r[x] and c[x] can be calculated by the following piece of code:c[n] = 0;for(int i = n - 1; i >= 0; --i) {    r[i] = i + 1;    while (r[i] < n && height[i] > height[r[i]]) r[i] = r[r[i]];    if (r[i] < n && height[i] == height[r[i]]) {        c[i] = c[r[i]] + 1;        r[i] = r[r[i]];    }}I am not going to prove here, that it works for the O(N) time, but believe it does :)Pay attention, that r[x] is undefined for hills with maximum height and this algorithm will find r[x] = n for such hills.Array l[x] can be found in a similar way.Having l[x], r[x] and c[x], it's not so difficult to calculate the answer. We should just notice, that:Each hill will add c[x] pairs to the answer.Each hill, lower than maximal, will also add 2 pairs (x, l[x]) and (x, r[x]) to the answer. The only corner case here is l[x] = 0 and r[x] = n, because (x, 0) and (x, n) is the same pair of hills in the original problem, where hills are circled.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/213",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.6,
            "reason": "宽松匹配: 包含题目编号 5 和字母"
          },
          "content_length": 6377
        },
        {
          "title": "C, D и E с CBR5 - разбор - Codeforces",
          "content": "Сначала хотел написать полный разбор, но как разбирать задачи A и B я не представляю :о) Разве что можно сказать, что на C++ чтобы читать до конца надо использовать while( gets( s ) ), а если вы не любите перенаправлять файлы и вводите тест прямо в консоль, то чтобы обозначить конец файла надо нажать Ctrl+Z.Задача СДавайте введем понятие баланса некоторого префикса подстроки - на сколько открывающихся скобок больше в этом префиксе, чем закрывающихся. Понятно, что некоторая строка является правильной скобочной подпоследовательностью, если для всей строки баланс равен нулю, а для любого ее префикса не отрицателен. Посчитаем баланс для каждого префикса данной нам в задаче строки и сложим их в массив prefs. Теперь рассмотрим любую подстроку это строки - пусть она идет от символа с позицией l включительно до символа в позиции r исключительно. Эта подстрока - правильная скобочная последовательность, если prefs[l] == prefs[r] и prefs[i] >= prefs[l] для любого i в интервале [l, r). Как нам теперь, зная это, найти максимальную подстроку правильную и их количество? Будем делать примерно так: поддерживать стек пар (баланс-позиция) - на какой позиции в строке впервые был замечен такой баланс, после которой еще не встречался меньший баланс. На самом деле можно даже хранить только позиции, потому что баланс всегда очевиден - в последнем элементе в стеке всегда будет текущий баланс, в предпоследнем на единицу меньше итд. Рассмотрим теперь скажем последовательность ((()())))(()). Балансы: 1,2,3,2,3,2,1,0,-1,0,1,0,-1Будем идти слева на право и поддерживать наш стек следующим образом: добавляя открывающуюся скобку добавлять в стек позицию этой скобки, а добавляя закрывающуюся удалять последний элемент из стека, улучшая ответ. Пример с нашей последовательносью:1. Помним, что на позиции 0 (то есть до добавления любой скобки) баланс был 0. То есть сейчас стек: 02. Добавляем первую скобку. Занесем ее позицию в стек. Стек: 0,13. Добавим вторую скобку. Занесем ее позицию в стек. Стек: 0,1,24. Аналогично для третьей скобки. Стек 0,1,2,35. Четвертая скобка - закрывающаяся. Соответственно удалим последний элемент из стека, Текущий стек: 0,1,2. Запоминаем, что мы нашли последоательность длины 2 (позиция-последний элемент в стеке после удаления, 4-2=2). 6. Пятая скобка - открывающаяся, добавим ее в стек: 0,1,2,57. Шестая скобка - закрывающаяся, удалим из стека последний элемент, запомним, что мы нашли последовательность длины 4. Стек: 0,1,28. Седьма скобка - закрывающаяся, удалим из стека последний элемент, запомнив, что мы нашли последовательность длины (7-1)=6. Стек: 0,1.9. Восьмая скобка - закрывающаяся, удалим из стека последний элемент, запомнив, что мы нашли последовательность длины (8-0)=8. Стек: 010. Девятая скобка - закрывающаяся, удалим из стека последний элемент. Стек: пустой.11. 10-ая скобка закрывающаяся, но стек и так пустой - ничего не меняем.12. Скобка открывающаяся, стек: 1113. Скобка открывающаяся, стек: 11,1214. Далее две закрывающихся скобки очистят стек и еще одна ничего не изменит, ответа больше 8 найдено не будет, таким образом мы нашли ответ 8.Задача DЭто задача хитрая на рассмотрение граничных случаев.Сначала случаи до столба:1. Самый простой - мы разгоняемся до макисимальной скорости, едем на ней участок и тормозим до скорости w. Достаточно просто - считаем время t1 и расстояние s1, проехав которое мы наберем макс. скорость, время t2 и расстояние s2, проехав которой мы с макс. скорости затормозим до w, проверяем, что сумма этих расстояний меньше d, прибавляем время t3=(d-s1-s2)/v, которое мы будем ехать с макс. скоростью. На второй участок мы попадем со скоростью w.2. Вариант второй - мы не успеваем разогнаться до максимальной скорости и затормозить до скорости w к столбу, то есть s1+s2 > d. Тогда все очевидно - ищем, до какой скорости мы можем разогнаться (я делал это бинарным поиском, но не сомневаюсь что это не обязательно :о)), и считаем сколько времени уйдет чтобы разогнаться до нее и затормозить с нее до w. На второй участок выходим со скоросью w.3. Третий случай - мы вообще за интервал d не успеваем даже разогнаться до w. Тогда проезжаем весь интервал d на разгоне, на второй участок выходим со скоростью, которую успели набрать.Тут есть корнер кейс, который зачем-то поместили в первый семпл - если w > v, и третий случай рассматривается до первого, и за интервал d нельзя достичь скорости w, но можно успеть достичь скорости v. Тогда можно ошибочно на первом интервале разгоняться до скорости большей v. Но наличие первого семпла спасало от такой ошибки (и меня от лишнего штрафа :о))На второй интервал мы выходим либо со скоростью w, если мы попали в первые два случая, либо со скоростью меньшей, если в третий. Теперь тут два достаточно простых случая - мы либо разгоняемся до максимальной и проезжаем часть дороги на максимальной скорости, либо, если мы не успеваем за оставшийся фрагмент дороги достичь максимальной скорости, просто проезжаем весь участок с ускорением a.Задача E.Задача подозрительно похожа на задачу С :о)Найдем максимальный элемент в последовательности и сдвинем все так, чтобы он оказался первым (или любой из них, если их несколько). Теперь, если не учиытвать максимальные холмы, мы можем полагать, что холмы расположены на не окружности, а в ряд, что упрощает задачу. Дальше отдельно решим для пар холмов, оба из которых не максимальной длины, для пар холмов, один из которых не максимальной длины, и для пар холмов, оба из которых максимальной длины.1. Как посчитать количество пар, где оба холма ниже максимального? Будем идти слева на право, поддерживая стек высот холмов, которые теоретически еще могут быть видны, и их количеств. Разумеется, этот стек всегда будет содержать высоты, идущие по убыванию. Добавляя очередной холм:1.а) если он максимальной длины, просто очистим стек (ничто не может быть видно, он все загородил), и НЕ улучшаем ответ, и НЕ добавляем его в стек, так как сейчас считаем ответ только для пар, в которых оба холма ниже максимального.1.б) иначе, пока последний элемент в стеке содержит высоту ниже текущего холма, удаляем этот элемент, прибавляя количество таких холмов к ответу (каждый из этих холмов виден с нашего более высокого).1.в.i) если после этого высота последнего элемента в стеке равна нашей, прибавим его количество и еще единицу, если в стеке хотя бы два элемента (потому что мы видим все холмы нашей высоты и еще ровно один выше, если он существует)1.в.ii) если же после этого высота последнего элемента в стеке выше нашей, то просто прибавляем к ответу единицу (мы видим только этот самый правый холм).1.в.iii) если же стек после 1.б. остался пустой, не меняем ответ.1.г) если последний элемент в стеке равен нашему, увеличим его количество. Иначе добавим в конец стека текущий элемент с количеством=1.1.д) пройдя так по всему массиву мы посчитаем количество пар, где оба холма ниже макисимального2. Как посчитать количество пар, где один из холмов максимальный, а второй нет? Очень легко, начиная от каждого максимального холма идем влево и вправо пока не встретим другой максимальный холм, и считаем сколько холмов мы видим. Это будет линейное время, потому что каждый элемент будет пройден ровно дважды: от холма максимальной высоты слева от него и от холма максимальной высоты справа от него.3. Как посчитать количество пар, где оба холма максимальны? n*(n-1)/2 где n - количество холмов максимальной высоты.Затем суммируем ответы из 1, 2 и 3.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/204",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.6,
            "reason": "宽松匹配: 包含题目编号 5 和字母"
          },
          "content_length": 7401
        }
      ],
      "code_examples": [],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    string s = inf.readLine(\"[()]+\", \"s\");\n    ensuref(s.length() <= 1000000, \"The length of the string should not exceed 1,000,000, but it is %d\", (int)s.length());\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    string s = inf.readLine(\"[()]+\", \"s\");\n    ensuref(s.length() <= 1000000, \"The length of the string should not exceed 1,000,000, but it is %d\", (int)s.length());\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    string s = inf.readLine(\"[()]+\", \"s\");\n    ensuref(s.length() <= 1000000, \"The length of the string should not exceed 1,000,000, but it is %d\", (int)s.length());\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string t = opt<string>(\"t\", \"random\");\n    int k = opt<int>(\"k\", n); // For some types that need parameter k\n\n    string s(n, ' ');\n\n    if (t == \"random\") {\n        // Randomly generate '(' or ')'\n        for (int i = 0; i < n; ++i) {\n            s[i] = rnd.next(2) ? '(' : ')';\n        }\n    } else if (t == \"valid\") {\n        // Generate a valid bracket sequence of length n\n        if (n % 2 != 0) {\n            // Can't generate valid bracket sequence of odd length\n            n -= 1;\n            s.resize(n);\n        }\n        // s = string(n / 2, '(') + string(n / 2, ')');\n        // Shuffle to make it less predictable\n        vector<char> brackets(n);\n        for (int i = 0; i < n / 2; ++i) brackets[i] = '(';\n        for (int i = n / 2; i < n; ++i) brackets[i] = ')';\n        shuffle(brackets.begin(), brackets.end());\n        // Adjust to ensure the sequence is valid\n        // Implement stack to balance brackets\n        stack<int> st;\n        for (int i = 0; i < n; ++i) {\n            if (brackets[i] == '(') {\n                st.push(i);\n            } else {\n                if (st.empty()) {\n                    brackets[i] = '(';\n                    st.push(i);\n                } else {\n                    st.pop();\n                }\n            }\n        }\n        while (!st.empty()) {\n            brackets[st.top()] = ')';\n            st.pop();\n        }\n        s.assign(brackets.begin(), brackets.end());\n    } else if (t == \"allleft\") {\n        s = string(n, '(');\n    } else if (t == \"allright\") {\n        s = string(n, ')');\n    } else if (t == \"alternating\") {\n        // e.g., '()()()()' or similar\n        if (n % 2 != 0) {\n            n -=1;\n            s.resize(n);\n        }\n        for (int i = 0; i < n; i += 2) {\n            s[i] = '(';\n            s[i + 1] = ')';\n        }\n    } else if (t == \"nested\") {\n        // Generate nested brackets, e.g., \"(((())))\"\n        if (n % 2 != 0) {\n            n -= 1;\n            s.resize(n);\n        }\n        for (int i = 0; i < n / 2; ++i) {\n            s[i] = '(';\n            s[n - i - 1] = ')';\n        }\n    } else if (t == \"maxsubstr\") {\n        // Generate string where the longest regular bracket substring is length k\n        if (k > n) k = n;\n        if (k % 2 != 0) {\n            k -= 1;\n        }\n        if (k <= 0) k = 2; // minimum valid length\n        s = string(n, ')'); // Initialize with ')'\n        int max_start = n - k;\n        int pos = rnd.next(0, max_start);\n        // Place valid substring\n        for (int i = 0; i < k / 2; ++i) {\n            s[pos + i] = '(';\n            s[pos + i + k / 2] = ')';\n        }\n    } else {\n        // Default to random\n        for (int i = 0; i < n; ++i) {\n            s[i] = rnd.next(2) ? '(' : ')';\n        }\n    }\n\n    // Output the string\n    printf(\"%s\\n\", s.c_str());\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string t = opt<string>(\"t\", \"random\");\n    int k = opt<int>(\"k\", n); // For some types that need parameter k\n\n    string s(n, ' ');\n\n    if (t == \"random\") {\n        // Randomly generate '(' or ')'\n        for (int i = 0; i < n; ++i) {\n            s[i] = rnd.next(2) ? '(' : ')';\n        }\n    } else if (t == \"valid\") {\n        // Generate a valid bracket sequence of length n\n        if (n % 2 != 0) {\n            // Can't generate valid bracket sequence of odd length\n            n -= 1;\n            s.resize(n);\n        }\n        // s = string(n / 2, '(') + string(n / 2, ')');\n        // Shuffle to make it less predictable\n        vector<char> brackets(n);\n        for (int i = 0; i < n / 2; ++i) brackets[i] = '(';\n        for (int i = n / 2; i < n; ++i) brackets[i] = ')';\n        shuffle(brackets.begin(), brackets.end());\n        // Adjust to ensure the sequence is valid\n        // Implement stack to balance brackets\n        stack<int> st;\n        for (int i = 0; i < n; ++i) {\n            if (brackets[i] == '(') {\n                st.push(i);\n            } else {\n                if (st.empty()) {\n                    brackets[i] = '(';\n                    st.push(i);\n                } else {\n                    st.pop();\n                }\n            }\n        }\n        while (!st.empty()) {\n            brackets[st.top()] = ')';\n            st.pop();\n        }\n        s.assign(brackets.begin(), brackets.end());\n    } else if (t == \"allleft\") {\n        s = string(n, '(');\n    } else if (t == \"allright\") {\n        s = string(n, ')');\n    } else if (t == \"alternating\") {\n        // e.g., '()()()()' or similar\n        if (n % 2 != 0) {\n            n -=1;\n            s.resize(n);\n        }\n        for (int i = 0; i < n; i += 2) {\n            s[i] = '(';\n            s[i + 1] = ')';\n        }\n    } else if (t == \"nested\") {\n        // Generate nested brackets, e.g., \"(((())))\"\n        if (n % 2 != 0) {\n            n -= 1;\n            s.resize(n);\n        }\n        for (int i = 0; i < n / 2; ++i) {\n            s[i] = '(';\n            s[n - i - 1] = ')';\n        }\n    } else if (t == \"maxsubstr\") {\n        // Generate string where the longest regular bracket substring is length k\n        if (k > n) k = n;\n        if (k % 2 != 0) {\n            k -= 1;\n        }\n        if (k <= 0) k = 2; // minimum valid length\n        s = string(n, ')'); // Initialize with ')'\n        int max_start = n - k;\n        int pos = rnd.next(0, max_start);\n        // Place valid substring\n        for (int i = 0; i < k / 2; ++i) {\n            s[pos + i] = '(';\n            s[pos + i + k / 2] = ')';\n        }\n    } else {\n        // Default to random\n        for (int i = 0; i < n; ++i) {\n            s[i] = rnd.next(2) ? '(' : ')';\n        }\n    }\n\n    // Output the string\n    printf(\"%s\\n\", s.c_str());\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 10 -t random\n./gen -n 10 -t valid\n./gen -n 10 -t allleft\n./gen -n 10 -t allright\n./gen -n 10 -t alternating\n./gen -n 10 -t nested\n./gen -n 10 -t maxsubstr -k 6\n\n./gen -n 20 -t random\n./gen -n 20 -t valid\n./gen -n 20 -t allleft\n./gen -n 20 -t allright\n./gen -n 20 -t alternating\n./gen -n 20 -t nested\n./gen -n 20 -t maxsubstr -k 10\n\n./gen -n 100 -t random\n./gen -n 100 -t valid\n./gen -n 100 -t allleft\n./gen -n 100 -t allright\n./gen -n 100 -t alternating\n./gen -n 100 -t nested\n./gen -n 100 -t maxsubstr -k 50\n\n./gen -n 1000 -t random\n./gen -n 1000 -t valid\n./gen -n 1000 -t allleft\n./gen -n 1000 -t allright\n./gen -n 1000 -t alternating\n./gen -n 1000 -t nested\n./gen -n 1000 -t maxsubstr -k 500\n\n./gen -n 1000000 -t random\n./gen -n 1000000 -t valid\n./gen -n 1000000 -t allleft\n./gen -n 1000000 -t allright\n./gen -n 1000000 -t alternating\n./gen -n 1000000 -t nested\n./gen -n 1000000 -t maxsubstr -k 500000\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:39:42.581262",
        "total_tutorials": 3,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "5/D",
      "title": "D. Follow Traffic Rules",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test64 megabytes",
      "input_spec": "InputThe first line of the input file contains two integer numbers a and v (1 ≤ a, v ≤ 10000). The second line contains three integer numbers l, d and w (2 ≤ l ≤ 10000; 1 ≤ d < l; 1 ≤ w ≤ 10000).",
      "output_spec": "OutputPrint the answer with at least five digits after the decimal point.",
      "sample_tests": "ExamplesInputCopy1 12 1 3OutputCopy2.500000000000InputCopy5 70200 170 40OutputCopy8.965874696353",
      "description": "D. Follow Traffic Rules\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test64 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line of the input file contains two integer numbers a and v (1 ≤ a, v ≤ 10000). The second line contains three integer numbers l, d and w (2 ≤ l ≤ 10000; 1 ≤ d < l; 1 ≤ w ≤ 10000).\n\nOutputPrint the answer with at least five digits after the decimal point.\n\nInputCopy1 12 1 3OutputCopy2.500000000000InputCopy5 70200 170 40OutputCopy8.965874696353\n\nInputCopy1 12 1 3\n\nOutputCopy2.500000000000\n\nInputCopy5 70200 170 40\n\nOutputCopy8.965874696353",
      "solutions": [
        {
          "title": "Codeforces Beta Round #5 - Codeforces",
          "content": "Welcome and good luck on the round! I'd like to remind that if you have any questions on the problems, the best way to ask them is to use the web interface on the problems page. Later in the same post we will discuss the round. Wish you high rating,MikeMirzayanov.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/196",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 264
        },
        {
          "title": "Codeforces Beta Round #5 - Tutorial - Codeforces",
          "content": "As there is no tutorial of Codeforces Beta Round #5 in English, I have decided to write this one. Possibly, some ideas will be similar to ones, expressed in Russian tutorial made by SkidanovAlex, but I hope everybody will find some useful in this problem analysis too.Problems A and B.Both are implementation problems. The only difficult, many participants faced with - to read data correctly. It is recommended to use gets(s) or getline(cin, s) in C++, readLine() method of BufferedReader class in Java.Problem C.First of all, for each closing bracket in our string let's define 2 values:d[j] = position of corresponding open bracket, or -1 if closing bracket doesn't belong to any regular bracket sequence. c[j] = position of earliest opening bracket, such that substring s(c[j], j) (both boundaries are inclusive) is a regular bracket sequence. Let's consider c[j] to be -1 if closing bracket doesn't belong to any regular bracket sequence. It can be seen, that c[j] defines the beginning position of the longest regular bracket sequence, which will end in position j. So, having c[j] answer for the problem can be easily calculated.Both d[j] and c[j] can be found with following algorithm, which uses stack.Iterate through the characters of the string.If current character is opening bracket, put its position into the stack.If current character is closing bracket, there are 2 subcases:Stack is empty - this means that current closing bracket doesn't have corresponding open one. Hence, both d[j] and c[j] are equal to -1. Stack is not empty - we will have position of the corresponding open bracket on the top of the stack - let's put it to d[j] and remove this position from the stack. Now it is obvious, that c[j] is equal at least to d[j]. But probably, there is a better value for c[j]. To find this out, we just need to look at the position d[j] - 1. If there is a closing bracket at this position, and c[d[j] - 1] is not -1, than we have 2 regular bracket sequences s(c[d[j] - 1], d[j] - 1) and s(d[j], j), which can be concatenated into one larger regular bracket sequence. So we put c[j] to be c[d[j] - 1] for this case.Problem D.This problem can be solved by careful case handling. Let's construct O(1) solution for it.First of all, let's define 2 functions:dist(speed, time) - calculates the distance will be covered in specified time, if car's current speed is speed. This function will not take car's speed limit into account. Also it assumes, that car is always driven with maximum acceleration a. It is obvious that required distance is equal to .travelTime(distance, speed) - calculates the time, required to travel specified distance, if car have starting speed equal to speed. This function will also take care about car's speed limit.We will have the following quadratic equation for time t: . This equation will have exactly 2 different roots. Using Viete's formulas it can be concluded, that one root of the equation is non-positive and other is non-negative. Let's define the larger root of the equation as tAll. It will be the answer, if there is no car's speed limit. To take the limit into account let's find the time, required to gain car's max speed. tMax = (v - speed) / a. If tMax ≥  tAll, function should just returns tAll as a result. Otherwise result is tMax hours to achieve car's maximal speed plus (distance - dist(speed, tMax)) / v hours to cover remaining distance.Having these functions, solution will be the following:If v ≤ w, answer is travelTime(l, 0).Calculate tw = w / a -  time, required to gain speed w.Consider dw = dist(0, tw).If dw ≥ d, we will pass the point there sign is placed before we gain speed w. Answer for this case is travelTime(l, 0) as well.Otherwise, we will gain speed w before the sign. Let's consider segment of the road [dw, d]. We need to find out the best strategy to drive it. It is obvious, that we definitely should have speed w at the both ends of this segment. Also we know, that acceleration is equal to deceleration. Taking these facts into account we can see, that the speed in the optimal solution will be symmetrical with respect to the middle of the segment [dw, d]. Hence answer for this case will be tw + 2 *  travelTime(0.5 * (d - dw), w) + travelTime(l - d, w).Problem E.Let's reduce the problem from the circle to the straight line. Perform the following actions to do it:Find the hill with the maximal height (if it is not unique, choose any).Rotate all the sequence in such a way that hill with maximal height goes first. For convenience, add one more hill with maximum height to the end of the sequence. (It will represent the first hill, which goes after the last in the circle order).Now we have almost the same problem on the straight line. One exception is that now first hill is doubled.General idea of the solution:Consider there is a pair of hills, such that these hills are visible from each other. Let's define hill with lower height (if heights are equal - with lower position) as responsible for adding this pair to the answer.From this point of view, hill x will adds to the answer 3 kinds of hills as his pair:First hill to the left of the x, which is strictly higher than x. (Let's define its position as l[x])First hill to the right of the x, which is strictly higher than x. (Let's call this hill y and define it's position as r[x]).All hills that are as high as x and are located between x and y. (Let's define this count as c[x]).Arrays r[x] and c[x] can be calculated by the following piece of code:c[n] = 0;for(int i = n - 1; i >= 0; --i) {    r[i] = i + 1;    while (r[i] < n && height[i] > height[r[i]]) r[i] = r[r[i]];    if (r[i] < n && height[i] == height[r[i]]) {        c[i] = c[r[i]] + 1;        r[i] = r[r[i]];    }}I am not going to prove here, that it works for the O(N) time, but believe it does :)Pay attention, that r[x] is undefined for hills with maximum height and this algorithm will find r[x] = n for such hills.Array l[x] can be found in a similar way.Having l[x], r[x] and c[x], it's not so difficult to calculate the answer. We should just notice, that:Each hill will add c[x] pairs to the answer.Each hill, lower than maximal, will also add 2 pairs (x, l[x]) and (x, r[x]) to the answer. The only corner case here is l[x] = 0 and r[x] = n, because (x, 0) and (x, n) is the same pair of hills in the original problem, where hills are circled.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/213",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.6,
            "reason": "宽松匹配: 包含题目编号 5 和字母"
          },
          "content_length": 6377
        },
        {
          "title": "C, D и E с CBR5 - разбор - Codeforces",
          "content": "Сначала хотел написать полный разбор, но как разбирать задачи A и B я не представляю :о) Разве что можно сказать, что на C++ чтобы читать до конца надо использовать while( gets( s ) ), а если вы не любите перенаправлять файлы и вводите тест прямо в консоль, то чтобы обозначить конец файла надо нажать Ctrl+Z.Задача СДавайте введем понятие баланса некоторого префикса подстроки - на сколько открывающихся скобок больше в этом префиксе, чем закрывающихся. Понятно, что некоторая строка является правильной скобочной подпоследовательностью, если для всей строки баланс равен нулю, а для любого ее префикса не отрицателен. Посчитаем баланс для каждого префикса данной нам в задаче строки и сложим их в массив prefs. Теперь рассмотрим любую подстроку это строки - пусть она идет от символа с позицией l включительно до символа в позиции r исключительно. Эта подстрока - правильная скобочная последовательность, если prefs[l] == prefs[r] и prefs[i] >= prefs[l] для любого i в интервале [l, r). Как нам теперь, зная это, найти максимальную подстроку правильную и их количество? Будем делать примерно так: поддерживать стек пар (баланс-позиция) - на какой позиции в строке впервые был замечен такой баланс, после которой еще не встречался меньший баланс. На самом деле можно даже хранить только позиции, потому что баланс всегда очевиден - в последнем элементе в стеке всегда будет текущий баланс, в предпоследнем на единицу меньше итд. Рассмотрим теперь скажем последовательность ((()())))(()). Балансы: 1,2,3,2,3,2,1,0,-1,0,1,0,-1Будем идти слева на право и поддерживать наш стек следующим образом: добавляя открывающуюся скобку добавлять в стек позицию этой скобки, а добавляя закрывающуюся удалять последний элемент из стека, улучшая ответ. Пример с нашей последовательносью:1. Помним, что на позиции 0 (то есть до добавления любой скобки) баланс был 0. То есть сейчас стек: 02. Добавляем первую скобку. Занесем ее позицию в стек. Стек: 0,13. Добавим вторую скобку. Занесем ее позицию в стек. Стек: 0,1,24. Аналогично для третьей скобки. Стек 0,1,2,35. Четвертая скобка - закрывающаяся. Соответственно удалим последний элемент из стека, Текущий стек: 0,1,2. Запоминаем, что мы нашли последоательность длины 2 (позиция-последний элемент в стеке после удаления, 4-2=2). 6. Пятая скобка - открывающаяся, добавим ее в стек: 0,1,2,57. Шестая скобка - закрывающаяся, удалим из стека последний элемент, запомним, что мы нашли последовательность длины 4. Стек: 0,1,28. Седьма скобка - закрывающаяся, удалим из стека последний элемент, запомнив, что мы нашли последовательность длины (7-1)=6. Стек: 0,1.9. Восьмая скобка - закрывающаяся, удалим из стека последний элемент, запомнив, что мы нашли последовательность длины (8-0)=8. Стек: 010. Девятая скобка - закрывающаяся, удалим из стека последний элемент. Стек: пустой.11. 10-ая скобка закрывающаяся, но стек и так пустой - ничего не меняем.12. Скобка открывающаяся, стек: 1113. Скобка открывающаяся, стек: 11,1214. Далее две закрывающихся скобки очистят стек и еще одна ничего не изменит, ответа больше 8 найдено не будет, таким образом мы нашли ответ 8.Задача DЭто задача хитрая на рассмотрение граничных случаев.Сначала случаи до столба:1. Самый простой - мы разгоняемся до макисимальной скорости, едем на ней участок и тормозим до скорости w. Достаточно просто - считаем время t1 и расстояние s1, проехав которое мы наберем макс. скорость, время t2 и расстояние s2, проехав которой мы с макс. скорости затормозим до w, проверяем, что сумма этих расстояний меньше d, прибавляем время t3=(d-s1-s2)/v, которое мы будем ехать с макс. скоростью. На второй участок мы попадем со скоростью w.2. Вариант второй - мы не успеваем разогнаться до максимальной скорости и затормозить до скорости w к столбу, то есть s1+s2 > d. Тогда все очевидно - ищем, до какой скорости мы можем разогнаться (я делал это бинарным поиском, но не сомневаюсь что это не обязательно :о)), и считаем сколько времени уйдет чтобы разогнаться до нее и затормозить с нее до w. На второй участок выходим со скоросью w.3. Третий случай - мы вообще за интервал d не успеваем даже разогнаться до w. Тогда проезжаем весь интервал d на разгоне, на второй участок выходим со скоростью, которую успели набрать.Тут есть корнер кейс, который зачем-то поместили в первый семпл - если w > v, и третий случай рассматривается до первого, и за интервал d нельзя достичь скорости w, но можно успеть достичь скорости v. Тогда можно ошибочно на первом интервале разгоняться до скорости большей v. Но наличие первого семпла спасало от такой ошибки (и меня от лишнего штрафа :о))На второй интервал мы выходим либо со скоростью w, если мы попали в первые два случая, либо со скоростью меньшей, если в третий. Теперь тут два достаточно простых случая - мы либо разгоняемся до максимальной и проезжаем часть дороги на максимальной скорости, либо, если мы не успеваем за оставшийся фрагмент дороги достичь максимальной скорости, просто проезжаем весь участок с ускорением a.Задача E.Задача подозрительно похожа на задачу С :о)Найдем максимальный элемент в последовательности и сдвинем все так, чтобы он оказался первым (или любой из них, если их несколько). Теперь, если не учиытвать максимальные холмы, мы можем полагать, что холмы расположены на не окружности, а в ряд, что упрощает задачу. Дальше отдельно решим для пар холмов, оба из которых не максимальной длины, для пар холмов, один из которых не максимальной длины, и для пар холмов, оба из которых максимальной длины.1. Как посчитать количество пар, где оба холма ниже максимального? Будем идти слева на право, поддерживая стек высот холмов, которые теоретически еще могут быть видны, и их количеств. Разумеется, этот стек всегда будет содержать высоты, идущие по убыванию. Добавляя очередной холм:1.а) если он максимальной длины, просто очистим стек (ничто не может быть видно, он все загородил), и НЕ улучшаем ответ, и НЕ добавляем его в стек, так как сейчас считаем ответ только для пар, в которых оба холма ниже максимального.1.б) иначе, пока последний элемент в стеке содержит высоту ниже текущего холма, удаляем этот элемент, прибавляя количество таких холмов к ответу (каждый из этих холмов виден с нашего более высокого).1.в.i) если после этого высота последнего элемента в стеке равна нашей, прибавим его количество и еще единицу, если в стеке хотя бы два элемента (потому что мы видим все холмы нашей высоты и еще ровно один выше, если он существует)1.в.ii) если же после этого высота последнего элемента в стеке выше нашей, то просто прибавляем к ответу единицу (мы видим только этот самый правый холм).1.в.iii) если же стек после 1.б. остался пустой, не меняем ответ.1.г) если последний элемент в стеке равен нашему, увеличим его количество. Иначе добавим в конец стека текущий элемент с количеством=1.1.д) пройдя так по всему массиву мы посчитаем количество пар, где оба холма ниже макисимального2. Как посчитать количество пар, где один из холмов максимальный, а второй нет? Очень легко, начиная от каждого максимального холма идем влево и вправо пока не встретим другой максимальный холм, и считаем сколько холмов мы видим. Это будет линейное время, потому что каждый элемент будет пройден ровно дважды: от холма максимальной высоты слева от него и от холма максимальной высоты справа от него.3. Как посчитать количество пар, где оба холма максимальны? n*(n-1)/2 где n - количество холмов максимальной высоты.Затем суммируем ответы из 1, 2 и 3.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/204",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.6,
            "reason": "宽松匹配: 包含题目编号 5 和字母"
          },
          "content_length": 7401
        }
      ],
      "code_examples": [],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int a = inf.readInt(1, 10000, \"a\");\n    inf.readSpace();\n    int v = inf.readInt(1, 10000, \"v\");\n    inf.readEoln();\n\n    int l = inf.readInt(2, 10000, \"l\");\n    inf.readSpace();\n    int d = inf.readInt(1, l - 1, \"d\");\n    inf.readSpace();\n    int w = inf.readInt(1, 10000, \"w\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int a = inf.readInt(1, 10000, \"a\");\n    inf.readSpace();\n    int v = inf.readInt(1, 10000, \"v\");\n    inf.readEoln();\n\n    int l = inf.readInt(2, 10000, \"l\");\n    inf.readSpace();\n    int d = inf.readInt(1, l - 1, \"d\");\n    inf.readSpace();\n    int w = inf.readInt(1, 10000, \"w\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int a = inf.readInt(1, 10000, \"a\");\n    inf.readSpace();\n    int v = inf.readInt(1, 10000, \"v\");\n    inf.readEoln();\n\n    int l = inf.readInt(2, 10000, \"l\");\n    inf.readSpace();\n    int d = inf.readInt(1, l - 1, \"d\");\n    inf.readSpace();\n    int w = inf.readInt(1, 10000, \"w\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nconst double EPS = 1E-9;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare two sequences of doubles, max absolute or relative error = %.10f\", EPS);\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    double j = 0, p = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        n++;\r\n        j = ans.readDouble();\r\n        p = ouf.readDouble();\r\n        if (!doubleCompare(j, p, EPS)) {\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%.10f', found: '%.10f', error = '%.10f'\",\r\n                  n, englishEnding(n).c_str(), j, p, doubleDelta(j, p));\r\n        }\r\n    }\r\n\r\n    if (n == 1)\r\n        quitf(_ok, \"found '%.10f', expected '%.10f', error '%.10f'\", p, j, doubleDelta(j, p));\r\n\r\n    quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int a = opt<int>(\"a\", 0);\n    int v = opt<int>(\"v\", 0);\n    int l = opt<int>(\"l\", 0);\n    int d = opt<int>(\"d\", -1);\n    int w = opt<int>(\"w\", 0);\n\n    // Generate random values if parameters are zero or not provided\n    if (a == 0) a = rnd.next(1, 10000);\n    if (v == 0) v = rnd.next(1, 10000);\n    if (l == 0) l = rnd.next(2, 10000);\n    if (w == 0) w = rnd.next(1, 10000);\n\n    // Ensure that d is in the range [1, l - 1]\n    if (d == -1) d = rnd.next(1, l - 1);\n    else if (d >= l || d < 1) {\n        fprintf(stderr, \"Invalid value for d: d must be in [1, l-1]\\n\");\n        return 1;\n    }\n\n    printf(\"%d %d\\n\", a, v);\n    printf(\"%d %d %d\\n\", l, d, w);\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int a = opt<int>(\"a\", 0);\n    int v = opt<int>(\"v\", 0);\n    int l = opt<int>(\"l\", 0);\n    int d = opt<int>(\"d\", -1);\n    int w = opt<int>(\"w\", 0);\n\n    // Generate random values if parameters are zero or not provided\n    if (a == 0) a = rnd.next(1, 10000);\n    if (v == 0) v = rnd.next(1, 10000);\n    if (l == 0) l = rnd.next(2, 10000);\n    if (w == 0) w = rnd.next(1, 10000);\n\n    // Ensure that d is in the range [1, l - 1]\n    if (d == -1) d = rnd.next(1, l - 1);\n    else if (d >= l || d < 1) {\n        fprintf(stderr, \"Invalid value for d: d must be in [1, l-1]\\n\");\n        return 1;\n    }\n\n    printf(\"%d %d\\n\", a, v);\n    printf(\"%d %d %d\\n\", l, d, w);\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Test case 1: All values random\n./gen\n\n# Test case 2: Minimum values\n./gen --a 1 --v 1 --l 2 --d 1 --w 1\n\n# Test case 3: Maximum values\n./gen --a 10000 --v 10000 --l 10000 --d 9999 --w 10000\n\n# Test case 4: w = v\n./gen --w 5000 --v 5000\n\n# Test case 5: w < v\n./gen --v 5000 --w 3000\n\n# Test case 6: w > v\n./gen --v 5000 --w 7000\n\n# Test case 7: d = 1\n./gen --d 1\n\n# Test case 8: d = l - 1\n./gen --l 1000 --d 999\n\n# Test case 9: w = 1\n./gen --w 1\n\n# Test case 10: w = 10000\n./gen --w 10000\n\n# Test case 11: a = 1\n./gen --a 1\n\n# Test case 12: a = 10000\n./gen --a 10000\n\n# Test case 13: v = 1\n./gen --v 1\n\n# Test case 14: v = 10000\n./gen --v 10000\n\n# Test case 15: Random, but w = v\n./gen --w 9999 --v 9999\n\n# Test case 16: Random, but w = v = 1\n./gen --w 1 --v 1\n\n# Test case 17: Random, but w = v = 10000\n./gen --w 10000 --v 10000\n\n# Test case 18: w = v + 1 (w > v)\n./gen --v 5000 --w 5001\n\n# Test case 19: w = v - 1 (w < v)\n./gen --v 5000 --w 4999\n\n# Test case 20: l = 2, d = 1\n./gen --l 2 --d 1\n\n# Test case 21: l = 10000, d = 1\n./gen --l 10000 --d 1\n\n# Test case 22: Large a, small v\n./gen --a 10000 --v 1\n\n# Test case 23: Small a, large v\n./gen --a 1 --v 10000\n\n# Test case 24: All maximum, w < v\n./gen --a 10000 --v 10000 --l 10000 --d 9999 --w 9999\n\n# Test case 25: All maximum, w > v\n./gen --a 10000 --v 9999 --l 10000 --d 9999 --w 10000\n\n# Test case 26: Random, w = 1\n./gen --w 1\n\n# Test case 27: Random, w = 10000\n./gen --w 10000\n\n# Test case 28: Middle values\n./gen --a 5000 --v 5000 --l 5000 --d 2500 --w 5000\n\n# Test case 29: Small values\n./gen --a 10 --v 10 --l 10 --d 5 --w 10\n\n# Test case 30: Large values\n./gen --a 9999 --v 9999 --l 9999 --d 8888 --w 9999\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:39:44.726551",
        "total_tutorials": 3,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "5/E",
      "title": "E. Bindian Signalizing",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test4 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line of the input data contains an integer number n (3 ≤ n ≤ 106), n — the amount of hills around the capital. The second line contains n numbers — heights of the hills in clockwise order. All height numbers are integer and lie between 1 and 109.",
      "output_spec": "OutputPrint the required amount of pairs.",
      "sample_tests": "ExamplesInputCopy51 2 4 5 3OutputCopy7",
      "description": "E. Bindian Signalizing\n\ntime limit per test4 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line of the input data contains an integer number n (3 ≤ n ≤ 106), n — the amount of hills around the capital. The second line contains n numbers — heights of the hills in clockwise order. All height numbers are integer and lie between 1 and 109.\n\nOutputPrint the required amount of pairs.\n\nInputCopy51 2 4 5 3OutputCopy7\n\nInputCopy51 2 4 5 3\n\nOutputCopy7",
      "solutions": [
        {
          "title": "Codeforces Beta Round #5 - Codeforces",
          "content": "Welcome and good luck on the round! I'd like to remind that if you have any questions on the problems, the best way to ask them is to use the web interface on the problems page. Later in the same post we will discuss the round. Wish you high rating,MikeMirzayanov.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/196",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 264
        },
        {
          "title": "Codeforces Beta Round #5 - Tutorial - Codeforces",
          "content": "As there is no tutorial of Codeforces Beta Round #5 in English, I have decided to write this one. Possibly, some ideas will be similar to ones, expressed in Russian tutorial made by SkidanovAlex, but I hope everybody will find some useful in this problem analysis too.Problems A and B.Both are implementation problems. The only difficult, many participants faced with - to read data correctly. It is recommended to use gets(s) or getline(cin, s) in C++, readLine() method of BufferedReader class in Java.Problem C.First of all, for each closing bracket in our string let's define 2 values:d[j] = position of corresponding open bracket, or -1 if closing bracket doesn't belong to any regular bracket sequence. c[j] = position of earliest opening bracket, such that substring s(c[j], j) (both boundaries are inclusive) is a regular bracket sequence. Let's consider c[j] to be -1 if closing bracket doesn't belong to any regular bracket sequence. It can be seen, that c[j] defines the beginning position of the longest regular bracket sequence, which will end in position j. So, having c[j] answer for the problem can be easily calculated.Both d[j] and c[j] can be found with following algorithm, which uses stack.Iterate through the characters of the string.If current character is opening bracket, put its position into the stack.If current character is closing bracket, there are 2 subcases:Stack is empty - this means that current closing bracket doesn't have corresponding open one. Hence, both d[j] and c[j] are equal to -1. Stack is not empty - we will have position of the corresponding open bracket on the top of the stack - let's put it to d[j] and remove this position from the stack. Now it is obvious, that c[j] is equal at least to d[j]. But probably, there is a better value for c[j]. To find this out, we just need to look at the position d[j] - 1. If there is a closing bracket at this position, and c[d[j] - 1] is not -1, than we have 2 regular bracket sequences s(c[d[j] - 1], d[j] - 1) and s(d[j], j), which can be concatenated into one larger regular bracket sequence. So we put c[j] to be c[d[j] - 1] for this case.Problem D.This problem can be solved by careful case handling. Let's construct O(1) solution for it.First of all, let's define 2 functions:dist(speed, time) - calculates the distance will be covered in specified time, if car's current speed is speed. This function will not take car's speed limit into account. Also it assumes, that car is always driven with maximum acceleration a. It is obvious that required distance is equal to .travelTime(distance, speed) - calculates the time, required to travel specified distance, if car have starting speed equal to speed. This function will also take care about car's speed limit.We will have the following quadratic equation for time t: . This equation will have exactly 2 different roots. Using Viete's formulas it can be concluded, that one root of the equation is non-positive and other is non-negative. Let's define the larger root of the equation as tAll. It will be the answer, if there is no car's speed limit. To take the limit into account let's find the time, required to gain car's max speed. tMax = (v - speed) / a. If tMax ≥  tAll, function should just returns tAll as a result. Otherwise result is tMax hours to achieve car's maximal speed plus (distance - dist(speed, tMax)) / v hours to cover remaining distance.Having these functions, solution will be the following:If v ≤ w, answer is travelTime(l, 0).Calculate tw = w / a -  time, required to gain speed w.Consider dw = dist(0, tw).If dw ≥ d, we will pass the point there sign is placed before we gain speed w. Answer for this case is travelTime(l, 0) as well.Otherwise, we will gain speed w before the sign. Let's consider segment of the road [dw, d]. We need to find out the best strategy to drive it. It is obvious, that we definitely should have speed w at the both ends of this segment. Also we know, that acceleration is equal to deceleration. Taking these facts into account we can see, that the speed in the optimal solution will be symmetrical with respect to the middle of the segment [dw, d]. Hence answer for this case will be tw + 2 *  travelTime(0.5 * (d - dw), w) + travelTime(l - d, w).Problem E.Let's reduce the problem from the circle to the straight line. Perform the following actions to do it:Find the hill with the maximal height (if it is not unique, choose any).Rotate all the sequence in such a way that hill with maximal height goes first. For convenience, add one more hill with maximum height to the end of the sequence. (It will represent the first hill, which goes after the last in the circle order).Now we have almost the same problem on the straight line. One exception is that now first hill is doubled.General idea of the solution:Consider there is a pair of hills, such that these hills are visible from each other. Let's define hill with lower height (if heights are equal - with lower position) as responsible for adding this pair to the answer.From this point of view, hill x will adds to the answer 3 kinds of hills as his pair:First hill to the left of the x, which is strictly higher than x. (Let's define its position as l[x])First hill to the right of the x, which is strictly higher than x. (Let's call this hill y and define it's position as r[x]).All hills that are as high as x and are located between x and y. (Let's define this count as c[x]).Arrays r[x] and c[x] can be calculated by the following piece of code:c[n] = 0;for(int i = n - 1; i >= 0; --i) {    r[i] = i + 1;    while (r[i] < n && height[i] > height[r[i]]) r[i] = r[r[i]];    if (r[i] < n && height[i] == height[r[i]]) {        c[i] = c[r[i]] + 1;        r[i] = r[r[i]];    }}I am not going to prove here, that it works for the O(N) time, but believe it does :)Pay attention, that r[x] is undefined for hills with maximum height and this algorithm will find r[x] = n for such hills.Array l[x] can be found in a similar way.Having l[x], r[x] and c[x], it's not so difficult to calculate the answer. We should just notice, that:Each hill will add c[x] pairs to the answer.Each hill, lower than maximal, will also add 2 pairs (x, l[x]) and (x, r[x]) to the answer. The only corner case here is l[x] = 0 and r[x] = n, because (x, 0) and (x, n) is the same pair of hills in the original problem, where hills are circled.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/213",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.6,
            "reason": "宽松匹配: 包含题目编号 5 和字母"
          },
          "content_length": 6377
        },
        {
          "title": "C, D и E с CBR5 - разбор - Codeforces",
          "content": "Сначала хотел написать полный разбор, но как разбирать задачи A и B я не представляю :о) Разве что можно сказать, что на C++ чтобы читать до конца надо использовать while( gets( s ) ), а если вы не любите перенаправлять файлы и вводите тест прямо в консоль, то чтобы обозначить конец файла надо нажать Ctrl+Z.Задача СДавайте введем понятие баланса некоторого префикса подстроки - на сколько открывающихся скобок больше в этом префиксе, чем закрывающихся. Понятно, что некоторая строка является правильной скобочной подпоследовательностью, если для всей строки баланс равен нулю, а для любого ее префикса не отрицателен. Посчитаем баланс для каждого префикса данной нам в задаче строки и сложим их в массив prefs. Теперь рассмотрим любую подстроку это строки - пусть она идет от символа с позицией l включительно до символа в позиции r исключительно. Эта подстрока - правильная скобочная последовательность, если prefs[l] == prefs[r] и prefs[i] >= prefs[l] для любого i в интервале [l, r). Как нам теперь, зная это, найти максимальную подстроку правильную и их количество? Будем делать примерно так: поддерживать стек пар (баланс-позиция) - на какой позиции в строке впервые был замечен такой баланс, после которой еще не встречался меньший баланс. На самом деле можно даже хранить только позиции, потому что баланс всегда очевиден - в последнем элементе в стеке всегда будет текущий баланс, в предпоследнем на единицу меньше итд. Рассмотрим теперь скажем последовательность ((()())))(()). Балансы: 1,2,3,2,3,2,1,0,-1,0,1,0,-1Будем идти слева на право и поддерживать наш стек следующим образом: добавляя открывающуюся скобку добавлять в стек позицию этой скобки, а добавляя закрывающуюся удалять последний элемент из стека, улучшая ответ. Пример с нашей последовательносью:1. Помним, что на позиции 0 (то есть до добавления любой скобки) баланс был 0. То есть сейчас стек: 02. Добавляем первую скобку. Занесем ее позицию в стек. Стек: 0,13. Добавим вторую скобку. Занесем ее позицию в стек. Стек: 0,1,24. Аналогично для третьей скобки. Стек 0,1,2,35. Четвертая скобка - закрывающаяся. Соответственно удалим последний элемент из стека, Текущий стек: 0,1,2. Запоминаем, что мы нашли последоательность длины 2 (позиция-последний элемент в стеке после удаления, 4-2=2). 6. Пятая скобка - открывающаяся, добавим ее в стек: 0,1,2,57. Шестая скобка - закрывающаяся, удалим из стека последний элемент, запомним, что мы нашли последовательность длины 4. Стек: 0,1,28. Седьма скобка - закрывающаяся, удалим из стека последний элемент, запомнив, что мы нашли последовательность длины (7-1)=6. Стек: 0,1.9. Восьмая скобка - закрывающаяся, удалим из стека последний элемент, запомнив, что мы нашли последовательность длины (8-0)=8. Стек: 010. Девятая скобка - закрывающаяся, удалим из стека последний элемент. Стек: пустой.11. 10-ая скобка закрывающаяся, но стек и так пустой - ничего не меняем.12. Скобка открывающаяся, стек: 1113. Скобка открывающаяся, стек: 11,1214. Далее две закрывающихся скобки очистят стек и еще одна ничего не изменит, ответа больше 8 найдено не будет, таким образом мы нашли ответ 8.Задача DЭто задача хитрая на рассмотрение граничных случаев.Сначала случаи до столба:1. Самый простой - мы разгоняемся до макисимальной скорости, едем на ней участок и тормозим до скорости w. Достаточно просто - считаем время t1 и расстояние s1, проехав которое мы наберем макс. скорость, время t2 и расстояние s2, проехав которой мы с макс. скорости затормозим до w, проверяем, что сумма этих расстояний меньше d, прибавляем время t3=(d-s1-s2)/v, которое мы будем ехать с макс. скоростью. На второй участок мы попадем со скоростью w.2. Вариант второй - мы не успеваем разогнаться до максимальной скорости и затормозить до скорости w к столбу, то есть s1+s2 > d. Тогда все очевидно - ищем, до какой скорости мы можем разогнаться (я делал это бинарным поиском, но не сомневаюсь что это не обязательно :о)), и считаем сколько времени уйдет чтобы разогнаться до нее и затормозить с нее до w. На второй участок выходим со скоросью w.3. Третий случай - мы вообще за интервал d не успеваем даже разогнаться до w. Тогда проезжаем весь интервал d на разгоне, на второй участок выходим со скоростью, которую успели набрать.Тут есть корнер кейс, который зачем-то поместили в первый семпл - если w > v, и третий случай рассматривается до первого, и за интервал d нельзя достичь скорости w, но можно успеть достичь скорости v. Тогда можно ошибочно на первом интервале разгоняться до скорости большей v. Но наличие первого семпла спасало от такой ошибки (и меня от лишнего штрафа :о))На второй интервал мы выходим либо со скоростью w, если мы попали в первые два случая, либо со скоростью меньшей, если в третий. Теперь тут два достаточно простых случая - мы либо разгоняемся до максимальной и проезжаем часть дороги на максимальной скорости, либо, если мы не успеваем за оставшийся фрагмент дороги достичь максимальной скорости, просто проезжаем весь участок с ускорением a.Задача E.Задача подозрительно похожа на задачу С :о)Найдем максимальный элемент в последовательности и сдвинем все так, чтобы он оказался первым (или любой из них, если их несколько). Теперь, если не учиытвать максимальные холмы, мы можем полагать, что холмы расположены на не окружности, а в ряд, что упрощает задачу. Дальше отдельно решим для пар холмов, оба из которых не максимальной длины, для пар холмов, один из которых не максимальной длины, и для пар холмов, оба из которых максимальной длины.1. Как посчитать количество пар, где оба холма ниже максимального? Будем идти слева на право, поддерживая стек высот холмов, которые теоретически еще могут быть видны, и их количеств. Разумеется, этот стек всегда будет содержать высоты, идущие по убыванию. Добавляя очередной холм:1.а) если он максимальной длины, просто очистим стек (ничто не может быть видно, он все загородил), и НЕ улучшаем ответ, и НЕ добавляем его в стек, так как сейчас считаем ответ только для пар, в которых оба холма ниже максимального.1.б) иначе, пока последний элемент в стеке содержит высоту ниже текущего холма, удаляем этот элемент, прибавляя количество таких холмов к ответу (каждый из этих холмов виден с нашего более высокого).1.в.i) если после этого высота последнего элемента в стеке равна нашей, прибавим его количество и еще единицу, если в стеке хотя бы два элемента (потому что мы видим все холмы нашей высоты и еще ровно один выше, если он существует)1.в.ii) если же после этого высота последнего элемента в стеке выше нашей, то просто прибавляем к ответу единицу (мы видим только этот самый правый холм).1.в.iii) если же стек после 1.б. остался пустой, не меняем ответ.1.г) если последний элемент в стеке равен нашему, увеличим его количество. Иначе добавим в конец стека текущий элемент с количеством=1.1.д) пройдя так по всему массиву мы посчитаем количество пар, где оба холма ниже макисимального2. Как посчитать количество пар, где один из холмов максимальный, а второй нет? Очень легко, начиная от каждого максимального холма идем влево и вправо пока не встретим другой максимальный холм, и считаем сколько холмов мы видим. Это будет линейное время, потому что каждый элемент будет пройден ровно дважды: от холма максимальной высоты слева от него и от холма максимальной высоты справа от него.3. Как посчитать количество пар, где оба холма максимальны? n*(n-1)/2 где n - количество холмов максимальной высоты.Затем суммируем ответы из 1, 2 и 3.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/204",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.6,
            "reason": "宽松匹配: 包含题目编号 5 和字母"
          },
          "content_length": 7401
        }
      ],
      "code_examples": [],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(3, 1000000, \"n\");\n    inf.readEoln();\n    inf.readInts(n, 1, 1000000000, \"h\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(3, 1000000, \"n\");\n    inf.readEoln();\n    inf.readInts(n, 1, 1000000000, \"h\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(3, 1000000, \"n\");\n    inf.readEoln();\n    inf.readInts(n, 1, 1000000000, \"h\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\");\n\n    vector<int> hills(n);\n\n    if (type == \"random\") {\n        int maxh = opt<int>(\"maxh\", 1000000000);\n        for (int i = 0; i < n; ++i) {\n            hills[i] = rnd.next(1, maxh);\n        }\n    } else if (type == \"same\") {\n        int h = opt<int>(\"h\", rnd.next(1, 1000000000));\n        for (int i = 0; i < n; ++i) {\n            hills[i] = h;\n        }\n    } else if (type == \"increasing\") {\n        int minh = opt<int>(\"minh\", 1);\n        int maxh = opt<int>(\"maxh\", 1000000000);\n        for (int i = 0; i < n; ++i) {\n            hills[i] = minh + (long long)(maxh - minh) * i / (n - 1);\n        }\n    } else if (type == \"decreasing\") {\n        int minh = opt<int>(\"minh\", 1);\n        int maxh = opt<int>(\"maxh\", 1000000000);\n        for (int i = 0; i < n; ++i) {\n            hills[i] = maxh - (long long)(maxh - minh) * i / (n - 1);\n        }\n    } else if (type == \"alternating\") {\n        int h1 = opt<int>(\"h1\", 1);\n        int h2 = opt<int>(\"h2\", 1000000000);\n        for (int i = 0; i < n; ++i) {\n            hills[i] = (i % 2 == 0) ? h1 : h2;\n        }\n    } else if (type == \"almost_same\") {\n        int h = opt<int>(\"h\", rnd.next(1, 1000000000));\n        for (int i = 0; i < n; ++i) {\n            hills[i] = h;\n        }\n        int idx = rnd.next(0, n - 1);\n        hills[idx] = h + 1 <= 1000000000 ? h + 1 : h - 1;\n    } else if (type == \"plateau\") {\n        int h1 = opt<int>(\"h1\", 1);\n        int h2 = opt<int>(\"h2\", 1000000000);\n        int plateau_size = opt<int>(\"plateau_size\", n / 2);\n        plateau_size = min(max(plateau_size, 1), n - 1);\n        for (int i = 0; i < n; ++i) {\n            if (i < plateau_size)\n                hills[i] = h1;\n            else\n                hills[i] = h2;\n        }\n    } else {\n        // Handle unknown type\n        fprintf(stderr, \"Unknown type '%s'\\n\", type.c_str());\n        return 1;\n    }\n\n    // Output\n    printf(\"%d\\n\", n);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d\", hills[i]);\n        if (i + 1 < n) {\n            printf(\" \");\n        } else {\n            printf(\"\\n\");\n        }\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\");\n\n    vector<int> hills(n);\n\n    if (type == \"random\") {\n        int maxh = opt<int>(\"maxh\", 1000000000);\n        for (int i = 0; i < n; ++i) {\n            hills[i] = rnd.next(1, maxh);\n        }\n    } else if (type == \"same\") {\n        int h = opt<int>(\"h\", rnd.next(1, 1000000000));\n        for (int i = 0; i < n; ++i) {\n            hills[i] = h;\n        }\n    } else if (type == \"increasing\") {\n        int minh = opt<int>(\"minh\", 1);\n        int maxh = opt<int>(\"maxh\", 1000000000);\n        for (int i = 0; i < n; ++i) {\n            hills[i] = minh + (long long)(maxh - minh) * i / (n - 1);\n        }\n    } else if (type == \"decreasing\") {\n        int minh = opt<int>(\"minh\", 1);\n        int maxh = opt<int>(\"maxh\", 1000000000);\n        for (int i = 0; i < n; ++i) {\n            hills[i] = maxh - (long long)(maxh - minh) * i / (n - 1);\n        }\n    } else if (type == \"alternating\") {\n        int h1 = opt<int>(\"h1\", 1);\n        int h2 = opt<int>(\"h2\", 1000000000);\n        for (int i = 0; i < n; ++i) {\n            hills[i] = (i % 2 == 0) ? h1 : h2;\n        }\n    } else if (type == \"almost_same\") {\n        int h = opt<int>(\"h\", rnd.next(1, 1000000000));\n        for (int i = 0; i < n; ++i) {\n            hills[i] = h;\n        }\n        int idx = rnd.next(0, n - 1);\n        hills[idx] = h + 1 <= 1000000000 ? h + 1 : h - 1;\n    } else if (type == \"plateau\") {\n        int h1 = opt<int>(\"h1\", 1);\n        int h2 = opt<int>(\"h2\", 1000000000);\n        int plateau_size = opt<int>(\"plateau_size\", n / 2);\n        plateau_size = min(max(plateau_size, 1), n - 1);\n        for (int i = 0; i < n; ++i) {\n            if (i < plateau_size)\n                hills[i] = h1;\n            else\n                hills[i] = h2;\n        }\n    } else {\n        // Handle unknown type\n        fprintf(stderr, \"Unknown type '%s'\\n\", type.c_str());\n        return 1;\n    }\n\n    // Output\n    printf(\"%d\\n\", n);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d\", hills[i]);\n        if (i + 1 < n) {\n            printf(\" \");\n        } else {\n            printf(\"\\n\");\n        }\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 3 -type random\n./gen -n 5 -type random\n./gen -n 10 -type increasing\n./gen -n 10 -type decreasing\n./gen -n 10 -type same -h 5\n./gen -n 10 -type alternating -h1 1 -h2 2\n./gen -n 10 -type almost_same -h 100\n./gen -n 10 -type plateau -h1 10 -h2 20 -plateau_size 5\n\n./gen -n 1000 -type random\n./gen -n 1000 -type increasing\n./gen -n 1000 -type decreasing\n./gen -n 1000 -type same -h 1000000\n./gen -n 1000 -type alternating -h1 1 -h2 10\n./gen -n 1000 -type almost_same -h 500000\n./gen -n 1000 -type plateau -h1 500000 -h2 1000000 -plateau_size 700\n\n./gen -n 1000000 -type random\n./gen -n 1000000 -type increasing\n./gen -n 1000000 -type decreasing\n./gen -n 1000000 -type same -h 1\n./gen -n 1000000 -type alternating -h1 1 -h2 1000000000\n./gen -n 1000000 -type almost_same -h 999999999\n./gen -n 1000000 -type plateau -h1 1 -h2 1000000000 -plateau_size 500000\n\n./gen -n 3 -type same -h 1\n./gen -n 3 -type same -h 1000000000\n\n./gen -n 999999 -type random -maxh 1000000000\n\n./gen -n 500000 -type plateau -h1 999999999 -h2 1 -plateau_size 1\n./gen -n 500000 -type plateau -h1 1 -h2 999999999 -plateau_size 499999\n\n./gen -n 100000 -type random -maxh 10\n./gen -n 100000 -type random -maxh 1000000000\n\n./gen -n 1000 -type almost_same -h 1\n./gen -n 1000 -type almost_same -h 1000000000\n\n./gen -n 1000000 -type alternating -h1 1000000000 -h2 1000000000\n./gen -n 1000000 -type alternating -h1 1 -h2 1\n\n./gen -n 1000000 -type same -h 999999999\n\n./gen -n 500000 -type increasing -minh 1 -maxh 500000\n./gen -n 500000 -type decreasing -minh 500000 -maxh 1000000000\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:39:46.939143",
        "total_tutorials": 3,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "50/A",
      "title": "A. Domino piling",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputIn a single line you are given two integers M and N — board sizes in squares (1 ≤ M ≤ N ≤ 16).",
      "output_spec": "OutputOutput one number — the maximal number of dominoes, which can be placed.",
      "sample_tests": "ExamplesInputCopy2 4OutputCopy4InputCopy3 3OutputCopy4",
      "description": "A. Domino piling\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputIn a single line you are given two integers M and N — board sizes in squares (1 ≤ M ≤ N ≤ 16).\n\nOutputOutput one number — the maximal number of dominoes, which can be placed.\n\nInputCopy2 4OutputCopy4InputCopy3 3OutputCopy4\n\nInputCopy2 4\n\nOutputCopy4\n\nInputCopy3 3\n\nOutputCopy4",
      "solutions": [
        {
          "title": "Codeforces Beta Round #47 - Codeforces",
          "content": "Good afternoon.One more codeforces format round takes place this evening. I'm the author of the contest problems. Artem Rakhov and Maria Belova helped me to prepare the problems. Great thanks to them and all codeforces \"fighters\"!I wish you good luck and funny hacks!P.S:  This round won't be rated. So your ratings won't change. That's because of severe problems with codeforces server. Read here for explanation.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/985",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 414
        },
        {
          "title": "Codeforces #47 problem solutions - Codeforces",
          "content": "Problem A: Answer is floor(N*M*0.5). Since there is N*M cells on the board and each domino covers exactly two of them we cannot place more for sure. Now let's show how to place exactly this number of dominoes. If N is even, then place M rows of N/2 dominoes and cover the whole board. Else N is odd, so cover N-1 row of the board as shown above and put floor(M/2) dominoes to the last row. In the worst case (N and M are odd) one cell remains uncovered. Problem B: Of course you were expected to code solution which is not quadratic in time complexity. Iterate over the string and count how many times each char is used. Let Ki be the number of occurrences of char with ASCII-code i in the string S. Then answer is sum(Ki2). While coding the solution the following common mistakes were made:1. Code quadratic solution (double loop over the string)2. Forget to use int64. Whether in answer or in Ki squaring.3. Wrong int64 output.All these problems were easily hacked by max test with 100000 equal chars. This turned the hacking process into the game \"who hacks the next B solution faster\" because newbies often made all these mistakes. This problem was severed by the fact that GCC-compiler turned out to be MinGW-compiler, so output like printf(\"%lld\", ...) did not work on it. Another strange problem hackers faced was quiet test truncation by length about 30000 when copy/pasting it into the test editor. Of course the overflow in solution disappears after it.Problem C: You were asked to make all the cows strictly inside the interior of the route. Initially I planned to put \"non-strict\" there, but later I abandoned this idea because the answer for single point was really weird then=) The difference in solution is quite small. The answer for \"strict\" problem is always more than for \"non-strict\" by exactly 4. Some coders preferred to add four neighboring points for each point like a cross to switch to solving non-strict problem.The non-strict problem is solved in the following way. Notice that the required route can always be searched as an octagon, perhaps with some zero sides. Take four pairs of parallel lines and \"press\" it to the points. In other words, we find axis-aligned bounding box for the set of points. Then find axis-aligned bounding box of the point set on the picture which is rotated by 45 degrees. Now intersect these two boxes (as filled figures). We get an octagon in the common case, which is the required one. To implement the solution, we have to calculate minimums and maximums of X, Y, X+Y, X-Y through all the points, then use non-trivial formulas to get the answer.A lot of contestants solved the problem in other way. It is easy to see that to move by vector (X, Y) shepherd needs to make max(|X|, |Y|) turns. We can make the shepherd walk along the vertices of convex hull. We need to run a standard Graham scan and then iterate through all the points on the hull and sum max(|X'-X|, |Y'-Y|) for all pairs of neighboring vertices in it. This solution is also correct.There was an idea to make limit on coordinates equal to 109, but we decided that there was no need to ask for int64 again. Perhaps it'd have been better if there'd been int64 in this problem instead of problem B.Problem D: The problem statement looks intricate and aggressive. That's because the problem legend originates from civil defense classes in the university. Civil defense is such a discipline which for example teaches how to behave before and after nuclear attack...First of all we should notice that the bigger the warhead, the better (I mean the probability to succeed is higher). This seems quite reasonable. Function P(D, R) increases as R increases with fixed D. Obviously the probability to hit at least K objects increases in this case too. Hence we can find the answer by binary search. We have to be able to find the probability to accomplish the mission with fixed and known radius R to perform binary search.Now we have to solve the problem: there are N objects, each of them is destroyed with given probability (pi). Find the probability to destroy at least K of them. The problem is solved by dynamic programming which is similar to calculating binomial coefficients using Pascal's triangle. Let R[i, j] be the probability to hit exactly j objects among the first i of all the given ones. If we find all the R values for 0<=j<=i<=N, then the answer is calculated as sum_{j=k..N} R[N, j]. The base of DP is: R[0, 0] = 1. Induction (calculating the new values) is given by the formula R[i, j] = R[i-1, j-1] * pi + R[i-1, j] * (1-pi). Keep in mind that for j<0 or j>i all the elements of R are zeroes.It was shown experimentally that many coders (me included) try to solve the problem by taking into account only the closest K targets. I.e. they think that the probability to succeed is simply p1 * p2 *... * pK. This is wrong: for example, if two buildings with equal distance are given, then the probability to hit at least one of them is 1-(1-p)2 instead of p. But I decided to please these coders and composed the pretests only of the cases on which this solution passes=) So this particular incorrect solution was passing all the pretests intentionally.Problem E: Let D = b2-c be quarter of discriminant. The equation roots are -b-sqrt(D) и -b+sqrt(D). Thus there are two types of roots: irrational ones like x +- sqrt(y) and integer ones. We count the number of different roots separately for these types.Irrational roots are in form x+sqrt(y) (y is not square of integer). If two numbers in this form are equal, then their x и y values are also equal. It can be checked on the piece of paper. The main idea is to use irrationality of sqrt(y). Thus if two irrational roots are equal, then the equations are the same. Hence all the irrational roots of all the given equations are different. Let's iterate b=1..N. For each of b values we have to find the number of equations with positive discriminant which are not squares on integers. I.e. number of c=1...M with D = b2-c is not square of integer. We can calculate set of all possible values of D as a segment [L; R] (L >= 0). Then take its size (R-L+1) and subtract number of squares in it. It is exactly the the number of equations with irrational roots for a fixed b. Multiply it by 2 (two roots per equation) and add it to the answer.Now let's handle integer roots. For a fixed b we've calculated the segment [L;R] of all D values. Then sqrt(D) takes integer values in segment [l; r] = [ceil(sqrt(L)); floor(sqrt(R))]. We put this segment into the formula for equation roots and understand that all the integer roots of equations with fixed b compose segments [-b-r;-b-l] и [-b+l;-b+r]. However the integer roots may substantially be equal for different equations. That's why we have to mark in a global data structure that all the roots in these two segments are \"found\". After we iterate through all b=1..N, we have to find number of integers marked at least once in this data structure.This data structure is implemented on array. All the integer roots of equations lie in bounds from -10000000 to 0. Allocate an array Q which is a bit larger in size. To mark segment [s; t] we increment Q[s] by one and decrement Q[t+1] by one. At the end of the solution iterate through the whole array Q from left to right and calculate prefix sums to array S. I.e. S[i] = Q[-10000010] + Q[-10000009] + ... + Q[i-1] + Q[i]. Then S[i] represents number of times we've marked number i. Now iterate through S array and count number of nonzero elements. It is the number of different integer roots.The solution requires O(N) time since we have to iterate through all b values. It is likely that purely combinatoric (O(1)) formula for answer exists=)Conclusion. I think that there were two problems in the contest (except the system's epic fail of course). The first: there was no technically hard problem. Because of this high-rated coders had solved all the problems by the end of first hour and had to torture themselves by hacking others in heavily instable contest system during the remaining hour. I think that problem E in any round should be really tough to code. The second problem is huge number of hacks for problem B. I should have set the limit on string length to 40000. There is one more interesting question: why are divisions merged together? It would be wiser if any room were first division only or second division only. Then first division coders would concentrate on hacking solution for difficult problems instead of catching simple newbies' mistakes.Reminder: you can see the tests for all problems in contest system.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/1006",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 8615
        },
        {
          "title": "Round# 47 simple tutorial - Codeforces",
          "content": "An*m/2.BRecord the occurrences' number of each letters, signed as cnt[char].For each char in string, get the cnt[c]^2 plus together, and this is the answer.CCalculate the Convex Hull. The sum of the max value between x-difference and y-difference of each adjacent points in the convex hull's set and 4 is the answer.4 step can make a circle of 360 degree.DCounting the answer with Half, and check the answer using Dynamic Programming.Let dp[i][j] means the probability of first i objects where j of them exploded, and the transfering formular is:dp[i][j] = P(i) * dp[i - 1][j - 1] + (1 - P(i)) * dp[i - 1][j], where P(i) means the i-th object exploding's probability.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/1003",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 667
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces #47 problem solutions - Codeforces - Code 1",
          "code": "#include<stdio.h>#include<string.h>char a[1000009];int b[256];int main(){        __int64 i,sum,n;        gets(a);        n=strlen(a);        for(i=0;i<n;i++){                ++b[a[i]];        }        sum=0;        for(i=0;i<256;i++){                if(b[i]){                        sum+=b[i]*b[i];                        b[i]=0;                }        }        printf(\"%I64d\\n\",sum);        return 0;}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/1006",
          "author": "jiangly"
        },
        {
          "title": "Codeforces #47 problem solutions - Codeforces - Code 2",
          "code": "sum+=b[i]*b[i];That's the mistake. Compiler will calculate the right part first: b[i] is int, so b[i]*b[i] is int too.If b[i]=100000, this line became the following: sum += 1410065408;So you should writesum+=(__int64)b[i]*b[i];instead.Compiler see that the first operand is __int64, and will convert the second one to __int64 too.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/1006",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    \n    vector<int> numbers = inf.readInts(2, 1, 16, \"M and N\");\n    int M = numbers[0];\n    int N = numbers[1];\n    inf.readEoln();\n    ensuref(M <= N, \"Expected M <= N, but M=%d and N=%d\", M, N);\n    inf.readEof();\n    \n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    \n    vector<int> numbers = inf.readInts(2, 1, 16, \"M and N\");\n    int M = numbers[0];\n    int N = numbers[1];\n    inf.readEoln();\n    ensuref(M <= N, \"Expected M <= N, but M=%d and N=%d\", M, N);\n    inf.readEof();\n    \n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    \n    vector<int> numbers = inf.readInts(2, 1, 16, \"M and N\");\n    int M = numbers[0];\n    int N = numbers[1];\n    inf.readEoln();\n    ensuref(M <= N, \"Expected M <= N, but M=%d and N=%d\", M, N);\n    inf.readEof();\n    \n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int maxN = opt<int>(\"maxN\", 16);\n    string type = opt<string>(\"type\", \"random\");\n\n    int M, N;\n\n    if (type == \"minimal\") {\n        /* Minimal case: M = N = 1 */\n        M = N = 1;\n    } else if (type == \"maximal\") {\n        /* Maximal case: M = N = maxN */\n        M = N = maxN;\n    } else if (type == \"random\") {\n        /* Random M and N where 1 ≤ M ≤ N ≤ maxN */\n        M = rnd.next(1, maxN);\n        N = rnd.next(M, maxN); // Ensure M ≤ N\n    } else if (type == \"even\") {\n        /* Both M and N are even numbers */\n        int maxEven = maxN / 2;\n        int mEven = rnd.next(1, maxEven);\n        int nEven = rnd.next(mEven, maxEven);\n        M = mEven * 2;\n        N = nEven * 2;\n    } else if (type == \"odd\") {\n        /* Both M and N are odd numbers */\n        int maxOdd = (maxN + 1) / 2;\n        int mOdd = rnd.next(1, maxOdd);\n        int nOdd = rnd.next(mOdd, maxOdd);\n        M = mOdd * 2 - 1;\n        N = nOdd * 2 - 1;\n    } else if (type == \"m1\") {\n        /* M = 1, N is random between 1 and maxN */\n        M = 1;\n        N = rnd.next(1, maxN);\n    } else if (type == \"n1\") {\n        /* N = 1, M must be 1 to satisfy M ≤ N */\n        N = 1;\n        M = 1;\n    } else if (type == \"prime\") {\n        /* Both M and N are prime numbers */\n        vector<int> primes;\n        for(int i = 1; i <= maxN; ++i) {\n            bool isPrime = true;\n            if (i < 2) isPrime = false;\n            else {\n                for (int j = 2; j * j <= i; ++j) {\n                    if (i % j == 0) {\n                        isPrime = false;\n                        break;\n                    }\n                }\n            }\n            if (isPrime)\n                primes.push_back(i);\n        }\n        if (primes.empty()) {\n            M = N = 2;\n        } else {\n            M = primes[rnd.next(0, (int)primes.size() - 1)];\n            vector<int> validN;\n            for (int p : primes)\n                if (p >= M)\n                    validN.push_back(p);\n            N = validN[rnd.next(0, (int)validN.size() - 1)];\n        }\n    } else {\n        /* Default to random */\n        M = rnd.next(1, maxN);\n        N = rnd.next(M, maxN); // Ensure M ≤ N\n    }\n\n    printf(\"%d %d\\n\", M, N);\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int maxN = opt<int>(\"maxN\", 16);\n    string type = opt<string>(\"type\", \"random\");\n\n    int M, N;\n\n    if (type == \"minimal\") {\n        /* Minimal case: M = N = 1 */\n        M = N = 1;\n    } else if (type == \"maximal\") {\n        /* Maximal case: M = N = maxN */\n        M = N = maxN;\n    } else if (type == \"random\") {\n        /* Random M and N where 1 ≤ M ≤ N ≤ maxN */\n        M = rnd.next(1, maxN);\n        N = rnd.next(M, maxN); // Ensure M ≤ N\n    } else if (type == \"even\") {\n        /* Both M and N are even numbers */\n        int maxEven = maxN / 2;\n        int mEven = rnd.next(1, maxEven);\n        int nEven = rnd.next(mEven, maxEven);\n        M = mEven * 2;\n        N = nEven * 2;\n    } else if (type == \"odd\") {\n        /* Both M and N are odd numbers */\n        int maxOdd = (maxN + 1) / 2;\n        int mOdd = rnd.next(1, maxOdd);\n        int nOdd = rnd.next(mOdd, maxOdd);\n        M = mOdd * 2 - 1;\n        N = nOdd * 2 - 1;\n    } else if (type == \"m1\") {\n        /* M = 1, N is random between 1 and maxN */\n        M = 1;\n        N = rnd.next(1, maxN);\n    } else if (type == \"n1\") {\n        /* N = 1, M must be 1 to satisfy M ≤ N */\n        N = 1;\n        M = 1;\n    } else if (type == \"prime\") {\n        /* Both M and N are prime numbers */\n        vector<int> primes;\n        for(int i = 1; i <= maxN; ++i) {\n            bool isPrime = true;\n            if (i < 2) isPrime = false;\n            else {\n                for (int j = 2; j * j <= i; ++j) {\n                    if (i % j == 0) {\n                        isPrime = false;\n                        break;\n                    }\n                }\n            }\n            if (isPrime)\n                primes.push_back(i);\n        }\n        if (primes.empty()) {\n            M = N = 2;\n        } else {\n            M = primes[rnd.next(0, (int)primes.size() - 1)];\n            vector<int> validN;\n            for (int p : primes)\n                if (p >= M)\n                    validN.push_back(p);\n            N = validN[rnd.next(0, (int)validN.size() - 1)];\n        }\n    } else {\n        /* Default to random */\n        M = rnd.next(1, maxN);\n        N = rnd.next(M, maxN); // Ensure M ≤ N\n    }\n\n    printf(\"%d %d\\n\", M, N);\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -type minimal\n\n./gen -type maximal -maxN 16\n./gen -type maximal -maxN 10\n./gen -type maximal -maxN 5\n\n./gen -type random -maxN 16\n./gen -type random -maxN 16\n./gen -type random -maxN 10\n./gen -type random -maxN 10\n./gen -type random -maxN 5\n./gen -type random -maxN 5\n\n./gen -type even -maxN 16\n./gen -type even -maxN 10\n./gen -type even -maxN 5\n\n./gen -type odd -maxN 16\n./gen -type odd -maxN 10\n./gen -type odd -maxN 5\n\n./gen -type m1 -maxN 16\n./gen -type m1 -maxN 10\n./gen -type m1 -maxN 5\n\n./gen -type prime -maxN 16\n./gen -type prime -maxN 10\n./gen -type prime -maxN 5\n\n./gen -type random\n./gen -type even\n./gen -type odd\n./gen -type m1\n./gen -type prime\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:39:49.096277",
        "total_tutorials": 3,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "50/B",
      "title": "B. Выбор пары символов",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест2 seconds",
      "memory_limit": "ограничение по памяти на тест256 megabytes",
      "input_spec": "Входные данныеЕдинственная строка входа содержит S, состоящую из строчных букв латинского алфавита и цифр. Гарантируется, что строка S непуста и её длина не превосходит 105.",
      "output_spec": "Выходные данныеВыведите одно число — количество пар i и j с требуемым свойством. Пары (x, y) и (y, x) следует считать различными, т. е. считаются упорядоченные пары.",
      "sample_tests": "ПримерыВходные данныеСкопироватьgreat10Выходные данныеСкопировать7Входные данныеСкопироватьaaaaaaaaaaВыходные данныеСкопировать100",
      "description": "B. Выбор пары символов\n\nограничение по времени на тест2 seconds\n\nограничение по времени на тест\n\nограничение по памяти на тест256 megabytes\n\nограничение по памяти на тест\n\nвыводstdout\n\nВходные данныеЕдинственная строка входа содержит S, состоящую из строчных букв латинского алфавита и цифр. Гарантируется, что строка S непуста и её длина не превосходит 105.\n\nВходные данные\n\nВыходные данныеВыведите одно число — количество пар i и j с требуемым свойством. Пары (x, y) и (y, x) следует считать различными, т. е. считаются упорядоченные пары.\n\nВыходные данные\n\nВходные данныеСкопироватьgreat10Выходные данныеСкопировать7Входные данныеСкопироватьaaaaaaaaaaВыходные данныеСкопировать100\n\nВходные данныеСкопироватьgreat10\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать7\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопироватьaaaaaaaaaa\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать100\n\nВыходные данныеСкопировать\n\nСкопировать",
      "solutions": [
        {
          "title": "Codeforces Beta Round #47 - Codeforces",
          "content": "Добрый день.Сегодня пройдёт ещё один раунд по правилам codeforces. Автором сегодняшнего контеста являюсь я. Раунд помогали готовить Артём Рахов и Мария Белова. Большое спасибо им и всем борцам фронта codeforces!Желаю всем удачи и весёлых хаков!P.S:  В связи с проблемами работы сервера раунд признан нерейтинговым. Приносим извинения всем участникам. Подробности в теме по этой ссылке.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/985",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 385
        },
        {
          "title": "Разбор задач Codeforces #47 - Codeforces",
          "content": "Задача A: Ответ равен floor(N*M*0.5). Поскольку на доске N*M клеток, и каждая доминошка покрывает ровно 2 клетки, то больше положить точно нельзя. Теперь покажем, как положить ровно столько доминошек. Если N чётно, то кладём M рядов по N/2 доминошек и занимаем всю доску. Если N нечётно, то укладываем полностью (N-1) ряд доски как написано выше, а последний ряд забиваем floor(M/2) доминошками. При этом максимум останется одна незанятая клетка, в случае если N и M нечётны. Задача B: Разумеется нужно было написать неквадратичное решение. Проходим по заданной строке и считаем, сколько раз встречается каждый символ. Пусть Ki - количество вхождений символа с ASCII-кодом i в строку S. Тогда ответ равен sum(Ki2). В коде решения часто возникали проблемы:Писали квадратичное решение (двойной цикл по строке).Забывали поставить int64. Либо в ответе, либо в возведении Ki в квадрат.Неверное выводили int64.Все эти проблемы хакались тестом из 100000 одинаковых символов. Из-за этого процесс хакания превратился в игру \"кто быстрей захакает очередное решение B\", поскольку новички часто допускали все эти ошибки. Эта проблема ещё усилилась из-за того, что GCC-компилятор на сервере оказывается является MinGW-компилятором, поэтому на нём не работает вывод printf(\"%lld\", ...). Ещё одна странная проблема, возникшая у хакеров - молчаливое обрезание теста по длине около 30000 при копировании его в редактор. Естественно, переполнение в решении из-за этого исчезало.Задача C: В задаче требовалось, чтобы все коровы находились строго внутри маршрута. Изначально я планировал сделать нестрого, но тогда ответ для случая одной коровы оказался бы странным=) На самом деле разница в решении невелика. Ответ для \"строгой\" задачи всегда на 4 больше, чем для \"нестрогой\". Некоторые участники предпочли добавить к каждой точке четырёх её соседей  крестиком, чтобы перейти к нестрогой задаче.Нестрогая задача решается следующим образом. Заметим, что искомый маршрут всегда можно представить восьмиугольником, возможно с нулевыми сторонами. Нужно было взять четыре пары параллельных прямых и \"прижать\" их к точкам. Иначе говоря, мы находим для набора точек ограничивающий прямоугольник, параллельный осям координат. Затем находим ограничивающий прямоугольник для набора точек на повёрнутой на 45 градусов картинке. Теперь пересекаем эти два прямоуольника (как заполненные фигуры). Получаем в общем случае восьмиугольник, который является искомым. Для реализации нужно посчитать минимумы и максимумы X, Y, X+Y, X-Y по всем точкам, потом посчитать по ним ответ по нетривиальным формулам.Многие участники решили задачу по-другому. Легко понять, что для перемещения на вектор (X, Y) пастуху требуется max(|X|, |Y|) ходов. Так вот, можно заставить пастуха ходить по вершинам выпуклой оболочки. Нужно запустить стандартный алгоритм Грэхема, потом обойти вершины на оболочке и просуммировать max(|X'-X|, |Y'-Y|) для соседних вершин в ней. Это решение также правильное.Была идея сделать ограничение координат по модулю до 109, но потом решили, что незачем лишний раз требовать int64. Возможно лучше бы int64 было в этой задаче, а не в задаче B.Задача D: Условие задачи выглядит запутанно и воинственно. Дело в том, что легенда была навеяна занятиями по гражданской обороне в университете. Это такой предмет, на котором в частности учат, что делать до и после ядерного взрыва...Сперва нужно заметить, что чем больше боеголовка, тем больше вероятность выполнить задание. Это вполне разумно с житейской точки зрения. Функция P(D, R) возрастает по R при фискированном D. Очевидно, что при этом и вероятность повредить как минимум K объектов тоже возрастает по R. Следовательно, можно было найти искомый радиус бинарным поиском. Для того, чтобы это сделать, нам нужно научиться находить вероятность выполнить задачу при фиксированном и известном радиусе R.Теперь нужно решить такую задачу: есть N объектов, каждый из которых разрушается с заданной вероятностью (pi). Нужно найти вероятность разрушения как минимум K из них. Задача решается динамическим программированием, очень похожим на подсчёт биномиальных коэффициентов по треугольнику Паскаля. Пусть R[i, j] - вероятность поразить ровно j объектов среди первых i из всех заданных. Если мы посчитаем все значения R для 0<=j<=i<=N, то ответ можно будет вычислить как sum_{j=k..N} R[N, j]. Начальное условие динамики: R[0, 0] = 1. Пересчёт выполняем по формуле R[i, j] = R[i-1, j-1] * pi + R[i-1, j] * (1-pi), считая, что все элементы R с j<0 или j>i нулевые.Экспериментально было выяснено, что многим кодерам (мне в том числе) в голову первым делом приходит идея учитывать только K ближайших к эпицентру строений. То есть считать, что вероятность выполнить задачу равна просто p1 * p2 *... * pK. Это неверно: например, если есть два строения на одинаковом расстоянии, то вероятность поразить хотя бы одно из них равна 1-(1-p)2 вместо p. Но я решил сделать тем, кто так посчитал, приятное и включил в претесты только такие случаи, когда это решение работает=) Так что это неверное решение специально проходило все претесты.Задача E: Пусть D = b2-c   - четверть дискриминанта уравнения. Решения уравнения равны -b-sqrt(D) и -b+sqrt(D). Таким образом, есть два типа корней: иррациональные корни вида x +- sqrt(y) и целые корни. Будем считать количество корней отдельно для двух типов.Иррациональные корни имеют вид x+sqrt(y) (y - не точный квадрат). Утверждается, что если два числа такого вида равны, то их x и y совпадают. Это можно легко проверить на бумажке, главное принять во внимание, что sqrt(y) иррационально. Таким образом, если два иррациональных корня равны, то и уравнения совпадают. Следовательно все иррациональные корни всех уравнений различны. Будем перебирать b=1..N. Для каждого из них нужно найти количество уравнений с положительным дискриминантом, не являющимся точным квадратом. То есть количество c=1...M таких, что D = b2-c - не точный квадрат. Можно определить отрезок [L; R], значения которого принимает D (L >= 0). Потом взять его длину (R-L+1) и вычесть количество точных квадратов в нём. Это и будет количество уравнений с иррациональными корнями для фиксированного b. Умножаем это число на два (корня два) и прибавляем к ответу.Теперь разберёмся с целыми корнями. Для фиксированного b мы определили отрезок [L;R] для D. Тогда sqrt(D) будет принимать целые значения  [l; r] = [ceil(sqrt(L)); floor(sqrt(R))]. Подставляем это множество значений в формулу для корня и получаем, что целые корни всех уравнений с фиксированным b составляют отрезки [-b-r;-b-l] и [-b+l;-b+r]. Однако целые корни существенно могут быть одинаковыми. Поэтому мы должны пометить в глобальной структуре данных, что все корни из этих двух отрезков \"найдены\". После того, как мы переберём все b=1..N, в этой структуре данных нужно найти количество чисел, помеченных хотя бы раз.Такая структура данных реализуется на массиве. Все целые корни уравнений лежат в пределах от -10000000 до 0. Заводим массив Q чуть большего размера. Для того, чтобы отметить отрезок [s; t], мы увеличиваем на 1 элемент Q[s] и уменьшаем на 1 элемент Q[t+1]. В конце работы алгоритма пробегаем весь массив Q слева направо и считаем префиксные суммы в массив S. То есть S[i] = Q[-10000010] + Q[-10000009] + ... + Q[i-1] + Q[i]. Тогда S[i] будет означать то, сколько раз мы всего пометили число i. Теперь пробегаем массив S и считаем количество ненулевых элементов - это и есть количество различных целых корней.Решение работает за O(N), поскольку требуется перебирать все значения b. Очень вероятно, что есть чисто комбинаторная (O(1)) формула для ответа=)Итого. Я считаю, что в зачадах раунда были две проблемы. Первая - отсутствие технически сложной задачи. Из-за этого кодеры высокого уровня решили все задачи за первый час, и мучались с хаканием в нестабильной системе остальной час. Мне кажется, задача E в раунде должна быть действительно сложной для написания. Вторая проблема - огромное количество хаков по задаче B. Надо было всё-таки сделать длину строки до 40000. Ещё интересный вопрос: почему смешиваются дивизионы? Было бы разумнее, если каждая комната была либо полностью первым дивизионом, либо полностью вторым. Тогда кодеры первого дивизиона будут хакать решения сложных задач, а не ловить элементарные ошибки новичков.Напоминаю, что в системе тестирования вы можете посмотреть тесты к задачам.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/1006",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 8306
        },
        {
          "title": "Round# 47 simple tutorial - Codeforces",
          "content": "An*m/2.BRecord the occurrences' number of each letters, signed as cnt[char].For each char in string, get the cnt[c]^2 plus together, and this is the answer.CCalculate the Convex Hull. The sum of the max value between x-difference and y-difference of each adjacent points in the convex hull's set and 4 is the answer.4 step can make a circle of 360 degree.DCounting the answer with Half, and check the answer using Dynamic Programming.Let dp[i][j] means the probability of first i objects where j of them exploded, and the transfering formular is:dp[i][j] = P(i) * dp[i - 1][j - 1] + (1 - P(i)) * dp[i - 1][j], where P(i) means the i-th object exploding's probability.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/1003",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 667
        }
      ],
      "code_examples": [
        {
          "title": "Разбор задач Codeforces #47 - Codeforces - Code 1",
          "code": "#include<stdio.h>#include<string.h>char a[1000009];int b[256];int main(){        __int64 i,sum,n;        gets(a);        n=strlen(a);        for(i=0;i<n;i++){                ++b[a[i]];        }        sum=0;        for(i=0;i<256;i++){                if(b[i]){                        sum+=b[i]*b[i];                        b[i]=0;                }        }        printf(\"%I64d\\n\",sum);        return 0;}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/1006",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Codeforces #47 - Codeforces - Code 2",
          "code": "sum+=b[i]*b[i];That's the mistake. Compiler will calculate the right part first: b[i] is int, so b[i]*b[i] is int too.If b[i]=100000, this line became the following: sum += 1410065408;So you should writesum+=(__int64)b[i]*b[i];instead.Compiler see that the first operand is __int64, and will convert the second one to __int64 too.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/1006",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    string S = inf.readToken(\"[a-z0-9]{1,100000}\", \"S\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    string S = inf.readToken(\"[a-z0-9]{1,100000}\", \"S\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    string S = inf.readToken(\"[a-z0-9]{1,100000}\", \"S\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<char> letters;\n    for (char c = 'a'; c <= 'z'; c++) letters.push_back(c);\n\n    vector<char> digits;\n    for (char c = '0'; c <= '9'; c++) digits.push_back(c);\n\n    vector<char> alphanum;\n    alphanum.insert(alphanum.end(), letters.begin(), letters.end());\n    alphanum.insert(alphanum.end(), digits.begin(), digits.end());\n\n    string S;\n\n    if (type == \"all_same\") {\n        // S is n repetitions of the same character\n        char c = alphanum[rnd.next(0, (int)alphanum.size() - 1)];\n        S = string(n, c);\n    } else if (type == \"all_unique\") {\n        // S is n distinct characters\n        if (n > (int)alphanum.size()) {\n            // Adjust n if it exceeds the number of unique characters\n            n = alphanum.size();\n        }\n        shuffle(alphanum.begin(), alphanum.end());\n        S = string(alphanum.begin(), alphanum.begin() + n);\n    } else if (type == \"random_letters\") {\n        // S is random lowercase letters 'a'-'z'\n        S.resize(n);\n        for (int i = 0; i < n; i++) {\n            S[i] = letters[rnd.next(0, (int)letters.size() - 1)];\n        }\n    } else if (type == \"random_digits\") {\n        // S is random digits '0'-'9'\n        S.resize(n);\n        for (int i = 0; i < n; i++) {\n            S[i] = digits[rnd.next(0, (int)digits.size() - 1)];\n        }\n    } else if (type == \"random\") {\n        // S is random characters from 'a'-'z' and '0'-'9'\n        S.resize(n);\n        for (int i = 0; i < n; i++) {\n            S[i] = alphanum[rnd.next(0, (int)alphanum.size() - 1)];\n        }\n    } else if (type == \"max_one_char\") {\n        // S has n-1 repetitions of one character, and one different character\n        char c1 = alphanum[rnd.next(0, (int)alphanum.size() - 1)];\n        char c2;\n        do {\n            c2 = alphanum[rnd.next(0, (int)alphanum.size() - 1)];\n        } while (c2 == c1);\n        S = string(n, c1);\n        int pos = rnd.next(0, n - 1);\n        S[pos] = c2;\n    } else if (type == \"alternating_chars\") {\n        // S alternates between two characters\n        char c1 = alphanum[rnd.next(0, (int)alphanum.size() - 1)];\n        char c2;\n        do {\n            c2 = alphanum[rnd.next(0, (int)alphanum.size() - 1)];\n        } while (c2 == c1);\n        S.resize(n);\n        for (int i = 0; i < n; i++) {\n            S[i] = (i % 2 == 0) ? c1 : c2;\n        }\n    } else {\n        // Default to random if type is not recognized\n        S.resize(n);\n        for (int i = 0; i < n; i++) {\n            S[i] = alphanum[rnd.next(0, (int)alphanum.size() - 1)];\n        }\n    }\n\n    cout << S << endl;\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<char> letters;\n    for (char c = 'a'; c <= 'z'; c++) letters.push_back(c);\n\n    vector<char> digits;\n    for (char c = '0'; c <= '9'; c++) digits.push_back(c);\n\n    vector<char> alphanum;\n    alphanum.insert(alphanum.end(), letters.begin(), letters.end());\n    alphanum.insert(alphanum.end(), digits.begin(), digits.end());\n\n    string S;\n\n    if (type == \"all_same\") {\n        // S is n repetitions of the same character\n        char c = alphanum[rnd.next(0, (int)alphanum.size() - 1)];\n        S = string(n, c);\n    } else if (type == \"all_unique\") {\n        // S is n distinct characters\n        if (n > (int)alphanum.size()) {\n            // Adjust n if it exceeds the number of unique characters\n            n = alphanum.size();\n        }\n        shuffle(alphanum.begin(), alphanum.end());\n        S = string(alphanum.begin(), alphanum.begin() + n);\n    } else if (type == \"random_letters\") {\n        // S is random lowercase letters 'a'-'z'\n        S.resize(n);\n        for (int i = 0; i < n; i++) {\n            S[i] = letters[rnd.next(0, (int)letters.size() - 1)];\n        }\n    } else if (type == \"random_digits\") {\n        // S is random digits '0'-'9'\n        S.resize(n);\n        for (int i = 0; i < n; i++) {\n            S[i] = digits[rnd.next(0, (int)digits.size() - 1)];\n        }\n    } else if (type == \"random\") {\n        // S is random characters from 'a'-'z' and '0'-'9'\n        S.resize(n);\n        for (int i = 0; i < n; i++) {\n            S[i] = alphanum[rnd.next(0, (int)alphanum.size() - 1)];\n        }\n    } else if (type == \"max_one_char\") {\n        // S has n-1 repetitions of one character, and one different character\n        char c1 = alphanum[rnd.next(0, (int)alphanum.size() - 1)];\n        char c2;\n        do {\n            c2 = alphanum[rnd.next(0, (int)alphanum.size() - 1)];\n        } while (c2 == c1);\n        S = string(n, c1);\n        int pos = rnd.next(0, n - 1);\n        S[pos] = c2;\n    } else if (type == \"alternating_chars\") {\n        // S alternates between two characters\n        char c1 = alphanum[rnd.next(0, (int)alphanum.size() - 1)];\n        char c2;\n        do {\n            c2 = alphanum[rnd.next(0, (int)alphanum.size() - 1)];\n        } while (c2 == c1);\n        S.resize(n);\n        for (int i = 0; i < n; i++) {\n            S[i] = (i % 2 == 0) ? c1 : c2;\n        }\n    } else {\n        // Default to random if type is not recognized\n        S.resize(n);\n        for (int i = 0; i < n; i++) {\n            S[i] = alphanum[rnd.next(0, (int)alphanum.size() - 1)];\n        }\n    }\n\n    cout << S << endl;\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -type all_same\n./gen -n 1 -type all_unique\n./gen -n 1 -type random_letters\n./gen -n 1 -type random_digits\n./gen -n 1 -type random\n\n./gen -n 2 -type max_one_char\n./gen -n 2 -type alternating_chars\n./gen -n 2 -type random\n\n./gen -n 5 -type all_same\n./gen -n 5 -type all_unique\n./gen -n 5 -type random_letters\n./gen -n 5 -type random_digits\n./gen -n 5 -type random\n\n./gen -n 10 -type all_same\n./gen -n 10 -type all_unique\n./gen -n 10 -type random_letters\n./gen -n 10 -type random_digits\n./gen -n 10 -type random\n./gen -n 10 -type max_one_char\n./gen -n 10 -type alternating_chars\n\n./gen -n 40 -type all_unique\n\n./gen -n 100000 -type all_same\n./gen -n 100000 -type random_letters\n./gen -n 100000 -type random_digits\n./gen -n 100000 -type random\n./gen -n 100000 -type max_one_char\n./gen -n 100000 -type alternating_chars\n\n./gen -n 99999 -type max_one_char\n\n./gen -n 50000 -type alternating_chars\n\n./gen -n 1000 -type random\n./gen -n 1000 -type all_same\n\n./gen -n 100000 -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:39:51.295011",
        "total_tutorials": 3,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "50/C",
      "title": "C. Happy Farm 5",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains an integer N which represents the number of cows in the herd (1 ≤ N ≤ 105). Each of the next N lines contains two integers Xi and Yi which represent the coordinates of one cow of (|Xi|, |Yi| ≤ 106). Several cows can stand on one point.",
      "output_spec": "OutputPrint the single number — the minimum number of moves in the sought path.",
      "sample_tests": "ExamplesInputCopy41 15 15 31 3OutputCopy16",
      "description": "C. Happy Farm 5\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains an integer N which represents the number of cows in the herd (1 ≤ N ≤ 105). Each of the next N lines contains two integers Xi and Yi which represent the coordinates of one cow of (|Xi|, |Yi| ≤ 106). Several cows can stand on one point.\n\nOutputPrint the single number — the minimum number of moves in the sought path.\n\nInputCopy41 15 15 31 3OutputCopy16\n\nInputCopy41 15 15 31 3\n\nOutputCopy16\n\nNotePicture for the example test: The coordinate grid is painted grey, the coordinates axes are painted black, the cows are painted red and the sought route is painted green.",
      "solutions": [
        {
          "title": "Codeforces Beta Round #47 - Codeforces",
          "content": "Good afternoon.One more codeforces format round takes place this evening. I'm the author of the contest problems. Artem Rakhov and Maria Belova helped me to prepare the problems. Great thanks to them and all codeforces \"fighters\"!I wish you good luck and funny hacks!P.S:  This round won't be rated. So your ratings won't change. That's because of severe problems with codeforces server. Read here for explanation.",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/985",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 414
        },
        {
          "title": "Codeforces #47 problem solutions - Codeforces",
          "content": "Problem A: Answer is floor(N*M*0.5). Since there is N*M cells on the board and each domino covers exactly two of them we cannot place more for sure. Now let's show how to place exactly this number of dominoes. If N is even, then place M rows of N/2 dominoes and cover the whole board. Else N is odd, so cover N-1 row of the board as shown above and put floor(M/2) dominoes to the last row. In the worst case (N and M are odd) one cell remains uncovered. Problem B: Of course you were expected to code solution which is not quadratic in time complexity. Iterate over the string and count how many times each char is used. Let Ki be the number of occurrences of char with ASCII-code i in the string S. Then answer is sum(Ki2). While coding the solution the following common mistakes were made:1. Code quadratic solution (double loop over the string)2. Forget to use int64. Whether in answer or in Ki squaring.3. Wrong int64 output.All these problems were easily hacked by max test with 100000 equal chars. This turned the hacking process into the game \"who hacks the next B solution faster\" because newbies often made all these mistakes. This problem was severed by the fact that GCC-compiler turned out to be MinGW-compiler, so output like printf(\"%lld\", ...) did not work on it. Another strange problem hackers faced was quiet test truncation by length about 30000 when copy/pasting it into the test editor. Of course the overflow in solution disappears after it.Problem C: You were asked to make all the cows strictly inside the interior of the route. Initially I planned to put \"non-strict\" there, but later I abandoned this idea because the answer for single point was really weird then=) The difference in solution is quite small. The answer for \"strict\" problem is always more than for \"non-strict\" by exactly 4. Some coders preferred to add four neighboring points for each point like a cross to switch to solving non-strict problem.The non-strict problem is solved in the following way. Notice that the required route can always be searched as an octagon, perhaps with some zero sides. Take four pairs of parallel lines and \"press\" it to the points. In other words, we find axis-aligned bounding box for the set of points. Then find axis-aligned bounding box of the point set on the picture which is rotated by 45 degrees. Now intersect these two boxes (as filled figures). We get an octagon in the common case, which is the required one. To implement the solution, we have to calculate minimums and maximums of X, Y, X+Y, X-Y through all the points, then use non-trivial formulas to get the answer.A lot of contestants solved the problem in other way. It is easy to see that to move by vector (X, Y) shepherd needs to make max(|X|, |Y|) turns. We can make the shepherd walk along the vertices of convex hull. We need to run a standard Graham scan and then iterate through all the points on the hull and sum max(|X'-X|, |Y'-Y|) for all pairs of neighboring vertices in it. This solution is also correct.There was an idea to make limit on coordinates equal to 109, but we decided that there was no need to ask for int64 again. Perhaps it'd have been better if there'd been int64 in this problem instead of problem B.Problem D: The problem statement looks intricate and aggressive. That's because the problem legend originates from civil defense classes in the university. Civil defense is such a discipline which for example teaches how to behave before and after nuclear attack...First of all we should notice that the bigger the warhead, the better (I mean the probability to succeed is higher). This seems quite reasonable. Function P(D, R) increases as R increases with fixed D. Obviously the probability to hit at least K objects increases in this case too. Hence we can find the answer by binary search. We have to be able to find the probability to accomplish the mission with fixed and known radius R to perform binary search.Now we have to solve the problem: there are N objects, each of them is destroyed with given probability (pi). Find the probability to destroy at least K of them. The problem is solved by dynamic programming which is similar to calculating binomial coefficients using Pascal's triangle. Let R[i, j] be the probability to hit exactly j objects among the first i of all the given ones. If we find all the R values for 0<=j<=i<=N, then the answer is calculated as sum_{j=k..N} R[N, j]. The base of DP is: R[0, 0] = 1. Induction (calculating the new values) is given by the formula R[i, j] = R[i-1, j-1] * pi + R[i-1, j] * (1-pi). Keep in mind that for j<0 or j>i all the elements of R are zeroes.It was shown experimentally that many coders (me included) try to solve the problem by taking into account only the closest K targets. I.e. they think that the probability to succeed is simply p1 * p2 *... * pK. This is wrong: for example, if two buildings with equal distance are given, then the probability to hit at least one of them is 1-(1-p)2 instead of p. But I decided to please these coders and composed the pretests only of the cases on which this solution passes=) So this particular incorrect solution was passing all the pretests intentionally.Problem E: Let D = b2-c be quarter of discriminant. The equation roots are -b-sqrt(D) и -b+sqrt(D). Thus there are two types of roots: irrational ones like x +- sqrt(y) and integer ones. We count the number of different roots separately for these types.Irrational roots are in form x+sqrt(y) (y is not square of integer). If two numbers in this form are equal, then their x и y values are also equal. It can be checked on the piece of paper. The main idea is to use irrationality of sqrt(y). Thus if two irrational roots are equal, then the equations are the same. Hence all the irrational roots of all the given equations are different. Let's iterate b=1..N. For each of b values we have to find the number of equations with positive discriminant which are not squares on integers. I.e. number of c=1...M with D = b2-c is not square of integer. We can calculate set of all possible values of D as a segment [L; R] (L >= 0). Then take its size (R-L+1) and subtract number of squares in it. It is exactly the the number of equations with irrational roots for a fixed b. Multiply it by 2 (two roots per equation) and add it to the answer.Now let's handle integer roots. For a fixed b we've calculated the segment [L;R] of all D values. Then sqrt(D) takes integer values in segment [l; r] = [ceil(sqrt(L)); floor(sqrt(R))]. We put this segment into the formula for equation roots and understand that all the integer roots of equations with fixed b compose segments [-b-r;-b-l] и [-b+l;-b+r]. However the integer roots may substantially be equal for different equations. That's why we have to mark in a global data structure that all the roots in these two segments are \"found\". After we iterate through all b=1..N, we have to find number of integers marked at least once in this data structure.This data structure is implemented on array. All the integer roots of equations lie in bounds from -10000000 to 0. Allocate an array Q which is a bit larger in size. To mark segment [s; t] we increment Q[s] by one and decrement Q[t+1] by one. At the end of the solution iterate through the whole array Q from left to right and calculate prefix sums to array S. I.e. S[i] = Q[-10000010] + Q[-10000009] + ... + Q[i-1] + Q[i]. Then S[i] represents number of times we've marked number i. Now iterate through S array and count number of nonzero elements. It is the number of different integer roots.The solution requires O(N) time since we have to iterate through all b values. It is likely that purely combinatoric (O(1)) formula for answer exists=)Conclusion. I think that there were two problems in the contest (except the system's epic fail of course). The first: there was no technically hard problem. Because of this high-rated coders had solved all the problems by the end of first hour and had to torture themselves by hacking others in heavily instable contest system during the remaining hour. I think that problem E in any round should be really tough to code. The second problem is huge number of hacks for problem B. I should have set the limit on string length to 40000. There is one more interesting question: why are divisions merged together? It would be wiser if any room were first division only or second division only. Then first division coders would concentrate on hacking solution for difficult problems instead of catching simple newbies' mistakes.Reminder: you can see the tests for all problems in contest system.",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/1006",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 8615
        },
        {
          "title": "Round# 47 simple tutorial - Codeforces",
          "content": "An*m/2.BRecord the occurrences' number of each letters, signed as cnt[char].For each char in string, get the cnt[c]^2 plus together, and this is the answer.CCalculate the Convex Hull. The sum of the max value between x-difference and y-difference of each adjacent points in the convex hull's set and 4 is the answer.4 step can make a circle of 360 degree.DCounting the answer with Half, and check the answer using Dynamic Programming.Let dp[i][j] means the probability of first i objects where j of them exploded, and the transfering formular is:dp[i][j] = P(i) * dp[i - 1][j - 1] + (1 - P(i)) * dp[i - 1][j], where P(i) means the i-th object exploding's probability.",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/1003",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 667
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces #47 problem solutions - Codeforces - Code 1",
          "code": "#include<stdio.h>#include<string.h>char a[1000009];int b[256];int main(){        __int64 i,sum,n;        gets(a);        n=strlen(a);        for(i=0;i<n;i++){                ++b[a[i]];        }        sum=0;        for(i=0;i<256;i++){                if(b[i]){                        sum+=b[i]*b[i];                        b[i]=0;                }        }        printf(\"%I64d\\n\",sum);        return 0;}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/1006",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces #47 problem solutions - Codeforces - Code 2",
          "code": "sum+=b[i]*b[i];That's the mistake. Compiler will calculate the right part first: b[i] is int, so b[i]*b[i] is int too.If b[i]=100000, this line became the following: sum += 1410065408;So you should writesum+=(__int64)b[i]*b[i];instead.Compiler see that the first operand is __int64, and will convert the second one to __int64 too.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/1006",
          "author": "Qingyu"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int N = inf.readInt(1, 100000, \"N\");\n    inf.readEoln();\n\n    for (int i = 0; i < N; i++) {\n        int xi = inf.readInt(-1000000, 1000000, \"x_i\");\n        inf.readSpace();\n        int yi = inf.readInt(-1000000, 1000000, \"y_i\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int N = inf.readInt(1, 100000, \"N\");\n    inf.readEoln();\n\n    for (int i = 0; i < N; i++) {\n        int xi = inf.readInt(-1000000, 1000000, \"x_i\");\n        inf.readSpace();\n        int yi = inf.readInt(-1000000, 1000000, \"y_i\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int N = inf.readInt(1, 100000, \"N\");\n    inf.readEoln();\n\n    for (int i = 0; i < N; i++) {\n        int xi = inf.readInt(-1000000, 1000000, \"x_i\");\n        inf.readSpace();\n        int yi = inf.readInt(-1000000, 1000000, \"y_i\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n#include <cmath>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\");\n\n    vector<pair<int, int>> cows(n);\n\n    if (type == \"small_random\") {\n        // Small N, random positions\n        for (int i = 0; i < n; ++i) {\n            int x = rnd.next(-10, 10);\n            int y = rnd.next(-10, 10);\n            cows[i] = {x, y};\n        }\n    } else if (type == \"max_random\") {\n        // N = 1e5, random positions\n        for (int i = 0; i < n; ++i) {\n            int x = rnd.next(-1000000, 1000000);\n            int y = rnd.next(-1000000, 1000000);\n            cows[i] = {x, y};\n        }\n    } else if (type == \"single_point\") {\n        int x = rnd.next(-1000000, 1000000);\n        int y = rnd.next(-1000000, 1000000);\n        for (int i = 0; i < n; ++i) {\n            cows[i] = {x, y};\n        }\n    } else if (type == \"line_horizontal\") {\n        int y = rnd.next(-1000000, 1000000);\n        int x_start = rnd.next(-1000000, 1000000 - n);\n        for (int i = 0; i < n; ++i) {\n            int x = x_start + i;\n            cows[i] = {x, y};\n        }\n    } else if (type == \"line_vertical\") {\n        int x = rnd.next(-1000000, 1000000);\n        int y_start = rnd.next(-1000000, 1000000 - n);\n        for (int i = 0; i < n; ++i) {\n            int y = y_start + i;\n            cows[i] = {x, y};\n        }\n    } else if (type == \"line_diagonal\") {\n        int x_start = rnd.next(-1000000, 1000000 - n);\n        int y_start = rnd.next(-1000000, 1000000 - n);\n        for (int i = 0; i < n; ++i) {\n            int x = x_start + i;\n            int y = y_start + i;\n            cows[i] = {x, y};\n        }\n    } else if (type == \"convex_shape\") {\n        // Generate cows on the convex hull of a circle\n        double radius = rnd.next(1e5, 1e6);\n        int cx = rnd.next(-1e6 + int(radius), 1e6 - int(radius));\n        int cy = rnd.next(-1e6 + int(radius), 1e6 - int(radius));\n        for (int i = 0; i < n; ++i) {\n            double angle = 2 * M_PI * i / n;\n            int x = int(cx + radius * cos(angle));\n            int y = int(cy + radius * sin(angle));\n            cows[i] = {x, y};\n        }\n    } else if (type == \"concave_shape\") {\n        // Generate cows for a concave polygon (star shape)\n        int cx = rnd.next(-500000, 500000);\n        int cy = rnd.next(-500000, 500000);\n        double radius_big = rnd.next(1e5, 1e6);\n        double radius_small = radius_big / 2;\n        for (int i = 0; i < n; ++i) {\n            double angle = 2 * M_PI * i / n;\n            double radius = (i % 2 == 0) ? radius_big : radius_small;\n            int x = int(cx + radius * cos(angle));\n            int y = int(cy + radius * sin(angle));\n            cows[i] = {x, y};\n        }\n    } else if (type == \"max_coordinate\") {\n        // Cows at extreme coordinates\n        for (int i = 0; i < n; ++i) {\n            int x = rnd.next(-1000000, 1000000);\n            int y = rnd.next(-1000000, 1000000);\n            cows[i] = {x, y};\n        }\n    } else if (type == \"cluster\") {\n        // Create clusters of cows\n        int num_clusters = rnd.next(1, min(n, 1000));\n        vector<pair<int, int>> centers;\n        for (int i = 0; i < num_clusters; ++i) {\n            int x = rnd.next(-999000, 999000);\n            int y = rnd.next(-999000, 999000);\n            centers.push_back({x, y});\n        }\n        for (int i = 0; i < n; ++i) {\n            int c = rnd.next(0, num_clusters - 1);\n            int x = centers[c].first + rnd.next(-1000, 1000);\n            int y = centers[c].second + rnd.next(-1000, 1000);\n            cows[i] = {x, y};\n        }\n    } else if (type == \"grid\") {\n        // Cows in a grid pattern\n        int grid_size = int(sqrt(n));\n        grid_size = max(grid_size, 1);\n        int x_start = rnd.next(-1000000 + grid_size, 1000000 - grid_size);\n        int y_start = rnd.next(-1000000 + grid_size, 1000000 - grid_size);\n        int idx = 0;\n        for (int dx = 0; dx < grid_size && idx < n; ++dx) {\n            for (int dy = 0; dy < grid_size && idx < n; ++dy) {\n                cows[idx++] = {x_start + dx, y_start + dy};\n            }\n        }\n    } else if (type == \"point_at_max\") {\n        int x = 1000000;\n        int y = 1000000;\n        for (int i = 0; i < n; ++i) {\n            cows[i] = {x, y};\n        }\n    } else if (type == \"point_at_min\") {\n        int x = -1000000;\n        int y = -1000000;\n        for (int i = 0; i < n; ++i) {\n            cows[i] = {x, y};\n        }\n    } else {\n        fprintf(stderr, \"Unknown type: %s\\n\", type.c_str());\n        return 1;\n    }\n\n    // Output\n    printf(\"%d\\n\", n);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d %d\\n\", cows[i].first, cows[i].second);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n#include <cmath>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\");\n\n    vector<pair<int, int>> cows(n);\n\n    if (type == \"small_random\") {\n        // Small N, random positions\n        for (int i = 0; i < n; ++i) {\n            int x = rnd.next(-10, 10);\n            int y = rnd.next(-10, 10);\n            cows[i] = {x, y};\n        }\n    } else if (type == \"max_random\") {\n        // N = 1e5, random positions\n        for (int i = 0; i < n; ++i) {\n            int x = rnd.next(-1000000, 1000000);\n            int y = rnd.next(-1000000, 1000000);\n            cows[i] = {x, y};\n        }\n    } else if (type == \"single_point\") {\n        int x = rnd.next(-1000000, 1000000);\n        int y = rnd.next(-1000000, 1000000);\n        for (int i = 0; i < n; ++i) {\n            cows[i] = {x, y};\n        }\n    } else if (type == \"line_horizontal\") {\n        int y = rnd.next(-1000000, 1000000);\n        int x_start = rnd.next(-1000000, 1000000 - n);\n        for (int i = 0; i < n; ++i) {\n            int x = x_start + i;\n            cows[i] = {x, y};\n        }\n    } else if (type == \"line_vertical\") {\n        int x = rnd.next(-1000000, 1000000);\n        int y_start = rnd.next(-1000000, 1000000 - n);\n        for (int i = 0; i < n; ++i) {\n            int y = y_start + i;\n            cows[i] = {x, y};\n        }\n    } else if (type == \"line_diagonal\") {\n        int x_start = rnd.next(-1000000, 1000000 - n);\n        int y_start = rnd.next(-1000000, 1000000 - n);\n        for (int i = 0; i < n; ++i) {\n            int x = x_start + i;\n            int y = y_start + i;\n            cows[i] = {x, y};\n        }\n    } else if (type == \"convex_shape\") {\n        // Generate cows on the convex hull of a circle\n        double radius = rnd.next(1e5, 1e6);\n        int cx = rnd.next(-1e6 + int(radius), 1e6 - int(radius));\n        int cy = rnd.next(-1e6 + int(radius), 1e6 - int(radius));\n        for (int i = 0; i < n; ++i) {\n            double angle = 2 * M_PI * i / n;\n            int x = int(cx + radius * cos(angle));\n            int y = int(cy + radius * sin(angle));\n            cows[i] = {x, y};\n        }\n    } else if (type == \"concave_shape\") {\n        // Generate cows for a concave polygon (star shape)\n        int cx = rnd.next(-500000, 500000);\n        int cy = rnd.next(-500000, 500000);\n        double radius_big = rnd.next(1e5, 1e6);\n        double radius_small = radius_big / 2;\n        for (int i = 0; i < n; ++i) {\n            double angle = 2 * M_PI * i / n;\n            double radius = (i % 2 == 0) ? radius_big : radius_small;\n            int x = int(cx + radius * cos(angle));\n            int y = int(cy + radius * sin(angle));\n            cows[i] = {x, y};\n        }\n    } else if (type == \"max_coordinate\") {\n        // Cows at extreme coordinates\n        for (int i = 0; i < n; ++i) {\n            int x = rnd.next(-1000000, 1000000);\n            int y = rnd.next(-1000000, 1000000);\n            cows[i] = {x, y};\n        }\n    } else if (type == \"cluster\") {\n        // Create clusters of cows\n        int num_clusters = rnd.next(1, min(n, 1000));\n        vector<pair<int, int>> centers;\n        for (int i = 0; i < num_clusters; ++i) {\n            int x = rnd.next(-999000, 999000);\n            int y = rnd.next(-999000, 999000);\n            centers.push_back({x, y});\n        }\n        for (int i = 0; i < n; ++i) {\n            int c = rnd.next(0, num_clusters - 1);\n            int x = centers[c].first + rnd.next(-1000, 1000);\n            int y = centers[c].second + rnd.next(-1000, 1000);\n            cows[i] = {x, y};\n        }\n    } else if (type == \"grid\") {\n        // Cows in a grid pattern\n        int grid_size = int(sqrt(n));\n        grid_size = max(grid_size, 1);\n        int x_start = rnd.next(-1000000 + grid_size, 1000000 - grid_size);\n        int y_start = rnd.next(-1000000 + grid_size, 1000000 - grid_size);\n        int idx = 0;\n        for (int dx = 0; dx < grid_size && idx < n; ++dx) {\n            for (int dy = 0; dy < grid_size && idx < n; ++dy) {\n                cows[idx++] = {x_start + dx, y_start + dy};\n            }\n        }\n    } else if (type == \"point_at_max\") {\n        int x = 1000000;\n        int y = 1000000;\n        for (int i = 0; i < n; ++i) {\n            cows[i] = {x, y};\n        }\n    } else if (type == \"point_at_min\") {\n        int x = -1000000;\n        int y = -1000000;\n        for (int i = 0; i < n; ++i) {\n            cows[i] = {x, y};\n        }\n    } else {\n        fprintf(stderr, \"Unknown type: %s\\n\", type.c_str());\n        return 1;\n    }\n\n    // Output\n    printf(\"%d\\n\", n);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d %d\\n\", cows[i].first, cows[i].second);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Small random test cases\n./gen -n 1 -type small_random\n./gen -n 2 -type small_random\n./gen -n 3 -type small_random\n./gen -n 10 -type small_random\n./gen -n 100 -type small_random\n\n# Max random test case\n./gen -n 100000 -type max_random\n\n# Single point test cases\n./gen -n 1 -type single_point\n./gen -n 10 -type single_point\n./gen -n 100000 -type single_point\n\n# Line horizontal test cases\n./gen -n 10 -type line_horizontal\n./gen -n 1000 -type line_horizontal\n./gen -n 100000 -type line_horizontal\n\n# Line vertical test cases\n./gen -n 10 -type line_vertical\n./gen -n 1000 -type line_vertical\n./gen -n 100000 -type line_vertical\n\n# Line diagonal test cases\n./gen -n 10 -type line_diagonal\n./gen -n 1000 -type line_diagonal\n./gen -n 100000 -type line_diagonal\n\n# Convex shape test cases\n./gen -n 3 -type convex_shape\n./gen -n 10 -type convex_shape\n./gen -n 1000 -type convex_shape\n\n# Concave shape test cases\n./gen -n 5 -type concave_shape\n./gen -n 10 -type concave_shape\n./gen -n 1000 -type concave_shape\n\n# Max coordinate test case\n./gen -n 100000 -type max_coordinate\n\n# Cluster test cases\n./gen -n 1000 -type cluster\n./gen -n 100000 -type cluster\n\n# Grid test cases\n./gen -n 100 -type grid\n./gen -n 10000 -type grid\n\n# Edge cases with extreme coordinates\n./gen -n 1 -type point_at_max\n./gen -n 100000 -type point_at_max\n./gen -n 1 -type point_at_min\n./gen -n 100000 -type point_at_min\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:39:53.465744",
        "total_tutorials": 3,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "50/D",
      "title": "D. Bombing",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains an integer N which represents the number of the enemy's objects (1 ≤ N ≤ 100). The second line contains two integers: K is the required number of deactivated objects, and ε is the maximally permitted probability of not completing the task, given in per mils (1 ≤ K ≤ N, 1 ≤ ε ≤ 999). The third line contains X0 and Y0 which are the coordinates of the strike impact point. The next N lines contain two numbers Xi and Yi each which are the coordinates of every strategically important object. All the coordinates are integer, their absolute values do not exceed 1000.Let us remind you that there are a thousand per mils in unity (number one).There can be several objects in one point.",
      "output_spec": "OutputPrint the sought estimated impact radius of the warhead. The absolute or relative measure of the inaccuracy of your answer should not exceed 10 - 6.",
      "sample_tests": "ExamplesInputCopy11 5005 51 2OutputCopy3.84257761518762740InputCopy53 1000 03 460 70100 10010 105 12OutputCopy13.45126176453737600",
      "description": "time limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains an integer N which represents the number of the enemy's objects (1 ≤ N ≤ 100). The second line contains two integers: K is the required number of deactivated objects, and ε is the maximally permitted probability of not completing the task, given in per mils (1 ≤ K ≤ N, 1 ≤ ε ≤ 999). The third line contains X0 and Y0 which are the coordinates of the strike impact point. The next N lines contain two numbers Xi and Yi each which are the coordinates of every strategically important object. All the coordinates are integer, their absolute values do not exceed 1000.Let us remind you that there are a thousand per mils in unity (number one).There can be several objects in one point.\n\nOutputPrint the sought estimated impact radius of the warhead. The absolute or relative measure of the inaccuracy of your answer should not exceed 10 - 6.\n\nInputCopy11 5005 51 2OutputCopy3.84257761518762740InputCopy53 1000 03 460 70100 10010 105 12OutputCopy13.45126176453737600\n\nInputCopy11 5005 51 2\n\nOutputCopy3.84257761518762740\n\nInputCopy53 1000 03 460 70100 10010 105 12\n\nOutputCopy13.45126176453737600",
      "solutions": [
        {
          "title": "Codeforces Beta Round #47 - Codeforces",
          "content": "Good afternoon.One more codeforces format round takes place this evening. I'm the author of the contest problems. Artem Rakhov and Maria Belova helped me to prepare the problems. Great thanks to them and all codeforces \"fighters\"!I wish you good luck and funny hacks!P.S:  This round won't be rated. So your ratings won't change. That's because of severe problems with codeforces server. Read here for explanation.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/985",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 414
        },
        {
          "title": "Codeforces #47 problem solutions - Codeforces",
          "content": "Problem A: Answer is floor(N*M*0.5). Since there is N*M cells on the board and each domino covers exactly two of them we cannot place more for sure. Now let's show how to place exactly this number of dominoes. If N is even, then place M rows of N/2 dominoes and cover the whole board. Else N is odd, so cover N-1 row of the board as shown above and put floor(M/2) dominoes to the last row. In the worst case (N and M are odd) one cell remains uncovered. Problem B: Of course you were expected to code solution which is not quadratic in time complexity. Iterate over the string and count how many times each char is used. Let Ki be the number of occurrences of char with ASCII-code i in the string S. Then answer is sum(Ki2). While coding the solution the following common mistakes were made:1. Code quadratic solution (double loop over the string)2. Forget to use int64. Whether in answer or in Ki squaring.3. Wrong int64 output.All these problems were easily hacked by max test with 100000 equal chars. This turned the hacking process into the game \"who hacks the next B solution faster\" because newbies often made all these mistakes. This problem was severed by the fact that GCC-compiler turned out to be MinGW-compiler, so output like printf(\"%lld\", ...) did not work on it. Another strange problem hackers faced was quiet test truncation by length about 30000 when copy/pasting it into the test editor. Of course the overflow in solution disappears after it.Problem C: You were asked to make all the cows strictly inside the interior of the route. Initially I planned to put \"non-strict\" there, but later I abandoned this idea because the answer for single point was really weird then=) The difference in solution is quite small. The answer for \"strict\" problem is always more than for \"non-strict\" by exactly 4. Some coders preferred to add four neighboring points for each point like a cross to switch to solving non-strict problem.The non-strict problem is solved in the following way. Notice that the required route can always be searched as an octagon, perhaps with some zero sides. Take four pairs of parallel lines and \"press\" it to the points. In other words, we find axis-aligned bounding box for the set of points. Then find axis-aligned bounding box of the point set on the picture which is rotated by 45 degrees. Now intersect these two boxes (as filled figures). We get an octagon in the common case, which is the required one. To implement the solution, we have to calculate minimums and maximums of X, Y, X+Y, X-Y through all the points, then use non-trivial formulas to get the answer.A lot of contestants solved the problem in other way. It is easy to see that to move by vector (X, Y) shepherd needs to make max(|X|, |Y|) turns. We can make the shepherd walk along the vertices of convex hull. We need to run a standard Graham scan and then iterate through all the points on the hull and sum max(|X'-X|, |Y'-Y|) for all pairs of neighboring vertices in it. This solution is also correct.There was an idea to make limit on coordinates equal to 109, but we decided that there was no need to ask for int64 again. Perhaps it'd have been better if there'd been int64 in this problem instead of problem B.Problem D: The problem statement looks intricate and aggressive. That's because the problem legend originates from civil defense classes in the university. Civil defense is such a discipline which for example teaches how to behave before and after nuclear attack...First of all we should notice that the bigger the warhead, the better (I mean the probability to succeed is higher). This seems quite reasonable. Function P(D, R) increases as R increases with fixed D. Obviously the probability to hit at least K objects increases in this case too. Hence we can find the answer by binary search. We have to be able to find the probability to accomplish the mission with fixed and known radius R to perform binary search.Now we have to solve the problem: there are N objects, each of them is destroyed with given probability (pi). Find the probability to destroy at least K of them. The problem is solved by dynamic programming which is similar to calculating binomial coefficients using Pascal's triangle. Let R[i, j] be the probability to hit exactly j objects among the first i of all the given ones. If we find all the R values for 0<=j<=i<=N, then the answer is calculated as sum_{j=k..N} R[N, j]. The base of DP is: R[0, 0] = 1. Induction (calculating the new values) is given by the formula R[i, j] = R[i-1, j-1] * pi + R[i-1, j] * (1-pi). Keep in mind that for j<0 or j>i all the elements of R are zeroes.It was shown experimentally that many coders (me included) try to solve the problem by taking into account only the closest K targets. I.e. they think that the probability to succeed is simply p1 * p2 *... * pK. This is wrong: for example, if two buildings with equal distance are given, then the probability to hit at least one of them is 1-(1-p)2 instead of p. But I decided to please these coders and composed the pretests only of the cases on which this solution passes=) So this particular incorrect solution was passing all the pretests intentionally.Problem E: Let D = b2-c be quarter of discriminant. The equation roots are -b-sqrt(D) и -b+sqrt(D). Thus there are two types of roots: irrational ones like x +- sqrt(y) and integer ones. We count the number of different roots separately for these types.Irrational roots are in form x+sqrt(y) (y is not square of integer). If two numbers in this form are equal, then their x и y values are also equal. It can be checked on the piece of paper. The main idea is to use irrationality of sqrt(y). Thus if two irrational roots are equal, then the equations are the same. Hence all the irrational roots of all the given equations are different. Let's iterate b=1..N. For each of b values we have to find the number of equations with positive discriminant which are not squares on integers. I.e. number of c=1...M with D = b2-c is not square of integer. We can calculate set of all possible values of D as a segment [L; R] (L >= 0). Then take its size (R-L+1) and subtract number of squares in it. It is exactly the the number of equations with irrational roots for a fixed b. Multiply it by 2 (two roots per equation) and add it to the answer.Now let's handle integer roots. For a fixed b we've calculated the segment [L;R] of all D values. Then sqrt(D) takes integer values in segment [l; r] = [ceil(sqrt(L)); floor(sqrt(R))]. We put this segment into the formula for equation roots and understand that all the integer roots of equations with fixed b compose segments [-b-r;-b-l] и [-b+l;-b+r]. However the integer roots may substantially be equal for different equations. That's why we have to mark in a global data structure that all the roots in these two segments are \"found\". After we iterate through all b=1..N, we have to find number of integers marked at least once in this data structure.This data structure is implemented on array. All the integer roots of equations lie in bounds from -10000000 to 0. Allocate an array Q which is a bit larger in size. To mark segment [s; t] we increment Q[s] by one and decrement Q[t+1] by one. At the end of the solution iterate through the whole array Q from left to right and calculate prefix sums to array S. I.e. S[i] = Q[-10000010] + Q[-10000009] + ... + Q[i-1] + Q[i]. Then S[i] represents number of times we've marked number i. Now iterate through S array and count number of nonzero elements. It is the number of different integer roots.The solution requires O(N) time since we have to iterate through all b values. It is likely that purely combinatoric (O(1)) formula for answer exists=)Conclusion. I think that there were two problems in the contest (except the system's epic fail of course). The first: there was no technically hard problem. Because of this high-rated coders had solved all the problems by the end of first hour and had to torture themselves by hacking others in heavily instable contest system during the remaining hour. I think that problem E in any round should be really tough to code. The second problem is huge number of hacks for problem B. I should have set the limit on string length to 40000. There is one more interesting question: why are divisions merged together? It would be wiser if any room were first division only or second division only. Then first division coders would concentrate on hacking solution for difficult problems instead of catching simple newbies' mistakes.Reminder: you can see the tests for all problems in contest system.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/1006",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 8615
        },
        {
          "title": "Round# 47 simple tutorial - Codeforces",
          "content": "An*m/2.BRecord the occurrences' number of each letters, signed as cnt[char].For each char in string, get the cnt[c]^2 plus together, and this is the answer.CCalculate the Convex Hull. The sum of the max value between x-difference and y-difference of each adjacent points in the convex hull's set and 4 is the answer.4 step can make a circle of 360 degree.DCounting the answer with Half, and check the answer using Dynamic Programming.Let dp[i][j] means the probability of first i objects where j of them exploded, and the transfering formular is:dp[i][j] = P(i) * dp[i - 1][j - 1] + (1 - P(i)) * dp[i - 1][j], where P(i) means the i-th object exploding's probability.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/1003",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 667
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces #47 problem solutions - Codeforces - Code 1",
          "code": "#include<stdio.h>#include<string.h>char a[1000009];int b[256];int main(){        __int64 i,sum,n;        gets(a);        n=strlen(a);        for(i=0;i<n;i++){                ++b[a[i]];        }        sum=0;        for(i=0;i<256;i++){                if(b[i]){                        sum+=b[i]*b[i];                        b[i]=0;                }        }        printf(\"%I64d\\n\",sum);        return 0;}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/1006",
          "author": "jiangly"
        },
        {
          "title": "Codeforces #47 problem solutions - Codeforces - Code 2",
          "code": "sum+=b[i]*b[i];That's the mistake. Compiler will calculate the right part first: b[i] is int, so b[i]*b[i] is int too.If b[i]=100000, this line became the following: sum += 1410065408;So you should writesum+=(__int64)b[i]*b[i];instead.Compiler see that the first operand is __int64, and will convert the second one to __int64 too.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/1006",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int N = inf.readInt(1, 100, \"N\");\n    inf.readEoln();\n\n    int K = inf.readInt(1, N, \"K\");\n    inf.readSpace();\n    int epsilon = inf.readInt(1, 999, \"epsilon\");\n    inf.readEoln();\n\n    int X0 = inf.readInt(-1000, 1000, \"X0\");\n    inf.readSpace();\n    int Y0 = inf.readInt(-1000, 1000, \"Y0\");\n    inf.readEoln();\n\n    for (int i = 0; i < N; ++i) {\n        string xi_name = \"Xi[\" + to_string(i + 1) + \"]\";\n        int Xi = inf.readInt(-1000, 1000, xi_name.c_str());\n        inf.readSpace();\n        string yi_name = \"Yi[\" + to_string(i + 1) + \"]\";\n        int Yi = inf.readInt(-1000, 1000, yi_name.c_str());\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int N = inf.readInt(1, 100, \"N\");\n    inf.readEoln();\n\n    int K = inf.readInt(1, N, \"K\");\n    inf.readSpace();\n    int epsilon = inf.readInt(1, 999, \"epsilon\");\n    inf.readEoln();\n\n    int X0 = inf.readInt(-1000, 1000, \"X0\");\n    inf.readSpace();\n    int Y0 = inf.readInt(-1000, 1000, \"Y0\");\n    inf.readEoln();\n\n    for (int i = 0; i < N; ++i) {\n        string xi_name = \"Xi[\" + to_string(i + 1) + \"]\";\n        int Xi = inf.readInt(-1000, 1000, xi_name.c_str());\n        inf.readSpace();\n        string yi_name = \"Yi[\" + to_string(i + 1) + \"]\";\n        int Yi = inf.readInt(-1000, 1000, yi_name.c_str());\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int N = inf.readInt(1, 100, \"N\");\n    inf.readEoln();\n\n    int K = inf.readInt(1, N, \"K\");\n    inf.readSpace();\n    int epsilon = inf.readInt(1, 999, \"epsilon\");\n    inf.readEoln();\n\n    int X0 = inf.readInt(-1000, 1000, \"X0\");\n    inf.readSpace();\n    int Y0 = inf.readInt(-1000, 1000, \"Y0\");\n    inf.readEoln();\n\n    for (int i = 0; i < N; ++i) {\n        string xi_name = \"Xi[\" + to_string(i + 1) + \"]\";\n        int Xi = inf.readInt(-1000, 1000, xi_name.c_str());\n        inf.readSpace();\n        string yi_name = \"Yi[\" + to_string(i + 1) + \"]\";\n        int Yi = inf.readInt(-1000, 1000, yi_name.c_str());\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nconst double EPS = 1E-6;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare two sequences of doubles, max absolute or relative  error = %.7f\", EPS);\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    double j = 0, p = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        n++;\r\n        j = ans.readDouble();\r\n        p = ouf.readDouble();\r\n        if (!doubleCompare(j, p, EPS)) {\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%.7f', found: '%.7f', error = '%.7f'\",\r\n                  n, englishEnding(n).c_str(), j, p, doubleDelta(j, p));\r\n        }\r\n    }\r\n\r\n    if (n == 1)\r\n        quitf(_ok, \"found '%.7f', expected '%.7f', error '%.7f'\", p, j, doubleDelta(j, p));\r\n\r\n    quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int k = opt<int>(\"k\");\n    // Ensure that 1 ≤ K ≤ N\n    if (k < 1 || k > n) {\n        fprintf(stderr, \"Invalid k: %d (should be 1 ≤ k ≤ n)\\n\", k);\n        exit(1);\n    }\n\n    int epsilon = opt<int>(\"epsilon\", 500); // default value\n    if (epsilon < 1 || epsilon > 999){\n        fprintf(stderr, \"Invalid epsilon: %d (should be 1 ≤ epsilon ≤ 999)\\n\", epsilon);\n        exit(1);\n    }\n\n    int x0 = opt<int>(\"x0\", 0);\n    int y0 = opt<int>(\"y0\", 0);\n    if (x0 < -1000 || x0 > 1000 || y0 < -1000 || y0 > 1000){\n        fprintf(stderr, \"Invalid x0, y0: (%d,%d) (should be between -1000 and 1000)\\n\", x0, y0);\n        exit(1);\n    }\n\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<pair<int, int> > objects;\n\n    if (type == \"all_at_point\") {\n        // All objects at impact point\n        for(int i=0; i<n; ++i) {\n            objects.push_back(make_pair(x0, y0));\n        }\n\n    } else if (type == \"max_distance\"){\n        // All objects at maximum distance from impact point\n        int xi, yi;\n        if (x0 >= 0) xi = x0 - 1000;\n        else xi = x0 + 1000;\n        if (y0 >= 0) yi = y0 - 1000;\n        else yi = y0 + 1000;\n\n        xi = max(-1000, min(1000, xi));\n        yi = max(-1000, min(1000, yi));\n\n        for(int i=0; i<n; ++i) {\n            objects.push_back(make_pair(xi, yi));\n        }\n\n    } else if (type == \"random\"){\n        // Random positions\n        for(int i=0; i<n; ++i) {\n            int xi = rnd.next(-1000, 1000);\n            int yi = rnd.next(-1000, 1000);\n            objects.push_back(make_pair(xi, yi));\n        }\n    } else if (type == \"line\"){\n        // Objects along a line from impact point\n        int dx = rnd.next(1, 5);\n        int dy = rnd.next(1, 5);\n        for(int i=0; i<n; ++i) {\n            int xi = x0 + i * dx;\n            int yi = y0 + i * dy;\n            xi = max(-1000, min(1000, xi));\n            yi = max(-1000, min(1000, yi));\n            objects.push_back(make_pair(xi, yi));\n        }\n    } else if (type == \"circle\"){\n        // Objects in a circle around impact point\n        double radius = opt<double>(\"radius\", 100.0); // default radius\n        for(int i=0; i<n; ++i) {\n            double angle = rnd.next(0.0, 2 * acos(-1));\n            int xi = x0 + int(radius * cos(angle));\n            int yi = y0 + int(radius * sin(angle));\n            xi = max(-1000, min(1000, xi));\n            yi = max(-1000, min(1000, yi));\n            objects.push_back(make_pair(xi, yi));\n        }\n    } else if (type == \"cluster\"){\n        // Objects clustered around impact point with small random offsets\n        for(int i=0; i<n; ++i) {\n            int xi = x0 + rnd.next(-5, 5);\n            int yi = y0 + rnd.next(-5, 5);\n            xi = max(-1000, min(1000, xi));\n            yi = max(-1000, min(1000, yi));\n            objects.push_back(make_pair(xi, yi));\n        }\n    } else if (type == \"one_far\"){\n        // One object far away, rest at impact point\n        for(int i=0; i<n-1; ++i) {\n            objects.push_back(make_pair(x0, y0));\n        }\n        int xi, yi;\n        if (x0 >= 0) xi = x0 - 1000;\n        else xi = x0 + 1000;\n        if (y0 >= 0) yi = y0 - 1000;\n        else yi = y0 + 1000;\n\n        xi = max(-1000, min(1000, xi));\n        yi = max(-1000, min(1000, yi));\n\n        objects.push_back(make_pair(xi, yi));\n\n    } else if (type == \"grid\"){\n        // Objects in a grid around impact point\n        int grid_size = opt<int>(\"grid_size\", 10);\n        int half_grid = grid_size / 2;\n        for(int i=-half_grid; i<=half_grid; ++i){\n            for(int j=-half_grid; j<=half_grid; ++j){\n                if ((int)objects.size() >= n)\n                    break;\n                int xi = x0 + i;\n                int yi = y0 + j;\n                xi = max(-1000, min(1000, xi));\n                yi = max(-1000, min(1000, yi));\n                objects.push_back(make_pair(xi, yi));\n            }\n            if ((int)objects.size() >= n)\n                break;\n        }\n    } else {\n        // Default to random positions\n        for(int i=0; i<n; ++i) {\n            int xi = rnd.next(-1000, 1000);\n            int yi = rnd.next(-1000, 1000);\n            objects.push_back(make_pair(xi, yi));\n        }\n    }\n\n    // Output\n    printf(\"%d\\n\", n);\n    printf(\"%d %d\\n\", k, epsilon);\n    printf(\"%d %d\\n\", x0, y0);\n    for(int i=0; i<n; ++i){\n        printf(\"%d %d\\n\", objects[i].first, objects[i].second);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int k = opt<int>(\"k\");\n    // Ensure that 1 ≤ K ≤ N\n    if (k < 1 || k > n) {\n        fprintf(stderr, \"Invalid k: %d (should be 1 ≤ k ≤ n)\\n\", k);\n        exit(1);\n    }\n\n    int epsilon = opt<int>(\"epsilon\", 500); // default value\n    if (epsilon < 1 || epsilon > 999){\n        fprintf(stderr, \"Invalid epsilon: %d (should be 1 ≤ epsilon ≤ 999)\\n\", epsilon);\n        exit(1);\n    }\n\n    int x0 = opt<int>(\"x0\", 0);\n    int y0 = opt<int>(\"y0\", 0);\n    if (x0 < -1000 || x0 > 1000 || y0 < -1000 || y0 > 1000){\n        fprintf(stderr, \"Invalid x0, y0: (%d,%d) (should be between -1000 and 1000)\\n\", x0, y0);\n        exit(1);\n    }\n\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<pair<int, int> > objects;\n\n    if (type == \"all_at_point\") {\n        // All objects at impact point\n        for(int i=0; i<n; ++i) {\n            objects.push_back(make_pair(x0, y0));\n        }\n\n    } else if (type == \"max_distance\"){\n        // All objects at maximum distance from impact point\n        int xi, yi;\n        if (x0 >= 0) xi = x0 - 1000;\n        else xi = x0 + 1000;\n        if (y0 >= 0) yi = y0 - 1000;\n        else yi = y0 + 1000;\n\n        xi = max(-1000, min(1000, xi));\n        yi = max(-1000, min(1000, yi));\n\n        for(int i=0; i<n; ++i) {\n            objects.push_back(make_pair(xi, yi));\n        }\n\n    } else if (type == \"random\"){\n        // Random positions\n        for(int i=0; i<n; ++i) {\n            int xi = rnd.next(-1000, 1000);\n            int yi = rnd.next(-1000, 1000);\n            objects.push_back(make_pair(xi, yi));\n        }\n    } else if (type == \"line\"){\n        // Objects along a line from impact point\n        int dx = rnd.next(1, 5);\n        int dy = rnd.next(1, 5);\n        for(int i=0; i<n; ++i) {\n            int xi = x0 + i * dx;\n            int yi = y0 + i * dy;\n            xi = max(-1000, min(1000, xi));\n            yi = max(-1000, min(1000, yi));\n            objects.push_back(make_pair(xi, yi));\n        }\n    } else if (type == \"circle\"){\n        // Objects in a circle around impact point\n        double radius = opt<double>(\"radius\", 100.0); // default radius\n        for(int i=0; i<n; ++i) {\n            double angle = rnd.next(0.0, 2 * acos(-1));\n            int xi = x0 + int(radius * cos(angle));\n            int yi = y0 + int(radius * sin(angle));\n            xi = max(-1000, min(1000, xi));\n            yi = max(-1000, min(1000, yi));\n            objects.push_back(make_pair(xi, yi));\n        }\n    } else if (type == \"cluster\"){\n        // Objects clustered around impact point with small random offsets\n        for(int i=0; i<n; ++i) {\n            int xi = x0 + rnd.next(-5, 5);\n            int yi = y0 + rnd.next(-5, 5);\n            xi = max(-1000, min(1000, xi));\n            yi = max(-1000, min(1000, yi));\n            objects.push_back(make_pair(xi, yi));\n        }\n    } else if (type == \"one_far\"){\n        // One object far away, rest at impact point\n        for(int i=0; i<n-1; ++i) {\n            objects.push_back(make_pair(x0, y0));\n        }\n        int xi, yi;\n        if (x0 >= 0) xi = x0 - 1000;\n        else xi = x0 + 1000;\n        if (y0 >= 0) yi = y0 - 1000;\n        else yi = y0 + 1000;\n\n        xi = max(-1000, min(1000, xi));\n        yi = max(-1000, min(1000, yi));\n\n        objects.push_back(make_pair(xi, yi));\n\n    } else if (type == \"grid\"){\n        // Objects in a grid around impact point\n        int grid_size = opt<int>(\"grid_size\", 10);\n        int half_grid = grid_size / 2;\n        for(int i=-half_grid; i<=half_grid; ++i){\n            for(int j=-half_grid; j<=half_grid; ++j){\n                if ((int)objects.size() >= n)\n                    break;\n                int xi = x0 + i;\n                int yi = y0 + j;\n                xi = max(-1000, min(1000, xi));\n                yi = max(-1000, min(1000, yi));\n                objects.push_back(make_pair(xi, yi));\n            }\n            if ((int)objects.size() >= n)\n                break;\n        }\n    } else {\n        // Default to random positions\n        for(int i=0; i<n; ++i) {\n            int xi = rnd.next(-1000, 1000);\n            int yi = rnd.next(-1000, 1000);\n            objects.push_back(make_pair(xi, yi));\n        }\n    }\n\n    // Output\n    printf(\"%d\\n\", n);\n    printf(\"%d %d\\n\", k, epsilon);\n    printf(\"%d %d\\n\", x0, y0);\n    for(int i=0; i<n; ++i){\n        printf(\"%d %d\\n\", objects[i].first, objects[i].second);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -k 1 -epsilon 1 -x0 0 -y0 0 -type all_at_point\n\n./gen -n 1 -k 1 -epsilon 1 -x0 0 -y0 0 -type max_distance\n\n./gen -n 100 -k 100 -epsilon 1 -x0 0 -y0 0 -type all_at_point\n\n./gen -n 100 -k 100 -epsilon 1 -x0 0 -y0 0 -type max_distance\n\n./gen -n 100 -k 1 -epsilon 999 -x0 0 -y0 0 -type random\n\n./gen -n 100 -k 99 -epsilon 1 -x0 0 -y0 0 -type one_far\n\n./gen -n 100 -k 50 -epsilon 500 -x0 0 -y0 0 -type random\n\n./gen -n 100 -k 50 -epsilon 1 -x0 0 -y0 0 -type line\n\n./gen -n 100 -k 50 -epsilon 1 -x0 0 -y0 0 -type circle -radius 100.0\n\n./gen -n 100 -k 1 -epsilon 1 -x0 -1000 -y0 -1000 -type random\n\n./gen -n 100 -k 1 -epsilon 1 -x0 1000 -y0 1000 -type random\n\n./gen -n 100 -k 100 -epsilon 1 -x0 0 -y0 0 -type cluster\n\n./gen -n 100 -k 50 -epsilon 500 -x0 0 -y0 0 -type grid -grid_size 20\n\n./gen -n 100 -k 1 -epsilon 1 -x0 0 -y0 0 -type one_far\n\n./gen -n 100 -k 1 -epsilon 1 -x0 0 -y0 0 -type cluster\n\n./gen -n 100 -k 1 -epsilon 999 -x0 0 -y0 0 -type random\n\n./gen -n 1 -k 1 -epsilon 999 -x0 0 -y0 0 -type max_distance\n\n./gen -n 100 -k 100 -epsilon 999 -x0 0 -y0 0 -type all_at_point\n\n./gen -n 100 -k 50 -epsilon 1 -x0 50 -y0 -50 -type line\n\n./gen -n 100 -k 50 -epsilon 1 -x0 0 -y0 0 -type circle -radius 500.0\n\n./gen -n 100 -k 100 -epsilon 1 -x0 0 -y0 0 -type grid -grid_size 2000\n\n./gen -n 50 -k 25 -epsilon 250 -x0 1000 -y0 1000 -type random\n\n./gen -n 80 -k 40 -epsilon 400 -x0 -1000 -y0 -1000 -type random\n\n./gen -n 2 -k 2 -epsilon 1 -x0 0 -y0 0 -type all_at_point\n\n./gen -n 2 -k 1 -epsilon 1 -x0 0 -y0 0 -type one_far\n\n./gen -n 1 -k 1 -epsilon 1 -x0 0 -y0 0 -type random\n\n./gen -n 100 -k 1 -epsilon 1 -x0 0 -y0 0 -type line\n\n./gen -n 100 -k 100 -epsilon 1 -x0 0 -y0 0 -type line\n\n./gen -n 100 -k 100 -epsilon 1 -x0 0 -y0 0 -type circle -radius 0\n\n./gen -n 100 -k 50 -epsilon 500 -x0 0 -y0 0 -type cluster\n\n./gen -n 100 -k 80 -epsilon 100 -x0 500 -y0 500 -type circle -radius 200\n\n./gen -n 100 -k 20 -epsilon 800 -x0 -500 -y0 -500 -type random\n\n./gen -n 100 -k 100 -epsilon 1 -x0 1000 -y0 -1000 -type all_at_point\n\n./gen -n 100 -k 1 -epsilon 1 -x0 0 -y0 0 -type random\n\n./gen -n 100 -k 99 -epsilon 1 -x0 0 -y0 0 -type one_far\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:39:55.571475",
        "total_tutorials": 3,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "50/E",
      "title": "E. Square Equation Roots",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test5 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe single line contains two integers n and m. (1 ≤ n, m ≤ 5000000).",
      "output_spec": "OutputPrint a single number which is the number of real roots of the described set of equations.",
      "sample_tests": "ExamplesInputCopy3 3OutputCopy12InputCopy1 2OutputCopy1",
      "description": "E. Square Equation Roots\n\ntime limit per test5 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe single line contains two integers n and m. (1 ≤ n, m ≤ 5000000).\n\nOutputPrint a single number which is the number of real roots of the described set of equations.\n\nInputCopy3 3OutputCopy12InputCopy1 2OutputCopy1\n\nInputCopy3 3\n\nOutputCopy12\n\nInputCopy1 2\n\nOutputCopy1\n\nNoteIn the second test from the statement the following equations are analysed: b = 1, c = 1: x2 + 2x + 1 = 0; The root is x =  - 1 b = 1, c = 2: x2 + 2x + 2 = 0; No roots Overall there's one rootIn the second test the following equations are analysed: b = 1, c = 1: x2 + 2x + 1 = 0; The root is x =  - 1 b = 1, c = 2: x2 + 2x + 2 = 0; No roots b = 1, c = 3: x2 + 2x + 3 = 0; No roots b = 2, c = 1: x2 + 4x + 1 = 0; The roots are  b = 2, c = 2: x2 + 4x + 2 = 0; The roots are  b = 2, c = 3: x2 + 4x + 3 = 0; The roots are x1 =  - 3, x2 =  - 1 b = 3, c = 1: x2 + 6x + 1 = 0; The roots are  b = 3, c = 2: x2 + 6x + 2 = 0; The roots are  b = 3, c = 3: x2 + 6x + 3 = 0; The roots are  Overall there are 13 roots and as the root  - 1 is repeated twice, that means there are 12 different roots.",
      "solutions": [
        {
          "title": "Codeforces Beta Round #47 - Codeforces",
          "content": "Good afternoon.One more codeforces format round takes place this evening. I'm the author of the contest problems. Artem Rakhov and Maria Belova helped me to prepare the problems. Great thanks to them and all codeforces \"fighters\"!I wish you good luck and funny hacks!P.S:  This round won't be rated. So your ratings won't change. That's because of severe problems with codeforces server. Read here for explanation.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/985",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 414
        },
        {
          "title": "Codeforces #47 problem solutions - Codeforces",
          "content": "Problem A: Answer is floor(N*M*0.5). Since there is N*M cells on the board and each domino covers exactly two of them we cannot place more for sure. Now let's show how to place exactly this number of dominoes. If N is even, then place M rows of N/2 dominoes and cover the whole board. Else N is odd, so cover N-1 row of the board as shown above and put floor(M/2) dominoes to the last row. In the worst case (N and M are odd) one cell remains uncovered. Problem B: Of course you were expected to code solution which is not quadratic in time complexity. Iterate over the string and count how many times each char is used. Let Ki be the number of occurrences of char with ASCII-code i in the string S. Then answer is sum(Ki2). While coding the solution the following common mistakes were made:1. Code quadratic solution (double loop over the string)2. Forget to use int64. Whether in answer or in Ki squaring.3. Wrong int64 output.All these problems were easily hacked by max test with 100000 equal chars. This turned the hacking process into the game \"who hacks the next B solution faster\" because newbies often made all these mistakes. This problem was severed by the fact that GCC-compiler turned out to be MinGW-compiler, so output like printf(\"%lld\", ...) did not work on it. Another strange problem hackers faced was quiet test truncation by length about 30000 when copy/pasting it into the test editor. Of course the overflow in solution disappears after it.Problem C: You were asked to make all the cows strictly inside the interior of the route. Initially I planned to put \"non-strict\" there, but later I abandoned this idea because the answer for single point was really weird then=) The difference in solution is quite small. The answer for \"strict\" problem is always more than for \"non-strict\" by exactly 4. Some coders preferred to add four neighboring points for each point like a cross to switch to solving non-strict problem.The non-strict problem is solved in the following way. Notice that the required route can always be searched as an octagon, perhaps with some zero sides. Take four pairs of parallel lines and \"press\" it to the points. In other words, we find axis-aligned bounding box for the set of points. Then find axis-aligned bounding box of the point set on the picture which is rotated by 45 degrees. Now intersect these two boxes (as filled figures). We get an octagon in the common case, which is the required one. To implement the solution, we have to calculate minimums and maximums of X, Y, X+Y, X-Y through all the points, then use non-trivial formulas to get the answer.A lot of contestants solved the problem in other way. It is easy to see that to move by vector (X, Y) shepherd needs to make max(|X|, |Y|) turns. We can make the shepherd walk along the vertices of convex hull. We need to run a standard Graham scan and then iterate through all the points on the hull and sum max(|X'-X|, |Y'-Y|) for all pairs of neighboring vertices in it. This solution is also correct.There was an idea to make limit on coordinates equal to 109, but we decided that there was no need to ask for int64 again. Perhaps it'd have been better if there'd been int64 in this problem instead of problem B.Problem D: The problem statement looks intricate and aggressive. That's because the problem legend originates from civil defense classes in the university. Civil defense is such a discipline which for example teaches how to behave before and after nuclear attack...First of all we should notice that the bigger the warhead, the better (I mean the probability to succeed is higher). This seems quite reasonable. Function P(D, R) increases as R increases with fixed D. Obviously the probability to hit at least K objects increases in this case too. Hence we can find the answer by binary search. We have to be able to find the probability to accomplish the mission with fixed and known radius R to perform binary search.Now we have to solve the problem: there are N objects, each of them is destroyed with given probability (pi). Find the probability to destroy at least K of them. The problem is solved by dynamic programming which is similar to calculating binomial coefficients using Pascal's triangle. Let R[i, j] be the probability to hit exactly j objects among the first i of all the given ones. If we find all the R values for 0<=j<=i<=N, then the answer is calculated as sum_{j=k..N} R[N, j]. The base of DP is: R[0, 0] = 1. Induction (calculating the new values) is given by the formula R[i, j] = R[i-1, j-1] * pi + R[i-1, j] * (1-pi). Keep in mind that for j<0 or j>i all the elements of R are zeroes.It was shown experimentally that many coders (me included) try to solve the problem by taking into account only the closest K targets. I.e. they think that the probability to succeed is simply p1 * p2 *... * pK. This is wrong: for example, if two buildings with equal distance are given, then the probability to hit at least one of them is 1-(1-p)2 instead of p. But I decided to please these coders and composed the pretests only of the cases on which this solution passes=) So this particular incorrect solution was passing all the pretests intentionally.Problem E: Let D = b2-c be quarter of discriminant. The equation roots are -b-sqrt(D) и -b+sqrt(D). Thus there are two types of roots: irrational ones like x +- sqrt(y) and integer ones. We count the number of different roots separately for these types.Irrational roots are in form x+sqrt(y) (y is not square of integer). If two numbers in this form are equal, then their x и y values are also equal. It can be checked on the piece of paper. The main idea is to use irrationality of sqrt(y). Thus if two irrational roots are equal, then the equations are the same. Hence all the irrational roots of all the given equations are different. Let's iterate b=1..N. For each of b values we have to find the number of equations with positive discriminant which are not squares on integers. I.e. number of c=1...M with D = b2-c is not square of integer. We can calculate set of all possible values of D as a segment [L; R] (L >= 0). Then take its size (R-L+1) and subtract number of squares in it. It is exactly the the number of equations with irrational roots for a fixed b. Multiply it by 2 (two roots per equation) and add it to the answer.Now let's handle integer roots. For a fixed b we've calculated the segment [L;R] of all D values. Then sqrt(D) takes integer values in segment [l; r] = [ceil(sqrt(L)); floor(sqrt(R))]. We put this segment into the formula for equation roots and understand that all the integer roots of equations with fixed b compose segments [-b-r;-b-l] и [-b+l;-b+r]. However the integer roots may substantially be equal for different equations. That's why we have to mark in a global data structure that all the roots in these two segments are \"found\". After we iterate through all b=1..N, we have to find number of integers marked at least once in this data structure.This data structure is implemented on array. All the integer roots of equations lie in bounds from -10000000 to 0. Allocate an array Q which is a bit larger in size. To mark segment [s; t] we increment Q[s] by one and decrement Q[t+1] by one. At the end of the solution iterate through the whole array Q from left to right and calculate prefix sums to array S. I.e. S[i] = Q[-10000010] + Q[-10000009] + ... + Q[i-1] + Q[i]. Then S[i] represents number of times we've marked number i. Now iterate through S array and count number of nonzero elements. It is the number of different integer roots.The solution requires O(N) time since we have to iterate through all b values. It is likely that purely combinatoric (O(1)) formula for answer exists=)Conclusion. I think that there were two problems in the contest (except the system's epic fail of course). The first: there was no technically hard problem. Because of this high-rated coders had solved all the problems by the end of first hour and had to torture themselves by hacking others in heavily instable contest system during the remaining hour. I think that problem E in any round should be really tough to code. The second problem is huge number of hacks for problem B. I should have set the limit on string length to 40000. There is one more interesting question: why are divisions merged together? It would be wiser if any room were first division only or second division only. Then first division coders would concentrate on hacking solution for difficult problems instead of catching simple newbies' mistakes.Reminder: you can see the tests for all problems in contest system.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/1006",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 8615
        },
        {
          "title": "Round# 47 simple tutorial - Codeforces",
          "content": "An*m/2.BRecord the occurrences' number of each letters, signed as cnt[char].For each char in string, get the cnt[c]^2 plus together, and this is the answer.CCalculate the Convex Hull. The sum of the max value between x-difference and y-difference of each adjacent points in the convex hull's set and 4 is the answer.4 step can make a circle of 360 degree.DCounting the answer with Half, and check the answer using Dynamic Programming.Let dp[i][j] means the probability of first i objects where j of them exploded, and the transfering formular is:dp[i][j] = P(i) * dp[i - 1][j - 1] + (1 - P(i)) * dp[i - 1][j], where P(i) means the i-th object exploding's probability.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/1003",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 667
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces #47 problem solutions - Codeforces - Code 1",
          "code": "#include<stdio.h>#include<string.h>char a[1000009];int b[256];int main(){        __int64 i,sum,n;        gets(a);        n=strlen(a);        for(i=0;i<n;i++){                ++b[a[i]];        }        sum=0;        for(i=0;i<256;i++){                if(b[i]){                        sum+=b[i]*b[i];                        b[i]=0;                }        }        printf(\"%I64d\\n\",sum);        return 0;}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/1006",
          "author": "jiangly"
        },
        {
          "title": "Codeforces #47 problem solutions - Codeforces - Code 2",
          "code": "sum+=b[i]*b[i];That's the mistake. Compiler will calculate the right part first: b[i] is int, so b[i]*b[i] is int too.If b[i]=100000, this line became the following: sum += 1410065408;So you should writesum+=(__int64)b[i]*b[i];instead.Compiler see that the first operand is __int64, and will convert the second one to __int64 too.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/1006",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 5000000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 5000000, \"m\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 5000000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 5000000, \"m\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 5000000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 5000000, \"m\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    // Register the generator; do not set any explicit seed\n    registerGen(argc, argv, 1);\n\n    // Read parameters from the command line\n    // By default, n = 10 and m = 10, and type = \"regular\"\n    int N = opt<int>(\"n\", 10);\n    int M = opt<int>(\"m\", 10);\n    string type = opt<string>(\"type\", \"regular\");\n\n    // We'll decide how to finalize n and m based on \"type\"\n    int n, m;\n\n    if (type == \"regular\") {\n        // Just output (N, M) as is\n        n = N;\n        m = M;\n    }\n    else if (type == \"random\") {\n        // Output random values in [1..N] and [1..M]\n        // (Use testlib's rnd to avoid using std::rand)\n        n = rnd.next(1, N);\n        m = rnd.next(1, M);\n    }\n    else if (type == \"maxn\") {\n        // Fix n = N, let m be random in [1..M]\n        n = N;\n        m = rnd.next(1, M);\n    }\n    else if (type == \"maxm\") {\n        // Fix m = M, let n be random in [1..N]\n        n = rnd.next(1, N);\n        m = M;\n    }\n    else if (type == \"maxboth\") {\n        // Fix both n = N, m = M\n        n = N;\n        m = M;\n    }\n    else if (type == \"small_special\") {\n        // Force a few small corner-case values, ignoring N, M\n        // for testing typical pitfalls\n        // e.g., randomly choose among known small corner cases\n        vector<pair<int,int>> corners = {\n            {1,1}, {1,2}, {2,2}, {3,3}, {2,3}, {3,2}\n        };\n        auto pr = corners[rnd.next((int)corners.size())];\n        n = pr.first;\n        m = pr.second;\n    }\n    else if (type == \"large_special\") {\n        // Large corner cases, ignoring N, M\n        // e.g., near the maximum, or mixed\n        vector<pair<int,int>> corners = {\n            {5000000, 5000000},\n            {5000000, 1},\n            {1, 5000000},\n            {4999999, 5000000},\n            {5000000, 4999999}\n        };\n        auto pr = corners[rnd.next((int)corners.size())];\n        n = pr.first;\n        m = pr.second;\n    }\n    else {\n        // Fallback: just output (N, M)\n        n = N;\n        m = M;\n    }\n\n    // Ensure they stay within [1..5,000,000] if someone passes large N, M\n    // (just in case)\n    n = max(1, min(n, 5000000));\n    m = max(1, min(m, 5000000));\n\n    // Output a single line with n and m\n    cout << n << \" \" << m << \"\\n\";\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    // Register the generator; do not set any explicit seed\n    registerGen(argc, argv, 1);\n\n    // Read parameters from the command line\n    // By default, n = 10 and m = 10, and type = \"regular\"\n    int N = opt<int>(\"n\", 10);\n    int M = opt<int>(\"m\", 10);\n    string type = opt<string>(\"type\", \"regular\");\n\n    // We'll decide how to finalize n and m based on \"type\"\n    int n, m;\n\n    if (type == \"regular\") {\n        // Just output (N, M) as is\n        n = N;\n        m = M;\n    }\n    else if (type == \"random\") {\n        // Output random values in [1..N] and [1..M]\n        // (Use testlib's rnd to avoid using std::rand)\n        n = rnd.next(1, N);\n        m = rnd.next(1, M);\n    }\n    else if (type == \"maxn\") {\n        // Fix n = N, let m be random in [1..M]\n        n = N;\n        m = rnd.next(1, M);\n    }\n    else if (type == \"maxm\") {\n        // Fix m = M, let n be random in [1..N]\n        n = rnd.next(1, N);\n        m = M;\n    }\n    else if (type == \"maxboth\") {\n        // Fix both n = N, m = M\n        n = N;\n        m = M;\n    }\n    else if (type == \"small_special\") {\n        // Force a few small corner-case values, ignoring N, M\n        // for testing typical pitfalls\n        // e.g., randomly choose among known small corner cases\n        vector<pair<int,int>> corners = {\n            {1,1}, {1,2}, {2,2}, {3,3}, {2,3}, {3,2}\n        };\n        auto pr = corners[rnd.next((int)corners.size())];\n        n = pr.first;\n        m = pr.second;\n    }\n    else if (type == \"large_special\") {\n        // Large corner cases, ignoring N, M\n        // e.g., near the maximum, or mixed\n        vector<pair<int,int>> corners = {\n            {5000000, 5000000},\n            {5000000, 1},\n            {1, 5000000},\n            {4999999, 5000000},\n            {5000000, 4999999}\n        };\n        auto pr = corners[rnd.next((int)corners.size())];\n        n = pr.first;\n        m = pr.second;\n    }\n    else {\n        // Fallback: just output (N, M)\n        n = N;\n        m = M;\n    }\n\n    // Ensure they stay within [1..5,000,000] if someone passes large N, M\n    // (just in case)\n    n = max(1, min(n, 5000000));\n    m = max(1, min(m, 5000000));\n\n    // Output a single line with n and m\n    cout << n << \" \" << m << \"\\n\";\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Below are example commands to generate around 20-30 diverse test cases.\n# Each command prints a single line \"n m\", without redirection to a file.\n\n# 1) Minimal corner case\n./gen -n 1 -m 1 -type regular\n\n# 2) Another small corner\n./gen -n 1 -m 2 -type regular\n\n# 3) A moderate small test\n./gen -n 3 -m 3 -type regular\n\n# 4) Force small corner-case picks from a fixed set\n./gen -type small_special\n\n# 5) Typical random among [1..5], [1..5]\n./gen -n 5 -m 5 -type random\n\n# 6) Another random, medium range\n./gen -n 100 -m 200 -type random\n\n# 7) Another random, bigger range\n./gen -n 1000 -m 1000 -type random\n\n# 8) Large random in [1..500000], [1..400000]\n./gen -n 500000 -m 400000 -type random\n\n# 9) Very large random in [1..5000000], [1..5000000]\n./gen -n 5000000 -m 5000000 -type random\n\n# 10) Force n = N, random m in [1..M]\n./gen -n 1000 -m 2000 -type maxn\n\n# 11) Force random n in [1..N], m = M\n./gen -n 1000 -m 2000 -type maxm\n\n# 12) Force n = N, m = M exactly\n./gen -n 2000 -m 3000 -type maxboth\n\n# 13) Another forced large corner\n./gen -n 5000000 -m 5000000 -type maxboth\n\n# 14) Large special corner from a set\n./gen -type large_special\n\n# 15) Another \"regular\" with moderate values\n./gen -n 999 -m 1001 -type regular\n\n# 16) Another random with moderate range\n./gen -n 999 -m 1001 -type random\n\n# 17) Slightly bigger random\n./gen -n 50000 -m 60000 -type random\n\n# 18) Another forced n = 5000000, random m\n./gen -n 5000000 -m 100 -type maxn\n\n# 19) Another forced m = 5000000, random n\n./gen -n 100 -m 5000000 -type maxm\n\n# 20) Regular with bigger but not max\n./gen -n 123456 -m 234567 -type regular\n\n# 21) Substantial random near mid-range\n./gen -n 300000 -m 250000 -type random\n\n# 22) Another large special\n./gen -type large_special\n\n# 23) Another small special\n./gen -type small_special\n\n# 24) Another explicit corner case\n./gen -n 2 -m 5000000 -type regular\n\n# 25) Same as above but random\n./gen -n 2 -m 5000000 -type random\n\n#\n# You can continue adding more as needed, but these ~25 should adequately\n# cover a wide variety of scenarios for contestants.\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:39:57.338770",
        "total_tutorials": 3,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "500/A",
      "title": "A. Транспорт на Новый год",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест2 секунды",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеВ первой строке записано два целых числа через пробел, n (3 ≤ n ≤ 3 × 104) и t (2 ≤ t ≤ n) — количество ячеек и номер ячейки, в которую я хочу попасть.Во второй строке записано n - 1 целых чисел через пробел a1, a2, ..., an - 1 (1 ≤ ai ≤ n - i). Гарантируется, что пользуясь данной транспортной системой, покинуть Линейный мир нельзя.",
      "output_spec": "Выходные данныеЕсли я могу дойти до ячейки t по данной транспортной системе, выведите \"YES\". В противном случае, выведите \"NO\".",
      "sample_tests": "ПримерыВходные данныеСкопировать8 41 2 1 2 1 2 1Выходные данныеСкопироватьYESВходные данныеСкопировать8 51 2 1 2 1 1 1Выходные данныеСкопироватьNO",
      "description": "A. Транспорт на Новый год\n\nограничение по времени на тест2 секунды\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвыводstdout\n\nВходные данныеВ первой строке записано два целых числа через пробел, n (3 ≤ n ≤ 3 × 104) и t (2 ≤ t ≤ n) — количество ячеек и номер ячейки, в которую я хочу попасть.Во второй строке записано n - 1 целых чисел через пробел a1, a2, ..., an - 1 (1 ≤ ai ≤ n - i). Гарантируется, что пользуясь данной транспортной системой, покинуть Линейный мир нельзя.\n\nВходные данные\n\nВыходные данныеЕсли я могу дойти до ячейки t по данной транспортной системе, выведите \"YES\". В противном случае, выведите \"NO\".\n\nВыходные данные\n\nВходные данныеСкопировать8 41 2 1 2 1 2 1Выходные данныеСкопироватьYESВходные данныеСкопировать8 51 2 1 2 1 1 1Выходные данныеСкопироватьNO\n\nВходные данныеСкопировать8 41 2 1 2 1 2 1\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопироватьYES\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать8 51 2 1 2 1 1 1\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопироватьNO\n\nВыходные данныеСкопировать\n\nСкопировать\n\nПримечаниеВ первом примере можно дойти до t, посетив следующие ячейки: 1, 2, 4.Во втором примере можно посетить лишь ячейки 1, 2, 4, 6, 7, 8; значит, мы не можем попасть в требуемую ячейку 5.",
      "solutions": [
        {
          "title": "Good Bye 2014 - Codeforces",
          "content": "Привет, Codeforces!Добро пожаловать на последний раунд Codeforces в 2014 году, Good Bye 2014! Этот раунд очень необычный; Во-первых, раунд начинается 30 декабря в 18:00 по Москве. Во-вторых, раунд длится 2.5 часа. И в третьих, раунд будет общим для двух дивизионов, что означает, что Div1- и Div2-участники не будут разделены.Задачи подготовлены мной (.o.) и Seunghyun Jo (ainta). Это наш второй раунд на Codeforces. После нашего первого раунда случился чёрный день Codeforces, и мы надеемся, что в этот раз ничего подобного не произойдёт :DСпасибо Won-seok Yoo(ainu7), который тестировал раунд и обусждал с нами набор задач.Также мы хотим поблагодарить некоторых людей, без которых этот раунд не состоялся бы. Максим Ахмедов (Zlobober) сильно помог нам в подготовке задач. Мария Белова (Delinur) перевела условия задач на русский язык. Михаил Мирзаянов (MikeMirzayanov) создал прекрасные сайт Codeforces и систему Polygon. Они также заслуживают аплодисменты!Разбалловка будет оглашена перед началом раунда, как обычно.Мы желаем вам всем удачи. С новым годом!Просьба оставлять комментарии на английском языке, если вы хотите, чтобы авторы смогли их прочитать.UPD (2014-12-30 17:34:48) Разбалловка будет выглядеть следующим образом: 500-1000-1000-1500-2750-2750-3500.UPD (2014-12-31 12:49:05) Sorry for updating in English. Round has finished, congratulations to the winners! tourist Petr rng_58 HYPERHYPERHYPERCUBELOVER subscriber Merkurev al13n mmaxio mexmans GlebsHP Also, thanks to Marcin_smu, who solved problem G after the contest for the first time.UPD(2014-12-31 12:51:08) Sorry for updating in English. Editorial is published. Currently, only A-F is available, but I will add G as soon as possible. Sorry for the late editorial.UPD(2015-01-02 21:30:44) I wrote the editorial of G. Sorry for the late update..",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/15465",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.6,
            "reason": "宽松匹配: 包含题目编号 500 和字母"
          },
          "content_length": 1816
        },
        {
          "title": "Good Bye 2014 Tutorial - Codeforces",
          "content": "500A — New Year TransportationIn this problem we are given a directed graph, and asked whether a particular vertex is reachable from vertex 1. It is possible to solve this by running a depth-first search starting from vertex 1.Since every vertex has at most one outgoing edge, it is possible to write the DFS as a simple loop. Some people used this to make very short submissions.500B — New Year PermutationImagine a graph with one vertex for each entry in the permutation, and edges between pairs of swappable entries. It is easy to see that no matter how many swaps we make, no entry can end up in a location that is not in its connected component. We can also show that within any connected component, we can achieve any rearrangement of the entries that we wish.Since we want to make the lexicographically smallest permutation, we should greedily rearrange the entries within each connected component so that they are in increasing order.N ≤ 300, so we are not concerned with runtime. One can determine the connected components using a number of standard algorithms (Floyd-Warshall, Union Find, etc.).500C — New Year Book ReadingConsider an arbitrary day d, on which we must read book b. Let d' be the last day before d on which book b was read (if there is no previous day, let d' =  - ∞). Observe that, on day d, we cannot avoid lifting all of the books read on any day between d' and d. If we add up all the weights of these required liftings, we will have a lower bound on the answer.This lower bound can be computed with two loops, in O(M2) time. We must be sure not to add a book's weight multiple times, if it was read multiple times in the interval (d', d).If we initially arrange the books in order of the first day on which they are read, we will achieve the described lower bound. So, we have our answer.500D — New Year Santa NetworkBy linearity of expectation, E(d(c1, c2) + d(c1, c3) + d(c2, c3)) = E(d(c1, c2)) + E(d(c1, c3)) + E(d(c2, c3)). By symmetry, those three values are all equal. So, we need only compute E(d(c1, c2)). We can multiply it by 3 to find the answer.Let us imagine that a random selection (c1, c2, c3) is made. We'll define a function f(j), for each edge j, so that f(j) = wj if j is part of the shortest path from c1 to c2, and f(j) = 0 otherwise. Observe that . Again by linearity, we have .We can write E(f(j)) = wj·P(j), where P(j) is the probability that edge j is included in the path from c1 to c2. If we compute P(j) for all j, we can then compute in O(N). Also, we can handle updates in O(1); if wj changes to w'j, we subtract wj·P(j) from the answer, and add w'j·P(j). So, let's figure out P(j) for each j. Any edge j, if removed from the tree, separates the graph into two separate connected components a and b. Edge j will be included in the shortest path from c1 to c2 if and only if one of them is in a, and the other is in b. So, we want the number of ways to select (c1, c2, c3) such that c1 and c2 are on opposite sides of edge j, divided by the total number of ways to select (c1, c2, c3). Let's have |a| and |b| denote the number of vertices in a and b, respectively. Then .To figure out |a| and |b| for each j, we can root the tree arbitrarily and compute the depth and subtree size for each vertex in O(N) time. Then for an edge j, if vj is the deeper vertex incident to j, we know one component has size equal to the subtree size of vj. For the other component, we use the fact that |b| = N - |a|. 500E — New Year DominoWhen domino i is knocked over, it covers the interval [pi, pi + li]. If we see a query (xj, yj), it is equivalent to the question \"If we knock over all dominoes with index , how much of the interval [pxj, pyj] won't be covered?\" We can modify that question a little more, to say that we knock over all dominoes with index i ≥ xj, without changing its answer. Now, consider knocking over the dominoes from right to left. As soon as we knock over domino i, we will immediately process all of the queries with xj = i, and record their answers. What we need is a data structure that supports two operations: \"cover range [pi, pi + li]\" (when we knock over a domino) and \"compute how much of the range [pxj, pyj] is not covered\" (when we wish to answer a query). This can be done using coordinate compression and a segment tree. It's worth noting there are a lot of other ways to solve this problem. The other tutorial uses a completely different approach. Also, the approach described here may be implemented using different data structures. For example, here is my implementation using BBSTs and a Binary Indexed Tree.500F — New Year ShoppingWe will use the standard dynamic programming approach for 0/1 knapsack. To summarize what it does for us, imagine we are given an ordered list of items (ci, hi). Let F(k, b) be the maximum happiness we can buy, if we consider only the first k items in the list, and have a budget of b. If K is the size of the list, and B is the maximum possible budget, we can compute F(k, b) for all possible k and b in O(KB) time.Let us sort all of the items by their display time. Suppose that we focus on the queries (aj, bj) with , for some particular t. Let A be a list of the items with display time in (t - P, t], and let B be a list of the items with display time in (t, t + P). Let both lists be sorted in order of display time.Every query with will have available to it some suffix of A, along with some prefix of B. We'll do a knapsack DP on the elements of A, in reverse order, and another on the elements of B, in normal order. Finally, to answer any query (aj, bj) with , we can consider all possible ways to split the budget bj between the items in A and the items in B, in linear time. For each possible way to split the budget, we need simply look up one value from each DP table to know the maximum possible happiness.If we perform the process above on t = 1, 1 + P, 1 + 2P, 1 + 3P, ... until t exceeds the maximum possible day D, we'll be able to answer all of the queries. Let's think about the runtime of this solution. For each t, the described process takes O(KB) time, where K is the number of items whose display time is in (t - P, t + P). Each object can only appear in up to two of these intervals. So, the overall runtime for all of the knapsack DP's we perform is O(nB). Computing the final answer takes O(B) per query, or O(qB) overall.500G — New Year RunningDon't know how to solve this yet. Maybe someone who is not gray can provide the solution. :)",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/15513",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 500\\s*A"
          },
          "content_length": 6486
        },
        {
          "title": "Good Bye 2014 Editorial - Codeforces",
          "content": "First of all, sorry for the late editorial. I was too exhausted and immediately went to bed after the round finished, and didn't write the editorial.There are many pictures in this editorial, to cover up my poor English skills! If you have detected any errors or have questions, feel free to ask questions by comments. Unfortunately, the authors only know English, so we can't answer you if you write comments in Russian.500A - Транспорт на Новый годLet's assume that I am in the cell i (1 ≤ i ≤ n). If i ≤ n - 1, I have two choices: to stay at cell i, or to go to cell (i + ai). If i = t, we are at the target cell, so I should print \"YES\" and terminate. If i > t, I cannot go to cell t because I can't use the portal backwards, so one should print \"NO\" and terminate. Otherwise, I must go to cell (i + ai).Using this method, I visit each cell at most once, and there are n cells, so the problem can be solved in linear time.What is test 13?There are 9 pretests in this problem. There are no test where n = t holds in pretests. Many people didn't handle this case, and got hacked or got Wrong Answer on test 13. Time: O(n) Memory: O(n) (maybe O(1)) Implementation: 9335683 500B - Новогодняя перестановкаIt seems that many contestants were confused by the statement, so let me clarify it first. Given a permutation p1, p2, ..., pn and a n × n-sized binary matrix A, the problem asks us to find the lexicographically minimum permutation which can be achieved by swapping two distinct elements pi and pj where the condition Ai, j = 1 holds. (From the statement, permutation A is prettier than permutation B if and only if A is lexicographically less than B.)Let's think matrix A as an adjacency matrix of a undirected unweighted graph.If two vertices i and j are in the same component (in other words, connected by some edges), the values of pi and pj can be swapped, using a method similar to bubble sort. Look at the picture below for easy understanding.Because all the two distinct vertices in the same component can be swapped, the vertices in the same component can be sorted. In conclusion, we can solve the problem by the following procedure. Find all the connected components. For each component, sort the elements in the component. Print the resulting permutation. The size limit is quite small, so one can use any algorithm (DFS/BFS/..) for as many times as you want. Time: O(n2) — because of the graph traversal. O(n3) is okay because of small constraints. Memory: O(n2) Implementation: 9335689 (.o.) What is test 15? There are too many wrong answers in this case.Actually, I made the pretests very weak in order to make many hacks. As mentioned in the Hack me! post by kostka, just swapping the elements greedily could pass the pretests easily. There were 14 pretests, and I made test 15 an counter-example of such algorithm in order to reduce judging time, and it seems that most of the wrong submissions failed in this test case :D500C - В Новый год --- с книгой!In order to calculate the minimum possible lifted weight, we should find the initial stack first. Let's find the positions one by one. First, let's decide the position of book b1. After day 1, book b1 will be on the top of the stack, regardless of the order of the initial stack. Therefore, in order to minimize the lifted weight during day 1, book b1 must be on the top of the initial stack. (so actually, in day 1, Jaehyun won't lift any book) Next, let's decide the position of book b2. (assume that b1 ≠ b2 for simplicity) Currently, b1 is on the top of the stack, and it cannot be changed because of the procedure. Therefore, in order to minimize the lifted weight during day 2, book b2 must be immediately below book b1. Considering this, we can find the optimal strategy to create the initial stack: Scan b1, b2, ..., bm step by step. Let's assume that I am handling bi now. If bi has appeared before (formally, if ), erase bi from the sequence. Otherwise, leave bi. The resulting sequence will be the optimal stack.You should note that it is not necessary for Jaehyun to read all the books during 2015, which means the size of the resulting sequence may be smaller than n. The books which doesn't appear in the resulting sequence must be in the bottom of the initial stack (obviously). However, this problem doesn't require us to print the initial stack, so it turned out not to be important. In conclusion, finding the initial stack takes O(n + m) time.After finding the initial stack, we can simulate the procedure given in the statement naively. It will take O(nm) time. Time: O(nm) Memory: O(n + m) Implementation: 9335694 (.o.) 500D - Новогоднее взаимодействие Санта-КлаусовThe problem asks us to calculate the value ofLet's write it down..So, we need to calculate the value of . I'll denote the sum as S. How should we calculate this?For simplicity, I'll set node 1 as the root of the tree. Let's focus on an edge e, connecting two vertices u and p. See the picture below.Set A is a set of vertices in the subtree of vertex u, and set B is a set of vertices which is not in the subtree of vertex u. So, is the set of vertices in the tree, and is empty.For all pairs of two vertices (x, y) where the condition and holds, the shortest path between x and y contains edge e. There are size(A) × size(B) such pairs. So, edge e increases the sum S by 2 × le × size(A) × size(B). (because d(x, y) and d(y, x) both contributes to S)size(A) (the size of the subtree whose root is u) can be calculated by dynamic programming in trees, which is well known. size(B) equals to N - size(A). So, for each edge e, we can pre-calculate how many times does this edge contributes to the total sum. Let's define t(e) = size(A) × size(B), (A and B is mentioned above). If the length of a certain road e decreases by d, S will decrease by t(e) × d. So we can answer each query. Time: O(n) (pre-calculation) + O(q) (query) Memory: O(n) (O(n + q) is okay too) Implementation: 9335695 (.o.) Something about precision errorBecause of the tight constraints, the total sum of d(a, b) + d(b, c) + d(c, a) (it is equal to S × (n - 2)) can be so large that it can't be saved in long long(64-bit integer) type. Some contestants didn't handle this and got WA. However, there are some contestants who saved this value divided by n × (n - 1) × (n - 2) in double type. double has 52 bits to store exact value, so it isn't enough. But because we allow 10 - 6 precision error, it seems to have been got accepted.What if we allowed the length of the road could become 0? Then the precision error gets much more bigger, and the solution prints something that is far from the expected value (for example, negative value). ainu7 discovered this effect and suggested to apply this, but we didn't because it was hard to fix the statement..Why does the road length decreases? It doesn't matter even if increases.It's because of the weird legend. It is hard to explain, \"People repairs a certain road per year, and its length may be increased or decreased.\" fluently for me..500E - Новогоднее доминоFrom the statement, it is clear that, when domino i falls to the right, it makes domino j also fall if and only if pi < pj ≤ pi + li.For each domino i, let's calculate the rightmost position of the fallen dominoes R[i] when we initially pushed domino i. From the definition, . This can be calculated by using a segment tree or using a stack, in decreasing order of i (from right to left). After that, we define U[i] as the smallest j where R[i] < pj holds. (In other words, the smallest j where domino j is not affected by pushing domino i)Now, the problem becomes: Calculate P[U[xi]] - R[xi] + P[U[U[xi]]] - R[U[xi]] + ..., until U[xi] ≤ yi. Because i < U[i], this task can be solved by precalculating 'jumps' of 2something times, using the method described in here. You must read the \"Another easy solution in <O(N logN, O(logN)>\" part..Formally, let's define Un + 1[k] = U[Un[k]] and Sn + 1[k] = Sn[k] + (P[Un + 1[k]] - R[Un[k]]). So, Sn[k] means the sum of domino length extensions when we initially push domino i and we prolonged the length exactly n times. U2i + 1[k] = U2i[U2i[k]], and S2i + 1[k] = S2i[k] + S2i[U2i[k]] holds. (If you don't understand this part, I suggest you to read the article linked above) Time : or . Memory : Implementation: 9335698 (.o.) We would like to know whether there is a linear offline solution or not. 500F - Новогодние покупки The i-th item is available during [ti, ti + p - 1]. In other words, at time T, item i is available if and only if ti ≤ T ≤ ti + p - 1. This can be re-written as (ti ≤ T and T - p + 1 ≤ ti), which is T - p + 1 ≤ ti ≤ T. With this observation, we can transform the item's purchasable range into a dot, and the candidate's visit time into a range: From now on, item i is only available at time ti. and each candidate pair (aj, bj) means that I can visit the store during [aj - p + 1, aj], and my budget is bj dollars at that visit. This transformation makes the problem easier to solve.Each red circled point denotes an item which is sold at that time, and each black interval denotes a candidate. Let's only consider the intervals which passes time T. All the intervals' length is exactly p, so the left bound of the interval is (T - p) and the right bound of the interval is (T + p). For each interval, we'd like to solve the 0/1 knapsack algorithm with the items that the interval contains. How can we do that effectively? There is an important fact that I've described above: all the interval passes time T. Therefore, the interval [aj - p + 1, aj] can be split into two intervals: [aj - p + 1, T - 1] and [T, aj].So, let's solve the 0/1 knapsack problem for all intervals [x, T - 1] (T - p ≤ x ≤ T - 1) and [T, y] (T ≤ y ≤ T + p). Because one of the endpoints is fixed, one can run a standard dynamic programming algorithm. Therefore, the time needed in precalculation is O(S × W), where S is the number of items where the condition holds.Let's define h(I, b), as the maximum happiness I can obtain by buying the items where the condition holds, using at most b dollars. For each candidate (aj, bj), we have to calculate h([aj - p + 1, aj], bj), which is equal to max0 ≤ k ≤ b{h([aj - p + 1, T - 1], k) + h([T, aj], b - k)}. So it takes O(bj) = O(W) time to solve each query.The only question left is: How should we choose the value of T? We have two facts. (1) The length of intervals is exactly p. (2) The algorithm covers intervals which passes time T. Therefore, to cover all the intervals given in the input, we should let T be p, 2p, 3p, 4p, ... (of course, one by one), and run the algorithm described above.Then, what is the total time complexity? Think of intervals [0, 2p], [p, 3p], [2p, 4p], [3p, 5p], .... For each point, there will be at most two intervals which contains the point. Therefore, each item is reflected in the pre-calculation at most twice, so the time needed to precalculate is O(n × W). The time needed to solve each query is O(bj), and the answer of the query is calculated at most once. Therefore, the time needed to answer all the queries is O(q × W). Time : O((n + q) × W). Memory : O(n × W) Implementations: 9335699 (ainta), 9335703 (ainu7) , 9335710 (.o., using a different approach), 9335709 (.o., using a divide and conquer approach) Divide and Conquer approachLet's assume that t1 ≤ t2 ≤ ... ≤ tn. We can easily know that at time T, the indexes of all the available items forms a segment [l, r]. (in other words, item l, item l + 1, ..., item r - 1, item r is available) We can use this fact to solve all the queries. Let's assume that item lj, item lj + 1, ..., item rj - 1, item rj is available at time aj.Define a function solve(L, R). This function calculates the answer for queries where the condition L ≤ lj ≤ rj ≤ R holds. Let's assume that L < R holds. (In the case L ≥ R, the answer can be calculated easily) Let . Call solve(L, M) and solve(M + 1, R). After that, the queries needed to be calculated, satisfies the condition lj ≤ M < rj, which means all the intervals(queries) passes item M. Now, to calculate the answer for such queries, we can use the method described at the dynamic programming approach.The time complexity is , because and the answer of the queries can be calculated in O(bj) per query. Time : . Memory : O(n × W) Implementation: 9335709 Unfortunately, this approach is offline, because of the memory. Is there any available online approach using divide and conquer?Blocking the divide and conquer solutionI tried my best to block divide and conquer solutions, but failed. It seems that many participants solved the problem with divide and conquer approach. My approach takes time, and it gets accepted in 546ms.500G - Новогодний забегBefore starting the editorial, I'd like to give a big applause to Marcin_smu, who solved the problem for the first time!Warning: The editorial is very long and has many mistakes. There are lots of lots of mistakes.. Keep calm, and please tell me by comments, if you discovered any errors.This problem can be solved by an online algorithm. Let's focus on a single query (u, v, x, y). This means that JH runs between u and v, and JY runs between x and y.Just like when we solve many problems with undirected trees, let vertex 1 be the root of the tree. Also, we will assume that they won't stop after when they meet, but they will continue running, in order to explain easily.Some definitions: Path (a, b): the shortest path between vertex a and vertex b. d(a, b): the length of Path (a, b). LCA(a, b): the lowest common ancestor of vertex a and vertex b. Finding the common path of two pathsIf there is no common vertex between Path (u, v) and Path (x, y), the answer will be obviously  - 1. So, let's find the common vertices first. Because the path between two vertices is always unique, the common vertices also form a path. So, I'll denote the path of the common vertices as Path (c1, c2). c1 and c2 may be equal to: u, v, x, y, and even each other.The possible endpoints are P1 = LCA(u, v), P2 = LCA(x, y), P3 = LCA(u, x), P4 = LCA(u, y), P5 = LCA(v, x), and P6 = LCA(v, y). Figure out by drawing some examples. (some of you might think it's obvious :D)See the pictures above, and make your own criteria to check whether the two paths intersects :DA small hint. Let's assume that we already know, that a vertex a lies on path (x, y). If a lies on path (u, v), a is a common vertex of two paths. What if a is guaranteed to be an end point of the common path?Additional definitions Let's denote JH's running course is: . Then, there are two possible courses for JY: and ). fJH : the time needed to run the course . fJY : the time needed to run the course . t1 : the first time when JH passes vertex c1, moving towards c2. t2 : the first time when JH passes vertex c2, moving towards c1. t3 : the first time when JY passes vertex c1, moving towards c2. t4 : the first time when JY passes vertex c2, moving towards c1. Case 1) When JH and JY meets while moving in the same directionObviously, they must meet at vertex c1 or vertex c2 for the first time. Without loss of generality, let's assume that they meet at vertex c1. In this case, both of them is moving towards vertex c2. (You can use the method similarly for c2) Let's assume that JH and JY meets at time T. Because the movements of both runners are periodic, T must satisfy the conditions below: Among possible T-s, we have to calculate the smallest value. How should we do? From the first condition, we can let T = fJH × p + t1, where p is a non-negative integer. With this, we can write the second condition as: . In conclusion, we have to find the smallest p which satisfies the condition Using the Extended Euclidean algorithm is enough to calculate the minimum p. With p, we can easily calculate the minimum T, which is the first time they meet. If there is no such p, they doesn't meet forever, so the answer is  - 1.Case 2) When JH and JY meets while moving in the opposite directionIn this case, they will meet at a vertex lying on Path (c1, c2). Without loss of generality, let's assume that JH is going from c1 to c2, and JY is going from c2 to c1.I'll assume that JH and JY meets at time T. [1] Let's see how JH moves: For all non-negative integer p, At time fJH × p + t1, he is at vertex c1, moving towards c2. At time fJH × p + t1 + d(c1, c2), he is at vertex c2. Therefore, when fJH × p + t1 ≤  (current time)  ≤ fJH × p + t1 + d(c1, c2), JH is on Path (c1, c2). So, T must satisfy the condition: fJH × p + t1 ≤ T ≤ fJH × p + t1 + d(c1, c2) [2] Let's see how JY moves: Similar to JH, for all non-negative integer q, At time fJY × q + t4, he is at vertex c2, moving towards c1. At time fJY × q + t4 + d(c2, c1), he is at vertex c1. Therefore, when fJY × q + t4 ≤  (current time)  ≤ fJY × q + t4 + d(c2, c1), JY is on Path (c2, c1). So, T must satisfy the condition: fJY × q + t4 ≤ T ≤ fJY × q + t4 + d(c1, c2) [3] These two conditions are not enough, because in this case, they can meet on an edge, but they cannot meet on a vertex.We'd like to know when do they meet on a vertex, like the picture below.As you see from the picture above, in this case, the condition d(c1, a) + d(a, c2) = d(c1, c2) holds. If this picture was taken at time s, this condition can be written as: {s - (fJH × p + t1)} + {s - (fJY × q + t4)} = d(c1, c2) 2s - (fJH × p + fJY × q) - (t1 + t4) = d(c1, c2) s = {d(c1, c2) + (fJH × p + fJY × q) + (t1 + t4)} / 2 Because JH and JY both travel their path back and forth, fJH and fJY are all even. Therefore, in order to make s an integer, d(c1, c2) + t1 + t4 must be even. This can be written as [4] Merging [1], [2] and [3], we can conclude that if these two conditions holds, max{fJH × p + t1, fJY × q + t4} ≤ min{fJH × p + t1 + d(c1, c2), fJY × p + t4 + d(c1, c2)} JH and JY meets on a certain vertex lying on path (c1, c2). The first condition can be easily checked, so let's focus on the second condition. The second condition holds if and only if: fJY × q + t4 - t1 - d ≤ fJH × p ≤ fJY × q + t4 - t1 + d You can check this by changing \"fJH × p\" to the lower bound and the upper bound of the inequality. Therefore, the problem is to find the smallest p which satisfies the condition above.Let's define a function g(M, D, L, R), where M, D, L, R are all non-negative integers. The function returns the smallest non-negative integer m which satisfies . This function can be implemented as follows. If L = 0, g(M, D, L, R) = 0. (because L = 0 ≤ D·0) If , it is \"obvious\" that there is no solution. If 2D > M, g(M, D, L, R) = g(M, M - D, M - R, M - L). If there exists an non-negative integer m which satisfies L ≤ D·m ≤ R (without modular condition), g(M, D, L, R) = m. Obviously, we should take the smallest m. Otherwise, there exists an integer m which satisfies D·m < L ≤ R < D·(m + 1). We should use this fact.. If holds, there exists an non-negative integer k which satisfies L + Mk ≤ D·m ≤ R + Mk. Let's write down.. D·m - R ≤ M·k ≤ D·m - L  - R ≤ M·k - D·m ≤  - L L ≤ D·m - M·k  ≤ RBecause , we can write the inequality as Therefore the minimum k among all possible solutions is equal to . We can easily calculate the smallest p using k. Then, what is the time complexity of calculating g(M, D, L, R)? Because 2D ≤ M (the 2D > M case is handled during step 3), the problem size becomes half, so it can be executed in .ConclusionFor each query, we have to consider both Case 1) and Case 2), with all possible directions. Both cases can be handled in , so the time complexity per query is , and it has really huge constant. Time: Memory: Implementation: 9330235",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/15488",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 500\\s*A"
          },
          "content_length": 19579
        }
      ],
      "code_examples": [
        {
          "title": "Good Bye 2014 - Codeforces - Code 1",
          "code": "division combined",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15465",
          "author": "jiangly"
        },
        {
          "title": "Good Bye 2014 - Codeforces - Code 2",
          "code": "3\n3 1 2\n011\n100\n100",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15465",
          "author": "jiangly"
        },
        {
          "title": "Good Bye 2014 - Codeforces - Code 3",
          "code": "3\n3 1 2\n011\n100\n100",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15465",
          "author": "jiangly"
        },
        {
          "title": "Good Bye 2014 - Codeforces - Code 4",
          "code": "(3,2) (1,2)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15465",
          "author": "jiangly"
        },
        {
          "title": "Good Bye 2014 - Codeforces - Code 5",
          "code": "7\n7 3 4 6 8 1 2\n0010000\n0001000\n0000100\n0000000\n0000001\n1000000\n0000000",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15465",
          "author": "jiangly"
        },
        {
          "title": "Good Bye 2014 - Codeforces - Code 6",
          "code": "7\n7 3 4 6 8 1 2\n0010000\n0001000\n0000100\n0000000\n0000001\n1000000\n0000000",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15465",
          "author": "jiangly"
        },
        {
          "title": "Good Bye 2014 - Codeforces - Code 7",
          "code": "1 3 2 6 4 7 8",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15465",
          "author": "jiangly"
        },
        {
          "title": "Good Bye 2014 - Codeforces - Code 8",
          "code": "2 3 4 6 7 1 8",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15465",
          "author": "jiangly"
        },
        {
          "title": "Good Bye 2014 - Codeforces - Code 9",
          "code": "3\n3 1 2\n011\n100\n100",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15465",
          "author": "jiangly"
        },
        {
          "title": "Good Bye 2014 - Codeforces - Code 10",
          "code": "3\n3 1 2\n011\n100\n100",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15465",
          "author": "jiangly"
        },
        {
          "title": "Good Bye 2014 - Codeforces - Code 11",
          "code": "5\n2 4 1 3 5\n00101\n00010\n10011\n01100\n10100",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15465",
          "author": "jiangly"
        },
        {
          "title": "Good Bye 2014 - Codeforces - Code 12",
          "code": "5\n2 4 1 3 5\n00101\n00010\n10011\n01100\n10100",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15465",
          "author": "jiangly"
        },
        {
          "title": "Good Bye 2014 - Codeforces - Code 13",
          "code": "__mingw_printf",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15465",
          "author": "jiangly"
        },
        {
          "title": "Good Bye 2014 Editorial - Codeforces - Code 1",
          "code": "3.0 / ((long long)n * (n-1))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15488",
          "author": "jiangly"
        },
        {
          "title": "Good Bye 2014 Editorial - Codeforces - Code 2",
          "code": "actually the sorting is o(q*log(q))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15488",
          "author": "jiangly"
        },
        {
          "title": "Good Bye 2014 Editorial - Codeforces - Code 3",
          "code": "actually the sorting is o(q*log(q))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15488",
          "author": "jiangly"
        },
        {
          "title": "Good Bye 2014 Editorial - Codeforces - Code 4",
          "code": "upper_bound",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15488",
          "author": "jiangly"
        },
        {
          "title": "Good Bye 2014 Editorial - Codeforces - Code 5",
          "code": "merge_group(i, j)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15488",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char *argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(3, 30000, \"n\");\n    inf.readSpace();\n    int t = inf.readInt(2, n, \"t\");\n    inf.readEoln();\n\n    for (int i = 1; i <= n - 1; i++) {\n        int ai = inf.readInt(1, n - i, (\"a_\" + to_string(i)).c_str());\n        if (i < n - 1)\n            inf.readSpace();\n        else\n            inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char *argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(3, 30000, \"n\");\n    inf.readSpace();\n    int t = inf.readInt(2, n, \"t\");\n    inf.readEoln();\n\n    for (int i = 1; i <= n - 1; i++) {\n        int ai = inf.readInt(1, n - i, (\"a_\" + to_string(i)).c_str());\n        if (i < n - 1)\n            inf.readSpace();\n        else\n            inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char *argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(3, 30000, \"n\");\n    inf.readSpace();\n    int t = inf.readInt(2, n, \"t\");\n    inf.readEoln();\n\n    for (int i = 1; i <= n - 1; i++) {\n        int ai = inf.readInt(1, n - i, (\"a_\" + to_string(i)).c_str());\n        if (i < n - 1)\n            inf.readSpace();\n        else\n            inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n#include <string>\r\n\r\nusing namespace std;\r\n\r\nconst string YES = \"YES\";\r\nconst string NO = \"NO\";\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"%s\", (\"multiple \" + YES + \"/\" + NO + \" (case insensitive)\").c_str());\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int index = 0, yesCount = 0, noCount = 0;\r\n    string pa;\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        index++;\r\n        string ja = upperCase(ans.readToken());\r\n        pa = upperCase(ouf.readToken());\r\n\r\n        if (ja != YES && ja != NO)\r\n            quitf(_fail, \"%s or %s expected in answer, but %s found [%d%s token]\",\r\n                  YES.c_str(), NO.c_str(), compress(ja).c_str(), index, englishEnding(index).c_str());\r\n\r\n        if (pa == YES)\r\n            yesCount++;\r\n        else if (pa == NO)\r\n            noCount++;\r\n        else\r\n            quitf(_pe, \"%s or %s expected, but %s found [%d%s token]\",\r\n                  YES.c_str(), NO.c_str(), compress(pa).c_str(), index, englishEnding(index).c_str());\r\n\r\n        if (ja != pa)\r\n            quitf(_wa, \"expected %s, found %s [%d%s token]\",\r\n                  compress(ja).c_str(), compress(pa).c_str(), index, englishEnding(index).c_str());\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n    while (!ans.seekEof()) {\r\n        ans.readToken();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n    while (!ouf.seekEof()) {\r\n        ouf.readToken();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              index + extraInAnsCount, index);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              index + extraInOufCount, index);\r\n\r\n    if (index == 0)\r\n        quitf(_ok, \"Empty output\");\r\n    else if (index == 1)\r\n        quitf(_ok, \"%s\", pa.c_str());\r\n    else\r\n        quitf(_ok, \"%d token(s): yes count is %d, no count is %d\", index, yesCount, noCount);\r\n\r\n    quitf(_fail, \"Impossible case\");\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int t = opt<int>(\"t\");\n    string type = opt<string>(\"type\", \"random\");\n\n    ensure(n >= 3 && n <= 30000);\n    ensure(t >= 2 && t <= n);\n\n    vector<int> a(n - 1);\n\n    if (type == \"random\") {\n        // Random a_i\n        for (int i = 0; i < n - 1; ++i) {\n            a[i] = rnd.next(1, n - i - 1);\n        }\n    } else if (type == \"yes\") {\n        // Ensure t is reachable from 1\n        for (int i = 0; i < n - 1; ++i) {\n            if (i < t - 1) {\n                a[i] = 1;\n            } else {\n                a[i] = rnd.next(1, n - i - 1);\n            }\n        }\n    } else if (type == \"no\") {\n        // Make t unreachable from 1 by trying to skip it\n        for (int i = 0; i < n - 1; ++i) {\n            if (i == t - 2) {\n                // At position i+1, prevent moving to t\n                if (2 <= n - i - 1) {\n                    a[i] = 2;\n                } else {\n                    a[i] = 1;\n                }\n            } else {\n                a[i] = min(2, n - i - 1);\n            }\n        }\n    } else if (type == \"ones\") {\n        // All a_i = 1\n        for (int i = 0; i < n - 1; ++i) {\n            a[i] = 1;\n        }\n    } else if (type == \"max_jump\") {\n        // All a_i = n - i - 1\n        for (int i = 0; i < n - 1; ++i) {\n            a[i] = n - i - 1;\n        }\n    } else {\n        // Default to random\n        for (int i = 0; i < n - 1; ++i) {\n            a[i] = rnd.next(1, n - i -1);\n        }\n    }\n\n    printf(\"%d %d\\n\", n, t);\n    for (int i = 0; i < n - 1; ++i) {\n        printf(\"%d\", a[i]);\n        if (i != n - 2) {\n            printf(\" \");\n        } else {\n            printf(\"\\n\");\n        }\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int t = opt<int>(\"t\");\n    string type = opt<string>(\"type\", \"random\");\n\n    ensure(n >= 3 && n <= 30000);\n    ensure(t >= 2 && t <= n);\n\n    vector<int> a(n - 1);\n\n    if (type == \"random\") {\n        // Random a_i\n        for (int i = 0; i < n - 1; ++i) {\n            a[i] = rnd.next(1, n - i - 1);\n        }\n    } else if (type == \"yes\") {\n        // Ensure t is reachable from 1\n        for (int i = 0; i < n - 1; ++i) {\n            if (i < t - 1) {\n                a[i] = 1;\n            } else {\n                a[i] = rnd.next(1, n - i - 1);\n            }\n        }\n    } else if (type == \"no\") {\n        // Make t unreachable from 1 by trying to skip it\n        for (int i = 0; i < n - 1; ++i) {\n            if (i == t - 2) {\n                // At position i+1, prevent moving to t\n                if (2 <= n - i - 1) {\n                    a[i] = 2;\n                } else {\n                    a[i] = 1;\n                }\n            } else {\n                a[i] = min(2, n - i - 1);\n            }\n        }\n    } else if (type == \"ones\") {\n        // All a_i = 1\n        for (int i = 0; i < n - 1; ++i) {\n            a[i] = 1;\n        }\n    } else if (type == \"max_jump\") {\n        // All a_i = n - i - 1\n        for (int i = 0; i < n - 1; ++i) {\n            a[i] = n - i - 1;\n        }\n    } else {\n        // Default to random\n        for (int i = 0; i < n - 1; ++i) {\n            a[i] = rnd.next(1, n - i -1);\n        }\n    }\n\n    printf(\"%d %d\\n\", n, t);\n    for (int i = 0; i < n - 1; ++i) {\n        printf(\"%d\", a[i]);\n        if (i != n - 2) {\n            printf(\" \");\n        } else {\n            printf(\"\\n\");\n        }\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 3 -t 3 -type yes\n./gen -n 3 -t 3 -type no\n\n./gen -n 10 -t 5 -type yes\n./gen -n 10 -t 5 -type no\n\n./gen -n 10 -t 10 -type ones\n\n./gen -n 100 -t 50 -type yes\n./gen -n 100 -t 50 -type no\n\n./gen -n 100 -t 100 -type max_jump\n\n./gen -n 1000 -t 500 -type yes\n./gen -n 1000 -t 500 -type no\n\n./gen -n 1000 -t 1000 -type random\n\n./gen -n 10000 -t 5000 -type yes\n./gen -n 10000 -t 5000 -type no\n\n./gen -n 10000 -t 10000 -type random\n\n./gen -n 30000 -t 29999 -type yes\n./gen -n 30000 -t 29999 -type no\n\n./gen -n 29999 -t 29999 -type max_jump\n\n./gen -n 30000 -t 2 -type ones\n\n./gen -n 30000 -t 30000 -type random\n\n./gen -n 30000 -t 15000 -type yes\n\n./gen -n 30000 -t 15000 -type no\n\n./gen -n 29999 -t 20000 -type random\n\n./gen -n 3 -t 2 -type no\n\n./gen -n 3 -t 2 -type yes\n\n./gen -n 1000 -t 2 -type ones\n./gen -n 1000 -t 3 -type max_jump\n./gen -n 1000 -t 999 -type random\n\n./gen -n 5000 -t 2500 -type yes\n./gen -n 5000 -t 2500 -type no\n\n./gen -n 5000 -t 4999 -type ones\n\n./gen -n 5000 -t 2501 -type random\n\n./gen -n 5000 -t 2 -type yes\n./gen -n 5000 -t 2 -type no\n\n./gen -n 100 -t 50 -type max_jump\n\n./gen -n 100 -t 99 -type ones\n\n./gen -n 100 -t 2 -type no\n\n./gen -n 3 -t 2 -type ones\n\n./gen -n 3 -t 3 -type max_jump\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:39:59.570267",
        "total_tutorials": 3,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "500/B",
      "title": "B. New Year Permutation",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains an integer n (1 ≤ n ≤ 300) — the size of the permutation p.The second line contains n space-separated integers p1, p2, ..., pn — the permutation p that user ainta has. Each integer between 1 and n occurs exactly once in the given permutation.Next n lines describe the matrix A. The i-th line contains n characters '0' or '1' and describes the i-th row of A. The j-th character of the i-th line Ai, j is the element on the intersection of the i-th row and the j-th column of A. It is guaranteed that, for all integers i, j where 1 ≤ i < j ≤ n, Ai, j = Aj, i holds. Also, for all integers i where 1 ≤ i ≤ n, Ai, i = 0 holds.",
      "output_spec": "OutputIn the first and only line, print n space-separated integers, describing the prettiest permutation that can be obtained.",
      "sample_tests": "ExamplesInputCopy75 2 4 3 6 7 10001001000000000000101000001000000000100001001000OutputCopy1 2 4 3 6 7 5InputCopy54 2 1 5 30010000011100100110101010OutputCopy1 2 3 4 5",
      "description": "B. New Year Permutation\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains an integer n (1 ≤ n ≤ 300) — the size of the permutation p.The second line contains n space-separated integers p1, p2, ..., pn — the permutation p that user ainta has. Each integer between 1 and n occurs exactly once in the given permutation.Next n lines describe the matrix A. The i-th line contains n characters '0' or '1' and describes the i-th row of A. The j-th character of the i-th line Ai, j is the element on the intersection of the i-th row and the j-th column of A. It is guaranteed that, for all integers i, j where 1 ≤ i < j ≤ n, Ai, j = Aj, i holds. Also, for all integers i where 1 ≤ i ≤ n, Ai, i = 0 holds.\n\nOutputIn the first and only line, print n space-separated integers, describing the prettiest permutation that can be obtained.\n\nInputCopy75 2 4 3 6 7 10001001000000000000101000001000000000100001001000OutputCopy1 2 4 3 6 7 5InputCopy54 2 1 5 30010000011100100110101010OutputCopy1 2 3 4 5\n\nInputCopy75 2 4 3 6 7 10001001000000000000101000001000000000100001001000\n\nOutputCopy1 2 4 3 6 7 5\n\nInputCopy54 2 1 5 30010000011100100110101010\n\nOutputCopy1 2 3 4 5\n\nNoteIn the first sample, the swap needed to obtain the prettiest permutation is: (p1, p7).In the second sample, the swaps needed to obtain the prettiest permutation is (p1, p3), (p4, p5), (p3, p4).   A permutation p is a sequence of integers p1, p2, ..., pn, consisting of n distinct positive integers, each of them doesn't exceed n. The i-th element of the permutation p is denoted as pi. The size of the permutation p is denoted as n.",
      "solutions": [
        {
          "title": "Good Bye 2014 - Codeforces",
          "content": "Hi, Codeforces!Welcome to the last Codeforces Round of 2014, Good Bye 2014! This round is very unusual; First, the round starts at December 30th, 18:00 MSK. Second, the round lasts for 2.5 hours. And lastly, the round will be division combined, which means Div1 contestants and Div2 contestants won't be separated.The problems are prepared by me (.o.) and Seunghyun Jo (ainta). This is our second round at Codeforces. Because our first round caused(?) the Black Day, we hope this round won't cause any errors like before :DThanks to Won-seok Yoo(ainu7), who tested our round and gave us comments about the problemset.We'd like to thank some people who were necessary to make this round: Maxim Akhmedov (Zlobober) gave us great help preparing the problems. Maria Belova (Delinur) translated problem statements in Russian. Mike Mirzayanov (MikeMirzayanov) made Codeforces and Polygon systems, which are really great. Let's give them an applause!The score distribution will be posted just before the round starts, as usual.We wish you all the best of luck. Happy New Year!UPD (2014-12-30 17:33:21) The score for each problem is going to be 500-1000-1000-1500-2750-2750-3500. Thanks to Xellos for giving us some ideas.UPD (2014-12-31 12:49:05) Round has finished, congratulations to the winners! tourist Petr rng_58 HYPERHYPERHYPERCUBELOVER subscriber Merkurev al13n mmaxio mexmans GlebsHP Also, thanks to Marcin_smu, who solved problem G after the contest for the first time.UPD(2014-12-31 12:51:08) Editorial is published. Currently, only A-F is available, but I will add G as soon as possible. Sorry for the late editorial.UPD(2015-01-02 21:30:44) I wrote the editorial of G. Sorry for the late update..",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/15465",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.6,
            "reason": "宽松匹配: 包含题目编号 500 和字母"
          },
          "content_length": 1702
        },
        {
          "title": "Good Bye 2014 Tutorial - Codeforces",
          "content": "500A — New Year TransportationIn this problem we are given a directed graph, and asked whether a particular vertex is reachable from vertex 1. It is possible to solve this by running a depth-first search starting from vertex 1.Since every vertex has at most one outgoing edge, it is possible to write the DFS as a simple loop. Some people used this to make very short submissions.500B — New Year PermutationImagine a graph with one vertex for each entry in the permutation, and edges between pairs of swappable entries. It is easy to see that no matter how many swaps we make, no entry can end up in a location that is not in its connected component. We can also show that within any connected component, we can achieve any rearrangement of the entries that we wish.Since we want to make the lexicographically smallest permutation, we should greedily rearrange the entries within each connected component so that they are in increasing order.N ≤ 300, so we are not concerned with runtime. One can determine the connected components using a number of standard algorithms (Floyd-Warshall, Union Find, etc.).500C — New Year Book ReadingConsider an arbitrary day d, on which we must read book b. Let d' be the last day before d on which book b was read (if there is no previous day, let d' =  - ∞). Observe that, on day d, we cannot avoid lifting all of the books read on any day between d' and d. If we add up all the weights of these required liftings, we will have a lower bound on the answer.This lower bound can be computed with two loops, in O(M2) time. We must be sure not to add a book's weight multiple times, if it was read multiple times in the interval (d', d).If we initially arrange the books in order of the first day on which they are read, we will achieve the described lower bound. So, we have our answer.500D — New Year Santa NetworkBy linearity of expectation, E(d(c1, c2) + d(c1, c3) + d(c2, c3)) = E(d(c1, c2)) + E(d(c1, c3)) + E(d(c2, c3)). By symmetry, those three values are all equal. So, we need only compute E(d(c1, c2)). We can multiply it by 3 to find the answer.Let us imagine that a random selection (c1, c2, c3) is made. We'll define a function f(j), for each edge j, so that f(j) = wj if j is part of the shortest path from c1 to c2, and f(j) = 0 otherwise. Observe that . Again by linearity, we have .We can write E(f(j)) = wj·P(j), where P(j) is the probability that edge j is included in the path from c1 to c2. If we compute P(j) for all j, we can then compute in O(N). Also, we can handle updates in O(1); if wj changes to w'j, we subtract wj·P(j) from the answer, and add w'j·P(j). So, let's figure out P(j) for each j. Any edge j, if removed from the tree, separates the graph into two separate connected components a and b. Edge j will be included in the shortest path from c1 to c2 if and only if one of them is in a, and the other is in b. So, we want the number of ways to select (c1, c2, c3) such that c1 and c2 are on opposite sides of edge j, divided by the total number of ways to select (c1, c2, c3). Let's have |a| and |b| denote the number of vertices in a and b, respectively. Then .To figure out |a| and |b| for each j, we can root the tree arbitrarily and compute the depth and subtree size for each vertex in O(N) time. Then for an edge j, if vj is the deeper vertex incident to j, we know one component has size equal to the subtree size of vj. For the other component, we use the fact that |b| = N - |a|. 500E — New Year DominoWhen domino i is knocked over, it covers the interval [pi, pi + li]. If we see a query (xj, yj), it is equivalent to the question \"If we knock over all dominoes with index , how much of the interval [pxj, pyj] won't be covered?\" We can modify that question a little more, to say that we knock over all dominoes with index i ≥ xj, without changing its answer. Now, consider knocking over the dominoes from right to left. As soon as we knock over domino i, we will immediately process all of the queries with xj = i, and record their answers. What we need is a data structure that supports two operations: \"cover range [pi, pi + li]\" (when we knock over a domino) and \"compute how much of the range [pxj, pyj] is not covered\" (when we wish to answer a query). This can be done using coordinate compression and a segment tree. It's worth noting there are a lot of other ways to solve this problem. The other tutorial uses a completely different approach. Also, the approach described here may be implemented using different data structures. For example, here is my implementation using BBSTs and a Binary Indexed Tree.500F — New Year ShoppingWe will use the standard dynamic programming approach for 0/1 knapsack. To summarize what it does for us, imagine we are given an ordered list of items (ci, hi). Let F(k, b) be the maximum happiness we can buy, if we consider only the first k items in the list, and have a budget of b. If K is the size of the list, and B is the maximum possible budget, we can compute F(k, b) for all possible k and b in O(KB) time.Let us sort all of the items by their display time. Suppose that we focus on the queries (aj, bj) with , for some particular t. Let A be a list of the items with display time in (t - P, t], and let B be a list of the items with display time in (t, t + P). Let both lists be sorted in order of display time.Every query with will have available to it some suffix of A, along with some prefix of B. We'll do a knapsack DP on the elements of A, in reverse order, and another on the elements of B, in normal order. Finally, to answer any query (aj, bj) with , we can consider all possible ways to split the budget bj between the items in A and the items in B, in linear time. For each possible way to split the budget, we need simply look up one value from each DP table to know the maximum possible happiness.If we perform the process above on t = 1, 1 + P, 1 + 2P, 1 + 3P, ... until t exceeds the maximum possible day D, we'll be able to answer all of the queries. Let's think about the runtime of this solution. For each t, the described process takes O(KB) time, where K is the number of items whose display time is in (t - P, t + P). Each object can only appear in up to two of these intervals. So, the overall runtime for all of the knapsack DP's we perform is O(nB). Computing the final answer takes O(B) per query, or O(qB) overall.500G — New Year RunningDon't know how to solve this yet. Maybe someone who is not gray can provide the solution. :)",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/15513",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 500\\s*B"
          },
          "content_length": 6486
        },
        {
          "title": "Good Bye 2014 Editorial - Codeforces",
          "content": "First of all, sorry for the late editorial. I was too exhausted and immediately went to bed after the round finished, and didn't write the editorial.There are many pictures in this editorial, to cover up my poor English skills! If you have detected any errors or have questions, feel free to ask questions by comments. Unfortunately, the authors only know English, so we can't answer you if you write comments in Russian.500A - Транспорт на Новый годLet's assume that I am in the cell i (1 ≤ i ≤ n). If i ≤ n - 1, I have two choices: to stay at cell i, or to go to cell (i + ai). If i = t, we are at the target cell, so I should print \"YES\" and terminate. If i > t, I cannot go to cell t because I can't use the portal backwards, so one should print \"NO\" and terminate. Otherwise, I must go to cell (i + ai).Using this method, I visit each cell at most once, and there are n cells, so the problem can be solved in linear time.What is test 13?There are 9 pretests in this problem. There are no test where n = t holds in pretests. Many people didn't handle this case, and got hacked or got Wrong Answer on test 13. Time: O(n) Memory: O(n) (maybe O(1)) Implementation: 9335683 500B - Новогодняя перестановкаIt seems that many contestants were confused by the statement, so let me clarify it first. Given a permutation p1, p2, ..., pn and a n × n-sized binary matrix A, the problem asks us to find the lexicographically minimum permutation which can be achieved by swapping two distinct elements pi and pj where the condition Ai, j = 1 holds. (From the statement, permutation A is prettier than permutation B if and only if A is lexicographically less than B.)Let's think matrix A as an adjacency matrix of a undirected unweighted graph.If two vertices i and j are in the same component (in other words, connected by some edges), the values of pi and pj can be swapped, using a method similar to bubble sort. Look at the picture below for easy understanding.Because all the two distinct vertices in the same component can be swapped, the vertices in the same component can be sorted. In conclusion, we can solve the problem by the following procedure. Find all the connected components. For each component, sort the elements in the component. Print the resulting permutation. The size limit is quite small, so one can use any algorithm (DFS/BFS/..) for as many times as you want. Time: O(n2) — because of the graph traversal. O(n3) is okay because of small constraints. Memory: O(n2) Implementation: 9335689 (.o.) What is test 15? There are too many wrong answers in this case.Actually, I made the pretests very weak in order to make many hacks. As mentioned in the Hack me! post by kostka, just swapping the elements greedily could pass the pretests easily. There were 14 pretests, and I made test 15 an counter-example of such algorithm in order to reduce judging time, and it seems that most of the wrong submissions failed in this test case :D500C - В Новый год --- с книгой!In order to calculate the minimum possible lifted weight, we should find the initial stack first. Let's find the positions one by one. First, let's decide the position of book b1. After day 1, book b1 will be on the top of the stack, regardless of the order of the initial stack. Therefore, in order to minimize the lifted weight during day 1, book b1 must be on the top of the initial stack. (so actually, in day 1, Jaehyun won't lift any book) Next, let's decide the position of book b2. (assume that b1 ≠ b2 for simplicity) Currently, b1 is on the top of the stack, and it cannot be changed because of the procedure. Therefore, in order to minimize the lifted weight during day 2, book b2 must be immediately below book b1. Considering this, we can find the optimal strategy to create the initial stack: Scan b1, b2, ..., bm step by step. Let's assume that I am handling bi now. If bi has appeared before (formally, if ), erase bi from the sequence. Otherwise, leave bi. The resulting sequence will be the optimal stack.You should note that it is not necessary for Jaehyun to read all the books during 2015, which means the size of the resulting sequence may be smaller than n. The books which doesn't appear in the resulting sequence must be in the bottom of the initial stack (obviously). However, this problem doesn't require us to print the initial stack, so it turned out not to be important. In conclusion, finding the initial stack takes O(n + m) time.After finding the initial stack, we can simulate the procedure given in the statement naively. It will take O(nm) time. Time: O(nm) Memory: O(n + m) Implementation: 9335694 (.o.) 500D - Новогоднее взаимодействие Санта-КлаусовThe problem asks us to calculate the value ofLet's write it down..So, we need to calculate the value of . I'll denote the sum as S. How should we calculate this?For simplicity, I'll set node 1 as the root of the tree. Let's focus on an edge e, connecting two vertices u and p. See the picture below.Set A is a set of vertices in the subtree of vertex u, and set B is a set of vertices which is not in the subtree of vertex u. So, is the set of vertices in the tree, and is empty.For all pairs of two vertices (x, y) where the condition and holds, the shortest path between x and y contains edge e. There are size(A) × size(B) such pairs. So, edge e increases the sum S by 2 × le × size(A) × size(B). (because d(x, y) and d(y, x) both contributes to S)size(A) (the size of the subtree whose root is u) can be calculated by dynamic programming in trees, which is well known. size(B) equals to N - size(A). So, for each edge e, we can pre-calculate how many times does this edge contributes to the total sum. Let's define t(e) = size(A) × size(B), (A and B is mentioned above). If the length of a certain road e decreases by d, S will decrease by t(e) × d. So we can answer each query. Time: O(n) (pre-calculation) + O(q) (query) Memory: O(n) (O(n + q) is okay too) Implementation: 9335695 (.o.) Something about precision errorBecause of the tight constraints, the total sum of d(a, b) + d(b, c) + d(c, a) (it is equal to S × (n - 2)) can be so large that it can't be saved in long long(64-bit integer) type. Some contestants didn't handle this and got WA. However, there are some contestants who saved this value divided by n × (n - 1) × (n - 2) in double type. double has 52 bits to store exact value, so it isn't enough. But because we allow 10 - 6 precision error, it seems to have been got accepted.What if we allowed the length of the road could become 0? Then the precision error gets much more bigger, and the solution prints something that is far from the expected value (for example, negative value). ainu7 discovered this effect and suggested to apply this, but we didn't because it was hard to fix the statement..Why does the road length decreases? It doesn't matter even if increases.It's because of the weird legend. It is hard to explain, \"People repairs a certain road per year, and its length may be increased or decreased.\" fluently for me..500E - Новогоднее доминоFrom the statement, it is clear that, when domino i falls to the right, it makes domino j also fall if and only if pi < pj ≤ pi + li.For each domino i, let's calculate the rightmost position of the fallen dominoes R[i] when we initially pushed domino i. From the definition, . This can be calculated by using a segment tree or using a stack, in decreasing order of i (from right to left). After that, we define U[i] as the smallest j where R[i] < pj holds. (In other words, the smallest j where domino j is not affected by pushing domino i)Now, the problem becomes: Calculate P[U[xi]] - R[xi] + P[U[U[xi]]] - R[U[xi]] + ..., until U[xi] ≤ yi. Because i < U[i], this task can be solved by precalculating 'jumps' of 2something times, using the method described in here. You must read the \"Another easy solution in <O(N logN, O(logN)>\" part..Formally, let's define Un + 1[k] = U[Un[k]] and Sn + 1[k] = Sn[k] + (P[Un + 1[k]] - R[Un[k]]). So, Sn[k] means the sum of domino length extensions when we initially push domino i and we prolonged the length exactly n times. U2i + 1[k] = U2i[U2i[k]], and S2i + 1[k] = S2i[k] + S2i[U2i[k]] holds. (If you don't understand this part, I suggest you to read the article linked above) Time : or . Memory : Implementation: 9335698 (.o.) We would like to know whether there is a linear offline solution or not. 500F - Новогодние покупки The i-th item is available during [ti, ti + p - 1]. In other words, at time T, item i is available if and only if ti ≤ T ≤ ti + p - 1. This can be re-written as (ti ≤ T and T - p + 1 ≤ ti), which is T - p + 1 ≤ ti ≤ T. With this observation, we can transform the item's purchasable range into a dot, and the candidate's visit time into a range: From now on, item i is only available at time ti. and each candidate pair (aj, bj) means that I can visit the store during [aj - p + 1, aj], and my budget is bj dollars at that visit. This transformation makes the problem easier to solve.Each red circled point denotes an item which is sold at that time, and each black interval denotes a candidate. Let's only consider the intervals which passes time T. All the intervals' length is exactly p, so the left bound of the interval is (T - p) and the right bound of the interval is (T + p). For each interval, we'd like to solve the 0/1 knapsack algorithm with the items that the interval contains. How can we do that effectively? There is an important fact that I've described above: all the interval passes time T. Therefore, the interval [aj - p + 1, aj] can be split into two intervals: [aj - p + 1, T - 1] and [T, aj].So, let's solve the 0/1 knapsack problem for all intervals [x, T - 1] (T - p ≤ x ≤ T - 1) and [T, y] (T ≤ y ≤ T + p). Because one of the endpoints is fixed, one can run a standard dynamic programming algorithm. Therefore, the time needed in precalculation is O(S × W), where S is the number of items where the condition holds.Let's define h(I, b), as the maximum happiness I can obtain by buying the items where the condition holds, using at most b dollars. For each candidate (aj, bj), we have to calculate h([aj - p + 1, aj], bj), which is equal to max0 ≤ k ≤ b{h([aj - p + 1, T - 1], k) + h([T, aj], b - k)}. So it takes O(bj) = O(W) time to solve each query.The only question left is: How should we choose the value of T? We have two facts. (1) The length of intervals is exactly p. (2) The algorithm covers intervals which passes time T. Therefore, to cover all the intervals given in the input, we should let T be p, 2p, 3p, 4p, ... (of course, one by one), and run the algorithm described above.Then, what is the total time complexity? Think of intervals [0, 2p], [p, 3p], [2p, 4p], [3p, 5p], .... For each point, there will be at most two intervals which contains the point. Therefore, each item is reflected in the pre-calculation at most twice, so the time needed to precalculate is O(n × W). The time needed to solve each query is O(bj), and the answer of the query is calculated at most once. Therefore, the time needed to answer all the queries is O(q × W). Time : O((n + q) × W). Memory : O(n × W) Implementations: 9335699 (ainta), 9335703 (ainu7) , 9335710 (.o., using a different approach), 9335709 (.o., using a divide and conquer approach) Divide and Conquer approachLet's assume that t1 ≤ t2 ≤ ... ≤ tn. We can easily know that at time T, the indexes of all the available items forms a segment [l, r]. (in other words, item l, item l + 1, ..., item r - 1, item r is available) We can use this fact to solve all the queries. Let's assume that item lj, item lj + 1, ..., item rj - 1, item rj is available at time aj.Define a function solve(L, R). This function calculates the answer for queries where the condition L ≤ lj ≤ rj ≤ R holds. Let's assume that L < R holds. (In the case L ≥ R, the answer can be calculated easily) Let . Call solve(L, M) and solve(M + 1, R). After that, the queries needed to be calculated, satisfies the condition lj ≤ M < rj, which means all the intervals(queries) passes item M. Now, to calculate the answer for such queries, we can use the method described at the dynamic programming approach.The time complexity is , because and the answer of the queries can be calculated in O(bj) per query. Time : . Memory : O(n × W) Implementation: 9335709 Unfortunately, this approach is offline, because of the memory. Is there any available online approach using divide and conquer?Blocking the divide and conquer solutionI tried my best to block divide and conquer solutions, but failed. It seems that many participants solved the problem with divide and conquer approach. My approach takes time, and it gets accepted in 546ms.500G - Новогодний забегBefore starting the editorial, I'd like to give a big applause to Marcin_smu, who solved the problem for the first time!Warning: The editorial is very long and has many mistakes. There are lots of lots of mistakes.. Keep calm, and please tell me by comments, if you discovered any errors.This problem can be solved by an online algorithm. Let's focus on a single query (u, v, x, y). This means that JH runs between u and v, and JY runs between x and y.Just like when we solve many problems with undirected trees, let vertex 1 be the root of the tree. Also, we will assume that they won't stop after when they meet, but they will continue running, in order to explain easily.Some definitions: Path (a, b): the shortest path between vertex a and vertex b. d(a, b): the length of Path (a, b). LCA(a, b): the lowest common ancestor of vertex a and vertex b. Finding the common path of two pathsIf there is no common vertex between Path (u, v) and Path (x, y), the answer will be obviously  - 1. So, let's find the common vertices first. Because the path between two vertices is always unique, the common vertices also form a path. So, I'll denote the path of the common vertices as Path (c1, c2). c1 and c2 may be equal to: u, v, x, y, and even each other.The possible endpoints are P1 = LCA(u, v), P2 = LCA(x, y), P3 = LCA(u, x), P4 = LCA(u, y), P5 = LCA(v, x), and P6 = LCA(v, y). Figure out by drawing some examples. (some of you might think it's obvious :D)See the pictures above, and make your own criteria to check whether the two paths intersects :DA small hint. Let's assume that we already know, that a vertex a lies on path (x, y). If a lies on path (u, v), a is a common vertex of two paths. What if a is guaranteed to be an end point of the common path?Additional definitions Let's denote JH's running course is: . Then, there are two possible courses for JY: and ). fJH : the time needed to run the course . fJY : the time needed to run the course . t1 : the first time when JH passes vertex c1, moving towards c2. t2 : the first time when JH passes vertex c2, moving towards c1. t3 : the first time when JY passes vertex c1, moving towards c2. t4 : the first time when JY passes vertex c2, moving towards c1. Case 1) When JH and JY meets while moving in the same directionObviously, they must meet at vertex c1 or vertex c2 for the first time. Without loss of generality, let's assume that they meet at vertex c1. In this case, both of them is moving towards vertex c2. (You can use the method similarly for c2) Let's assume that JH and JY meets at time T. Because the movements of both runners are periodic, T must satisfy the conditions below: Among possible T-s, we have to calculate the smallest value. How should we do? From the first condition, we can let T = fJH × p + t1, where p is a non-negative integer. With this, we can write the second condition as: . In conclusion, we have to find the smallest p which satisfies the condition Using the Extended Euclidean algorithm is enough to calculate the minimum p. With p, we can easily calculate the minimum T, which is the first time they meet. If there is no such p, they doesn't meet forever, so the answer is  - 1.Case 2) When JH and JY meets while moving in the opposite directionIn this case, they will meet at a vertex lying on Path (c1, c2). Without loss of generality, let's assume that JH is going from c1 to c2, and JY is going from c2 to c1.I'll assume that JH and JY meets at time T. [1] Let's see how JH moves: For all non-negative integer p, At time fJH × p + t1, he is at vertex c1, moving towards c2. At time fJH × p + t1 + d(c1, c2), he is at vertex c2. Therefore, when fJH × p + t1 ≤  (current time)  ≤ fJH × p + t1 + d(c1, c2), JH is on Path (c1, c2). So, T must satisfy the condition: fJH × p + t1 ≤ T ≤ fJH × p + t1 + d(c1, c2) [2] Let's see how JY moves: Similar to JH, for all non-negative integer q, At time fJY × q + t4, he is at vertex c2, moving towards c1. At time fJY × q + t4 + d(c2, c1), he is at vertex c1. Therefore, when fJY × q + t4 ≤  (current time)  ≤ fJY × q + t4 + d(c2, c1), JY is on Path (c2, c1). So, T must satisfy the condition: fJY × q + t4 ≤ T ≤ fJY × q + t4 + d(c1, c2) [3] These two conditions are not enough, because in this case, they can meet on an edge, but they cannot meet on a vertex.We'd like to know when do they meet on a vertex, like the picture below.As you see from the picture above, in this case, the condition d(c1, a) + d(a, c2) = d(c1, c2) holds. If this picture was taken at time s, this condition can be written as: {s - (fJH × p + t1)} + {s - (fJY × q + t4)} = d(c1, c2) 2s - (fJH × p + fJY × q) - (t1 + t4) = d(c1, c2) s = {d(c1, c2) + (fJH × p + fJY × q) + (t1 + t4)} / 2 Because JH and JY both travel their path back and forth, fJH and fJY are all even. Therefore, in order to make s an integer, d(c1, c2) + t1 + t4 must be even. This can be written as [4] Merging [1], [2] and [3], we can conclude that if these two conditions holds, max{fJH × p + t1, fJY × q + t4} ≤ min{fJH × p + t1 + d(c1, c2), fJY × p + t4 + d(c1, c2)} JH and JY meets on a certain vertex lying on path (c1, c2). The first condition can be easily checked, so let's focus on the second condition. The second condition holds if and only if: fJY × q + t4 - t1 - d ≤ fJH × p ≤ fJY × q + t4 - t1 + d You can check this by changing \"fJH × p\" to the lower bound and the upper bound of the inequality. Therefore, the problem is to find the smallest p which satisfies the condition above.Let's define a function g(M, D, L, R), where M, D, L, R are all non-negative integers. The function returns the smallest non-negative integer m which satisfies . This function can be implemented as follows. If L = 0, g(M, D, L, R) = 0. (because L = 0 ≤ D·0) If , it is \"obvious\" that there is no solution. If 2D > M, g(M, D, L, R) = g(M, M - D, M - R, M - L). If there exists an non-negative integer m which satisfies L ≤ D·m ≤ R (without modular condition), g(M, D, L, R) = m. Obviously, we should take the smallest m. Otherwise, there exists an integer m which satisfies D·m < L ≤ R < D·(m + 1). We should use this fact.. If holds, there exists an non-negative integer k which satisfies L + Mk ≤ D·m ≤ R + Mk. Let's write down.. D·m - R ≤ M·k ≤ D·m - L  - R ≤ M·k - D·m ≤  - L L ≤ D·m - M·k  ≤ RBecause , we can write the inequality as Therefore the minimum k among all possible solutions is equal to . We can easily calculate the smallest p using k. Then, what is the time complexity of calculating g(M, D, L, R)? Because 2D ≤ M (the 2D > M case is handled during step 3), the problem size becomes half, so it can be executed in .ConclusionFor each query, we have to consider both Case 1) and Case 2), with all possible directions. Both cases can be handled in , so the time complexity per query is , and it has really huge constant. Time: Memory: Implementation: 9330235",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/15488",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 500\\s*B"
          },
          "content_length": 19579
        }
      ],
      "code_examples": [
        {
          "title": "Good Bye 2014 - Codeforces - Code 1",
          "code": "division combined",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15465",
          "author": "jiangly"
        },
        {
          "title": "Good Bye 2014 - Codeforces - Code 2",
          "code": "3\n3 1 2\n011\n100\n100",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15465",
          "author": "jiangly"
        },
        {
          "title": "Good Bye 2014 - Codeforces - Code 3",
          "code": "3\n3 1 2\n011\n100\n100",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15465",
          "author": "jiangly"
        },
        {
          "title": "Good Bye 2014 - Codeforces - Code 4",
          "code": "(3,2) (1,2)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15465",
          "author": "jiangly"
        },
        {
          "title": "Good Bye 2014 - Codeforces - Code 5",
          "code": "7\n7 3 4 6 8 1 2\n0010000\n0001000\n0000100\n0000000\n0000001\n1000000\n0000000",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15465",
          "author": "jiangly"
        },
        {
          "title": "Good Bye 2014 - Codeforces - Code 6",
          "code": "7\n7 3 4 6 8 1 2\n0010000\n0001000\n0000100\n0000000\n0000001\n1000000\n0000000",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15465",
          "author": "jiangly"
        },
        {
          "title": "Good Bye 2014 - Codeforces - Code 7",
          "code": "1 3 2 6 4 7 8",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15465",
          "author": "jiangly"
        },
        {
          "title": "Good Bye 2014 - Codeforces - Code 8",
          "code": "2 3 4 6 7 1 8",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15465",
          "author": "jiangly"
        },
        {
          "title": "Good Bye 2014 - Codeforces - Code 9",
          "code": "3\n3 1 2\n011\n100\n100",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15465",
          "author": "jiangly"
        },
        {
          "title": "Good Bye 2014 - Codeforces - Code 10",
          "code": "3\n3 1 2\n011\n100\n100",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15465",
          "author": "jiangly"
        },
        {
          "title": "Good Bye 2014 - Codeforces - Code 11",
          "code": "5\n2 4 1 3 5\n00101\n00010\n10011\n01100\n10100",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15465",
          "author": "jiangly"
        },
        {
          "title": "Good Bye 2014 - Codeforces - Code 12",
          "code": "5\n2 4 1 3 5\n00101\n00010\n10011\n01100\n10100",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15465",
          "author": "jiangly"
        },
        {
          "title": "Good Bye 2014 - Codeforces - Code 13",
          "code": "__mingw_printf",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15465",
          "author": "jiangly"
        },
        {
          "title": "Good Bye 2014 Editorial - Codeforces - Code 1",
          "code": "3.0 / ((long long)n * (n-1))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15488",
          "author": "jiangly"
        },
        {
          "title": "Good Bye 2014 Editorial - Codeforces - Code 2",
          "code": "actually the sorting is o(q*log(q))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15488",
          "author": "jiangly"
        },
        {
          "title": "Good Bye 2014 Editorial - Codeforces - Code 3",
          "code": "actually the sorting is o(q*log(q))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15488",
          "author": "jiangly"
        },
        {
          "title": "Good Bye 2014 Editorial - Codeforces - Code 4",
          "code": "upper_bound",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15488",
          "author": "jiangly"
        },
        {
          "title": "Good Bye 2014 Editorial - Codeforces - Code 5",
          "code": "merge_group(i, j)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15488",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 300, \"n\");\n    inf.readEoln();\n    vector<int> p = inf.readInts(n, 1, n, \"p\");\n    inf.readEoln();\n    // Ensure p is a permutation\n    vector<bool> seen(n + 1, false);\n    for (int i = 0; i < n; ++i) {\n        ensuref(!seen[p[i]], \"p must be a permutation, value %d occurs more than once at position %d\", p[i], i + 1);\n        seen[p[i]] = true;\n    }\n    vector<string> A;\n    for (int i = 0; i < n; ++i) {\n        string s = inf.readLine(format(\"[01]{%d}\", n), format(\"A[%d]\", i + 1));\n        A.push_back(s);\n    }\n    // Check that Ai,i = 0\n    for (int i = 0; i < n; ++i) {\n        ensuref(A[i][i] == '0', \"A[%d][%d] must be 0\", i + 1, i + 1);\n    }\n    // Check that A is symmetric\n    for (int i = 0; i < n; ++i)\n        for (int j = i + 1; j < n; ++j) {\n            ensuref(A[i][j] == A[j][i], \"A must be symmetric, but A[%d][%d]=%c and A[%d][%d]=%c\", i + 1, j + 1, A[i][j], j + 1, i + 1, A[j][i]);\n        }\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 300, \"n\");\n    inf.readEoln();\n    vector<int> p = inf.readInts(n, 1, n, \"p\");\n    inf.readEoln();\n    // Ensure p is a permutation\n    vector<bool> seen(n + 1, false);\n    for (int i = 0; i < n; ++i) {\n        ensuref(!seen[p[i]], \"p must be a permutation, value %d occurs more than once at position %d\", p[i], i + 1);\n        seen[p[i]] = true;\n    }\n    vector<string> A;\n    for (int i = 0; i < n; ++i) {\n        string s = inf.readLine(format(\"[01]{%d}\", n), format(\"A[%d]\", i + 1));\n        A.push_back(s);\n    }\n    // Check that Ai,i = 0\n    for (int i = 0; i < n; ++i) {\n        ensuref(A[i][i] == '0', \"A[%d][%d] must be 0\", i + 1, i + 1);\n    }\n    // Check that A is symmetric\n    for (int i = 0; i < n; ++i)\n        for (int j = i + 1; j < n; ++j) {\n            ensuref(A[i][j] == A[j][i], \"A must be symmetric, but A[%d][%d]=%c and A[%d][%d]=%c\", i + 1, j + 1, A[i][j], j + 1, i + 1, A[j][i]);\n        }\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 300, \"n\");\n    inf.readEoln();\n    vector<int> p = inf.readInts(n, 1, n, \"p\");\n    inf.readEoln();\n    // Ensure p is a permutation\n    vector<bool> seen(n + 1, false);\n    for (int i = 0; i < n; ++i) {\n        ensuref(!seen[p[i]], \"p must be a permutation, value %d occurs more than once at position %d\", p[i], i + 1);\n        seen[p[i]] = true;\n    }\n    vector<string> A;\n    for (int i = 0; i < n; ++i) {\n        string s = inf.readLine(format(\"[01]{%d}\", n), format(\"A[%d]\", i + 1));\n        A.push_back(s);\n    }\n    // Check that Ai,i = 0\n    for (int i = 0; i < n; ++i) {\n        ensuref(A[i][i] == '0', \"A[%d][%d] must be 0\", i + 1, i + 1);\n    }\n    // Check that A is symmetric\n    for (int i = 0; i < n; ++i)\n        for (int j = i + 1; j < n; ++j) {\n            ensuref(A[i][j] == A[j][i], \"A must be symmetric, but A[%d][%d]=%c and A[%d][%d]=%c\", i + 1, j + 1, A[i][j], j + 1, i + 1, A[j][i]);\n        }\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> p(n);\n    for (int i = 0; i < n; ++i)\n        p[i] = i + 1; // Initialize p as 1..n\n\n    vector<string> A(n, string(n, '0'));\n\n    if (type == \"identity\") {\n        // p remains sorted\n    } else if (type == \"reversed\") {\n        reverse(p.begin(), p.end());\n    } else if (type == \"shuffled\") {\n        shuffle(p.begin(), p.end());\n    } else if (type == \"full\") {\n        // All swaps are allowed\n        for (int i = 0; i < n; ++i)\n            for (int j = i+1; j < n; ++j)\n                A[i][j] = A[j][i] = '1';\n        shuffle(p.begin(), p.end());\n    } else if (type == \"none\") {\n        // No swaps allowed; A is all zeros\n        shuffle(p.begin(), p.end());\n    } else if (type == \"chain\") {\n        // Can swap with adjacent positions\n        for (int i = 0; i < n-1; ++i) {\n            A[i][i+1] = A[i+1][i] = '1';\n        }\n        shuffle(p.begin(), p.end());\n    } else if (type == \"random\") {\n        // Random swaps\n        double density = opt<double>(\"density\", 0.5); // Proportion of allowed swaps\n        for (int i = 0; i < n; ++i)\n            for (int j = i+1; j < n; ++j)\n                if (rnd.next(1.0) < density)\n                    A[i][j] = A[j][i] = '1';\n        shuffle(p.begin(), p.end());\n    } else if (type == \"components\") {\n        // Generate k connected components\n        int k = opt<int>(\"k\", 1); // Number of components\n        // Assign positions to components\n        vector<int> component(n);\n        for (int i = 0; i < n; ++i)\n            component[i] = i * k / n;\n        // Within each component, make it fully connected\n        for (int i = 0; i < n; ++i)\n            for (int j = i+1; j < n; ++j)\n                if (component[i] == component[j])\n                    A[i][j] = A[j][i] = '1';\n        // Shuffle p within components\n        vector<vector<int>> positions(k);\n        for (int i = 0; i < n; ++i)\n            positions[component[i]].push_back(i);\n        for (int c = 0; c < k; ++c) {\n            vector<int> indices = positions[c];\n            vector<int> values;\n            for (int idx : indices)\n                values.push_back(p[idx]);\n            shuffle(values.begin(), values.end());\n            for (size_t i = 0; i < indices.size(); ++i)\n                p[indices[i]] = values[i];\n        }\n    } else if (type == \"inverse\") {\n        // p is in reverse order, A only allows swaps between distant positions\n        for (int i = 0; i < n; ++i)\n            p[i] = n - i;\n        for (int i = 0; i < n; ++i)\n            for (int j = i+1; j < n; ++j)\n                if (abs(i - j) >= n / 2)\n                    A[i][j] = A[j][i] = '1';\n    } else {\n        // Default: random\n        // Random swaps\n        double density = opt<double>(\"density\", 0.5); // Proportion of allowed swaps\n        for (int i = 0; i < n; ++i)\n            for (int j = i+1; j < n; ++j)\n                if (rnd.next(1.0) < density)\n                    A[i][j] = A[j][i] = '1';\n        shuffle(p.begin(), p.end());\n    }\n\n    // Output n\n    printf(\"%d\\n\", n);\n    // Output permutation p\n    for (int i = 0; i < n; ++i) {\n        if (i > 0) printf(\" \");\n        printf(\"%d\", p[i]);\n    }\n    printf(\"\\n\");\n    // Output matrix A\n    for (int i = 0; i < n; ++i)\n        printf(\"%s\\n\", A[i].c_str());\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> p(n);\n    for (int i = 0; i < n; ++i)\n        p[i] = i + 1; // Initialize p as 1..n\n\n    vector<string> A(n, string(n, '0'));\n\n    if (type == \"identity\") {\n        // p remains sorted\n    } else if (type == \"reversed\") {\n        reverse(p.begin(), p.end());\n    } else if (type == \"shuffled\") {\n        shuffle(p.begin(), p.end());\n    } else if (type == \"full\") {\n        // All swaps are allowed\n        for (int i = 0; i < n; ++i)\n            for (int j = i+1; j < n; ++j)\n                A[i][j] = A[j][i] = '1';\n        shuffle(p.begin(), p.end());\n    } else if (type == \"none\") {\n        // No swaps allowed; A is all zeros\n        shuffle(p.begin(), p.end());\n    } else if (type == \"chain\") {\n        // Can swap with adjacent positions\n        for (int i = 0; i < n-1; ++i) {\n            A[i][i+1] = A[i+1][i] = '1';\n        }\n        shuffle(p.begin(), p.end());\n    } else if (type == \"random\") {\n        // Random swaps\n        double density = opt<double>(\"density\", 0.5); // Proportion of allowed swaps\n        for (int i = 0; i < n; ++i)\n            for (int j = i+1; j < n; ++j)\n                if (rnd.next(1.0) < density)\n                    A[i][j] = A[j][i] = '1';\n        shuffle(p.begin(), p.end());\n    } else if (type == \"components\") {\n        // Generate k connected components\n        int k = opt<int>(\"k\", 1); // Number of components\n        // Assign positions to components\n        vector<int> component(n);\n        for (int i = 0; i < n; ++i)\n            component[i] = i * k / n;\n        // Within each component, make it fully connected\n        for (int i = 0; i < n; ++i)\n            for (int j = i+1; j < n; ++j)\n                if (component[i] == component[j])\n                    A[i][j] = A[j][i] = '1';\n        // Shuffle p within components\n        vector<vector<int>> positions(k);\n        for (int i = 0; i < n; ++i)\n            positions[component[i]].push_back(i);\n        for (int c = 0; c < k; ++c) {\n            vector<int> indices = positions[c];\n            vector<int> values;\n            for (int idx : indices)\n                values.push_back(p[idx]);\n            shuffle(values.begin(), values.end());\n            for (size_t i = 0; i < indices.size(); ++i)\n                p[indices[i]] = values[i];\n        }\n    } else if (type == \"inverse\") {\n        // p is in reverse order, A only allows swaps between distant positions\n        for (int i = 0; i < n; ++i)\n            p[i] = n - i;\n        for (int i = 0; i < n; ++i)\n            for (int j = i+1; j < n; ++j)\n                if (abs(i - j) >= n / 2)\n                    A[i][j] = A[j][i] = '1';\n    } else {\n        // Default: random\n        // Random swaps\n        double density = opt<double>(\"density\", 0.5); // Proportion of allowed swaps\n        for (int i = 0; i < n; ++i)\n            for (int j = i+1; j < n; ++j)\n                if (rnd.next(1.0) < density)\n                    A[i][j] = A[j][i] = '1';\n        shuffle(p.begin(), p.end());\n    }\n\n    // Output n\n    printf(\"%d\\n\", n);\n    // Output permutation p\n    for (int i = 0; i < n; ++i) {\n        if (i > 0) printf(\" \");\n        printf(\"%d\", p[i]);\n    }\n    printf(\"\\n\");\n    // Output matrix A\n    for (int i = 0; i < n; ++i)\n        printf(\"%s\\n\", A[i].c_str());\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -type identity\n./gen -n 1 -type none\n\n./gen -n 5 -type full\n./gen -n 5 -type none\n./gen -n 5 -type chain\n./gen -n 5 -type random -density 0.2\n./gen -n 5 -type components -k 2\n./gen -n 5 -type inverse\n\n./gen -n 10 -type full\n./gen -n 10 -type none\n./gen -n 10 -type chain\n./gen -n 10 -type random -density 0.5\n./gen -n 10 -type components -k 3\n./gen -n 10 -type inverse\n\n./gen -n 50 -type full\n./gen -n 50 -type none\n./gen -n 50 -type chain\n./gen -n 50 -type random -density 0.3\n./gen -n 50 -type components -k 5\n./gen -n 50 -type inverse\n\n./gen -n 100 -type full\n./gen -n 100 -type none\n./gen -n 100 -type chain\n./gen -n 100 -type random -density 0.1\n./gen -n 100 -type components -k 10\n./gen -n 100 -type inverse\n\n./gen -n 200 -type full\n./gen -n 200 -type none\n./gen -n 200 -type chain\n./gen -n 200 -type random -density 0.05\n./gen -n 200 -type components -k 20\n./gen -n 200 -type inverse\n\n./gen -n 300 -type full\n./gen -n 300 -type none\n./gen -n 300 -type chain\n./gen -n 300 -type random -density 0.01\n./gen -n 300 -type components -k 30\n./gen -n 300 -type inverse\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:40:01.340539",
        "total_tutorials": 3,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "500/C",
      "title": "C. New Year Book Reading",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains two space-separated integers n (2 ≤ n ≤ 500) and m (1 ≤ m ≤ 1000) — the number of books, and the number of days for which Jaehyun would read books.The second line contains n space-separated integers w1, w2, ..., wn (1 ≤ wi ≤ 100) — the weight of each book.The third line contains m space separated integers b1, b2, ..., bm (1 ≤ bj ≤ n) — the order of books that he would read. Note that he can read the same book more than once.",
      "output_spec": "OutputPrint the minimum total weight of books he should lift, which can be achieved by rearranging the order of stacked books.",
      "sample_tests": "ExamplesInputCopy3 51 2 31 3 2 3 1OutputCopy12",
      "description": "C. New Year Book Reading\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains two space-separated integers n (2 ≤ n ≤ 500) and m (1 ≤ m ≤ 1000) — the number of books, and the number of days for which Jaehyun would read books.The second line contains n space-separated integers w1, w2, ..., wn (1 ≤ wi ≤ 100) — the weight of each book.The third line contains m space separated integers b1, b2, ..., bm (1 ≤ bj ≤ n) — the order of books that he would read. Note that he can read the same book more than once.\n\nOutputPrint the minimum total weight of books he should lift, which can be achieved by rearranging the order of stacked books.\n\nInputCopy3 51 2 31 3 2 3 1OutputCopy12\n\nInputCopy3 51 2 31 3 2 3 1\n\nOutputCopy12\n\nNoteHere's a picture depicting the example. Each vertical column presents the stacked books.",
      "solutions": [
        {
          "title": "Good Bye 2014 - Codeforces",
          "content": "Hi, Codeforces!Welcome to the last Codeforces Round of 2014, Good Bye 2014! This round is very unusual; First, the round starts at December 30th, 18:00 MSK. Second, the round lasts for 2.5 hours. And lastly, the round will be division combined, which means Div1 contestants and Div2 contestants won't be separated.The problems are prepared by me (.o.) and Seunghyun Jo (ainta). This is our second round at Codeforces. Because our first round caused(?) the Black Day, we hope this round won't cause any errors like before :DThanks to Won-seok Yoo(ainu7), who tested our round and gave us comments about the problemset.We'd like to thank some people who were necessary to make this round: Maxim Akhmedov (Zlobober) gave us great help preparing the problems. Maria Belova (Delinur) translated problem statements in Russian. Mike Mirzayanov (MikeMirzayanov) made Codeforces and Polygon systems, which are really great. Let's give them an applause!The score distribution will be posted just before the round starts, as usual.We wish you all the best of luck. Happy New Year!UPD (2014-12-30 17:33:21) The score for each problem is going to be 500-1000-1000-1500-2750-2750-3500. Thanks to Xellos for giving us some ideas.UPD (2014-12-31 12:49:05) Round has finished, congratulations to the winners! tourist Petr rng_58 HYPERHYPERHYPERCUBELOVER subscriber Merkurev al13n mmaxio mexmans GlebsHP Also, thanks to Marcin_smu, who solved problem G after the contest for the first time.UPD(2014-12-31 12:51:08) Editorial is published. Currently, only A-F is available, but I will add G as soon as possible. Sorry for the late editorial.UPD(2015-01-02 21:30:44) I wrote the editorial of G. Sorry for the late update..",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/15465",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.6,
            "reason": "宽松匹配: 包含题目编号 500 和字母"
          },
          "content_length": 1702
        },
        {
          "title": "Good Bye 2014 Tutorial - Codeforces",
          "content": "500A — New Year TransportationIn this problem we are given a directed graph, and asked whether a particular vertex is reachable from vertex 1. It is possible to solve this by running a depth-first search starting from vertex 1.Since every vertex has at most one outgoing edge, it is possible to write the DFS as a simple loop. Some people used this to make very short submissions.500B — New Year PermutationImagine a graph with one vertex for each entry in the permutation, and edges between pairs of swappable entries. It is easy to see that no matter how many swaps we make, no entry can end up in a location that is not in its connected component. We can also show that within any connected component, we can achieve any rearrangement of the entries that we wish.Since we want to make the lexicographically smallest permutation, we should greedily rearrange the entries within each connected component so that they are in increasing order.N ≤ 300, so we are not concerned with runtime. One can determine the connected components using a number of standard algorithms (Floyd-Warshall, Union Find, etc.).500C — New Year Book ReadingConsider an arbitrary day d, on which we must read book b. Let d' be the last day before d on which book b was read (if there is no previous day, let d' =  - ∞). Observe that, on day d, we cannot avoid lifting all of the books read on any day between d' and d. If we add up all the weights of these required liftings, we will have a lower bound on the answer.This lower bound can be computed with two loops, in O(M2) time. We must be sure not to add a book's weight multiple times, if it was read multiple times in the interval (d', d).If we initially arrange the books in order of the first day on which they are read, we will achieve the described lower bound. So, we have our answer.500D — New Year Santa NetworkBy linearity of expectation, E(d(c1, c2) + d(c1, c3) + d(c2, c3)) = E(d(c1, c2)) + E(d(c1, c3)) + E(d(c2, c3)). By symmetry, those three values are all equal. So, we need only compute E(d(c1, c2)). We can multiply it by 3 to find the answer.Let us imagine that a random selection (c1, c2, c3) is made. We'll define a function f(j), for each edge j, so that f(j) = wj if j is part of the shortest path from c1 to c2, and f(j) = 0 otherwise. Observe that . Again by linearity, we have .We can write E(f(j)) = wj·P(j), where P(j) is the probability that edge j is included in the path from c1 to c2. If we compute P(j) for all j, we can then compute in O(N). Also, we can handle updates in O(1); if wj changes to w'j, we subtract wj·P(j) from the answer, and add w'j·P(j). So, let's figure out P(j) for each j. Any edge j, if removed from the tree, separates the graph into two separate connected components a and b. Edge j will be included in the shortest path from c1 to c2 if and only if one of them is in a, and the other is in b. So, we want the number of ways to select (c1, c2, c3) such that c1 and c2 are on opposite sides of edge j, divided by the total number of ways to select (c1, c2, c3). Let's have |a| and |b| denote the number of vertices in a and b, respectively. Then .To figure out |a| and |b| for each j, we can root the tree arbitrarily and compute the depth and subtree size for each vertex in O(N) time. Then for an edge j, if vj is the deeper vertex incident to j, we know one component has size equal to the subtree size of vj. For the other component, we use the fact that |b| = N - |a|. 500E — New Year DominoWhen domino i is knocked over, it covers the interval [pi, pi + li]. If we see a query (xj, yj), it is equivalent to the question \"If we knock over all dominoes with index , how much of the interval [pxj, pyj] won't be covered?\" We can modify that question a little more, to say that we knock over all dominoes with index i ≥ xj, without changing its answer. Now, consider knocking over the dominoes from right to left. As soon as we knock over domino i, we will immediately process all of the queries with xj = i, and record their answers. What we need is a data structure that supports two operations: \"cover range [pi, pi + li]\" (when we knock over a domino) and \"compute how much of the range [pxj, pyj] is not covered\" (when we wish to answer a query). This can be done using coordinate compression and a segment tree. It's worth noting there are a lot of other ways to solve this problem. The other tutorial uses a completely different approach. Also, the approach described here may be implemented using different data structures. For example, here is my implementation using BBSTs and a Binary Indexed Tree.500F — New Year ShoppingWe will use the standard dynamic programming approach for 0/1 knapsack. To summarize what it does for us, imagine we are given an ordered list of items (ci, hi). Let F(k, b) be the maximum happiness we can buy, if we consider only the first k items in the list, and have a budget of b. If K is the size of the list, and B is the maximum possible budget, we can compute F(k, b) for all possible k and b in O(KB) time.Let us sort all of the items by their display time. Suppose that we focus on the queries (aj, bj) with , for some particular t. Let A be a list of the items with display time in (t - P, t], and let B be a list of the items with display time in (t, t + P). Let both lists be sorted in order of display time.Every query with will have available to it some suffix of A, along with some prefix of B. We'll do a knapsack DP on the elements of A, in reverse order, and another on the elements of B, in normal order. Finally, to answer any query (aj, bj) with , we can consider all possible ways to split the budget bj between the items in A and the items in B, in linear time. For each possible way to split the budget, we need simply look up one value from each DP table to know the maximum possible happiness.If we perform the process above on t = 1, 1 + P, 1 + 2P, 1 + 3P, ... until t exceeds the maximum possible day D, we'll be able to answer all of the queries. Let's think about the runtime of this solution. For each t, the described process takes O(KB) time, where K is the number of items whose display time is in (t - P, t + P). Each object can only appear in up to two of these intervals. So, the overall runtime for all of the knapsack DP's we perform is O(nB). Computing the final answer takes O(B) per query, or O(qB) overall.500G — New Year RunningDon't know how to solve this yet. Maybe someone who is not gray can provide the solution. :)",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/15513",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 500\\s*C"
          },
          "content_length": 6486
        },
        {
          "title": "Good Bye 2014 Editorial - Codeforces",
          "content": "First of all, sorry for the late editorial. I was too exhausted and immediately went to bed after the round finished, and didn't write the editorial.There are many pictures in this editorial, to cover up my poor English skills! If you have detected any errors or have questions, feel free to ask questions by comments. Unfortunately, the authors only know English, so we can't answer you if you write comments in Russian.500A - Транспорт на Новый годLet's assume that I am in the cell i (1 ≤ i ≤ n). If i ≤ n - 1, I have two choices: to stay at cell i, or to go to cell (i + ai). If i = t, we are at the target cell, so I should print \"YES\" and terminate. If i > t, I cannot go to cell t because I can't use the portal backwards, so one should print \"NO\" and terminate. Otherwise, I must go to cell (i + ai).Using this method, I visit each cell at most once, and there are n cells, so the problem can be solved in linear time.What is test 13?There are 9 pretests in this problem. There are no test where n = t holds in pretests. Many people didn't handle this case, and got hacked or got Wrong Answer on test 13. Time: O(n) Memory: O(n) (maybe O(1)) Implementation: 9335683 500B - Новогодняя перестановкаIt seems that many contestants were confused by the statement, so let me clarify it first. Given a permutation p1, p2, ..., pn and a n × n-sized binary matrix A, the problem asks us to find the lexicographically minimum permutation which can be achieved by swapping two distinct elements pi and pj where the condition Ai, j = 1 holds. (From the statement, permutation A is prettier than permutation B if and only if A is lexicographically less than B.)Let's think matrix A as an adjacency matrix of a undirected unweighted graph.If two vertices i and j are in the same component (in other words, connected by some edges), the values of pi and pj can be swapped, using a method similar to bubble sort. Look at the picture below for easy understanding.Because all the two distinct vertices in the same component can be swapped, the vertices in the same component can be sorted. In conclusion, we can solve the problem by the following procedure. Find all the connected components. For each component, sort the elements in the component. Print the resulting permutation. The size limit is quite small, so one can use any algorithm (DFS/BFS/..) for as many times as you want. Time: O(n2) — because of the graph traversal. O(n3) is okay because of small constraints. Memory: O(n2) Implementation: 9335689 (.o.) What is test 15? There are too many wrong answers in this case.Actually, I made the pretests very weak in order to make many hacks. As mentioned in the Hack me! post by kostka, just swapping the elements greedily could pass the pretests easily. There were 14 pretests, and I made test 15 an counter-example of such algorithm in order to reduce judging time, and it seems that most of the wrong submissions failed in this test case :D500C - В Новый год --- с книгой!In order to calculate the minimum possible lifted weight, we should find the initial stack first. Let's find the positions one by one. First, let's decide the position of book b1. After day 1, book b1 will be on the top of the stack, regardless of the order of the initial stack. Therefore, in order to minimize the lifted weight during day 1, book b1 must be on the top of the initial stack. (so actually, in day 1, Jaehyun won't lift any book) Next, let's decide the position of book b2. (assume that b1 ≠ b2 for simplicity) Currently, b1 is on the top of the stack, and it cannot be changed because of the procedure. Therefore, in order to minimize the lifted weight during day 2, book b2 must be immediately below book b1. Considering this, we can find the optimal strategy to create the initial stack: Scan b1, b2, ..., bm step by step. Let's assume that I am handling bi now. If bi has appeared before (formally, if ), erase bi from the sequence. Otherwise, leave bi. The resulting sequence will be the optimal stack.You should note that it is not necessary for Jaehyun to read all the books during 2015, which means the size of the resulting sequence may be smaller than n. The books which doesn't appear in the resulting sequence must be in the bottom of the initial stack (obviously). However, this problem doesn't require us to print the initial stack, so it turned out not to be important. In conclusion, finding the initial stack takes O(n + m) time.After finding the initial stack, we can simulate the procedure given in the statement naively. It will take O(nm) time. Time: O(nm) Memory: O(n + m) Implementation: 9335694 (.o.) 500D - Новогоднее взаимодействие Санта-КлаусовThe problem asks us to calculate the value ofLet's write it down..So, we need to calculate the value of . I'll denote the sum as S. How should we calculate this?For simplicity, I'll set node 1 as the root of the tree. Let's focus on an edge e, connecting two vertices u and p. See the picture below.Set A is a set of vertices in the subtree of vertex u, and set B is a set of vertices which is not in the subtree of vertex u. So, is the set of vertices in the tree, and is empty.For all pairs of two vertices (x, y) where the condition and holds, the shortest path between x and y contains edge e. There are size(A) × size(B) such pairs. So, edge e increases the sum S by 2 × le × size(A) × size(B). (because d(x, y) and d(y, x) both contributes to S)size(A) (the size of the subtree whose root is u) can be calculated by dynamic programming in trees, which is well known. size(B) equals to N - size(A). So, for each edge e, we can pre-calculate how many times does this edge contributes to the total sum. Let's define t(e) = size(A) × size(B), (A and B is mentioned above). If the length of a certain road e decreases by d, S will decrease by t(e) × d. So we can answer each query. Time: O(n) (pre-calculation) + O(q) (query) Memory: O(n) (O(n + q) is okay too) Implementation: 9335695 (.o.) Something about precision errorBecause of the tight constraints, the total sum of d(a, b) + d(b, c) + d(c, a) (it is equal to S × (n - 2)) can be so large that it can't be saved in long long(64-bit integer) type. Some contestants didn't handle this and got WA. However, there are some contestants who saved this value divided by n × (n - 1) × (n - 2) in double type. double has 52 bits to store exact value, so it isn't enough. But because we allow 10 - 6 precision error, it seems to have been got accepted.What if we allowed the length of the road could become 0? Then the precision error gets much more bigger, and the solution prints something that is far from the expected value (for example, negative value). ainu7 discovered this effect and suggested to apply this, but we didn't because it was hard to fix the statement..Why does the road length decreases? It doesn't matter even if increases.It's because of the weird legend. It is hard to explain, \"People repairs a certain road per year, and its length may be increased or decreased.\" fluently for me..500E - Новогоднее доминоFrom the statement, it is clear that, when domino i falls to the right, it makes domino j also fall if and only if pi < pj ≤ pi + li.For each domino i, let's calculate the rightmost position of the fallen dominoes R[i] when we initially pushed domino i. From the definition, . This can be calculated by using a segment tree or using a stack, in decreasing order of i (from right to left). After that, we define U[i] as the smallest j where R[i] < pj holds. (In other words, the smallest j where domino j is not affected by pushing domino i)Now, the problem becomes: Calculate P[U[xi]] - R[xi] + P[U[U[xi]]] - R[U[xi]] + ..., until U[xi] ≤ yi. Because i < U[i], this task can be solved by precalculating 'jumps' of 2something times, using the method described in here. You must read the \"Another easy solution in <O(N logN, O(logN)>\" part..Formally, let's define Un + 1[k] = U[Un[k]] and Sn + 1[k] = Sn[k] + (P[Un + 1[k]] - R[Un[k]]). So, Sn[k] means the sum of domino length extensions when we initially push domino i and we prolonged the length exactly n times. U2i + 1[k] = U2i[U2i[k]], and S2i + 1[k] = S2i[k] + S2i[U2i[k]] holds. (If you don't understand this part, I suggest you to read the article linked above) Time : or . Memory : Implementation: 9335698 (.o.) We would like to know whether there is a linear offline solution or not. 500F - Новогодние покупки The i-th item is available during [ti, ti + p - 1]. In other words, at time T, item i is available if and only if ti ≤ T ≤ ti + p - 1. This can be re-written as (ti ≤ T and T - p + 1 ≤ ti), which is T - p + 1 ≤ ti ≤ T. With this observation, we can transform the item's purchasable range into a dot, and the candidate's visit time into a range: From now on, item i is only available at time ti. and each candidate pair (aj, bj) means that I can visit the store during [aj - p + 1, aj], and my budget is bj dollars at that visit. This transformation makes the problem easier to solve.Each red circled point denotes an item which is sold at that time, and each black interval denotes a candidate. Let's only consider the intervals which passes time T. All the intervals' length is exactly p, so the left bound of the interval is (T - p) and the right bound of the interval is (T + p). For each interval, we'd like to solve the 0/1 knapsack algorithm with the items that the interval contains. How can we do that effectively? There is an important fact that I've described above: all the interval passes time T. Therefore, the interval [aj - p + 1, aj] can be split into two intervals: [aj - p + 1, T - 1] and [T, aj].So, let's solve the 0/1 knapsack problem for all intervals [x, T - 1] (T - p ≤ x ≤ T - 1) and [T, y] (T ≤ y ≤ T + p). Because one of the endpoints is fixed, one can run a standard dynamic programming algorithm. Therefore, the time needed in precalculation is O(S × W), where S is the number of items where the condition holds.Let's define h(I, b), as the maximum happiness I can obtain by buying the items where the condition holds, using at most b dollars. For each candidate (aj, bj), we have to calculate h([aj - p + 1, aj], bj), which is equal to max0 ≤ k ≤ b{h([aj - p + 1, T - 1], k) + h([T, aj], b - k)}. So it takes O(bj) = O(W) time to solve each query.The only question left is: How should we choose the value of T? We have two facts. (1) The length of intervals is exactly p. (2) The algorithm covers intervals which passes time T. Therefore, to cover all the intervals given in the input, we should let T be p, 2p, 3p, 4p, ... (of course, one by one), and run the algorithm described above.Then, what is the total time complexity? Think of intervals [0, 2p], [p, 3p], [2p, 4p], [3p, 5p], .... For each point, there will be at most two intervals which contains the point. Therefore, each item is reflected in the pre-calculation at most twice, so the time needed to precalculate is O(n × W). The time needed to solve each query is O(bj), and the answer of the query is calculated at most once. Therefore, the time needed to answer all the queries is O(q × W). Time : O((n + q) × W). Memory : O(n × W) Implementations: 9335699 (ainta), 9335703 (ainu7) , 9335710 (.o., using a different approach), 9335709 (.o., using a divide and conquer approach) Divide and Conquer approachLet's assume that t1 ≤ t2 ≤ ... ≤ tn. We can easily know that at time T, the indexes of all the available items forms a segment [l, r]. (in other words, item l, item l + 1, ..., item r - 1, item r is available) We can use this fact to solve all the queries. Let's assume that item lj, item lj + 1, ..., item rj - 1, item rj is available at time aj.Define a function solve(L, R). This function calculates the answer for queries where the condition L ≤ lj ≤ rj ≤ R holds. Let's assume that L < R holds. (In the case L ≥ R, the answer can be calculated easily) Let . Call solve(L, M) and solve(M + 1, R). After that, the queries needed to be calculated, satisfies the condition lj ≤ M < rj, which means all the intervals(queries) passes item M. Now, to calculate the answer for such queries, we can use the method described at the dynamic programming approach.The time complexity is , because and the answer of the queries can be calculated in O(bj) per query. Time : . Memory : O(n × W) Implementation: 9335709 Unfortunately, this approach is offline, because of the memory. Is there any available online approach using divide and conquer?Blocking the divide and conquer solutionI tried my best to block divide and conquer solutions, but failed. It seems that many participants solved the problem with divide and conquer approach. My approach takes time, and it gets accepted in 546ms.500G - Новогодний забегBefore starting the editorial, I'd like to give a big applause to Marcin_smu, who solved the problem for the first time!Warning: The editorial is very long and has many mistakes. There are lots of lots of mistakes.. Keep calm, and please tell me by comments, if you discovered any errors.This problem can be solved by an online algorithm. Let's focus on a single query (u, v, x, y). This means that JH runs between u and v, and JY runs between x and y.Just like when we solve many problems with undirected trees, let vertex 1 be the root of the tree. Also, we will assume that they won't stop after when they meet, but they will continue running, in order to explain easily.Some definitions: Path (a, b): the shortest path between vertex a and vertex b. d(a, b): the length of Path (a, b). LCA(a, b): the lowest common ancestor of vertex a and vertex b. Finding the common path of two pathsIf there is no common vertex between Path (u, v) and Path (x, y), the answer will be obviously  - 1. So, let's find the common vertices first. Because the path between two vertices is always unique, the common vertices also form a path. So, I'll denote the path of the common vertices as Path (c1, c2). c1 and c2 may be equal to: u, v, x, y, and even each other.The possible endpoints are P1 = LCA(u, v), P2 = LCA(x, y), P3 = LCA(u, x), P4 = LCA(u, y), P5 = LCA(v, x), and P6 = LCA(v, y). Figure out by drawing some examples. (some of you might think it's obvious :D)See the pictures above, and make your own criteria to check whether the two paths intersects :DA small hint. Let's assume that we already know, that a vertex a lies on path (x, y). If a lies on path (u, v), a is a common vertex of two paths. What if a is guaranteed to be an end point of the common path?Additional definitions Let's denote JH's running course is: . Then, there are two possible courses for JY: and ). fJH : the time needed to run the course . fJY : the time needed to run the course . t1 : the first time when JH passes vertex c1, moving towards c2. t2 : the first time when JH passes vertex c2, moving towards c1. t3 : the first time when JY passes vertex c1, moving towards c2. t4 : the first time when JY passes vertex c2, moving towards c1. Case 1) When JH and JY meets while moving in the same directionObviously, they must meet at vertex c1 or vertex c2 for the first time. Without loss of generality, let's assume that they meet at vertex c1. In this case, both of them is moving towards vertex c2. (You can use the method similarly for c2) Let's assume that JH and JY meets at time T. Because the movements of both runners are periodic, T must satisfy the conditions below: Among possible T-s, we have to calculate the smallest value. How should we do? From the first condition, we can let T = fJH × p + t1, where p is a non-negative integer. With this, we can write the second condition as: . In conclusion, we have to find the smallest p which satisfies the condition Using the Extended Euclidean algorithm is enough to calculate the minimum p. With p, we can easily calculate the minimum T, which is the first time they meet. If there is no such p, they doesn't meet forever, so the answer is  - 1.Case 2) When JH and JY meets while moving in the opposite directionIn this case, they will meet at a vertex lying on Path (c1, c2). Without loss of generality, let's assume that JH is going from c1 to c2, and JY is going from c2 to c1.I'll assume that JH and JY meets at time T. [1] Let's see how JH moves: For all non-negative integer p, At time fJH × p + t1, he is at vertex c1, moving towards c2. At time fJH × p + t1 + d(c1, c2), he is at vertex c2. Therefore, when fJH × p + t1 ≤  (current time)  ≤ fJH × p + t1 + d(c1, c2), JH is on Path (c1, c2). So, T must satisfy the condition: fJH × p + t1 ≤ T ≤ fJH × p + t1 + d(c1, c2) [2] Let's see how JY moves: Similar to JH, for all non-negative integer q, At time fJY × q + t4, he is at vertex c2, moving towards c1. At time fJY × q + t4 + d(c2, c1), he is at vertex c1. Therefore, when fJY × q + t4 ≤  (current time)  ≤ fJY × q + t4 + d(c2, c1), JY is on Path (c2, c1). So, T must satisfy the condition: fJY × q + t4 ≤ T ≤ fJY × q + t4 + d(c1, c2) [3] These two conditions are not enough, because in this case, they can meet on an edge, but they cannot meet on a vertex.We'd like to know when do they meet on a vertex, like the picture below.As you see from the picture above, in this case, the condition d(c1, a) + d(a, c2) = d(c1, c2) holds. If this picture was taken at time s, this condition can be written as: {s - (fJH × p + t1)} + {s - (fJY × q + t4)} = d(c1, c2) 2s - (fJH × p + fJY × q) - (t1 + t4) = d(c1, c2) s = {d(c1, c2) + (fJH × p + fJY × q) + (t1 + t4)} / 2 Because JH and JY both travel their path back and forth, fJH and fJY are all even. Therefore, in order to make s an integer, d(c1, c2) + t1 + t4 must be even. This can be written as [4] Merging [1], [2] and [3], we can conclude that if these two conditions holds, max{fJH × p + t1, fJY × q + t4} ≤ min{fJH × p + t1 + d(c1, c2), fJY × p + t4 + d(c1, c2)} JH and JY meets on a certain vertex lying on path (c1, c2). The first condition can be easily checked, so let's focus on the second condition. The second condition holds if and only if: fJY × q + t4 - t1 - d ≤ fJH × p ≤ fJY × q + t4 - t1 + d You can check this by changing \"fJH × p\" to the lower bound and the upper bound of the inequality. Therefore, the problem is to find the smallest p which satisfies the condition above.Let's define a function g(M, D, L, R), where M, D, L, R are all non-negative integers. The function returns the smallest non-negative integer m which satisfies . This function can be implemented as follows. If L = 0, g(M, D, L, R) = 0. (because L = 0 ≤ D·0) If , it is \"obvious\" that there is no solution. If 2D > M, g(M, D, L, R) = g(M, M - D, M - R, M - L). If there exists an non-negative integer m which satisfies L ≤ D·m ≤ R (without modular condition), g(M, D, L, R) = m. Obviously, we should take the smallest m. Otherwise, there exists an integer m which satisfies D·m < L ≤ R < D·(m + 1). We should use this fact.. If holds, there exists an non-negative integer k which satisfies L + Mk ≤ D·m ≤ R + Mk. Let's write down.. D·m - R ≤ M·k ≤ D·m - L  - R ≤ M·k - D·m ≤  - L L ≤ D·m - M·k  ≤ RBecause , we can write the inequality as Therefore the minimum k among all possible solutions is equal to . We can easily calculate the smallest p using k. Then, what is the time complexity of calculating g(M, D, L, R)? Because 2D ≤ M (the 2D > M case is handled during step 3), the problem size becomes half, so it can be executed in .ConclusionFor each query, we have to consider both Case 1) and Case 2), with all possible directions. Both cases can be handled in , so the time complexity per query is , and it has really huge constant. Time: Memory: Implementation: 9330235",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/15488",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 500\\s*C"
          },
          "content_length": 19579
        }
      ],
      "code_examples": [
        {
          "title": "Good Bye 2014 - Codeforces - Code 1",
          "code": "division combined",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15465",
          "author": "jiangly"
        },
        {
          "title": "Good Bye 2014 - Codeforces - Code 2",
          "code": "3\n3 1 2\n011\n100\n100",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15465",
          "author": "jiangly"
        },
        {
          "title": "Good Bye 2014 - Codeforces - Code 3",
          "code": "3\n3 1 2\n011\n100\n100",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15465",
          "author": "jiangly"
        },
        {
          "title": "Good Bye 2014 - Codeforces - Code 4",
          "code": "(3,2) (1,2)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15465",
          "author": "jiangly"
        },
        {
          "title": "Good Bye 2014 - Codeforces - Code 5",
          "code": "7\n7 3 4 6 8 1 2\n0010000\n0001000\n0000100\n0000000\n0000001\n1000000\n0000000",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15465",
          "author": "jiangly"
        },
        {
          "title": "Good Bye 2014 - Codeforces - Code 6",
          "code": "7\n7 3 4 6 8 1 2\n0010000\n0001000\n0000100\n0000000\n0000001\n1000000\n0000000",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15465",
          "author": "jiangly"
        },
        {
          "title": "Good Bye 2014 - Codeforces - Code 7",
          "code": "1 3 2 6 4 7 8",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15465",
          "author": "jiangly"
        },
        {
          "title": "Good Bye 2014 - Codeforces - Code 8",
          "code": "2 3 4 6 7 1 8",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15465",
          "author": "jiangly"
        },
        {
          "title": "Good Bye 2014 - Codeforces - Code 9",
          "code": "3\n3 1 2\n011\n100\n100",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15465",
          "author": "jiangly"
        },
        {
          "title": "Good Bye 2014 - Codeforces - Code 10",
          "code": "3\n3 1 2\n011\n100\n100",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15465",
          "author": "jiangly"
        },
        {
          "title": "Good Bye 2014 - Codeforces - Code 11",
          "code": "5\n2 4 1 3 5\n00101\n00010\n10011\n01100\n10100",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15465",
          "author": "jiangly"
        },
        {
          "title": "Good Bye 2014 - Codeforces - Code 12",
          "code": "5\n2 4 1 3 5\n00101\n00010\n10011\n01100\n10100",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15465",
          "author": "jiangly"
        },
        {
          "title": "Good Bye 2014 - Codeforces - Code 13",
          "code": "__mingw_printf",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15465",
          "author": "jiangly"
        },
        {
          "title": "Good Bye 2014 Editorial - Codeforces - Code 1",
          "code": "3.0 / ((long long)n * (n-1))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15488",
          "author": "jiangly"
        },
        {
          "title": "Good Bye 2014 Editorial - Codeforces - Code 2",
          "code": "actually the sorting is o(q*log(q))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15488",
          "author": "jiangly"
        },
        {
          "title": "Good Bye 2014 Editorial - Codeforces - Code 3",
          "code": "actually the sorting is o(q*log(q))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15488",
          "author": "jiangly"
        },
        {
          "title": "Good Bye 2014 Editorial - Codeforces - Code 4",
          "code": "upper_bound",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15488",
          "author": "jiangly"
        },
        {
          "title": "Good Bye 2014 Editorial - Codeforces - Code 5",
          "code": "merge_group(i, j)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15488",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(2, 500, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 1000, \"m\");\n    inf.readEoln();\n\n    vector<int> w = inf.readInts(n, 1, 100, \"w\");\n    inf.readEoln();\n\n    vector<int> b = inf.readInts(m, 1, n, \"b\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(2, 500, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 1000, \"m\");\n    inf.readEoln();\n\n    vector<int> w = inf.readInts(n, 1, 100, \"w\");\n    inf.readEoln();\n\n    vector<int> b = inf.readInts(m, 1, n, \"b\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(2, 500, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 1000, \"m\");\n    inf.readEoln();\n\n    vector<int> w = inf.readInts(n, 1, 100, \"w\");\n    inf.readEoln();\n\n    vector<int> b = inf.readInts(m, 1, n, \"b\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string wt = opt<string>(\"wt\", \"random\");\n    string ord = opt<string>(\"ord\", \"random\");\n\n    n = max(2, min(500, n));\n    m = max(1, min(1000, m));\n\n    vector<int> w(n);\n    vector<int> b(m);\n\n    // Generate weights\n    if (wt == \"equal\") {\n        int val = rnd.next(1, 100);\n        fill(w.begin(), w.end(), val);\n    } else if (wt == \"max\") {\n        fill(w.begin(), w.end(), 100);\n    } else if (wt == \"min\") {\n        fill(w.begin(), w.end(), 1);\n    } else if (wt == \"increasing\") {\n        for(int i = 0; i < n; ++i)\n            w[i] = (i % 100) + 1;\n    } else if (wt == \"decreasing\") {\n        for(int i = 0; i < n; ++i)\n            w[i] = 100 - (i % 100);\n    } else { // random weights\n        for(int i = 0; i < n; ++i)\n            w[i] = rnd.next(1, 100);\n    }\n\n    // Generate reading order\n    if (ord == \"random\") {\n        for(int i = 0; i < m; ++i)\n            b[i] = rnd.next(1, n);\n    } else if (ord == \"same\") {\n        int val = rnd.next(1, n);\n        fill(b.begin(), b.end(), val);\n    } else if (ord == \"increasing\") {\n        for(int i = 0; i < m; ++i)\n            b[i] = (i % n) + 1;\n    } else if (ord == \"decreasing\") {\n        for(int i = 0; i < m; ++i)\n            b[i] = n - (i % n);\n    } else if (ord == \"alternating\") {\n        for(int i = 0; i < m; ++i)\n            b[i] = (i % 2 == 0) ? 1 : n;\n    } else { // default to random\n        for(int i = 0; i < m; ++i)\n            b[i] = rnd.next(1, n);\n    }\n\n    // Output\n    cout << n << \" \" << m << \"\\n\";\n    for(int i = 0; i < n; ++i) {\n        cout << w[i];\n        if (i + 1 < n)\n            cout << \" \";\n        else\n            cout << \"\\n\";\n    }\n    for(int i = 0; i < m; ++i) {\n        cout << b[i];\n        if (i + 1 < m)\n            cout << \" \";\n        else\n            cout << \"\\n\";\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string wt = opt<string>(\"wt\", \"random\");\n    string ord = opt<string>(\"ord\", \"random\");\n\n    n = max(2, min(500, n));\n    m = max(1, min(1000, m));\n\n    vector<int> w(n);\n    vector<int> b(m);\n\n    // Generate weights\n    if (wt == \"equal\") {\n        int val = rnd.next(1, 100);\n        fill(w.begin(), w.end(), val);\n    } else if (wt == \"max\") {\n        fill(w.begin(), w.end(), 100);\n    } else if (wt == \"min\") {\n        fill(w.begin(), w.end(), 1);\n    } else if (wt == \"increasing\") {\n        for(int i = 0; i < n; ++i)\n            w[i] = (i % 100) + 1;\n    } else if (wt == \"decreasing\") {\n        for(int i = 0; i < n; ++i)\n            w[i] = 100 - (i % 100);\n    } else { // random weights\n        for(int i = 0; i < n; ++i)\n            w[i] = rnd.next(1, 100);\n    }\n\n    // Generate reading order\n    if (ord == \"random\") {\n        for(int i = 0; i < m; ++i)\n            b[i] = rnd.next(1, n);\n    } else if (ord == \"same\") {\n        int val = rnd.next(1, n);\n        fill(b.begin(), b.end(), val);\n    } else if (ord == \"increasing\") {\n        for(int i = 0; i < m; ++i)\n            b[i] = (i % n) + 1;\n    } else if (ord == \"decreasing\") {\n        for(int i = 0; i < m; ++i)\n            b[i] = n - (i % n);\n    } else if (ord == \"alternating\") {\n        for(int i = 0; i < m; ++i)\n            b[i] = (i % 2 == 0) ? 1 : n;\n    } else { // default to random\n        for(int i = 0; i < m; ++i)\n            b[i] = rnd.next(1, n);\n    }\n\n    // Output\n    cout << n << \" \" << m << \"\\n\";\n    for(int i = 0; i < n; ++i) {\n        cout << w[i];\n        if (i + 1 < n)\n            cout << \" \";\n        else\n            cout << \"\\n\";\n    }\n    for(int i = 0; i < m; ++i) {\n        cout << b[i];\n        if (i + 1 < m)\n            cout << \" \";\n        else\n            cout << \"\\n\";\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 2 -m 1 -wt equal -ord same\n./gen -n 2 -m 1 -wt equal -ord random\n./gen -n 2 -m 1 -wt random -ord random\n\n./gen -n 2 -m 1 -wt min -ord same\n./gen -n 2 -m 1 -wt max -ord same\n\n./gen -n 100 -m 10 -wt increasing -ord decreasing\n./gen -n 100 -m 10 -wt decreasing -ord increasing\n\n./gen -n 250 -m 500 -wt random -ord random\n./gen -n 250 -m 500 -wt equal -ord same\n\n./gen -n 500 -m 1000 -wt max -ord random\n./gen -n 500 -m 1000 -wt min -ord random\n./gen -n 500 -m 1000 -wt random -ord random\n./gen -n 500 -m 1000 -wt equal -ord same\n\n./gen -n 500 -m 1000 -wt increasing -ord increasing\n./gen -n 500 -m 1000 -wt decreasing -ord decreasing\n./gen -n 500 -m 1000 -wt increasing -ord decreasing\n./gen -n 500 -m 1000 -wt decreasing -ord increasing\n\n./gen -n 500 -m 1000 -wt random -ord same\n./gen -n 500 -m 1000 -wt equal -ord sequential\n./gen -n 500 -m 1000 -wt equal -ord reverse\n\n./gen -n 500 -m 1000 -wt random -ord alternating\n./gen -n 500 -m 1000 -wt increasing -ord alternating\n./gen -n 500 -m 1000 -wt decreasing -ord alternating\n\n./gen -n 500 -m 1 -wt random -ord random\n./gen -n 500 -m 1000 -wt max -ord same\n./gen -n 500 -m 1000 -wt min -ord same\n./gen -n 500 -m 1000 -wt equal -ord same\n./gen -n 500 -m 1000 -wt equal -ord random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:40:03.509530",
        "total_tutorials": 3,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "500/D",
      "title": "D. New Year Santa Network",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains an integer n (3 ≤ n ≤ 105) — the number of cities in Tree World.Next n - 1 lines describe the roads. The i-th line of them (1 ≤ i ≤ n - 1) contains three space-separated integers ai, bi, li (1 ≤ ai, bi ≤ n, ai ≠ bi, 1 ≤ li ≤ 103), denoting that the i-th road connects cities ai and bi, and the length of i-th road is li.The next line contains an integer q (1 ≤ q ≤ 105) — the number of road length changes.Next q lines describe the length changes. The j-th line of them (1 ≤ j ≤ q) contains two space-separated integers rj, wj (1 ≤ rj ≤ n - 1, 1 ≤ wj ≤ 103). It means that in the j-th repair, the length of the rj-th road becomes wj. It is guaranteed that wj is smaller than the current length of the rj-th road. The same road can be repaired several times.",
      "output_spec": "OutputOutput q numbers. For each given change, print a line containing the expected cost needed to build the network in Tree World. The answer will be considered correct if its absolute and relative error doesn't exceed 10 - 6.",
      "sample_tests": "ExamplesInputCopy32 3 51 3 351 42 21 22 11 1OutputCopy14.000000000012.00000000008.00000000006.00000000004.0000000000InputCopy61 5 35 3 26 1 71 4 45 2 351 22 13 54 15 2OutputCopy19.600000000018.600000000016.600000000013.600000000012.6000000000",
      "description": "D. New Year Santa Network\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains an integer n (3 ≤ n ≤ 105) — the number of cities in Tree World.Next n - 1 lines describe the roads. The i-th line of them (1 ≤ i ≤ n - 1) contains three space-separated integers ai, bi, li (1 ≤ ai, bi ≤ n, ai ≠ bi, 1 ≤ li ≤ 103), denoting that the i-th road connects cities ai and bi, and the length of i-th road is li.The next line contains an integer q (1 ≤ q ≤ 105) — the number of road length changes.Next q lines describe the length changes. The j-th line of them (1 ≤ j ≤ q) contains two space-separated integers rj, wj (1 ≤ rj ≤ n - 1, 1 ≤ wj ≤ 103). It means that in the j-th repair, the length of the rj-th road becomes wj. It is guaranteed that wj is smaller than the current length of the rj-th road. The same road can be repaired several times.\n\nOutputOutput q numbers. For each given change, print a line containing the expected cost needed to build the network in Tree World. The answer will be considered correct if its absolute and relative error doesn't exceed 10 - 6.\n\nInputCopy32 3 51 3 351 42 21 22 11 1OutputCopy14.000000000012.00000000008.00000000006.00000000004.0000000000InputCopy61 5 35 3 26 1 71 4 45 2 351 22 13 54 15 2OutputCopy19.600000000018.600000000016.600000000013.600000000012.6000000000\n\nInputCopy32 3 51 3 351 42 21 22 11 1\n\nOutputCopy14.000000000012.00000000008.00000000006.00000000004.0000000000\n\nInputCopy61 5 35 3 26 1 71 4 45 2 351 22 13 54 15 2\n\nOutputCopy19.600000000018.600000000016.600000000013.600000000012.6000000000\n\nNoteConsider the first sample. There are 6 triples: (1, 2, 3), (1, 3, 2), (2, 1, 3), (2, 3, 1), (3, 1, 2), (3, 2, 1). Because n = 3, the cost needed to build the network is always d(1, 2) + d(2, 3) + d(3, 1) for all the triples. So, the expected cost equals to d(1, 2) + d(2, 3) + d(3, 1).",
      "solutions": [
        {
          "title": "Good Bye 2014 - Codeforces",
          "content": "Hi, Codeforces!Welcome to the last Codeforces Round of 2014, Good Bye 2014! This round is very unusual; First, the round starts at December 30th, 18:00 MSK. Second, the round lasts for 2.5 hours. And lastly, the round will be division combined, which means Div1 contestants and Div2 contestants won't be separated.The problems are prepared by me (.o.) and Seunghyun Jo (ainta). This is our second round at Codeforces. Because our first round caused(?) the Black Day, we hope this round won't cause any errors like before :DThanks to Won-seok Yoo(ainu7), who tested our round and gave us comments about the problemset.We'd like to thank some people who were necessary to make this round: Maxim Akhmedov (Zlobober) gave us great help preparing the problems. Maria Belova (Delinur) translated problem statements in Russian. Mike Mirzayanov (MikeMirzayanov) made Codeforces and Polygon systems, which are really great. Let's give them an applause!The score distribution will be posted just before the round starts, as usual.We wish you all the best of luck. Happy New Year!UPD (2014-12-30 17:33:21) The score for each problem is going to be 500-1000-1000-1500-2750-2750-3500. Thanks to Xellos for giving us some ideas.UPD (2014-12-31 12:49:05) Round has finished, congratulations to the winners! tourist Petr rng_58 HYPERHYPERHYPERCUBELOVER subscriber Merkurev al13n mmaxio mexmans GlebsHP Also, thanks to Marcin_smu, who solved problem G after the contest for the first time.UPD(2014-12-31 12:51:08) Editorial is published. Currently, only A-F is available, but I will add G as soon as possible. Sorry for the late editorial.UPD(2015-01-02 21:30:44) I wrote the editorial of G. Sorry for the late update..",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/15465",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.6,
            "reason": "宽松匹配: 包含题目编号 500 和字母"
          },
          "content_length": 1702
        },
        {
          "title": "Good Bye 2014 Tutorial - Codeforces",
          "content": "500A — New Year TransportationIn this problem we are given a directed graph, and asked whether a particular vertex is reachable from vertex 1. It is possible to solve this by running a depth-first search starting from vertex 1.Since every vertex has at most one outgoing edge, it is possible to write the DFS as a simple loop. Some people used this to make very short submissions.500B — New Year PermutationImagine a graph with one vertex for each entry in the permutation, and edges between pairs of swappable entries. It is easy to see that no matter how many swaps we make, no entry can end up in a location that is not in its connected component. We can also show that within any connected component, we can achieve any rearrangement of the entries that we wish.Since we want to make the lexicographically smallest permutation, we should greedily rearrange the entries within each connected component so that they are in increasing order.N ≤ 300, so we are not concerned with runtime. One can determine the connected components using a number of standard algorithms (Floyd-Warshall, Union Find, etc.).500C — New Year Book ReadingConsider an arbitrary day d, on which we must read book b. Let d' be the last day before d on which book b was read (if there is no previous day, let d' =  - ∞). Observe that, on day d, we cannot avoid lifting all of the books read on any day between d' and d. If we add up all the weights of these required liftings, we will have a lower bound on the answer.This lower bound can be computed with two loops, in O(M2) time. We must be sure not to add a book's weight multiple times, if it was read multiple times in the interval (d', d).If we initially arrange the books in order of the first day on which they are read, we will achieve the described lower bound. So, we have our answer.500D — New Year Santa NetworkBy linearity of expectation, E(d(c1, c2) + d(c1, c3) + d(c2, c3)) = E(d(c1, c2)) + E(d(c1, c3)) + E(d(c2, c3)). By symmetry, those three values are all equal. So, we need only compute E(d(c1, c2)). We can multiply it by 3 to find the answer.Let us imagine that a random selection (c1, c2, c3) is made. We'll define a function f(j), for each edge j, so that f(j) = wj if j is part of the shortest path from c1 to c2, and f(j) = 0 otherwise. Observe that . Again by linearity, we have .We can write E(f(j)) = wj·P(j), where P(j) is the probability that edge j is included in the path from c1 to c2. If we compute P(j) for all j, we can then compute in O(N). Also, we can handle updates in O(1); if wj changes to w'j, we subtract wj·P(j) from the answer, and add w'j·P(j). So, let's figure out P(j) for each j. Any edge j, if removed from the tree, separates the graph into two separate connected components a and b. Edge j will be included in the shortest path from c1 to c2 if and only if one of them is in a, and the other is in b. So, we want the number of ways to select (c1, c2, c3) such that c1 and c2 are on opposite sides of edge j, divided by the total number of ways to select (c1, c2, c3). Let's have |a| and |b| denote the number of vertices in a and b, respectively. Then .To figure out |a| and |b| for each j, we can root the tree arbitrarily and compute the depth and subtree size for each vertex in O(N) time. Then for an edge j, if vj is the deeper vertex incident to j, we know one component has size equal to the subtree size of vj. For the other component, we use the fact that |b| = N - |a|. 500E — New Year DominoWhen domino i is knocked over, it covers the interval [pi, pi + li]. If we see a query (xj, yj), it is equivalent to the question \"If we knock over all dominoes with index , how much of the interval [pxj, pyj] won't be covered?\" We can modify that question a little more, to say that we knock over all dominoes with index i ≥ xj, without changing its answer. Now, consider knocking over the dominoes from right to left. As soon as we knock over domino i, we will immediately process all of the queries with xj = i, and record their answers. What we need is a data structure that supports two operations: \"cover range [pi, pi + li]\" (when we knock over a domino) and \"compute how much of the range [pxj, pyj] is not covered\" (when we wish to answer a query). This can be done using coordinate compression and a segment tree. It's worth noting there are a lot of other ways to solve this problem. The other tutorial uses a completely different approach. Also, the approach described here may be implemented using different data structures. For example, here is my implementation using BBSTs and a Binary Indexed Tree.500F — New Year ShoppingWe will use the standard dynamic programming approach for 0/1 knapsack. To summarize what it does for us, imagine we are given an ordered list of items (ci, hi). Let F(k, b) be the maximum happiness we can buy, if we consider only the first k items in the list, and have a budget of b. If K is the size of the list, and B is the maximum possible budget, we can compute F(k, b) for all possible k and b in O(KB) time.Let us sort all of the items by their display time. Suppose that we focus on the queries (aj, bj) with , for some particular t. Let A be a list of the items with display time in (t - P, t], and let B be a list of the items with display time in (t, t + P). Let both lists be sorted in order of display time.Every query with will have available to it some suffix of A, along with some prefix of B. We'll do a knapsack DP on the elements of A, in reverse order, and another on the elements of B, in normal order. Finally, to answer any query (aj, bj) with , we can consider all possible ways to split the budget bj between the items in A and the items in B, in linear time. For each possible way to split the budget, we need simply look up one value from each DP table to know the maximum possible happiness.If we perform the process above on t = 1, 1 + P, 1 + 2P, 1 + 3P, ... until t exceeds the maximum possible day D, we'll be able to answer all of the queries. Let's think about the runtime of this solution. For each t, the described process takes O(KB) time, where K is the number of items whose display time is in (t - P, t + P). Each object can only appear in up to two of these intervals. So, the overall runtime for all of the knapsack DP's we perform is O(nB). Computing the final answer takes O(B) per query, or O(qB) overall.500G — New Year RunningDon't know how to solve this yet. Maybe someone who is not gray can provide the solution. :)",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/15513",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 500\\s*D"
          },
          "content_length": 6486
        },
        {
          "title": "Good Bye 2014 Editorial - Codeforces",
          "content": "First of all, sorry for the late editorial. I was too exhausted and immediately went to bed after the round finished, and didn't write the editorial.There are many pictures in this editorial, to cover up my poor English skills! If you have detected any errors or have questions, feel free to ask questions by comments. Unfortunately, the authors only know English, so we can't answer you if you write comments in Russian.500A - Транспорт на Новый годLet's assume that I am in the cell i (1 ≤ i ≤ n). If i ≤ n - 1, I have two choices: to stay at cell i, or to go to cell (i + ai). If i = t, we are at the target cell, so I should print \"YES\" and terminate. If i > t, I cannot go to cell t because I can't use the portal backwards, so one should print \"NO\" and terminate. Otherwise, I must go to cell (i + ai).Using this method, I visit each cell at most once, and there are n cells, so the problem can be solved in linear time.What is test 13?There are 9 pretests in this problem. There are no test where n = t holds in pretests. Many people didn't handle this case, and got hacked or got Wrong Answer on test 13. Time: O(n) Memory: O(n) (maybe O(1)) Implementation: 9335683 500B - Новогодняя перестановкаIt seems that many contestants were confused by the statement, so let me clarify it first. Given a permutation p1, p2, ..., pn and a n × n-sized binary matrix A, the problem asks us to find the lexicographically minimum permutation which can be achieved by swapping two distinct elements pi and pj where the condition Ai, j = 1 holds. (From the statement, permutation A is prettier than permutation B if and only if A is lexicographically less than B.)Let's think matrix A as an adjacency matrix of a undirected unweighted graph.If two vertices i and j are in the same component (in other words, connected by some edges), the values of pi and pj can be swapped, using a method similar to bubble sort. Look at the picture below for easy understanding.Because all the two distinct vertices in the same component can be swapped, the vertices in the same component can be sorted. In conclusion, we can solve the problem by the following procedure. Find all the connected components. For each component, sort the elements in the component. Print the resulting permutation. The size limit is quite small, so one can use any algorithm (DFS/BFS/..) for as many times as you want. Time: O(n2) — because of the graph traversal. O(n3) is okay because of small constraints. Memory: O(n2) Implementation: 9335689 (.o.) What is test 15? There are too many wrong answers in this case.Actually, I made the pretests very weak in order to make many hacks. As mentioned in the Hack me! post by kostka, just swapping the elements greedily could pass the pretests easily. There were 14 pretests, and I made test 15 an counter-example of such algorithm in order to reduce judging time, and it seems that most of the wrong submissions failed in this test case :D500C - В Новый год --- с книгой!In order to calculate the minimum possible lifted weight, we should find the initial stack first. Let's find the positions one by one. First, let's decide the position of book b1. After day 1, book b1 will be on the top of the stack, regardless of the order of the initial stack. Therefore, in order to minimize the lifted weight during day 1, book b1 must be on the top of the initial stack. (so actually, in day 1, Jaehyun won't lift any book) Next, let's decide the position of book b2. (assume that b1 ≠ b2 for simplicity) Currently, b1 is on the top of the stack, and it cannot be changed because of the procedure. Therefore, in order to minimize the lifted weight during day 2, book b2 must be immediately below book b1. Considering this, we can find the optimal strategy to create the initial stack: Scan b1, b2, ..., bm step by step. Let's assume that I am handling bi now. If bi has appeared before (formally, if ), erase bi from the sequence. Otherwise, leave bi. The resulting sequence will be the optimal stack.You should note that it is not necessary for Jaehyun to read all the books during 2015, which means the size of the resulting sequence may be smaller than n. The books which doesn't appear in the resulting sequence must be in the bottom of the initial stack (obviously). However, this problem doesn't require us to print the initial stack, so it turned out not to be important. In conclusion, finding the initial stack takes O(n + m) time.After finding the initial stack, we can simulate the procedure given in the statement naively. It will take O(nm) time. Time: O(nm) Memory: O(n + m) Implementation: 9335694 (.o.) 500D - Новогоднее взаимодействие Санта-КлаусовThe problem asks us to calculate the value ofLet's write it down..So, we need to calculate the value of . I'll denote the sum as S. How should we calculate this?For simplicity, I'll set node 1 as the root of the tree. Let's focus on an edge e, connecting two vertices u and p. See the picture below.Set A is a set of vertices in the subtree of vertex u, and set B is a set of vertices which is not in the subtree of vertex u. So, is the set of vertices in the tree, and is empty.For all pairs of two vertices (x, y) where the condition and holds, the shortest path between x and y contains edge e. There are size(A) × size(B) such pairs. So, edge e increases the sum S by 2 × le × size(A) × size(B). (because d(x, y) and d(y, x) both contributes to S)size(A) (the size of the subtree whose root is u) can be calculated by dynamic programming in trees, which is well known. size(B) equals to N - size(A). So, for each edge e, we can pre-calculate how many times does this edge contributes to the total sum. Let's define t(e) = size(A) × size(B), (A and B is mentioned above). If the length of a certain road e decreases by d, S will decrease by t(e) × d. So we can answer each query. Time: O(n) (pre-calculation) + O(q) (query) Memory: O(n) (O(n + q) is okay too) Implementation: 9335695 (.o.) Something about precision errorBecause of the tight constraints, the total sum of d(a, b) + d(b, c) + d(c, a) (it is equal to S × (n - 2)) can be so large that it can't be saved in long long(64-bit integer) type. Some contestants didn't handle this and got WA. However, there are some contestants who saved this value divided by n × (n - 1) × (n - 2) in double type. double has 52 bits to store exact value, so it isn't enough. But because we allow 10 - 6 precision error, it seems to have been got accepted.What if we allowed the length of the road could become 0? Then the precision error gets much more bigger, and the solution prints something that is far from the expected value (for example, negative value). ainu7 discovered this effect and suggested to apply this, but we didn't because it was hard to fix the statement..Why does the road length decreases? It doesn't matter even if increases.It's because of the weird legend. It is hard to explain, \"People repairs a certain road per year, and its length may be increased or decreased.\" fluently for me..500E - Новогоднее доминоFrom the statement, it is clear that, when domino i falls to the right, it makes domino j also fall if and only if pi < pj ≤ pi + li.For each domino i, let's calculate the rightmost position of the fallen dominoes R[i] when we initially pushed domino i. From the definition, . This can be calculated by using a segment tree or using a stack, in decreasing order of i (from right to left). After that, we define U[i] as the smallest j where R[i] < pj holds. (In other words, the smallest j where domino j is not affected by pushing domino i)Now, the problem becomes: Calculate P[U[xi]] - R[xi] + P[U[U[xi]]] - R[U[xi]] + ..., until U[xi] ≤ yi. Because i < U[i], this task can be solved by precalculating 'jumps' of 2something times, using the method described in here. You must read the \"Another easy solution in <O(N logN, O(logN)>\" part..Formally, let's define Un + 1[k] = U[Un[k]] and Sn + 1[k] = Sn[k] + (P[Un + 1[k]] - R[Un[k]]). So, Sn[k] means the sum of domino length extensions when we initially push domino i and we prolonged the length exactly n times. U2i + 1[k] = U2i[U2i[k]], and S2i + 1[k] = S2i[k] + S2i[U2i[k]] holds. (If you don't understand this part, I suggest you to read the article linked above) Time : or . Memory : Implementation: 9335698 (.o.) We would like to know whether there is a linear offline solution or not. 500F - Новогодние покупки The i-th item is available during [ti, ti + p - 1]. In other words, at time T, item i is available if and only if ti ≤ T ≤ ti + p - 1. This can be re-written as (ti ≤ T and T - p + 1 ≤ ti), which is T - p + 1 ≤ ti ≤ T. With this observation, we can transform the item's purchasable range into a dot, and the candidate's visit time into a range: From now on, item i is only available at time ti. and each candidate pair (aj, bj) means that I can visit the store during [aj - p + 1, aj], and my budget is bj dollars at that visit. This transformation makes the problem easier to solve.Each red circled point denotes an item which is sold at that time, and each black interval denotes a candidate. Let's only consider the intervals which passes time T. All the intervals' length is exactly p, so the left bound of the interval is (T - p) and the right bound of the interval is (T + p). For each interval, we'd like to solve the 0/1 knapsack algorithm with the items that the interval contains. How can we do that effectively? There is an important fact that I've described above: all the interval passes time T. Therefore, the interval [aj - p + 1, aj] can be split into two intervals: [aj - p + 1, T - 1] and [T, aj].So, let's solve the 0/1 knapsack problem for all intervals [x, T - 1] (T - p ≤ x ≤ T - 1) and [T, y] (T ≤ y ≤ T + p). Because one of the endpoints is fixed, one can run a standard dynamic programming algorithm. Therefore, the time needed in precalculation is O(S × W), where S is the number of items where the condition holds.Let's define h(I, b), as the maximum happiness I can obtain by buying the items where the condition holds, using at most b dollars. For each candidate (aj, bj), we have to calculate h([aj - p + 1, aj], bj), which is equal to max0 ≤ k ≤ b{h([aj - p + 1, T - 1], k) + h([T, aj], b - k)}. So it takes O(bj) = O(W) time to solve each query.The only question left is: How should we choose the value of T? We have two facts. (1) The length of intervals is exactly p. (2) The algorithm covers intervals which passes time T. Therefore, to cover all the intervals given in the input, we should let T be p, 2p, 3p, 4p, ... (of course, one by one), and run the algorithm described above.Then, what is the total time complexity? Think of intervals [0, 2p], [p, 3p], [2p, 4p], [3p, 5p], .... For each point, there will be at most two intervals which contains the point. Therefore, each item is reflected in the pre-calculation at most twice, so the time needed to precalculate is O(n × W). The time needed to solve each query is O(bj), and the answer of the query is calculated at most once. Therefore, the time needed to answer all the queries is O(q × W). Time : O((n + q) × W). Memory : O(n × W) Implementations: 9335699 (ainta), 9335703 (ainu7) , 9335710 (.o., using a different approach), 9335709 (.o., using a divide and conquer approach) Divide and Conquer approachLet's assume that t1 ≤ t2 ≤ ... ≤ tn. We can easily know that at time T, the indexes of all the available items forms a segment [l, r]. (in other words, item l, item l + 1, ..., item r - 1, item r is available) We can use this fact to solve all the queries. Let's assume that item lj, item lj + 1, ..., item rj - 1, item rj is available at time aj.Define a function solve(L, R). This function calculates the answer for queries where the condition L ≤ lj ≤ rj ≤ R holds. Let's assume that L < R holds. (In the case L ≥ R, the answer can be calculated easily) Let . Call solve(L, M) and solve(M + 1, R). After that, the queries needed to be calculated, satisfies the condition lj ≤ M < rj, which means all the intervals(queries) passes item M. Now, to calculate the answer for such queries, we can use the method described at the dynamic programming approach.The time complexity is , because and the answer of the queries can be calculated in O(bj) per query. Time : . Memory : O(n × W) Implementation: 9335709 Unfortunately, this approach is offline, because of the memory. Is there any available online approach using divide and conquer?Blocking the divide and conquer solutionI tried my best to block divide and conquer solutions, but failed. It seems that many participants solved the problem with divide and conquer approach. My approach takes time, and it gets accepted in 546ms.500G - Новогодний забегBefore starting the editorial, I'd like to give a big applause to Marcin_smu, who solved the problem for the first time!Warning: The editorial is very long and has many mistakes. There are lots of lots of mistakes.. Keep calm, and please tell me by comments, if you discovered any errors.This problem can be solved by an online algorithm. Let's focus on a single query (u, v, x, y). This means that JH runs between u and v, and JY runs between x and y.Just like when we solve many problems with undirected trees, let vertex 1 be the root of the tree. Also, we will assume that they won't stop after when they meet, but they will continue running, in order to explain easily.Some definitions: Path (a, b): the shortest path between vertex a and vertex b. d(a, b): the length of Path (a, b). LCA(a, b): the lowest common ancestor of vertex a and vertex b. Finding the common path of two pathsIf there is no common vertex between Path (u, v) and Path (x, y), the answer will be obviously  - 1. So, let's find the common vertices first. Because the path between two vertices is always unique, the common vertices also form a path. So, I'll denote the path of the common vertices as Path (c1, c2). c1 and c2 may be equal to: u, v, x, y, and even each other.The possible endpoints are P1 = LCA(u, v), P2 = LCA(x, y), P3 = LCA(u, x), P4 = LCA(u, y), P5 = LCA(v, x), and P6 = LCA(v, y). Figure out by drawing some examples. (some of you might think it's obvious :D)See the pictures above, and make your own criteria to check whether the two paths intersects :DA small hint. Let's assume that we already know, that a vertex a lies on path (x, y). If a lies on path (u, v), a is a common vertex of two paths. What if a is guaranteed to be an end point of the common path?Additional definitions Let's denote JH's running course is: . Then, there are two possible courses for JY: and ). fJH : the time needed to run the course . fJY : the time needed to run the course . t1 : the first time when JH passes vertex c1, moving towards c2. t2 : the first time when JH passes vertex c2, moving towards c1. t3 : the first time when JY passes vertex c1, moving towards c2. t4 : the first time when JY passes vertex c2, moving towards c1. Case 1) When JH and JY meets while moving in the same directionObviously, they must meet at vertex c1 or vertex c2 for the first time. Without loss of generality, let's assume that they meet at vertex c1. In this case, both of them is moving towards vertex c2. (You can use the method similarly for c2) Let's assume that JH and JY meets at time T. Because the movements of both runners are periodic, T must satisfy the conditions below: Among possible T-s, we have to calculate the smallest value. How should we do? From the first condition, we can let T = fJH × p + t1, where p is a non-negative integer. With this, we can write the second condition as: . In conclusion, we have to find the smallest p which satisfies the condition Using the Extended Euclidean algorithm is enough to calculate the minimum p. With p, we can easily calculate the minimum T, which is the first time they meet. If there is no such p, they doesn't meet forever, so the answer is  - 1.Case 2) When JH and JY meets while moving in the opposite directionIn this case, they will meet at a vertex lying on Path (c1, c2). Without loss of generality, let's assume that JH is going from c1 to c2, and JY is going from c2 to c1.I'll assume that JH and JY meets at time T. [1] Let's see how JH moves: For all non-negative integer p, At time fJH × p + t1, he is at vertex c1, moving towards c2. At time fJH × p + t1 + d(c1, c2), he is at vertex c2. Therefore, when fJH × p + t1 ≤  (current time)  ≤ fJH × p + t1 + d(c1, c2), JH is on Path (c1, c2). So, T must satisfy the condition: fJH × p + t1 ≤ T ≤ fJH × p + t1 + d(c1, c2) [2] Let's see how JY moves: Similar to JH, for all non-negative integer q, At time fJY × q + t4, he is at vertex c2, moving towards c1. At time fJY × q + t4 + d(c2, c1), he is at vertex c1. Therefore, when fJY × q + t4 ≤  (current time)  ≤ fJY × q + t4 + d(c2, c1), JY is on Path (c2, c1). So, T must satisfy the condition: fJY × q + t4 ≤ T ≤ fJY × q + t4 + d(c1, c2) [3] These two conditions are not enough, because in this case, they can meet on an edge, but they cannot meet on a vertex.We'd like to know when do they meet on a vertex, like the picture below.As you see from the picture above, in this case, the condition d(c1, a) + d(a, c2) = d(c1, c2) holds. If this picture was taken at time s, this condition can be written as: {s - (fJH × p + t1)} + {s - (fJY × q + t4)} = d(c1, c2) 2s - (fJH × p + fJY × q) - (t1 + t4) = d(c1, c2) s = {d(c1, c2) + (fJH × p + fJY × q) + (t1 + t4)} / 2 Because JH and JY both travel their path back and forth, fJH and fJY are all even. Therefore, in order to make s an integer, d(c1, c2) + t1 + t4 must be even. This can be written as [4] Merging [1], [2] and [3], we can conclude that if these two conditions holds, max{fJH × p + t1, fJY × q + t4} ≤ min{fJH × p + t1 + d(c1, c2), fJY × p + t4 + d(c1, c2)} JH and JY meets on a certain vertex lying on path (c1, c2). The first condition can be easily checked, so let's focus on the second condition. The second condition holds if and only if: fJY × q + t4 - t1 - d ≤ fJH × p ≤ fJY × q + t4 - t1 + d You can check this by changing \"fJH × p\" to the lower bound and the upper bound of the inequality. Therefore, the problem is to find the smallest p which satisfies the condition above.Let's define a function g(M, D, L, R), where M, D, L, R are all non-negative integers. The function returns the smallest non-negative integer m which satisfies . This function can be implemented as follows. If L = 0, g(M, D, L, R) = 0. (because L = 0 ≤ D·0) If , it is \"obvious\" that there is no solution. If 2D > M, g(M, D, L, R) = g(M, M - D, M - R, M - L). If there exists an non-negative integer m which satisfies L ≤ D·m ≤ R (without modular condition), g(M, D, L, R) = m. Obviously, we should take the smallest m. Otherwise, there exists an integer m which satisfies D·m < L ≤ R < D·(m + 1). We should use this fact.. If holds, there exists an non-negative integer k which satisfies L + Mk ≤ D·m ≤ R + Mk. Let's write down.. D·m - R ≤ M·k ≤ D·m - L  - R ≤ M·k - D·m ≤  - L L ≤ D·m - M·k  ≤ RBecause , we can write the inequality as Therefore the minimum k among all possible solutions is equal to . We can easily calculate the smallest p using k. Then, what is the time complexity of calculating g(M, D, L, R)? Because 2D ≤ M (the 2D > M case is handled during step 3), the problem size becomes half, so it can be executed in .ConclusionFor each query, we have to consider both Case 1) and Case 2), with all possible directions. Both cases can be handled in , so the time complexity per query is , and it has really huge constant. Time: Memory: Implementation: 9330235",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/15488",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 500\\s*D"
          },
          "content_length": 19579
        }
      ],
      "code_examples": [
        {
          "title": "Good Bye 2014 - Codeforces - Code 1",
          "code": "division combined",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15465",
          "author": "Qingyu"
        },
        {
          "title": "Good Bye 2014 - Codeforces - Code 2",
          "code": "3\n3 1 2\n011\n100\n100",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15465",
          "author": "Qingyu"
        },
        {
          "title": "Good Bye 2014 - Codeforces - Code 3",
          "code": "3\n3 1 2\n011\n100\n100",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15465",
          "author": "Qingyu"
        },
        {
          "title": "Good Bye 2014 - Codeforces - Code 4",
          "code": "(3,2) (1,2)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15465",
          "author": "Qingyu"
        },
        {
          "title": "Good Bye 2014 - Codeforces - Code 5",
          "code": "7\n7 3 4 6 8 1 2\n0010000\n0001000\n0000100\n0000000\n0000001\n1000000\n0000000",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15465",
          "author": "Qingyu"
        },
        {
          "title": "Good Bye 2014 - Codeforces - Code 6",
          "code": "7\n7 3 4 6 8 1 2\n0010000\n0001000\n0000100\n0000000\n0000001\n1000000\n0000000",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15465",
          "author": "Qingyu"
        },
        {
          "title": "Good Bye 2014 - Codeforces - Code 7",
          "code": "1 3 2 6 4 7 8",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15465",
          "author": "Qingyu"
        },
        {
          "title": "Good Bye 2014 - Codeforces - Code 8",
          "code": "2 3 4 6 7 1 8",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15465",
          "author": "Qingyu"
        },
        {
          "title": "Good Bye 2014 - Codeforces - Code 9",
          "code": "3\n3 1 2\n011\n100\n100",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15465",
          "author": "Qingyu"
        },
        {
          "title": "Good Bye 2014 - Codeforces - Code 10",
          "code": "3\n3 1 2\n011\n100\n100",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15465",
          "author": "Qingyu"
        },
        {
          "title": "Good Bye 2014 - Codeforces - Code 11",
          "code": "5\n2 4 1 3 5\n00101\n00010\n10011\n01100\n10100",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15465",
          "author": "Qingyu"
        },
        {
          "title": "Good Bye 2014 - Codeforces - Code 12",
          "code": "5\n2 4 1 3 5\n00101\n00010\n10011\n01100\n10100",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15465",
          "author": "Qingyu"
        },
        {
          "title": "Good Bye 2014 - Codeforces - Code 13",
          "code": "__mingw_printf",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15465",
          "author": "Qingyu"
        },
        {
          "title": "Good Bye 2014 Editorial - Codeforces - Code 1",
          "code": "3.0 / ((long long)n * (n-1))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15488",
          "author": "Qingyu"
        },
        {
          "title": "Good Bye 2014 Editorial - Codeforces - Code 2",
          "code": "actually the sorting is o(q*log(q))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15488",
          "author": "Qingyu"
        },
        {
          "title": "Good Bye 2014 Editorial - Codeforces - Code 3",
          "code": "actually the sorting is o(q*log(q))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15488",
          "author": "Qingyu"
        },
        {
          "title": "Good Bye 2014 Editorial - Codeforces - Code 4",
          "code": "upper_bound",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15488",
          "author": "Qingyu"
        },
        {
          "title": "Good Bye 2014 Editorial - Codeforces - Code 5",
          "code": "merge_group(i, j)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15488",
          "author": "Qingyu"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAXN = 100005;\n\nint parent[MAXN];\n\nint find(int x) {\n    if (parent[x] != x)\n        parent[x] = find(parent[x]);\n    return parent[x];\n}\n\nbool unite(int x, int y) {\n    x = find(x);\n    y = find(y);\n    if (x == y)\n        return false; // cycle detected\n    parent[y] = x;\n    return true;\n}\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(3, 100000, \"n\");\n    inf.readEoln();\n\n    int n_edges = n - 1;\n\n    for (int i = 1; i <= n; ++i)\n        parent[i] = i;\n\n    vector<int> current_length(n_edges + 1); // index 1..n_edges\n\n    for (int i = 1; i <= n_edges; ++i) {\n        int ai = inf.readInt(1, n, \"ai\");\n        inf.readSpace();\n        int bi = inf.readInt(1, n, \"bi\");\n        inf.readSpace();\n        int li = inf.readInt(1, 1000, \"li\");\n        inf.readEoln();\n\n        ensuref(ai != bi, \"ai (%d) should not be equal to bi (%d)\", ai, bi);\n\n        if (!unite(ai, bi))\n            quitf(_fail, \"Graph contains a cycle between %d and %d\", ai, bi);\n\n        current_length[i] = li; // edge index from 1 to n - 1\n    }\n\n    // After processing all edges, check that all nodes are connected\n    int root = find(1);\n    for (int i = 2; i <= n; ++i) {\n        if (find(i) != root)\n            quitf(_fail, \"Graph is not connected\");\n    }\n\n    int q = inf.readInt(1, 100000, \"q\");\n    inf.readEoln();\n\n    for (int i = 0; i < q; ++i) {\n        int rj = inf.readInt(1, n_edges, \"rj\");\n        inf.readSpace();\n        int wj = inf.readInt(1, 1000, \"wj\");\n        inf.readEoln();\n\n        ensuref(wj < current_length[rj], \"At repair %d, wj (%d) should be less than current_length[rj=%d] (%d)\", i + 1, wj, rj, current_length[rj]);\n\n        current_length[rj] = wj;\n    }\n\n    inf.readEof();\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAXN = 100005;\n\nint parent[MAXN];\n\nint find(int x) {\n    if (parent[x] != x)\n        parent[x] = find(parent[x]);\n    return parent[x];\n}\n\nbool unite(int x, int y) {\n    x = find(x);\n    y = find(y);\n    if (x == y)\n        return false; // cycle detected\n    parent[y] = x;\n    return true;\n}\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(3, 100000, \"n\");\n    inf.readEoln();\n\n    int n_edges = n - 1;\n\n    for (int i = 1; i <= n; ++i)\n        parent[i] = i;\n\n    vector<int> current_length(n_edges + 1); // index 1..n_edges\n\n    for (int i = 1; i <= n_edges; ++i) {\n        int ai = inf.readInt(1, n, \"ai\");\n        inf.readSpace();\n        int bi = inf.readInt(1, n, \"bi\");\n        inf.readSpace();\n        int li = inf.readInt(1, 1000, \"li\");\n        inf.readEoln();\n\n        ensuref(ai != bi, \"ai (%d) should not be equal to bi (%d)\", ai, bi);\n\n        if (!unite(ai, bi))\n            quitf(_fail, \"Graph contains a cycle between %d and %d\", ai, bi);\n\n        current_length[i] = li; // edge index from 1 to n - 1\n    }\n\n    // After processing all edges, check that all nodes are connected\n    int root = find(1);\n    for (int i = 2; i <= n; ++i) {\n        if (find(i) != root)\n            quitf(_fail, \"Graph is not connected\");\n    }\n\n    int q = inf.readInt(1, 100000, \"q\");\n    inf.readEoln();\n\n    for (int i = 0; i < q; ++i) {\n        int rj = inf.readInt(1, n_edges, \"rj\");\n        inf.readSpace();\n        int wj = inf.readInt(1, 1000, \"wj\");\n        inf.readEoln();\n\n        ensuref(wj < current_length[rj], \"At repair %d, wj (%d) should be less than current_length[rj=%d] (%d)\", i + 1, wj, rj, current_length[rj]);\n\n        current_length[rj] = wj;\n    }\n\n    inf.readEof();\n\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAXN = 100005;\n\nint parent[MAXN];\n\nint find(int x) {\n    if (parent[x] != x)\n        parent[x] = find(parent[x]);\n    return parent[x];\n}\n\nbool unite(int x, int y) {\n    x = find(x);\n    y = find(y);\n    if (x == y)\n        return false; // cycle detected\n    parent[y] = x;\n    return true;\n}\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(3, 100000, \"n\");\n    inf.readEoln();\n\n    int n_edges = n - 1;\n\n    for (int i = 1; i <= n; ++i)\n        parent[i] = i;\n\n    vector<int> current_length(n_edges + 1); // index 1..n_edges\n\n    for (int i = 1; i <= n_edges; ++i) {\n        int ai = inf.readInt(1, n, \"ai\");\n        inf.readSpace();\n        int bi = inf.readInt(1, n, \"bi\");\n        inf.readSpace();\n        int li = inf.readInt(1, 1000, \"li\");\n        inf.readEoln();\n\n        ensuref(ai != bi, \"ai (%d) should not be equal to bi (%d)\", ai, bi);\n\n        if (!unite(ai, bi))\n            quitf(_fail, \"Graph contains a cycle between %d and %d\", ai, bi);\n\n        current_length[i] = li; // edge index from 1 to n - 1\n    }\n\n    // After processing all edges, check that all nodes are connected\n    int root = find(1);\n    for (int i = 2; i <= n; ++i) {\n        if (find(i) != root)\n            quitf(_fail, \"Graph is not connected\");\n    }\n\n    int q = inf.readInt(1, 100000, \"q\");\n    inf.readEoln();\n\n    for (int i = 0; i < q; ++i) {\n        int rj = inf.readInt(1, n_edges, \"rj\");\n        inf.readSpace();\n        int wj = inf.readInt(1, 1000, \"wj\");\n        inf.readEoln();\n\n        ensuref(wj < current_length[rj], \"At repair %d, wj (%d) should be less than current_length[rj=%d] (%d)\", i + 1, wj, rj, current_length[rj]);\n\n        current_length[rj] = wj;\n    }\n\n    inf.readEof();\n\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst double EPS = 1E-6;\n\nint main(int argc, char* argv[]) {\n    registerTestlibCmd(argc, argv);\n\n    vector<double> jury_ans;\n    vector<double> part_ans;\n\n    while (!ans.seekEof()) {\n        double t = ans.readDouble();\n        jury_ans.push_back(t);\n    }\n\n    while (!ouf.seekEof()) {\n        double t = ouf.readDouble();\n        part_ans.push_back(t);\n    }\n\n    if (jury_ans.size() != part_ans.size()) {\n        quitf(_wa, \"Different number of outputs: expected %d numbers, but participant output %d numbers\", int(jury_ans.size()), int(part_ans.size()));\n    }\n\n    for (size_t i = 0; i < jury_ans.size(); i++) {\n        double expected = jury_ans[i];\n        double found = part_ans[i];\n        if (isnan(found) || isinf(found)) {\n            quitf(_wa, \"Participant's answer is NaN or Infinity at position %d\", int(i + 1));\n        }\n        double diff = fabs(expected - found);\n        if (fabs(expected) < 1e-9) {\n            if (diff > EPS) {\n                quitf(_wa, \"Wrong answer at position %d: expected %.10f, found %.10f, absolute error %.10f exceeds %e\", int(i + 1), expected, found, diff, EPS);\n            }\n        } else {\n            double rel_error = diff / fabs(expected);\n            if (diff > EPS && rel_error > EPS) {\n                quitf(_wa, \"Wrong answer at position %d: expected %.10f, found %.10f, absolute error %.10f, relative error %.10f exceed %e\", int(i + 1), expected, found, diff, rel_error, EPS);\n            }\n        }\n    }\n\n    quitf(_ok, \"All answers are correct within acceptable error\");\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\n/*\n  Generator for the \"Tree World\" problem.\n\n  Usage:\n    ./gen -n <number_of_cities> -q <number_of_updates> -type <tree_shape>\n  where <tree_shape> can be one of {chain, star, random}, default is \"random\".\n\n  This generator:\n  1) Produces a tree of n vertices in the specified shape.\n  2) Assigns each edge a length of 1000 initially (so we have room to decrease).\n  3) Prints n, then the n-1 edges.\n  4) Prints q.\n  5) Prints q updates (r_j, w_j). Each update chooses a random edge whose length > 1\n     and decreases its length by exactly 1.\n  \n  Important:\n    - We rely on (n-1) * 999 >= q to ensure we can always find an edge > 1 for each update.\n    - If you choose n, q such that (n-1)*999 < q, this generator may fail to produce valid output.\n    - We DO NOT set or accept a random seed. testlib's registerGen() handles randomness.\n*/\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int q = opt<int>(\"q\");\n    string shape = opt<string>(\"type\", \"random\");\n\n    // Step 1: build a parent array to form a particular tree structure\n    // p[i] = parent of node i (where i ranges 1..n-1, with root at node 0)\n    // We'll store edges as (parent[i], i).\n    vector<int> parent(n, 0);\n\n    if (shape == \"chain\") {\n        // chain: 0 - 1 - 2 - ... - (n-1)\n        for (int i = 1; i < n; i++) {\n            parent[i] = i - 1;\n        }\n    } \n    else if (shape == \"star\") {\n        // star: all children of node 0\n        for (int i = 1; i < n; i++) {\n            parent[i] = 0;\n        }\n    } \n    else {\n        // random tree\n        for (int i = 1; i < n; i++) {\n            parent[i] = rnd.next(i); \n            // ensures a valid parent among [0..i-1], creating a tree\n        }\n    }\n\n    // Step 2: Create edges. We'll label them in the order i=1..n-1\n    // Edge i => (parent[i], i)\n    // Each edge has length = 1000.\n    vector<int> A(n-1), B(n-1), L(n-1, 1000);\n    for (int i = 1; i < n; i++) {\n        A[i-1] = parent[i];\n        B[i-1] = i;\n    }\n\n    // Step 3: Print n\n    cout << n << \"\\n\";\n\n    // Step 4: Print the edges in 1-based indexing. \n    // i-th edge in input has index i, connect (A[i-1]+1, B[i-1]+1), length L[i-1].\n    for (int i = 0; i < n - 1; i++) {\n        cout << A[i] + 1 << \" \" \n             << B[i] + 1 << \" \" \n             << L[i] << \"\\n\";\n    }\n\n    // Step 5: Print q\n    cout << q << \"\\n\";\n\n    // Step 6: Produce q valid updates.\n    // For each update:\n    //  1) pick a random edge e with L[e] > 1\n    //  2) L[e]--\n    //  3) print (e+1, L[e])\n    // We do up to 100 attempts to find an edge with L[e]>1 each time.\n    // If it fails, we assume the user gave incompatible (n,q).\n    // In a real contest environment, we'd either error out or produce invalid input,\n    // but here we'll produce a runtime error if we cannot find a valid edge.\n\n    for (int i = 0; i < q; i++) {\n        int tries = 100;\n        int e = -1;\n        while (tries--) {\n            int cand = rnd.next(0, n-2);\n            if (L[cand] > 1) {\n                e = cand;\n                break;\n            }\n        }\n        // If still e == -1, we cannot make a valid next update => stop or error.\n        if (e == -1) {\n            // If you want to gracefully stop, you could break,\n            // but that would produce fewer than q updates.\n            // Here, we'll just force an error for mismatch between n and q.\n            cerr << \"Cannot find an edge with length > 1. Invalid (n, q) combination.\\n\";\n            // produce a forced runtime error\n            assert(false);\n        }\n        // Decrease that edge by 1\n        L[e]--;\n        // Print the update: r_j = e+1, w_j = L[e]\n        cout << (e + 1) << \" \" << L[e] << \"\\n\";\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\n/*\n  Generator for the \"Tree World\" problem.\n\n  Usage:\n    ./gen -n <number_of_cities> -q <number_of_updates> -type <tree_shape>\n  where <tree_shape> can be one of {chain, star, random}, default is \"random\".\n\n  This generator:\n  1) Produces a tree of n vertices in the specified shape.\n  2) Assigns each edge a length of 1000 initially (so we have room to decrease).\n  3) Prints n, then the n-1 edges.\n  4) Prints q.\n  5) Prints q updates (r_j, w_j). Each update chooses a random edge whose length > 1\n     and decreases its length by exactly 1.\n  \n  Important:\n    - We rely on (n-1) * 999 >= q to ensure we can always find an edge > 1 for each update.\n    - If you choose n, q such that (n-1)*999 < q, this generator may fail to produce valid output.\n    - We DO NOT set or accept a random seed. testlib's registerGen() handles randomness.\n*/\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int q = opt<int>(\"q\");\n    string shape = opt<string>(\"type\", \"random\");\n\n    // Step 1: build a parent array to form a particular tree structure\n    // p[i] = parent of node i (where i ranges 1..n-1, with root at node 0)\n    // We'll store edges as (parent[i], i).\n    vector<int> parent(n, 0);\n\n    if (shape == \"chain\") {\n        // chain: 0 - 1 - 2 - ... - (n-1)\n        for (int i = 1; i < n; i++) {\n            parent[i] = i - 1;\n        }\n    } \n    else if (shape == \"star\") {\n        // star: all children of node 0\n        for (int i = 1; i < n; i++) {\n            parent[i] = 0;\n        }\n    } \n    else {\n        // random tree\n        for (int i = 1; i < n; i++) {\n            parent[i] = rnd.next(i); \n            // ensures a valid parent among [0..i-1], creating a tree\n        }\n    }\n\n    // Step 2: Create edges. We'll label them in the order i=1..n-1\n    // Edge i => (parent[i], i)\n    // Each edge has length = 1000.\n    vector<int> A(n-1), B(n-1), L(n-1, 1000);\n    for (int i = 1; i < n; i++) {\n        A[i-1] = parent[i];\n        B[i-1] = i;\n    }\n\n    // Step 3: Print n\n    cout << n << \"\\n\";\n\n    // Step 4: Print the edges in 1-based indexing. \n    // i-th edge in input has index i, connect (A[i-1]+1, B[i-1]+1), length L[i-1].\n    for (int i = 0; i < n - 1; i++) {\n        cout << A[i] + 1 << \" \" \n             << B[i] + 1 << \" \" \n             << L[i] << \"\\n\";\n    }\n\n    // Step 5: Print q\n    cout << q << \"\\n\";\n\n    // Step 6: Produce q valid updates.\n    // For each update:\n    //  1) pick a random edge e with L[e] > 1\n    //  2) L[e]--\n    //  3) print (e+1, L[e])\n    // We do up to 100 attempts to find an edge with L[e]>1 each time.\n    // If it fails, we assume the user gave incompatible (n,q).\n    // In a real contest environment, we'd either error out or produce invalid input,\n    // but here we'll produce a runtime error if we cannot find a valid edge.\n\n    for (int i = 0; i < q; i++) {\n        int tries = 100;\n        int e = -1;\n        while (tries--) {\n            int cand = rnd.next(0, n-2);\n            if (L[cand] > 1) {\n                e = cand;\n                break;\n            }\n        }\n        // If still e == -1, we cannot make a valid next update => stop or error.\n        if (e == -1) {\n            // If you want to gracefully stop, you could break,\n            // but that would produce fewer than q updates.\n            // Here, we'll just force an error for mismatch between n and q.\n            cerr << \"Cannot find an edge with length > 1. Invalid (n, q) combination.\\n\";\n            // produce a forced runtime error\n            assert(false);\n        }\n        // Decrease that edge by 1\n        L[e]--;\n        // Print the update: r_j = e+1, w_j = L[e]\n        cout << (e + 1) << \" \" << L[e] << \"\\n\";\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Below are approximately 20 distinct ways to run the generator.\n# Each command prints one test case to stdout, with the given n, q, and tree type.\n# Note: To generate valid data, please ensure that (n-1)*999 >= q.\n\n./gen -n 3 -q 1 -type chain\n./gen -n 3 -q 1 -type star\n./gen -n 3 -q 2 -type random\n\n./gen -n 4 -q 3 -type chain\n./gen -n 5 -q 5 -type random\n./gen -n 10 -q 9 -type star\n./gen -n 10 -q 50 -type random\n\n./gen -n 50 -q 49 -type chain\n./gen -n 50 -q 100 -type star\n./gen -n 100 -q 50 -type random\n./gen -n 100 -q 500 -type chain\n\n./gen -n 200 -q 1000 -type random\n./gen -n 500 -q 2000 -type star\n./gen -n 500 -q 499 -type random\n\n./gen -n 1000 -q 999 -type chain\n./gen -n 1000 -q 10000 -type random\n\n./gen -n 5000 -q 9999 -type star\n./gen -n 10000 -q 5000 -type random\n\n./gen -n 50000 -q 99999 -type star\n./gen -n 100000 -q 100000 -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:40:05.266122",
        "total_tutorials": 3,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "500/E",
      "title": "E. Новогоднее домино",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест2 секунды",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеВ первой строке содержится целое число n (2 ≤ n ≤ 2 × 105)— количество доминошек.В следующих n строках описываются доминошки. В i-й строке (1 ≤ i ≤ n) записано два целых числа через пробел pi, li (1 ≤ pi, li ≤ 109)— x-координата и длина i-й доминошки. Гарантируется, что p1 < p2 < ... < pn - 1 < pn.В следующей строке содержится целое число q (1 ≤ q ≤ 2 × 105) — количество планов.Следующие q строк описывают планы. В j-ой строке (1 ≤ j ≤ q) записано два целых числа через пробел xj, yj (1 ≤ xj < yj ≤ n). Это означает, что j-ый план заключается в том, чтобы толкнуть xj-ю доминошку и снимать видео, пока не упадет yj-я доминошка.",
      "output_spec": "Выходные данныеДля каждого плана выведите строку, содержащую минимальную стоимость, необходимую для его реализации. Если никаких затрат не требуется, выведите 0.",
      "sample_tests": "ПримерыВходные данныеСкопировать61 53 34 49 210 112 141 22 42 52 6Выходные данныеСкопировать0112",
      "description": "E. Новогоднее домино\n\nограничение по времени на тест2 секунды\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвыводstdout\n\nВходные данныеВ первой строке содержится целое число n (2 ≤ n ≤ 2 × 105)— количество доминошек.В следующих n строках описываются доминошки. В i-й строке (1 ≤ i ≤ n) записано два целых числа через пробел pi, li (1 ≤ pi, li ≤ 109)— x-координата и длина i-й доминошки. Гарантируется, что p1 < p2 < ... < pn - 1 < pn.В следующей строке содержится целое число q (1 ≤ q ≤ 2 × 105) — количество планов.Следующие q строк описывают планы. В j-ой строке (1 ≤ j ≤ q) записано два целых числа через пробел xj, yj (1 ≤ xj < yj ≤ n). Это означает, что j-ый план заключается в том, чтобы толкнуть xj-ю доминошку и снимать видео, пока не упадет yj-я доминошка.\n\nВходные данные\n\nВыходные данныеДля каждого плана выведите строку, содержащую минимальную стоимость, необходимую для его реализации. Если никаких затрат не требуется, выведите 0.\n\nВыходные данные\n\nВходные данныеСкопировать61 53 34 49 210 112 141 22 42 52 6Выходные данныеСкопировать0112\n\nВходные данныеСкопировать61 53 34 49 210 112 141 22 42 52 6\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать0112\n\nВыходные данныеСкопировать\n\nСкопировать\n\nПримечаниеРассмотрим пример. Доминошки расставлены как на картинке ниже.  Посмотрим на 4-й план. Для того, чтобы 2-я доминошка привела к падению 6-й, третью доминошку (с x-координатой 4) надо увеличить на 1, и 5-ю доминошку (с x-координатой 10) надо увеличить на 1 (альтернативный вариант — вместо 5-й доминошки можно также увеличить 4-ю доминошку на 1). Затем доминошки попадают так, как указано на картинке ниже. Каждый крестик обозначет соприкосновение двух доминошек.",
      "solutions": [
        {
          "title": "Good Bye 2014 - Codeforces",
          "content": "Привет, Codeforces!Добро пожаловать на последний раунд Codeforces в 2014 году, Good Bye 2014! Этот раунд очень необычный; Во-первых, раунд начинается 30 декабря в 18:00 по Москве. Во-вторых, раунд длится 2.5 часа. И в третьих, раунд будет общим для двух дивизионов, что означает, что Div1- и Div2-участники не будут разделены.Задачи подготовлены мной (.o.) и Seunghyun Jo (ainta). Это наш второй раунд на Codeforces. После нашего первого раунда случился чёрный день Codeforces, и мы надеемся, что в этот раз ничего подобного не произойдёт :DСпасибо Won-seok Yoo(ainu7), который тестировал раунд и обусждал с нами набор задач.Также мы хотим поблагодарить некоторых людей, без которых этот раунд не состоялся бы. Максим Ахмедов (Zlobober) сильно помог нам в подготовке задач. Мария Белова (Delinur) перевела условия задач на русский язык. Михаил Мирзаянов (MikeMirzayanov) создал прекрасные сайт Codeforces и систему Polygon. Они также заслуживают аплодисменты!Разбалловка будет оглашена перед началом раунда, как обычно.Мы желаем вам всем удачи. С новым годом!Просьба оставлять комментарии на английском языке, если вы хотите, чтобы авторы смогли их прочитать.UPD (2014-12-30 17:34:48) Разбалловка будет выглядеть следующим образом: 500-1000-1000-1500-2750-2750-3500.UPD (2014-12-31 12:49:05) Sorry for updating in English. Round has finished, congratulations to the winners! tourist Petr rng_58 HYPERHYPERHYPERCUBELOVER subscriber Merkurev al13n mmaxio mexmans GlebsHP Also, thanks to Marcin_smu, who solved problem G after the contest for the first time.UPD(2014-12-31 12:51:08) Sorry for updating in English. Editorial is published. Currently, only A-F is available, but I will add G as soon as possible. Sorry for the late editorial.UPD(2015-01-02 21:30:44) I wrote the editorial of G. Sorry for the late update..",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/15465",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.6,
            "reason": "宽松匹配: 包含题目编号 500 和字母"
          },
          "content_length": 1816
        },
        {
          "title": "Good Bye 2014 Tutorial - Codeforces",
          "content": "500A — New Year TransportationIn this problem we are given a directed graph, and asked whether a particular vertex is reachable from vertex 1. It is possible to solve this by running a depth-first search starting from vertex 1.Since every vertex has at most one outgoing edge, it is possible to write the DFS as a simple loop. Some people used this to make very short submissions.500B — New Year PermutationImagine a graph with one vertex for each entry in the permutation, and edges between pairs of swappable entries. It is easy to see that no matter how many swaps we make, no entry can end up in a location that is not in its connected component. We can also show that within any connected component, we can achieve any rearrangement of the entries that we wish.Since we want to make the lexicographically smallest permutation, we should greedily rearrange the entries within each connected component so that they are in increasing order.N ≤ 300, so we are not concerned with runtime. One can determine the connected components using a number of standard algorithms (Floyd-Warshall, Union Find, etc.).500C — New Year Book ReadingConsider an arbitrary day d, on which we must read book b. Let d' be the last day before d on which book b was read (if there is no previous day, let d' =  - ∞). Observe that, on day d, we cannot avoid lifting all of the books read on any day between d' and d. If we add up all the weights of these required liftings, we will have a lower bound on the answer.This lower bound can be computed with two loops, in O(M2) time. We must be sure not to add a book's weight multiple times, if it was read multiple times in the interval (d', d).If we initially arrange the books in order of the first day on which they are read, we will achieve the described lower bound. So, we have our answer.500D — New Year Santa NetworkBy linearity of expectation, E(d(c1, c2) + d(c1, c3) + d(c2, c3)) = E(d(c1, c2)) + E(d(c1, c3)) + E(d(c2, c3)). By symmetry, those three values are all equal. So, we need only compute E(d(c1, c2)). We can multiply it by 3 to find the answer.Let us imagine that a random selection (c1, c2, c3) is made. We'll define a function f(j), for each edge j, so that f(j) = wj if j is part of the shortest path from c1 to c2, and f(j) = 0 otherwise. Observe that . Again by linearity, we have .We can write E(f(j)) = wj·P(j), where P(j) is the probability that edge j is included in the path from c1 to c2. If we compute P(j) for all j, we can then compute in O(N). Also, we can handle updates in O(1); if wj changes to w'j, we subtract wj·P(j) from the answer, and add w'j·P(j). So, let's figure out P(j) for each j. Any edge j, if removed from the tree, separates the graph into two separate connected components a and b. Edge j will be included in the shortest path from c1 to c2 if and only if one of them is in a, and the other is in b. So, we want the number of ways to select (c1, c2, c3) such that c1 and c2 are on opposite sides of edge j, divided by the total number of ways to select (c1, c2, c3). Let's have |a| and |b| denote the number of vertices in a and b, respectively. Then .To figure out |a| and |b| for each j, we can root the tree arbitrarily and compute the depth and subtree size for each vertex in O(N) time. Then for an edge j, if vj is the deeper vertex incident to j, we know one component has size equal to the subtree size of vj. For the other component, we use the fact that |b| = N - |a|. 500E — New Year DominoWhen domino i is knocked over, it covers the interval [pi, pi + li]. If we see a query (xj, yj), it is equivalent to the question \"If we knock over all dominoes with index , how much of the interval [pxj, pyj] won't be covered?\" We can modify that question a little more, to say that we knock over all dominoes with index i ≥ xj, without changing its answer. Now, consider knocking over the dominoes from right to left. As soon as we knock over domino i, we will immediately process all of the queries with xj = i, and record their answers. What we need is a data structure that supports two operations: \"cover range [pi, pi + li]\" (when we knock over a domino) and \"compute how much of the range [pxj, pyj] is not covered\" (when we wish to answer a query). This can be done using coordinate compression and a segment tree. It's worth noting there are a lot of other ways to solve this problem. The other tutorial uses a completely different approach. Also, the approach described here may be implemented using different data structures. For example, here is my implementation using BBSTs and a Binary Indexed Tree.500F — New Year ShoppingWe will use the standard dynamic programming approach for 0/1 knapsack. To summarize what it does for us, imagine we are given an ordered list of items (ci, hi). Let F(k, b) be the maximum happiness we can buy, if we consider only the first k items in the list, and have a budget of b. If K is the size of the list, and B is the maximum possible budget, we can compute F(k, b) for all possible k and b in O(KB) time.Let us sort all of the items by their display time. Suppose that we focus on the queries (aj, bj) with , for some particular t. Let A be a list of the items with display time in (t - P, t], and let B be a list of the items with display time in (t, t + P). Let both lists be sorted in order of display time.Every query with will have available to it some suffix of A, along with some prefix of B. We'll do a knapsack DP on the elements of A, in reverse order, and another on the elements of B, in normal order. Finally, to answer any query (aj, bj) with , we can consider all possible ways to split the budget bj between the items in A and the items in B, in linear time. For each possible way to split the budget, we need simply look up one value from each DP table to know the maximum possible happiness.If we perform the process above on t = 1, 1 + P, 1 + 2P, 1 + 3P, ... until t exceeds the maximum possible day D, we'll be able to answer all of the queries. Let's think about the runtime of this solution. For each t, the described process takes O(KB) time, where K is the number of items whose display time is in (t - P, t + P). Each object can only appear in up to two of these intervals. So, the overall runtime for all of the knapsack DP's we perform is O(nB). Computing the final answer takes O(B) per query, or O(qB) overall.500G — New Year RunningDon't know how to solve this yet. Maybe someone who is not gray can provide the solution. :)",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/15513",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 500\\s*E"
          },
          "content_length": 6486
        },
        {
          "title": "Good Bye 2014 Editorial - Codeforces",
          "content": "First of all, sorry for the late editorial. I was too exhausted and immediately went to bed after the round finished, and didn't write the editorial.There are many pictures in this editorial, to cover up my poor English skills! If you have detected any errors or have questions, feel free to ask questions by comments. Unfortunately, the authors only know English, so we can't answer you if you write comments in Russian.500A - Транспорт на Новый годLet's assume that I am in the cell i (1 ≤ i ≤ n). If i ≤ n - 1, I have two choices: to stay at cell i, or to go to cell (i + ai). If i = t, we are at the target cell, so I should print \"YES\" and terminate. If i > t, I cannot go to cell t because I can't use the portal backwards, so one should print \"NO\" and terminate. Otherwise, I must go to cell (i + ai).Using this method, I visit each cell at most once, and there are n cells, so the problem can be solved in linear time.What is test 13?There are 9 pretests in this problem. There are no test where n = t holds in pretests. Many people didn't handle this case, and got hacked or got Wrong Answer on test 13. Time: O(n) Memory: O(n) (maybe O(1)) Implementation: 9335683 500B - Новогодняя перестановкаIt seems that many contestants were confused by the statement, so let me clarify it first. Given a permutation p1, p2, ..., pn and a n × n-sized binary matrix A, the problem asks us to find the lexicographically minimum permutation which can be achieved by swapping two distinct elements pi and pj where the condition Ai, j = 1 holds. (From the statement, permutation A is prettier than permutation B if and only if A is lexicographically less than B.)Let's think matrix A as an adjacency matrix of a undirected unweighted graph.If two vertices i and j are in the same component (in other words, connected by some edges), the values of pi and pj can be swapped, using a method similar to bubble sort. Look at the picture below for easy understanding.Because all the two distinct vertices in the same component can be swapped, the vertices in the same component can be sorted. In conclusion, we can solve the problem by the following procedure. Find all the connected components. For each component, sort the elements in the component. Print the resulting permutation. The size limit is quite small, so one can use any algorithm (DFS/BFS/..) for as many times as you want. Time: O(n2) — because of the graph traversal. O(n3) is okay because of small constraints. Memory: O(n2) Implementation: 9335689 (.o.) What is test 15? There are too many wrong answers in this case.Actually, I made the pretests very weak in order to make many hacks. As mentioned in the Hack me! post by kostka, just swapping the elements greedily could pass the pretests easily. There were 14 pretests, and I made test 15 an counter-example of such algorithm in order to reduce judging time, and it seems that most of the wrong submissions failed in this test case :D500C - В Новый год --- с книгой!In order to calculate the minimum possible lifted weight, we should find the initial stack first. Let's find the positions one by one. First, let's decide the position of book b1. After day 1, book b1 will be on the top of the stack, regardless of the order of the initial stack. Therefore, in order to minimize the lifted weight during day 1, book b1 must be on the top of the initial stack. (so actually, in day 1, Jaehyun won't lift any book) Next, let's decide the position of book b2. (assume that b1 ≠ b2 for simplicity) Currently, b1 is on the top of the stack, and it cannot be changed because of the procedure. Therefore, in order to minimize the lifted weight during day 2, book b2 must be immediately below book b1. Considering this, we can find the optimal strategy to create the initial stack: Scan b1, b2, ..., bm step by step. Let's assume that I am handling bi now. If bi has appeared before (formally, if ), erase bi from the sequence. Otherwise, leave bi. The resulting sequence will be the optimal stack.You should note that it is not necessary for Jaehyun to read all the books during 2015, which means the size of the resulting sequence may be smaller than n. The books which doesn't appear in the resulting sequence must be in the bottom of the initial stack (obviously). However, this problem doesn't require us to print the initial stack, so it turned out not to be important. In conclusion, finding the initial stack takes O(n + m) time.After finding the initial stack, we can simulate the procedure given in the statement naively. It will take O(nm) time. Time: O(nm) Memory: O(n + m) Implementation: 9335694 (.o.) 500D - Новогоднее взаимодействие Санта-КлаусовThe problem asks us to calculate the value ofLet's write it down..So, we need to calculate the value of . I'll denote the sum as S. How should we calculate this?For simplicity, I'll set node 1 as the root of the tree. Let's focus on an edge e, connecting two vertices u and p. See the picture below.Set A is a set of vertices in the subtree of vertex u, and set B is a set of vertices which is not in the subtree of vertex u. So, is the set of vertices in the tree, and is empty.For all pairs of two vertices (x, y) where the condition and holds, the shortest path between x and y contains edge e. There are size(A) × size(B) such pairs. So, edge e increases the sum S by 2 × le × size(A) × size(B). (because d(x, y) and d(y, x) both contributes to S)size(A) (the size of the subtree whose root is u) can be calculated by dynamic programming in trees, which is well known. size(B) equals to N - size(A). So, for each edge e, we can pre-calculate how many times does this edge contributes to the total sum. Let's define t(e) = size(A) × size(B), (A and B is mentioned above). If the length of a certain road e decreases by d, S will decrease by t(e) × d. So we can answer each query. Time: O(n) (pre-calculation) + O(q) (query) Memory: O(n) (O(n + q) is okay too) Implementation: 9335695 (.o.) Something about precision errorBecause of the tight constraints, the total sum of d(a, b) + d(b, c) + d(c, a) (it is equal to S × (n - 2)) can be so large that it can't be saved in long long(64-bit integer) type. Some contestants didn't handle this and got WA. However, there are some contestants who saved this value divided by n × (n - 1) × (n - 2) in double type. double has 52 bits to store exact value, so it isn't enough. But because we allow 10 - 6 precision error, it seems to have been got accepted.What if we allowed the length of the road could become 0? Then the precision error gets much more bigger, and the solution prints something that is far from the expected value (for example, negative value). ainu7 discovered this effect and suggested to apply this, but we didn't because it was hard to fix the statement..Why does the road length decreases? It doesn't matter even if increases.It's because of the weird legend. It is hard to explain, \"People repairs a certain road per year, and its length may be increased or decreased.\" fluently for me..500E - Новогоднее доминоFrom the statement, it is clear that, when domino i falls to the right, it makes domino j also fall if and only if pi < pj ≤ pi + li.For each domino i, let's calculate the rightmost position of the fallen dominoes R[i] when we initially pushed domino i. From the definition, . This can be calculated by using a segment tree or using a stack, in decreasing order of i (from right to left). After that, we define U[i] as the smallest j where R[i] < pj holds. (In other words, the smallest j where domino j is not affected by pushing domino i)Now, the problem becomes: Calculate P[U[xi]] - R[xi] + P[U[U[xi]]] - R[U[xi]] + ..., until U[xi] ≤ yi. Because i < U[i], this task can be solved by precalculating 'jumps' of 2something times, using the method described in here. You must read the \"Another easy solution in <O(N logN, O(logN)>\" part..Formally, let's define Un + 1[k] = U[Un[k]] and Sn + 1[k] = Sn[k] + (P[Un + 1[k]] - R[Un[k]]). So, Sn[k] means the sum of domino length extensions when we initially push domino i and we prolonged the length exactly n times. U2i + 1[k] = U2i[U2i[k]], and S2i + 1[k] = S2i[k] + S2i[U2i[k]] holds. (If you don't understand this part, I suggest you to read the article linked above) Time : or . Memory : Implementation: 9335698 (.o.) We would like to know whether there is a linear offline solution or not. 500F - Новогодние покупки The i-th item is available during [ti, ti + p - 1]. In other words, at time T, item i is available if and only if ti ≤ T ≤ ti + p - 1. This can be re-written as (ti ≤ T and T - p + 1 ≤ ti), which is T - p + 1 ≤ ti ≤ T. With this observation, we can transform the item's purchasable range into a dot, and the candidate's visit time into a range: From now on, item i is only available at time ti. and each candidate pair (aj, bj) means that I can visit the store during [aj - p + 1, aj], and my budget is bj dollars at that visit. This transformation makes the problem easier to solve.Each red circled point denotes an item which is sold at that time, and each black interval denotes a candidate. Let's only consider the intervals which passes time T. All the intervals' length is exactly p, so the left bound of the interval is (T - p) and the right bound of the interval is (T + p). For each interval, we'd like to solve the 0/1 knapsack algorithm with the items that the interval contains. How can we do that effectively? There is an important fact that I've described above: all the interval passes time T. Therefore, the interval [aj - p + 1, aj] can be split into two intervals: [aj - p + 1, T - 1] and [T, aj].So, let's solve the 0/1 knapsack problem for all intervals [x, T - 1] (T - p ≤ x ≤ T - 1) and [T, y] (T ≤ y ≤ T + p). Because one of the endpoints is fixed, one can run a standard dynamic programming algorithm. Therefore, the time needed in precalculation is O(S × W), where S is the number of items where the condition holds.Let's define h(I, b), as the maximum happiness I can obtain by buying the items where the condition holds, using at most b dollars. For each candidate (aj, bj), we have to calculate h([aj - p + 1, aj], bj), which is equal to max0 ≤ k ≤ b{h([aj - p + 1, T - 1], k) + h([T, aj], b - k)}. So it takes O(bj) = O(W) time to solve each query.The only question left is: How should we choose the value of T? We have two facts. (1) The length of intervals is exactly p. (2) The algorithm covers intervals which passes time T. Therefore, to cover all the intervals given in the input, we should let T be p, 2p, 3p, 4p, ... (of course, one by one), and run the algorithm described above.Then, what is the total time complexity? Think of intervals [0, 2p], [p, 3p], [2p, 4p], [3p, 5p], .... For each point, there will be at most two intervals which contains the point. Therefore, each item is reflected in the pre-calculation at most twice, so the time needed to precalculate is O(n × W). The time needed to solve each query is O(bj), and the answer of the query is calculated at most once. Therefore, the time needed to answer all the queries is O(q × W). Time : O((n + q) × W). Memory : O(n × W) Implementations: 9335699 (ainta), 9335703 (ainu7) , 9335710 (.o., using a different approach), 9335709 (.o., using a divide and conquer approach) Divide and Conquer approachLet's assume that t1 ≤ t2 ≤ ... ≤ tn. We can easily know that at time T, the indexes of all the available items forms a segment [l, r]. (in other words, item l, item l + 1, ..., item r - 1, item r is available) We can use this fact to solve all the queries. Let's assume that item lj, item lj + 1, ..., item rj - 1, item rj is available at time aj.Define a function solve(L, R). This function calculates the answer for queries where the condition L ≤ lj ≤ rj ≤ R holds. Let's assume that L < R holds. (In the case L ≥ R, the answer can be calculated easily) Let . Call solve(L, M) and solve(M + 1, R). After that, the queries needed to be calculated, satisfies the condition lj ≤ M < rj, which means all the intervals(queries) passes item M. Now, to calculate the answer for such queries, we can use the method described at the dynamic programming approach.The time complexity is , because and the answer of the queries can be calculated in O(bj) per query. Time : . Memory : O(n × W) Implementation: 9335709 Unfortunately, this approach is offline, because of the memory. Is there any available online approach using divide and conquer?Blocking the divide and conquer solutionI tried my best to block divide and conquer solutions, but failed. It seems that many participants solved the problem with divide and conquer approach. My approach takes time, and it gets accepted in 546ms.500G - Новогодний забегBefore starting the editorial, I'd like to give a big applause to Marcin_smu, who solved the problem for the first time!Warning: The editorial is very long and has many mistakes. There are lots of lots of mistakes.. Keep calm, and please tell me by comments, if you discovered any errors.This problem can be solved by an online algorithm. Let's focus on a single query (u, v, x, y). This means that JH runs between u and v, and JY runs between x and y.Just like when we solve many problems with undirected trees, let vertex 1 be the root of the tree. Also, we will assume that they won't stop after when they meet, but they will continue running, in order to explain easily.Some definitions: Path (a, b): the shortest path between vertex a and vertex b. d(a, b): the length of Path (a, b). LCA(a, b): the lowest common ancestor of vertex a and vertex b. Finding the common path of two pathsIf there is no common vertex between Path (u, v) and Path (x, y), the answer will be obviously  - 1. So, let's find the common vertices first. Because the path between two vertices is always unique, the common vertices also form a path. So, I'll denote the path of the common vertices as Path (c1, c2). c1 and c2 may be equal to: u, v, x, y, and even each other.The possible endpoints are P1 = LCA(u, v), P2 = LCA(x, y), P3 = LCA(u, x), P4 = LCA(u, y), P5 = LCA(v, x), and P6 = LCA(v, y). Figure out by drawing some examples. (some of you might think it's obvious :D)See the pictures above, and make your own criteria to check whether the two paths intersects :DA small hint. Let's assume that we already know, that a vertex a lies on path (x, y). If a lies on path (u, v), a is a common vertex of two paths. What if a is guaranteed to be an end point of the common path?Additional definitions Let's denote JH's running course is: . Then, there are two possible courses for JY: and ). fJH : the time needed to run the course . fJY : the time needed to run the course . t1 : the first time when JH passes vertex c1, moving towards c2. t2 : the first time when JH passes vertex c2, moving towards c1. t3 : the first time when JY passes vertex c1, moving towards c2. t4 : the first time when JY passes vertex c2, moving towards c1. Case 1) When JH and JY meets while moving in the same directionObviously, they must meet at vertex c1 or vertex c2 for the first time. Without loss of generality, let's assume that they meet at vertex c1. In this case, both of them is moving towards vertex c2. (You can use the method similarly for c2) Let's assume that JH and JY meets at time T. Because the movements of both runners are periodic, T must satisfy the conditions below: Among possible T-s, we have to calculate the smallest value. How should we do? From the first condition, we can let T = fJH × p + t1, where p is a non-negative integer. With this, we can write the second condition as: . In conclusion, we have to find the smallest p which satisfies the condition Using the Extended Euclidean algorithm is enough to calculate the minimum p. With p, we can easily calculate the minimum T, which is the first time they meet. If there is no such p, they doesn't meet forever, so the answer is  - 1.Case 2) When JH and JY meets while moving in the opposite directionIn this case, they will meet at a vertex lying on Path (c1, c2). Without loss of generality, let's assume that JH is going from c1 to c2, and JY is going from c2 to c1.I'll assume that JH and JY meets at time T. [1] Let's see how JH moves: For all non-negative integer p, At time fJH × p + t1, he is at vertex c1, moving towards c2. At time fJH × p + t1 + d(c1, c2), he is at vertex c2. Therefore, when fJH × p + t1 ≤  (current time)  ≤ fJH × p + t1 + d(c1, c2), JH is on Path (c1, c2). So, T must satisfy the condition: fJH × p + t1 ≤ T ≤ fJH × p + t1 + d(c1, c2) [2] Let's see how JY moves: Similar to JH, for all non-negative integer q, At time fJY × q + t4, he is at vertex c2, moving towards c1. At time fJY × q + t4 + d(c2, c1), he is at vertex c1. Therefore, when fJY × q + t4 ≤  (current time)  ≤ fJY × q + t4 + d(c2, c1), JY is on Path (c2, c1). So, T must satisfy the condition: fJY × q + t4 ≤ T ≤ fJY × q + t4 + d(c1, c2) [3] These two conditions are not enough, because in this case, they can meet on an edge, but they cannot meet on a vertex.We'd like to know when do they meet on a vertex, like the picture below.As you see from the picture above, in this case, the condition d(c1, a) + d(a, c2) = d(c1, c2) holds. If this picture was taken at time s, this condition can be written as: {s - (fJH × p + t1)} + {s - (fJY × q + t4)} = d(c1, c2) 2s - (fJH × p + fJY × q) - (t1 + t4) = d(c1, c2) s = {d(c1, c2) + (fJH × p + fJY × q) + (t1 + t4)} / 2 Because JH and JY both travel their path back and forth, fJH and fJY are all even. Therefore, in order to make s an integer, d(c1, c2) + t1 + t4 must be even. This can be written as [4] Merging [1], [2] and [3], we can conclude that if these two conditions holds, max{fJH × p + t1, fJY × q + t4} ≤ min{fJH × p + t1 + d(c1, c2), fJY × p + t4 + d(c1, c2)} JH and JY meets on a certain vertex lying on path (c1, c2). The first condition can be easily checked, so let's focus on the second condition. The second condition holds if and only if: fJY × q + t4 - t1 - d ≤ fJH × p ≤ fJY × q + t4 - t1 + d You can check this by changing \"fJH × p\" to the lower bound and the upper bound of the inequality. Therefore, the problem is to find the smallest p which satisfies the condition above.Let's define a function g(M, D, L, R), where M, D, L, R are all non-negative integers. The function returns the smallest non-negative integer m which satisfies . This function can be implemented as follows. If L = 0, g(M, D, L, R) = 0. (because L = 0 ≤ D·0) If , it is \"obvious\" that there is no solution. If 2D > M, g(M, D, L, R) = g(M, M - D, M - R, M - L). If there exists an non-negative integer m which satisfies L ≤ D·m ≤ R (without modular condition), g(M, D, L, R) = m. Obviously, we should take the smallest m. Otherwise, there exists an integer m which satisfies D·m < L ≤ R < D·(m + 1). We should use this fact.. If holds, there exists an non-negative integer k which satisfies L + Mk ≤ D·m ≤ R + Mk. Let's write down.. D·m - R ≤ M·k ≤ D·m - L  - R ≤ M·k - D·m ≤  - L L ≤ D·m - M·k  ≤ RBecause , we can write the inequality as Therefore the minimum k among all possible solutions is equal to . We can easily calculate the smallest p using k. Then, what is the time complexity of calculating g(M, D, L, R)? Because 2D ≤ M (the 2D > M case is handled during step 3), the problem size becomes half, so it can be executed in .ConclusionFor each query, we have to consider both Case 1) and Case 2), with all possible directions. Both cases can be handled in , so the time complexity per query is , and it has really huge constant. Time: Memory: Implementation: 9330235",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/15488",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 500\\s*E"
          },
          "content_length": 19579
        }
      ],
      "code_examples": [
        {
          "title": "Good Bye 2014 - Codeforces - Code 1",
          "code": "division combined",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15465",
          "author": "jiangly"
        },
        {
          "title": "Good Bye 2014 - Codeforces - Code 2",
          "code": "3\n3 1 2\n011\n100\n100",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15465",
          "author": "jiangly"
        },
        {
          "title": "Good Bye 2014 - Codeforces - Code 3",
          "code": "3\n3 1 2\n011\n100\n100",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15465",
          "author": "jiangly"
        },
        {
          "title": "Good Bye 2014 - Codeforces - Code 4",
          "code": "(3,2) (1,2)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15465",
          "author": "jiangly"
        },
        {
          "title": "Good Bye 2014 - Codeforces - Code 5",
          "code": "7\n7 3 4 6 8 1 2\n0010000\n0001000\n0000100\n0000000\n0000001\n1000000\n0000000",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15465",
          "author": "jiangly"
        },
        {
          "title": "Good Bye 2014 - Codeforces - Code 6",
          "code": "7\n7 3 4 6 8 1 2\n0010000\n0001000\n0000100\n0000000\n0000001\n1000000\n0000000",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15465",
          "author": "jiangly"
        },
        {
          "title": "Good Bye 2014 - Codeforces - Code 7",
          "code": "1 3 2 6 4 7 8",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15465",
          "author": "jiangly"
        },
        {
          "title": "Good Bye 2014 - Codeforces - Code 8",
          "code": "2 3 4 6 7 1 8",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15465",
          "author": "jiangly"
        },
        {
          "title": "Good Bye 2014 - Codeforces - Code 9",
          "code": "3\n3 1 2\n011\n100\n100",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15465",
          "author": "jiangly"
        },
        {
          "title": "Good Bye 2014 - Codeforces - Code 10",
          "code": "3\n3 1 2\n011\n100\n100",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15465",
          "author": "jiangly"
        },
        {
          "title": "Good Bye 2014 - Codeforces - Code 11",
          "code": "5\n2 4 1 3 5\n00101\n00010\n10011\n01100\n10100",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15465",
          "author": "jiangly"
        },
        {
          "title": "Good Bye 2014 - Codeforces - Code 12",
          "code": "5\n2 4 1 3 5\n00101\n00010\n10011\n01100\n10100",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15465",
          "author": "jiangly"
        },
        {
          "title": "Good Bye 2014 - Codeforces - Code 13",
          "code": "__mingw_printf",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15465",
          "author": "jiangly"
        },
        {
          "title": "Good Bye 2014 Editorial - Codeforces - Code 1",
          "code": "3.0 / ((long long)n * (n-1))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15488",
          "author": "jiangly"
        },
        {
          "title": "Good Bye 2014 Editorial - Codeforces - Code 2",
          "code": "actually the sorting is o(q*log(q))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15488",
          "author": "jiangly"
        },
        {
          "title": "Good Bye 2014 Editorial - Codeforces - Code 3",
          "code": "actually the sorting is o(q*log(q))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15488",
          "author": "jiangly"
        },
        {
          "title": "Good Bye 2014 Editorial - Codeforces - Code 4",
          "code": "upper_bound",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15488",
          "author": "jiangly"
        },
        {
          "title": "Good Bye 2014 Editorial - Codeforces - Code 5",
          "code": "merge_group(i, j)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15488",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    const int MAXN = 200000;\n    const int MAXQ = 200000;\n    const int MAXP = 1000000000;\n    const int MAXL = 1000000000;\n\n    int n = inf.readInt(2, MAXN, \"n\");\n    inf.readEoln();\n\n    vector<int> p(n + 1);  // 1-based indexing\n    for (int i = 1; i <= n; i++) {\n        p[i] = inf.readInt(1, MAXP, \"p_i\");\n        inf.readSpace();\n        int l_i = inf.readInt(1, MAXL, \"l_i\");\n        inf.readEoln();\n\n        if (i > 1) {\n            ensuref(p[i - 1] < p[i],\n                    \"p_i should be strictly increasing, but p[%d]=%d and p[%d]=%d\",\n                    i - 1, p[i - 1], i, p[i]);\n        }\n    }\n\n    int q = inf.readInt(1, MAXQ, \"q\");\n    inf.readEoln();\n\n    for (int i = 0; i < q; i++) {\n        int xj = inf.readInt(1, n - 1, \"xj\");\n        inf.readSpace();\n        int yj = inf.readInt(xj + 1, n, \"yj\");\n        inf.readEoln();\n\n        ensuref(xj < yj, \"xj (%d) should be less than yj (%d)\", xj, yj);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    const int MAXN = 200000;\n    const int MAXQ = 200000;\n    const int MAXP = 1000000000;\n    const int MAXL = 1000000000;\n\n    int n = inf.readInt(2, MAXN, \"n\");\n    inf.readEoln();\n\n    vector<int> p(n + 1);  // 1-based indexing\n    for (int i = 1; i <= n; i++) {\n        p[i] = inf.readInt(1, MAXP, \"p_i\");\n        inf.readSpace();\n        int l_i = inf.readInt(1, MAXL, \"l_i\");\n        inf.readEoln();\n\n        if (i > 1) {\n            ensuref(p[i - 1] < p[i],\n                    \"p_i should be strictly increasing, but p[%d]=%d and p[%d]=%d\",\n                    i - 1, p[i - 1], i, p[i]);\n        }\n    }\n\n    int q = inf.readInt(1, MAXQ, \"q\");\n    inf.readEoln();\n\n    for (int i = 0; i < q; i++) {\n        int xj = inf.readInt(1, n - 1, \"xj\");\n        inf.readSpace();\n        int yj = inf.readInt(xj + 1, n, \"yj\");\n        inf.readEoln();\n\n        ensuref(xj < yj, \"xj (%d) should be less than yj (%d)\", xj, yj);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    const int MAXN = 200000;\n    const int MAXQ = 200000;\n    const int MAXP = 1000000000;\n    const int MAXL = 1000000000;\n\n    int n = inf.readInt(2, MAXN, \"n\");\n    inf.readEoln();\n\n    vector<int> p(n + 1);  // 1-based indexing\n    for (int i = 1; i <= n; i++) {\n        p[i] = inf.readInt(1, MAXP, \"p_i\");\n        inf.readSpace();\n        int l_i = inf.readInt(1, MAXL, \"l_i\");\n        inf.readEoln();\n\n        if (i > 1) {\n            ensuref(p[i - 1] < p[i],\n                    \"p_i should be strictly increasing, but p[%d]=%d and p[%d]=%d\",\n                    i - 1, p[i - 1], i, p[i]);\n        }\n    }\n\n    int q = inf.readInt(1, MAXQ, \"q\");\n    inf.readEoln();\n\n    for (int i = 0; i < q; i++) {\n        int xj = inf.readInt(1, n - 1, \"xj\");\n        inf.readSpace();\n        int yj = inf.readInt(xj + 1, n, \"yj\");\n        inf.readEoln();\n\n        ensuref(xj < yj, \"xj (%d) should be less than yj (%d)\", xj, yj);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAX_P = (int)1e9;\nconst int MAX_L = (int)1e9;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    int n = opt<int>(\"n\");\n    int q = opt<int>(\"q\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> p(n);\n    vector<int> l(n);\n\n    // Generate p_i and l_i according to type\n    if (type == \"chain\") {\n        // Chain where each domino can reach the next without increasing lengths\n        p[0] = 1;\n        l[0] = rnd.next(1, MAX_L / n);\n        for (int i = 1; i < n; ++i) {\n            p[i] = p[i - 1] + l[i - 1];\n            if (p[i] > MAX_P) {\n                p[i] = MAX_P;\n            }\n            l[i] = rnd.next(1, MAX_L / n);\n        }\n    } else if (type == \"gap\") {\n        // Gaps between dominos so they cannot reach next dominos\n        int gap_size = 10000000; // Adjusted to create large gaps\n        p[0] = 1;\n        l[0] = rnd.next(1, 10);\n        for (int i = 1; i < n; ++i) {\n            p[i] = p[i - 1] + gap_size;\n            if (p[i] > MAX_P)\n                p[i] = MAX_P;\n            l[i] = rnd.next(1, 10);\n        }\n    } else if (type == \"max\") {\n        // Maximal values\n        p[0] = 1;\n        l[0] = MAX_L;\n        for (int i = 1; i < n; ++i) {\n            int max_increment = max(1, (MAX_P - p[i - 1]) / (n - i));\n            int delta_p = rnd.next(1, max_increment);\n            p[i] = p[i - 1] + delta_p;\n            l[i] = MAX_L;\n        }\n    } else if (type == \"random\") {\n        // Random positions and lengths\n        p[0] = rnd.next(1, MAX_P / n);\n        l[0] = rnd.next(1, MAX_L);\n        for (int i = 1; i < n; ++i) {\n            int max_increment = max(1, (MAX_P - p[i - 1]) / (n - i));\n            int delta_p = rnd.next(1, max_increment);\n            p[i] = p[i - 1] + delta_p;\n            l[i] = rnd.next(1, MAX_L);\n        }\n    } else if (type == \"min\") {\n        // Minimal values\n        for (int i = 0; i < n; ++i) {\n            p[i] = i + 1;\n            l[i] = 1;\n        }\n    } else if (type == \"exact\") {\n        // Small gaps that can be bridged by small increases in l_i\n        p[0] = 1;\n        l[0] = rnd.next(1, 10);\n        for (int i = 1; i < n; ++i) {\n            int gap = rnd.next(1, 10); // Small gap\n            p[i] = p[i - 1] + l[i - 1] + gap;\n            if (p[i] > MAX_P) p[i] = MAX_P;\n            l[i] = rnd.next(1, 10);\n        }\n    } else {\n        // Default to random\n        p[0] = rnd.next(1, MAX_P / n);\n        l[0] = rnd.next(1, MAX_L);\n        for (int i = 1; i < n; ++i) {\n            int max_increment = max(1, (MAX_P - p[i - 1]) / (n - i));\n            int delta_p = rnd.next(1, max_increment);\n            p[i] = p[i - 1] + delta_p;\n            l[i] = rnd.next(1, MAX_L);\n        }\n    }\n\n    // Now output n\n    printf(\"%d\\n\", n);\n    // Output p_i and l_i\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d %d\\n\", p[i], l[i]);\n    }\n\n    // Generate q queries\n    printf(\"%d\\n\", q);\n    for (int i = 0; i < q; ++i) {\n        int x = rnd.next(1, n - 1);\n        int y = rnd.next(x + 1, n);\n        printf(\"%d %d\\n\", x, y);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAX_P = (int)1e9;\nconst int MAX_L = (int)1e9;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    int n = opt<int>(\"n\");\n    int q = opt<int>(\"q\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> p(n);\n    vector<int> l(n);\n\n    // Generate p_i and l_i according to type\n    if (type == \"chain\") {\n        // Chain where each domino can reach the next without increasing lengths\n        p[0] = 1;\n        l[0] = rnd.next(1, MAX_L / n);\n        for (int i = 1; i < n; ++i) {\n            p[i] = p[i - 1] + l[i - 1];\n            if (p[i] > MAX_P) {\n                p[i] = MAX_P;\n            }\n            l[i] = rnd.next(1, MAX_L / n);\n        }\n    } else if (type == \"gap\") {\n        // Gaps between dominos so they cannot reach next dominos\n        int gap_size = 10000000; // Adjusted to create large gaps\n        p[0] = 1;\n        l[0] = rnd.next(1, 10);\n        for (int i = 1; i < n; ++i) {\n            p[i] = p[i - 1] + gap_size;\n            if (p[i] > MAX_P)\n                p[i] = MAX_P;\n            l[i] = rnd.next(1, 10);\n        }\n    } else if (type == \"max\") {\n        // Maximal values\n        p[0] = 1;\n        l[0] = MAX_L;\n        for (int i = 1; i < n; ++i) {\n            int max_increment = max(1, (MAX_P - p[i - 1]) / (n - i));\n            int delta_p = rnd.next(1, max_increment);\n            p[i] = p[i - 1] + delta_p;\n            l[i] = MAX_L;\n        }\n    } else if (type == \"random\") {\n        // Random positions and lengths\n        p[0] = rnd.next(1, MAX_P / n);\n        l[0] = rnd.next(1, MAX_L);\n        for (int i = 1; i < n; ++i) {\n            int max_increment = max(1, (MAX_P - p[i - 1]) / (n - i));\n            int delta_p = rnd.next(1, max_increment);\n            p[i] = p[i - 1] + delta_p;\n            l[i] = rnd.next(1, MAX_L);\n        }\n    } else if (type == \"min\") {\n        // Minimal values\n        for (int i = 0; i < n; ++i) {\n            p[i] = i + 1;\n            l[i] = 1;\n        }\n    } else if (type == \"exact\") {\n        // Small gaps that can be bridged by small increases in l_i\n        p[0] = 1;\n        l[0] = rnd.next(1, 10);\n        for (int i = 1; i < n; ++i) {\n            int gap = rnd.next(1, 10); // Small gap\n            p[i] = p[i - 1] + l[i - 1] + gap;\n            if (p[i] > MAX_P) p[i] = MAX_P;\n            l[i] = rnd.next(1, 10);\n        }\n    } else {\n        // Default to random\n        p[0] = rnd.next(1, MAX_P / n);\n        l[0] = rnd.next(1, MAX_L);\n        for (int i = 1; i < n; ++i) {\n            int max_increment = max(1, (MAX_P - p[i - 1]) / (n - i));\n            int delta_p = rnd.next(1, max_increment);\n            p[i] = p[i - 1] + delta_p;\n            l[i] = rnd.next(1, MAX_L);\n        }\n    }\n\n    // Now output n\n    printf(\"%d\\n\", n);\n    // Output p_i and l_i\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d %d\\n\", p[i], l[i]);\n    }\n\n    // Generate q queries\n    printf(\"%d\\n\", q);\n    for (int i = 0; i < q; ++i) {\n        int x = rnd.next(1, n - 1);\n        int y = rnd.next(x + 1, n);\n        printf(\"%d %d\\n\", x, y);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 2 -q 1 -type min\n./gen -n 10 -q 5 -type random\n./gen -n 100 -q 50 -type random\n./gen -n 1000 -q 500 -type random\n./gen -n 5000 -q 1000 -type random\n./gen -n 10000 -q 5000 -type random\n./gen -n 20000 -q 10000 -type random\n\n./gen -n 200000 -q 1000 -type chain\n./gen -n 100000 -q 1000 -type chain\n./gen -n 50000 -q 500 -type chain\n./gen -n 200000 -q 200000 -type chain\n\n./gen -n 200000 -q 1000 -type gap\n./gen -n 100000 -q 10000 -type gap\n\n./gen -n 200000 -q 1 -type exact\n./gen -n 200000 -q 100000 -type exact\n\n./gen -n 200000 -q 200000 -type max\n\n./gen -n 2 -q 1 -type min\n\n./gen -n 200000 -q 200000 -type random\n./gen -n 199999 -q 199999 -type random\n./gen -n 150000 -q 100000 -type random\n./gen -n 100000 -q 100000 -type random\n./gen -n 50000 -q 50000 -type random\n\n./gen -n 200000 -q 1 -type random\n./gen -n 200000 -q 1 -type chain\n./gen -n 200000 -q 1 -type gap\n\n./gen -n 50000 -q 50000 -type exact\n./gen -n 100000 -q 100000 -type exact\n\n./gen -n 200000 -q 200000 -type exact\n\n./gen -n 3 -q 3 -type min\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:40:07.071025",
        "total_tutorials": 3,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "500/F",
      "title": "F. New Year Shopping",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains two space-separated integers n and p (1 ≤ n ≤ 4000, 1 ≤ p ≤ 10 000) — the number of items, and the display time of each item.Next n lines describe the items. The i-th (1 ≤ i ≤ n) of them contains three space-separated integers ci, hi, ti (1 ≤ ci, hi ≤ 4000, 1 ≤ ti ≤ 10 000) — the cost of the i-th item, the happiness of the i-th item, and the time when the i-th item starts to be displayed.The next line contains an integer q (1 ≤ q ≤ 20 000)— the number of candidates.Next q lines describe the candidates. The j-th (1 ≤ j ≤ q) of them contains two space-separated integers aj, bj (1 ≤ aj ≤ 20 000, 1 ≤ bj ≤ 4000) — the visit time and the budget for j-th visit of store.",
      "output_spec": "OutputFor each candidate, print a single line containing the maximum happiness that I can obtain by buying some items.",
      "sample_tests": "ExamplesInputCopy4 42 3 23 5 14 7 211 15 541 32 52 65 14OutputCopy581018InputCopy5 43 2 17 4 42 1 26 3 53 2 2101 52 54 84 94 105 85 95 108 47 9OutputCopy2355645604",
      "description": "F. New Year Shopping\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains two space-separated integers n and p (1 ≤ n ≤ 4000, 1 ≤ p ≤ 10 000) — the number of items, and the display time of each item.Next n lines describe the items. The i-th (1 ≤ i ≤ n) of them contains three space-separated integers ci, hi, ti (1 ≤ ci, hi ≤ 4000, 1 ≤ ti ≤ 10 000) — the cost of the i-th item, the happiness of the i-th item, and the time when the i-th item starts to be displayed.The next line contains an integer q (1 ≤ q ≤ 20 000)— the number of candidates.Next q lines describe the candidates. The j-th (1 ≤ j ≤ q) of them contains two space-separated integers aj, bj (1 ≤ aj ≤ 20 000, 1 ≤ bj ≤ 4000) — the visit time and the budget for j-th visit of store.\n\nOutputFor each candidate, print a single line containing the maximum happiness that I can obtain by buying some items.\n\nInputCopy4 42 3 23 5 14 7 211 15 541 32 52 65 14OutputCopy581018InputCopy5 43 2 17 4 42 1 26 3 53 2 2101 52 54 84 94 105 85 95 108 47 9OutputCopy2355645604\n\nInputCopy4 42 3 23 5 14 7 211 15 541 32 52 65 14\n\nOutputCopy581018\n\nInputCopy5 43 2 17 4 42 1 26 3 53 2 2101 52 54 84 94 105 85 95 108 47 9\n\nOutputCopy2355645604\n\nNoteConsider the first sample.     At time 1, only the 2nd item is available. I can buy the 2nd item using 3 dollars and my happiness will increase by 5.  At time 2, the 1st, 2nd, and 3rd item is available. I can buy the 1st item using 2 dollars, and the 2nd item using 3 dollars. My happiness will increase by 3 + 5 = 8.  At time 2, the 1st, 2nd, and 3rd item is available. I can buy the 1st item using 2 dollars, and the 3nd item using 4 dollars. My happiness will increase by 3 + 7 = 10.  At time 5, the 1st, 3rd, and 4th item is available. I can buy the 1st item using 2 dollars, and the 4th item using 11 dollars. My happiness will increase by 3 + 15 = 18. Note that I don't need to use the whole budget in this case.",
      "solutions": [
        {
          "title": "Good Bye 2014 - Codeforces",
          "content": "Hi, Codeforces!Welcome to the last Codeforces Round of 2014, Good Bye 2014! This round is very unusual; First, the round starts at December 30th, 18:00 MSK. Second, the round lasts for 2.5 hours. And lastly, the round will be division combined, which means Div1 contestants and Div2 contestants won't be separated.The problems are prepared by me (.o.) and Seunghyun Jo (ainta). This is our second round at Codeforces. Because our first round caused(?) the Black Day, we hope this round won't cause any errors like before :DThanks to Won-seok Yoo(ainu7), who tested our round and gave us comments about the problemset.We'd like to thank some people who were necessary to make this round: Maxim Akhmedov (Zlobober) gave us great help preparing the problems. Maria Belova (Delinur) translated problem statements in Russian. Mike Mirzayanov (MikeMirzayanov) made Codeforces and Polygon systems, which are really great. Let's give them an applause!The score distribution will be posted just before the round starts, as usual.We wish you all the best of luck. Happy New Year!UPD (2014-12-30 17:33:21) The score for each problem is going to be 500-1000-1000-1500-2750-2750-3500. Thanks to Xellos for giving us some ideas.UPD (2014-12-31 12:49:05) Round has finished, congratulations to the winners! tourist Petr rng_58 HYPERHYPERHYPERCUBELOVER subscriber Merkurev al13n mmaxio mexmans GlebsHP Also, thanks to Marcin_smu, who solved problem G after the contest for the first time.UPD(2014-12-31 12:51:08) Editorial is published. Currently, only A-F is available, but I will add G as soon as possible. Sorry for the late editorial.UPD(2015-01-02 21:30:44) I wrote the editorial of G. Sorry for the late update..",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/15465",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.6,
            "reason": "宽松匹配: 包含题目编号 500 和字母"
          },
          "content_length": 1702
        },
        {
          "title": "Good Bye 2014 Tutorial - Codeforces",
          "content": "500A — New Year TransportationIn this problem we are given a directed graph, and asked whether a particular vertex is reachable from vertex 1. It is possible to solve this by running a depth-first search starting from vertex 1.Since every vertex has at most one outgoing edge, it is possible to write the DFS as a simple loop. Some people used this to make very short submissions.500B — New Year PermutationImagine a graph with one vertex for each entry in the permutation, and edges between pairs of swappable entries. It is easy to see that no matter how many swaps we make, no entry can end up in a location that is not in its connected component. We can also show that within any connected component, we can achieve any rearrangement of the entries that we wish.Since we want to make the lexicographically smallest permutation, we should greedily rearrange the entries within each connected component so that they are in increasing order.N ≤ 300, so we are not concerned with runtime. One can determine the connected components using a number of standard algorithms (Floyd-Warshall, Union Find, etc.).500C — New Year Book ReadingConsider an arbitrary day d, on which we must read book b. Let d' be the last day before d on which book b was read (if there is no previous day, let d' =  - ∞). Observe that, on day d, we cannot avoid lifting all of the books read on any day between d' and d. If we add up all the weights of these required liftings, we will have a lower bound on the answer.This lower bound can be computed with two loops, in O(M2) time. We must be sure not to add a book's weight multiple times, if it was read multiple times in the interval (d', d).If we initially arrange the books in order of the first day on which they are read, we will achieve the described lower bound. So, we have our answer.500D — New Year Santa NetworkBy linearity of expectation, E(d(c1, c2) + d(c1, c3) + d(c2, c3)) = E(d(c1, c2)) + E(d(c1, c3)) + E(d(c2, c3)). By symmetry, those three values are all equal. So, we need only compute E(d(c1, c2)). We can multiply it by 3 to find the answer.Let us imagine that a random selection (c1, c2, c3) is made. We'll define a function f(j), for each edge j, so that f(j) = wj if j is part of the shortest path from c1 to c2, and f(j) = 0 otherwise. Observe that . Again by linearity, we have .We can write E(f(j)) = wj·P(j), where P(j) is the probability that edge j is included in the path from c1 to c2. If we compute P(j) for all j, we can then compute in O(N). Also, we can handle updates in O(1); if wj changes to w'j, we subtract wj·P(j) from the answer, and add w'j·P(j). So, let's figure out P(j) for each j. Any edge j, if removed from the tree, separates the graph into two separate connected components a and b. Edge j will be included in the shortest path from c1 to c2 if and only if one of them is in a, and the other is in b. So, we want the number of ways to select (c1, c2, c3) such that c1 and c2 are on opposite sides of edge j, divided by the total number of ways to select (c1, c2, c3). Let's have |a| and |b| denote the number of vertices in a and b, respectively. Then .To figure out |a| and |b| for each j, we can root the tree arbitrarily and compute the depth and subtree size for each vertex in O(N) time. Then for an edge j, if vj is the deeper vertex incident to j, we know one component has size equal to the subtree size of vj. For the other component, we use the fact that |b| = N - |a|. 500E — New Year DominoWhen domino i is knocked over, it covers the interval [pi, pi + li]. If we see a query (xj, yj), it is equivalent to the question \"If we knock over all dominoes with index , how much of the interval [pxj, pyj] won't be covered?\" We can modify that question a little more, to say that we knock over all dominoes with index i ≥ xj, without changing its answer. Now, consider knocking over the dominoes from right to left. As soon as we knock over domino i, we will immediately process all of the queries with xj = i, and record their answers. What we need is a data structure that supports two operations: \"cover range [pi, pi + li]\" (when we knock over a domino) and \"compute how much of the range [pxj, pyj] is not covered\" (when we wish to answer a query). This can be done using coordinate compression and a segment tree. It's worth noting there are a lot of other ways to solve this problem. The other tutorial uses a completely different approach. Also, the approach described here may be implemented using different data structures. For example, here is my implementation using BBSTs and a Binary Indexed Tree.500F — New Year ShoppingWe will use the standard dynamic programming approach for 0/1 knapsack. To summarize what it does for us, imagine we are given an ordered list of items (ci, hi). Let F(k, b) be the maximum happiness we can buy, if we consider only the first k items in the list, and have a budget of b. If K is the size of the list, and B is the maximum possible budget, we can compute F(k, b) for all possible k and b in O(KB) time.Let us sort all of the items by their display time. Suppose that we focus on the queries (aj, bj) with , for some particular t. Let A be a list of the items with display time in (t - P, t], and let B be a list of the items with display time in (t, t + P). Let both lists be sorted in order of display time.Every query with will have available to it some suffix of A, along with some prefix of B. We'll do a knapsack DP on the elements of A, in reverse order, and another on the elements of B, in normal order. Finally, to answer any query (aj, bj) with , we can consider all possible ways to split the budget bj between the items in A and the items in B, in linear time. For each possible way to split the budget, we need simply look up one value from each DP table to know the maximum possible happiness.If we perform the process above on t = 1, 1 + P, 1 + 2P, 1 + 3P, ... until t exceeds the maximum possible day D, we'll be able to answer all of the queries. Let's think about the runtime of this solution. For each t, the described process takes O(KB) time, where K is the number of items whose display time is in (t - P, t + P). Each object can only appear in up to two of these intervals. So, the overall runtime for all of the knapsack DP's we perform is O(nB). Computing the final answer takes O(B) per query, or O(qB) overall.500G — New Year RunningDon't know how to solve this yet. Maybe someone who is not gray can provide the solution. :)",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/15513",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 500\\s*F"
          },
          "content_length": 6486
        },
        {
          "title": "Good Bye 2014 Editorial - Codeforces",
          "content": "First of all, sorry for the late editorial. I was too exhausted and immediately went to bed after the round finished, and didn't write the editorial.There are many pictures in this editorial, to cover up my poor English skills! If you have detected any errors or have questions, feel free to ask questions by comments. Unfortunately, the authors only know English, so we can't answer you if you write comments in Russian.500A - Транспорт на Новый годLet's assume that I am in the cell i (1 ≤ i ≤ n). If i ≤ n - 1, I have two choices: to stay at cell i, or to go to cell (i + ai). If i = t, we are at the target cell, so I should print \"YES\" and terminate. If i > t, I cannot go to cell t because I can't use the portal backwards, so one should print \"NO\" and terminate. Otherwise, I must go to cell (i + ai).Using this method, I visit each cell at most once, and there are n cells, so the problem can be solved in linear time.What is test 13?There are 9 pretests in this problem. There are no test where n = t holds in pretests. Many people didn't handle this case, and got hacked or got Wrong Answer on test 13. Time: O(n) Memory: O(n) (maybe O(1)) Implementation: 9335683 500B - Новогодняя перестановкаIt seems that many contestants were confused by the statement, so let me clarify it first. Given a permutation p1, p2, ..., pn and a n × n-sized binary matrix A, the problem asks us to find the lexicographically minimum permutation which can be achieved by swapping two distinct elements pi and pj where the condition Ai, j = 1 holds. (From the statement, permutation A is prettier than permutation B if and only if A is lexicographically less than B.)Let's think matrix A as an adjacency matrix of a undirected unweighted graph.If two vertices i and j are in the same component (in other words, connected by some edges), the values of pi and pj can be swapped, using a method similar to bubble sort. Look at the picture below for easy understanding.Because all the two distinct vertices in the same component can be swapped, the vertices in the same component can be sorted. In conclusion, we can solve the problem by the following procedure. Find all the connected components. For each component, sort the elements in the component. Print the resulting permutation. The size limit is quite small, so one can use any algorithm (DFS/BFS/..) for as many times as you want. Time: O(n2) — because of the graph traversal. O(n3) is okay because of small constraints. Memory: O(n2) Implementation: 9335689 (.o.) What is test 15? There are too many wrong answers in this case.Actually, I made the pretests very weak in order to make many hacks. As mentioned in the Hack me! post by kostka, just swapping the elements greedily could pass the pretests easily. There were 14 pretests, and I made test 15 an counter-example of such algorithm in order to reduce judging time, and it seems that most of the wrong submissions failed in this test case :D500C - В Новый год --- с книгой!In order to calculate the minimum possible lifted weight, we should find the initial stack first. Let's find the positions one by one. First, let's decide the position of book b1. After day 1, book b1 will be on the top of the stack, regardless of the order of the initial stack. Therefore, in order to minimize the lifted weight during day 1, book b1 must be on the top of the initial stack. (so actually, in day 1, Jaehyun won't lift any book) Next, let's decide the position of book b2. (assume that b1 ≠ b2 for simplicity) Currently, b1 is on the top of the stack, and it cannot be changed because of the procedure. Therefore, in order to minimize the lifted weight during day 2, book b2 must be immediately below book b1. Considering this, we can find the optimal strategy to create the initial stack: Scan b1, b2, ..., bm step by step. Let's assume that I am handling bi now. If bi has appeared before (formally, if ), erase bi from the sequence. Otherwise, leave bi. The resulting sequence will be the optimal stack.You should note that it is not necessary for Jaehyun to read all the books during 2015, which means the size of the resulting sequence may be smaller than n. The books which doesn't appear in the resulting sequence must be in the bottom of the initial stack (obviously). However, this problem doesn't require us to print the initial stack, so it turned out not to be important. In conclusion, finding the initial stack takes O(n + m) time.After finding the initial stack, we can simulate the procedure given in the statement naively. It will take O(nm) time. Time: O(nm) Memory: O(n + m) Implementation: 9335694 (.o.) 500D - Новогоднее взаимодействие Санта-КлаусовThe problem asks us to calculate the value ofLet's write it down..So, we need to calculate the value of . I'll denote the sum as S. How should we calculate this?For simplicity, I'll set node 1 as the root of the tree. Let's focus on an edge e, connecting two vertices u and p. See the picture below.Set A is a set of vertices in the subtree of vertex u, and set B is a set of vertices which is not in the subtree of vertex u. So, is the set of vertices in the tree, and is empty.For all pairs of two vertices (x, y) where the condition and holds, the shortest path between x and y contains edge e. There are size(A) × size(B) such pairs. So, edge e increases the sum S by 2 × le × size(A) × size(B). (because d(x, y) and d(y, x) both contributes to S)size(A) (the size of the subtree whose root is u) can be calculated by dynamic programming in trees, which is well known. size(B) equals to N - size(A). So, for each edge e, we can pre-calculate how many times does this edge contributes to the total sum. Let's define t(e) = size(A) × size(B), (A and B is mentioned above). If the length of a certain road e decreases by d, S will decrease by t(e) × d. So we can answer each query. Time: O(n) (pre-calculation) + O(q) (query) Memory: O(n) (O(n + q) is okay too) Implementation: 9335695 (.o.) Something about precision errorBecause of the tight constraints, the total sum of d(a, b) + d(b, c) + d(c, a) (it is equal to S × (n - 2)) can be so large that it can't be saved in long long(64-bit integer) type. Some contestants didn't handle this and got WA. However, there are some contestants who saved this value divided by n × (n - 1) × (n - 2) in double type. double has 52 bits to store exact value, so it isn't enough. But because we allow 10 - 6 precision error, it seems to have been got accepted.What if we allowed the length of the road could become 0? Then the precision error gets much more bigger, and the solution prints something that is far from the expected value (for example, negative value). ainu7 discovered this effect and suggested to apply this, but we didn't because it was hard to fix the statement..Why does the road length decreases? It doesn't matter even if increases.It's because of the weird legend. It is hard to explain, \"People repairs a certain road per year, and its length may be increased or decreased.\" fluently for me..500E - Новогоднее доминоFrom the statement, it is clear that, when domino i falls to the right, it makes domino j also fall if and only if pi < pj ≤ pi + li.For each domino i, let's calculate the rightmost position of the fallen dominoes R[i] when we initially pushed domino i. From the definition, . This can be calculated by using a segment tree or using a stack, in decreasing order of i (from right to left). After that, we define U[i] as the smallest j where R[i] < pj holds. (In other words, the smallest j where domino j is not affected by pushing domino i)Now, the problem becomes: Calculate P[U[xi]] - R[xi] + P[U[U[xi]]] - R[U[xi]] + ..., until U[xi] ≤ yi. Because i < U[i], this task can be solved by precalculating 'jumps' of 2something times, using the method described in here. You must read the \"Another easy solution in <O(N logN, O(logN)>\" part..Formally, let's define Un + 1[k] = U[Un[k]] and Sn + 1[k] = Sn[k] + (P[Un + 1[k]] - R[Un[k]]). So, Sn[k] means the sum of domino length extensions when we initially push domino i and we prolonged the length exactly n times. U2i + 1[k] = U2i[U2i[k]], and S2i + 1[k] = S2i[k] + S2i[U2i[k]] holds. (If you don't understand this part, I suggest you to read the article linked above) Time : or . Memory : Implementation: 9335698 (.o.) We would like to know whether there is a linear offline solution or not. 500F - Новогодние покупки The i-th item is available during [ti, ti + p - 1]. In other words, at time T, item i is available if and only if ti ≤ T ≤ ti + p - 1. This can be re-written as (ti ≤ T and T - p + 1 ≤ ti), which is T - p + 1 ≤ ti ≤ T. With this observation, we can transform the item's purchasable range into a dot, and the candidate's visit time into a range: From now on, item i is only available at time ti. and each candidate pair (aj, bj) means that I can visit the store during [aj - p + 1, aj], and my budget is bj dollars at that visit. This transformation makes the problem easier to solve.Each red circled point denotes an item which is sold at that time, and each black interval denotes a candidate. Let's only consider the intervals which passes time T. All the intervals' length is exactly p, so the left bound of the interval is (T - p) and the right bound of the interval is (T + p). For each interval, we'd like to solve the 0/1 knapsack algorithm with the items that the interval contains. How can we do that effectively? There is an important fact that I've described above: all the interval passes time T. Therefore, the interval [aj - p + 1, aj] can be split into two intervals: [aj - p + 1, T - 1] and [T, aj].So, let's solve the 0/1 knapsack problem for all intervals [x, T - 1] (T - p ≤ x ≤ T - 1) and [T, y] (T ≤ y ≤ T + p). Because one of the endpoints is fixed, one can run a standard dynamic programming algorithm. Therefore, the time needed in precalculation is O(S × W), where S is the number of items where the condition holds.Let's define h(I, b), as the maximum happiness I can obtain by buying the items where the condition holds, using at most b dollars. For each candidate (aj, bj), we have to calculate h([aj - p + 1, aj], bj), which is equal to max0 ≤ k ≤ b{h([aj - p + 1, T - 1], k) + h([T, aj], b - k)}. So it takes O(bj) = O(W) time to solve each query.The only question left is: How should we choose the value of T? We have two facts. (1) The length of intervals is exactly p. (2) The algorithm covers intervals which passes time T. Therefore, to cover all the intervals given in the input, we should let T be p, 2p, 3p, 4p, ... (of course, one by one), and run the algorithm described above.Then, what is the total time complexity? Think of intervals [0, 2p], [p, 3p], [2p, 4p], [3p, 5p], .... For each point, there will be at most two intervals which contains the point. Therefore, each item is reflected in the pre-calculation at most twice, so the time needed to precalculate is O(n × W). The time needed to solve each query is O(bj), and the answer of the query is calculated at most once. Therefore, the time needed to answer all the queries is O(q × W). Time : O((n + q) × W). Memory : O(n × W) Implementations: 9335699 (ainta), 9335703 (ainu7) , 9335710 (.o., using a different approach), 9335709 (.o., using a divide and conquer approach) Divide and Conquer approachLet's assume that t1 ≤ t2 ≤ ... ≤ tn. We can easily know that at time T, the indexes of all the available items forms a segment [l, r]. (in other words, item l, item l + 1, ..., item r - 1, item r is available) We can use this fact to solve all the queries. Let's assume that item lj, item lj + 1, ..., item rj - 1, item rj is available at time aj.Define a function solve(L, R). This function calculates the answer for queries where the condition L ≤ lj ≤ rj ≤ R holds. Let's assume that L < R holds. (In the case L ≥ R, the answer can be calculated easily) Let . Call solve(L, M) and solve(M + 1, R). After that, the queries needed to be calculated, satisfies the condition lj ≤ M < rj, which means all the intervals(queries) passes item M. Now, to calculate the answer for such queries, we can use the method described at the dynamic programming approach.The time complexity is , because and the answer of the queries can be calculated in O(bj) per query. Time : . Memory : O(n × W) Implementation: 9335709 Unfortunately, this approach is offline, because of the memory. Is there any available online approach using divide and conquer?Blocking the divide and conquer solutionI tried my best to block divide and conquer solutions, but failed. It seems that many participants solved the problem with divide and conquer approach. My approach takes time, and it gets accepted in 546ms.500G - Новогодний забегBefore starting the editorial, I'd like to give a big applause to Marcin_smu, who solved the problem for the first time!Warning: The editorial is very long and has many mistakes. There are lots of lots of mistakes.. Keep calm, and please tell me by comments, if you discovered any errors.This problem can be solved by an online algorithm. Let's focus on a single query (u, v, x, y). This means that JH runs between u and v, and JY runs between x and y.Just like when we solve many problems with undirected trees, let vertex 1 be the root of the tree. Also, we will assume that they won't stop after when they meet, but they will continue running, in order to explain easily.Some definitions: Path (a, b): the shortest path between vertex a and vertex b. d(a, b): the length of Path (a, b). LCA(a, b): the lowest common ancestor of vertex a and vertex b. Finding the common path of two pathsIf there is no common vertex between Path (u, v) and Path (x, y), the answer will be obviously  - 1. So, let's find the common vertices first. Because the path between two vertices is always unique, the common vertices also form a path. So, I'll denote the path of the common vertices as Path (c1, c2). c1 and c2 may be equal to: u, v, x, y, and even each other.The possible endpoints are P1 = LCA(u, v), P2 = LCA(x, y), P3 = LCA(u, x), P4 = LCA(u, y), P5 = LCA(v, x), and P6 = LCA(v, y). Figure out by drawing some examples. (some of you might think it's obvious :D)See the pictures above, and make your own criteria to check whether the two paths intersects :DA small hint. Let's assume that we already know, that a vertex a lies on path (x, y). If a lies on path (u, v), a is a common vertex of two paths. What if a is guaranteed to be an end point of the common path?Additional definitions Let's denote JH's running course is: . Then, there are two possible courses for JY: and ). fJH : the time needed to run the course . fJY : the time needed to run the course . t1 : the first time when JH passes vertex c1, moving towards c2. t2 : the first time when JH passes vertex c2, moving towards c1. t3 : the first time when JY passes vertex c1, moving towards c2. t4 : the first time when JY passes vertex c2, moving towards c1. Case 1) When JH and JY meets while moving in the same directionObviously, they must meet at vertex c1 or vertex c2 for the first time. Without loss of generality, let's assume that they meet at vertex c1. In this case, both of them is moving towards vertex c2. (You can use the method similarly for c2) Let's assume that JH and JY meets at time T. Because the movements of both runners are periodic, T must satisfy the conditions below: Among possible T-s, we have to calculate the smallest value. How should we do? From the first condition, we can let T = fJH × p + t1, where p is a non-negative integer. With this, we can write the second condition as: . In conclusion, we have to find the smallest p which satisfies the condition Using the Extended Euclidean algorithm is enough to calculate the minimum p. With p, we can easily calculate the minimum T, which is the first time they meet. If there is no such p, they doesn't meet forever, so the answer is  - 1.Case 2) When JH and JY meets while moving in the opposite directionIn this case, they will meet at a vertex lying on Path (c1, c2). Without loss of generality, let's assume that JH is going from c1 to c2, and JY is going from c2 to c1.I'll assume that JH and JY meets at time T. [1] Let's see how JH moves: For all non-negative integer p, At time fJH × p + t1, he is at vertex c1, moving towards c2. At time fJH × p + t1 + d(c1, c2), he is at vertex c2. Therefore, when fJH × p + t1 ≤  (current time)  ≤ fJH × p + t1 + d(c1, c2), JH is on Path (c1, c2). So, T must satisfy the condition: fJH × p + t1 ≤ T ≤ fJH × p + t1 + d(c1, c2) [2] Let's see how JY moves: Similar to JH, for all non-negative integer q, At time fJY × q + t4, he is at vertex c2, moving towards c1. At time fJY × q + t4 + d(c2, c1), he is at vertex c1. Therefore, when fJY × q + t4 ≤  (current time)  ≤ fJY × q + t4 + d(c2, c1), JY is on Path (c2, c1). So, T must satisfy the condition: fJY × q + t4 ≤ T ≤ fJY × q + t4 + d(c1, c2) [3] These two conditions are not enough, because in this case, they can meet on an edge, but they cannot meet on a vertex.We'd like to know when do they meet on a vertex, like the picture below.As you see from the picture above, in this case, the condition d(c1, a) + d(a, c2) = d(c1, c2) holds. If this picture was taken at time s, this condition can be written as: {s - (fJH × p + t1)} + {s - (fJY × q + t4)} = d(c1, c2) 2s - (fJH × p + fJY × q) - (t1 + t4) = d(c1, c2) s = {d(c1, c2) + (fJH × p + fJY × q) + (t1 + t4)} / 2 Because JH and JY both travel their path back and forth, fJH and fJY are all even. Therefore, in order to make s an integer, d(c1, c2) + t1 + t4 must be even. This can be written as [4] Merging [1], [2] and [3], we can conclude that if these two conditions holds, max{fJH × p + t1, fJY × q + t4} ≤ min{fJH × p + t1 + d(c1, c2), fJY × p + t4 + d(c1, c2)} JH and JY meets on a certain vertex lying on path (c1, c2). The first condition can be easily checked, so let's focus on the second condition. The second condition holds if and only if: fJY × q + t4 - t1 - d ≤ fJH × p ≤ fJY × q + t4 - t1 + d You can check this by changing \"fJH × p\" to the lower bound and the upper bound of the inequality. Therefore, the problem is to find the smallest p which satisfies the condition above.Let's define a function g(M, D, L, R), where M, D, L, R are all non-negative integers. The function returns the smallest non-negative integer m which satisfies . This function can be implemented as follows. If L = 0, g(M, D, L, R) = 0. (because L = 0 ≤ D·0) If , it is \"obvious\" that there is no solution. If 2D > M, g(M, D, L, R) = g(M, M - D, M - R, M - L). If there exists an non-negative integer m which satisfies L ≤ D·m ≤ R (without modular condition), g(M, D, L, R) = m. Obviously, we should take the smallest m. Otherwise, there exists an integer m which satisfies D·m < L ≤ R < D·(m + 1). We should use this fact.. If holds, there exists an non-negative integer k which satisfies L + Mk ≤ D·m ≤ R + Mk. Let's write down.. D·m - R ≤ M·k ≤ D·m - L  - R ≤ M·k - D·m ≤  - L L ≤ D·m - M·k  ≤ RBecause , we can write the inequality as Therefore the minimum k among all possible solutions is equal to . We can easily calculate the smallest p using k. Then, what is the time complexity of calculating g(M, D, L, R)? Because 2D ≤ M (the 2D > M case is handled during step 3), the problem size becomes half, so it can be executed in .ConclusionFor each query, we have to consider both Case 1) and Case 2), with all possible directions. Both cases can be handled in , so the time complexity per query is , and it has really huge constant. Time: Memory: Implementation: 9330235",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/15488",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 500\\s*F"
          },
          "content_length": 19579
        }
      ],
      "code_examples": [
        {
          "title": "Good Bye 2014 - Codeforces - Code 1",
          "code": "division combined",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15465",
          "author": "jiangly"
        },
        {
          "title": "Good Bye 2014 - Codeforces - Code 2",
          "code": "3\n3 1 2\n011\n100\n100",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15465",
          "author": "jiangly"
        },
        {
          "title": "Good Bye 2014 - Codeforces - Code 3",
          "code": "3\n3 1 2\n011\n100\n100",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15465",
          "author": "jiangly"
        },
        {
          "title": "Good Bye 2014 - Codeforces - Code 4",
          "code": "(3,2) (1,2)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15465",
          "author": "jiangly"
        },
        {
          "title": "Good Bye 2014 - Codeforces - Code 5",
          "code": "7\n7 3 4 6 8 1 2\n0010000\n0001000\n0000100\n0000000\n0000001\n1000000\n0000000",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15465",
          "author": "jiangly"
        },
        {
          "title": "Good Bye 2014 - Codeforces - Code 6",
          "code": "7\n7 3 4 6 8 1 2\n0010000\n0001000\n0000100\n0000000\n0000001\n1000000\n0000000",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15465",
          "author": "jiangly"
        },
        {
          "title": "Good Bye 2014 - Codeforces - Code 7",
          "code": "1 3 2 6 4 7 8",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15465",
          "author": "jiangly"
        },
        {
          "title": "Good Bye 2014 - Codeforces - Code 8",
          "code": "2 3 4 6 7 1 8",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15465",
          "author": "jiangly"
        },
        {
          "title": "Good Bye 2014 - Codeforces - Code 9",
          "code": "3\n3 1 2\n011\n100\n100",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15465",
          "author": "jiangly"
        },
        {
          "title": "Good Bye 2014 - Codeforces - Code 10",
          "code": "3\n3 1 2\n011\n100\n100",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15465",
          "author": "jiangly"
        },
        {
          "title": "Good Bye 2014 - Codeforces - Code 11",
          "code": "5\n2 4 1 3 5\n00101\n00010\n10011\n01100\n10100",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15465",
          "author": "jiangly"
        },
        {
          "title": "Good Bye 2014 - Codeforces - Code 12",
          "code": "5\n2 4 1 3 5\n00101\n00010\n10011\n01100\n10100",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15465",
          "author": "jiangly"
        },
        {
          "title": "Good Bye 2014 - Codeforces - Code 13",
          "code": "__mingw_printf",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15465",
          "author": "jiangly"
        },
        {
          "title": "Good Bye 2014 Editorial - Codeforces - Code 1",
          "code": "3.0 / ((long long)n * (n-1))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15488",
          "author": "jiangly"
        },
        {
          "title": "Good Bye 2014 Editorial - Codeforces - Code 2",
          "code": "actually the sorting is o(q*log(q))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15488",
          "author": "jiangly"
        },
        {
          "title": "Good Bye 2014 Editorial - Codeforces - Code 3",
          "code": "actually the sorting is o(q*log(q))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15488",
          "author": "jiangly"
        },
        {
          "title": "Good Bye 2014 Editorial - Codeforces - Code 4",
          "code": "upper_bound",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15488",
          "author": "jiangly"
        },
        {
          "title": "Good Bye 2014 Editorial - Codeforces - Code 5",
          "code": "merge_group(i, j)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15488",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 4000, \"n\");\n    inf.readSpace();\n    int p = inf.readInt(1, 10000, \"p\");\n    inf.readEoln();\n\n    for (int i = 0; i < n; ++i) {\n        int ci = inf.readInt(1, 4000, \"ci\");\n        inf.readSpace();\n        int hi = inf.readInt(1, 4000, \"hi\");\n        inf.readSpace();\n        int ti = inf.readInt(1, 10000, \"ti\");\n        inf.readEoln();\n    }\n\n    int q = inf.readInt(1, 20000, \"q\");\n    inf.readEoln();\n\n    for (int i = 0; i < q; ++i) {\n        int aj = inf.readInt(1, 20000, \"aj\");\n        inf.readSpace();\n        int bj = inf.readInt(1, 4000, \"bj\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 4000, \"n\");\n    inf.readSpace();\n    int p = inf.readInt(1, 10000, \"p\");\n    inf.readEoln();\n\n    for (int i = 0; i < n; ++i) {\n        int ci = inf.readInt(1, 4000, \"ci\");\n        inf.readSpace();\n        int hi = inf.readInt(1, 4000, \"hi\");\n        inf.readSpace();\n        int ti = inf.readInt(1, 10000, \"ti\");\n        inf.readEoln();\n    }\n\n    int q = inf.readInt(1, 20000, \"q\");\n    inf.readEoln();\n\n    for (int i = 0; i < q; ++i) {\n        int aj = inf.readInt(1, 20000, \"aj\");\n        inf.readSpace();\n        int bj = inf.readInt(1, 4000, \"bj\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 4000, \"n\");\n    inf.readSpace();\n    int p = inf.readInt(1, 10000, \"p\");\n    inf.readEoln();\n\n    for (int i = 0; i < n; ++i) {\n        int ci = inf.readInt(1, 4000, \"ci\");\n        inf.readSpace();\n        int hi = inf.readInt(1, 4000, \"hi\");\n        inf.readSpace();\n        int ti = inf.readInt(1, 10000, \"ti\");\n        inf.readEoln();\n    }\n\n    int q = inf.readInt(1, 20000, \"q\");\n    inf.readEoln();\n\n    for (int i = 0; i < q; ++i) {\n        int aj = inf.readInt(1, 20000, \"aj\");\n        inf.readSpace();\n        int bj = inf.readInt(1, 4000, \"bj\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\", 4000);\n    int p = opt<int>(\"p\", 10000);\n    int q = opt<int>(\"q\", 20000);\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> ci(n), hi(n), ti(n); // items\n    vector<int> aj(q), bj(q); // queries\n\n    if (type == \"max_n_q\") {\n        n = 4000;\n        q = 20000;\n        ci.resize(n);\n        hi.resize(n);\n        ti.resize(n);\n        aj.resize(q);\n        bj.resize(q);\n        for (int i = 0; i < n; ++i) {\n            ci[i] = rnd.next(1, 4000);\n            hi[i] = rnd.next(1, 4000);\n            ti[i] = rnd.next(1, 10000);\n        }\n        for (int i = 0; i < q; ++i) {\n            aj[i] = rnd.next(1, 20000);\n            bj[i] = rnd.next(1, 4000);\n        }\n    } else if (type == \"max_p\") {\n        p = 10000;\n        for (int i = 0; i < n; ++i) {\n            ci[i] = rnd.next(1, 4000);\n            hi[i] = rnd.next(1, 4000);\n            ti[i] = rnd.next(1, 10000);\n        }\n        for (int i = 0; i < q; ++i) {\n            aj[i] = rnd.next(1, 20000);\n            bj[i] = rnd.next(1, 4000);\n        }\n    } else if (type == \"min_p\") {\n        p = 1;\n        for (int i = 0; i < n; ++i) {\n            ci[i] = rnd.next(1, 4000);\n            hi[i] = rnd.next(1, 4000);\n            ti[i] = rnd.next(1, 10000);\n        }\n        for (int i = 0; i < q; ++i) {\n            aj[i] = rnd.next(1, 20000);\n            bj[i] = rnd.next(1, 4000);\n        }\n    } else if (type == \"same_ti\") {\n        int same_ti = rnd.next(1, 10000);\n        for (int i = 0; i < n; ++i) {\n            ci[i] = rnd.next(1, 4000);\n            hi[i] = rnd.next(1, 4000);\n            ti[i] = same_ti;\n        }\n        for (int i = 0; i < q; ++i) {\n            aj[i] = rnd.next(1, 20000);\n            bj[i] = rnd.next(1, 4000);\n        }\n    } else if (type == \"disjoint_ti\") {\n        int start_ti = 1;\n        int max_ti = 10000 - (p - 1);\n        ci.resize(n);\n        hi.resize(n);\n        ti.resize(n);\n        for (int i = 0; i < n; ++i) {\n            ti[i] = start_ti;\n            start_ti += p + 1; // Ensure no overlapping\n            if (start_ti > max_ti) {\n                start_ti = (start_ti % max_ti) + 1;\n            }\n            ci[i] = rnd.next(1, 4000);\n            hi[i] = rnd.next(1, 4000);\n        }\n        for (int i = 0; i < q; ++i) {\n            // Visit during availability periods\n            int idx = rnd.next(0, n - 1);\n            aj[i] = ti[idx] + rnd.next(0, p - 1);\n            bj[i] = rnd.next(1, 4000);\n        }\n    } else if (type == \"max_ci\") {\n        for (int i = 0; i < n; ++i) {\n            ci[i] = 4000;\n            hi[i] = rnd.next(1, 4000);\n            ti[i] = rnd.next(1, 10000);\n        }\n    } else if (type == \"min_ci\") {\n        for (int i = 0; i < n; ++i) {\n            ci[i] = 1;\n            hi[i] = rnd.next(1, 4000);\n            ti[i] = rnd.next(1, 10000);\n        }\n    } else if (type == \"max_hi\") {\n        for (int i = 0; i < n; ++i) {\n            ci[i] = rnd.next(1, 4000);\n            hi[i] = 4000;\n            ti[i] = rnd.next(1, 10000);\n        }\n    } else if (type == \"min_hi\") {\n        for (int i = 0; i < n; ++i) {\n            ci[i] = rnd.next(1, 4000);\n            hi[i] = 1;\n            ti[i] = rnd.next(1, 10000);\n        }\n    } else if (type == \"max_items_at_same_time\") {\n        for (int i = 0; i < n; ++i) {\n            ci[i] = rnd.next(1, 4000);\n            hi[i] = rnd.next(1, 4000);\n            ti[i] = 1;\n        }\n        p = 10000;\n        for (int i = 0; i < q; ++i) {\n            aj[i] = 1;\n            bj[i] = rnd.next(1, 4000);\n        }\n    } else if (type == \"small_budget_large_ci\") {\n        for (int i = 0; i < n; ++i) {\n            ci[i] = rnd.next(2000, 4000);\n            hi[i] = rnd.next(1, 4000);\n            ti[i] = rnd.next(1, 10000);\n        }\n        for (int i = 0; i < q; ++i) {\n            aj[i] = rnd.next(1, 20000);\n            bj[i] = rnd.next(1, 1000);\n        }\n    } else if (type == \"large_budget_small_ci\") {\n        for (int i = 0; i < n; ++i) {\n            ci[i] = rnd.next(1, 1000);\n            hi[i] = rnd.next(1, 4000);\n            ti[i] = rnd.next(1, 10000);\n        }\n        for (int i = 0; i < q; ++i) {\n            aj[i] = rnd.next(1, 20000);\n            bj[i] = rnd.next(3000, 4000);\n        }\n    } else if (type == \"customer_no_items\") {\n        for (int i = 0; i < n; ++i) {\n            ci[i] = rnd.next(1, 4000);\n            hi[i] = rnd.next(1, 4000);\n            ti[i] = 10000; // After queries\n        }\n        for (int i = 0; i < q; ++i) {\n            aj[i] = rnd.next(1, 9999); // Before items are displayed\n            bj[i] = rnd.next(1, 4000);\n        }\n    } else if (type == \"customer_cannot_buy\") {\n        for (int i = 0; i < n; ++i) {\n            ci[i] = 4000; // Maximum cost\n            hi[i] = rnd.next(1, 4000);\n            ti[i] = rnd.next(1, 10000);\n        }\n        for (int i = 0; i < q; ++i) {\n            aj[i] = rnd.next(1, 20000);\n            bj[i] = 1; // Minimum budget\n        }\n    } else if (type == \"max_happiness_per_cost\") {\n        for (int i = 0; i < n; ++i) {\n            ci[i] = rnd.next(1, 1000);\n            hi[i] = min(4000, ci[i] * 4);\n            ti[i] = rnd.next(1, 10000);\n        }\n    } else if (type == \"min_happiness_per_cost\") {\n        for (int i = 0; i < n; ++i) {\n            ci[i] = rnd.next(1, 4000);\n            hi[i] = 1;\n            ti[i] = rnd.next(1, 10000);\n        }\n    } else {\n        // Random test case\n        for (int i = 0; i < n; ++i) {\n            ci[i] = rnd.next(1, 4000);\n            hi[i] = rnd.next(1, 4000);\n            ti[i] = rnd.next(1, 10000);\n        }\n        for (int i = 0; i < q; ++i) {\n            aj[i] = rnd.next(1, 20000);\n            bj[i] = rnd.next(1, 4000);\n        }\n    }\n\n    // Output n and p\n    printf(\"%d %d\\n\", n, p);\n\n    // Output n lines of ci, hi, ti\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d %d %d\\n\", ci[i], hi[i], ti[i]);\n    }\n\n    // Output q\n    printf(\"%d\\n\", q);\n\n    // Output q lines of aj, bj\n    for (int i = 0; i < q; ++i) {\n        printf(\"%d %d\\n\", aj[i], bj[i]);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\", 4000);\n    int p = opt<int>(\"p\", 10000);\n    int q = opt<int>(\"q\", 20000);\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> ci(n), hi(n), ti(n); // items\n    vector<int> aj(q), bj(q); // queries\n\n    if (type == \"max_n_q\") {\n        n = 4000;\n        q = 20000;\n        ci.resize(n);\n        hi.resize(n);\n        ti.resize(n);\n        aj.resize(q);\n        bj.resize(q);\n        for (int i = 0; i < n; ++i) {\n            ci[i] = rnd.next(1, 4000);\n            hi[i] = rnd.next(1, 4000);\n            ti[i] = rnd.next(1, 10000);\n        }\n        for (int i = 0; i < q; ++i) {\n            aj[i] = rnd.next(1, 20000);\n            bj[i] = rnd.next(1, 4000);\n        }\n    } else if (type == \"max_p\") {\n        p = 10000;\n        for (int i = 0; i < n; ++i) {\n            ci[i] = rnd.next(1, 4000);\n            hi[i] = rnd.next(1, 4000);\n            ti[i] = rnd.next(1, 10000);\n        }\n        for (int i = 0; i < q; ++i) {\n            aj[i] = rnd.next(1, 20000);\n            bj[i] = rnd.next(1, 4000);\n        }\n    } else if (type == \"min_p\") {\n        p = 1;\n        for (int i = 0; i < n; ++i) {\n            ci[i] = rnd.next(1, 4000);\n            hi[i] = rnd.next(1, 4000);\n            ti[i] = rnd.next(1, 10000);\n        }\n        for (int i = 0; i < q; ++i) {\n            aj[i] = rnd.next(1, 20000);\n            bj[i] = rnd.next(1, 4000);\n        }\n    } else if (type == \"same_ti\") {\n        int same_ti = rnd.next(1, 10000);\n        for (int i = 0; i < n; ++i) {\n            ci[i] = rnd.next(1, 4000);\n            hi[i] = rnd.next(1, 4000);\n            ti[i] = same_ti;\n        }\n        for (int i = 0; i < q; ++i) {\n            aj[i] = rnd.next(1, 20000);\n            bj[i] = rnd.next(1, 4000);\n        }\n    } else if (type == \"disjoint_ti\") {\n        int start_ti = 1;\n        int max_ti = 10000 - (p - 1);\n        ci.resize(n);\n        hi.resize(n);\n        ti.resize(n);\n        for (int i = 0; i < n; ++i) {\n            ti[i] = start_ti;\n            start_ti += p + 1; // Ensure no overlapping\n            if (start_ti > max_ti) {\n                start_ti = (start_ti % max_ti) + 1;\n            }\n            ci[i] = rnd.next(1, 4000);\n            hi[i] = rnd.next(1, 4000);\n        }\n        for (int i = 0; i < q; ++i) {\n            // Visit during availability periods\n            int idx = rnd.next(0, n - 1);\n            aj[i] = ti[idx] + rnd.next(0, p - 1);\n            bj[i] = rnd.next(1, 4000);\n        }\n    } else if (type == \"max_ci\") {\n        for (int i = 0; i < n; ++i) {\n            ci[i] = 4000;\n            hi[i] = rnd.next(1, 4000);\n            ti[i] = rnd.next(1, 10000);\n        }\n    } else if (type == \"min_ci\") {\n        for (int i = 0; i < n; ++i) {\n            ci[i] = 1;\n            hi[i] = rnd.next(1, 4000);\n            ti[i] = rnd.next(1, 10000);\n        }\n    } else if (type == \"max_hi\") {\n        for (int i = 0; i < n; ++i) {\n            ci[i] = rnd.next(1, 4000);\n            hi[i] = 4000;\n            ti[i] = rnd.next(1, 10000);\n        }\n    } else if (type == \"min_hi\") {\n        for (int i = 0; i < n; ++i) {\n            ci[i] = rnd.next(1, 4000);\n            hi[i] = 1;\n            ti[i] = rnd.next(1, 10000);\n        }\n    } else if (type == \"max_items_at_same_time\") {\n        for (int i = 0; i < n; ++i) {\n            ci[i] = rnd.next(1, 4000);\n            hi[i] = rnd.next(1, 4000);\n            ti[i] = 1;\n        }\n        p = 10000;\n        for (int i = 0; i < q; ++i) {\n            aj[i] = 1;\n            bj[i] = rnd.next(1, 4000);\n        }\n    } else if (type == \"small_budget_large_ci\") {\n        for (int i = 0; i < n; ++i) {\n            ci[i] = rnd.next(2000, 4000);\n            hi[i] = rnd.next(1, 4000);\n            ti[i] = rnd.next(1, 10000);\n        }\n        for (int i = 0; i < q; ++i) {\n            aj[i] = rnd.next(1, 20000);\n            bj[i] = rnd.next(1, 1000);\n        }\n    } else if (type == \"large_budget_small_ci\") {\n        for (int i = 0; i < n; ++i) {\n            ci[i] = rnd.next(1, 1000);\n            hi[i] = rnd.next(1, 4000);\n            ti[i] = rnd.next(1, 10000);\n        }\n        for (int i = 0; i < q; ++i) {\n            aj[i] = rnd.next(1, 20000);\n            bj[i] = rnd.next(3000, 4000);\n        }\n    } else if (type == \"customer_no_items\") {\n        for (int i = 0; i < n; ++i) {\n            ci[i] = rnd.next(1, 4000);\n            hi[i] = rnd.next(1, 4000);\n            ti[i] = 10000; // After queries\n        }\n        for (int i = 0; i < q; ++i) {\n            aj[i] = rnd.next(1, 9999); // Before items are displayed\n            bj[i] = rnd.next(1, 4000);\n        }\n    } else if (type == \"customer_cannot_buy\") {\n        for (int i = 0; i < n; ++i) {\n            ci[i] = 4000; // Maximum cost\n            hi[i] = rnd.next(1, 4000);\n            ti[i] = rnd.next(1, 10000);\n        }\n        for (int i = 0; i < q; ++i) {\n            aj[i] = rnd.next(1, 20000);\n            bj[i] = 1; // Minimum budget\n        }\n    } else if (type == \"max_happiness_per_cost\") {\n        for (int i = 0; i < n; ++i) {\n            ci[i] = rnd.next(1, 1000);\n            hi[i] = min(4000, ci[i] * 4);\n            ti[i] = rnd.next(1, 10000);\n        }\n    } else if (type == \"min_happiness_per_cost\") {\n        for (int i = 0; i < n; ++i) {\n            ci[i] = rnd.next(1, 4000);\n            hi[i] = 1;\n            ti[i] = rnd.next(1, 10000);\n        }\n    } else {\n        // Random test case\n        for (int i = 0; i < n; ++i) {\n            ci[i] = rnd.next(1, 4000);\n            hi[i] = rnd.next(1, 4000);\n            ti[i] = rnd.next(1, 10000);\n        }\n        for (int i = 0; i < q; ++i) {\n            aj[i] = rnd.next(1, 20000);\n            bj[i] = rnd.next(1, 4000);\n        }\n    }\n\n    // Output n and p\n    printf(\"%d %d\\n\", n, p);\n\n    // Output n lines of ci, hi, ti\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d %d %d\\n\", ci[i], hi[i], ti[i]);\n    }\n\n    // Output q\n    printf(\"%d\\n\", q);\n\n    // Output q lines of aj, bj\n    for (int i = 0; i < q; ++i) {\n        printf(\"%d %d\\n\", aj[i], bj[i]);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -type max_n_q\n./gen -type max_p\n./gen -type min_p\n./gen -type same_ti\n./gen -type disjoint_ti\n./gen -type max_ci\n./gen -type min_ci\n./gen -type max_hi\n./gen -type min_hi\n./gen -type max_items_at_same_time\n./gen -type small_budget_large_ci\n./gen -type large_budget_small_ci\n./gen -type customer_no_items\n./gen -type customer_cannot_buy\n./gen -type max_happiness_per_cost\n./gen -type min_happiness_per_cost\n./gen -n 4000 -p 1 -q 20000 -type random\n./gen -n 4000 -p 10000 -q 20000 -type random\n./gen -n 1 -p 1 -q 1 -type random\n./gen -n 1 -p 10000 -q 1 -type random\n./gen -n 1 -p 1 -q 20000 -type random\n./gen -n 4000 -p 10000 -q 1 -type random\n./gen -n 1000 -p 5000 -q 5000 -type random\n./gen -n 4000 -p 5000 -q 20000 -type max_hi\n./gen -n 4000 -p 5000 -q 20000 -type min_hi\n./gen -n 4000 -p 5000 -q 20000 -type max_ci\n./gen -n 4000 -p 5000 -q 20000 -type min_ci\n./gen -n 4000 -p 10000 -q 20000 -type small_budget_large_ci\n./gen -n 4000 -p 10000 -q 20000 -type large_budget_small_ci\n./gen -n 100 -p 50 -q 100 -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:40:08.767695",
        "total_tutorials": 3,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "500/G",
      "title": "G. Новогодний забег",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест4 секунды",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеВ первой строке записано единственное положительное целое число, n (5 ≤ n ≤ 2 × 105) — количество городов на Древесном острове.Следующие n - 1 строк описывают дороги Древесного острова. В i-й (1 ≤ i ≤ n - 1) из этих строк записано два целых числа через пробел, ai и bi (1 ≤ ai, bi ≤ n, ai ≠ bi) — вершины, соединенные одной дорогой дерева.В следующей строке записано одно целое число t (1 ≤ t ≤ 2 × 105) — количество тестовых примеров.Следующие t строк описывают тестовые примеры. В j-й строке (1 ≤ j ≤ t) записано четыре целых числа через пробел uj, vj, xj, yj (1 ≤ uj, vj, xj, yj ≤ n, uj ≠ vj, xj ≠ yj). Это значит, что в этом тестовом примере JH выбрал два города, uj и vj, JY выбрал два города, xj и yj. JH начинает бежать из города uj, а JY начинает бежать из города xj.",
      "output_spec": "Выходные данныеДля каждого тестового примера выведите целое число, описывающее количество времени, необходимое для пробега в минутах. Если ребятам придётся бежать бесконечно долго (иными словами, если бегуны никогда не встретятся в одном городе), выведите -1. Если ребята встретятся в момент начала забега, выведите 0.",
      "sample_tests": "ПримерыВходные данныеСкопировать71 33 67 43 75 47 246 5 5 33 5 4 61 5 1 31 5 3 1Выходные данныеСкопировать210-1",
      "description": "G. Новогодний забег\n\nограничение по времени на тест4 секунды\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвыводstdout\n\nВходные данныеВ первой строке записано единственное положительное целое число, n (5 ≤ n ≤ 2 × 105) — количество городов на Древесном острове.Следующие n - 1 строк описывают дороги Древесного острова. В i-й (1 ≤ i ≤ n - 1) из этих строк записано два целых числа через пробел, ai и bi (1 ≤ ai, bi ≤ n, ai ≠ bi) — вершины, соединенные одной дорогой дерева.В следующей строке записано одно целое число t (1 ≤ t ≤ 2 × 105) — количество тестовых примеров.Следующие t строк описывают тестовые примеры. В j-й строке (1 ≤ j ≤ t) записано четыре целых числа через пробел uj, vj, xj, yj (1 ≤ uj, vj, xj, yj ≤ n, uj ≠ vj, xj ≠ yj). Это значит, что в этом тестовом примере JH выбрал два города, uj и vj, JY выбрал два города, xj и yj. JH начинает бежать из города uj, а JY начинает бежать из города xj.\n\nВходные данные\n\nВыходные данныеДля каждого тестового примера выведите целое число, описывающее количество времени, необходимое для пробега в минутах. Если ребятам придётся бежать бесконечно долго (иными словами, если бегуны никогда не встретятся в одном городе), выведите -1. Если ребята встретятся в момент начала забега, выведите 0.\n\nВыходные данные\n\nВходные данныеСкопировать71 33 67 43 75 47 246 5 5 33 5 4 61 5 1 31 5 3 1Выходные данныеСкопировать210-1\n\nВходные данныеСкопировать71 33 67 43 75 47 246 5 5 33 5 4 61 5 1 31 5 3 1\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать210-1\n\nВыходные данныеСкопировать\n\nСкопировать\n\nПримечаниеПример выглядит так:",
      "solutions": [
        {
          "title": "Good Bye 2014 - Codeforces",
          "content": "Привет, Codeforces!Добро пожаловать на последний раунд Codeforces в 2014 году, Good Bye 2014! Этот раунд очень необычный; Во-первых, раунд начинается 30 декабря в 18:00 по Москве. Во-вторых, раунд длится 2.5 часа. И в третьих, раунд будет общим для двух дивизионов, что означает, что Div1- и Div2-участники не будут разделены.Задачи подготовлены мной (.o.) и Seunghyun Jo (ainta). Это наш второй раунд на Codeforces. После нашего первого раунда случился чёрный день Codeforces, и мы надеемся, что в этот раз ничего подобного не произойдёт :DСпасибо Won-seok Yoo(ainu7), который тестировал раунд и обусждал с нами набор задач.Также мы хотим поблагодарить некоторых людей, без которых этот раунд не состоялся бы. Максим Ахмедов (Zlobober) сильно помог нам в подготовке задач. Мария Белова (Delinur) перевела условия задач на русский язык. Михаил Мирзаянов (MikeMirzayanov) создал прекрасные сайт Codeforces и систему Polygon. Они также заслуживают аплодисменты!Разбалловка будет оглашена перед началом раунда, как обычно.Мы желаем вам всем удачи. С новым годом!Просьба оставлять комментарии на английском языке, если вы хотите, чтобы авторы смогли их прочитать.UPD (2014-12-30 17:34:48) Разбалловка будет выглядеть следующим образом: 500-1000-1000-1500-2750-2750-3500.UPD (2014-12-31 12:49:05) Sorry for updating in English. Round has finished, congratulations to the winners! tourist Petr rng_58 HYPERHYPERHYPERCUBELOVER subscriber Merkurev al13n mmaxio mexmans GlebsHP Also, thanks to Marcin_smu, who solved problem G after the contest for the first time.UPD(2014-12-31 12:51:08) Sorry for updating in English. Editorial is published. Currently, only A-F is available, but I will add G as soon as possible. Sorry for the late editorial.UPD(2015-01-02 21:30:44) I wrote the editorial of G. Sorry for the late update..",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/15465",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.6,
            "reason": "宽松匹配: 包含题目编号 500 和字母"
          },
          "content_length": 1816
        },
        {
          "title": "Good Bye 2014 Tutorial - Codeforces",
          "content": "500A — New Year TransportationIn this problem we are given a directed graph, and asked whether a particular vertex is reachable from vertex 1. It is possible to solve this by running a depth-first search starting from vertex 1.Since every vertex has at most one outgoing edge, it is possible to write the DFS as a simple loop. Some people used this to make very short submissions.500B — New Year PermutationImagine a graph with one vertex for each entry in the permutation, and edges between pairs of swappable entries. It is easy to see that no matter how many swaps we make, no entry can end up in a location that is not in its connected component. We can also show that within any connected component, we can achieve any rearrangement of the entries that we wish.Since we want to make the lexicographically smallest permutation, we should greedily rearrange the entries within each connected component so that they are in increasing order.N ≤ 300, so we are not concerned with runtime. One can determine the connected components using a number of standard algorithms (Floyd-Warshall, Union Find, etc.).500C — New Year Book ReadingConsider an arbitrary day d, on which we must read book b. Let d' be the last day before d on which book b was read (if there is no previous day, let d' =  - ∞). Observe that, on day d, we cannot avoid lifting all of the books read on any day between d' and d. If we add up all the weights of these required liftings, we will have a lower bound on the answer.This lower bound can be computed with two loops, in O(M2) time. We must be sure not to add a book's weight multiple times, if it was read multiple times in the interval (d', d).If we initially arrange the books in order of the first day on which they are read, we will achieve the described lower bound. So, we have our answer.500D — New Year Santa NetworkBy linearity of expectation, E(d(c1, c2) + d(c1, c3) + d(c2, c3)) = E(d(c1, c2)) + E(d(c1, c3)) + E(d(c2, c3)). By symmetry, those three values are all equal. So, we need only compute E(d(c1, c2)). We can multiply it by 3 to find the answer.Let us imagine that a random selection (c1, c2, c3) is made. We'll define a function f(j), for each edge j, so that f(j) = wj if j is part of the shortest path from c1 to c2, and f(j) = 0 otherwise. Observe that . Again by linearity, we have .We can write E(f(j)) = wj·P(j), where P(j) is the probability that edge j is included in the path from c1 to c2. If we compute P(j) for all j, we can then compute in O(N). Also, we can handle updates in O(1); if wj changes to w'j, we subtract wj·P(j) from the answer, and add w'j·P(j). So, let's figure out P(j) for each j. Any edge j, if removed from the tree, separates the graph into two separate connected components a and b. Edge j will be included in the shortest path from c1 to c2 if and only if one of them is in a, and the other is in b. So, we want the number of ways to select (c1, c2, c3) such that c1 and c2 are on opposite sides of edge j, divided by the total number of ways to select (c1, c2, c3). Let's have |a| and |b| denote the number of vertices in a and b, respectively. Then .To figure out |a| and |b| for each j, we can root the tree arbitrarily and compute the depth and subtree size for each vertex in O(N) time. Then for an edge j, if vj is the deeper vertex incident to j, we know one component has size equal to the subtree size of vj. For the other component, we use the fact that |b| = N - |a|. 500E — New Year DominoWhen domino i is knocked over, it covers the interval [pi, pi + li]. If we see a query (xj, yj), it is equivalent to the question \"If we knock over all dominoes with index , how much of the interval [pxj, pyj] won't be covered?\" We can modify that question a little more, to say that we knock over all dominoes with index i ≥ xj, without changing its answer. Now, consider knocking over the dominoes from right to left. As soon as we knock over domino i, we will immediately process all of the queries with xj = i, and record their answers. What we need is a data structure that supports two operations: \"cover range [pi, pi + li]\" (when we knock over a domino) and \"compute how much of the range [pxj, pyj] is not covered\" (when we wish to answer a query). This can be done using coordinate compression and a segment tree. It's worth noting there are a lot of other ways to solve this problem. The other tutorial uses a completely different approach. Also, the approach described here may be implemented using different data structures. For example, here is my implementation using BBSTs and a Binary Indexed Tree.500F — New Year ShoppingWe will use the standard dynamic programming approach for 0/1 knapsack. To summarize what it does for us, imagine we are given an ordered list of items (ci, hi). Let F(k, b) be the maximum happiness we can buy, if we consider only the first k items in the list, and have a budget of b. If K is the size of the list, and B is the maximum possible budget, we can compute F(k, b) for all possible k and b in O(KB) time.Let us sort all of the items by their display time. Suppose that we focus on the queries (aj, bj) with , for some particular t. Let A be a list of the items with display time in (t - P, t], and let B be a list of the items with display time in (t, t + P). Let both lists be sorted in order of display time.Every query with will have available to it some suffix of A, along with some prefix of B. We'll do a knapsack DP on the elements of A, in reverse order, and another on the elements of B, in normal order. Finally, to answer any query (aj, bj) with , we can consider all possible ways to split the budget bj between the items in A and the items in B, in linear time. For each possible way to split the budget, we need simply look up one value from each DP table to know the maximum possible happiness.If we perform the process above on t = 1, 1 + P, 1 + 2P, 1 + 3P, ... until t exceeds the maximum possible day D, we'll be able to answer all of the queries. Let's think about the runtime of this solution. For each t, the described process takes O(KB) time, where K is the number of items whose display time is in (t - P, t + P). Each object can only appear in up to two of these intervals. So, the overall runtime for all of the knapsack DP's we perform is O(nB). Computing the final answer takes O(B) per query, or O(qB) overall.500G — New Year RunningDon't know how to solve this yet. Maybe someone who is not gray can provide the solution. :)",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/15513",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 500\\s*G"
          },
          "content_length": 6486
        },
        {
          "title": "Good Bye 2014 Editorial - Codeforces",
          "content": "First of all, sorry for the late editorial. I was too exhausted and immediately went to bed after the round finished, and didn't write the editorial.There are many pictures in this editorial, to cover up my poor English skills! If you have detected any errors or have questions, feel free to ask questions by comments. Unfortunately, the authors only know English, so we can't answer you if you write comments in Russian.500A - Транспорт на Новый годLet's assume that I am in the cell i (1 ≤ i ≤ n). If i ≤ n - 1, I have two choices: to stay at cell i, or to go to cell (i + ai). If i = t, we are at the target cell, so I should print \"YES\" and terminate. If i > t, I cannot go to cell t because I can't use the portal backwards, so one should print \"NO\" and terminate. Otherwise, I must go to cell (i + ai).Using this method, I visit each cell at most once, and there are n cells, so the problem can be solved in linear time.What is test 13?There are 9 pretests in this problem. There are no test where n = t holds in pretests. Many people didn't handle this case, and got hacked or got Wrong Answer on test 13. Time: O(n) Memory: O(n) (maybe O(1)) Implementation: 9335683 500B - Новогодняя перестановкаIt seems that many contestants were confused by the statement, so let me clarify it first. Given a permutation p1, p2, ..., pn and a n × n-sized binary matrix A, the problem asks us to find the lexicographically minimum permutation which can be achieved by swapping two distinct elements pi and pj where the condition Ai, j = 1 holds. (From the statement, permutation A is prettier than permutation B if and only if A is lexicographically less than B.)Let's think matrix A as an adjacency matrix of a undirected unweighted graph.If two vertices i and j are in the same component (in other words, connected by some edges), the values of pi and pj can be swapped, using a method similar to bubble sort. Look at the picture below for easy understanding.Because all the two distinct vertices in the same component can be swapped, the vertices in the same component can be sorted. In conclusion, we can solve the problem by the following procedure. Find all the connected components. For each component, sort the elements in the component. Print the resulting permutation. The size limit is quite small, so one can use any algorithm (DFS/BFS/..) for as many times as you want. Time: O(n2) — because of the graph traversal. O(n3) is okay because of small constraints. Memory: O(n2) Implementation: 9335689 (.o.) What is test 15? There are too many wrong answers in this case.Actually, I made the pretests very weak in order to make many hacks. As mentioned in the Hack me! post by kostka, just swapping the elements greedily could pass the pretests easily. There were 14 pretests, and I made test 15 an counter-example of such algorithm in order to reduce judging time, and it seems that most of the wrong submissions failed in this test case :D500C - В Новый год --- с книгой!In order to calculate the minimum possible lifted weight, we should find the initial stack first. Let's find the positions one by one. First, let's decide the position of book b1. After day 1, book b1 will be on the top of the stack, regardless of the order of the initial stack. Therefore, in order to minimize the lifted weight during day 1, book b1 must be on the top of the initial stack. (so actually, in day 1, Jaehyun won't lift any book) Next, let's decide the position of book b2. (assume that b1 ≠ b2 for simplicity) Currently, b1 is on the top of the stack, and it cannot be changed because of the procedure. Therefore, in order to minimize the lifted weight during day 2, book b2 must be immediately below book b1. Considering this, we can find the optimal strategy to create the initial stack: Scan b1, b2, ..., bm step by step. Let's assume that I am handling bi now. If bi has appeared before (formally, if ), erase bi from the sequence. Otherwise, leave bi. The resulting sequence will be the optimal stack.You should note that it is not necessary for Jaehyun to read all the books during 2015, which means the size of the resulting sequence may be smaller than n. The books which doesn't appear in the resulting sequence must be in the bottom of the initial stack (obviously). However, this problem doesn't require us to print the initial stack, so it turned out not to be important. In conclusion, finding the initial stack takes O(n + m) time.After finding the initial stack, we can simulate the procedure given in the statement naively. It will take O(nm) time. Time: O(nm) Memory: O(n + m) Implementation: 9335694 (.o.) 500D - Новогоднее взаимодействие Санта-КлаусовThe problem asks us to calculate the value ofLet's write it down..So, we need to calculate the value of . I'll denote the sum as S. How should we calculate this?For simplicity, I'll set node 1 as the root of the tree. Let's focus on an edge e, connecting two vertices u and p. See the picture below.Set A is a set of vertices in the subtree of vertex u, and set B is a set of vertices which is not in the subtree of vertex u. So, is the set of vertices in the tree, and is empty.For all pairs of two vertices (x, y) where the condition and holds, the shortest path between x and y contains edge e. There are size(A) × size(B) such pairs. So, edge e increases the sum S by 2 × le × size(A) × size(B). (because d(x, y) and d(y, x) both contributes to S)size(A) (the size of the subtree whose root is u) can be calculated by dynamic programming in trees, which is well known. size(B) equals to N - size(A). So, for each edge e, we can pre-calculate how many times does this edge contributes to the total sum. Let's define t(e) = size(A) × size(B), (A and B is mentioned above). If the length of a certain road e decreases by d, S will decrease by t(e) × d. So we can answer each query. Time: O(n) (pre-calculation) + O(q) (query) Memory: O(n) (O(n + q) is okay too) Implementation: 9335695 (.o.) Something about precision errorBecause of the tight constraints, the total sum of d(a, b) + d(b, c) + d(c, a) (it is equal to S × (n - 2)) can be so large that it can't be saved in long long(64-bit integer) type. Some contestants didn't handle this and got WA. However, there are some contestants who saved this value divided by n × (n - 1) × (n - 2) in double type. double has 52 bits to store exact value, so it isn't enough. But because we allow 10 - 6 precision error, it seems to have been got accepted.What if we allowed the length of the road could become 0? Then the precision error gets much more bigger, and the solution prints something that is far from the expected value (for example, negative value). ainu7 discovered this effect and suggested to apply this, but we didn't because it was hard to fix the statement..Why does the road length decreases? It doesn't matter even if increases.It's because of the weird legend. It is hard to explain, \"People repairs a certain road per year, and its length may be increased or decreased.\" fluently for me..500E - Новогоднее доминоFrom the statement, it is clear that, when domino i falls to the right, it makes domino j also fall if and only if pi < pj ≤ pi + li.For each domino i, let's calculate the rightmost position of the fallen dominoes R[i] when we initially pushed domino i. From the definition, . This can be calculated by using a segment tree or using a stack, in decreasing order of i (from right to left). After that, we define U[i] as the smallest j where R[i] < pj holds. (In other words, the smallest j where domino j is not affected by pushing domino i)Now, the problem becomes: Calculate P[U[xi]] - R[xi] + P[U[U[xi]]] - R[U[xi]] + ..., until U[xi] ≤ yi. Because i < U[i], this task can be solved by precalculating 'jumps' of 2something times, using the method described in here. You must read the \"Another easy solution in <O(N logN, O(logN)>\" part..Formally, let's define Un + 1[k] = U[Un[k]] and Sn + 1[k] = Sn[k] + (P[Un + 1[k]] - R[Un[k]]). So, Sn[k] means the sum of domino length extensions when we initially push domino i and we prolonged the length exactly n times. U2i + 1[k] = U2i[U2i[k]], and S2i + 1[k] = S2i[k] + S2i[U2i[k]] holds. (If you don't understand this part, I suggest you to read the article linked above) Time : or . Memory : Implementation: 9335698 (.o.) We would like to know whether there is a linear offline solution or not. 500F - Новогодние покупки The i-th item is available during [ti, ti + p - 1]. In other words, at time T, item i is available if and only if ti ≤ T ≤ ti + p - 1. This can be re-written as (ti ≤ T and T - p + 1 ≤ ti), which is T - p + 1 ≤ ti ≤ T. With this observation, we can transform the item's purchasable range into a dot, and the candidate's visit time into a range: From now on, item i is only available at time ti. and each candidate pair (aj, bj) means that I can visit the store during [aj - p + 1, aj], and my budget is bj dollars at that visit. This transformation makes the problem easier to solve.Each red circled point denotes an item which is sold at that time, and each black interval denotes a candidate. Let's only consider the intervals which passes time T. All the intervals' length is exactly p, so the left bound of the interval is (T - p) and the right bound of the interval is (T + p). For each interval, we'd like to solve the 0/1 knapsack algorithm with the items that the interval contains. How can we do that effectively? There is an important fact that I've described above: all the interval passes time T. Therefore, the interval [aj - p + 1, aj] can be split into two intervals: [aj - p + 1, T - 1] and [T, aj].So, let's solve the 0/1 knapsack problem for all intervals [x, T - 1] (T - p ≤ x ≤ T - 1) and [T, y] (T ≤ y ≤ T + p). Because one of the endpoints is fixed, one can run a standard dynamic programming algorithm. Therefore, the time needed in precalculation is O(S × W), where S is the number of items where the condition holds.Let's define h(I, b), as the maximum happiness I can obtain by buying the items where the condition holds, using at most b dollars. For each candidate (aj, bj), we have to calculate h([aj - p + 1, aj], bj), which is equal to max0 ≤ k ≤ b{h([aj - p + 1, T - 1], k) + h([T, aj], b - k)}. So it takes O(bj) = O(W) time to solve each query.The only question left is: How should we choose the value of T? We have two facts. (1) The length of intervals is exactly p. (2) The algorithm covers intervals which passes time T. Therefore, to cover all the intervals given in the input, we should let T be p, 2p, 3p, 4p, ... (of course, one by one), and run the algorithm described above.Then, what is the total time complexity? Think of intervals [0, 2p], [p, 3p], [2p, 4p], [3p, 5p], .... For each point, there will be at most two intervals which contains the point. Therefore, each item is reflected in the pre-calculation at most twice, so the time needed to precalculate is O(n × W). The time needed to solve each query is O(bj), and the answer of the query is calculated at most once. Therefore, the time needed to answer all the queries is O(q × W). Time : O((n + q) × W). Memory : O(n × W) Implementations: 9335699 (ainta), 9335703 (ainu7) , 9335710 (.o., using a different approach), 9335709 (.o., using a divide and conquer approach) Divide and Conquer approachLet's assume that t1 ≤ t2 ≤ ... ≤ tn. We can easily know that at time T, the indexes of all the available items forms a segment [l, r]. (in other words, item l, item l + 1, ..., item r - 1, item r is available) We can use this fact to solve all the queries. Let's assume that item lj, item lj + 1, ..., item rj - 1, item rj is available at time aj.Define a function solve(L, R). This function calculates the answer for queries where the condition L ≤ lj ≤ rj ≤ R holds. Let's assume that L < R holds. (In the case L ≥ R, the answer can be calculated easily) Let . Call solve(L, M) and solve(M + 1, R). After that, the queries needed to be calculated, satisfies the condition lj ≤ M < rj, which means all the intervals(queries) passes item M. Now, to calculate the answer for such queries, we can use the method described at the dynamic programming approach.The time complexity is , because and the answer of the queries can be calculated in O(bj) per query. Time : . Memory : O(n × W) Implementation: 9335709 Unfortunately, this approach is offline, because of the memory. Is there any available online approach using divide and conquer?Blocking the divide and conquer solutionI tried my best to block divide and conquer solutions, but failed. It seems that many participants solved the problem with divide and conquer approach. My approach takes time, and it gets accepted in 546ms.500G - Новогодний забегBefore starting the editorial, I'd like to give a big applause to Marcin_smu, who solved the problem for the first time!Warning: The editorial is very long and has many mistakes. There are lots of lots of mistakes.. Keep calm, and please tell me by comments, if you discovered any errors.This problem can be solved by an online algorithm. Let's focus on a single query (u, v, x, y). This means that JH runs between u and v, and JY runs between x and y.Just like when we solve many problems with undirected trees, let vertex 1 be the root of the tree. Also, we will assume that they won't stop after when they meet, but they will continue running, in order to explain easily.Some definitions: Path (a, b): the shortest path between vertex a and vertex b. d(a, b): the length of Path (a, b). LCA(a, b): the lowest common ancestor of vertex a and vertex b. Finding the common path of two pathsIf there is no common vertex between Path (u, v) and Path (x, y), the answer will be obviously  - 1. So, let's find the common vertices first. Because the path between two vertices is always unique, the common vertices also form a path. So, I'll denote the path of the common vertices as Path (c1, c2). c1 and c2 may be equal to: u, v, x, y, and even each other.The possible endpoints are P1 = LCA(u, v), P2 = LCA(x, y), P3 = LCA(u, x), P4 = LCA(u, y), P5 = LCA(v, x), and P6 = LCA(v, y). Figure out by drawing some examples. (some of you might think it's obvious :D)See the pictures above, and make your own criteria to check whether the two paths intersects :DA small hint. Let's assume that we already know, that a vertex a lies on path (x, y). If a lies on path (u, v), a is a common vertex of two paths. What if a is guaranteed to be an end point of the common path?Additional definitions Let's denote JH's running course is: . Then, there are two possible courses for JY: and ). fJH : the time needed to run the course . fJY : the time needed to run the course . t1 : the first time when JH passes vertex c1, moving towards c2. t2 : the first time when JH passes vertex c2, moving towards c1. t3 : the first time when JY passes vertex c1, moving towards c2. t4 : the first time when JY passes vertex c2, moving towards c1. Case 1) When JH and JY meets while moving in the same directionObviously, they must meet at vertex c1 or vertex c2 for the first time. Without loss of generality, let's assume that they meet at vertex c1. In this case, both of them is moving towards vertex c2. (You can use the method similarly for c2) Let's assume that JH and JY meets at time T. Because the movements of both runners are periodic, T must satisfy the conditions below: Among possible T-s, we have to calculate the smallest value. How should we do? From the first condition, we can let T = fJH × p + t1, where p is a non-negative integer. With this, we can write the second condition as: . In conclusion, we have to find the smallest p which satisfies the condition Using the Extended Euclidean algorithm is enough to calculate the minimum p. With p, we can easily calculate the minimum T, which is the first time they meet. If there is no such p, they doesn't meet forever, so the answer is  - 1.Case 2) When JH and JY meets while moving in the opposite directionIn this case, they will meet at a vertex lying on Path (c1, c2). Without loss of generality, let's assume that JH is going from c1 to c2, and JY is going from c2 to c1.I'll assume that JH and JY meets at time T. [1] Let's see how JH moves: For all non-negative integer p, At time fJH × p + t1, he is at vertex c1, moving towards c2. At time fJH × p + t1 + d(c1, c2), he is at vertex c2. Therefore, when fJH × p + t1 ≤  (current time)  ≤ fJH × p + t1 + d(c1, c2), JH is on Path (c1, c2). So, T must satisfy the condition: fJH × p + t1 ≤ T ≤ fJH × p + t1 + d(c1, c2) [2] Let's see how JY moves: Similar to JH, for all non-negative integer q, At time fJY × q + t4, he is at vertex c2, moving towards c1. At time fJY × q + t4 + d(c2, c1), he is at vertex c1. Therefore, when fJY × q + t4 ≤  (current time)  ≤ fJY × q + t4 + d(c2, c1), JY is on Path (c2, c1). So, T must satisfy the condition: fJY × q + t4 ≤ T ≤ fJY × q + t4 + d(c1, c2) [3] These two conditions are not enough, because in this case, they can meet on an edge, but they cannot meet on a vertex.We'd like to know when do they meet on a vertex, like the picture below.As you see from the picture above, in this case, the condition d(c1, a) + d(a, c2) = d(c1, c2) holds. If this picture was taken at time s, this condition can be written as: {s - (fJH × p + t1)} + {s - (fJY × q + t4)} = d(c1, c2) 2s - (fJH × p + fJY × q) - (t1 + t4) = d(c1, c2) s = {d(c1, c2) + (fJH × p + fJY × q) + (t1 + t4)} / 2 Because JH and JY both travel their path back and forth, fJH and fJY are all even. Therefore, in order to make s an integer, d(c1, c2) + t1 + t4 must be even. This can be written as [4] Merging [1], [2] and [3], we can conclude that if these two conditions holds, max{fJH × p + t1, fJY × q + t4} ≤ min{fJH × p + t1 + d(c1, c2), fJY × p + t4 + d(c1, c2)} JH and JY meets on a certain vertex lying on path (c1, c2). The first condition can be easily checked, so let's focus on the second condition. The second condition holds if and only if: fJY × q + t4 - t1 - d ≤ fJH × p ≤ fJY × q + t4 - t1 + d You can check this by changing \"fJH × p\" to the lower bound and the upper bound of the inequality. Therefore, the problem is to find the smallest p which satisfies the condition above.Let's define a function g(M, D, L, R), where M, D, L, R are all non-negative integers. The function returns the smallest non-negative integer m which satisfies . This function can be implemented as follows. If L = 0, g(M, D, L, R) = 0. (because L = 0 ≤ D·0) If , it is \"obvious\" that there is no solution. If 2D > M, g(M, D, L, R) = g(M, M - D, M - R, M - L). If there exists an non-negative integer m which satisfies L ≤ D·m ≤ R (without modular condition), g(M, D, L, R) = m. Obviously, we should take the smallest m. Otherwise, there exists an integer m which satisfies D·m < L ≤ R < D·(m + 1). We should use this fact.. If holds, there exists an non-negative integer k which satisfies L + Mk ≤ D·m ≤ R + Mk. Let's write down.. D·m - R ≤ M·k ≤ D·m - L  - R ≤ M·k - D·m ≤  - L L ≤ D·m - M·k  ≤ RBecause , we can write the inequality as Therefore the minimum k among all possible solutions is equal to . We can easily calculate the smallest p using k. Then, what is the time complexity of calculating g(M, D, L, R)? Because 2D ≤ M (the 2D > M case is handled during step 3), the problem size becomes half, so it can be executed in .ConclusionFor each query, we have to consider both Case 1) and Case 2), with all possible directions. Both cases can be handled in , so the time complexity per query is , and it has really huge constant. Time: Memory: Implementation: 9330235",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/15488",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 500\\s*G"
          },
          "content_length": 19579
        }
      ],
      "code_examples": [
        {
          "title": "Good Bye 2014 - Codeforces - Code 1",
          "code": "division combined",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15465",
          "author": "jiangly"
        },
        {
          "title": "Good Bye 2014 - Codeforces - Code 2",
          "code": "3\n3 1 2\n011\n100\n100",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15465",
          "author": "jiangly"
        },
        {
          "title": "Good Bye 2014 - Codeforces - Code 3",
          "code": "3\n3 1 2\n011\n100\n100",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15465",
          "author": "jiangly"
        },
        {
          "title": "Good Bye 2014 - Codeforces - Code 4",
          "code": "(3,2) (1,2)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15465",
          "author": "jiangly"
        },
        {
          "title": "Good Bye 2014 - Codeforces - Code 5",
          "code": "7\n7 3 4 6 8 1 2\n0010000\n0001000\n0000100\n0000000\n0000001\n1000000\n0000000",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15465",
          "author": "jiangly"
        },
        {
          "title": "Good Bye 2014 - Codeforces - Code 6",
          "code": "7\n7 3 4 6 8 1 2\n0010000\n0001000\n0000100\n0000000\n0000001\n1000000\n0000000",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15465",
          "author": "jiangly"
        },
        {
          "title": "Good Bye 2014 - Codeforces - Code 7",
          "code": "1 3 2 6 4 7 8",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15465",
          "author": "jiangly"
        },
        {
          "title": "Good Bye 2014 - Codeforces - Code 8",
          "code": "2 3 4 6 7 1 8",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15465",
          "author": "jiangly"
        },
        {
          "title": "Good Bye 2014 - Codeforces - Code 9",
          "code": "3\n3 1 2\n011\n100\n100",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15465",
          "author": "jiangly"
        },
        {
          "title": "Good Bye 2014 - Codeforces - Code 10",
          "code": "3\n3 1 2\n011\n100\n100",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15465",
          "author": "jiangly"
        },
        {
          "title": "Good Bye 2014 - Codeforces - Code 11",
          "code": "5\n2 4 1 3 5\n00101\n00010\n10011\n01100\n10100",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15465",
          "author": "jiangly"
        },
        {
          "title": "Good Bye 2014 - Codeforces - Code 12",
          "code": "5\n2 4 1 3 5\n00101\n00010\n10011\n01100\n10100",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15465",
          "author": "jiangly"
        },
        {
          "title": "Good Bye 2014 - Codeforces - Code 13",
          "code": "__mingw_printf",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15465",
          "author": "jiangly"
        },
        {
          "title": "Good Bye 2014 Editorial - Codeforces - Code 1",
          "code": "3.0 / ((long long)n * (n-1))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15488",
          "author": "jiangly"
        },
        {
          "title": "Good Bye 2014 Editorial - Codeforces - Code 2",
          "code": "actually the sorting is o(q*log(q))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15488",
          "author": "jiangly"
        },
        {
          "title": "Good Bye 2014 Editorial - Codeforces - Code 3",
          "code": "actually the sorting is o(q*log(q))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15488",
          "author": "jiangly"
        },
        {
          "title": "Good Bye 2014 Editorial - Codeforces - Code 4",
          "code": "upper_bound",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15488",
          "author": "jiangly"
        },
        {
          "title": "Good Bye 2014 Editorial - Codeforces - Code 5",
          "code": "merge_group(i, j)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15488",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAXN = 200000 + 5;\n\nint parent[MAXN];\n\n// Union-Find functions\nint find(int x) {\n    if (parent[x] != x)\n        parent[x] = find(parent[x]);\n    return parent[x];\n}\n\nbool unite(int x, int y) {\n    int px = find(x);\n    int py = find(y);\n\n    if (px == py)\n        return false;\n    parent[py] = px;\n    return true;\n}\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    // Read n\n    int n = inf.readInt(5, 200000, \"n\");\n    inf.readEoln();\n\n    // Initialize Union-Find parent array\n    for (int i = 1; i <= n; i++)\n        parent[i] = i;\n\n    // Read n-1 edges\n    for (int i = 0; i < n - 1; i++) {\n        int a = inf.readInt(1, n, \"ai\");\n        inf.readSpace();\n        int b = inf.readInt(1, n, \"bi\");\n        inf.readEoln();\n\n        // Ensure a != b\n        ensuref(a != b, \"Edge can't connect a node to itself (edge %d connects node %d to itself)\", i + 1, a);\n\n        // Check for cycles\n        bool merged = unite(a, b);\n        ensuref(merged, \"Edge %d creates a cycle in the graph (edge between %d and %d)\", i + 1, a, b);\n    }\n\n    // After adding all edges, check that the graph is connected\n    // Since it's supposed to be connected, all nodes should have the same parent\n    int root = find(1);\n    for (int i = 2; i <= n; i++) {\n        int pi = find(i);\n        ensuref(pi == root, \"Graph is not connected: Node %d is not connected to node 1\", i);\n    }\n\n    // Read t\n    int t = inf.readInt(1, 200000, \"t\");\n    inf.readEoln();\n\n    // For each test case\n    for (int i = 0; i < t; i++) {\n        int uj = inf.readInt(1, n, \"uj\");\n        inf.readSpace();\n        int vj = inf.readInt(1, n, \"vj\");\n        inf.readSpace();\n        int xj = inf.readInt(1, n, \"xj\");\n        inf.readSpace();\n        int yj = inf.readInt(1, n, \"yj\");\n        inf.readEoln();\n\n        // Ensure uj != vj\n        ensuref(uj != vj, \"In test case %d, uj should not be equal to vj\", i + 1);\n        // Ensure xj != yj\n        ensuref(xj != yj, \"In test case %d, xj should not be equal to yj\", i + 1);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAXN = 200000 + 5;\n\nint parent[MAXN];\n\n// Union-Find functions\nint find(int x) {\n    if (parent[x] != x)\n        parent[x] = find(parent[x]);\n    return parent[x];\n}\n\nbool unite(int x, int y) {\n    int px = find(x);\n    int py = find(y);\n\n    if (px == py)\n        return false;\n    parent[py] = px;\n    return true;\n}\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    // Read n\n    int n = inf.readInt(5, 200000, \"n\");\n    inf.readEoln();\n\n    // Initialize Union-Find parent array\n    for (int i = 1; i <= n; i++)\n        parent[i] = i;\n\n    // Read n-1 edges\n    for (int i = 0; i < n - 1; i++) {\n        int a = inf.readInt(1, n, \"ai\");\n        inf.readSpace();\n        int b = inf.readInt(1, n, \"bi\");\n        inf.readEoln();\n\n        // Ensure a != b\n        ensuref(a != b, \"Edge can't connect a node to itself (edge %d connects node %d to itself)\", i + 1, a);\n\n        // Check for cycles\n        bool merged = unite(a, b);\n        ensuref(merged, \"Edge %d creates a cycle in the graph (edge between %d and %d)\", i + 1, a, b);\n    }\n\n    // After adding all edges, check that the graph is connected\n    // Since it's supposed to be connected, all nodes should have the same parent\n    int root = find(1);\n    for (int i = 2; i <= n; i++) {\n        int pi = find(i);\n        ensuref(pi == root, \"Graph is not connected: Node %d is not connected to node 1\", i);\n    }\n\n    // Read t\n    int t = inf.readInt(1, 200000, \"t\");\n    inf.readEoln();\n\n    // For each test case\n    for (int i = 0; i < t; i++) {\n        int uj = inf.readInt(1, n, \"uj\");\n        inf.readSpace();\n        int vj = inf.readInt(1, n, \"vj\");\n        inf.readSpace();\n        int xj = inf.readInt(1, n, \"xj\");\n        inf.readSpace();\n        int yj = inf.readInt(1, n, \"yj\");\n        inf.readEoln();\n\n        // Ensure uj != vj\n        ensuref(uj != vj, \"In test case %d, uj should not be equal to vj\", i + 1);\n        // Ensure xj != yj\n        ensuref(xj != yj, \"In test case %d, xj should not be equal to yj\", i + 1);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAXN = 200000 + 5;\n\nint parent[MAXN];\n\n// Union-Find functions\nint find(int x) {\n    if (parent[x] != x)\n        parent[x] = find(parent[x]);\n    return parent[x];\n}\n\nbool unite(int x, int y) {\n    int px = find(x);\n    int py = find(y);\n\n    if (px == py)\n        return false;\n    parent[py] = px;\n    return true;\n}\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    // Read n\n    int n = inf.readInt(5, 200000, \"n\");\n    inf.readEoln();\n\n    // Initialize Union-Find parent array\n    for (int i = 1; i <= n; i++)\n        parent[i] = i;\n\n    // Read n-1 edges\n    for (int i = 0; i < n - 1; i++) {\n        int a = inf.readInt(1, n, \"ai\");\n        inf.readSpace();\n        int b = inf.readInt(1, n, \"bi\");\n        inf.readEoln();\n\n        // Ensure a != b\n        ensuref(a != b, \"Edge can't connect a node to itself (edge %d connects node %d to itself)\", i + 1, a);\n\n        // Check for cycles\n        bool merged = unite(a, b);\n        ensuref(merged, \"Edge %d creates a cycle in the graph (edge between %d and %d)\", i + 1, a, b);\n    }\n\n    // After adding all edges, check that the graph is connected\n    // Since it's supposed to be connected, all nodes should have the same parent\n    int root = find(1);\n    for (int i = 2; i <= n; i++) {\n        int pi = find(i);\n        ensuref(pi == root, \"Graph is not connected: Node %d is not connected to node 1\", i);\n    }\n\n    // Read t\n    int t = inf.readInt(1, 200000, \"t\");\n    inf.readEoln();\n\n    // For each test case\n    for (int i = 0; i < t; i++) {\n        int uj = inf.readInt(1, n, \"uj\");\n        inf.readSpace();\n        int vj = inf.readInt(1, n, \"vj\");\n        inf.readSpace();\n        int xj = inf.readInt(1, n, \"xj\");\n        inf.readSpace();\n        int yj = inf.readInt(1, n, \"yj\");\n        inf.readEoln();\n\n        // Ensure uj != vj\n        ensuref(uj != vj, \"In test case %d, uj should not be equal to vj\", i + 1);\n        // Ensure xj != yj\n        ensuref(xj != yj, \"In test case %d, xj should not be equal to yj\", i + 1);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<pair<int,int>> edges;\n\n// Generate a chain tree\nvoid generate_chain(int n) {\n    edges.clear();\n    for(int i = 2; i <= n; ++i) {\n        edges.push_back({i - 1, i});\n    }\n}\n\n// Generate a star-shaped tree\nvoid generate_star(int n) {\n    edges.clear();\n    for(int i = 2; i <= n; ++i) {\n        edges.push_back({1, i});\n    }\n}\n\n// Generate a random tree using random parents\nvoid generate_random_tree(int n) {\n    edges.clear();\n    for(int i = 2; i <= n; ++i) {\n        int p = rnd.next(1, i - 1);\n        edges.push_back({p, i});\n    }\n}\n\n// Generate a balanced binary tree\nvoid generate_balanced_tree(int n) {\n    edges.clear();\n    queue<int> q;\n    int idx = 1;\n    q.push(idx++);\n    while(idx <= n) {\n        int parent = q.front(); q.pop();\n        int left = idx++;\n        edges.push_back({parent, left});\n        q.push(left);\n        if(idx > n) break;\n        int right = idx++;\n        edges.push_back({parent, right});\n        q.push(right);\n    }\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int t = opt<int>(\"t\");\n    string tree_type = opt<string>(\"type\", \"random\");\n\n    if(tree_type == \"chain\") {\n        generate_chain(n);\n    } else if(tree_type == \"star\") {\n        generate_star(n);\n    } else if(tree_type == \"balanced\") {\n        generate_balanced_tree(n);\n    } else {\n        generate_random_tree(n);\n    }\n\n    // Shuffle node labels\n    vector<int> perm(n + 1);\n    for(int i = 1; i <= n; ++i) perm[i] = i;\n    shuffle(perm.begin() + 1, perm.end());\n\n    for(auto &e : edges) {\n        e.first = perm[e.first];\n        e.second = perm[e.second];\n    }\n\n    // Shuffle edges\n    shuffle(edges.begin(), edges.end());\n\n    // Output n\n    printf(\"%d\\n\", n);\n    // Output edges\n    for(auto e : edges) {\n        printf(\"%d %d\\n\", e.first, e.second);\n    }\n\n    // Output t\n    printf(\"%d\\n\", t);\n\n    // Generate t test cases\n    for(int i = 0; i < t; ++i) {\n        int u, v, x, y;\n        u = rnd.next(1, n);\n        do {\n            v = rnd.next(1, n);\n        } while(u == v);\n\n        x = rnd.next(1, n);\n        do {\n            y = rnd.next(1, n);\n        } while(x == y);\n\n        printf(\"%d %d %d %d\\n\", u, v, x, y);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<pair<int,int>> edges;\n\n// Generate a chain tree\nvoid generate_chain(int n) {\n    edges.clear();\n    for(int i = 2; i <= n; ++i) {\n        edges.push_back({i - 1, i});\n    }\n}\n\n// Generate a star-shaped tree\nvoid generate_star(int n) {\n    edges.clear();\n    for(int i = 2; i <= n; ++i) {\n        edges.push_back({1, i});\n    }\n}\n\n// Generate a random tree using random parents\nvoid generate_random_tree(int n) {\n    edges.clear();\n    for(int i = 2; i <= n; ++i) {\n        int p = rnd.next(1, i - 1);\n        edges.push_back({p, i});\n    }\n}\n\n// Generate a balanced binary tree\nvoid generate_balanced_tree(int n) {\n    edges.clear();\n    queue<int> q;\n    int idx = 1;\n    q.push(idx++);\n    while(idx <= n) {\n        int parent = q.front(); q.pop();\n        int left = idx++;\n        edges.push_back({parent, left});\n        q.push(left);\n        if(idx > n) break;\n        int right = idx++;\n        edges.push_back({parent, right});\n        q.push(right);\n    }\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int t = opt<int>(\"t\");\n    string tree_type = opt<string>(\"type\", \"random\");\n\n    if(tree_type == \"chain\") {\n        generate_chain(n);\n    } else if(tree_type == \"star\") {\n        generate_star(n);\n    } else if(tree_type == \"balanced\") {\n        generate_balanced_tree(n);\n    } else {\n        generate_random_tree(n);\n    }\n\n    // Shuffle node labels\n    vector<int> perm(n + 1);\n    for(int i = 1; i <= n; ++i) perm[i] = i;\n    shuffle(perm.begin() + 1, perm.end());\n\n    for(auto &e : edges) {\n        e.first = perm[e.first];\n        e.second = perm[e.second];\n    }\n\n    // Shuffle edges\n    shuffle(edges.begin(), edges.end());\n\n    // Output n\n    printf(\"%d\\n\", n);\n    // Output edges\n    for(auto e : edges) {\n        printf(\"%d %d\\n\", e.first, e.second);\n    }\n\n    // Output t\n    printf(\"%d\\n\", t);\n\n    // Generate t test cases\n    for(int i = 0; i < t; ++i) {\n        int u, v, x, y;\n        u = rnd.next(1, n);\n        do {\n            v = rnd.next(1, n);\n        } while(u == v);\n\n        x = rnd.next(1, n);\n        do {\n            y = rnd.next(1, n);\n        } while(x == y);\n\n        printf(\"%d %d %d %d\\n\", u, v, x, y);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 5 -t 1 -type chain\n./gen -n 5 -t 1 -type star\n./gen -n 5 -t 1 -type random\n./gen -n 5 -t 1 -type balanced\n\n./gen -n 10 -t 5 -type chain\n./gen -n 10 -t 5 -type star\n./gen -n 10 -t 5 -type random\n./gen -n 10 -t 5 -type balanced\n\n./gen -n 100 -t 50 -type chain\n./gen -n 100 -t 50 -type star\n./gen -n 100 -t 50 -type random\n./gen -n 100 -t 50 -type balanced\n\n./gen -n 1000 -t 500 -type chain\n./gen -n 1000 -t 500 -type star\n./gen -n 1000 -t 500 -type random\n./gen -n 1000 -t 500 -type balanced\n\n./gen -n 10000 -t 5000 -type chain\n./gen -n 10000 -t 5000 -type star\n./gen -n 10000 -t 5000 -type random\n./gen -n 10000 -t 5000 -type balanced\n\n./gen -n 200000 -t 200000 -type chain\n./gen -n 200000 -t 200000 -type star\n./gen -n 200000 -t 200000 -type random\n./gen -n 200000 -t 200000 -type balanced\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:40:11.253466",
        "total_tutorials": 3,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "501/A",
      "title": "A. Contest",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains four integers a, b, c, d (250 ≤ a, b ≤ 3500, 0 ≤ c, d ≤ 180). It is guaranteed that numbers a and b are divisible by 250 (just like on any real Codeforces round).",
      "output_spec": "OutputOutput on a single line: \"Misha\" (without the quotes), if Misha got more points than Vasya.\"Vasya\" (without the quotes), if Vasya got more points than Misha.\"Tie\" (without the quotes), if both of them got the same number of points.",
      "sample_tests": "ExamplesInputCopy500 1000 20 30OutputCopyVasyaInputCopy1000 1000 1 1OutputCopyTieInputCopy1500 1000 176 177OutputCopyMisha",
      "description": "time limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains four integers a, b, c, d (250 ≤ a, b ≤ 3500, 0 ≤ c, d ≤ 180). It is guaranteed that numbers a and b are divisible by 250 (just like on any real Codeforces round).\n\nOutputOutput on a single line: \"Misha\" (without the quotes), if Misha got more points than Vasya.\"Vasya\" (without the quotes), if Vasya got more points than Misha.\"Tie\" (without the quotes), if both of them got the same number of points.\n\nInputCopy500 1000 20 30OutputCopyVasyaInputCopy1000 1000 1 1OutputCopyTieInputCopy1500 1000 176 177OutputCopyMisha\n\nInputCopy500 1000 20 30\n\nOutputCopyVasya\n\nInputCopy1000 1000 1 1\n\nOutputCopyTie\n\nInputCopy1500 1000 176 177\n\nOutputCopyMisha",
      "solutions": [
        {
          "title": "Codeforces Round #285 - Codeforces",
          "content": "Hi, Codeforces!Codeforces Round #285 will be held at 12 January, 12.00 MSK. Problems are authored by me, Evgeny Savinov. This is my first round at Codeforces. I hope that this isn't the last one.I want to thank sokian and Golovanov399 for help in preparing and testing round, Zlobober for invaluable help in preparing round, AlexFetisov for testing round, Delinur for translating problem statements in English, and of course, MikeMirzayanov for great systems Codeforces and Polygon.By the way, today(11 January) is MikeMirzayanov's birthday. Happy birthday, Mike!The round will be for both divisions. Information about score distribution will be posted just before the round starts.UPD1: Scoring system will be dynamic. Problems will be arranged in ascending expected difficulty order.UPD2: The editorial can be found here. I'm sorry for the delay.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/15725",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 848
        },
        {
          "title": "Codeforces Round #285 Editorial - Codeforces",
          "content": "501A - ContestIn this problem one need to determine the number of points for both guys and find out who got more points.Time complexity: O(1).501B - Misha and Changing HandlesThe problem can be formulated as follows: The directed graph is given, its vertices correspond to users' handles and edges — to requests. It consists of a number of chains, so every vertex ingoing and outgoing degree doesn't exceed one. One need to find number of chains and first and last vertices of every chain. The arcs of this graph can be stored in dictionary(one can use std::map\\unoredered_map in C++ and TreeMap\\HashMap in Java) with head of the arc as the key and the tail as the value.Each zero ingoing degree vertex corresponds to unique user as well as first vertex of some chain. We should iterate from such vertices through the arcs while it's possible. Thus we find relation between first and last vertices in the chain as well as relation between the original and the new handle of some user.You can see my solution for details.Time complexity: .504A - Misha and ForestNote that every non-empty forest has a leaf(vertex of degree 1). Let's remove edges one by one and maintain actual values (degreev, sv) as long as graph is not empty. To do so, we can maintain the queue(or stack) of the leaves. On every iteration we dequeue vertex v and remove edge (v, sv) and update values for vertex sv: degreesv -= 1 and ssv ^= v. If degree of vertex sv becomes equal to 1, we enqueue it.When dequeued vertex has zero degree, just ignore it because we have already removed all edges of corresponding tree.You can see my solution for details.Time complexity: O(n)504B - Misha and Permutations SummationTo solve the problem, one need to be able to find the index of given permutation in lexicographical order and permutation by its index. We will store indices in factorial number system. Thus number x is represented as . You can find the rules of the transform here.To make the transform, you may need to use data structures such as binary search tree or binary indexed tree (for maintaining queries of finding k-th number in the set and finding the amount of numbers less than given one).So, one need to get indices of the permutations, to sum them modulo n! and make inverse transform. You can read any accepted solution for better understanding.Time complexity: or .504C - Misha and Palindrome DegreeNote that if the amount of elements, which number of occurrences is odd, is greater than one, the answer is zero. On the other hand, if array is the palindrome, answer is .Let's cut equal elements from the end and the beginning of array while it is possible. Let's call remaining array as b and its length as m. We are interested in segments [l, r] which cover some prefix or suffix of b.We need to find the minimum length of such prefix and suffix. Prefix and suffix can overlap the middle of b and these cases are needed to maintain. To find minimum length you can use binary search or simply iterating over array and storing the amount of every element to the left and right from the current index. Let's call minimum length of prefix as pref and as suf of suffix. So .Time complexity: O(n) or .504D - Misha and XORFirstly, we convert each number into a binary system: it can be done in O(MAXBITS2), where MAXBITS ≤ 2000 with rather small constant(we store number in system with big radix).To solve the problem we need to modify Gauss elimination algorithm. For each row we should store set of row's indices which we already XORed this row to get row echelon form (we can store it in bitset), also for each bit i we store index p[i] of row, which lowest set bit is i in row echelon form.Maintaining the query we try to reset bits from lowest to highest using array p and save information, which rows were XORed with current number. If we can reset whole number, the answer is positive and we know indices of answer. We update array p, otherwise.Time complexity: O(m × MAXBITS × (MAXBITS + m)) with small constant due to bit compression.504E - Misha and LCP on TreeLet's build heavy-light decomposition of given tree and write all strings corresponding to heavy paths one by one in one string T, every path should be written twice: in the direct and reverse order.Maintaining query we can split paths (a, b) и (c, d) into parts, which completely belongs to some heavy paths. There can be at most such parts. Note that every part corresponds to some substring of T.Now we only need to find longest common prefix of two substrings in string T. It can be done building suffix array of string T and lcp array. So, we can find longest common prefix of two substring in O(1) constructing rmq sparse table on lcp array.Time complexity: For the better understanding see my solution.P.S. One can uses hashes instead of suffix array.ADD: There is another approach to solve this problem in but it's rather slow in practice. We can do binary search on answer and use hashes, but we do it for all queries at one time. The only problem is to find k-th vertex on the path, we can do it offline for all queries in O(n + m) time. We run dfs and maintain stack of vertices. See my solution for details.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/15743",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 501\\s*A"
          },
          "content_length": 5171
        },
        {
          "title": "Codeforces Round #285 Editorial - Codeforces",
          "content": "501A - ContestIn this problem one need to determine the number of points for both guys and find out who got more points.Time complexity: O(1).501B - Misha and Changing HandlesThe problem can be formulated as follows: The directed graph is given, its vertices correspond to users' handles and edges — to requests. It consists of a number of chains, so every vertex ingoing and outgoing degree doesn't exceed one. One need to find number of chains and first and last vertices of every chain. The arcs of this graph can be stored in dictionary(one can use std::map\\unoredered_map in C++ and TreeMap\\HashMap in Java) with head of the arc as the key and the tail as the value.Each zero ingoing degree vertex corresponds to unique user as well as first vertex of some chain. We should iterate from such vertices through the arcs while it's possible. Thus we find relation between first and last vertices in the chain as well as relation between the original and the new handle of some user.You can see my solution for details.Time complexity: .504A - Misha and ForestNote that every non-empty forest has a leaf(vertex of degree 1). Let's remove edges one by one and maintain actual values (degreev, sv) as long as graph is not empty. To do so, we can maintain the queue(or stack) of the leaves. On every iteration we dequeue vertex v and remove edge (v, sv) and update values for vertex sv: degreesv -= 1 and ssv ^= v. If degree of vertex sv becomes equal to 1, we enqueue it.When dequeued vertex has zero degree, just ignore it because we have already removed all edges of corresponding tree.You can see my solution for details.Time complexity: O(n)504B - Misha and Permutations SummationTo solve the problem, one need to be able to find the index of given permutation in lexicographical order and permutation by its index. We will store indices in factorial number system. Thus number x is represented as . You can find the rules of the transform here.To make the transform, you may need to use data structures such as binary search tree or binary indexed tree (for maintaining queries of finding k-th number in the set and finding the amount of numbers less than given one).So, one need to get indices of the permutations, to sum them modulo n! and make inverse transform. You can read any accepted solution for better understanding.Time complexity: or .504C - Misha and Palindrome DegreeNote that if the amount of elements, which number of occurrences is odd, is greater than one, the answer is zero. On the other hand, if array is the palindrome, answer is .Let's cut equal elements from the end and the beginning of array while it is possible. Let's call remaining array as b and its length as m. We are interested in segments [l, r] which cover some prefix or suffix of b.We need to find the minimum length of such prefix and suffix. Prefix and suffix can overlap the middle of b and these cases are needed to maintain. To find minimum length you can use binary search or simply iterating over array and storing the amount of every element to the left and right from the current index. Let's call minimum length of prefix as pref and as suf of suffix. So .Time complexity: O(n) or .504D - Misha and XORFirstly, we convert each number into a binary system: it can be done in O(MAXBITS2), where MAXBITS ≤ 2000 with rather small constant(we store number in system with big radix).To solve the problem we need to modify Gauss elimination algorithm. For each row we should store set of row's indices which we already XORed this row to get row echelon form (we can store it in bitset), also for each bit i we store index p[i] of row, which lowest set bit is i in row echelon form.Maintaining the query we try to reset bits from lowest to highest using array p and save information, which rows were XORed with current number. If we can reset whole number, the answer is positive and we know indices of answer. We update array p, otherwise.Time complexity: O(m × MAXBITS × (MAXBITS + m)) with small constant due to bit compression.504E - Misha and LCP on TreeLet's build heavy-light decomposition of given tree and write all strings corresponding to heavy paths one by one in one string T, every path should be written twice: in the direct and reverse order.Maintaining query we can split paths (a, b) и (c, d) into parts, which completely belongs to some heavy paths. There can be at most such parts. Note that every part corresponds to some substring of T.Now we only need to find longest common prefix of two substrings in string T. It can be done building suffix array of string T and lcp array. So, we can find longest common prefix of two substring in O(1) constructing rmq sparse table on lcp array.Time complexity: For the better understanding see my solution.P.S. One can uses hashes instead of suffix array.ADD: There is another approach to solve this problem in but it's rather slow in practice. We can do binary search on answer and use hashes, but we do it for all queries at one time. The only problem is to find k-th vertex on the path, we can do it offline for all queries in O(n + m) time. We run dfs and maintain stack of vertices. See my solution for details.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/15743",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 501\\s*A"
          },
          "content_length": 5171
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #285 - Codeforces - Code 1",
          "code": "#include <iostream>\nusing namespace std;\n\nint main ()\n{\n        cout << \"Happy Birthday Mike ! \\\\:D/\" << endl << \"Thanks For Everything !!! :D\" << endl;\n        return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/15725",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #285 - Codeforces - Code 2",
          "code": "#include <iostream>\nusing namespace std;\n\nint main ()\n{\n        cout << \"Happy Birthday Mike ! \\\\:D/\" << endl << \"Thanks For Everything !!! :D\" << endl;\n        return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/15725",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #285 - Codeforces - Code 3",
          "code": "math.factorial(x)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15725",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #285 - Codeforces - Code 4",
          "code": "math.factorial(200000)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15725",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #285 - Codeforces - Code 5",
          "code": "i = 1\nj = 1\nwhile(i <= n) {\n while(i > j || !is_it_a_good_range(i,j)) {\n  ++j;\n  update_set_with_bad_numbers(j);\n  update_set_with_bad_numbers(n+1-j);\n }\n update_set_with_bad_numbers(i);\n update_set_with_bad_numbers(n+1-i);\n ++i;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15725",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #285 - Codeforces - Code 6",
          "code": "i = 1\nj = 1\nwhile(i <= n) {\n while(i > j || !is_it_a_good_range(i,j)) {\n  ++j;\n  update_set_with_bad_numbers(j);\n  update_set_with_bad_numbers(n+1-j);\n }\n update_set_with_bad_numbers(i);\n update_set_with_bad_numbers(n+1-i);\n ++i;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15725",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #285 - Codeforces - Code 7",
          "code": "BigInteger x = new BigInteger(in.next());\nx.testBit(j);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15725",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #285 - Codeforces - Code 8",
          "code": "BigInteger x = new BigInteger(in.next());\nx.testBit(j);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15725",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #285 - Codeforces - Code 9",
          "code": "set<int>::iterator it = s.lower_bound(x);\ns.erase(it);\nupd(*it);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15725",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #285 - Codeforces - Code 10",
          "code": "set<int>::iterator it = s.lower_bound(x);\ns.erase(it);\nupd(*it);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15725",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int a = inf.readInt(250, 3500, \"a\");\n    ensuref(a % 250 == 0, \"a must be divisible by 250, a = %d\", a);\n    inf.readSpace();\n\n    int b = inf.readInt(250, 3500, \"b\");\n    ensuref(b % 250 == 0, \"b must be divisible by 250, b = %d\", b);\n    inf.readSpace();\n\n    int c = inf.readInt(0, 180, \"c\");\n    inf.readSpace();\n\n    int d = inf.readInt(0, 180, \"d\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int a = inf.readInt(250, 3500, \"a\");\n    ensuref(a % 250 == 0, \"a must be divisible by 250, a = %d\", a);\n    inf.readSpace();\n\n    int b = inf.readInt(250, 3500, \"b\");\n    ensuref(b % 250 == 0, \"b must be divisible by 250, b = %d\", b);\n    inf.readSpace();\n\n    int c = inf.readInt(0, 180, \"c\");\n    inf.readSpace();\n\n    int d = inf.readInt(0, 180, \"d\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int a = inf.readInt(250, 3500, \"a\");\n    ensuref(a % 250 == 0, \"a must be divisible by 250, a = %d\", a);\n    inf.readSpace();\n\n    int b = inf.readInt(250, 3500, \"b\");\n    ensuref(b % 250 == 0, \"b must be divisible by 250, b = %d\", b);\n    inf.readSpace();\n\n    int c = inf.readInt(0, 180, \"c\");\n    inf.readSpace();\n\n    int d = inf.readInt(0, 180, \"d\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare sequences of tokens\");\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string j, p;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n\r\n        ans.readWordTo(j);\r\n        ouf.readWordTo(p);\r\n\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s words differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  compress(j).c_str(), compress(p).c_str());\r\n    }\r\n\r\n    if (ans.seekEof() && ouf.seekEof()) {\r\n        if (n == 1)\r\n            quitf(_ok, \"\\\"%s\\\"\", compress(j).c_str());\r\n        else\r\n            quitf(_ok, \"%d tokens\", n);\r\n    } else {\r\n        if (ans.seekEof())\r\n            quitf(_wa, \"Participant output contains extra tokens\");\r\n        else\r\n            quitf(_wa, \"Unexpected EOF in the participants output\");\r\n    }\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int a = opt<int>(\"a\", -1);\n    int b = opt<int>(\"b\", -1);\n    int c = opt<int>(\"c\", -1);\n    int d = opt<int>(\"d\", -1);\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> possibleP;\n    for (int p = 250; p <= 3500; p += 250)\n        possibleP.push_back(p);\n\n    if (type == \"random\") {\n        if (a == -1)\n            a = possibleP[rnd.next(0, (int)possibleP.size() - 1)];\n        if (b == -1)\n            b = possibleP[rnd.next(0, (int)possibleP.size() - 1)];\n        if (c == -1)\n            c = rnd.next(0,180);\n        if (d == -1)\n            d = rnd.next(0,180);\n\n    } else if (type == \"edge\") {\n        // Choose min or max values randomly\n        int choicesP[2] = {250, 3500};\n        int choicesT[2] = {0, 180};\n\n        if (a == -1)\n            a = choicesP[rnd.next(0,1)];\n        if (b == -1)\n            b = choicesP[rnd.next(0,1)];\n        if (c == -1)\n            c = choicesT[rnd.next(0,1)];\n        if (d == -1)\n            d = choicesT[rnd.next(0,1)];\n\n    } else if (type == \"tie\") {\n        // Generate test case where Misha and Vasya get the same score\n        if (a == -1)\n            a = possibleP[rnd.next(0, (int)possibleP.size() - 1)];\n        if (b == -1)\n            b = possibleP[rnd.next(0, (int)possibleP.size() - 1)];\n        if (c == -1)\n            c = rnd.next(0,180);\n\n        // Compute Misha's score\n        auto computeScore = [](int p, int t) {\n            int s1 = (3 * p) / 10;\n            int s2 = p - (p * t) / 250;\n            return max(s1, s2);\n        };\n\n        int scoreMisha = computeScore(a, c);\n\n        // Try to find d such that Vasya's score equals Misha's score\n        bool found = false;\n        for (int dd = 0; dd <= 180; ++dd) {\n            int scoreVasya = computeScore(b, dd);\n            if (scoreVasya == scoreMisha) {\n                d = dd;\n                found = true;\n                break;\n            }\n        }\n\n        if (!found) {\n            // Could not find suitable d, exit\n            cerr << \"Could not find d to make tie. Try again.\" << endl;\n            exit(1);\n        }\n\n    } else if (type == \"method_equal\") {\n        // Generate test case where method1 and method2 give the same score\n        if (a == -1)\n            a = possibleP[rnd.next(0, (int)possibleP.size() -1)];\n\n        // Calculate t where methods are equal for Misha\n        int t_equal = 175; // (3/10)p = p - (p * t)/250 => t = 175\n\n        if (c == -1)\n            c = t_equal;\n\n        // For Vasya, pick random b and d\n        if (b == -1)\n            b = possibleP[rnd.next(0, (int)possibleP.size() -1)];\n        if (d == -1)\n            d = rnd.next(0, 180);\n\n    } else {\n        // Handle other types if needed\n    }\n\n    // Output the test case\n    printf(\"%d %d %d %d\\n\", a, b, c, d);\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int a = opt<int>(\"a\", -1);\n    int b = opt<int>(\"b\", -1);\n    int c = opt<int>(\"c\", -1);\n    int d = opt<int>(\"d\", -1);\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> possibleP;\n    for (int p = 250; p <= 3500; p += 250)\n        possibleP.push_back(p);\n\n    if (type == \"random\") {\n        if (a == -1)\n            a = possibleP[rnd.next(0, (int)possibleP.size() - 1)];\n        if (b == -1)\n            b = possibleP[rnd.next(0, (int)possibleP.size() - 1)];\n        if (c == -1)\n            c = rnd.next(0,180);\n        if (d == -1)\n            d = rnd.next(0,180);\n\n    } else if (type == \"edge\") {\n        // Choose min or max values randomly\n        int choicesP[2] = {250, 3500};\n        int choicesT[2] = {0, 180};\n\n        if (a == -1)\n            a = choicesP[rnd.next(0,1)];\n        if (b == -1)\n            b = choicesP[rnd.next(0,1)];\n        if (c == -1)\n            c = choicesT[rnd.next(0,1)];\n        if (d == -1)\n            d = choicesT[rnd.next(0,1)];\n\n    } else if (type == \"tie\") {\n        // Generate test case where Misha and Vasya get the same score\n        if (a == -1)\n            a = possibleP[rnd.next(0, (int)possibleP.size() - 1)];\n        if (b == -1)\n            b = possibleP[rnd.next(0, (int)possibleP.size() - 1)];\n        if (c == -1)\n            c = rnd.next(0,180);\n\n        // Compute Misha's score\n        auto computeScore = [](int p, int t) {\n            int s1 = (3 * p) / 10;\n            int s2 = p - (p * t) / 250;\n            return max(s1, s2);\n        };\n\n        int scoreMisha = computeScore(a, c);\n\n        // Try to find d such that Vasya's score equals Misha's score\n        bool found = false;\n        for (int dd = 0; dd <= 180; ++dd) {\n            int scoreVasya = computeScore(b, dd);\n            if (scoreVasya == scoreMisha) {\n                d = dd;\n                found = true;\n                break;\n            }\n        }\n\n        if (!found) {\n            // Could not find suitable d, exit\n            cerr << \"Could not find d to make tie. Try again.\" << endl;\n            exit(1);\n        }\n\n    } else if (type == \"method_equal\") {\n        // Generate test case where method1 and method2 give the same score\n        if (a == -1)\n            a = possibleP[rnd.next(0, (int)possibleP.size() -1)];\n\n        // Calculate t where methods are equal for Misha\n        int t_equal = 175; // (3/10)p = p - (p * t)/250 => t = 175\n\n        if (c == -1)\n            c = t_equal;\n\n        // For Vasya, pick random b and d\n        if (b == -1)\n            b = possibleP[rnd.next(0, (int)possibleP.size() -1)];\n        if (d == -1)\n            d = rnd.next(0, 180);\n\n    } else {\n        // Handle other types if needed\n    }\n\n    // Output the test case\n    printf(\"%d %d %d %d\\n\", a, b, c, d);\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Random test cases\n./gen -type random\n./gen -type random\n./gen -type random\n./gen -type random\n./gen -type random\n\n# Edge cases with min and max values\n./gen -type edge\n./gen -type edge\n./gen -type edge\n\n# Tie cases where Misha and Vasya get the same score\n./gen -type tie\n./gen -type tie\n./gen -type tie\n\n# Cases where method1 and method2 give the same score for Misha\n./gen -type method_equal\n./gen -type method_equal\n./gen -type method_equal\n\n# Fixed values at min and max\n./gen -a 250 -b 250 -c 0 -d 0\n./gen -a 3500 -b 3500 -c 180 -d 180\n./gen -a 250 -b 3500 -c 0 -d 180\n./gen -a 3500 -b 250 -c 180 -d 0\n\n# Random but fix a\n./gen -type random -a 250\n./gen -type random -a 500\n./gen -type random -a 750\n\n# Random but fix b\n./gen -type random -b 1000\n./gen -type random -b 1250\n./gen -type random -b 1500\n\n# Random but fix c\n./gen -type random -c 0\n./gen -type random -c 90\n./gen -type random -c 180\n\n# Random but fix d\n./gen -type random -d 0\n./gen -type random -d 90\n./gen -type random -d 180\n\n# Random but fix both c and d\n./gen -type random -c 90 -d 90\n./gen -type random -c 0 -d 180\n./gen -type random -c 180 -d 0\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:40:13.395865",
        "total_tutorials": 3,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "501/B",
      "title": "B. Misha and Changing Handles",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains integer q (1 ≤ q ≤ 1000), the number of handle change requests.Next q lines contain the descriptions of the requests, one per line.Each query consists of two non-empty strings old and new, separated by a space. The strings consist of lowercase and uppercase Latin letters and digits. Strings old and new are distinct. The lengths of the strings do not exceed 20.The requests are given chronologically. In other words, by the moment of a query there is a single person with handle old, and handle new is not used and has not been used by anyone.",
      "output_spec": "OutputIn the first line output the integer n — the number of users that changed their handles at least once.In the next n lines print the mapping between the old and the new handles of the users. Each of them must contain two strings, old and new, separated by a space, meaning that before the user had handle old, and after all the requests are completed, his handle is new. You may output lines in any order.Each user who changes the handle must occur exactly once in this description.",
      "sample_tests": "ExamplesInputCopy5Misha ILoveCodeforcesVasya PetrovPetrov VasyaPetrov123ILoveCodeforces MikeMirzayanovPetya IvanovOutputCopy3Petya IvanovMisha MikeMirzayanovVasya VasyaPetrov123",
      "description": "B. Misha and Changing Handles\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains integer q (1 ≤ q ≤ 1000), the number of handle change requests.Next q lines contain the descriptions of the requests, one per line.Each query consists of two non-empty strings old and new, separated by a space. The strings consist of lowercase and uppercase Latin letters and digits. Strings old and new are distinct. The lengths of the strings do not exceed 20.The requests are given chronologically. In other words, by the moment of a query there is a single person with handle old, and handle new is not used and has not been used by anyone.\n\nOutputIn the first line output the integer n — the number of users that changed their handles at least once.In the next n lines print the mapping between the old and the new handles of the users. Each of them must contain two strings, old and new, separated by a space, meaning that before the user had handle old, and after all the requests are completed, his handle is new. You may output lines in any order.Each user who changes the handle must occur exactly once in this description.\n\nInputCopy5Misha ILoveCodeforcesVasya PetrovPetrov VasyaPetrov123ILoveCodeforces MikeMirzayanovPetya IvanovOutputCopy3Petya IvanovMisha MikeMirzayanovVasya VasyaPetrov123\n\nInputCopy5Misha ILoveCodeforcesVasya PetrovPetrov VasyaPetrov123ILoveCodeforces MikeMirzayanovPetya Ivanov\n\nOutputCopy3Petya IvanovMisha MikeMirzayanovVasya VasyaPetrov123",
      "solutions": [
        {
          "title": "Codeforces Round #285 - Codeforces",
          "content": "Hi, Codeforces!Codeforces Round #285 will be held at 12 January, 12.00 MSK. Problems are authored by me, Evgeny Savinov. This is my first round at Codeforces. I hope that this isn't the last one.I want to thank sokian and Golovanov399 for help in preparing and testing round, Zlobober for invaluable help in preparing round, AlexFetisov for testing round, Delinur for translating problem statements in English, and of course, MikeMirzayanov for great systems Codeforces and Polygon.By the way, today(11 January) is MikeMirzayanov's birthday. Happy birthday, Mike!The round will be for both divisions. Information about score distribution will be posted just before the round starts.UPD1: Scoring system will be dynamic. Problems will be arranged in ascending expected difficulty order.UPD2: The editorial can be found here. I'm sorry for the delay.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/15725",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 848
        },
        {
          "title": "Codeforces Round #285 Editorial - Codeforces",
          "content": "501A - ContestIn this problem one need to determine the number of points for both guys and find out who got more points.Time complexity: O(1).501B - Misha and Changing HandlesThe problem can be formulated as follows: The directed graph is given, its vertices correspond to users' handles and edges — to requests. It consists of a number of chains, so every vertex ingoing and outgoing degree doesn't exceed one. One need to find number of chains and first and last vertices of every chain. The arcs of this graph can be stored in dictionary(one can use std::map\\unoredered_map in C++ and TreeMap\\HashMap in Java) with head of the arc as the key and the tail as the value.Each zero ingoing degree vertex corresponds to unique user as well as first vertex of some chain. We should iterate from such vertices through the arcs while it's possible. Thus we find relation between first and last vertices in the chain as well as relation between the original and the new handle of some user.You can see my solution for details.Time complexity: .504A - Misha and ForestNote that every non-empty forest has a leaf(vertex of degree 1). Let's remove edges one by one and maintain actual values (degreev, sv) as long as graph is not empty. To do so, we can maintain the queue(or stack) of the leaves. On every iteration we dequeue vertex v and remove edge (v, sv) and update values for vertex sv: degreesv -= 1 and ssv ^= v. If degree of vertex sv becomes equal to 1, we enqueue it.When dequeued vertex has zero degree, just ignore it because we have already removed all edges of corresponding tree.You can see my solution for details.Time complexity: O(n)504B - Misha and Permutations SummationTo solve the problem, one need to be able to find the index of given permutation in lexicographical order and permutation by its index. We will store indices in factorial number system. Thus number x is represented as . You can find the rules of the transform here.To make the transform, you may need to use data structures such as binary search tree or binary indexed tree (for maintaining queries of finding k-th number in the set and finding the amount of numbers less than given one).So, one need to get indices of the permutations, to sum them modulo n! and make inverse transform. You can read any accepted solution for better understanding.Time complexity: or .504C - Misha and Palindrome DegreeNote that if the amount of elements, which number of occurrences is odd, is greater than one, the answer is zero. On the other hand, if array is the palindrome, answer is .Let's cut equal elements from the end and the beginning of array while it is possible. Let's call remaining array as b and its length as m. We are interested in segments [l, r] which cover some prefix or suffix of b.We need to find the minimum length of such prefix and suffix. Prefix and suffix can overlap the middle of b and these cases are needed to maintain. To find minimum length you can use binary search or simply iterating over array and storing the amount of every element to the left and right from the current index. Let's call minimum length of prefix as pref and as suf of suffix. So .Time complexity: O(n) or .504D - Misha and XORFirstly, we convert each number into a binary system: it can be done in O(MAXBITS2), where MAXBITS ≤ 2000 with rather small constant(we store number in system with big radix).To solve the problem we need to modify Gauss elimination algorithm. For each row we should store set of row's indices which we already XORed this row to get row echelon form (we can store it in bitset), also for each bit i we store index p[i] of row, which lowest set bit is i in row echelon form.Maintaining the query we try to reset bits from lowest to highest using array p and save information, which rows were XORed with current number. If we can reset whole number, the answer is positive and we know indices of answer. We update array p, otherwise.Time complexity: O(m × MAXBITS × (MAXBITS + m)) with small constant due to bit compression.504E - Misha and LCP on TreeLet's build heavy-light decomposition of given tree and write all strings corresponding to heavy paths one by one in one string T, every path should be written twice: in the direct and reverse order.Maintaining query we can split paths (a, b) и (c, d) into parts, which completely belongs to some heavy paths. There can be at most such parts. Note that every part corresponds to some substring of T.Now we only need to find longest common prefix of two substrings in string T. It can be done building suffix array of string T and lcp array. So, we can find longest common prefix of two substring in O(1) constructing rmq sparse table on lcp array.Time complexity: For the better understanding see my solution.P.S. One can uses hashes instead of suffix array.ADD: There is another approach to solve this problem in but it's rather slow in practice. We can do binary search on answer and use hashes, but we do it for all queries at one time. The only problem is to find k-th vertex on the path, we can do it offline for all queries in O(n + m) time. We run dfs and maintain stack of vertices. See my solution for details.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/15743",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 501\\s*B"
          },
          "content_length": 5171
        },
        {
          "title": "Codeforces Round #285 Editorial - Codeforces",
          "content": "501A - ContestIn this problem one need to determine the number of points for both guys and find out who got more points.Time complexity: O(1).501B - Misha and Changing HandlesThe problem can be formulated as follows: The directed graph is given, its vertices correspond to users' handles and edges — to requests. It consists of a number of chains, so every vertex ingoing and outgoing degree doesn't exceed one. One need to find number of chains and first and last vertices of every chain. The arcs of this graph can be stored in dictionary(one can use std::map\\unoredered_map in C++ and TreeMap\\HashMap in Java) with head of the arc as the key and the tail as the value.Each zero ingoing degree vertex corresponds to unique user as well as first vertex of some chain. We should iterate from such vertices through the arcs while it's possible. Thus we find relation between first and last vertices in the chain as well as relation between the original and the new handle of some user.You can see my solution for details.Time complexity: .504A - Misha and ForestNote that every non-empty forest has a leaf(vertex of degree 1). Let's remove edges one by one and maintain actual values (degreev, sv) as long as graph is not empty. To do so, we can maintain the queue(or stack) of the leaves. On every iteration we dequeue vertex v and remove edge (v, sv) and update values for vertex sv: degreesv -= 1 and ssv ^= v. If degree of vertex sv becomes equal to 1, we enqueue it.When dequeued vertex has zero degree, just ignore it because we have already removed all edges of corresponding tree.You can see my solution for details.Time complexity: O(n)504B - Misha and Permutations SummationTo solve the problem, one need to be able to find the index of given permutation in lexicographical order and permutation by its index. We will store indices in factorial number system. Thus number x is represented as . You can find the rules of the transform here.To make the transform, you may need to use data structures such as binary search tree or binary indexed tree (for maintaining queries of finding k-th number in the set and finding the amount of numbers less than given one).So, one need to get indices of the permutations, to sum them modulo n! and make inverse transform. You can read any accepted solution for better understanding.Time complexity: or .504C - Misha and Palindrome DegreeNote that if the amount of elements, which number of occurrences is odd, is greater than one, the answer is zero. On the other hand, if array is the palindrome, answer is .Let's cut equal elements from the end and the beginning of array while it is possible. Let's call remaining array as b and its length as m. We are interested in segments [l, r] which cover some prefix or suffix of b.We need to find the minimum length of such prefix and suffix. Prefix and suffix can overlap the middle of b and these cases are needed to maintain. To find minimum length you can use binary search or simply iterating over array and storing the amount of every element to the left and right from the current index. Let's call minimum length of prefix as pref and as suf of suffix. So .Time complexity: O(n) or .504D - Misha and XORFirstly, we convert each number into a binary system: it can be done in O(MAXBITS2), where MAXBITS ≤ 2000 with rather small constant(we store number in system with big radix).To solve the problem we need to modify Gauss elimination algorithm. For each row we should store set of row's indices which we already XORed this row to get row echelon form (we can store it in bitset), also for each bit i we store index p[i] of row, which lowest set bit is i in row echelon form.Maintaining the query we try to reset bits from lowest to highest using array p and save information, which rows were XORed with current number. If we can reset whole number, the answer is positive and we know indices of answer. We update array p, otherwise.Time complexity: O(m × MAXBITS × (MAXBITS + m)) with small constant due to bit compression.504E - Misha and LCP on TreeLet's build heavy-light decomposition of given tree and write all strings corresponding to heavy paths one by one in one string T, every path should be written twice: in the direct and reverse order.Maintaining query we can split paths (a, b) и (c, d) into parts, which completely belongs to some heavy paths. There can be at most such parts. Note that every part corresponds to some substring of T.Now we only need to find longest common prefix of two substrings in string T. It can be done building suffix array of string T and lcp array. So, we can find longest common prefix of two substring in O(1) constructing rmq sparse table on lcp array.Time complexity: For the better understanding see my solution.P.S. One can uses hashes instead of suffix array.ADD: There is another approach to solve this problem in but it's rather slow in practice. We can do binary search on answer and use hashes, but we do it for all queries at one time. The only problem is to find k-th vertex on the path, we can do it offline for all queries in O(n + m) time. We run dfs and maintain stack of vertices. See my solution for details.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/15743",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 501\\s*B"
          },
          "content_length": 5171
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #285 - Codeforces - Code 1",
          "code": "#include <iostream>\nusing namespace std;\n\nint main ()\n{\n        cout << \"Happy Birthday Mike ! \\\\:D/\" << endl << \"Thanks For Everything !!! :D\" << endl;\n        return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/15725",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #285 - Codeforces - Code 2",
          "code": "#include <iostream>\nusing namespace std;\n\nint main ()\n{\n        cout << \"Happy Birthday Mike ! \\\\:D/\" << endl << \"Thanks For Everything !!! :D\" << endl;\n        return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/15725",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #285 - Codeforces - Code 3",
          "code": "math.factorial(x)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15725",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #285 - Codeforces - Code 4",
          "code": "math.factorial(200000)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15725",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #285 - Codeforces - Code 5",
          "code": "i = 1\nj = 1\nwhile(i <= n) {\n while(i > j || !is_it_a_good_range(i,j)) {\n  ++j;\n  update_set_with_bad_numbers(j);\n  update_set_with_bad_numbers(n+1-j);\n }\n update_set_with_bad_numbers(i);\n update_set_with_bad_numbers(n+1-i);\n ++i;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15725",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #285 - Codeforces - Code 6",
          "code": "i = 1\nj = 1\nwhile(i <= n) {\n while(i > j || !is_it_a_good_range(i,j)) {\n  ++j;\n  update_set_with_bad_numbers(j);\n  update_set_with_bad_numbers(n+1-j);\n }\n update_set_with_bad_numbers(i);\n update_set_with_bad_numbers(n+1-i);\n ++i;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15725",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #285 - Codeforces - Code 7",
          "code": "BigInteger x = new BigInteger(in.next());\nx.testBit(j);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15725",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #285 - Codeforces - Code 8",
          "code": "BigInteger x = new BigInteger(in.next());\nx.testBit(j);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15725",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #285 - Codeforces - Code 9",
          "code": "set<int>::iterator it = s.lower_bound(x);\ns.erase(it);\nupd(*it);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15725",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #285 - Codeforces - Code 10",
          "code": "set<int>::iterator it = s.lower_bound(x);\ns.erase(it);\nupd(*it);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15725",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int q = inf.readInt(1, 1000, \"q\");\n    inf.readEoln();\n\n    unordered_map<string, string> handle_owner;\n    unordered_set<string> used_handles;\n\n    for (int i = 0; i < q; ++i) {\n        string old_handle = inf.readToken(\"[a-zA-Z0-9]{1,20}\", \"old\");\n        inf.readSpace();\n        string new_handle = inf.readToken(\"[a-zA-Z0-9]{1,20}\", \"new\");\n        inf.readEoln();\n\n        ensuref(old_handle != new_handle, \"old and new handles must be different\");\n\n        // Check that old_handle is currently assigned to a user\n        auto it = handle_owner.find(old_handle);\n        string user_id;\n        if (it != handle_owner.end()) {\n            user_id = it->second;\n        } else {\n            // If old_handle hasn't been used before, assign it to a new user\n            if (used_handles.count(old_handle)) {\n                ensuref(false, \"Handle '%s' is not currently assigned to any user\", old_handle.c_str());\n            } else {\n                user_id = old_handle;\n                handle_owner[old_handle] = user_id;\n                used_handles.insert(old_handle);\n            }\n        }\n\n        // Check that new_handle hasn't been used before\n        ensuref(!used_handles.count(new_handle), \"Handle '%s' has already been used\", new_handle.c_str());\n\n        // Update the handle assignment\n        handle_owner.erase(old_handle);\n        handle_owner[new_handle] = user_id;\n        used_handles.insert(new_handle);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int q = inf.readInt(1, 1000, \"q\");\n    inf.readEoln();\n\n    unordered_map<string, string> handle_owner;\n    unordered_set<string> used_handles;\n\n    for (int i = 0; i < q; ++i) {\n        string old_handle = inf.readToken(\"[a-zA-Z0-9]{1,20}\", \"old\");\n        inf.readSpace();\n        string new_handle = inf.readToken(\"[a-zA-Z0-9]{1,20}\", \"new\");\n        inf.readEoln();\n\n        ensuref(old_handle != new_handle, \"old and new handles must be different\");\n\n        // Check that old_handle is currently assigned to a user\n        auto it = handle_owner.find(old_handle);\n        string user_id;\n        if (it != handle_owner.end()) {\n            user_id = it->second;\n        } else {\n            // If old_handle hasn't been used before, assign it to a new user\n            if (used_handles.count(old_handle)) {\n                ensuref(false, \"Handle '%s' is not currently assigned to any user\", old_handle.c_str());\n            } else {\n                user_id = old_handle;\n                handle_owner[old_handle] = user_id;\n                used_handles.insert(old_handle);\n            }\n        }\n\n        // Check that new_handle hasn't been used before\n        ensuref(!used_handles.count(new_handle), \"Handle '%s' has already been used\", new_handle.c_str());\n\n        // Update the handle assignment\n        handle_owner.erase(old_handle);\n        handle_owner[new_handle] = user_id;\n        used_handles.insert(new_handle);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int q = inf.readInt(1, 1000, \"q\");\n    inf.readEoln();\n\n    unordered_map<string, string> handle_owner;\n    unordered_set<string> used_handles;\n\n    for (int i = 0; i < q; ++i) {\n        string old_handle = inf.readToken(\"[a-zA-Z0-9]{1,20}\", \"old\");\n        inf.readSpace();\n        string new_handle = inf.readToken(\"[a-zA-Z0-9]{1,20}\", \"new\");\n        inf.readEoln();\n\n        ensuref(old_handle != new_handle, \"old and new handles must be different\");\n\n        // Check that old_handle is currently assigned to a user\n        auto it = handle_owner.find(old_handle);\n        string user_id;\n        if (it != handle_owner.end()) {\n            user_id = it->second;\n        } else {\n            // If old_handle hasn't been used before, assign it to a new user\n            if (used_handles.count(old_handle)) {\n                ensuref(false, \"Handle '%s' is not currently assigned to any user\", old_handle.c_str());\n            } else {\n                user_id = old_handle;\n                handle_owner[old_handle] = user_id;\n                used_handles.insert(old_handle);\n            }\n        }\n\n        // Check that new_handle hasn't been used before\n        ensuref(!used_handles.count(new_handle), \"Handle '%s' has already been used\", new_handle.c_str());\n\n        // Update the handle assignment\n        handle_owner.erase(old_handle);\n        handle_owner[new_handle] = user_id;\n        used_handles.insert(new_handle);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerTestlibCmd(argc, argv);\n\n    int q = inf.readInt(1, 1000);\n\n    map<string, string> current_handles; // current_handle -> initial_handle\n    set<string> used_handles; // handles that have been used at any time\n\n    // Process the handle change requests and build the correct mapping\n    for (int i = 0; i < q; ++i) {\n        string old_handle = inf.readToken(\"[a-zA-Z0-9]{1,20}\");\n        string new_handle = inf.readToken(\"[a-zA-Z0-9]{1,20}\");\n        if (old_handle == new_handle) {\n            quitf(_fail, \"Invalid input: old handle equals new handle at line %d\", i + 2);\n        }\n        if (used_handles.count(new_handle)) {\n            quitf(_fail, \"Invalid input: new handle '%s' has been used before at line %d\", new_handle.c_str(), i + 2);\n        }\n        if (!current_handles.count(old_handle)) {\n            current_handles[old_handle] = old_handle; // initial handle is old_handle\n        }\n        string initial_handle = current_handles[old_handle];\n        current_handles.erase(old_handle);\n        current_handles[new_handle] = initial_handle;\n        used_handles.insert(new_handle);\n    }\n\n    // Build the correct mapping from initial_handle to final_handle\n    map<string, string> correct_mapping; // initial_handle -> final_handle\n    for (const auto& p : current_handles) {\n        string final_handle = p.first;\n        string initial_handle = p.second;\n        correct_mapping[initial_handle] = final_handle;\n    }\n\n    // Read the participant's output\n    int n = ouf.readInt(0, 1000, \"n\");\n    if (n != (int)correct_mapping.size()) {\n        quitf(_wa, \"Number of users mismatch: expected %d, found %d\", (int)correct_mapping.size(), n);\n    }\n\n    map<string, string> participant_mapping;\n    set<string> participant_initial_handles;\n    for (int i = 0; i < n; ++i) {\n        string initial_handle = ouf.readToken(\"[a-zA-Z0-9]{1,20}\", format(\"old handle at line %d\", i + 2).c_str());\n        string final_handle = ouf.readToken(\"[a-zA-Z0-9]{1,20}\", format(\"new handle at line %d\", i + 2).c_str());\n        if (participant_initial_handles.count(initial_handle)) {\n            quitf(_wa, \"Duplicate initial handle '%s' in participant's output\", initial_handle.c_str());\n        }\n        participant_initial_handles.insert(initial_handle);\n        participant_mapping[initial_handle] = final_handle;\n    }\n\n    // Compare participant's mapping with the correct mapping\n    if (participant_mapping.size() != correct_mapping.size()) {\n        quitf(_wa, \"Participant's mapping size %d does not match correct mapping size %d\", (int)participant_mapping.size(), (int)correct_mapping.size());\n    }\n\n    for (const auto& p : correct_mapping) {\n        const string& initial_handle = p.first;\n        const string& correct_final_handle = p.second;\n        if (!participant_mapping.count(initial_handle)) {\n            quitf(_wa, \"Missing mapping for initial handle '%s'\", initial_handle.c_str());\n        }\n        const string& participant_final_handle = participant_mapping[initial_handle];\n        if (participant_final_handle != correct_final_handle) {\n            quitf(_wa, \"Final handle mismatch for initial handle '%s': expected '%s', found '%s'\", initial_handle.c_str(), correct_final_handle.c_str(), participant_final_handle.c_str());\n        }\n    }\n\n    quitf(_ok, \"Correct\");\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\n// Function to generate random handle of length between min_len and max_len\nstring random_handle(int min_len, int max_len) {\n    int len = rnd.next(min_len, max_len);\n    string s;\n    for (int i = 0; i < len; ++i) {\n        int t = rnd.next(0, 2);\n        char c;\n        if (t == 0) {\n            c = 'a' + rnd.next(0, 25);\n        } else if (t == 1) {\n            c = 'A' + rnd.next(0, 25);\n        } else {\n            c = '0' + rnd.next(0, 9);\n        }\n        s += c;\n    }\n    return s;\n}\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int q = opt<int>(\"q\");\n    string type = opt<string>(\"type\", \"random\");\n\n    // Map from handle to user id\n    map<string, int> handle_to_user;\n\n    // Map from user id to current handle\n    map<int, string> user_current_handle;\n\n    // Set of used handles\n    set<string> used_handles;\n\n    int next_user_id = 1;\n\n    vector<pair<string, string>> queries;\n\n    if (type == \"single\") {\n        int user_id = next_user_id++;\n        string old_handle;\n        do {\n            old_handle = random_handle(1, 20);\n        } while (used_handles.count(old_handle));\n        handle_to_user[old_handle] = user_id;\n        user_current_handle[user_id] = old_handle;\n        used_handles.insert(old_handle);\n        for (int i = 0; i < q; ++i) {\n            string new_handle;\n            do {\n                new_handle = random_handle(1, 20);\n            } while (used_handles.count(new_handle));\n            queries.emplace_back(user_current_handle[user_id], new_handle);\n            used_handles.insert(new_handle);\n            handle_to_user.erase(user_current_handle[user_id]);\n            handle_to_user[new_handle] = user_id;\n            user_current_handle[user_id] = new_handle;\n        }\n    } else if (type == \"maxlen\") {\n        for (int i = 0; i < q; ++i) {\n            string old_handle, new_handle;\n            if (handle_to_user.empty() || rnd.next(0, 1) == 0) {\n                // Create a new user with handle length 20\n                do {\n                    old_handle = random_handle(20, 20);\n                } while (used_handles.count(old_handle));\n                int user_id = next_user_id++;\n                handle_to_user[old_handle] = user_id;\n                user_current_handle[user_id] = old_handle;\n                used_handles.insert(old_handle);\n            } else {\n                // Pick an existing handle\n                auto it = handle_to_user.begin();\n                advance(it, rnd.next(0, (int)handle_to_user.size() - 1));\n                old_handle = it->first;\n            }\n            // Generate 'new' handle of length 20\n            do {\n                new_handle = random_handle(20, 20);\n            } while (used_handles.count(new_handle));\n\n            // Update handles\n            int user_id = handle_to_user[old_handle];\n            // Update mappings\n            handle_to_user.erase(old_handle);\n            handle_to_user[new_handle] = user_id;\n            user_current_handle[user_id] = new_handle;\n            used_handles.insert(new_handle);\n\n            queries.emplace_back(old_handle, new_handle);\n        }\n    } else if (type == \"caseSensitive\") {\n        // Generate handles that differ only in case.\n        for (int i = 0; i < q; ++i) {\n            string old_handle, new_handle;\n            if (handle_to_user.empty() || rnd.next(0, 1) == 0) {\n                // Create a new user\n                do {\n                    old_handle = random_handle(1, 20);\n                } while (used_handles.count(old_handle));\n                int user_id = next_user_id++;\n                handle_to_user[old_handle] = user_id;\n                user_current_handle[user_id] = old_handle;\n                used_handles.insert(old_handle);\n            } else {\n                // Pick an existing handle\n                auto it = handle_to_user.begin();\n                advance(it, rnd.next(0, (int)handle_to_user.size() - 1));\n                old_handle = it->first;\n            }\n            // Generate 'new' handle that differs from 'old_handle' only in case\n            new_handle = old_handle;\n            for (char &c : new_handle) {\n                if ('a' <= c && c <= 'z') {\n                    c = 'A' + (c - 'a');\n                } else if ('A' <= c && c <= 'Z') {\n                    c = 'a' + (c - 'A');\n                }\n                // Leave digits unchanged\n            }\n            // Make sure 'new_handle' is distinct and unused\n            if (used_handles.count(new_handle) || new_handle == old_handle) {\n                // If 'new_handle' is invalid, generate a random one\n                do {\n                    new_handle = random_handle(1, 20);\n                } while (used_handles.count(new_handle));\n            }\n            // Update handles\n            int user_id = handle_to_user[old_handle];\n            // Update mappings\n            handle_to_user.erase(old_handle);\n            handle_to_user[new_handle] = user_id;\n            user_current_handle[user_id] = new_handle;\n            used_handles.insert(new_handle);\n\n            queries.emplace_back(old_handle, new_handle);\n        }\n    } else {\n        // Default is \"random\" type\n        for (int i = 0; i < q; ++i) {\n            string old_handle, new_handle;\n            if (handle_to_user.empty() || rnd.next(0, 1) == 0) {\n                // Create a new user\n                do {\n                    old_handle = random_handle(1, 20);\n                } while (used_handles.count(old_handle));\n                int user_id = next_user_id++;\n                handle_to_user[old_handle] = user_id;\n                user_current_handle[user_id] = old_handle;\n                used_handles.insert(old_handle);\n            } else {\n                // Pick an existing handle\n                auto it = handle_to_user.begin();\n                advance(it, rnd.next(0, (int)handle_to_user.size() - 1));\n                old_handle = it->first;\n            }\n            // Generate 'new' handle\n            do {\n                new_handle = random_handle(1, 20);\n            } while (used_handles.count(new_handle));\n\n            // Update handles\n            int user_id = handle_to_user[old_handle];\n            // Update mappings\n            handle_to_user.erase(old_handle);\n            handle_to_user[new_handle] = user_id;\n            user_current_handle[user_id] = new_handle;\n            used_handles.insert(new_handle);\n\n            queries.emplace_back(old_handle, new_handle);\n        }\n    }\n\n    // Now output the test case\n    printf(\"%d\\n\", q);\n\n    for (auto &p : queries) {\n        printf(\"%s %s\\n\", p.first.c_str(), p.second.c_str());\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\n// Function to generate random handle of length between min_len and max_len\nstring random_handle(int min_len, int max_len) {\n    int len = rnd.next(min_len, max_len);\n    string s;\n    for (int i = 0; i < len; ++i) {\n        int t = rnd.next(0, 2);\n        char c;\n        if (t == 0) {\n            c = 'a' + rnd.next(0, 25);\n        } else if (t == 1) {\n            c = 'A' + rnd.next(0, 25);\n        } else {\n            c = '0' + rnd.next(0, 9);\n        }\n        s += c;\n    }\n    return s;\n}\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int q = opt<int>(\"q\");\n    string type = opt<string>(\"type\", \"random\");\n\n    // Map from handle to user id\n    map<string, int> handle_to_user;\n\n    // Map from user id to current handle\n    map<int, string> user_current_handle;\n\n    // Set of used handles\n    set<string> used_handles;\n\n    int next_user_id = 1;\n\n    vector<pair<string, string>> queries;\n\n    if (type == \"single\") {\n        int user_id = next_user_id++;\n        string old_handle;\n        do {\n            old_handle = random_handle(1, 20);\n        } while (used_handles.count(old_handle));\n        handle_to_user[old_handle] = user_id;\n        user_current_handle[user_id] = old_handle;\n        used_handles.insert(old_handle);\n        for (int i = 0; i < q; ++i) {\n            string new_handle;\n            do {\n                new_handle = random_handle(1, 20);\n            } while (used_handles.count(new_handle));\n            queries.emplace_back(user_current_handle[user_id], new_handle);\n            used_handles.insert(new_handle);\n            handle_to_user.erase(user_current_handle[user_id]);\n            handle_to_user[new_handle] = user_id;\n            user_current_handle[user_id] = new_handle;\n        }\n    } else if (type == \"maxlen\") {\n        for (int i = 0; i < q; ++i) {\n            string old_handle, new_handle;\n            if (handle_to_user.empty() || rnd.next(0, 1) == 0) {\n                // Create a new user with handle length 20\n                do {\n                    old_handle = random_handle(20, 20);\n                } while (used_handles.count(old_handle));\n                int user_id = next_user_id++;\n                handle_to_user[old_handle] = user_id;\n                user_current_handle[user_id] = old_handle;\n                used_handles.insert(old_handle);\n            } else {\n                // Pick an existing handle\n                auto it = handle_to_user.begin();\n                advance(it, rnd.next(0, (int)handle_to_user.size() - 1));\n                old_handle = it->first;\n            }\n            // Generate 'new' handle of length 20\n            do {\n                new_handle = random_handle(20, 20);\n            } while (used_handles.count(new_handle));\n\n            // Update handles\n            int user_id = handle_to_user[old_handle];\n            // Update mappings\n            handle_to_user.erase(old_handle);\n            handle_to_user[new_handle] = user_id;\n            user_current_handle[user_id] = new_handle;\n            used_handles.insert(new_handle);\n\n            queries.emplace_back(old_handle, new_handle);\n        }\n    } else if (type == \"caseSensitive\") {\n        // Generate handles that differ only in case.\n        for (int i = 0; i < q; ++i) {\n            string old_handle, new_handle;\n            if (handle_to_user.empty() || rnd.next(0, 1) == 0) {\n                // Create a new user\n                do {\n                    old_handle = random_handle(1, 20);\n                } while (used_handles.count(old_handle));\n                int user_id = next_user_id++;\n                handle_to_user[old_handle] = user_id;\n                user_current_handle[user_id] = old_handle;\n                used_handles.insert(old_handle);\n            } else {\n                // Pick an existing handle\n                auto it = handle_to_user.begin();\n                advance(it, rnd.next(0, (int)handle_to_user.size() - 1));\n                old_handle = it->first;\n            }\n            // Generate 'new' handle that differs from 'old_handle' only in case\n            new_handle = old_handle;\n            for (char &c : new_handle) {\n                if ('a' <= c && c <= 'z') {\n                    c = 'A' + (c - 'a');\n                } else if ('A' <= c && c <= 'Z') {\n                    c = 'a' + (c - 'A');\n                }\n                // Leave digits unchanged\n            }\n            // Make sure 'new_handle' is distinct and unused\n            if (used_handles.count(new_handle) || new_handle == old_handle) {\n                // If 'new_handle' is invalid, generate a random one\n                do {\n                    new_handle = random_handle(1, 20);\n                } while (used_handles.count(new_handle));\n            }\n            // Update handles\n            int user_id = handle_to_user[old_handle];\n            // Update mappings\n            handle_to_user.erase(old_handle);\n            handle_to_user[new_handle] = user_id;\n            user_current_handle[user_id] = new_handle;\n            used_handles.insert(new_handle);\n\n            queries.emplace_back(old_handle, new_handle);\n        }\n    } else {\n        // Default is \"random\" type\n        for (int i = 0; i < q; ++i) {\n            string old_handle, new_handle;\n            if (handle_to_user.empty() || rnd.next(0, 1) == 0) {\n                // Create a new user\n                do {\n                    old_handle = random_handle(1, 20);\n                } while (used_handles.count(old_handle));\n                int user_id = next_user_id++;\n                handle_to_user[old_handle] = user_id;\n                user_current_handle[user_id] = old_handle;\n                used_handles.insert(old_handle);\n            } else {\n                // Pick an existing handle\n                auto it = handle_to_user.begin();\n                advance(it, rnd.next(0, (int)handle_to_user.size() - 1));\n                old_handle = it->first;\n            }\n            // Generate 'new' handle\n            do {\n                new_handle = random_handle(1, 20);\n            } while (used_handles.count(new_handle));\n\n            // Update handles\n            int user_id = handle_to_user[old_handle];\n            // Update mappings\n            handle_to_user.erase(old_handle);\n            handle_to_user[new_handle] = user_id;\n            user_current_handle[user_id] = new_handle;\n            used_handles.insert(new_handle);\n\n            queries.emplace_back(old_handle, new_handle);\n        }\n    }\n\n    // Now output the test case\n    printf(\"%d\\n\", q);\n\n    for (auto &p : queries) {\n        printf(\"%s %s\\n\", p.first.c_str(), p.second.c_str());\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -q 1 -type random\n./gen -q 10 -type random\n./gen -q 100 -type random\n./gen -q 1000 -type random\n\n./gen -q 1 -type single\n./gen -q 10 -type single\n./gen -q 100 -type single\n./gen -q 1000 -type single\n\n./gen -q 1 -type maxlen\n./gen -q 10 -type maxlen\n./gen -q 100 -type maxlen\n./gen -q 1000 -type maxlen\n\n./gen -q 1 -type caseSensitive\n./gen -q 10 -type caseSensitive\n./gen -q 100 -type caseSensitive\n./gen -q 1000 -type caseSensitive\n\n# Additional test cases\n\n# Mix different types\n./gen -q 500 -type random\n./gen -q 500 -type single\n./gen -q 500 -type maxlen\n./gen -q 500 -type caseSensitive\n\n# Edge cases\n./gen -q 1 -type random\n./gen -q 1 -type single\n./gen -q 1 -type maxlen\n./gen -q 1 -type caseSensitive\n\n# Max queries\n./gen -q 1000 -type random\n./gen -q 1000 -type single\n./gen -q 1000 -type maxlen\n./gen -q 1000 -type caseSensitive\n\n# Default random test cases\n./gen -q 1000 -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:40:15.472205",
        "total_tutorials": 3,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "501/C",
      "title": "C. Misha and Forest",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains integer n (1 ≤ n ≤ 216), the number of vertices in the graph.The i-th of the next lines contains numbers degreei and si (0 ≤ degreei ≤ n - 1, 0 ≤ si < 216), separated by a space.",
      "output_spec": "OutputIn the first line print number m, the number of edges of the graph.Next print m lines, each containing two distinct numbers, a and b (0 ≤ a ≤ n - 1, 0 ≤ b ≤ n - 1), corresponding to edge (a, b).Edges can be printed in any order; vertices of the edge can also be printed in any order.",
      "sample_tests": "ExamplesInputCopy32 31 01 0OutputCopy21 02 0InputCopy21 11 0OutputCopy10 1",
      "description": "C. Misha and Forest\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains integer n (1 ≤ n ≤ 216), the number of vertices in the graph.The i-th of the next lines contains numbers degreei and si (0 ≤ degreei ≤ n - 1, 0 ≤ si < 216), separated by a space.\n\nOutputIn the first line print number m, the number of edges of the graph.Next print m lines, each containing two distinct numbers, a and b (0 ≤ a ≤ n - 1, 0 ≤ b ≤ n - 1), corresponding to edge (a, b).Edges can be printed in any order; vertices of the edge can also be printed in any order.\n\nInputCopy32 31 01 0OutputCopy21 02 0InputCopy21 11 0OutputCopy10 1\n\nInputCopy32 31 01 0\n\nOutputCopy21 02 0\n\nInputCopy21 11 0\n\nOutputCopy10 1\n\nNoteThe XOR sum of numbers is the result of bitwise adding numbers modulo 2. This operation exists in many modern programming languages. For example, in languages C++, Java and Python it is represented as \"^\", and in Pascal — as \"xor\".",
      "solutions": [
        {
          "title": "Codeforces Round #285 - Codeforces",
          "content": "Hi, Codeforces!Codeforces Round #285 will be held at 12 January, 12.00 MSK. Problems are authored by me, Evgeny Savinov. This is my first round at Codeforces. I hope that this isn't the last one.I want to thank sokian and Golovanov399 for help in preparing and testing round, Zlobober for invaluable help in preparing round, AlexFetisov for testing round, Delinur for translating problem statements in English, and of course, MikeMirzayanov for great systems Codeforces and Polygon.By the way, today(11 January) is MikeMirzayanov's birthday. Happy birthday, Mike!The round will be for both divisions. Information about score distribution will be posted just before the round starts.UPD1: Scoring system will be dynamic. Problems will be arranged in ascending expected difficulty order.UPD2: The editorial can be found here. I'm sorry for the delay.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/15725",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 848
        },
        {
          "title": "Codeforces Round #285 Editorial - Codeforces",
          "content": "501A - ContestIn this problem one need to determine the number of points for both guys and find out who got more points.Time complexity: O(1).501B - Misha and Changing HandlesThe problem can be formulated as follows: The directed graph is given, its vertices correspond to users' handles and edges — to requests. It consists of a number of chains, so every vertex ingoing and outgoing degree doesn't exceed one. One need to find number of chains and first and last vertices of every chain. The arcs of this graph can be stored in dictionary(one can use std::map\\unoredered_map in C++ and TreeMap\\HashMap in Java) with head of the arc as the key and the tail as the value.Each zero ingoing degree vertex corresponds to unique user as well as first vertex of some chain. We should iterate from such vertices through the arcs while it's possible. Thus we find relation between first and last vertices in the chain as well as relation between the original and the new handle of some user.You can see my solution for details.Time complexity: .504A - Misha and ForestNote that every non-empty forest has a leaf(vertex of degree 1). Let's remove edges one by one and maintain actual values (degreev, sv) as long as graph is not empty. To do so, we can maintain the queue(or stack) of the leaves. On every iteration we dequeue vertex v and remove edge (v, sv) and update values for vertex sv: degreesv -= 1 and ssv ^= v. If degree of vertex sv becomes equal to 1, we enqueue it.When dequeued vertex has zero degree, just ignore it because we have already removed all edges of corresponding tree.You can see my solution for details.Time complexity: O(n)504B - Misha and Permutations SummationTo solve the problem, one need to be able to find the index of given permutation in lexicographical order and permutation by its index. We will store indices in factorial number system. Thus number x is represented as . You can find the rules of the transform here.To make the transform, you may need to use data structures such as binary search tree or binary indexed tree (for maintaining queries of finding k-th number in the set and finding the amount of numbers less than given one).So, one need to get indices of the permutations, to sum them modulo n! and make inverse transform. You can read any accepted solution for better understanding.Time complexity: or .504C - Misha and Palindrome DegreeNote that if the amount of elements, which number of occurrences is odd, is greater than one, the answer is zero. On the other hand, if array is the palindrome, answer is .Let's cut equal elements from the end and the beginning of array while it is possible. Let's call remaining array as b and its length as m. We are interested in segments [l, r] which cover some prefix or suffix of b.We need to find the minimum length of such prefix and suffix. Prefix and suffix can overlap the middle of b and these cases are needed to maintain. To find minimum length you can use binary search or simply iterating over array and storing the amount of every element to the left and right from the current index. Let's call minimum length of prefix as pref and as suf of suffix. So .Time complexity: O(n) or .504D - Misha and XORFirstly, we convert each number into a binary system: it can be done in O(MAXBITS2), where MAXBITS ≤ 2000 with rather small constant(we store number in system with big radix).To solve the problem we need to modify Gauss elimination algorithm. For each row we should store set of row's indices which we already XORed this row to get row echelon form (we can store it in bitset), also for each bit i we store index p[i] of row, which lowest set bit is i in row echelon form.Maintaining the query we try to reset bits from lowest to highest using array p and save information, which rows were XORed with current number. If we can reset whole number, the answer is positive and we know indices of answer. We update array p, otherwise.Time complexity: O(m × MAXBITS × (MAXBITS + m)) with small constant due to bit compression.504E - Misha and LCP on TreeLet's build heavy-light decomposition of given tree and write all strings corresponding to heavy paths one by one in one string T, every path should be written twice: in the direct and reverse order.Maintaining query we can split paths (a, b) и (c, d) into parts, which completely belongs to some heavy paths. There can be at most such parts. Note that every part corresponds to some substring of T.Now we only need to find longest common prefix of two substrings in string T. It can be done building suffix array of string T and lcp array. So, we can find longest common prefix of two substring in O(1) constructing rmq sparse table on lcp array.Time complexity: For the better understanding see my solution.P.S. One can uses hashes instead of suffix array.ADD: There is another approach to solve this problem in but it's rather slow in practice. We can do binary search on answer and use hashes, but we do it for all queries at one time. The only problem is to find k-th vertex on the path, we can do it offline for all queries in O(n + m) time. We run dfs and maintain stack of vertices. See my solution for details.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/15743",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.6,
            "reason": "宽松匹配: 包含题目编号 501 和字母"
          },
          "content_length": 5171
        },
        {
          "title": "Codeforces Round #285 Editorial - Codeforces",
          "content": "501A - ContestIn this problem one need to determine the number of points for both guys and find out who got more points.Time complexity: O(1).501B - Misha and Changing HandlesThe problem can be formulated as follows: The directed graph is given, its vertices correspond to users' handles and edges — to requests. It consists of a number of chains, so every vertex ingoing and outgoing degree doesn't exceed one. One need to find number of chains and first and last vertices of every chain. The arcs of this graph can be stored in dictionary(one can use std::map\\unoredered_map in C++ and TreeMap\\HashMap in Java) with head of the arc as the key and the tail as the value.Each zero ingoing degree vertex corresponds to unique user as well as first vertex of some chain. We should iterate from such vertices through the arcs while it's possible. Thus we find relation between first and last vertices in the chain as well as relation between the original and the new handle of some user.You can see my solution for details.Time complexity: .504A - Misha and ForestNote that every non-empty forest has a leaf(vertex of degree 1). Let's remove edges one by one and maintain actual values (degreev, sv) as long as graph is not empty. To do so, we can maintain the queue(or stack) of the leaves. On every iteration we dequeue vertex v and remove edge (v, sv) and update values for vertex sv: degreesv -= 1 and ssv ^= v. If degree of vertex sv becomes equal to 1, we enqueue it.When dequeued vertex has zero degree, just ignore it because we have already removed all edges of corresponding tree.You can see my solution for details.Time complexity: O(n)504B - Misha and Permutations SummationTo solve the problem, one need to be able to find the index of given permutation in lexicographical order and permutation by its index. We will store indices in factorial number system. Thus number x is represented as . You can find the rules of the transform here.To make the transform, you may need to use data structures such as binary search tree or binary indexed tree (for maintaining queries of finding k-th number in the set and finding the amount of numbers less than given one).So, one need to get indices of the permutations, to sum them modulo n! and make inverse transform. You can read any accepted solution for better understanding.Time complexity: or .504C - Misha and Palindrome DegreeNote that if the amount of elements, which number of occurrences is odd, is greater than one, the answer is zero. On the other hand, if array is the palindrome, answer is .Let's cut equal elements from the end and the beginning of array while it is possible. Let's call remaining array as b and its length as m. We are interested in segments [l, r] which cover some prefix or suffix of b.We need to find the minimum length of such prefix and suffix. Prefix and suffix can overlap the middle of b and these cases are needed to maintain. To find minimum length you can use binary search or simply iterating over array and storing the amount of every element to the left and right from the current index. Let's call minimum length of prefix as pref and as suf of suffix. So .Time complexity: O(n) or .504D - Misha and XORFirstly, we convert each number into a binary system: it can be done in O(MAXBITS2), where MAXBITS ≤ 2000 with rather small constant(we store number in system with big radix).To solve the problem we need to modify Gauss elimination algorithm. For each row we should store set of row's indices which we already XORed this row to get row echelon form (we can store it in bitset), also for each bit i we store index p[i] of row, which lowest set bit is i in row echelon form.Maintaining the query we try to reset bits from lowest to highest using array p and save information, which rows were XORed with current number. If we can reset whole number, the answer is positive and we know indices of answer. We update array p, otherwise.Time complexity: O(m × MAXBITS × (MAXBITS + m)) with small constant due to bit compression.504E - Misha and LCP on TreeLet's build heavy-light decomposition of given tree and write all strings corresponding to heavy paths one by one in one string T, every path should be written twice: in the direct and reverse order.Maintaining query we can split paths (a, b) и (c, d) into parts, which completely belongs to some heavy paths. There can be at most such parts. Note that every part corresponds to some substring of T.Now we only need to find longest common prefix of two substrings in string T. It can be done building suffix array of string T and lcp array. So, we can find longest common prefix of two substring in O(1) constructing rmq sparse table on lcp array.Time complexity: For the better understanding see my solution.P.S. One can uses hashes instead of suffix array.ADD: There is another approach to solve this problem in but it's rather slow in practice. We can do binary search on answer and use hashes, but we do it for all queries at one time. The only problem is to find k-th vertex on the path, we can do it offline for all queries in O(n + m) time. We run dfs and maintain stack of vertices. See my solution for details.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/15743",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.6,
            "reason": "宽松匹配: 包含题目编号 501 和字母"
          },
          "content_length": 5171
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #285 - Codeforces - Code 1",
          "code": "#include <iostream>\nusing namespace std;\n\nint main ()\n{\n        cout << \"Happy Birthday Mike ! \\\\:D/\" << endl << \"Thanks For Everything !!! :D\" << endl;\n        return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/15725",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #285 - Codeforces - Code 2",
          "code": "#include <iostream>\nusing namespace std;\n\nint main ()\n{\n        cout << \"Happy Birthday Mike ! \\\\:D/\" << endl << \"Thanks For Everything !!! :D\" << endl;\n        return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/15725",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #285 - Codeforces - Code 3",
          "code": "math.factorial(x)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15725",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #285 - Codeforces - Code 4",
          "code": "math.factorial(200000)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15725",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #285 - Codeforces - Code 5",
          "code": "i = 1\nj = 1\nwhile(i <= n) {\n while(i > j || !is_it_a_good_range(i,j)) {\n  ++j;\n  update_set_with_bad_numbers(j);\n  update_set_with_bad_numbers(n+1-j);\n }\n update_set_with_bad_numbers(i);\n update_set_with_bad_numbers(n+1-i);\n ++i;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15725",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #285 - Codeforces - Code 6",
          "code": "i = 1\nj = 1\nwhile(i <= n) {\n while(i > j || !is_it_a_good_range(i,j)) {\n  ++j;\n  update_set_with_bad_numbers(j);\n  update_set_with_bad_numbers(n+1-j);\n }\n update_set_with_bad_numbers(i);\n update_set_with_bad_numbers(n+1-i);\n ++i;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15725",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #285 - Codeforces - Code 7",
          "code": "BigInteger x = new BigInteger(in.next());\nx.testBit(j);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15725",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #285 - Codeforces - Code 8",
          "code": "BigInteger x = new BigInteger(in.next());\nx.testBit(j);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15725",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #285 - Codeforces - Code 9",
          "code": "set<int>::iterator it = s.lower_bound(x);\ns.erase(it);\nupd(*it);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15725",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #285 - Codeforces - Code 10",
          "code": "set<int>::iterator it = s.lower_bound(x);\ns.erase(it);\nupd(*it);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15725",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 65536, \"n\");\n    inf.readEoln();\n\n    long long sumDegrees = 0;\n\n    for (int i = 0; i < n; i++) {\n        int degree = inf.readInt(0, n - 1, \"degreei\");\n        inf.readSpace();\n        int s = inf.readInt(0, 65535, \"si\");\n        inf.readEoln();\n\n        sumDegrees += degree;\n    }\n\n    ensuref(sumDegrees % 2 == 0, \"Sum of degrees must be even, but it is %lld\", sumDegrees);\n    ensuref(sumDegrees <= 2LL * (n - 1), \"Sum of degrees must be at most 2*(n-1)=%lld, but it is %lld\", 2LL * (n - 1), sumDegrees);\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 65536, \"n\");\n    inf.readEoln();\n\n    long long sumDegrees = 0;\n\n    for (int i = 0; i < n; i++) {\n        int degree = inf.readInt(0, n - 1, \"degreei\");\n        inf.readSpace();\n        int s = inf.readInt(0, 65535, \"si\");\n        inf.readEoln();\n\n        sumDegrees += degree;\n    }\n\n    ensuref(sumDegrees % 2 == 0, \"Sum of degrees must be even, but it is %lld\", sumDegrees);\n    ensuref(sumDegrees <= 2LL * (n - 1), \"Sum of degrees must be at most 2*(n-1)=%lld, but it is %lld\", 2LL * (n - 1), sumDegrees);\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 65536, \"n\");\n    inf.readEoln();\n\n    long long sumDegrees = 0;\n\n    for (int i = 0; i < n; i++) {\n        int degree = inf.readInt(0, n - 1, \"degreei\");\n        inf.readSpace();\n        int s = inf.readInt(0, 65535, \"si\");\n        inf.readEoln();\n\n        sumDegrees += degree;\n    }\n\n    ensuref(sumDegrees % 2 == 0, \"Sum of degrees must be even, but it is %lld\", sumDegrees);\n    ensuref(sumDegrees <= 2LL * (n - 1), \"Sum of degrees must be at most 2*(n-1)=%lld, but it is %lld\", 2LL * (n - 1), sumDegrees);\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char * argv[]) {\n\n    registerTestlibCmd(argc, argv);\n\n    // Read n\n    int n = inf.readInt(1, (1<<16), \"n\");\n\n    vector<int> degree_v(n);\n    vector<int> s_v(n);\n\n    for (int i = 0; i < n; ++i) {\n        degree_v[i] = inf.readInt(0, n - 1, format(\"degree_v[%d]\", i).c_str());\n        s_v[i] = inf.readInt(0, (1<<16)-1, format(\"s_v[%d]\", i).c_str());\n    }\n\n    // Read participant's output\n    int m = ouf.readInt(0, n - 1, \"m\");\n    // m must satisfy 0 ≤ m ≤ n - 1\n    if (m < 0 || m > n - 1)\n        ouf.quitf(_wa, \"invalid number of edges m = %d\", m);\n\n    // Read edges\n    vector<vector<int>> adj(n);\n    set<pair<int,int>> edge_set;\n\n    // For cycle detection\n    vector<int> parent(n);\n    for (int i = 0; i < n; ++i)\n        parent[i] = i;\n\n    function<int(int)> find = [&](int u) {\n        if (parent[u] != u)\n            parent[u] = find(parent[u]);\n        return parent[u];\n    };\n\n    auto unite = [&](int u, int v) -> bool {\n        int pu = find(u);\n        int pv = find(v);\n        if (pu == pv)\n            return false;\n        parent[pu] = pv;\n        return true;\n    };\n\n    for (int i = 0; i < m; ++i) {\n        int a = ouf.readInt(0, n - 1, format(\"edge[%d].a\", i+1).c_str());\n        int b = ouf.readInt(0, n - 1, format(\"edge[%d].b\", i+1).c_str());\n        if (a == b)\n            ouf.quitf(_wa, \"edge cannot connect a vertex to itself: edge[%d] connects %d to itself\", i+1, a);\n\n        // Check for duplicate edges\n        int u = min(a, b);\n        int v = max(a, b);\n        pair<int,int> edge(u, v);\n        if (edge_set.count(edge))\n            ouf.quitf(_wa, \"duplicate edge between %d and %d\", u, v);\n        edge_set.insert(edge);\n\n        // Check for cycles\n        if (!unite(a, b))\n            ouf.quitf(_wa, \"graph contains a cycle at edge %d (%d, %d)\", i+1, a, b);\n\n        // Build adjacency list\n        adj[a].push_back(b);\n        adj[b].push_back(a);\n    }\n\n    // Now, check degrees and s_v\n    for (int v = 0; v < n; ++v) {\n        int deg = adj[v].size();\n        if (deg != degree_v[v]) {\n            ouf.quitf(_wa, \"degree mismatch at vertex %d: expected %d, found %d\", v, degree_v[v], deg);\n        }\n        int s_v_out = 0;\n        for (int u : adj[v]) {\n            s_v_out ^= u;\n        }\n        if (s_v_out != s_v[v]) {\n            ouf.quitf(_wa, \"s_v mismatch at vertex %d: expected %d, found %d\", v, s_v[v], s_v_out);\n        }\n    }\n\n    // If everything is okay\n    ouf.quitf(_ok, \"Correct\");\n\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random_tree\");\n    int components = opt<int>(\"components\", 1); // For forests\n\n    vector<vector<int>> adj(n);\n    vector<pair<int, int>> edges;\n\n    if (type == \"random_tree\") {\n        // Generate a random tree\n        for (int i = 1; i < n; ++i) {\n            int u = i;\n            int v = rnd.next(0, i - 1);\n            adj[u].push_back(v);\n            adj[v].push_back(u);\n            edges.push_back({u, v});\n        }\n    }\n    else if (type == \"path\") {\n        // Generate a path (chain)\n        for (int i = 1; i < n; ++i) {\n            int u = i - 1;\n            int v = i;\n            adj[u].push_back(v);\n            adj[v].push_back(u);\n            edges.push_back({u, v});\n        }\n    }\n    else if (type == \"star\") {\n        // Generate a star graph\n        for (int i = 1; i < n; ++i) {\n            int u = 0;\n            int v = i;\n            adj[u].push_back(v);\n            adj[v].push_back(u);\n            edges.push_back({u, v});\n        }\n    }\n    else if (type == \"binary_tree\") {\n        // Generate a binary tree\n        for (int i = 1; i < n; ++i) {\n            int u = i;\n            int v = (i - 1) / 2;\n            adj[u].push_back(v);\n            adj[v].push_back(u);\n            edges.push_back({u, v});\n        }\n    }\n    else if (type == \"random_forest\") {\n        // Generate a random forest\n        if (components < 1 || components > n) {\n            cerr << \"Invalid number of components\\n\";\n            return 1;\n        }\n        // Partition nodes into components\n        vector<int> nodes(n);\n        for (int i = 0; i < n; ++i) {\n            nodes[i] = i;\n        }\n        shuffle(nodes.begin(), nodes.end());\n        vector<vector<int>> component_nodes(components);\n        for (int i = 0; i < n; ++i) {\n            component_nodes[i % components].push_back(nodes[i]);\n        }\n        // Generate a tree in each component\n        for (int c = 0; c < components; ++c) {\n            vector<int>& comp = component_nodes[c];\n            int sz = comp.size();\n            for (int i = 1; i < sz; ++i) {\n                int u = comp[i];\n                int v = comp[rnd.next(0, i - 1)];\n                adj[u].push_back(v);\n                adj[v].push_back(u);\n                edges.push_back({u, v});\n            }\n        }\n    }\n    else if (type == \"isolated_nodes\") {\n        // All nodes are isolated; no edges needed\n    }\n    else {\n        cerr << \"Unknown type: \" << type << endl;\n        return 1;\n    }\n\n    // Compute degree and s_v for each vertex\n    vector<int> degree(n);\n    vector<int> s_v(n);\n    for (int u = 0; u < n; ++u) {\n        degree[u] = adj[u].size();\n        s_v[u] = 0;\n        for (int v : adj[u]) {\n            s_v[u] ^= v;\n        }\n    }\n\n    // Output n\n    printf(\"%d\\n\", n);\n\n    // Output degrees and s_v\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d %d\\n\", degree[i], s_v[i]);\n    }\n\n    // Note: Do not output edges, as per problem requirement\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random_tree\");\n    int components = opt<int>(\"components\", 1); // For forests\n\n    vector<vector<int>> adj(n);\n    vector<pair<int, int>> edges;\n\n    if (type == \"random_tree\") {\n        // Generate a random tree\n        for (int i = 1; i < n; ++i) {\n            int u = i;\n            int v = rnd.next(0, i - 1);\n            adj[u].push_back(v);\n            adj[v].push_back(u);\n            edges.push_back({u, v});\n        }\n    }\n    else if (type == \"path\") {\n        // Generate a path (chain)\n        for (int i = 1; i < n; ++i) {\n            int u = i - 1;\n            int v = i;\n            adj[u].push_back(v);\n            adj[v].push_back(u);\n            edges.push_back({u, v});\n        }\n    }\n    else if (type == \"star\") {\n        // Generate a star graph\n        for (int i = 1; i < n; ++i) {\n            int u = 0;\n            int v = i;\n            adj[u].push_back(v);\n            adj[v].push_back(u);\n            edges.push_back({u, v});\n        }\n    }\n    else if (type == \"binary_tree\") {\n        // Generate a binary tree\n        for (int i = 1; i < n; ++i) {\n            int u = i;\n            int v = (i - 1) / 2;\n            adj[u].push_back(v);\n            adj[v].push_back(u);\n            edges.push_back({u, v});\n        }\n    }\n    else if (type == \"random_forest\") {\n        // Generate a random forest\n        if (components < 1 || components > n) {\n            cerr << \"Invalid number of components\\n\";\n            return 1;\n        }\n        // Partition nodes into components\n        vector<int> nodes(n);\n        for (int i = 0; i < n; ++i) {\n            nodes[i] = i;\n        }\n        shuffle(nodes.begin(), nodes.end());\n        vector<vector<int>> component_nodes(components);\n        for (int i = 0; i < n; ++i) {\n            component_nodes[i % components].push_back(nodes[i]);\n        }\n        // Generate a tree in each component\n        for (int c = 0; c < components; ++c) {\n            vector<int>& comp = component_nodes[c];\n            int sz = comp.size();\n            for (int i = 1; i < sz; ++i) {\n                int u = comp[i];\n                int v = comp[rnd.next(0, i - 1)];\n                adj[u].push_back(v);\n                adj[v].push_back(u);\n                edges.push_back({u, v});\n            }\n        }\n    }\n    else if (type == \"isolated_nodes\") {\n        // All nodes are isolated; no edges needed\n    }\n    else {\n        cerr << \"Unknown type: \" << type << endl;\n        return 1;\n    }\n\n    // Compute degree and s_v for each vertex\n    vector<int> degree(n);\n    vector<int> s_v(n);\n    for (int u = 0; u < n; ++u) {\n        degree[u] = adj[u].size();\n        s_v[u] = 0;\n        for (int v : adj[u]) {\n            s_v[u] ^= v;\n        }\n    }\n\n    // Output n\n    printf(\"%d\\n\", n);\n\n    // Output degrees and s_v\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d %d\\n\", degree[i], s_v[i]);\n    }\n\n    // Note: Do not output edges, as per problem requirement\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -type isolated_nodes\n\n./gen -n 2 -type path\n./gen -n 2 -type star\n\n./gen -n 5 -type random_tree\n./gen -n 5 -type path\n./gen -n 5 -type star\n./gen -n 5 -type binary_tree\n\n./gen -n 10 -type random_tree\n./gen -n 10 -type random_forest -components 2\n./gen -n 10 -type random_forest -components 5\n./gen -n 10 -type isolated_nodes\n\n./gen -n 100 -type random_tree\n./gen -n 100 -type path\n./gen -n 100 -type star\n./gen -n 100 -type binary_tree\n./gen -n 100 -type random_forest -components 10\n./gen -n 100 -type random_forest -components 50\n\n./gen -n 1000 -type random_tree\n./gen -n 1000 -type path\n./gen -n 1000 -type star\n./gen -n 1000 -type binary_tree\n./gen -n 1000 -type random_forest -components 100\n./gen -n 1000 -type random_forest -components 500\n\n./gen -n 10000 -type random_tree\n./gen -n 10000 -type random_forest -components 1000\n\n./gen -n 50000 -type random_tree\n\n./gen -n 65536 -type random_tree\n./gen -n 65536 -type random_forest -components 1\n./gen -n 65536 -type random_forest -components 65536\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:40:17.662424",
        "total_tutorials": 3,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "501/D",
      "title": "D. Misha and Permutations Summation",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains an integer n (1 ≤ n ≤ 200 000).The second line contains n distinct integers from 0 to n - 1, separated by a space, forming permutation p.The third line contains n distinct integers from 0 to n - 1, separated by spaces, forming permutation q.",
      "output_spec": "OutputPrint n distinct integers from 0 to n - 1, forming the sum of the given permutations. Separate the numbers by spaces.",
      "sample_tests": "ExamplesInputCopy20 10 1OutputCopy0 1InputCopy20 11 0OutputCopy1 0InputCopy31 2 02 1 0OutputCopy1 0 2",
      "description": "D. Misha and Permutations Summation\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains an integer n (1 ≤ n ≤ 200 000).The second line contains n distinct integers from 0 to n - 1, separated by a space, forming permutation p.The third line contains n distinct integers from 0 to n - 1, separated by spaces, forming permutation q.\n\nOutputPrint n distinct integers from 0 to n - 1, forming the sum of the given permutations. Separate the numbers by spaces.\n\nInputCopy20 10 1OutputCopy0 1InputCopy20 11 0OutputCopy1 0InputCopy31 2 02 1 0OutputCopy1 0 2\n\nInputCopy20 10 1\n\nOutputCopy0 1\n\nInputCopy20 11 0\n\nOutputCopy1 0\n\nInputCopy31 2 02 1 0\n\nOutputCopy1 0 2\n\nNotePermutations of numbers from 0 to 1 in the lexicographical order: (0, 1), (1, 0).In the first sample Ord(p) = 0 and Ord(q) = 0, so the answer is .In the second sample Ord(p) = 0 and Ord(q) = 1, so the answer is .Permutations of numbers from 0 to 2 in the lexicographical order: (0, 1, 2), (0, 2, 1), (1, 0, 2), (1, 2, 0), (2, 0, 1), (2, 1, 0).In the third sample Ord(p) = 3 and Ord(q) = 5, so the answer is .",
      "solutions": [
        {
          "title": "Codeforces Round #285 - Codeforces",
          "content": "Hi, Codeforces!Codeforces Round #285 will be held at 12 January, 12.00 MSK. Problems are authored by me, Evgeny Savinov. This is my first round at Codeforces. I hope that this isn't the last one.I want to thank sokian and Golovanov399 for help in preparing and testing round, Zlobober for invaluable help in preparing round, AlexFetisov for testing round, Delinur for translating problem statements in English, and of course, MikeMirzayanov for great systems Codeforces and Polygon.By the way, today(11 January) is MikeMirzayanov's birthday. Happy birthday, Mike!The round will be for both divisions. Information about score distribution will be posted just before the round starts.UPD1: Scoring system will be dynamic. Problems will be arranged in ascending expected difficulty order.UPD2: The editorial can be found here. I'm sorry for the delay.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/15725",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 848
        },
        {
          "title": "Codeforces Round #285 Editorial - Codeforces",
          "content": "501A - ContestIn this problem one need to determine the number of points for both guys and find out who got more points.Time complexity: O(1).501B - Misha and Changing HandlesThe problem can be formulated as follows: The directed graph is given, its vertices correspond to users' handles and edges — to requests. It consists of a number of chains, so every vertex ingoing and outgoing degree doesn't exceed one. One need to find number of chains and first and last vertices of every chain. The arcs of this graph can be stored in dictionary(one can use std::map\\unoredered_map in C++ and TreeMap\\HashMap in Java) with head of the arc as the key and the tail as the value.Each zero ingoing degree vertex corresponds to unique user as well as first vertex of some chain. We should iterate from such vertices through the arcs while it's possible. Thus we find relation between first and last vertices in the chain as well as relation between the original and the new handle of some user.You can see my solution for details.Time complexity: .504A - Misha and ForestNote that every non-empty forest has a leaf(vertex of degree 1). Let's remove edges one by one and maintain actual values (degreev, sv) as long as graph is not empty. To do so, we can maintain the queue(or stack) of the leaves. On every iteration we dequeue vertex v and remove edge (v, sv) and update values for vertex sv: degreesv -= 1 and ssv ^= v. If degree of vertex sv becomes equal to 1, we enqueue it.When dequeued vertex has zero degree, just ignore it because we have already removed all edges of corresponding tree.You can see my solution for details.Time complexity: O(n)504B - Misha and Permutations SummationTo solve the problem, one need to be able to find the index of given permutation in lexicographical order and permutation by its index. We will store indices in factorial number system. Thus number x is represented as . You can find the rules of the transform here.To make the transform, you may need to use data structures such as binary search tree or binary indexed tree (for maintaining queries of finding k-th number in the set and finding the amount of numbers less than given one).So, one need to get indices of the permutations, to sum them modulo n! and make inverse transform. You can read any accepted solution for better understanding.Time complexity: or .504C - Misha and Palindrome DegreeNote that if the amount of elements, which number of occurrences is odd, is greater than one, the answer is zero. On the other hand, if array is the palindrome, answer is .Let's cut equal elements from the end and the beginning of array while it is possible. Let's call remaining array as b and its length as m. We are interested in segments [l, r] which cover some prefix or suffix of b.We need to find the minimum length of such prefix and suffix. Prefix and suffix can overlap the middle of b and these cases are needed to maintain. To find minimum length you can use binary search or simply iterating over array and storing the amount of every element to the left and right from the current index. Let's call minimum length of prefix as pref and as suf of suffix. So .Time complexity: O(n) or .504D - Misha and XORFirstly, we convert each number into a binary system: it can be done in O(MAXBITS2), where MAXBITS ≤ 2000 with rather small constant(we store number in system with big radix).To solve the problem we need to modify Gauss elimination algorithm. For each row we should store set of row's indices which we already XORed this row to get row echelon form (we can store it in bitset), also for each bit i we store index p[i] of row, which lowest set bit is i in row echelon form.Maintaining the query we try to reset bits from lowest to highest using array p and save information, which rows were XORed with current number. If we can reset whole number, the answer is positive and we know indices of answer. We update array p, otherwise.Time complexity: O(m × MAXBITS × (MAXBITS + m)) with small constant due to bit compression.504E - Misha and LCP on TreeLet's build heavy-light decomposition of given tree and write all strings corresponding to heavy paths one by one in one string T, every path should be written twice: in the direct and reverse order.Maintaining query we can split paths (a, b) и (c, d) into parts, which completely belongs to some heavy paths. There can be at most such parts. Note that every part corresponds to some substring of T.Now we only need to find longest common prefix of two substrings in string T. It can be done building suffix array of string T and lcp array. So, we can find longest common prefix of two substring in O(1) constructing rmq sparse table on lcp array.Time complexity: For the better understanding see my solution.P.S. One can uses hashes instead of suffix array.ADD: There is another approach to solve this problem in but it's rather slow in practice. We can do binary search on answer and use hashes, but we do it for all queries at one time. The only problem is to find k-th vertex on the path, we can do it offline for all queries in O(n + m) time. We run dfs and maintain stack of vertices. See my solution for details.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/15743",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.6,
            "reason": "宽松匹配: 包含题目编号 501 和字母"
          },
          "content_length": 5171
        },
        {
          "title": "Codeforces Round #285 Editorial - Codeforces",
          "content": "501A - ContestIn this problem one need to determine the number of points for both guys and find out who got more points.Time complexity: O(1).501B - Misha and Changing HandlesThe problem can be formulated as follows: The directed graph is given, its vertices correspond to users' handles and edges — to requests. It consists of a number of chains, so every vertex ingoing and outgoing degree doesn't exceed one. One need to find number of chains and first and last vertices of every chain. The arcs of this graph can be stored in dictionary(one can use std::map\\unoredered_map in C++ and TreeMap\\HashMap in Java) with head of the arc as the key and the tail as the value.Each zero ingoing degree vertex corresponds to unique user as well as first vertex of some chain. We should iterate from such vertices through the arcs while it's possible. Thus we find relation between first and last vertices in the chain as well as relation between the original and the new handle of some user.You can see my solution for details.Time complexity: .504A - Misha and ForestNote that every non-empty forest has a leaf(vertex of degree 1). Let's remove edges one by one and maintain actual values (degreev, sv) as long as graph is not empty. To do so, we can maintain the queue(or stack) of the leaves. On every iteration we dequeue vertex v and remove edge (v, sv) and update values for vertex sv: degreesv -= 1 and ssv ^= v. If degree of vertex sv becomes equal to 1, we enqueue it.When dequeued vertex has zero degree, just ignore it because we have already removed all edges of corresponding tree.You can see my solution for details.Time complexity: O(n)504B - Misha and Permutations SummationTo solve the problem, one need to be able to find the index of given permutation in lexicographical order and permutation by its index. We will store indices in factorial number system. Thus number x is represented as . You can find the rules of the transform here.To make the transform, you may need to use data structures such as binary search tree or binary indexed tree (for maintaining queries of finding k-th number in the set and finding the amount of numbers less than given one).So, one need to get indices of the permutations, to sum them modulo n! and make inverse transform. You can read any accepted solution for better understanding.Time complexity: or .504C - Misha and Palindrome DegreeNote that if the amount of elements, which number of occurrences is odd, is greater than one, the answer is zero. On the other hand, if array is the palindrome, answer is .Let's cut equal elements from the end and the beginning of array while it is possible. Let's call remaining array as b and its length as m. We are interested in segments [l, r] which cover some prefix or suffix of b.We need to find the minimum length of such prefix and suffix. Prefix and suffix can overlap the middle of b and these cases are needed to maintain. To find minimum length you can use binary search or simply iterating over array and storing the amount of every element to the left and right from the current index. Let's call minimum length of prefix as pref and as suf of suffix. So .Time complexity: O(n) or .504D - Misha and XORFirstly, we convert each number into a binary system: it can be done in O(MAXBITS2), where MAXBITS ≤ 2000 with rather small constant(we store number in system with big radix).To solve the problem we need to modify Gauss elimination algorithm. For each row we should store set of row's indices which we already XORed this row to get row echelon form (we can store it in bitset), also for each bit i we store index p[i] of row, which lowest set bit is i in row echelon form.Maintaining the query we try to reset bits from lowest to highest using array p and save information, which rows were XORed with current number. If we can reset whole number, the answer is positive and we know indices of answer. We update array p, otherwise.Time complexity: O(m × MAXBITS × (MAXBITS + m)) with small constant due to bit compression.504E - Misha and LCP on TreeLet's build heavy-light decomposition of given tree and write all strings corresponding to heavy paths one by one in one string T, every path should be written twice: in the direct and reverse order.Maintaining query we can split paths (a, b) и (c, d) into parts, which completely belongs to some heavy paths. There can be at most such parts. Note that every part corresponds to some substring of T.Now we only need to find longest common prefix of two substrings in string T. It can be done building suffix array of string T and lcp array. So, we can find longest common prefix of two substring in O(1) constructing rmq sparse table on lcp array.Time complexity: For the better understanding see my solution.P.S. One can uses hashes instead of suffix array.ADD: There is another approach to solve this problem in but it's rather slow in practice. We can do binary search on answer and use hashes, but we do it for all queries at one time. The only problem is to find k-th vertex on the path, we can do it offline for all queries in O(n + m) time. We run dfs and maintain stack of vertices. See my solution for details.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/15743",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.6,
            "reason": "宽松匹配: 包含题目编号 501 和字母"
          },
          "content_length": 5171
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #285 - Codeforces - Code 1",
          "code": "#include <iostream>\nusing namespace std;\n\nint main ()\n{\n        cout << \"Happy Birthday Mike ! \\\\:D/\" << endl << \"Thanks For Everything !!! :D\" << endl;\n        return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/15725",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #285 - Codeforces - Code 2",
          "code": "#include <iostream>\nusing namespace std;\n\nint main ()\n{\n        cout << \"Happy Birthday Mike ! \\\\:D/\" << endl << \"Thanks For Everything !!! :D\" << endl;\n        return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/15725",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #285 - Codeforces - Code 3",
          "code": "math.factorial(x)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15725",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #285 - Codeforces - Code 4",
          "code": "math.factorial(200000)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15725",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #285 - Codeforces - Code 5",
          "code": "i = 1\nj = 1\nwhile(i <= n) {\n while(i > j || !is_it_a_good_range(i,j)) {\n  ++j;\n  update_set_with_bad_numbers(j);\n  update_set_with_bad_numbers(n+1-j);\n }\n update_set_with_bad_numbers(i);\n update_set_with_bad_numbers(n+1-i);\n ++i;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15725",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #285 - Codeforces - Code 6",
          "code": "i = 1\nj = 1\nwhile(i <= n) {\n while(i > j || !is_it_a_good_range(i,j)) {\n  ++j;\n  update_set_with_bad_numbers(j);\n  update_set_with_bad_numbers(n+1-j);\n }\n update_set_with_bad_numbers(i);\n update_set_with_bad_numbers(n+1-i);\n ++i;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15725",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #285 - Codeforces - Code 7",
          "code": "BigInteger x = new BigInteger(in.next());\nx.testBit(j);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15725",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #285 - Codeforces - Code 8",
          "code": "BigInteger x = new BigInteger(in.next());\nx.testBit(j);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15725",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #285 - Codeforces - Code 9",
          "code": "set<int>::iterator it = s.lower_bound(x);\ns.erase(it);\nupd(*it);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15725",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #285 - Codeforces - Code 10",
          "code": "set<int>::iterator it = s.lower_bound(x);\ns.erase(it);\nupd(*it);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15725",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 200000, \"n\");\n    inf.readEoln();\n\n    vector<int> p = inf.readInts(n, 0, n - 1, \"p\");\n    inf.readEoln();\n\n    vector<int> q = inf.readInts(n, 0, n - 1, \"q\");\n    inf.readEoln();\n\n    // Check that p is a permutation\n    {\n        vector<bool> used(n, false);\n        for (int i = 0; i < n; ++i) {\n            ensuref(!used[p[i]], \"p is not a permutation, duplicate element %d\", p[i]);\n            used[p[i]] = true;\n        }\n    }\n\n    // Similarly check q\n    {\n        vector<bool> used(n, false);\n        for (int i = 0; i < n; ++i) {\n            ensuref(!used[q[i]], \"q is not a permutation, duplicate element %d\", q[i]);\n            used[q[i]] = true;\n        }\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 200000, \"n\");\n    inf.readEoln();\n\n    vector<int> p = inf.readInts(n, 0, n - 1, \"p\");\n    inf.readEoln();\n\n    vector<int> q = inf.readInts(n, 0, n - 1, \"q\");\n    inf.readEoln();\n\n    // Check that p is a permutation\n    {\n        vector<bool> used(n, false);\n        for (int i = 0; i < n; ++i) {\n            ensuref(!used[p[i]], \"p is not a permutation, duplicate element %d\", p[i]);\n            used[p[i]] = true;\n        }\n    }\n\n    // Similarly check q\n    {\n        vector<bool> used(n, false);\n        for (int i = 0; i < n; ++i) {\n            ensuref(!used[q[i]], \"q is not a permutation, duplicate element %d\", q[i]);\n            used[q[i]] = true;\n        }\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 200000, \"n\");\n    inf.readEoln();\n\n    vector<int> p = inf.readInts(n, 0, n - 1, \"p\");\n    inf.readEoln();\n\n    vector<int> q = inf.readInts(n, 0, n - 1, \"q\");\n    inf.readEoln();\n\n    // Check that p is a permutation\n    {\n        vector<bool> used(n, false);\n        for (int i = 0; i < n; ++i) {\n            ensuref(!used[p[i]], \"p is not a permutation, duplicate element %d\", p[i]);\n            used[p[i]] = true;\n        }\n    }\n\n    // Similarly check q\n    {\n        vector<bool> used(n, false);\n        for (int i = 0; i < n; ++i) {\n            ensuref(!used[q[i]], \"q is not a permutation, duplicate element %d\", q[i]);\n            used[q[i]] = true;\n        }\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string p_type = opt<string>(\"p_type\", \"random\");\n    string q_type = opt<string>(\"q_type\", \"random\");\n\n    vector<int> p(n), q(n);\n\n    auto generate_permutation = [&](string type, vector<int> &perm) {\n        if (type == \"identity\") {\n            for (int i = 0; i < n; ++i) perm[i] = i;\n        } else if (type == \"reverse\") {\n            for (int i = 0; i < n; ++i) perm[i] = n - 1 - i;\n        } else if (type == \"random\") {\n            for (int i = 0; i < n; ++i) perm[i] = i;\n            shuffle(perm.begin(), perm.end());\n        } else if (type == \"almost_identity\") {\n            for (int i = 0; i < n; ++i) perm[i] = i;\n            if (n >= 2) {\n                int i = rnd.next(0, n - 1);\n                int j = rnd.next(0, n - 1);\n                if (i != j) swap(perm[i], perm[j]);\n            }\n        } else if (type == \"shifted\") {\n            for (int i = 0; i < n; ++i) perm[i] = (i + 1) % n;\n        } else if (type == \"same\") {\n            // Will handle in q_type\n        } else {\n            cerr << \"Unknown type: \" << type << endl;\n            exit(1);\n        }\n    };\n\n    generate_permutation(p_type, p);\n\n    if (q_type == \"same\") {\n        q = p;\n    } else {\n        generate_permutation(q_type, q);\n    }\n\n    // Output n\n    printf(\"%d\\n\", n);\n\n    // Output p\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d%c\", p[i], (i + 1 == n) ? '\\n' : ' ');\n    }\n\n    // Output q\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d%c\", q[i], (i + 1 == n) ? '\\n' : ' ');\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string p_type = opt<string>(\"p_type\", \"random\");\n    string q_type = opt<string>(\"q_type\", \"random\");\n\n    vector<int> p(n), q(n);\n\n    auto generate_permutation = [&](string type, vector<int> &perm) {\n        if (type == \"identity\") {\n            for (int i = 0; i < n; ++i) perm[i] = i;\n        } else if (type == \"reverse\") {\n            for (int i = 0; i < n; ++i) perm[i] = n - 1 - i;\n        } else if (type == \"random\") {\n            for (int i = 0; i < n; ++i) perm[i] = i;\n            shuffle(perm.begin(), perm.end());\n        } else if (type == \"almost_identity\") {\n            for (int i = 0; i < n; ++i) perm[i] = i;\n            if (n >= 2) {\n                int i = rnd.next(0, n - 1);\n                int j = rnd.next(0, n - 1);\n                if (i != j) swap(perm[i], perm[j]);\n            }\n        } else if (type == \"shifted\") {\n            for (int i = 0; i < n; ++i) perm[i] = (i + 1) % n;\n        } else if (type == \"same\") {\n            // Will handle in q_type\n        } else {\n            cerr << \"Unknown type: \" << type << endl;\n            exit(1);\n        }\n    };\n\n    generate_permutation(p_type, p);\n\n    if (q_type == \"same\") {\n        q = p;\n    } else {\n        generate_permutation(q_type, q);\n    }\n\n    // Output n\n    printf(\"%d\\n\", n);\n\n    // Output p\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d%c\", p[i], (i + 1 == n) ? '\\n' : ' ');\n    }\n\n    // Output q\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d%c\", q[i], (i + 1 == n) ? '\\n' : ' ');\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -p_type identity -q_type identity\n./gen -n 2 -p_type identity -q_type reverse\n./gen -n 3 -p_type random -q_type random\n\n./gen -n 5 -p_type almost_identity -q_type identity\n./gen -n 5 -p_type shifted -q_type shifted\n./gen -n 5 -p_type random -q_type same\n\n./gen -n 1000 -p_type random -q_type random\n./gen -n 1000 -p_type identity -q_type reverse\n./gen -n 1000 -p_type almost_identity -q_type almost_identity\n\n./gen -n 10000 -p_type random -q_type random\n./gen -n 10000 -p_type identity -q_type reverse\n./gen -n 10000 -p_type almost_identity -q_type almost_identity\n\n./gen -n 99999 -p_type random -q_type random\n./gen -n 99999 -p_type identity -q_type reverse\n./gen -n 99999 -p_type random -q_type same\n\n./gen -n 200000 -p_type identity -q_type identity\n./gen -n 200000 -p_type reverse -q_type reverse\n./gen -n 200000 -p_type identity -q_type reverse\n./gen -n 200000 -p_type random -q_type random\n./gen -n 200000 -p_type random -q_type same\n\n./gen -n 200000 -p_type shifted -q_type shifted\n./gen -n 200000 -p_type almost_identity -q_type almost_identity\n./gen -n 200000 -p_type identity -q_type shifted\n./gen -n 200000 -p_type shifted -q_type reverse\n./gen -n 200000 -p_type random -q_type shifted\n\n./gen -n 200000 -p_type identity -q_type same\n./gen -n 200000 -p_type reverse -q_type same\n./gen -n 200000 -p_type shifted -q_type same\n./gen -n 200000 -p_type almost_identity -q_type same\n./gen -n 200000 -p_type identity -q_type almost_identity\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:40:20.144266",
        "total_tutorials": 3,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "501/E",
      "title": "E. Миша и палиндромность",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест1 секунда",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеВ первой строке находится целое число n (1 ≤ n ≤ 105).Во второй строке находятся n положительных целых чисел a[i] (1 ≤ a[i] ≤ n), разделённых пробелами — элементы Мишиного массива.",
      "output_spec": "Выходные данныеВ единственной строке выведите ответ на задачу.",
      "sample_tests": "ПримерыВходные данныеСкопировать32 2 2Выходные данныеСкопировать6Входные данныеСкопировать63 6 5 3 3 5Выходные данныеСкопировать0Входные данныеСкопировать55 5 2 5 2Выходные данныеСкопировать4",
      "description": "E. Миша и палиндромность\n\nограничение по времени на тест1 секунда\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвыводstdout\n\nВходные данныеВ первой строке находится целое число n (1 ≤ n ≤ 105).Во второй строке находятся n положительных целых чисел a[i] (1 ≤ a[i] ≤ n), разделённых пробелами — элементы Мишиного массива.\n\nВходные данные\n\nВыходные данныеВ единственной строке выведите ответ на задачу.\n\nВыходные данные\n\nВходные данныеСкопировать32 2 2Выходные данныеСкопировать6Входные данныеСкопировать63 6 5 3 3 5Выходные данныеСкопировать0Входные данныеСкопировать55 5 2 5 2Выходные данныеСкопировать4\n\nВходные данныеСкопировать32 2 2\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать6\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать63 6 5 3 3 5\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать0\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать55 5 2 5 2\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать4\n\nВыходные данныеСкопировать\n\nСкопировать\n\nПримечаниеВ первом примере подходит любая пара возможная пара (l, r).В третьем примере подходят пары (1, 3), (1, 4), (1, 5), (2, 5).",
      "solutions": [
        {
          "title": "Codeforces Round #285 - Codeforces",
          "content": "Привет, Codeforces!12 января в 12.00 MSK пройдет очередной 285-й раунд Codeforces. Автором задач являюсь я(Савинов Евгений). Это мой первый раунд на Codeforces и, надеюсь, не последний.Хочу поблагодарить Сергея Кияна(sokian) и Александра Голованова(Golovanov399) за помощь в подготовке и прорешивании задач, Макса Ахмедова(Zlobober) за неоценимую помощь в подготовке контеста, Алекса Фетисова(AlexFetisov) за прорешивание раунда, Марию Белову(Delinur) за перевод условий на английский язык и, конечно же, Михаила Мирзаянова(MikeMirzayanov) за замечательные системы Codeforces и Polygon.Кстати, сегодня(11 января) у Михаила Расиховича день рождения, давайте поздравим его с этим!Раунд состоится в обоих дивизионах. Информация о разбалловке будет опубликована перед началом раунда.UPD1: Будет использоваться динамическая разбалловка. Задачи расположены в порядке возрастания предполагаемой сложности.UPD2: Разбор задач можно найти здесь.",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/15725",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 935
        },
        {
          "title": "Разбор задач Codeforces Round #285 - Codeforces",
          "content": "501A - КонтестВ этой задаче требовалось сделать то, что написано в условии. Считать числа и определить у кого из ребят больше баллов.Асимптотика: O(1).501B - Миша и смена хэндловДля начала немного переформулируем задачу. Был дан ориентированный граф, вершинами которого являются хэндлы пользователей, а ребрами запросы изменения хэндлов. Он состоит из некоторого количества цепочек, нужно было найти их количество, начальные и конечные вершины каждой цепочки. То есть у каждой вершины входящая и исходящая степень не превосходит 1. Ввиду последнего ограничения, ребра этого графа можно хранить в словаре(в C++ — std::map\\unoredered_map, Java — TreeMap\\HashMap), где ключом является вершина из которой исходит ребро, а значением — вершина, в которую оно входит.Каждому уникальному пользователю соответствует вершина с нулевой входящей степенью. Из всех таких вершин нужно переходить по ребру, до тех пор, пока существует переход. Чтобы найти вершины с нулевой степенью, запомним вершины в которые входит ребро, и добавим их в множество(в C++ — std::set\\unoredered_set, Java — TreeSet\\HashSet).Асимптотика: .504A - Миша и лесЗаметим, что у непустого леса найдется вершина со степенью 1(такая вершина называется листом). Будем удалять ребра графа по очереди и поддерживать актуальные значения (degreev, sv), до тех пор пока он не станет пустым. Для этого будем поддерживать очередь(или стек) вершин являющихся листьями. На очередной итерации мы достаем вершину v из очереди, и удаляем ребро (v, sv), для этого делаем degreesv -= 1 и ssv ^= v. Если у вершины sv степень стала равной 1, то добавим ее в очередь.Необходимо обработать случай, когда мы достаем вершину v из очереди и у нее degreev = 0, тогда стоит проигнорировать это, так как мы уже удалили нужное ребро.Асимптотика: O(n)504B - Миша и сложение перестановокДля решения данной задачи необходимо научиться находить порядковый номер данной перестановки и перестановку по данному порядковому номеру. Так порядковые номера имеют достаточно большую длину, будем хранить их в факториальной системе счисления. То есть число x будем представлять как .Чтобы найти порядковый номер перестановки, заменим каждое число в перестановке на количество чисел стоящих правее и меньше его. Таким образом мы получим число, записанное в факториальной системе счисления.Чтобы получить по порядковому номеру перестановку необходимо провести обратную процедуру, для этого потребуется находить k-тое по величине число в множестве, и добавлять элемент в множество. В обоих случаях нам пригодится дерево отрезков, которое позволяет отвечать на запросы такого вида.В итоге получаем, что нам необходимо получить индексы перестановок, сложить их в факториальной системе счисления по модулю n!, и провести обратное преобразование. Для лучшего понимания ознакомьтесь с wiki и/или любым прошедшим решением.Асимптотика: или .504C - Миша и палиндромностьЗаметим, что если количество элементов, встречающихся нечетное число раз, больше одного — ответ равен нулю. Аналогично, если массив изначально является палиндромом — ответ .Будем обрезать с обоих концов палиндрома одинаковые символы, пока это возможно. Пусть при этом мы получили массив b длины m, его первый и последний элементы различны. Нужные нам отрезки [l, r] содержат какой-то префикс или суффикс массива b.Найдем минимальные длины суффикса и префикса. Здесь нужно рассмотреть два случая: переходит ли кратчайший префикс/суффикс за середину массива или нет. Определить минимальные длины можно с помощью бинпоиска или проходом по массиву и поддержанием количества каждого элемента слева и справа от текущего индекса. Обозначим минимальные длины префикса за pref, и суффикса за suf. Тогда ответ .Асимптотика O(n) или .504D - Миша и XORПереведем каждое число в двоичную систему счисления, для одного числа это делается MAXBITS2 c малой константой, если хранить число в системе счисления с основанием 109 или 1018. MAXBITS ≤ 2000.Для решения задачи нам потребуется небольшая модификация алгоритма Гаусса. Будем обрабатывать запросы по одному, проделывать итерацию алгоритма Гаусса, и поддерживать следующую информацию, для бита с индексом i хранить индекс p[i] запроса, или  - 1, если такого запроса нет, у которого этот бит является младшим выставленным после его(запроса) нормировки. Нормировкой я называю, процесс, в котором число приводится к такому виду, что его индекс наименьшего выставленного бита максимален. При нормировке мы можем XOR-ить число с любыми другими числами из запросов с индексами меньше текущего. Также нам понадобится информация о том, с числами из каких запросов мы проXOR-или текущее число чтобы его отнормировать, будем хранить это в битсете x[j], где j-индекс запроса.Итак, обрабатывая очередной запрос v, мы пробегаем по его битам от младшего к старшему. В случае если текущий бит i выставлен, мы пытаемся обнулить его. Если p[i] =  - 1, то обнулить этот бит нельзя и мы заканчиваем обработку этого запроса, иначе XOR-им текущее число с отнормированным числом из запроса p[i], а так же XOR-им x[v] с x[p[i]]. Если после обработки запросов нам удалось обнулить число, тогда ответ на запрос — да, и в битсете x[v] содержится множество индексов являющееся ответом, иначе — нет. Асимптотика решения O(m × MAXBITS × (MAXBITS + m)) с малой константой, засчет битового сжатия.504E - Миша и LCP на деревеПостроим heavy - light декомпозицию дерева и запишем все строки соответствующие heavy-путям идущим вверх и вниз в одну строку T.Обрабатывая очередной запрос разобьем пути (a, b) и (c, d) на части, целиком принадлежащие heavy-путям. Таких частей будет . Заметим, что каждой части пути соответствует некоторая подстрока T.Теперь для ответа на запрос нам необходимо находить наибольший общий префикс двух подстрок в строке. Это можно сделать, найдя суффиксный массив строки T, массив lcp и построить sparsetable на минимумы на нем.Асимтотика: Для лучшего понимания ознакомьтесь с моим решением.P.S. Вместо суффиксного массива можно использовать хэши, сохраняя асимптотику.P.P.S. Решения, использующие двоичный подъем и хэши, отсекались по времени большими тестами.",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/15743",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.6,
            "reason": "宽松匹配: 包含题目编号 501 和字母"
          },
          "content_length": 6068
        },
        {
          "title": "Разбор задач Codeforces Round #285 - Codeforces",
          "content": "501A - КонтестВ этой задаче требовалось сделать то, что написано в условии. Считать числа и определить у кого из ребят больше баллов.Асимптотика: O(1).501B - Миша и смена хэндловДля начала немного переформулируем задачу. Был дан ориентированный граф, вершинами которого являются хэндлы пользователей, а ребрами запросы изменения хэндлов. Он состоит из некоторого количества цепочек, нужно было найти их количество, начальные и конечные вершины каждой цепочки. То есть у каждой вершины входящая и исходящая степень не превосходит 1. Ввиду последнего ограничения, ребра этого графа можно хранить в словаре(в C++ — std::map\\unoredered_map, Java — TreeMap\\HashMap), где ключом является вершина из которой исходит ребро, а значением — вершина, в которую оно входит.Каждому уникальному пользователю соответствует вершина с нулевой входящей степенью. Из всех таких вершин нужно переходить по ребру, до тех пор, пока существует переход. Чтобы найти вершины с нулевой степенью, запомним вершины в которые входит ребро, и добавим их в множество(в C++ — std::set\\unoredered_set, Java — TreeSet\\HashSet).Асимптотика: .504A - Миша и лесЗаметим, что у непустого леса найдется вершина со степенью 1(такая вершина называется листом). Будем удалять ребра графа по очереди и поддерживать актуальные значения (degreev, sv), до тех пор пока он не станет пустым. Для этого будем поддерживать очередь(или стек) вершин являющихся листьями. На очередной итерации мы достаем вершину v из очереди, и удаляем ребро (v, sv), для этого делаем degreesv -= 1 и ssv ^= v. Если у вершины sv степень стала равной 1, то добавим ее в очередь.Необходимо обработать случай, когда мы достаем вершину v из очереди и у нее degreev = 0, тогда стоит проигнорировать это, так как мы уже удалили нужное ребро.Асимптотика: O(n)504B - Миша и сложение перестановокДля решения данной задачи необходимо научиться находить порядковый номер данной перестановки и перестановку по данному порядковому номеру. Так порядковые номера имеют достаточно большую длину, будем хранить их в факториальной системе счисления. То есть число x будем представлять как .Чтобы найти порядковый номер перестановки, заменим каждое число в перестановке на количество чисел стоящих правее и меньше его. Таким образом мы получим число, записанное в факториальной системе счисления.Чтобы получить по порядковому номеру перестановку необходимо провести обратную процедуру, для этого потребуется находить k-тое по величине число в множестве, и добавлять элемент в множество. В обоих случаях нам пригодится дерево отрезков, которое позволяет отвечать на запросы такого вида.В итоге получаем, что нам необходимо получить индексы перестановок, сложить их в факториальной системе счисления по модулю n!, и провести обратное преобразование. Для лучшего понимания ознакомьтесь с wiki и/или любым прошедшим решением.Асимптотика: или .504C - Миша и палиндромностьЗаметим, что если количество элементов, встречающихся нечетное число раз, больше одного — ответ равен нулю. Аналогично, если массив изначально является палиндромом — ответ .Будем обрезать с обоих концов палиндрома одинаковые символы, пока это возможно. Пусть при этом мы получили массив b длины m, его первый и последний элементы различны. Нужные нам отрезки [l, r] содержат какой-то префикс или суффикс массива b.Найдем минимальные длины суффикса и префикса. Здесь нужно рассмотреть два случая: переходит ли кратчайший префикс/суффикс за середину массива или нет. Определить минимальные длины можно с помощью бинпоиска или проходом по массиву и поддержанием количества каждого элемента слева и справа от текущего индекса. Обозначим минимальные длины префикса за pref, и суффикса за suf. Тогда ответ .Асимптотика O(n) или .504D - Миша и XORПереведем каждое число в двоичную систему счисления, для одного числа это делается MAXBITS2 c малой константой, если хранить число в системе счисления с основанием 109 или 1018. MAXBITS ≤ 2000.Для решения задачи нам потребуется небольшая модификация алгоритма Гаусса. Будем обрабатывать запросы по одному, проделывать итерацию алгоритма Гаусса, и поддерживать следующую информацию, для бита с индексом i хранить индекс p[i] запроса, или  - 1, если такого запроса нет, у которого этот бит является младшим выставленным после его(запроса) нормировки. Нормировкой я называю, процесс, в котором число приводится к такому виду, что его индекс наименьшего выставленного бита максимален. При нормировке мы можем XOR-ить число с любыми другими числами из запросов с индексами меньше текущего. Также нам понадобится информация о том, с числами из каких запросов мы проXOR-или текущее число чтобы его отнормировать, будем хранить это в битсете x[j], где j-индекс запроса.Итак, обрабатывая очередной запрос v, мы пробегаем по его битам от младшего к старшему. В случае если текущий бит i выставлен, мы пытаемся обнулить его. Если p[i] =  - 1, то обнулить этот бит нельзя и мы заканчиваем обработку этого запроса, иначе XOR-им текущее число с отнормированным числом из запроса p[i], а так же XOR-им x[v] с x[p[i]]. Если после обработки запросов нам удалось обнулить число, тогда ответ на запрос — да, и в битсете x[v] содержится множество индексов являющееся ответом, иначе — нет. Асимптотика решения O(m × MAXBITS × (MAXBITS + m)) с малой константой, засчет битового сжатия.504E - Миша и LCP на деревеПостроим heavy - light декомпозицию дерева и запишем все строки соответствующие heavy-путям идущим вверх и вниз в одну строку T.Обрабатывая очередной запрос разобьем пути (a, b) и (c, d) на части, целиком принадлежащие heavy-путям. Таких частей будет . Заметим, что каждой части пути соответствует некоторая подстрока T.Теперь для ответа на запрос нам необходимо находить наибольший общий префикс двух подстрок в строке. Это можно сделать, найдя суффиксный массив строки T, массив lcp и построить sparsetable на минимумы на нем.Асимтотика: Для лучшего понимания ознакомьтесь с моим решением.P.S. Вместо суффиксного массива можно использовать хэши, сохраняя асимптотику.P.P.S. Решения, использующие двоичный подъем и хэши, отсекались по времени большими тестами.",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/15743",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.6,
            "reason": "宽松匹配: 包含题目编号 501 和字母"
          },
          "content_length": 6068
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #285 - Codeforces - Code 1",
          "code": "#include <iostream>\nusing namespace std;\n\nint main ()\n{\n        cout << \"Happy Birthday Mike ! \\\\:D/\" << endl << \"Thanks For Everything !!! :D\" << endl;\n        return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/15725",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #285 - Codeforces - Code 2",
          "code": "#include <iostream>\nusing namespace std;\n\nint main ()\n{\n        cout << \"Happy Birthday Mike ! \\\\:D/\" << endl << \"Thanks For Everything !!! :D\" << endl;\n        return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/15725",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #285 - Codeforces - Code 3",
          "code": "math.factorial(x)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15725",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #285 - Codeforces - Code 4",
          "code": "math.factorial(200000)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15725",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #285 - Codeforces - Code 5",
          "code": "i = 1\nj = 1\nwhile(i <= n) {\n while(i > j || !is_it_a_good_range(i,j)) {\n  ++j;\n  update_set_with_bad_numbers(j);\n  update_set_with_bad_numbers(n+1-j);\n }\n update_set_with_bad_numbers(i);\n update_set_with_bad_numbers(n+1-i);\n ++i;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15725",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #285 - Codeforces - Code 6",
          "code": "i = 1\nj = 1\nwhile(i <= n) {\n while(i > j || !is_it_a_good_range(i,j)) {\n  ++j;\n  update_set_with_bad_numbers(j);\n  update_set_with_bad_numbers(n+1-j);\n }\n update_set_with_bad_numbers(i);\n update_set_with_bad_numbers(n+1-i);\n ++i;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15725",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #285 - Codeforces - Code 7",
          "code": "BigInteger x = new BigInteger(in.next());\nx.testBit(j);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15725",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #285 - Codeforces - Code 8",
          "code": "BigInteger x = new BigInteger(in.next());\nx.testBit(j);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15725",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #285 - Codeforces - Code 9",
          "code": "set<int>::iterator it = s.lower_bound(x);\ns.erase(it);\nupd(*it);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15725",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #285 - Codeforces - Code 10",
          "code": "set<int>::iterator it = s.lower_bound(x);\ns.erase(it);\nupd(*it);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15725",
          "author": "Qingyu"
        },
        {
          "title": "Разбор задач Codeforces Round #285 - Codeforces - Code 1",
          "code": "P.P.S. Решения, использующие двоичный подъем и хэши, отсекались по времени большими тестами.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15743",
          "author": "Qingyu"
        },
        {
          "title": "Разбор задач Codeforces Round #285 - Codeforces - Code 2",
          "code": "P.P.S. Решения, использующие двоичный подъем и хэши, отсекались по времени большими тестами.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15743",
          "author": "Qingyu"
        },
        {
          "title": "Разбор задач Codeforces Round #285 - Codeforces - Code 1",
          "code": "P.P.S. Решения, использующие двоичный подъем и хэши, отсекались по времени большими тестами.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15743",
          "author": "Qingyu"
        },
        {
          "title": "Разбор задач Codeforces Round #285 - Codeforces - Code 2",
          "code": "P.P.S. Решения, использующие двоичный подъем и хэши, отсекались по времени большими тестами.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15743",
          "author": "Qingyu"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n    vector<int> a = inf.readInts(n, 1, n, \"a_i\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n    vector<int> a = inf.readInts(n, 1, n, \"a_i\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n    vector<int> a = inf.readInts(n, 1, n, \"a_i\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n    vector<int> a(n);\n    if (type == \"all_same\") {\n        // All elements are the same\n        int val = rnd.next(1, n);\n        for(int i = 0; i < n; ++i)\n            a[i] = val;\n    } else if (type == \"all_distinct\") {\n        // All elements are distinct\n        iota(a.begin(), a.end(), 1);\n        shuffle(a.begin(), a.end());\n    } else if (type == \"palindrome\") {\n        // Generate a palindrome\n        for(int i = 0; i < (n+1)/2; ++i) {\n            int val = rnd.next(1, n);\n            a[i] = val;\n            a[n - i - 1] = val;\n        }\n    } else if (type == \"almost_palindrome\") {\n        // Generate a palindrome and change one element\n        for(int i = 0; i < (n+1)/2; ++i) {\n            int val = rnd.next(1, n);\n            a[i] = val;\n            a[n - i - 1] = val;\n        }\n        // Change one element\n        int pos = rnd.next(0, n - 1);\n        int old_val = a[pos];\n        int new_val = rnd.next(1, n);\n        while (new_val == old_val)\n            new_val = rnd.next(1, n);\n        a[pos] = new_val;\n    } else if (type == \"random_large\") {\n        // Random elements in [1, n]\n        for(int i = 0; i < n; ++i)\n            a[i] = rnd.next(1, n);\n    } else if (type == \"random_small\") {\n        // Random elements in [1, k]\n        int k = opt<int>(\"k\", 5);\n        for(int i = 0; i < n; ++i)\n            a[i] = rnd.next(1, k);\n    } else if (type == \"alternate\") {\n        // Alternate between two values\n        int val1 = rnd.next(1, n);\n        int val2 = rnd.next(1, n);\n        while (val2 == val1)\n            val2 = rnd.next(1, n);\n        for(int i = 0; i < n; ++i)\n            a[i] = (i % 2 == 0) ? val1 : val2;\n    } else {\n        // Random elements in [1, n]\n        for(int i = 0; i < n; ++i)\n            a[i] = rnd.next(1, n);\n    }\n    // Output\n    printf(\"%d\\n\", n);\n    for(int i = 0; i < n; ++i)\n        printf(\"%d%c\", a[i], i == n - 1 ? '\\n' : ' ');\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n    vector<int> a(n);\n    if (type == \"all_same\") {\n        // All elements are the same\n        int val = rnd.next(1, n);\n        for(int i = 0; i < n; ++i)\n            a[i] = val;\n    } else if (type == \"all_distinct\") {\n        // All elements are distinct\n        iota(a.begin(), a.end(), 1);\n        shuffle(a.begin(), a.end());\n    } else if (type == \"palindrome\") {\n        // Generate a palindrome\n        for(int i = 0; i < (n+1)/2; ++i) {\n            int val = rnd.next(1, n);\n            a[i] = val;\n            a[n - i - 1] = val;\n        }\n    } else if (type == \"almost_palindrome\") {\n        // Generate a palindrome and change one element\n        for(int i = 0; i < (n+1)/2; ++i) {\n            int val = rnd.next(1, n);\n            a[i] = val;\n            a[n - i - 1] = val;\n        }\n        // Change one element\n        int pos = rnd.next(0, n - 1);\n        int old_val = a[pos];\n        int new_val = rnd.next(1, n);\n        while (new_val == old_val)\n            new_val = rnd.next(1, n);\n        a[pos] = new_val;\n    } else if (type == \"random_large\") {\n        // Random elements in [1, n]\n        for(int i = 0; i < n; ++i)\n            a[i] = rnd.next(1, n);\n    } else if (type == \"random_small\") {\n        // Random elements in [1, k]\n        int k = opt<int>(\"k\", 5);\n        for(int i = 0; i < n; ++i)\n            a[i] = rnd.next(1, k);\n    } else if (type == \"alternate\") {\n        // Alternate between two values\n        int val1 = rnd.next(1, n);\n        int val2 = rnd.next(1, n);\n        while (val2 == val1)\n            val2 = rnd.next(1, n);\n        for(int i = 0; i < n; ++i)\n            a[i] = (i % 2 == 0) ? val1 : val2;\n    } else {\n        // Random elements in [1, n]\n        for(int i = 0; i < n; ++i)\n            a[i] = rnd.next(1, n);\n    }\n    // Output\n    printf(\"%d\\n\", n);\n    for(int i = 0; i < n; ++i)\n        printf(\"%d%c\", a[i], i == n - 1 ? '\\n' : ' ');\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -type all_same\n./gen -n 1 -type all_distinct\n./gen -n 1 -type palindrome\n./gen -n 2 -type palindrome\n./gen -n 2 -type random_small -k 2\n\n./gen -n 10 -type palindrome\n./gen -n 10 -type almost_palindrome\n./gen -n 10 -type random_small -k 2\n./gen -n 10 -type random_small -k 5\n\n./gen -n 1000 -type random_large\n./gen -n 1000 -type palindrome\n./gen -n 1000 -type almost_palindrome\n\n./gen -n 50000 -type palindrome\n./gen -n 50000 -type random_small -k 2\n./gen -n 50000 -type random_large\n\n./gen -n 100000 -type random_large\n./gen -n 100000 -type palindrome\n./gen -n 100000 -type almost_palindrome\n./gen -n 100000 -type all_same\n./gen -n 100000 -type all_distinct\n\n./gen -n 100000 -type alternate\n./gen -n 99999 -type palindrome\n./gen -n 99998 -type almost_palindrome\n./gen -n 100000 -type random_small -k 1\n./gen -n 100000 -type random_small -k 2\n\n./gen -n 100000\n./gen -n 100000 -type random_large\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:40:21.786526",
        "total_tutorials": 3,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "504/A",
      "title": "A. Миша и лес",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест1 секунда",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеВ первой строке находится целое число n (1 ≤ n ≤ 216), количество вершин в графе. В i-й из последующих строк находятся числа degreei и si (0 ≤ degreei ≤ n - 1, 0 ≤ si < 216), разделенные пробелом.",
      "output_spec": "Выходные данныеВ первой строке выведите число m, количество ребер графа.Далее выведите m строк, каждая из которых содержит два различных числа a и b (0 ≤ a ≤ n - 1, 0 ≤ b ≤ n - 1), соответствующие ребру (a, b).Рёбра могут быть выведены в любом порядке; вершины одного ребра также могут быть выведены в любом порядке.",
      "sample_tests": "ПримерыВходные данныеСкопировать32 31 01 0Выходные данныеСкопировать21 02 0Входные данныеСкопировать21 11 0Выходные данныеСкопировать10 1",
      "description": "A. Миша и лес\n\nограничение по времени на тест1 секунда\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвыводstdout\n\nВходные данныеВ первой строке находится целое число n (1 ≤ n ≤ 216), количество вершин в графе. В i-й из последующих строк находятся числа degreei и si (0 ≤ degreei ≤ n - 1, 0 ≤ si < 216), разделенные пробелом.\n\nВходные данные\n\nВыходные данныеВ первой строке выведите число m, количество ребер графа.Далее выведите m строк, каждая из которых содержит два различных числа a и b (0 ≤ a ≤ n - 1, 0 ≤ b ≤ n - 1), соответствующие ребру (a, b).Рёбра могут быть выведены в любом порядке; вершины одного ребра также могут быть выведены в любом порядке.\n\nВыходные данные\n\nВходные данныеСкопировать32 31 01 0Выходные данныеСкопировать21 02 0Входные данныеСкопировать21 11 0Выходные данныеСкопировать10 1\n\nВходные данныеСкопировать32 31 01 0\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать21 02 0\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать21 11 0\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать10 1\n\nВыходные данныеСкопировать\n\nСкопировать\n\nПримечаниеXOR-суммой чисел называется результат побитового сложения чисел по модулю 2. Данная операция существует во многих современных языках программирования, например, в языках C++, Java и Python она обозначается как «^», а в Pascal — как «xor».",
      "solutions": [
        {
          "title": "Codeforces Round #285 - Codeforces",
          "content": "Привет, Codeforces!12 января в 12.00 MSK пройдет очередной 285-й раунд Codeforces. Автором задач являюсь я(Савинов Евгений). Это мой первый раунд на Codeforces и, надеюсь, не последний.Хочу поблагодарить Сергея Кияна(sokian) и Александра Голованова(Golovanov399) за помощь в подготовке и прорешивании задач, Макса Ахмедова(Zlobober) за неоценимую помощь в подготовке контеста, Алекса Фетисова(AlexFetisov) за прорешивание раунда, Марию Белову(Delinur) за перевод условий на английский язык и, конечно же, Михаила Мирзаянова(MikeMirzayanov) за замечательные системы Codeforces и Polygon.Кстати, сегодня(11 января) у Михаила Расиховича день рождения, давайте поздравим его с этим!Раунд состоится в обоих дивизионах. Информация о разбалловке будет опубликована перед началом раунда.UPD1: Будет использоваться динамическая разбалловка. Задачи расположены в порядке возрастания предполагаемой сложности.UPD2: Разбор задач можно найти здесь.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/15725",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 935
        },
        {
          "title": "Разбор задач Codeforces Round #285 - Codeforces",
          "content": "501A - КонтестВ этой задаче требовалось сделать то, что написано в условии. Считать числа и определить у кого из ребят больше баллов.Асимптотика: O(1).501B - Миша и смена хэндловДля начала немного переформулируем задачу. Был дан ориентированный граф, вершинами которого являются хэндлы пользователей, а ребрами запросы изменения хэндлов. Он состоит из некоторого количества цепочек, нужно было найти их количество, начальные и конечные вершины каждой цепочки. То есть у каждой вершины входящая и исходящая степень не превосходит 1. Ввиду последнего ограничения, ребра этого графа можно хранить в словаре(в C++ — std::map\\unoredered_map, Java — TreeMap\\HashMap), где ключом является вершина из которой исходит ребро, а значением — вершина, в которую оно входит.Каждому уникальному пользователю соответствует вершина с нулевой входящей степенью. Из всех таких вершин нужно переходить по ребру, до тех пор, пока существует переход. Чтобы найти вершины с нулевой степенью, запомним вершины в которые входит ребро, и добавим их в множество(в C++ — std::set\\unoredered_set, Java — TreeSet\\HashSet).Асимптотика: .504A - Миша и лесЗаметим, что у непустого леса найдется вершина со степенью 1(такая вершина называется листом). Будем удалять ребра графа по очереди и поддерживать актуальные значения (degreev, sv), до тех пор пока он не станет пустым. Для этого будем поддерживать очередь(или стек) вершин являющихся листьями. На очередной итерации мы достаем вершину v из очереди, и удаляем ребро (v, sv), для этого делаем degreesv -= 1 и ssv ^= v. Если у вершины sv степень стала равной 1, то добавим ее в очередь.Необходимо обработать случай, когда мы достаем вершину v из очереди и у нее degreev = 0, тогда стоит проигнорировать это, так как мы уже удалили нужное ребро.Асимптотика: O(n)504B - Миша и сложение перестановокДля решения данной задачи необходимо научиться находить порядковый номер данной перестановки и перестановку по данному порядковому номеру. Так порядковые номера имеют достаточно большую длину, будем хранить их в факториальной системе счисления. То есть число x будем представлять как .Чтобы найти порядковый номер перестановки, заменим каждое число в перестановке на количество чисел стоящих правее и меньше его. Таким образом мы получим число, записанное в факториальной системе счисления.Чтобы получить по порядковому номеру перестановку необходимо провести обратную процедуру, для этого потребуется находить k-тое по величине число в множестве, и добавлять элемент в множество. В обоих случаях нам пригодится дерево отрезков, которое позволяет отвечать на запросы такого вида.В итоге получаем, что нам необходимо получить индексы перестановок, сложить их в факториальной системе счисления по модулю n!, и провести обратное преобразование. Для лучшего понимания ознакомьтесь с wiki и/или любым прошедшим решением.Асимптотика: или .504C - Миша и палиндромностьЗаметим, что если количество элементов, встречающихся нечетное число раз, больше одного — ответ равен нулю. Аналогично, если массив изначально является палиндромом — ответ .Будем обрезать с обоих концов палиндрома одинаковые символы, пока это возможно. Пусть при этом мы получили массив b длины m, его первый и последний элементы различны. Нужные нам отрезки [l, r] содержат какой-то префикс или суффикс массива b.Найдем минимальные длины суффикса и префикса. Здесь нужно рассмотреть два случая: переходит ли кратчайший префикс/суффикс за середину массива или нет. Определить минимальные длины можно с помощью бинпоиска или проходом по массиву и поддержанием количества каждого элемента слева и справа от текущего индекса. Обозначим минимальные длины префикса за pref, и суффикса за suf. Тогда ответ .Асимптотика O(n) или .504D - Миша и XORПереведем каждое число в двоичную систему счисления, для одного числа это делается MAXBITS2 c малой константой, если хранить число в системе счисления с основанием 109 или 1018. MAXBITS ≤ 2000.Для решения задачи нам потребуется небольшая модификация алгоритма Гаусса. Будем обрабатывать запросы по одному, проделывать итерацию алгоритма Гаусса, и поддерживать следующую информацию, для бита с индексом i хранить индекс p[i] запроса, или  - 1, если такого запроса нет, у которого этот бит является младшим выставленным после его(запроса) нормировки. Нормировкой я называю, процесс, в котором число приводится к такому виду, что его индекс наименьшего выставленного бита максимален. При нормировке мы можем XOR-ить число с любыми другими числами из запросов с индексами меньше текущего. Также нам понадобится информация о том, с числами из каких запросов мы проXOR-или текущее число чтобы его отнормировать, будем хранить это в битсете x[j], где j-индекс запроса.Итак, обрабатывая очередной запрос v, мы пробегаем по его битам от младшего к старшему. В случае если текущий бит i выставлен, мы пытаемся обнулить его. Если p[i] =  - 1, то обнулить этот бит нельзя и мы заканчиваем обработку этого запроса, иначе XOR-им текущее число с отнормированным числом из запроса p[i], а так же XOR-им x[v] с x[p[i]]. Если после обработки запросов нам удалось обнулить число, тогда ответ на запрос — да, и в битсете x[v] содержится множество индексов являющееся ответом, иначе — нет. Асимптотика решения O(m × MAXBITS × (MAXBITS + m)) с малой константой, засчет битового сжатия.504E - Миша и LCP на деревеПостроим heavy - light декомпозицию дерева и запишем все строки соответствующие heavy-путям идущим вверх и вниз в одну строку T.Обрабатывая очередной запрос разобьем пути (a, b) и (c, d) на части, целиком принадлежащие heavy-путям. Таких частей будет . Заметим, что каждой части пути соответствует некоторая подстрока T.Теперь для ответа на запрос нам необходимо находить наибольший общий префикс двух подстрок в строке. Это можно сделать, найдя суффиксный массив строки T, массив lcp и построить sparsetable на минимумы на нем.Асимтотика: Для лучшего понимания ознакомьтесь с моим решением.P.S. Вместо суффиксного массива можно использовать хэши, сохраняя асимптотику.P.P.S. Решения, использующие двоичный подъем и хэши, отсекались по времени большими тестами.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/15743",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 504\\s*A"
          },
          "content_length": 6068
        },
        {
          "title": "Разбор задач Codeforces Round #285 - Codeforces",
          "content": "501A - КонтестВ этой задаче требовалось сделать то, что написано в условии. Считать числа и определить у кого из ребят больше баллов.Асимптотика: O(1).501B - Миша и смена хэндловДля начала немного переформулируем задачу. Был дан ориентированный граф, вершинами которого являются хэндлы пользователей, а ребрами запросы изменения хэндлов. Он состоит из некоторого количества цепочек, нужно было найти их количество, начальные и конечные вершины каждой цепочки. То есть у каждой вершины входящая и исходящая степень не превосходит 1. Ввиду последнего ограничения, ребра этого графа можно хранить в словаре(в C++ — std::map\\unoredered_map, Java — TreeMap\\HashMap), где ключом является вершина из которой исходит ребро, а значением — вершина, в которую оно входит.Каждому уникальному пользователю соответствует вершина с нулевой входящей степенью. Из всех таких вершин нужно переходить по ребру, до тех пор, пока существует переход. Чтобы найти вершины с нулевой степенью, запомним вершины в которые входит ребро, и добавим их в множество(в C++ — std::set\\unoredered_set, Java — TreeSet\\HashSet).Асимптотика: .504A - Миша и лесЗаметим, что у непустого леса найдется вершина со степенью 1(такая вершина называется листом). Будем удалять ребра графа по очереди и поддерживать актуальные значения (degreev, sv), до тех пор пока он не станет пустым. Для этого будем поддерживать очередь(или стек) вершин являющихся листьями. На очередной итерации мы достаем вершину v из очереди, и удаляем ребро (v, sv), для этого делаем degreesv -= 1 и ssv ^= v. Если у вершины sv степень стала равной 1, то добавим ее в очередь.Необходимо обработать случай, когда мы достаем вершину v из очереди и у нее degreev = 0, тогда стоит проигнорировать это, так как мы уже удалили нужное ребро.Асимптотика: O(n)504B - Миша и сложение перестановокДля решения данной задачи необходимо научиться находить порядковый номер данной перестановки и перестановку по данному порядковому номеру. Так порядковые номера имеют достаточно большую длину, будем хранить их в факториальной системе счисления. То есть число x будем представлять как .Чтобы найти порядковый номер перестановки, заменим каждое число в перестановке на количество чисел стоящих правее и меньше его. Таким образом мы получим число, записанное в факториальной системе счисления.Чтобы получить по порядковому номеру перестановку необходимо провести обратную процедуру, для этого потребуется находить k-тое по величине число в множестве, и добавлять элемент в множество. В обоих случаях нам пригодится дерево отрезков, которое позволяет отвечать на запросы такого вида.В итоге получаем, что нам необходимо получить индексы перестановок, сложить их в факториальной системе счисления по модулю n!, и провести обратное преобразование. Для лучшего понимания ознакомьтесь с wiki и/или любым прошедшим решением.Асимптотика: или .504C - Миша и палиндромностьЗаметим, что если количество элементов, встречающихся нечетное число раз, больше одного — ответ равен нулю. Аналогично, если массив изначально является палиндромом — ответ .Будем обрезать с обоих концов палиндрома одинаковые символы, пока это возможно. Пусть при этом мы получили массив b длины m, его первый и последний элементы различны. Нужные нам отрезки [l, r] содержат какой-то префикс или суффикс массива b.Найдем минимальные длины суффикса и префикса. Здесь нужно рассмотреть два случая: переходит ли кратчайший префикс/суффикс за середину массива или нет. Определить минимальные длины можно с помощью бинпоиска или проходом по массиву и поддержанием количества каждого элемента слева и справа от текущего индекса. Обозначим минимальные длины префикса за pref, и суффикса за suf. Тогда ответ .Асимптотика O(n) или .504D - Миша и XORПереведем каждое число в двоичную систему счисления, для одного числа это делается MAXBITS2 c малой константой, если хранить число в системе счисления с основанием 109 или 1018. MAXBITS ≤ 2000.Для решения задачи нам потребуется небольшая модификация алгоритма Гаусса. Будем обрабатывать запросы по одному, проделывать итерацию алгоритма Гаусса, и поддерживать следующую информацию, для бита с индексом i хранить индекс p[i] запроса, или  - 1, если такого запроса нет, у которого этот бит является младшим выставленным после его(запроса) нормировки. Нормировкой я называю, процесс, в котором число приводится к такому виду, что его индекс наименьшего выставленного бита максимален. При нормировке мы можем XOR-ить число с любыми другими числами из запросов с индексами меньше текущего. Также нам понадобится информация о том, с числами из каких запросов мы проXOR-или текущее число чтобы его отнормировать, будем хранить это в битсете x[j], где j-индекс запроса.Итак, обрабатывая очередной запрос v, мы пробегаем по его битам от младшего к старшему. В случае если текущий бит i выставлен, мы пытаемся обнулить его. Если p[i] =  - 1, то обнулить этот бит нельзя и мы заканчиваем обработку этого запроса, иначе XOR-им текущее число с отнормированным числом из запроса p[i], а так же XOR-им x[v] с x[p[i]]. Если после обработки запросов нам удалось обнулить число, тогда ответ на запрос — да, и в битсете x[v] содержится множество индексов являющееся ответом, иначе — нет. Асимптотика решения O(m × MAXBITS × (MAXBITS + m)) с малой константой, засчет битового сжатия.504E - Миша и LCP на деревеПостроим heavy - light декомпозицию дерева и запишем все строки соответствующие heavy-путям идущим вверх и вниз в одну строку T.Обрабатывая очередной запрос разобьем пути (a, b) и (c, d) на части, целиком принадлежащие heavy-путям. Таких частей будет . Заметим, что каждой части пути соответствует некоторая подстрока T.Теперь для ответа на запрос нам необходимо находить наибольший общий префикс двух подстрок в строке. Это можно сделать, найдя суффиксный массив строки T, массив lcp и построить sparsetable на минимумы на нем.Асимтотика: Для лучшего понимания ознакомьтесь с моим решением.P.S. Вместо суффиксного массива можно использовать хэши, сохраняя асимптотику.P.P.S. Решения, использующие двоичный подъем и хэши, отсекались по времени большими тестами.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/15743",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 504\\s*A"
          },
          "content_length": 6068
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #285 - Codeforces - Code 1",
          "code": "#include <iostream>\nusing namespace std;\n\nint main ()\n{\n        cout << \"Happy Birthday Mike ! \\\\:D/\" << endl << \"Thanks For Everything !!! :D\" << endl;\n        return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/15725",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #285 - Codeforces - Code 2",
          "code": "#include <iostream>\nusing namespace std;\n\nint main ()\n{\n        cout << \"Happy Birthday Mike ! \\\\:D/\" << endl << \"Thanks For Everything !!! :D\" << endl;\n        return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/15725",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #285 - Codeforces - Code 3",
          "code": "math.factorial(x)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15725",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #285 - Codeforces - Code 4",
          "code": "math.factorial(200000)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15725",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #285 - Codeforces - Code 5",
          "code": "i = 1\nj = 1\nwhile(i <= n) {\n while(i > j || !is_it_a_good_range(i,j)) {\n  ++j;\n  update_set_with_bad_numbers(j);\n  update_set_with_bad_numbers(n+1-j);\n }\n update_set_with_bad_numbers(i);\n update_set_with_bad_numbers(n+1-i);\n ++i;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15725",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #285 - Codeforces - Code 6",
          "code": "i = 1\nj = 1\nwhile(i <= n) {\n while(i > j || !is_it_a_good_range(i,j)) {\n  ++j;\n  update_set_with_bad_numbers(j);\n  update_set_with_bad_numbers(n+1-j);\n }\n update_set_with_bad_numbers(i);\n update_set_with_bad_numbers(n+1-i);\n ++i;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15725",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #285 - Codeforces - Code 7",
          "code": "BigInteger x = new BigInteger(in.next());\nx.testBit(j);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15725",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #285 - Codeforces - Code 8",
          "code": "BigInteger x = new BigInteger(in.next());\nx.testBit(j);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15725",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #285 - Codeforces - Code 9",
          "code": "set<int>::iterator it = s.lower_bound(x);\ns.erase(it);\nupd(*it);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15725",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #285 - Codeforces - Code 10",
          "code": "set<int>::iterator it = s.lower_bound(x);\ns.erase(it);\nupd(*it);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15725",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Codeforces Round #285 - Codeforces - Code 1",
          "code": "P.P.S. Решения, использующие двоичный подъем и хэши, отсекались по времени большими тестами.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15743",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Codeforces Round #285 - Codeforces - Code 2",
          "code": "P.P.S. Решения, использующие двоичный подъем и хэши, отсекались по времени большими тестами.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15743",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Codeforces Round #285 - Codeforces - Code 1",
          "code": "P.P.S. Решения, использующие двоичный подъем и хэши, отсекались по времени большими тестами.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15743",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Codeforces Round #285 - Codeforces - Code 2",
          "code": "P.P.S. Решения, использующие двоичный подъем и хэши, отсекались по времени большими тестами.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15743",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 65536, \"n\");\n    inf.readEoln();\n    for (int i = 0; i < n; i++) {\n        int degree_i = inf.readInt(0, n - 1, \"degree_i\");\n        inf.readSpace();\n        int s_i = inf.readInt(0, 65535, \"s_i\");\n        inf.readEoln();\n    }\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 65536, \"n\");\n    inf.readEoln();\n    for (int i = 0; i < n; i++) {\n        int degree_i = inf.readInt(0, n - 1, \"degree_i\");\n        inf.readSpace();\n        int s_i = inf.readInt(0, 65535, \"s_i\");\n        inf.readEoln();\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 65536, \"n\");\n    inf.readEoln();\n    for (int i = 0; i < n; i++) {\n        int degree_i = inf.readInt(0, n - 1, \"degree_i\");\n        inf.readSpace();\n        int s_i = inf.readInt(0, 65535, \"s_i\");\n        inf.readEoln();\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerTestlibCmd(argc, argv);\n\n    // Read input from inf stream:\n    // n\n    // degrees and s_v values\n    int n = inf.readInt(1, 65536, \"n\"); // 1 ≤ n ≤ 2^16\n\n    vector<int> degree_in(n);\n    vector<int> s_in(n);\n\n    for (int i = 0; i < n; ++i) {\n        degree_in[i] = inf.readInt(0, n - 1, format(\"degree[%d]\", i).c_str());\n        s_in[i] = inf.readInt(0, 65535, format(\"s[%d]\", i).c_str()); // 0 ≤ s_v < 2^16\n    }\n\n    // Read participant's output from ouf.\n    int m = ouf.readInt(0, n - 1, \"m\"); // number of edges, m ≤ n - 1\n\n    // Prepare data structures\n    set< pair<int, int> > edge_set; // to detect loops and multiple edges\n    vector<int> degree_comp(n, 0);\n    vector<int> s_comp(n, 0);\n    vector<int> parent(n);\n    for (int i = 0; i < n; ++i) parent[i] = i;\n\n    function<int(int)> find = [&](int x) {\n        if (parent[x] != x)\n            parent[x] = find(parent[x]);\n        return parent[x];\n    };\n\n    // Read edges and build the graph\n    for (int i = 0; i < m; ++i) {\n        int u = ouf.readInt(0, n - 1, format(\"edge %d u\", i + 1).c_str());\n        int v = ouf.readInt(0, n - 1, format(\"edge %d v\", i + 1).c_str());\n\n        if (u == v) {\n            ouf.quitf(_wa, \"Edge %d forms a loop at vertex %d\", i + 1, u);\n        }\n\n        int a = min(u, v);\n        int b = max(u, v);\n\n        if (edge_set.find({ a, b }) != edge_set.end()) {\n            ouf.quitf(_wa, \"Edge %d duplicates an existing edge between %d and %d\", i + 1, a, b);\n        }\n\n        edge_set.insert({ a, b });\n\n        // Update degrees and s_v\n        degree_comp[u]++;\n        degree_comp[v]++;\n        s_comp[u] ^= v;\n        s_comp[v] ^= u;\n\n        // Union-Find check for cycles\n        int pu = find(u);\n        int pv = find(v);\n\n        if (pu == pv) {\n            ouf.quitf(_wa, \"Cycle detected when adding edge %d between %d and %d\", i + 1, u, v);\n        }\n\n        parent[pu] = pv;\n    }\n\n    // Check degrees and s_v for each vertex\n    for (int i = 0; i < n; ++i) {\n        if (degree_comp[i] != degree_in[i]) {\n            ouf.quitf(_wa, \"Degree of vertex %d does not match: expected %d, found %d\", i, degree_in[i], degree_comp[i]);\n        }\n        if (s_comp[i] != s_in[i]) {\n            ouf.quitf(_wa, \"s_v of vertex %d does not match: expected %d, found %d\", i, s_in[i], s_comp[i]);\n        }\n    }\n\n    // All checks passed\n    quitf(_ok, \"The participant's graph is correct\");\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    // Get parameters\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random_tree\"); // default to random_tree\n\n    // Initialize edge list\n    vector<pair<int, int>> edges;\n\n    if (type == \"chain\") {\n        // Generate a chain\n        for (int i = 0; i < n - 1; ++i) {\n            edges.push_back({i, i + 1});\n        }\n    } else if (type == \"star\") {\n        // Generate a star\n        for (int i = 1; i < n; ++i) {\n            edges.push_back({0, i});\n        }\n    } else if (type == \"random_tree\") {\n        // Generate a random tree\n        for (int i = 1; i < n; ++i) {\n            int parent = rnd.next(0, i - 1);\n            edges.push_back({parent, i});\n        }\n    } else if (type == \"random_forest\") {\n        // Generate a random forest with random number of components\n        int k = rnd.next(1, n); // Number of components\n        // Distribute nodes into k components\n        vector<int> nodes(n);\n        for (int i = 0; i < n; ++i) nodes[i] = i;\n        shuffle(nodes.begin(), nodes.end());\n\n        int idx = 0;\n        for (int comp = 0; comp < k; ++comp) {\n            int comp_size;\n            if (comp == k - 1) {\n                comp_size = n - idx;\n            } else {\n                comp_size = rnd.next(1, n - idx - (k - comp - 1));\n            }\n\n            if (comp_size >= 2) {\n                // Generate a tree with comp_size nodes\n                int base = idx;\n                for (int i = 1; i < comp_size; ++i) {\n                    int u = nodes[base + i];\n                    int v = nodes[base + rnd.next(0, i - 1)];\n                    edges.push_back({u, v});\n                }\n            }\n            idx += comp_size;\n        }\n    } else if (type == \"isolated\") {\n        // No edges\n        // Edges vector remains empty\n    } else if (type == \"bushy_tree\") {\n        // Generate a tree with high degree nodes\n        int branch_factor = 1000; // Arbitrary large degree\n        int idx = 0;\n        queue<int> q;\n        q.push(idx++);\n        while (idx < n) {\n            int u = q.front(); q.pop();\n            int children = min(branch_factor, n - idx);\n            for (int i = 0; i < children; ++i) {\n                edges.push_back({u, idx});\n                q.push(idx++);\n            }\n        }\n    } else if (type == \"binary_tree\") {\n        // Generate a complete binary tree\n        for (int i = 1; i < n; ++i) {\n            int parent = (i - 1) / 2;\n            edges.push_back({parent, i});\n        }\n    } else {\n        // Default to random tree\n        for (int i = 1; i < n; ++i) {\n            int parent = rnd.next(0, i - 1);\n            edges.push_back({parent, i});\n        }\n    }\n\n    // Now compute degrees and s_i\n    vector<int> degree(n, 0);\n    vector<int> s(n, 0);\n\n    for (auto e : edges) {\n        int u = e.first;\n        int v = e.second;\n        degree[u]++;\n        degree[v]++;\n        s[u] ^= v;\n        s[v] ^= u;\n    }\n\n    // Output n\n    printf(\"%d\\n\", n);\n    // Output degrees and s_i\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d %d\\n\", degree[i], s[i]);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    // Get parameters\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random_tree\"); // default to random_tree\n\n    // Initialize edge list\n    vector<pair<int, int>> edges;\n\n    if (type == \"chain\") {\n        // Generate a chain\n        for (int i = 0; i < n - 1; ++i) {\n            edges.push_back({i, i + 1});\n        }\n    } else if (type == \"star\") {\n        // Generate a star\n        for (int i = 1; i < n; ++i) {\n            edges.push_back({0, i});\n        }\n    } else if (type == \"random_tree\") {\n        // Generate a random tree\n        for (int i = 1; i < n; ++i) {\n            int parent = rnd.next(0, i - 1);\n            edges.push_back({parent, i});\n        }\n    } else if (type == \"random_forest\") {\n        // Generate a random forest with random number of components\n        int k = rnd.next(1, n); // Number of components\n        // Distribute nodes into k components\n        vector<int> nodes(n);\n        for (int i = 0; i < n; ++i) nodes[i] = i;\n        shuffle(nodes.begin(), nodes.end());\n\n        int idx = 0;\n        for (int comp = 0; comp < k; ++comp) {\n            int comp_size;\n            if (comp == k - 1) {\n                comp_size = n - idx;\n            } else {\n                comp_size = rnd.next(1, n - idx - (k - comp - 1));\n            }\n\n            if (comp_size >= 2) {\n                // Generate a tree with comp_size nodes\n                int base = idx;\n                for (int i = 1; i < comp_size; ++i) {\n                    int u = nodes[base + i];\n                    int v = nodes[base + rnd.next(0, i - 1)];\n                    edges.push_back({u, v});\n                }\n            }\n            idx += comp_size;\n        }\n    } else if (type == \"isolated\") {\n        // No edges\n        // Edges vector remains empty\n    } else if (type == \"bushy_tree\") {\n        // Generate a tree with high degree nodes\n        int branch_factor = 1000; // Arbitrary large degree\n        int idx = 0;\n        queue<int> q;\n        q.push(idx++);\n        while (idx < n) {\n            int u = q.front(); q.pop();\n            int children = min(branch_factor, n - idx);\n            for (int i = 0; i < children; ++i) {\n                edges.push_back({u, idx});\n                q.push(idx++);\n            }\n        }\n    } else if (type == \"binary_tree\") {\n        // Generate a complete binary tree\n        for (int i = 1; i < n; ++i) {\n            int parent = (i - 1) / 2;\n            edges.push_back({parent, i});\n        }\n    } else {\n        // Default to random tree\n        for (int i = 1; i < n; ++i) {\n            int parent = rnd.next(0, i - 1);\n            edges.push_back({parent, i});\n        }\n    }\n\n    // Now compute degrees and s_i\n    vector<int> degree(n, 0);\n    vector<int> s(n, 0);\n\n    for (auto e : edges) {\n        int u = e.first;\n        int v = e.second;\n        degree[u]++;\n        degree[v]++;\n        s[u] ^= v;\n        s[v] ^= u;\n    }\n\n    // Output n\n    printf(\"%d\\n\", n);\n    // Output degrees and s_i\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d %d\\n\", degree[i], s[i]);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -type isolated\n./gen -n 2 -type chain\n./gen -n 2 -type star\n./gen -n 2 -type isolated\n./gen -n 3 -type chain\n./gen -n 3 -type star\n./gen -n 3 -type isolated\n./gen -n 5 -type chain\n./gen -n 5 -type star\n./gen -n 5 -type random_tree\n./gen -n 10 -type chain\n./gen -n 10 -type star\n./gen -n 10 -type random_tree\n./gen -n 10 -type random_forest\n./gen -n 10 -type binary_tree\n./gen -n 100 -type chain\n./gen -n 100 -type star\n./gen -n 100 -type random_tree\n./gen -n 100 -type random_forest\n./gen -n 100 -type bushy_tree\n./gen -n 1000 -type chain\n./gen -n 1000 -type star\n./gen -n 1000 -type random_tree\n./gen -n 1000 -type random_forest\n./gen -n 1000 -type bushy_tree\n./gen -n 10000 -type chain\n./gen -n 10000 -type random_tree\n./gen -n 10000 -type random_forest\n./gen -n 10000 -type binary_tree\n./gen -n 65536 -type random_tree\n./gen -n 65536 -type random_forest\n./gen -n 65536 -type isolated\n./gen -n 65536 -type bushy_tree\n./gen -n 65536 -type binary_tree\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:40:24.147442",
        "total_tutorials": 3,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "504/B",
      "title": "B. Misha and Permutations Summation",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains an integer n (1 ≤ n ≤ 200 000).The second line contains n distinct integers from 0 to n - 1, separated by a space, forming permutation p.The third line contains n distinct integers from 0 to n - 1, separated by spaces, forming permutation q.",
      "output_spec": "OutputPrint n distinct integers from 0 to n - 1, forming the sum of the given permutations. Separate the numbers by spaces.",
      "sample_tests": "ExamplesInputCopy20 10 1OutputCopy0 1InputCopy20 11 0OutputCopy1 0InputCopy31 2 02 1 0OutputCopy1 0 2",
      "description": "B. Misha and Permutations Summation\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains an integer n (1 ≤ n ≤ 200 000).The second line contains n distinct integers from 0 to n - 1, separated by a space, forming permutation p.The third line contains n distinct integers from 0 to n - 1, separated by spaces, forming permutation q.\n\nOutputPrint n distinct integers from 0 to n - 1, forming the sum of the given permutations. Separate the numbers by spaces.\n\nInputCopy20 10 1OutputCopy0 1InputCopy20 11 0OutputCopy1 0InputCopy31 2 02 1 0OutputCopy1 0 2\n\nInputCopy20 10 1\n\nOutputCopy0 1\n\nInputCopy20 11 0\n\nOutputCopy1 0\n\nInputCopy31 2 02 1 0\n\nOutputCopy1 0 2\n\nNotePermutations of numbers from 0 to 1 in the lexicographical order: (0, 1), (1, 0).In the first sample Ord(p) = 0 and Ord(q) = 0, so the answer is .In the second sample Ord(p) = 0 and Ord(q) = 1, so the answer is .Permutations of numbers from 0 to 2 in the lexicographical order: (0, 1, 2), (0, 2, 1), (1, 0, 2), (1, 2, 0), (2, 0, 1), (2, 1, 0).In the third sample Ord(p) = 3 and Ord(q) = 5, so the answer is .",
      "solutions": [
        {
          "title": "Codeforces Round #285 - Codeforces",
          "content": "Hi, Codeforces!Codeforces Round #285 will be held at 12 January, 12.00 MSK. Problems are authored by me, Evgeny Savinov. This is my first round at Codeforces. I hope that this isn't the last one.I want to thank sokian and Golovanov399 for help in preparing and testing round, Zlobober for invaluable help in preparing round, AlexFetisov for testing round, Delinur for translating problem statements in English, and of course, MikeMirzayanov for great systems Codeforces and Polygon.By the way, today(11 January) is MikeMirzayanov's birthday. Happy birthday, Mike!The round will be for both divisions. Information about score distribution will be posted just before the round starts.UPD1: Scoring system will be dynamic. Problems will be arranged in ascending expected difficulty order.UPD2: The editorial can be found here. I'm sorry for the delay.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/15725",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 848
        },
        {
          "title": "Codeforces Round #285 Editorial - Codeforces",
          "content": "501A - ContestIn this problem one need to determine the number of points for both guys and find out who got more points.Time complexity: O(1).501B - Misha and Changing HandlesThe problem can be formulated as follows: The directed graph is given, its vertices correspond to users' handles and edges — to requests. It consists of a number of chains, so every vertex ingoing and outgoing degree doesn't exceed one. One need to find number of chains and first and last vertices of every chain. The arcs of this graph can be stored in dictionary(one can use std::map\\unoredered_map in C++ and TreeMap\\HashMap in Java) with head of the arc as the key and the tail as the value.Each zero ingoing degree vertex corresponds to unique user as well as first vertex of some chain. We should iterate from such vertices through the arcs while it's possible. Thus we find relation between first and last vertices in the chain as well as relation between the original and the new handle of some user.You can see my solution for details.Time complexity: .504A - Misha and ForestNote that every non-empty forest has a leaf(vertex of degree 1). Let's remove edges one by one and maintain actual values (degreev, sv) as long as graph is not empty. To do so, we can maintain the queue(or stack) of the leaves. On every iteration we dequeue vertex v and remove edge (v, sv) and update values for vertex sv: degreesv -= 1 and ssv ^= v. If degree of vertex sv becomes equal to 1, we enqueue it.When dequeued vertex has zero degree, just ignore it because we have already removed all edges of corresponding tree.You can see my solution for details.Time complexity: O(n)504B - Misha and Permutations SummationTo solve the problem, one need to be able to find the index of given permutation in lexicographical order and permutation by its index. We will store indices in factorial number system. Thus number x is represented as . You can find the rules of the transform here.To make the transform, you may need to use data structures such as binary search tree or binary indexed tree (for maintaining queries of finding k-th number in the set and finding the amount of numbers less than given one).So, one need to get indices of the permutations, to sum them modulo n! and make inverse transform. You can read any accepted solution for better understanding.Time complexity: or .504C - Misha and Palindrome DegreeNote that if the amount of elements, which number of occurrences is odd, is greater than one, the answer is zero. On the other hand, if array is the palindrome, answer is .Let's cut equal elements from the end and the beginning of array while it is possible. Let's call remaining array as b and its length as m. We are interested in segments [l, r] which cover some prefix or suffix of b.We need to find the minimum length of such prefix and suffix. Prefix and suffix can overlap the middle of b and these cases are needed to maintain. To find minimum length you can use binary search or simply iterating over array and storing the amount of every element to the left and right from the current index. Let's call minimum length of prefix as pref and as suf of suffix. So .Time complexity: O(n) or .504D - Misha and XORFirstly, we convert each number into a binary system: it can be done in O(MAXBITS2), where MAXBITS ≤ 2000 with rather small constant(we store number in system with big radix).To solve the problem we need to modify Gauss elimination algorithm. For each row we should store set of row's indices which we already XORed this row to get row echelon form (we can store it in bitset), also for each bit i we store index p[i] of row, which lowest set bit is i in row echelon form.Maintaining the query we try to reset bits from lowest to highest using array p and save information, which rows were XORed with current number. If we can reset whole number, the answer is positive and we know indices of answer. We update array p, otherwise.Time complexity: O(m × MAXBITS × (MAXBITS + m)) with small constant due to bit compression.504E - Misha and LCP on TreeLet's build heavy-light decomposition of given tree and write all strings corresponding to heavy paths one by one in one string T, every path should be written twice: in the direct and reverse order.Maintaining query we can split paths (a, b) и (c, d) into parts, which completely belongs to some heavy paths. There can be at most such parts. Note that every part corresponds to some substring of T.Now we only need to find longest common prefix of two substrings in string T. It can be done building suffix array of string T and lcp array. So, we can find longest common prefix of two substring in O(1) constructing rmq sparse table on lcp array.Time complexity: For the better understanding see my solution.P.S. One can uses hashes instead of suffix array.ADD: There is another approach to solve this problem in but it's rather slow in practice. We can do binary search on answer and use hashes, but we do it for all queries at one time. The only problem is to find k-th vertex on the path, we can do it offline for all queries in O(n + m) time. We run dfs and maintain stack of vertices. See my solution for details.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/15743",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 504\\s*B"
          },
          "content_length": 5171
        },
        {
          "title": "Codeforces Round #285 Editorial - Codeforces",
          "content": "501A - ContestIn this problem one need to determine the number of points for both guys and find out who got more points.Time complexity: O(1).501B - Misha and Changing HandlesThe problem can be formulated as follows: The directed graph is given, its vertices correspond to users' handles and edges — to requests. It consists of a number of chains, so every vertex ingoing and outgoing degree doesn't exceed one. One need to find number of chains and first and last vertices of every chain. The arcs of this graph can be stored in dictionary(one can use std::map\\unoredered_map in C++ and TreeMap\\HashMap in Java) with head of the arc as the key and the tail as the value.Each zero ingoing degree vertex corresponds to unique user as well as first vertex of some chain. We should iterate from such vertices through the arcs while it's possible. Thus we find relation between first and last vertices in the chain as well as relation between the original and the new handle of some user.You can see my solution for details.Time complexity: .504A - Misha and ForestNote that every non-empty forest has a leaf(vertex of degree 1). Let's remove edges one by one and maintain actual values (degreev, sv) as long as graph is not empty. To do so, we can maintain the queue(or stack) of the leaves. On every iteration we dequeue vertex v and remove edge (v, sv) and update values for vertex sv: degreesv -= 1 and ssv ^= v. If degree of vertex sv becomes equal to 1, we enqueue it.When dequeued vertex has zero degree, just ignore it because we have already removed all edges of corresponding tree.You can see my solution for details.Time complexity: O(n)504B - Misha and Permutations SummationTo solve the problem, one need to be able to find the index of given permutation in lexicographical order and permutation by its index. We will store indices in factorial number system. Thus number x is represented as . You can find the rules of the transform here.To make the transform, you may need to use data structures such as binary search tree or binary indexed tree (for maintaining queries of finding k-th number in the set and finding the amount of numbers less than given one).So, one need to get indices of the permutations, to sum them modulo n! and make inverse transform. You can read any accepted solution for better understanding.Time complexity: or .504C - Misha and Palindrome DegreeNote that if the amount of elements, which number of occurrences is odd, is greater than one, the answer is zero. On the other hand, if array is the palindrome, answer is .Let's cut equal elements from the end and the beginning of array while it is possible. Let's call remaining array as b and its length as m. We are interested in segments [l, r] which cover some prefix or suffix of b.We need to find the minimum length of such prefix and suffix. Prefix and suffix can overlap the middle of b and these cases are needed to maintain. To find minimum length you can use binary search or simply iterating over array and storing the amount of every element to the left and right from the current index. Let's call minimum length of prefix as pref and as suf of suffix. So .Time complexity: O(n) or .504D - Misha and XORFirstly, we convert each number into a binary system: it can be done in O(MAXBITS2), where MAXBITS ≤ 2000 with rather small constant(we store number in system with big radix).To solve the problem we need to modify Gauss elimination algorithm. For each row we should store set of row's indices which we already XORed this row to get row echelon form (we can store it in bitset), also for each bit i we store index p[i] of row, which lowest set bit is i in row echelon form.Maintaining the query we try to reset bits from lowest to highest using array p and save information, which rows were XORed with current number. If we can reset whole number, the answer is positive and we know indices of answer. We update array p, otherwise.Time complexity: O(m × MAXBITS × (MAXBITS + m)) with small constant due to bit compression.504E - Misha and LCP on TreeLet's build heavy-light decomposition of given tree and write all strings corresponding to heavy paths one by one in one string T, every path should be written twice: in the direct and reverse order.Maintaining query we can split paths (a, b) и (c, d) into parts, which completely belongs to some heavy paths. There can be at most such parts. Note that every part corresponds to some substring of T.Now we only need to find longest common prefix of two substrings in string T. It can be done building suffix array of string T and lcp array. So, we can find longest common prefix of two substring in O(1) constructing rmq sparse table on lcp array.Time complexity: For the better understanding see my solution.P.S. One can uses hashes instead of suffix array.ADD: There is another approach to solve this problem in but it's rather slow in practice. We can do binary search on answer and use hashes, but we do it for all queries at one time. The only problem is to find k-th vertex on the path, we can do it offline for all queries in O(n + m) time. We run dfs and maintain stack of vertices. See my solution for details.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/15743",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 504\\s*B"
          },
          "content_length": 5171
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #285 - Codeforces - Code 1",
          "code": "#include <iostream>\nusing namespace std;\n\nint main ()\n{\n        cout << \"Happy Birthday Mike ! \\\\:D/\" << endl << \"Thanks For Everything !!! :D\" << endl;\n        return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/15725",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #285 - Codeforces - Code 2",
          "code": "#include <iostream>\nusing namespace std;\n\nint main ()\n{\n        cout << \"Happy Birthday Mike ! \\\\:D/\" << endl << \"Thanks For Everything !!! :D\" << endl;\n        return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/15725",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #285 - Codeforces - Code 3",
          "code": "math.factorial(x)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15725",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #285 - Codeforces - Code 4",
          "code": "math.factorial(200000)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15725",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #285 - Codeforces - Code 5",
          "code": "i = 1\nj = 1\nwhile(i <= n) {\n while(i > j || !is_it_a_good_range(i,j)) {\n  ++j;\n  update_set_with_bad_numbers(j);\n  update_set_with_bad_numbers(n+1-j);\n }\n update_set_with_bad_numbers(i);\n update_set_with_bad_numbers(n+1-i);\n ++i;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15725",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #285 - Codeforces - Code 6",
          "code": "i = 1\nj = 1\nwhile(i <= n) {\n while(i > j || !is_it_a_good_range(i,j)) {\n  ++j;\n  update_set_with_bad_numbers(j);\n  update_set_with_bad_numbers(n+1-j);\n }\n update_set_with_bad_numbers(i);\n update_set_with_bad_numbers(n+1-i);\n ++i;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15725",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #285 - Codeforces - Code 7",
          "code": "BigInteger x = new BigInteger(in.next());\nx.testBit(j);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15725",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #285 - Codeforces - Code 8",
          "code": "BigInteger x = new BigInteger(in.next());\nx.testBit(j);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15725",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #285 - Codeforces - Code 9",
          "code": "set<int>::iterator it = s.lower_bound(x);\ns.erase(it);\nupd(*it);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15725",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #285 - Codeforces - Code 10",
          "code": "set<int>::iterator it = s.lower_bound(x);\ns.erase(it);\nupd(*it);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15725",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 200000, \"n\");\n    inf.readEoln();\n\n    vector<int> p = inf.readInts(n, 0, n - 1, \"p\");\n    inf.readEoln();\n    vector<int> cnt_p(n, 0);\n    for (int i = 0; i < n; ++i) {\n        int val = p[i];\n        cnt_p[val]++;\n        ensuref(cnt_p[val] == 1, \"Element %d appears more than once in p\", val);\n    }\n\n    vector<int> q = inf.readInts(n, 0, n - 1, \"q\");\n    inf.readEoln();\n    vector<int> cnt_q(n, 0);\n    for (int i = 0; i < n; ++i) {\n        int val = q[i];\n        cnt_q[val]++;\n        ensuref(cnt_q[val] == 1, \"Element %d appears more than once in q\", val);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 200000, \"n\");\n    inf.readEoln();\n\n    vector<int> p = inf.readInts(n, 0, n - 1, \"p\");\n    inf.readEoln();\n    vector<int> cnt_p(n, 0);\n    for (int i = 0; i < n; ++i) {\n        int val = p[i];\n        cnt_p[val]++;\n        ensuref(cnt_p[val] == 1, \"Element %d appears more than once in p\", val);\n    }\n\n    vector<int> q = inf.readInts(n, 0, n - 1, \"q\");\n    inf.readEoln();\n    vector<int> cnt_q(n, 0);\n    for (int i = 0; i < n; ++i) {\n        int val = q[i];\n        cnt_q[val]++;\n        ensuref(cnt_q[val] == 1, \"Element %d appears more than once in q\", val);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 200000, \"n\");\n    inf.readEoln();\n\n    vector<int> p = inf.readInts(n, 0, n - 1, \"p\");\n    inf.readEoln();\n    vector<int> cnt_p(n, 0);\n    for (int i = 0; i < n; ++i) {\n        int val = p[i];\n        cnt_p[val]++;\n        ensuref(cnt_p[val] == 1, \"Element %d appears more than once in p\", val);\n    }\n\n    vector<int> q = inf.readInts(n, 0, n - 1, \"q\");\n    inf.readEoln();\n    vector<int> cnt_q(n, 0);\n    for (int i = 0; i < n; ++i) {\n        int val = q[i];\n        cnt_q[val]++;\n        ensuref(cnt_q[val] == 1, \"Element %d appears more than once in q\", val);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string t_p = opt<string>(\"t_p\", \"random\");\n    string t_q = opt<string>(\"t_q\", \"random\");\n    int k_p = opt<int>(\"k_p\", 0);\n    int k_q = opt<int>(\"k_q\", 0);\n\n    vector<int> p(n), q(n);\n\n    // Generate permutation p\n    if (t_p == \"identity\") {\n        for (int i = 0; i < n; i++) p[i] = i;\n    } else if (t_p == \"reverse\") {\n        for (int i = 0; i < n; i++) p[i] = n - 1 - i;\n    } else if (t_p == \"random\") {\n        for (int i = 0; i < n; i++) p[i] = i;\n        shuffle(p.begin(), p.end());\n    } else if (t_p == \"shift\") {\n        int k = (k_p % n + n) % n;\n        for (int i = 0; i < n; i++) p[i] = (i + k) % n;\n    } else if (t_p == \"almostsorted\") {\n        for (int i = 0; i < n; i++) p[i] = i;\n        int swaps = min(n, 10);\n        for (int i = 0; i < swaps; i++) {\n            int idx1 = rnd.next(0, n - 1);\n            int idx2 = rnd.next(0, n - 1);\n            swap(p[idx1], p[idx2]);\n        }\n    } else {\n        // Default to random\n        for (int i = 0; i < n; i++) p[i] = i;\n        shuffle(p.begin(), p.end());\n    }\n\n    // Generate permutation q\n    if (t_q == \"same\") {\n        q = p;\n    } else if (t_q == \"opposite\") {\n        for (int i = 0; i < n; i++) q[i] = n - 1 - p[i];\n    } else if (t_q == \"identity\") {\n        for (int i = 0; i < n; i++) q[i] = i;\n    } else if (t_q == \"reverse\") {\n        for (int i = 0; i < n; i++) q[i] = n - 1 - i;\n    } else if (t_q == \"random\") {\n        for (int i = 0; i < n; i++) q[i] = i;\n        shuffle(q.begin(), q.end());\n    } else if (t_q == \"shift\") {\n        int k = (k_q % n + n) % n;\n        for (int i = 0; i < n; i++) q[i] = (i + k) % n;\n    } else if (t_q == \"almostsorted\") {\n        for (int i = 0; i < n; i++) q[i] = i;\n        int swaps = min(n, 10);\n        for (int i = 0; i < swaps; i++) {\n            int idx1 = rnd.next(0, n - 1);\n            int idx2 = rnd.next(0, n - 1);\n            swap(q[idx1], q[idx2]);\n        }\n    } else {\n        // Default to random\n        for (int i = 0; i < n; i++) q[i] = i;\n        shuffle(q.begin(), q.end());\n    }\n\n    // Output n\n    printf(\"%d\\n\", n);\n\n    // Output permutation p\n    for (int i = 0; i < n; i++) {\n        printf(\"%d%c\", p[i], i == n - 1 ? '\\n' : ' ');\n    }\n\n    // Output permutation q\n    for (int i = 0; i < n; i++) {\n        printf(\"%d%c\", q[i], i == n - 1 ? '\\n' : ' ');\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string t_p = opt<string>(\"t_p\", \"random\");\n    string t_q = opt<string>(\"t_q\", \"random\");\n    int k_p = opt<int>(\"k_p\", 0);\n    int k_q = opt<int>(\"k_q\", 0);\n\n    vector<int> p(n), q(n);\n\n    // Generate permutation p\n    if (t_p == \"identity\") {\n        for (int i = 0; i < n; i++) p[i] = i;\n    } else if (t_p == \"reverse\") {\n        for (int i = 0; i < n; i++) p[i] = n - 1 - i;\n    } else if (t_p == \"random\") {\n        for (int i = 0; i < n; i++) p[i] = i;\n        shuffle(p.begin(), p.end());\n    } else if (t_p == \"shift\") {\n        int k = (k_p % n + n) % n;\n        for (int i = 0; i < n; i++) p[i] = (i + k) % n;\n    } else if (t_p == \"almostsorted\") {\n        for (int i = 0; i < n; i++) p[i] = i;\n        int swaps = min(n, 10);\n        for (int i = 0; i < swaps; i++) {\n            int idx1 = rnd.next(0, n - 1);\n            int idx2 = rnd.next(0, n - 1);\n            swap(p[idx1], p[idx2]);\n        }\n    } else {\n        // Default to random\n        for (int i = 0; i < n; i++) p[i] = i;\n        shuffle(p.begin(), p.end());\n    }\n\n    // Generate permutation q\n    if (t_q == \"same\") {\n        q = p;\n    } else if (t_q == \"opposite\") {\n        for (int i = 0; i < n; i++) q[i] = n - 1 - p[i];\n    } else if (t_q == \"identity\") {\n        for (int i = 0; i < n; i++) q[i] = i;\n    } else if (t_q == \"reverse\") {\n        for (int i = 0; i < n; i++) q[i] = n - 1 - i;\n    } else if (t_q == \"random\") {\n        for (int i = 0; i < n; i++) q[i] = i;\n        shuffle(q.begin(), q.end());\n    } else if (t_q == \"shift\") {\n        int k = (k_q % n + n) % n;\n        for (int i = 0; i < n; i++) q[i] = (i + k) % n;\n    } else if (t_q == \"almostsorted\") {\n        for (int i = 0; i < n; i++) q[i] = i;\n        int swaps = min(n, 10);\n        for (int i = 0; i < swaps; i++) {\n            int idx1 = rnd.next(0, n - 1);\n            int idx2 = rnd.next(0, n - 1);\n            swap(q[idx1], q[idx2]);\n        }\n    } else {\n        // Default to random\n        for (int i = 0; i < n; i++) q[i] = i;\n        shuffle(q.begin(), q.end());\n    }\n\n    // Output n\n    printf(\"%d\\n\", n);\n\n    // Output permutation p\n    for (int i = 0; i < n; i++) {\n        printf(\"%d%c\", p[i], i == n - 1 ? '\\n' : ' ');\n    }\n\n    // Output permutation q\n    for (int i = 0; i < n; i++) {\n        printf(\"%d%c\", q[i], i == n - 1 ? '\\n' : ' ');\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Small n\n./gen -n 1 -t_p identity -t_q identity\n./gen -n 1 -t_p identity -t_q reverse\n./gen -n 2 -t_p identity -t_q identity\n./gen -n 2 -t_p reverse -t_q reverse\n./gen -n 2 -t_p random -t_q random\n./gen -n 3 -t_p random -t_q random\n\n# Small n with special permutations\n./gen -n 5 -t_p identity -t_q reverse\n./gen -n 5 -t_p shift -k_p 1 -t_q shift -k_q -1\n./gen -n 5 -t_p almostsorted -t_q almostsorted\n\n# Medium n\n./gen -n 1000 -t_p identity -t_q identity\n./gen -n 1000 -t_p reverse -t_q reverse\n./gen -n 1000 -t_p random -t_q random\n./gen -n 1000 -t_p random -t_q same\n./gen -n 1000 -t_p random -t_q opposite\n\n# Large n\n./gen -n 50000 -t_p random -t_q random\n./gen -n 50000 -t_p identity -t_q reverse\n./gen -n 50000 -t_p shift -k_p 12345 -t_q shift -k_q 54321\n./gen -n 50000 -t_p almostsorted -t_q almostsorted\n\n# Maximum n\n./gen -n 200000 -t_p random -t_q random\n./gen -n 200000 -t_p identity -t_q reverse\n./gen -n 200000 -t_p identity -t_q identity\n./gen -n 200000 -t_p reverse -t_q reverse\n./gen -n 200000 -t_p shift -k_p 99999 -t_q shift -k_q 1\n./gen -n 200000 -t_p almostsorted -t_q almostsorted\n\n# n near maximum\n./gen -n 199999 -t_p random -t_q random\n./gen -n 199998 -t_p random -t_q random\n\n# Edge cases\n./gen -n 2 -t_p identity -t_q reverse\n./gen -n 3 -t_p identity -t_q reverse\n./gen -n 1 -t_p random -t_q random\n\n# Test p = q\n./gen -n 200000 -t_p random -t_q same\n./gen -n 200000 -t_p reverse -t_q same\n./gen -n 200000 -t_p identity -t_q same\n\n# Test q is opposite of p\n./gen -n 200000 -t_p random -t_q opposite\n./gen -n 200000 -t_p identity -t_q opposite\n./gen -n 200000 -t_p reverse -t_q opposite\n\n# Test with shift\n./gen -n 200000 -t_p shift -k_p 123456 -t_q shift -k_q 654321\n\n# Test almost sorted\n./gen -n 200000 -t_p almostsorted -t_q random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:40:25.748366",
        "total_tutorials": 3,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "504/C",
      "title": "C. Misha and Palindrome Degree",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains integer n (1 ≤ n ≤ 105).The second line contains n positive integers a[i] (1 ≤ a[i] ≤ n), separated by spaces — the elements of Misha's array.",
      "output_spec": "OutputIn a single line print the answer to the problem.",
      "sample_tests": "ExamplesInputCopy32 2 2OutputCopy6InputCopy63 6 5 3 3 5OutputCopy0InputCopy55 5 2 5 2OutputCopy4",
      "description": "C. Misha and Palindrome Degree\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains integer n (1 ≤ n ≤ 105).The second line contains n positive integers a[i] (1 ≤ a[i] ≤ n), separated by spaces — the elements of Misha's array.\n\nOutputIn a single line print the answer to the problem.\n\nInputCopy32 2 2OutputCopy6InputCopy63 6 5 3 3 5OutputCopy0InputCopy55 5 2 5 2OutputCopy4\n\nInputCopy32 2 2\n\nOutputCopy6\n\nInputCopy63 6 5 3 3 5\n\nOutputCopy0\n\nInputCopy55 5 2 5 2\n\nOutputCopy4\n\nNoteIn the first sample test any possible pair (l, r) meets the condition.In the third sample test following pairs (1, 3), (1, 4), (1, 5), (2, 5) meet the condition.",
      "solutions": [
        {
          "title": "Codeforces Round #285 - Codeforces",
          "content": "Hi, Codeforces!Codeforces Round #285 will be held at 12 January, 12.00 MSK. Problems are authored by me, Evgeny Savinov. This is my first round at Codeforces. I hope that this isn't the last one.I want to thank sokian and Golovanov399 for help in preparing and testing round, Zlobober for invaluable help in preparing round, AlexFetisov for testing round, Delinur for translating problem statements in English, and of course, MikeMirzayanov for great systems Codeforces and Polygon.By the way, today(11 January) is MikeMirzayanov's birthday. Happy birthday, Mike!The round will be for both divisions. Information about score distribution will be posted just before the round starts.UPD1: Scoring system will be dynamic. Problems will be arranged in ascending expected difficulty order.UPD2: The editorial can be found here. I'm sorry for the delay.",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/15725",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 848
        },
        {
          "title": "Codeforces Round #285 Editorial - Codeforces",
          "content": "501A - ContestIn this problem one need to determine the number of points for both guys and find out who got more points.Time complexity: O(1).501B - Misha and Changing HandlesThe problem can be formulated as follows: The directed graph is given, its vertices correspond to users' handles and edges — to requests. It consists of a number of chains, so every vertex ingoing and outgoing degree doesn't exceed one. One need to find number of chains and first and last vertices of every chain. The arcs of this graph can be stored in dictionary(one can use std::map\\unoredered_map in C++ and TreeMap\\HashMap in Java) with head of the arc as the key and the tail as the value.Each zero ingoing degree vertex corresponds to unique user as well as first vertex of some chain. We should iterate from such vertices through the arcs while it's possible. Thus we find relation between first and last vertices in the chain as well as relation between the original and the new handle of some user.You can see my solution for details.Time complexity: .504A - Misha and ForestNote that every non-empty forest has a leaf(vertex of degree 1). Let's remove edges one by one and maintain actual values (degreev, sv) as long as graph is not empty. To do so, we can maintain the queue(or stack) of the leaves. On every iteration we dequeue vertex v and remove edge (v, sv) and update values for vertex sv: degreesv -= 1 and ssv ^= v. If degree of vertex sv becomes equal to 1, we enqueue it.When dequeued vertex has zero degree, just ignore it because we have already removed all edges of corresponding tree.You can see my solution for details.Time complexity: O(n)504B - Misha and Permutations SummationTo solve the problem, one need to be able to find the index of given permutation in lexicographical order and permutation by its index. We will store indices in factorial number system. Thus number x is represented as . You can find the rules of the transform here.To make the transform, you may need to use data structures such as binary search tree or binary indexed tree (for maintaining queries of finding k-th number in the set and finding the amount of numbers less than given one).So, one need to get indices of the permutations, to sum them modulo n! and make inverse transform. You can read any accepted solution for better understanding.Time complexity: or .504C - Misha and Palindrome DegreeNote that if the amount of elements, which number of occurrences is odd, is greater than one, the answer is zero. On the other hand, if array is the palindrome, answer is .Let's cut equal elements from the end and the beginning of array while it is possible. Let's call remaining array as b and its length as m. We are interested in segments [l, r] which cover some prefix or suffix of b.We need to find the minimum length of such prefix and suffix. Prefix and suffix can overlap the middle of b and these cases are needed to maintain. To find minimum length you can use binary search or simply iterating over array and storing the amount of every element to the left and right from the current index. Let's call minimum length of prefix as pref and as suf of suffix. So .Time complexity: O(n) or .504D - Misha and XORFirstly, we convert each number into a binary system: it can be done in O(MAXBITS2), where MAXBITS ≤ 2000 with rather small constant(we store number in system with big radix).To solve the problem we need to modify Gauss elimination algorithm. For each row we should store set of row's indices which we already XORed this row to get row echelon form (we can store it in bitset), also for each bit i we store index p[i] of row, which lowest set bit is i in row echelon form.Maintaining the query we try to reset bits from lowest to highest using array p and save information, which rows were XORed with current number. If we can reset whole number, the answer is positive and we know indices of answer. We update array p, otherwise.Time complexity: O(m × MAXBITS × (MAXBITS + m)) with small constant due to bit compression.504E - Misha and LCP on TreeLet's build heavy-light decomposition of given tree and write all strings corresponding to heavy paths one by one in one string T, every path should be written twice: in the direct and reverse order.Maintaining query we can split paths (a, b) и (c, d) into parts, which completely belongs to some heavy paths. There can be at most such parts. Note that every part corresponds to some substring of T.Now we only need to find longest common prefix of two substrings in string T. It can be done building suffix array of string T and lcp array. So, we can find longest common prefix of two substring in O(1) constructing rmq sparse table on lcp array.Time complexity: For the better understanding see my solution.P.S. One can uses hashes instead of suffix array.ADD: There is another approach to solve this problem in but it's rather slow in practice. We can do binary search on answer and use hashes, but we do it for all queries at one time. The only problem is to find k-th vertex on the path, we can do it offline for all queries in O(n + m) time. We run dfs and maintain stack of vertices. See my solution for details.",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/15743",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 504\\s*C"
          },
          "content_length": 5171
        },
        {
          "title": "Codeforces Round #285 Editorial - Codeforces",
          "content": "501A - ContestIn this problem one need to determine the number of points for both guys and find out who got more points.Time complexity: O(1).501B - Misha and Changing HandlesThe problem can be formulated as follows: The directed graph is given, its vertices correspond to users' handles and edges — to requests. It consists of a number of chains, so every vertex ingoing and outgoing degree doesn't exceed one. One need to find number of chains and first and last vertices of every chain. The arcs of this graph can be stored in dictionary(one can use std::map\\unoredered_map in C++ and TreeMap\\HashMap in Java) with head of the arc as the key and the tail as the value.Each zero ingoing degree vertex corresponds to unique user as well as first vertex of some chain. We should iterate from such vertices through the arcs while it's possible. Thus we find relation between first and last vertices in the chain as well as relation between the original and the new handle of some user.You can see my solution for details.Time complexity: .504A - Misha and ForestNote that every non-empty forest has a leaf(vertex of degree 1). Let's remove edges one by one and maintain actual values (degreev, sv) as long as graph is not empty. To do so, we can maintain the queue(or stack) of the leaves. On every iteration we dequeue vertex v and remove edge (v, sv) and update values for vertex sv: degreesv -= 1 and ssv ^= v. If degree of vertex sv becomes equal to 1, we enqueue it.When dequeued vertex has zero degree, just ignore it because we have already removed all edges of corresponding tree.You can see my solution for details.Time complexity: O(n)504B - Misha and Permutations SummationTo solve the problem, one need to be able to find the index of given permutation in lexicographical order and permutation by its index. We will store indices in factorial number system. Thus number x is represented as . You can find the rules of the transform here.To make the transform, you may need to use data structures such as binary search tree or binary indexed tree (for maintaining queries of finding k-th number in the set and finding the amount of numbers less than given one).So, one need to get indices of the permutations, to sum them modulo n! and make inverse transform. You can read any accepted solution for better understanding.Time complexity: or .504C - Misha and Palindrome DegreeNote that if the amount of elements, which number of occurrences is odd, is greater than one, the answer is zero. On the other hand, if array is the palindrome, answer is .Let's cut equal elements from the end and the beginning of array while it is possible. Let's call remaining array as b and its length as m. We are interested in segments [l, r] which cover some prefix or suffix of b.We need to find the minimum length of such prefix and suffix. Prefix and suffix can overlap the middle of b and these cases are needed to maintain. To find minimum length you can use binary search or simply iterating over array and storing the amount of every element to the left and right from the current index. Let's call minimum length of prefix as pref and as suf of suffix. So .Time complexity: O(n) or .504D - Misha and XORFirstly, we convert each number into a binary system: it can be done in O(MAXBITS2), where MAXBITS ≤ 2000 with rather small constant(we store number in system with big radix).To solve the problem we need to modify Gauss elimination algorithm. For each row we should store set of row's indices which we already XORed this row to get row echelon form (we can store it in bitset), also for each bit i we store index p[i] of row, which lowest set bit is i in row echelon form.Maintaining the query we try to reset bits from lowest to highest using array p and save information, which rows were XORed with current number. If we can reset whole number, the answer is positive and we know indices of answer. We update array p, otherwise.Time complexity: O(m × MAXBITS × (MAXBITS + m)) with small constant due to bit compression.504E - Misha and LCP on TreeLet's build heavy-light decomposition of given tree and write all strings corresponding to heavy paths one by one in one string T, every path should be written twice: in the direct and reverse order.Maintaining query we can split paths (a, b) и (c, d) into parts, which completely belongs to some heavy paths. There can be at most such parts. Note that every part corresponds to some substring of T.Now we only need to find longest common prefix of two substrings in string T. It can be done building suffix array of string T and lcp array. So, we can find longest common prefix of two substring in O(1) constructing rmq sparse table on lcp array.Time complexity: For the better understanding see my solution.P.S. One can uses hashes instead of suffix array.ADD: There is another approach to solve this problem in but it's rather slow in practice. We can do binary search on answer and use hashes, but we do it for all queries at one time. The only problem is to find k-th vertex on the path, we can do it offline for all queries in O(n + m) time. We run dfs and maintain stack of vertices. See my solution for details.",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/15743",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 504\\s*C"
          },
          "content_length": 5171
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #285 - Codeforces - Code 1",
          "code": "#include <iostream>\nusing namespace std;\n\nint main ()\n{\n        cout << \"Happy Birthday Mike ! \\\\:D/\" << endl << \"Thanks For Everything !!! :D\" << endl;\n        return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/15725",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #285 - Codeforces - Code 2",
          "code": "#include <iostream>\nusing namespace std;\n\nint main ()\n{\n        cout << \"Happy Birthday Mike ! \\\\:D/\" << endl << \"Thanks For Everything !!! :D\" << endl;\n        return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/15725",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #285 - Codeforces - Code 3",
          "code": "math.factorial(x)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15725",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #285 - Codeforces - Code 4",
          "code": "math.factorial(200000)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15725",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #285 - Codeforces - Code 5",
          "code": "i = 1\nj = 1\nwhile(i <= n) {\n while(i > j || !is_it_a_good_range(i,j)) {\n  ++j;\n  update_set_with_bad_numbers(j);\n  update_set_with_bad_numbers(n+1-j);\n }\n update_set_with_bad_numbers(i);\n update_set_with_bad_numbers(n+1-i);\n ++i;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15725",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #285 - Codeforces - Code 6",
          "code": "i = 1\nj = 1\nwhile(i <= n) {\n while(i > j || !is_it_a_good_range(i,j)) {\n  ++j;\n  update_set_with_bad_numbers(j);\n  update_set_with_bad_numbers(n+1-j);\n }\n update_set_with_bad_numbers(i);\n update_set_with_bad_numbers(n+1-i);\n ++i;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15725",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #285 - Codeforces - Code 7",
          "code": "BigInteger x = new BigInteger(in.next());\nx.testBit(j);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15725",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #285 - Codeforces - Code 8",
          "code": "BigInteger x = new BigInteger(in.next());\nx.testBit(j);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15725",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #285 - Codeforces - Code 9",
          "code": "set<int>::iterator it = s.lower_bound(x);\ns.erase(it);\nupd(*it);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15725",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #285 - Codeforces - Code 10",
          "code": "set<int>::iterator it = s.lower_bound(x);\ns.erase(it);\nupd(*it);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15725",
          "author": "Qingyu"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n    vector<int> a = inf.readInts(n, 1, n, \"a_i\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n    vector<int> a = inf.readInts(n, 1, n, \"a_i\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n    vector<int> a = inf.readInts(n, 1, n, \"a_i\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    // Parse parameters\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n    int max_value = opt<int>(\"max_value\", n);\n\n    vector<int> a(n);\n\n    if (type == \"all_same\") {\n        // All elements are the same\n        int val = rnd.next(1, max_value);\n        for (int i = 0; i < n; ++i)\n            a[i] = val;\n    } else if (type == \"distinct\") {\n        // All elements are distinct\n        // Create permutation of numbers 1..n\n        a.resize(n);\n        for (int i = 0; i < n; ++i)\n            a[i] = i + 1;\n        shuffle(a.begin(), a.end());\n        if (max_value < n) {\n            // Adjust values to fit in 1..max_value\n            for (int i = 0; i < n; ++i)\n                a[i] = (a[i] - 1) % max_value + 1;\n        }\n    } else if (type == \"palindrome\") {\n        // Create a palindrome\n        for (int i = 0; i < (n + 1) / 2; ++i) {\n            int val = rnd.next(1, max_value);\n            a[i] = a[n - i - 1] = val;\n        }\n    } else if (type == \"almost_palindrome\") {\n        // Create an array that's almost a palindrome but needs minimal changes\n        for (int i = 0; i < (n + 1) / 2; ++i) {\n            int val = rnd.next(1, max_value);\n            a[i] = a[n - i - 1] = val;\n        }\n        // Change a random element\n        int pos = rnd.next(0, n - 1);\n        a[pos] = rnd.next(1, max_value);\n    } else if (type == \"symmetric_ends\") {\n        // Ends are symmetric, middle is random\n        int len = rnd.next(1, n / 2); // length of symmetric ends\n        for (int i = 0; i < len; ++i) {\n            int val = rnd.next(1, max_value);\n            a[i] = a[n - i - 1] = val;\n        }\n        // Middle elements\n        for (int i = len; i < n - len; ++i)\n            a[i] = rnd.next(1, max_value);\n    } else if (type == \"random\") {\n        // Random elements\n        for (int i = 0; i < n; ++i)\n            a[i] = rnd.next(1, max_value);\n    }\n    else {\n        // If unrecognized type, default to random\n        for (int i = 0; i < n; ++i)\n            a[i] = rnd.next(1, max_value);\n    }\n\n    // Output n\n    printf(\"%d\\n\", n);\n    // Output array a\n    for (int i = 0; i < n; ++i)\n        printf(\"%d%c\", a[i], \" \\n\"[i == n - 1]);\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    // Parse parameters\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n    int max_value = opt<int>(\"max_value\", n);\n\n    vector<int> a(n);\n\n    if (type == \"all_same\") {\n        // All elements are the same\n        int val = rnd.next(1, max_value);\n        for (int i = 0; i < n; ++i)\n            a[i] = val;\n    } else if (type == \"distinct\") {\n        // All elements are distinct\n        // Create permutation of numbers 1..n\n        a.resize(n);\n        for (int i = 0; i < n; ++i)\n            a[i] = i + 1;\n        shuffle(a.begin(), a.end());\n        if (max_value < n) {\n            // Adjust values to fit in 1..max_value\n            for (int i = 0; i < n; ++i)\n                a[i] = (a[i] - 1) % max_value + 1;\n        }\n    } else if (type == \"palindrome\") {\n        // Create a palindrome\n        for (int i = 0; i < (n + 1) / 2; ++i) {\n            int val = rnd.next(1, max_value);\n            a[i] = a[n - i - 1] = val;\n        }\n    } else if (type == \"almost_palindrome\") {\n        // Create an array that's almost a palindrome but needs minimal changes\n        for (int i = 0; i < (n + 1) / 2; ++i) {\n            int val = rnd.next(1, max_value);\n            a[i] = a[n - i - 1] = val;\n        }\n        // Change a random element\n        int pos = rnd.next(0, n - 1);\n        a[pos] = rnd.next(1, max_value);\n    } else if (type == \"symmetric_ends\") {\n        // Ends are symmetric, middle is random\n        int len = rnd.next(1, n / 2); // length of symmetric ends\n        for (int i = 0; i < len; ++i) {\n            int val = rnd.next(1, max_value);\n            a[i] = a[n - i - 1] = val;\n        }\n        // Middle elements\n        for (int i = len; i < n - len; ++i)\n            a[i] = rnd.next(1, max_value);\n    } else if (type == \"random\") {\n        // Random elements\n        for (int i = 0; i < n; ++i)\n            a[i] = rnd.next(1, max_value);\n    }\n    else {\n        // If unrecognized type, default to random\n        for (int i = 0; i < n; ++i)\n            a[i] = rnd.next(1, max_value);\n    }\n\n    // Output n\n    printf(\"%d\\n\", n);\n    // Output array a\n    for (int i = 0; i < n; ++i)\n        printf(\"%d%c\", a[i], \" \\n\"[i == n - 1]);\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -type random\n./gen -n 1 -type all_same\n./gen -n 1 -type palindrome\n\n./gen -n 2 -type random\n./gen -n 2 -type palindrome\n./gen -n 2 -type almost_palindrome\n\n./gen -n 5 -type all_same\n./gen -n 5 -type distinct\n./gen -n 5 -type palindrome\n\n./gen -n 10 -type random\n./gen -n 10 -type symmetric_ends\n./gen -n 10 -type almost_palindrome\n\n./gen -n 100 -type random\n./gen -n 100 -type palindrome\n./gen -n 100 -type symmetric_ends -max_value 2\n\n./gen -n 1000 -type random\n./gen -n 1000 -type all_same\n./gen -n 1000 -type distinct\n\n./gen -n 10000 -type random\n./gen -n 10000 -type palindrome\n\n./gen -n 50000 -type random -max_value 50\n./gen -n 50000 -type symmetric_ends -max_value 2\n\n./gen -n 100000 -type random\n./gen -n 100000 -type palindrome\n./gen -n 100000 -type symmetric_ends -max_value 1\n\n./gen -n 100000 -type all_same\n./gen -n 100000 -type distinct\n\n./gen -n 7 -type almost_palindrome\n./gen -n 20 -type symmetric_ends\n\n./gen -n 100000 -type random -max_value 1\n./gen -n 100000 -type random -max_value 2\n\n./gen -n 50000 -type symmetric_ends -max_value 1000\n\n./gen -n 100000 -type all_same\n\n./gen -n 100000 -type distinct\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:40:27.797670",
        "total_tutorials": 3,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "504/D",
      "title": "D. Misha and XOR",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains number m (1 ≤ m ≤ 2000), showing how many numbers are scattered around the room.The next m lines contain the numbers in the order in which the robot puts them in the basket. Each number is a positive integer strictly less than 10600 that doesn't contain leading zeroes.",
      "output_spec": "OutputFor each number either print a 0 on the corresponding line, if the number cannot be represented as a XOR sum of numbers that are in the basket, or print integer k showing how many numbers are in the representation and the indexes of these numbers. Separate the numbers by spaces. Each number can occur in the representation at most once.",
      "sample_tests": "ExamplesInputCopy77654321OutputCopy0003 0 1 22 1 22 0 22 0 1InputCopy255OutputCopy01 0",
      "description": "D. Misha and XOR\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains number m (1 ≤ m ≤ 2000), showing how many numbers are scattered around the room.The next m lines contain the numbers in the order in which the robot puts them in the basket. Each number is a positive integer strictly less than 10600 that doesn't contain leading zeroes.\n\nOutputFor each number either print a 0 on the corresponding line, if the number cannot be represented as a XOR sum of numbers that are in the basket, or print integer k showing how many numbers are in the representation and the indexes of these numbers. Separate the numbers by spaces. Each number can occur in the representation at most once.\n\nInputCopy77654321OutputCopy0003 0 1 22 1 22 0 22 0 1InputCopy255OutputCopy01 0\n\nInputCopy77654321\n\nOutputCopy0003 0 1 22 1 22 0 22 0 1\n\nInputCopy255\n\nOutputCopy01 0\n\nNoteThe XOR sum of numbers is the result of bitwise sum of numbers modulo 2.",
      "solutions": [
        {
          "title": "Codeforces Round #285 - Codeforces",
          "content": "Hi, Codeforces!Codeforces Round #285 will be held at 12 January, 12.00 MSK. Problems are authored by me, Evgeny Savinov. This is my first round at Codeforces. I hope that this isn't the last one.I want to thank sokian and Golovanov399 for help in preparing and testing round, Zlobober for invaluable help in preparing round, AlexFetisov for testing round, Delinur for translating problem statements in English, and of course, MikeMirzayanov for great systems Codeforces and Polygon.By the way, today(11 January) is MikeMirzayanov's birthday. Happy birthday, Mike!The round will be for both divisions. Information about score distribution will be posted just before the round starts.UPD1: Scoring system will be dynamic. Problems will be arranged in ascending expected difficulty order.UPD2: The editorial can be found here. I'm sorry for the delay.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/15725",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 848
        },
        {
          "title": "Codeforces Round #285 Editorial - Codeforces",
          "content": "501A - ContestIn this problem one need to determine the number of points for both guys and find out who got more points.Time complexity: O(1).501B - Misha and Changing HandlesThe problem can be formulated as follows: The directed graph is given, its vertices correspond to users' handles and edges — to requests. It consists of a number of chains, so every vertex ingoing and outgoing degree doesn't exceed one. One need to find number of chains and first and last vertices of every chain. The arcs of this graph can be stored in dictionary(one can use std::map\\unoredered_map in C++ and TreeMap\\HashMap in Java) with head of the arc as the key and the tail as the value.Each zero ingoing degree vertex corresponds to unique user as well as first vertex of some chain. We should iterate from such vertices through the arcs while it's possible. Thus we find relation between first and last vertices in the chain as well as relation between the original and the new handle of some user.You can see my solution for details.Time complexity: .504A - Misha and ForestNote that every non-empty forest has a leaf(vertex of degree 1). Let's remove edges one by one and maintain actual values (degreev, sv) as long as graph is not empty. To do so, we can maintain the queue(or stack) of the leaves. On every iteration we dequeue vertex v and remove edge (v, sv) and update values for vertex sv: degreesv -= 1 and ssv ^= v. If degree of vertex sv becomes equal to 1, we enqueue it.When dequeued vertex has zero degree, just ignore it because we have already removed all edges of corresponding tree.You can see my solution for details.Time complexity: O(n)504B - Misha and Permutations SummationTo solve the problem, one need to be able to find the index of given permutation in lexicographical order and permutation by its index. We will store indices in factorial number system. Thus number x is represented as . You can find the rules of the transform here.To make the transform, you may need to use data structures such as binary search tree or binary indexed tree (for maintaining queries of finding k-th number in the set and finding the amount of numbers less than given one).So, one need to get indices of the permutations, to sum them modulo n! and make inverse transform. You can read any accepted solution for better understanding.Time complexity: or .504C - Misha and Palindrome DegreeNote that if the amount of elements, which number of occurrences is odd, is greater than one, the answer is zero. On the other hand, if array is the palindrome, answer is .Let's cut equal elements from the end and the beginning of array while it is possible. Let's call remaining array as b and its length as m. We are interested in segments [l, r] which cover some prefix or suffix of b.We need to find the minimum length of such prefix and suffix. Prefix and suffix can overlap the middle of b and these cases are needed to maintain. To find minimum length you can use binary search or simply iterating over array and storing the amount of every element to the left and right from the current index. Let's call minimum length of prefix as pref and as suf of suffix. So .Time complexity: O(n) or .504D - Misha and XORFirstly, we convert each number into a binary system: it can be done in O(MAXBITS2), where MAXBITS ≤ 2000 with rather small constant(we store number in system with big radix).To solve the problem we need to modify Gauss elimination algorithm. For each row we should store set of row's indices which we already XORed this row to get row echelon form (we can store it in bitset), also for each bit i we store index p[i] of row, which lowest set bit is i in row echelon form.Maintaining the query we try to reset bits from lowest to highest using array p and save information, which rows were XORed with current number. If we can reset whole number, the answer is positive and we know indices of answer. We update array p, otherwise.Time complexity: O(m × MAXBITS × (MAXBITS + m)) with small constant due to bit compression.504E - Misha and LCP on TreeLet's build heavy-light decomposition of given tree and write all strings corresponding to heavy paths one by one in one string T, every path should be written twice: in the direct and reverse order.Maintaining query we can split paths (a, b) и (c, d) into parts, which completely belongs to some heavy paths. There can be at most such parts. Note that every part corresponds to some substring of T.Now we only need to find longest common prefix of two substrings in string T. It can be done building suffix array of string T and lcp array. So, we can find longest common prefix of two substring in O(1) constructing rmq sparse table on lcp array.Time complexity: For the better understanding see my solution.P.S. One can uses hashes instead of suffix array.ADD: There is another approach to solve this problem in but it's rather slow in practice. We can do binary search on answer and use hashes, but we do it for all queries at one time. The only problem is to find k-th vertex on the path, we can do it offline for all queries in O(n + m) time. We run dfs and maintain stack of vertices. See my solution for details.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/15743",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 504\\s*D"
          },
          "content_length": 5171
        },
        {
          "title": "Codeforces Round #285 Editorial - Codeforces",
          "content": "501A - ContestIn this problem one need to determine the number of points for both guys and find out who got more points.Time complexity: O(1).501B - Misha and Changing HandlesThe problem can be formulated as follows: The directed graph is given, its vertices correspond to users' handles and edges — to requests. It consists of a number of chains, so every vertex ingoing and outgoing degree doesn't exceed one. One need to find number of chains and first and last vertices of every chain. The arcs of this graph can be stored in dictionary(one can use std::map\\unoredered_map in C++ and TreeMap\\HashMap in Java) with head of the arc as the key and the tail as the value.Each zero ingoing degree vertex corresponds to unique user as well as first vertex of some chain. We should iterate from such vertices through the arcs while it's possible. Thus we find relation between first and last vertices in the chain as well as relation between the original and the new handle of some user.You can see my solution for details.Time complexity: .504A - Misha and ForestNote that every non-empty forest has a leaf(vertex of degree 1). Let's remove edges one by one and maintain actual values (degreev, sv) as long as graph is not empty. To do so, we can maintain the queue(or stack) of the leaves. On every iteration we dequeue vertex v and remove edge (v, sv) and update values for vertex sv: degreesv -= 1 and ssv ^= v. If degree of vertex sv becomes equal to 1, we enqueue it.When dequeued vertex has zero degree, just ignore it because we have already removed all edges of corresponding tree.You can see my solution for details.Time complexity: O(n)504B - Misha and Permutations SummationTo solve the problem, one need to be able to find the index of given permutation in lexicographical order and permutation by its index. We will store indices in factorial number system. Thus number x is represented as . You can find the rules of the transform here.To make the transform, you may need to use data structures such as binary search tree or binary indexed tree (for maintaining queries of finding k-th number in the set and finding the amount of numbers less than given one).So, one need to get indices of the permutations, to sum them modulo n! and make inverse transform. You can read any accepted solution for better understanding.Time complexity: or .504C - Misha and Palindrome DegreeNote that if the amount of elements, which number of occurrences is odd, is greater than one, the answer is zero. On the other hand, if array is the palindrome, answer is .Let's cut equal elements from the end and the beginning of array while it is possible. Let's call remaining array as b and its length as m. We are interested in segments [l, r] which cover some prefix or suffix of b.We need to find the minimum length of such prefix and suffix. Prefix and suffix can overlap the middle of b and these cases are needed to maintain. To find minimum length you can use binary search or simply iterating over array and storing the amount of every element to the left and right from the current index. Let's call minimum length of prefix as pref and as suf of suffix. So .Time complexity: O(n) or .504D - Misha and XORFirstly, we convert each number into a binary system: it can be done in O(MAXBITS2), where MAXBITS ≤ 2000 with rather small constant(we store number in system with big radix).To solve the problem we need to modify Gauss elimination algorithm. For each row we should store set of row's indices which we already XORed this row to get row echelon form (we can store it in bitset), also for each bit i we store index p[i] of row, which lowest set bit is i in row echelon form.Maintaining the query we try to reset bits from lowest to highest using array p and save information, which rows were XORed with current number. If we can reset whole number, the answer is positive and we know indices of answer. We update array p, otherwise.Time complexity: O(m × MAXBITS × (MAXBITS + m)) with small constant due to bit compression.504E - Misha and LCP on TreeLet's build heavy-light decomposition of given tree and write all strings corresponding to heavy paths one by one in one string T, every path should be written twice: in the direct and reverse order.Maintaining query we can split paths (a, b) и (c, d) into parts, which completely belongs to some heavy paths. There can be at most such parts. Note that every part corresponds to some substring of T.Now we only need to find longest common prefix of two substrings in string T. It can be done building suffix array of string T and lcp array. So, we can find longest common prefix of two substring in O(1) constructing rmq sparse table on lcp array.Time complexity: For the better understanding see my solution.P.S. One can uses hashes instead of suffix array.ADD: There is another approach to solve this problem in but it's rather slow in practice. We can do binary search on answer and use hashes, but we do it for all queries at one time. The only problem is to find k-th vertex on the path, we can do it offline for all queries in O(n + m) time. We run dfs and maintain stack of vertices. See my solution for details.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/15743",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 504\\s*D"
          },
          "content_length": 5171
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #285 - Codeforces - Code 1",
          "code": "#include <iostream>\nusing namespace std;\n\nint main ()\n{\n        cout << \"Happy Birthday Mike ! \\\\:D/\" << endl << \"Thanks For Everything !!! :D\" << endl;\n        return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/15725",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #285 - Codeforces - Code 2",
          "code": "#include <iostream>\nusing namespace std;\n\nint main ()\n{\n        cout << \"Happy Birthday Mike ! \\\\:D/\" << endl << \"Thanks For Everything !!! :D\" << endl;\n        return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/15725",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #285 - Codeforces - Code 3",
          "code": "math.factorial(x)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15725",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #285 - Codeforces - Code 4",
          "code": "math.factorial(200000)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15725",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #285 - Codeforces - Code 5",
          "code": "i = 1\nj = 1\nwhile(i <= n) {\n while(i > j || !is_it_a_good_range(i,j)) {\n  ++j;\n  update_set_with_bad_numbers(j);\n  update_set_with_bad_numbers(n+1-j);\n }\n update_set_with_bad_numbers(i);\n update_set_with_bad_numbers(n+1-i);\n ++i;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15725",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #285 - Codeforces - Code 6",
          "code": "i = 1\nj = 1\nwhile(i <= n) {\n while(i > j || !is_it_a_good_range(i,j)) {\n  ++j;\n  update_set_with_bad_numbers(j);\n  update_set_with_bad_numbers(n+1-j);\n }\n update_set_with_bad_numbers(i);\n update_set_with_bad_numbers(n+1-i);\n ++i;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15725",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #285 - Codeforces - Code 7",
          "code": "BigInteger x = new BigInteger(in.next());\nx.testBit(j);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15725",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #285 - Codeforces - Code 8",
          "code": "BigInteger x = new BigInteger(in.next());\nx.testBit(j);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15725",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #285 - Codeforces - Code 9",
          "code": "set<int>::iterator it = s.lower_bound(x);\ns.erase(it);\nupd(*it);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15725",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #285 - Codeforces - Code 10",
          "code": "set<int>::iterator it = s.lower_bound(x);\ns.erase(it);\nupd(*it);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15725",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int m = inf.readInt(1, 2000, \"m\");\n    inf.readEoln();\n\n    for (int i = 0; i < m; ++i) {\n        string xi = inf.readToken();\n        inf.readEoln();\n\n        ensuref(xi.length() <= 600, \"number at line %d is too long\", i + 2);\n        ensuref(xi[0] != '0', \"number at line %d has leading zero\", i + 2);\n        for (char c : xi) {\n            ensuref('0' <= c && c <= '9', \"number at line %d contains invalid character\", i + 2);\n        }\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int m = inf.readInt(1, 2000, \"m\");\n    inf.readEoln();\n\n    for (int i = 0; i < m; ++i) {\n        string xi = inf.readToken();\n        inf.readEoln();\n\n        ensuref(xi.length() <= 600, \"number at line %d is too long\", i + 2);\n        ensuref(xi[0] != '0', \"number at line %d has leading zero\", i + 2);\n        for (char c : xi) {\n            ensuref('0' <= c && c <= '9', \"number at line %d contains invalid character\", i + 2);\n        }\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int m = inf.readInt(1, 2000, \"m\");\n    inf.readEoln();\n\n    for (int i = 0; i < m; ++i) {\n        string xi = inf.readToken();\n        inf.readEoln();\n\n        ensuref(xi.length() <= 600, \"number at line %d is too long\", i + 2);\n        ensuref(xi[0] != '0', \"number at line %d has leading zero\", i + 2);\n        for (char c : xi) {\n            ensuref('0' <= c && c <= '9', \"number at line %d contains invalid character\", i + 2);\n        }\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAX_BITS = 2000;\n\nbitset<MAX_BITS> stringToBitset(const string& s) {\n    bitset<MAX_BITS> bits;\n    bits.reset();\n\n    vector<int> digits;\n    for (char c : s) {\n        digits.push_back(c - '0');\n    }\n\n    int bit_index = 0;\n\n    while (!digits.empty()) {\n        int remainder = 0;\n        vector<int> new_digits;\n        for (int i = 0; i < (int)digits.size(); ++i) {\n            int num = remainder * 10 + digits[i];\n            int quotient = num / 2;\n            remainder = num % 2;\n            if (!new_digits.empty() || quotient != 0) {\n                new_digits.push_back(quotient);\n            }\n        }\n        bits[bit_index++] = remainder;\n        digits = new_digits;\n    }\n\n    return bits;\n}\n\nbool isInSpan(const bitset<MAX_BITS>& x, bitset<MAX_BITS> basis[]) {\n    bitset<MAX_BITS> tmp = x;\n    for (int i = MAX_BITS - 1; i >= 0; --i) {\n        if (tmp[i]) {\n            if (basis[i].none()) {\n                // Cannot represent x\n                return false;\n            }\n            tmp ^= basis[i];\n        }\n    }\n    return true;\n}\n\nvoid insertVector(bitset<MAX_BITS>& x, bitset<MAX_BITS> basis[]) {\n    bitset<MAX_BITS> tmp = x;\n    for (int i = MAX_BITS - 1; i >= 0; --i) {\n        if (tmp[i]) {\n            if (basis[i].none()) {\n                // No basis vector at position i, so we can insert x\n                basis[i] = tmp;\n                return;\n            } else {\n                tmp ^= basis[i];\n            }\n        }\n    }\n    // If x becomes zero, do nothing\n}\n\nint main(int argc, char* argv[]) {\n    registerTestlibCmd(argc, argv);\n\n    int m = inf.readInt(1, 2000, \"m\");\n    vector<bitset<MAX_BITS>> numbers;\n    numbers.reserve(m);\n\n    for (int i = 0; i < m; ++i) {\n        string s = inf.readToken();\n        bitset<MAX_BITS> bits = stringToBitset(s);\n        numbers.push_back(bits);\n    }\n\n    bitset<MAX_BITS> basis[MAX_BITS] = {};\n\n    for (int i = 0; i < m; ++i) {\n        bitset<MAX_BITS> x = numbers[i];\n\n        int t = ouf.readInt(0, i, format(\"number of indices for number %d\", i + 1).c_str());\n\n        if (t == 0) {\n            if (isInSpan(x, basis)) {\n                quitf(_wa, \"At step %d, number can be represented as XOR of previous numbers, but participant reports 0\", i + 1);\n            }\n        } else {\n            if (t < 1)\n                quitf(_wa, \"At step %d, number of indices must be at least 1\", i + 1);\n            vector<int> indices = ouf.readInts(t, 0, i - 1, format(\"indices for number %d\", i + 1).c_str());\n\n            set<int> unique_indices(indices.begin(), indices.end());\n            if ((int)unique_indices.size() < t) {\n                quitf(_wa, \"At step %d, indices are not unique\", i + 1);\n            }\n\n            bitset<MAX_BITS> xor_sum;\n            xor_sum.reset();\n            for (int idx : indices) {\n                xor_sum ^= numbers[idx];\n            }\n\n            if (xor_sum != x) {\n                quitf(_wa, \"At step %d, the XOR of numbers at given indices does not equal the number\", i + 1);\n            }\n        }\n\n        insertVector(x, basis);\n    }\n\n    quitf(_ok, \"Correct output\");\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring randBigInt(int len) {\n    string res = \"\";\n    res += rnd.next('1', '9'); // First digit non-zero\n    for (int i = 1; i < len; i++) {\n        res += rnd.next('0', '9');\n    }\n    return res;\n}\n\nstring pow2AsString(int exp) {\n    string res = \"1\";\n    for (int i = 0; i < exp; i++) {\n        int carry = 0;\n        for (int j = res.size() -1; j >= 0; j--) {\n            int digit = (res[j] - '0') *2 + carry;\n            res[j] = (digit %10) + '0';\n            carry = digit /10;\n        }\n        if (carry >0) {\n            res = char(carry + '0') + res;\n        }\n    }\n    return res;\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    \n    int m = opt<int>(\"m\");\n    int minLen = opt<int>(\"minLen\", 1);\n    int maxLen = opt<int>(\"maxLen\", 600);\n    string type = opt<string>(\"type\", \"random\");\n\n    // Output m\n    cout << m << endl;\n\n    for (int i = 0; i < m; i++) {\n        string x;\n        if (type == \"random\") {\n            int len = rnd.next(minLen, maxLen);\n            x = randBigInt(len);\n        } else if (type == \"small\") {\n            int val = rnd.next(1, 1000);\n            x = to_string(val);\n        } else if (type == \"large\") {\n            int len = maxLen;\n            x = randBigInt(len);\n        } else if (type == \"pattern_powers_of_two\") {\n            int exp = rnd.next(0, 1000);\n            x = pow2AsString(exp);\n        } else if (type == \"pattern_repeats\") {\n            int len = rnd.next(minLen, maxLen);\n            char digit = rnd.next('1', '9');\n            x = string(len, digit);\n        } else {\n            // Default to random\n            int len = rnd.next(minLen, maxLen);\n            x = randBigInt(len);\n        }\n        // Output x\n        cout << x << endl;\n    }\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring randBigInt(int len) {\n    string res = \"\";\n    res += rnd.next('1', '9'); // First digit non-zero\n    for (int i = 1; i < len; i++) {\n        res += rnd.next('0', '9');\n    }\n    return res;\n}\n\nstring pow2AsString(int exp) {\n    string res = \"1\";\n    for (int i = 0; i < exp; i++) {\n        int carry = 0;\n        for (int j = res.size() -1; j >= 0; j--) {\n            int digit = (res[j] - '0') *2 + carry;\n            res[j] = (digit %10) + '0';\n            carry = digit /10;\n        }\n        if (carry >0) {\n            res = char(carry + '0') + res;\n        }\n    }\n    return res;\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    \n    int m = opt<int>(\"m\");\n    int minLen = opt<int>(\"minLen\", 1);\n    int maxLen = opt<int>(\"maxLen\", 600);\n    string type = opt<string>(\"type\", \"random\");\n\n    // Output m\n    cout << m << endl;\n\n    for (int i = 0; i < m; i++) {\n        string x;\n        if (type == \"random\") {\n            int len = rnd.next(minLen, maxLen);\n            x = randBigInt(len);\n        } else if (type == \"small\") {\n            int val = rnd.next(1, 1000);\n            x = to_string(val);\n        } else if (type == \"large\") {\n            int len = maxLen;\n            x = randBigInt(len);\n        } else if (type == \"pattern_powers_of_two\") {\n            int exp = rnd.next(0, 1000);\n            x = pow2AsString(exp);\n        } else if (type == \"pattern_repeats\") {\n            int len = rnd.next(minLen, maxLen);\n            char digit = rnd.next('1', '9');\n            x = string(len, digit);\n        } else {\n            // Default to random\n            int len = rnd.next(minLen, maxLen);\n            x = randBigInt(len);\n        }\n        // Output x\n        cout << x << endl;\n    }\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -m 1 -type small\n./gen -m 1 -type large -maxLen 600\n./gen -m 2 -type small\n./gen -m 2 -type large -maxLen 600\n./gen -m 2 -type pattern_powers_of_two\n./gen -m 2 -type pattern_repeats\n./gen -m 10 -type small\n./gen -m 10 -type random -minLen 1 -maxLen 100\n./gen -m 10 -type large -maxLen 600\n./gen -m 100 -type random -minLen 1 -maxLen 600\n./gen -m 100 -type pattern_powers_of_two\n./gen -m 100 -type pattern_repeats\n./gen -m 200 -type pattern_powers_of_two\n./gen -m 200 -type pattern_repeats\n./gen -m 200 -type random -minLen 600 -maxLen 600\n./gen -m 200 -type random -minLen 1 -maxLen 1\n./gen -m 200 -type large -maxLen 600\n./gen -m 500 -type small\n./gen -m 500 -type random -minLen 1 -maxLen 600\n./gen -m 500 -type pattern_repeats\n./gen -m 1000 -type random -minLen 1 -maxLen 600\n./gen -m 1000 -type large -maxLen 600\n./gen -m 1000 -type pattern_powers_of_two\n./gen -m 2000 -type random -minLen 1 -maxLen 600\n./gen -m 2000 -type pattern_repeats\n./gen -m 2000 -type small\n./gen -m 2000 -type pattern_powers_of_two\n./gen -m 2000 -type large -maxLen 600\n./gen -m 2000 -type random -minLen 600 -maxLen 600\n./gen -m 2000 -type random -minLen 1 -maxLen 1\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:40:29.643586",
        "total_tutorials": 3,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "504/E",
      "title": "E. Misha and LCP on Tree",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test8 seconds",
      "memory_limit": "memory limit per test512 megabytes",
      "input_spec": "InputThe first line contains integer n (1 ≤ n ≤ 300 000) — the number of vertices in the tree.Next follows a line consisting of n small English letters. The i-th character of the string corresponds to the character written on the i-th vertex. Next n - 1 lines contain information about edges. An edge is defined by a pair of integers u, v (1 ≤ u, v ≤ n, u ≠ v), separated by spaces.The next line contains integer m (1 ≤ m ≤ 1 000 000) — the number of queries.Next m lines contain information about queries. A query is defined by four integers a, b, c, d (1 ≤ a, b, c, d ≤ n), separated by spaces.",
      "output_spec": "OutputFor each query print the length of the largest common prefix on a separate line.",
      "sample_tests": "ExamplesInputCopy6bbbabb2 13 24 35 26 562 5 3 11 5 2 35 6 5 66 3 4 16 2 3 42 2 4 5OutputCopy222010",
      "description": "E. Misha and LCP on Tree\n\ntime limit per test8 seconds\n\ntime limit per test\n\nmemory limit per test512 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains integer n (1 ≤ n ≤ 300 000) — the number of vertices in the tree.Next follows a line consisting of n small English letters. The i-th character of the string corresponds to the character written on the i-th vertex. Next n - 1 lines contain information about edges. An edge is defined by a pair of integers u, v (1 ≤ u, v ≤ n, u ≠ v), separated by spaces.The next line contains integer m (1 ≤ m ≤ 1 000 000) — the number of queries.Next m lines contain information about queries. A query is defined by four integers a, b, c, d (1 ≤ a, b, c, d ≤ n), separated by spaces.\n\nOutputFor each query print the length of the largest common prefix on a separate line.\n\nInputCopy6bbbabb2 13 24 35 26 562 5 3 11 5 2 35 6 5 66 3 4 16 2 3 42 2 4 5OutputCopy222010\n\nInputCopy6bbbabb2 13 24 35 26 562 5 3 11 5 2 35 6 5 66 3 4 16 2 3 42 2 4 5\n\nOutputCopy222010",
      "solutions": [
        {
          "title": "Codeforces Round #285 - Codeforces",
          "content": "Hi, Codeforces!Codeforces Round #285 will be held at 12 January, 12.00 MSK. Problems are authored by me, Evgeny Savinov. This is my first round at Codeforces. I hope that this isn't the last one.I want to thank sokian and Golovanov399 for help in preparing and testing round, Zlobober for invaluable help in preparing round, AlexFetisov for testing round, Delinur for translating problem statements in English, and of course, MikeMirzayanov for great systems Codeforces and Polygon.By the way, today(11 January) is MikeMirzayanov's birthday. Happy birthday, Mike!The round will be for both divisions. Information about score distribution will be posted just before the round starts.UPD1: Scoring system will be dynamic. Problems will be arranged in ascending expected difficulty order.UPD2: The editorial can be found here. I'm sorry for the delay.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/15725",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 848
        },
        {
          "title": "Codeforces Round #285 Editorial - Codeforces",
          "content": "501A - ContestIn this problem one need to determine the number of points for both guys and find out who got more points.Time complexity: O(1).501B - Misha and Changing HandlesThe problem can be formulated as follows: The directed graph is given, its vertices correspond to users' handles and edges — to requests. It consists of a number of chains, so every vertex ingoing and outgoing degree doesn't exceed one. One need to find number of chains and first and last vertices of every chain. The arcs of this graph can be stored in dictionary(one can use std::map\\unoredered_map in C++ and TreeMap\\HashMap in Java) with head of the arc as the key and the tail as the value.Each zero ingoing degree vertex corresponds to unique user as well as first vertex of some chain. We should iterate from such vertices through the arcs while it's possible. Thus we find relation between first and last vertices in the chain as well as relation between the original and the new handle of some user.You can see my solution for details.Time complexity: .504A - Misha and ForestNote that every non-empty forest has a leaf(vertex of degree 1). Let's remove edges one by one and maintain actual values (degreev, sv) as long as graph is not empty. To do so, we can maintain the queue(or stack) of the leaves. On every iteration we dequeue vertex v and remove edge (v, sv) and update values for vertex sv: degreesv -= 1 and ssv ^= v. If degree of vertex sv becomes equal to 1, we enqueue it.When dequeued vertex has zero degree, just ignore it because we have already removed all edges of corresponding tree.You can see my solution for details.Time complexity: O(n)504B - Misha and Permutations SummationTo solve the problem, one need to be able to find the index of given permutation in lexicographical order and permutation by its index. We will store indices in factorial number system. Thus number x is represented as . You can find the rules of the transform here.To make the transform, you may need to use data structures such as binary search tree or binary indexed tree (for maintaining queries of finding k-th number in the set and finding the amount of numbers less than given one).So, one need to get indices of the permutations, to sum them modulo n! and make inverse transform. You can read any accepted solution for better understanding.Time complexity: or .504C - Misha and Palindrome DegreeNote that if the amount of elements, which number of occurrences is odd, is greater than one, the answer is zero. On the other hand, if array is the palindrome, answer is .Let's cut equal elements from the end and the beginning of array while it is possible. Let's call remaining array as b and its length as m. We are interested in segments [l, r] which cover some prefix or suffix of b.We need to find the minimum length of such prefix and suffix. Prefix and suffix can overlap the middle of b and these cases are needed to maintain. To find minimum length you can use binary search or simply iterating over array and storing the amount of every element to the left and right from the current index. Let's call minimum length of prefix as pref and as suf of suffix. So .Time complexity: O(n) or .504D - Misha and XORFirstly, we convert each number into a binary system: it can be done in O(MAXBITS2), where MAXBITS ≤ 2000 with rather small constant(we store number in system with big radix).To solve the problem we need to modify Gauss elimination algorithm. For each row we should store set of row's indices which we already XORed this row to get row echelon form (we can store it in bitset), also for each bit i we store index p[i] of row, which lowest set bit is i in row echelon form.Maintaining the query we try to reset bits from lowest to highest using array p and save information, which rows were XORed with current number. If we can reset whole number, the answer is positive and we know indices of answer. We update array p, otherwise.Time complexity: O(m × MAXBITS × (MAXBITS + m)) with small constant due to bit compression.504E - Misha and LCP on TreeLet's build heavy-light decomposition of given tree and write all strings corresponding to heavy paths one by one in one string T, every path should be written twice: in the direct and reverse order.Maintaining query we can split paths (a, b) и (c, d) into parts, which completely belongs to some heavy paths. There can be at most such parts. Note that every part corresponds to some substring of T.Now we only need to find longest common prefix of two substrings in string T. It can be done building suffix array of string T and lcp array. So, we can find longest common prefix of two substring in O(1) constructing rmq sparse table on lcp array.Time complexity: For the better understanding see my solution.P.S. One can uses hashes instead of suffix array.ADD: There is another approach to solve this problem in but it's rather slow in practice. We can do binary search on answer and use hashes, but we do it for all queries at one time. The only problem is to find k-th vertex on the path, we can do it offline for all queries in O(n + m) time. We run dfs and maintain stack of vertices. See my solution for details.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/15743",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 504\\s*E"
          },
          "content_length": 5171
        },
        {
          "title": "Codeforces Round #285 Editorial - Codeforces",
          "content": "501A - ContestIn this problem one need to determine the number of points for both guys and find out who got more points.Time complexity: O(1).501B - Misha and Changing HandlesThe problem can be formulated as follows: The directed graph is given, its vertices correspond to users' handles and edges — to requests. It consists of a number of chains, so every vertex ingoing and outgoing degree doesn't exceed one. One need to find number of chains and first and last vertices of every chain. The arcs of this graph can be stored in dictionary(one can use std::map\\unoredered_map in C++ and TreeMap\\HashMap in Java) with head of the arc as the key and the tail as the value.Each zero ingoing degree vertex corresponds to unique user as well as first vertex of some chain. We should iterate from such vertices through the arcs while it's possible. Thus we find relation between first and last vertices in the chain as well as relation between the original and the new handle of some user.You can see my solution for details.Time complexity: .504A - Misha and ForestNote that every non-empty forest has a leaf(vertex of degree 1). Let's remove edges one by one and maintain actual values (degreev, sv) as long as graph is not empty. To do so, we can maintain the queue(or stack) of the leaves. On every iteration we dequeue vertex v and remove edge (v, sv) and update values for vertex sv: degreesv -= 1 and ssv ^= v. If degree of vertex sv becomes equal to 1, we enqueue it.When dequeued vertex has zero degree, just ignore it because we have already removed all edges of corresponding tree.You can see my solution for details.Time complexity: O(n)504B - Misha and Permutations SummationTo solve the problem, one need to be able to find the index of given permutation in lexicographical order and permutation by its index. We will store indices in factorial number system. Thus number x is represented as . You can find the rules of the transform here.To make the transform, you may need to use data structures such as binary search tree or binary indexed tree (for maintaining queries of finding k-th number in the set and finding the amount of numbers less than given one).So, one need to get indices of the permutations, to sum them modulo n! and make inverse transform. You can read any accepted solution for better understanding.Time complexity: or .504C - Misha and Palindrome DegreeNote that if the amount of elements, which number of occurrences is odd, is greater than one, the answer is zero. On the other hand, if array is the palindrome, answer is .Let's cut equal elements from the end and the beginning of array while it is possible. Let's call remaining array as b and its length as m. We are interested in segments [l, r] which cover some prefix or suffix of b.We need to find the minimum length of such prefix and suffix. Prefix and suffix can overlap the middle of b and these cases are needed to maintain. To find minimum length you can use binary search or simply iterating over array and storing the amount of every element to the left and right from the current index. Let's call minimum length of prefix as pref and as suf of suffix. So .Time complexity: O(n) or .504D - Misha and XORFirstly, we convert each number into a binary system: it can be done in O(MAXBITS2), where MAXBITS ≤ 2000 with rather small constant(we store number in system with big radix).To solve the problem we need to modify Gauss elimination algorithm. For each row we should store set of row's indices which we already XORed this row to get row echelon form (we can store it in bitset), also for each bit i we store index p[i] of row, which lowest set bit is i in row echelon form.Maintaining the query we try to reset bits from lowest to highest using array p and save information, which rows were XORed with current number. If we can reset whole number, the answer is positive and we know indices of answer. We update array p, otherwise.Time complexity: O(m × MAXBITS × (MAXBITS + m)) with small constant due to bit compression.504E - Misha and LCP on TreeLet's build heavy-light decomposition of given tree and write all strings corresponding to heavy paths one by one in one string T, every path should be written twice: in the direct and reverse order.Maintaining query we can split paths (a, b) и (c, d) into parts, which completely belongs to some heavy paths. There can be at most such parts. Note that every part corresponds to some substring of T.Now we only need to find longest common prefix of two substrings in string T. It can be done building suffix array of string T and lcp array. So, we can find longest common prefix of two substring in O(1) constructing rmq sparse table on lcp array.Time complexity: For the better understanding see my solution.P.S. One can uses hashes instead of suffix array.ADD: There is another approach to solve this problem in but it's rather slow in practice. We can do binary search on answer and use hashes, but we do it for all queries at one time. The only problem is to find k-th vertex on the path, we can do it offline for all queries in O(n + m) time. We run dfs and maintain stack of vertices. See my solution for details.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/15743",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 504\\s*E"
          },
          "content_length": 5171
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #285 - Codeforces - Code 1",
          "code": "#include <iostream>\nusing namespace std;\n\nint main ()\n{\n        cout << \"Happy Birthday Mike ! \\\\:D/\" << endl << \"Thanks For Everything !!! :D\" << endl;\n        return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/15725",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #285 - Codeforces - Code 2",
          "code": "#include <iostream>\nusing namespace std;\n\nint main ()\n{\n        cout << \"Happy Birthday Mike ! \\\\:D/\" << endl << \"Thanks For Everything !!! :D\" << endl;\n        return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/15725",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #285 - Codeforces - Code 3",
          "code": "math.factorial(x)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15725",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #285 - Codeforces - Code 4",
          "code": "math.factorial(200000)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15725",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #285 - Codeforces - Code 5",
          "code": "i = 1\nj = 1\nwhile(i <= n) {\n while(i > j || !is_it_a_good_range(i,j)) {\n  ++j;\n  update_set_with_bad_numbers(j);\n  update_set_with_bad_numbers(n+1-j);\n }\n update_set_with_bad_numbers(i);\n update_set_with_bad_numbers(n+1-i);\n ++i;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15725",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #285 - Codeforces - Code 6",
          "code": "i = 1\nj = 1\nwhile(i <= n) {\n while(i > j || !is_it_a_good_range(i,j)) {\n  ++j;\n  update_set_with_bad_numbers(j);\n  update_set_with_bad_numbers(n+1-j);\n }\n update_set_with_bad_numbers(i);\n update_set_with_bad_numbers(n+1-i);\n ++i;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15725",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #285 - Codeforces - Code 7",
          "code": "BigInteger x = new BigInteger(in.next());\nx.testBit(j);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15725",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #285 - Codeforces - Code 8",
          "code": "BigInteger x = new BigInteger(in.next());\nx.testBit(j);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15725",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #285 - Codeforces - Code 9",
          "code": "set<int>::iterator it = s.lower_bound(x);\ns.erase(it);\nupd(*it);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15725",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #285 - Codeforces - Code 10",
          "code": "set<int>::iterator it = s.lower_bound(x);\ns.erase(it);\nupd(*it);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15725",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAXN = 300000;\nconst int MAXM = 1000000;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, MAXN, \"n\");\n    inf.readEoln();\n\n    string s_pattern = \"[a-z]{\"+to_string(n)+\"}\";\n    string s = inf.readLine(s_pattern, \"s\");\n\n    // Read edges and check for cycles and connectivity\n    vector<int> parent(n+1), rank(n+1, 0);\n    for (int i = 1; i <= n; ++i)\n        parent[i] = i;\n\n    function<int(int)> find_set = [&](int x) {\n        if (parent[x] != x)\n            parent[x] = find_set(parent[x]);\n        return parent[x];\n    };\n\n    auto union_sets = [&](int a, int b) {\n        a = find_set(a);\n        b = find_set(b);\n        if (a == b)\n            return false; // Cycle detected\n        if (rank[a] < rank[b])\n            swap(a, b);\n        parent[b] = a;\n        if (rank[a] == rank[b])\n            ++rank[a];\n        return true;\n    };\n\n    for (int i = 0; i < n - 1; ++i) {\n        int u = inf.readInt(1, n, \"u\");\n        inf.readSpace();\n        int v = inf.readInt(1, n, \"v\");\n        inf.readEoln();\n        ensuref(u != v, \"Edge can't be a loop: u = v = %d\", u);\n        bool merged = union_sets(u, v);\n        ensuref(merged, \"Graph must be acyclic (no cycles), but extra edge between %d and %d creates a cycle\", u, v);\n    }\n\n    // Check connectedness\n    int root = find_set(1);\n    for (int i = 2; i <= n; ++i) {\n        ensuref(find_set(i) == root, \"Graph must be connected, but node %d is in a different component\", i);\n    }\n\n    int m = inf.readInt(1, MAXM, \"m\");\n    inf.readEoln();\n\n    for (int i = 0; i < m; ++i) {\n        int a = inf.readInt(1, n, \"a\");\n        inf.readSpace();\n        int b = inf.readInt(1, n, \"b\");\n        inf.readSpace();\n        int c = inf.readInt(1, n, \"c\");\n        inf.readSpace();\n        int d = inf.readInt(1, n, \"d\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAXN = 300000;\nconst int MAXM = 1000000;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, MAXN, \"n\");\n    inf.readEoln();\n\n    string s_pattern = \"[a-z]{\"+to_string(n)+\"}\";\n    string s = inf.readLine(s_pattern, \"s\");\n\n    // Read edges and check for cycles and connectivity\n    vector<int> parent(n+1), rank(n+1, 0);\n    for (int i = 1; i <= n; ++i)\n        parent[i] = i;\n\n    function<int(int)> find_set = [&](int x) {\n        if (parent[x] != x)\n            parent[x] = find_set(parent[x]);\n        return parent[x];\n    };\n\n    auto union_sets = [&](int a, int b) {\n        a = find_set(a);\n        b = find_set(b);\n        if (a == b)\n            return false; // Cycle detected\n        if (rank[a] < rank[b])\n            swap(a, b);\n        parent[b] = a;\n        if (rank[a] == rank[b])\n            ++rank[a];\n        return true;\n    };\n\n    for (int i = 0; i < n - 1; ++i) {\n        int u = inf.readInt(1, n, \"u\");\n        inf.readSpace();\n        int v = inf.readInt(1, n, \"v\");\n        inf.readEoln();\n        ensuref(u != v, \"Edge can't be a loop: u = v = %d\", u);\n        bool merged = union_sets(u, v);\n        ensuref(merged, \"Graph must be acyclic (no cycles), but extra edge between %d and %d creates a cycle\", u, v);\n    }\n\n    // Check connectedness\n    int root = find_set(1);\n    for (int i = 2; i <= n; ++i) {\n        ensuref(find_set(i) == root, \"Graph must be connected, but node %d is in a different component\", i);\n    }\n\n    int m = inf.readInt(1, MAXM, \"m\");\n    inf.readEoln();\n\n    for (int i = 0; i < m; ++i) {\n        int a = inf.readInt(1, n, \"a\");\n        inf.readSpace();\n        int b = inf.readInt(1, n, \"b\");\n        inf.readSpace();\n        int c = inf.readInt(1, n, \"c\");\n        inf.readSpace();\n        int d = inf.readInt(1, n, \"d\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAXN = 300000;\nconst int MAXM = 1000000;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, MAXN, \"n\");\n    inf.readEoln();\n\n    string s_pattern = \"[a-z]{\"+to_string(n)+\"}\";\n    string s = inf.readLine(s_pattern, \"s\");\n\n    // Read edges and check for cycles and connectivity\n    vector<int> parent(n+1), rank(n+1, 0);\n    for (int i = 1; i <= n; ++i)\n        parent[i] = i;\n\n    function<int(int)> find_set = [&](int x) {\n        if (parent[x] != x)\n            parent[x] = find_set(parent[x]);\n        return parent[x];\n    };\n\n    auto union_sets = [&](int a, int b) {\n        a = find_set(a);\n        b = find_set(b);\n        if (a == b)\n            return false; // Cycle detected\n        if (rank[a] < rank[b])\n            swap(a, b);\n        parent[b] = a;\n        if (rank[a] == rank[b])\n            ++rank[a];\n        return true;\n    };\n\n    for (int i = 0; i < n - 1; ++i) {\n        int u = inf.readInt(1, n, \"u\");\n        inf.readSpace();\n        int v = inf.readInt(1, n, \"v\");\n        inf.readEoln();\n        ensuref(u != v, \"Edge can't be a loop: u = v = %d\", u);\n        bool merged = union_sets(u, v);\n        ensuref(merged, \"Graph must be acyclic (no cycles), but extra edge between %d and %d creates a cycle\", u, v);\n    }\n\n    // Check connectedness\n    int root = find_set(1);\n    for (int i = 2; i <= n; ++i) {\n        ensuref(find_set(i) == root, \"Graph must be connected, but node %d is in a different component\", i);\n    }\n\n    int m = inf.readInt(1, MAXM, \"m\");\n    inf.readEoln();\n\n    for (int i = 0; i < m; ++i) {\n        int a = inf.readInt(1, n, \"a\");\n        inf.readSpace();\n        int b = inf.readInt(1, n, \"b\");\n        inf.readSpace();\n        int c = inf.readInt(1, n, \"c\");\n        inf.readSpace();\n        int d = inf.readInt(1, n, \"d\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint n, m;\nstring tree_type, char_type, query_type;\nvector<pair<int, int> > edges; // list of edges\nstring s; // characters on vertices\nvector<pair<pair<int, int>, pair<int, int> > > queries; // list of queries\n\nvoid generate_tree() {\n    edges.clear();\n    if (tree_type == \"random\") {\n        // Generate a random tree using random edges\n        for (int i = 2; i <= n; ++i) {\n            int u = i;\n            int v = rnd.next(1, i - 1);\n            edges.push_back(make_pair(u, v));\n        }\n        shuffle(edges.begin(), edges.end());\n    } else if (tree_type == \"chain\") {\n        // Generate a chain tree\n        for (int i = 2; i <= n; ++i) {\n            edges.push_back(make_pair(i - 1, i));\n        }\n    } else if (tree_type == \"star\") {\n        // Generate a star tree\n        for (int i = 2; i <= n; ++i) {\n            edges.push_back(make_pair(1, i));\n        }\n    } else if (tree_type == \"balanced\") {\n        // Generate a balanced binary tree\n        queue<int> q;\n        q.push(1);\n        int cnt = 2;\n        while (cnt <= n && !q.empty()) {\n            int u = q.front(); q.pop();\n            int l = cnt++;\n            if (l > n) break;\n            edges.push_back(make_pair(u, l));\n            q.push(l);\n            int r = cnt++;\n            if (r > n) break;\n            edges.push_back(make_pair(u, r));\n            q.push(r);\n        }\n    } else {\n        // Default to random tree\n        for (int i = 2; i <= n; ++i) {\n            int u = i;\n            int v = rnd.next(1, i - 1);\n            edges.push_back(make_pair(u, v));\n        }\n        shuffle(edges.begin(), edges.end());\n    }\n}\n\nvoid assign_characters() {\n    s = \"\";\n    if (char_type == \"random\") {\n        for (int i = 0; i < n; ++i) {\n            char c = 'a' + rnd.next(26);\n            s += c;\n        }\n    } else if (char_type == \"same\") {\n        char c = 'a' + rnd.next(26);\n        s = string(n, c);\n    } else if (char_type == \"alternating\") {\n        char c1 = 'a' + rnd.next(26);\n        char c2 = 'a' + rnd.next(26);\n        if (c1 == c2) c2 = 'a' + (c1 - 'a' + 1) % 26;\n        for (int i = 0; i < n; ++i) {\n            s += (i % 2 == 0) ? c1 : c2;\n        }\n    } else if (char_type == \"incrementing\") {\n        for (int i = 0; i < n; ++i) {\n            char c = 'a' + (i % 26);\n            s += c;\n        }\n    } else {\n        // Default to random characters\n        for (int i = 0; i < n; ++i) {\n            char c = 'a' + rnd.next(26);\n            s += c;\n        }\n    }\n}\n\nvoid generate_queries() {\n    queries.clear();\n    if (query_type == \"random\") {\n        for (int i = 0; i < m; ++i) {\n            int a = rnd.next(1, n);\n            int b = rnd.next(1, n);\n            int c = rnd.next(1, n);\n            int d = rnd.next(1, n);\n            queries.push_back(make_pair(make_pair(a, b), make_pair(c, d)));\n        }\n    } else if (query_type == \"maxcommon\") {\n        for (int i = 0; i < m; ++i) {\n            int a = rnd.next(1, n);\n            int b = rnd.next(1, n);\n            int c = a; // same starting point\n            int d = rnd.next(1, n);\n            queries.push_back(make_pair(make_pair(a, b), make_pair(c, d)));\n        }\n    } else if (query_type == \"mincommon\") {\n        for (int i = 0; i < m; ++i) {\n            int a = rnd.next(1, n);\n            int b = rnd.next(1, n);\n            int c = rnd.next(1, n);\n            int d = rnd.next(1, n);\n            while (a == c) c = rnd.next(1, n);\n            queries.push_back(make_pair(make_pair(a, b), make_pair(c, d)));\n        }\n    } else {\n        // Default to random queries\n        for (int i = 0; i < m; ++i) {\n            int a = rnd.next(1, n);\n            int b = rnd.next(1, n);\n            int c = rnd.next(1, n);\n            int d = rnd.next(1, n);\n            queries.push_back(make_pair(make_pair(a, b), make_pair(c, d)));\n        }\n    }\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    \n    n = opt<int>(\"n\");\n    m = opt<int>(\"m\");\n    tree_type = opt<string>(\"tree_type\", \"random\");\n    char_type = opt<string>(\"char_type\", \"random\");\n    query_type = opt<string>(\"query_type\", \"random\");\n    \n    generate_tree();\n    assign_characters();\n    generate_queries();\n\n    // Output the data\n    printf(\"%d\\n\", n);\n    printf(\"%s\\n\", s.c_str());\n    for (auto e : edges) {\n        printf(\"%d %d\\n\", e.first, e.second);\n    }\n    printf(\"%d\\n\", m);\n    for (auto q : queries) {\n        printf(\"%d %d %d %d\\n\", q.first.first, q.first.second, q.second.first, q.second.second);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint n, m;\nstring tree_type, char_type, query_type;\nvector<pair<int, int> > edges; // list of edges\nstring s; // characters on vertices\nvector<pair<pair<int, int>, pair<int, int> > > queries; // list of queries\n\nvoid generate_tree() {\n    edges.clear();\n    if (tree_type == \"random\") {\n        // Generate a random tree using random edges\n        for (int i = 2; i <= n; ++i) {\n            int u = i;\n            int v = rnd.next(1, i - 1);\n            edges.push_back(make_pair(u, v));\n        }\n        shuffle(edges.begin(), edges.end());\n    } else if (tree_type == \"chain\") {\n        // Generate a chain tree\n        for (int i = 2; i <= n; ++i) {\n            edges.push_back(make_pair(i - 1, i));\n        }\n    } else if (tree_type == \"star\") {\n        // Generate a star tree\n        for (int i = 2; i <= n; ++i) {\n            edges.push_back(make_pair(1, i));\n        }\n    } else if (tree_type == \"balanced\") {\n        // Generate a balanced binary tree\n        queue<int> q;\n        q.push(1);\n        int cnt = 2;\n        while (cnt <= n && !q.empty()) {\n            int u = q.front(); q.pop();\n            int l = cnt++;\n            if (l > n) break;\n            edges.push_back(make_pair(u, l));\n            q.push(l);\n            int r = cnt++;\n            if (r > n) break;\n            edges.push_back(make_pair(u, r));\n            q.push(r);\n        }\n    } else {\n        // Default to random tree\n        for (int i = 2; i <= n; ++i) {\n            int u = i;\n            int v = rnd.next(1, i - 1);\n            edges.push_back(make_pair(u, v));\n        }\n        shuffle(edges.begin(), edges.end());\n    }\n}\n\nvoid assign_characters() {\n    s = \"\";\n    if (char_type == \"random\") {\n        for (int i = 0; i < n; ++i) {\n            char c = 'a' + rnd.next(26);\n            s += c;\n        }\n    } else if (char_type == \"same\") {\n        char c = 'a' + rnd.next(26);\n        s = string(n, c);\n    } else if (char_type == \"alternating\") {\n        char c1 = 'a' + rnd.next(26);\n        char c2 = 'a' + rnd.next(26);\n        if (c1 == c2) c2 = 'a' + (c1 - 'a' + 1) % 26;\n        for (int i = 0; i < n; ++i) {\n            s += (i % 2 == 0) ? c1 : c2;\n        }\n    } else if (char_type == \"incrementing\") {\n        for (int i = 0; i < n; ++i) {\n            char c = 'a' + (i % 26);\n            s += c;\n        }\n    } else {\n        // Default to random characters\n        for (int i = 0; i < n; ++i) {\n            char c = 'a' + rnd.next(26);\n            s += c;\n        }\n    }\n}\n\nvoid generate_queries() {\n    queries.clear();\n    if (query_type == \"random\") {\n        for (int i = 0; i < m; ++i) {\n            int a = rnd.next(1, n);\n            int b = rnd.next(1, n);\n            int c = rnd.next(1, n);\n            int d = rnd.next(1, n);\n            queries.push_back(make_pair(make_pair(a, b), make_pair(c, d)));\n        }\n    } else if (query_type == \"maxcommon\") {\n        for (int i = 0; i < m; ++i) {\n            int a = rnd.next(1, n);\n            int b = rnd.next(1, n);\n            int c = a; // same starting point\n            int d = rnd.next(1, n);\n            queries.push_back(make_pair(make_pair(a, b), make_pair(c, d)));\n        }\n    } else if (query_type == \"mincommon\") {\n        for (int i = 0; i < m; ++i) {\n            int a = rnd.next(1, n);\n            int b = rnd.next(1, n);\n            int c = rnd.next(1, n);\n            int d = rnd.next(1, n);\n            while (a == c) c = rnd.next(1, n);\n            queries.push_back(make_pair(make_pair(a, b), make_pair(c, d)));\n        }\n    } else {\n        // Default to random queries\n        for (int i = 0; i < m; ++i) {\n            int a = rnd.next(1, n);\n            int b = rnd.next(1, n);\n            int c = rnd.next(1, n);\n            int d = rnd.next(1, n);\n            queries.push_back(make_pair(make_pair(a, b), make_pair(c, d)));\n        }\n    }\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    \n    n = opt<int>(\"n\");\n    m = opt<int>(\"m\");\n    tree_type = opt<string>(\"tree_type\", \"random\");\n    char_type = opt<string>(\"char_type\", \"random\");\n    query_type = opt<string>(\"query_type\", \"random\");\n    \n    generate_tree();\n    assign_characters();\n    generate_queries();\n\n    // Output the data\n    printf(\"%d\\n\", n);\n    printf(\"%s\\n\", s.c_str());\n    for (auto e : edges) {\n        printf(\"%d %d\\n\", e.first, e.second);\n    }\n    printf(\"%d\\n\", m);\n    for (auto q : queries) {\n        printf(\"%d %d %d %d\\n\", q.first.first, q.first.second, q.second.first, q.second.second);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 5 -m 5 -tree_type chain -char_type same -query_type random\n./gen -n 5 -m 5 -tree_type star -char_type random -query_type random\n./gen -n 5 -m 5 -tree_type random -char_type incrementing -query_type maxcommon\n./gen -n 5 -m 5 -tree_type balanced -char_type alternating -query_type mincommon\n\n./gen -n 10 -m 10 -tree_type chain -char_type same -query_type mincommon\n./gen -n 10 -m 10 -tree_type star -char_type same -query_type maxcommon\n./gen -n 10 -m 10 -tree_type balanced -char_type incrementing -query_type random\n./gen -n 10 -m 10 -tree_type random -char_type alternating -query_type random\n./gen -n 10 -m 10 -tree_type random -char_type random -query_type random\n\n./gen -n 1000 -m 1000 -tree_type random -char_type random -query_type random\n./gen -n 1000 -m 1000 -tree_type chain -char_type same -query_type maxcommon\n./gen -n 1000 -m 1000 -tree_type star -char_type incrementing -query_type mincommon\n./gen -n 1000 -m 1000 -tree_type random -char_type random -query_type maxcommon\n./gen -n 1000 -m 1000 -tree_type random -char_type random -query_type mincommon\n\n./gen -n 100000 -m 100000 -tree_type random -char_type random -query_type random\n./gen -n 100000 -m 1000000 -tree_type chain -char_type random -query_type random\n./gen -n 100000 -m 1000000 -tree_type balanced -char_type same -query_type maxcommon\n./gen -n 100000 -m 1000000 -tree_type balanced -char_type incrementing -query_type mincommon\n\n./gen -n 300000 -m 1000000 -tree_type random -char_type random -query_type random\n./gen -n 300000 -m 1000000 -tree_type random -char_type same -query_type random\n./gen -n 300000 -m 1000000 -tree_type random -char_type alternating -query_type random\n./gen -n 300000 -m 1000000 -tree_type random -char_type incrementing -query_type random\n./gen -n 300000 -m 1000000 -tree_type random -char_type random -query_type maxcommon\n./gen -n 300000 -m 1000000 -tree_type random -char_type random -query_type mincommon\n./gen -n 300000 -m 1000000 -tree_type chain -char_type same -query_type maxcommon\n./gen -n 300000 -m 1000000 -tree_type chain -char_type random -query_type mincommon\n./gen -n 300000 -m 1000000 -tree_type star -char_type same -query_type mincommon\n./gen -n 300000 -m 1000000 -tree_type star -char_type random -query_type maxcommon\n./gen -n 300000 -m 1000000 -tree_type star -char_type random -query_type random\n./gen -n 300000 -m 1000000 -tree_type balanced -char_type alternating -query_type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:40:31.650877",
        "total_tutorials": 3,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "505/A",
      "title": "A. Mr. Kitayuta's Gift",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe only line of the input contains a string s (1 ≤ |s| ≤ 10). Each character in s is a lowercase English letter.",
      "output_spec": "OutputIf it is possible to turn s into a palindrome by inserting one lowercase English letter, print the resulting string in a single line. Otherwise, print \"NA\" (without quotes, case-sensitive). In case there is more than one solution, any of them will be accepted.",
      "sample_tests": "ExamplesInputCopyreviveOutputCopyreviverInputCopyeeOutputCopyeyeInputCopykitayutaOutputCopyNA",
      "description": "A. Mr. Kitayuta's Gift\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe only line of the input contains a string s (1 ≤ |s| ≤ 10). Each character in s is a lowercase English letter.\n\nOutputIf it is possible to turn s into a palindrome by inserting one lowercase English letter, print the resulting string in a single line. Otherwise, print \"NA\" (without quotes, case-sensitive). In case there is more than one solution, any of them will be accepted.\n\nInputCopyreviveOutputCopyreviverInputCopyeeOutputCopyeyeInputCopykitayutaOutputCopyNA\n\nInputCopyrevive\n\nOutputCopyreviver\n\nInputCopyee\n\nOutputCopyeye\n\nInputCopykitayuta\n\nOutputCopyNA\n\nNoteFor the first sample, insert 'r' to the end of \"revive\" to obtain a palindrome \"reviver\".For the second sample, there is more than one solution. For example, \"eve\" will also be accepted.For the third sample, it is not possible to turn \"kitayuta\" into a palindrome by just inserting one letter.",
      "solutions": [
        {
          "title": "Codeforces Round #286 - Codeforces",
          "content": "Hello Codeforces!evima, yosupo and I would like you to participate in Codeforces Round #286. It will be held on Sunday, January 18th at 16:00 MSK. Please note that this round starts on unusual time.Great thanks to Zlobober who helped us prepare this round, Delinur who translated statements into Russian and MikeMirzayanov who created Codeforces and polygon.This is the 3rd time(following #162 and #263) for me, and the 1st time for evima and yosupo to prepare a Codeforces Round.Scores of the problems will be500-1000-1750-1750-2500 for Div.1, and500-1000-1500-2000-2750 for Div.2.In this round, you'll help a man named Mr. kitayuta. I hope he will participate :)The system tests are now over! The top-5 are as follows:Div.1:1.ilyakor2.kcm17003.LayCurse4.RomaWhite5.TankEngineerDiv.2:1.Konijntje2.cpcpc3.zgzjsxshycxksxhsh4.Ronnie0075.sha384Also, special congrats on Petr, who solved problem E in Div.1, which anyone else could not solve.Here are the editorials",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/15842",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 961
        },
        {
          "title": "Codeforces Round #286 Editorial (Complete) - Codeforces",
          "content": "Edit (Jan 22, 2:45 AM UTC): Added Div1E and the editorial is now complete. I am sorry for the delay.Edit (Jan 21, 9:45 AM UTC): Added the explanation for Div1C/2E, and the problem setters' codes. Div1E will need several more hours. Thank you again for your patience.First, here are some statistics on this round: Division Registrants Participants A Accepted B Accepted C Accepted D Accepted E Accepted 1 1364 572 (*) 294 199 8 113 1 (Estimated number of AC by me) 800 (wrong) 500 (wrong) 70 (FAIL) 90 (ok) 5 (wrong) 2 4016 2028 1355 945 41 5 0 (*) Where did the remaining 792 people go? :) We are sorry for terribly underestimating the difficulty of the problems (except Div1D), especially Div1A/2C and Div1C/2E. Div.2 A: 505A - Mr. Kitayuta's Gift[Problem] Given a string, turn it into a palindrome by inserting one letter or state that it is impossible.(Problem by evima)Since the string is short (at most 10 characters), you can simply try every possible way of inserting a letter (\"where\" and \"what\" to insert), and check if the resulting string is a palindrome.The writer's code (C++): 9501249Note: For some strange reason, we (contest managers) cannot submit solutions so that everyone can see them. PraveenDhinwa told us how to do so. Thank you! Div.2 B: 505B - Mr. Kitayuta's Colorful Graph[Problem] Given an undirected graph whose edges are painted in colors, process the queries of the following form: Given two vertices ui and vi, find the number of the colors that satisfies the following condition: the edges of that color connect ui and vi (possibly indirectly). (Problem by hogloid)Since neither the graph nor the number of queries is too large, for each query you can simply count the number of the \"good\" colors (the colors that satisfies the condition) by checking if each color is \"good\". To do that, you can perform Depth First Search (or Breadth First Search) and verify whether you can reach vi from ui traversing only the edges of that color. If you prefer using Union-Find, it will also do the job.The writer's code (DFS, C++)The writer's code (Union-Find, C++) Div.2 C / Div.1 A: 505C - Mr. Kitayuta, the Treasure Hunter[Problem] Since it is hard to summarize this problem, please refer to the official statement.(Problem by yosupo)Below is the explanation from yosupo, translated by me.[From here]Let m be the number of the islands (that is, 30001). First, let us describe a solution with time and memory complexity of O(m2).We will apply Dynamic Programming. let dp[i][j] be the number of the gems that Mr. Kitayuta can collect after he jumps to island i, when the length of his previous jump is j (let us assume that he have not collect the gems on island i). Then, you can calculate the values of the table dp by the following: dp[i][j] = 0, if i ≥ m(actually these islands do not exist, but we can suppose that they exist and when Mr. Kitayuta jumps to these islands, he stops jumping) dp[i][j] =  (the number of the gems on island i)  + max(dp[i + j][j], dp[i + j + 1][j + 1]), if i < m, j = 1(he cannot perform a jump of length 0) dp[i][j] =  (the number of the gems on island i)  + max(dp[i + j - 1][j - 1], dp[i + j][j], dp[i + j + 1][j + 1]), if i < m, j ≥ 2 This solution is unfeasible in terms of both time and memory. However, the following observation makes it an Accepted solution: there are only 491 values of j that we have to consider, which are d - 245, d - 244, d - 243, ..., d + 244 and d + 245.Why? First, let us find the upper bound of j. Suppose Mr. Kitayuta always performs the \"l + 1\" jump (l: the length of the previous jump). Then, he will reach the end of the islands before he performs a jump of length d + 246, becaused + (d + 1) + (d + 2) + ... + (d + 245) ≥ 1 + 2 + ... + 245 = 245·(245 + 1) / 2 = 30135 > 30000. Thus, he will never be able to perform a jump of length d + 246 or longer.Next, let us consider the lower bound of j in a similar way. If d ≤ 246, then obviously he will not be able to perform a jump of length d - 246 or shorter, because the length of a jump must be positive. Suppose Mr. Kitayuta always performs the \"l - 1\" jump, where d ≥ 247. Then, again he will reach the end of the islands before he performs a jump of length d - 246, becaused + (d - 1) + (d - 2) + ... + (d - 245) ≥ 245 + 244 + ... + 1 = 245·(245 + 1) / 2 = 30135 > 30000. Thus, he will never be able to perform a jump of length d - 246 or shorter.Therefore, we have obtained a working solution: similar to the O(m2) one, but we will only consider the value of j between d - 245 and d + 245. The time and memory complexity of this solution will be O(m1.5), since the value \"245\" is slightly larger than .This solution can be implemented by, for example, using a \"normal\" two dimensional array with a offset like this: dp[i][j - offset]. The time limit is set tight in order to fail most of naive solutions with search using std::map or something, so using hash maps (unordered_map) will be risky although the complexity will be the same as the described solution.[End]The writer's code (memoized recursion, C++) Div.2 D / Div.1 B: 505D - Mr. Kitayuta's Technology[Problem] Given an integer n and m pairs of integers (ai, bi) (1 ≤ ai, bi ≤ n), find the minimum number of edges in a directed graph that satisfies the following condition: For each i, there exists a path from vertex ai to vertex bi. (Problem from evima)Let G1 be the directed graph built from the input, and G2 be a directed graph that satisfies the given conditions. What we seek is the minimum number of edges in G2. Also, we say that two vertices u and v in a directed graph are \"weakly connected\" if we can reach v from u by traversing edges, not considering their directions.If a pair (u, v) is present in the input, then vertices u and v must be weakly connected in G2. Therefore, for each weakly connected component (abbreviated to wcc) in G1, the vertices in that component must also be in the same wcc in G2. We can \"merge\" multiple wccs in G1 and create a larger wcc in G2, but for now, let us find the minimum number of edges required in G2 for each wcc in G1 when we do not \"merge\" them. There are two cases to consider: If a wcc in G1 does not have cycles, then we can perform topological sort on that wcc, and we can make a \"chain\" (see the image below) using the topological order to satisfy the conditions. We need (the number of the vertices in the wcc)  - 1 edges, which is the minimum required number since any connected graph with V vertices has at least V - 1 edges. If a wcc in G1 has cycles, then topological sort cannot be applied. We need at least (the number of the vertices in the wcc) edges this time, since any connected graph with V vertices and V - 1 edges is a tree, which does not contain cycles. Actually, this number (the number of the vertices in the wcc) is always achievable by connecting the vertices into a \"ring\" (see the image below), thus it is the minimum required number that we seek. We have found the minimum required number of edges for each wcc in G1 when we do not \"merge\" them. Let us show that \"merging\" wccs in G1 do not reduce the number of required edges. Suppose we combine k( > 1) wccs C1, C2, ..., Ck in G1 into one wcc C in G2. Again, there are two cases to consider: If none of C1, C2, ..., Ck contains cycles, then C will need |C1| + |C2| + ... + |Ck| - 1 edges. However, if we do not combine them, we will only need (|C1| - 1) + (|C2| - 1) + ... + (|Ck| - 1) edges in total, which is fewer. If some of C1, C2, ..., Ck contain cycles, then C will need |C1| + |C2| + ... + |Ck| edges. However, if we do not combine them, we will need(|C1| - noCycles(C1)) + (|C2| - noCycles(C2)) + ... + (|Ck| - noCycles(Ck)  ≤ |C1| + |C2| + ... + |Ck| edges(here, noCycles(Ci) is 1 if Ci do not contain cycles, otherwise 0), thus combining them does not reduce the number of required edges. Thus, we do not need to combine multiple wccs into one wcc in G2 in order to obtain the optimal solution. That is, the final answer to the problem is the sum of the minimum required number of edges for each wcc in G1, when they are considered separately.As for the implementation, detecting cycles in a directed graph with 105 vertices and edges might be a problem if this is your first encounter with it. One possible way is to paste a code that decomposes a graph into strongly connected components. If the size of a strongly connected component is more than one, then that means the component contains cycles.The writer's code (strongly connected component decomposition, C++): 9501202 Div.2 E / Div.1 C: 505E - Mr. Kitayuta vs. Bamboos[Problem] Since it is hard to summarize this problem, please refer to the official statement.(Problem from yosupo)Below is the explanation from yosupo, translated by me.[From here]Let us begin by applying Binary Search. The problem becomes: \"is it possible that all the bamboos are at most X meters after m days?\" It is complicated by the fact that the height does not become negative; the excessive decrease will be wasted. We have found two approaches to this problem. Solution 1 Mr. Kitayuta must beat the i-th bamboo at least max(0, ⌈(hi + m·ai - X) / P⌉) times (let this number ti). Actually, it is not necessary for him to beat it more than this number of times. Thus, let us assume that he beat the i-th bamboo exactly ti times. Also, for each j (1 ≤ j ≤ ti), find the day di, j such that, if the j-th beat on the i-th bamboo is performed before day di, it will be no longer possible to keep the i-th bamboo's height after m days at most X (it can be found by doing simple math). If Mr. Kitayuta can beat the bamboos under this constraint, all the bamboos' heights will become X meters or less after m days. Otherwise, some bamboos' heights will exceed X meters.The time complexity of this solution will be , if we first calculate only ti, then if the sum of ti exceeds km, we skip finding di, j (the answer is \"NO\"). Solution 2 This problem becomes simpler if we simulate Mr. Kitayuta's fight backwards, that is, from day m to day 1. It looks like this:[Problem'] There are n bamboos. At the moment, the height of the i-th bamboo is X meters, and it shrinks ai meters at the beginning of each day. Mr. Kitayuta will play a game. He can use Magic Hammer at most k times per day to increase the height of a bamboo by p meters. If some bamboo's height becomes negative at any moment, he will lose the game immediately. Also, in order for him to win the game, the i-th bamboo's height must be at least hi meters after m days. Is victory possible?Below is an illustration of this \"reverse simulation\": This version is simpler because he is increasing the heights instead of decreasing, thus we do not need to take into account the \"excessive decrease beyond 0 meters\" which will be wasted. Let us consider an optimal strategy. If there exist bamboos whose heights would become negative after day m, he should beat the one that is the earliest to make him lose. Otherwise, he can choose any bamboo whose height would be less than hi meters after day m. Repeat beating the bamboos following this strategy, and see if he can actually claim victory.The writer's implementation of this solution uses a priority queue, and its time complexity is .[End]The tester's code (Solution 1, C++): 9501229The writer's code (Solution 2, C++) Div.1 D: 506D - Mr. Kitayuta's Colorful Graph[Problem] Given an undirected graph whose edges are painted in colors, process the queries of the following form: Given two vertices ui and vi, find the number of the colors that satisfies the following condition: the edges of that color connect ui and vi (possibly indirectly). Note: this is the exact same problem as Div.2 B except the constraints, which are 105 instead of 100.(Problem from hogloid)Below is the explanation from hogloid.[From here]For each color, make a new graph that consists of the edges of the color and vertices connected by the edges. Make UnionFind for each graph, and you can check whether a color connects vertex A and B , using it. For each query, find a vertex which has smaller degree(let this vertex A, and the other vertex B) For each colors such that a edge of the color connects to A, check whether A and B is connected by the color. After answering the query, memorize its tuple — (A, B, answer). If the same query is requested, answer using this information.This will lead to solution.For each query, the complexity is (For each color connects A, find a vertex of B of the color & check whether they are connected) The queries that require longest computing time are, to ask every pair among vertices which have largest degrees. Let the indices of the vertices be , and degrees of the vertices be d1, d2, ...dk. Now, let's fix vertex B as i. The total computing time of the queries such that B is vertex i is . Vertex B can vary from 2 to k. Hence, the total complexity is at most . This complexity is at most .By the way, in C++, using unordered_map, total complexity would be .[End]There will be many other solutions. I will briefly explain one of them which I think is typical.Let ci be the number of colors of the edges incident to vertex i. The sum of all ci does not exceed 2m since each edge increases this sum by at most 2. Thus, there will be at most 450 values of i such that ci ≥ 450 (let B = 450). We will call these vertices large, and the remaining ones small. Using O(m / B·m) = O(m2 / B) time and memory, we can precalculate and store the answer for all the possible queries where at least one of ui and vi is large, then we can immediately answer these queries. For the remaining queries, both ui and vi will be small, therefore it is enough to directly count the color that connects vertices ui and vi in O(B) time. The total time required will be O(m2 / B + Bq). If we choose , we can solve the problem in time.The writer's code (the first solution, C++)The tester's code (the second solution, C++): 9501240 Div.1 E: 506E - Mr. Kitayuta's Gift[Problem] Given a string s and an integer n, find the number of the palindromes that can be obtained by inserting exactly n letters into s.Note: Div.2 A is a similar problem, where n is fixed to 1.(Problem from evima)First of all, let us note that we are asked to count the resulting palindromes, not the ways to obtain them. For example, if we are to insert \"b\" into \"abba\", there are 5 possible positions, but only 3 strings will be produced (\"babba\", \"abbba\" and \"abbab\"). Rather than trying to count the ways of inserting a letter n times and removing the duplicated results, we should directly count the resulting palindrome. To do that, let us reformulate the problem:[Problem'] Given a string s and an integer n, find the number of the palindromes of length |s| + n (let this number be N) that contains s as a subsequence (not necessarily contiguous).Consider constructing a palindrome from both ends, and matching it to s from both left and right. For example, let s = \"abaac\" and N = 11. Let us call the final resulting string t. We first decide what letter to use as t1 and t11 (they must be equal in order for t to be a palindrome). Let us say 'c' is chosen. Now, we have to construct the remaining part of t, that is, t2..t10, so that t2..t10 contains \"abaa\" as a substring (note that the 'c' at the end of s is discarded). Again, we decide what letter to use as t2 and t10. This time we choose 'a'. Then, we have to construct t3..t9, so that it contains \"ba\" as a substring (this time the two 'a's at the both ends of s are discarded). We choose t3 = t9 = 'c'. Next, we construct t4..t8, so that it contains \"ba\" as a substring (this time s remains unchanged). We choose t4 = t8 = 'b'. Then, we construct t5..t7, so that it contains \"a\" as a substring. We choose t5 = t7 = 'a' (it is becoming repetitive, isn't it?). The last part of t, that is, t6, has no restriction (this time we choose a letter for only one position of t, not two). We choose 'd', and we have obtained a palindrome \"cacbadabcac\" that contains s = \"abaac\" as a subsequence.This problem is mostly about analyzing this process carefully.The most naive solution other than literally enumerating all palindromes of length N would be the following Dynamic Programming: let dp[i][left][right] be the number of the palindromes t that can be obtained if you have already decided the leftmost and the rightmost i letters (2i in total), and the substring sleftsleft + 1..sright of s remains unmatched. Each value in this table can be computed in O(1) time. Of course, since i can be up to ⌊n / 2⌋ (n ≤ 109), this solution is far from our goal.Notice that the transitions from dp[i] to dp[i + 1] are the same regardless of i, thus we can calculate the table by matrix exponentiation. However, since there are O(|s|2) possible pairs for (left, right), we will need time, which is actually worse than the naive calculation considering that |s| can be up to 200.This is where we need to observe the process which we have gone through at the beginning more carefully. Let us build a automaton corresponding to the process (the image below). (*) An self-loop with a number means that there are actually that number of edges.A process of producing a palindrome of length N that contains s as a subsequence corresponds to a path of length ⌈N / 2⌉ from the upper-right vertex to the lower-left vertex. Each red vertex has 24 self-loops since the letters at the both ends of the remaining part of s is different, which correspond to two non-self-loop transitions. Similarly, each green vertex has 25 self-loops since the first letter and the last letter of the remaining string is the same, and the blue vertex, the destination, has 26 self-loops, as there are no more non-self-loop transitions available.Here is an important fact: there are not so many possible combination of (n24, n25), where n24 and n25 are the number of times a path from START to GOAL visits a red vertex (with 24 self-loops) and a green vertex (with 25 self-loops), respectively. Why? Each time we leave a red vertex, the length of the remaining unmatched part of s decreases by 1, since exactly one of the two letters at the ends of the remaining part is matched and discarded. Similarly, each time we leave a green vertex, the length of the remaining string decreases by 2, since both of the two letters at the ends are matched and discarded. There is a exception, however: if the length of the remaining string is 1, then it will be a green vertex, but in this case the length will decrease by 1. Thus, for any path from START to GOAL, n24 + 2·n25 will be equal to either |s| or |s| + 1. If we fix n24, then n25 will be uniquely determined by n25 = ⌈(|s| - n24) / 2⌉. Since n24 can only take the value between 0 and |s| - 1, there are at most |s| possible pairs of (n24, n25).With this fact, we are ready to count the paths: let us classify them by the value of n24. For each possible pair of (n24, n25), let us count the number of corresponding paths. To do that, we divide each paths into two parts: first we count the number of paths from START to GOAL, using only non-self-loop transitions. Then, we count the ways of inserting self-loop transitions into each of these paths. The product of these two numbers will be the number that we seek.The first part is straightforward to solve: let dp[left][right][n24] be the number of paths from the vertex that corresponds to the substring sleftsleft + 1..sright, visiting exactly n24 red vertices using only non-self-loop transitions. Each value of the table can be found in O(1) time, thus the whole table can be computed in O(|s|3) time, which is fast enough for the input size (|s| ≤ 200).The main obstacle will be the second part. For example, let us consider the case where s = \"abaac\", N = 11, n24 = 2, which corresponds to the example at the beginning. From the fact we found earlier, n25 = ⌈(|s| - n24) / 2⌉ = ⌈(5 - 2) / 2⌉ = 2. Thus, we have to insert ⌈N / 2⌉ - n24 - n25 = 6 - 2 - 2 = 2 self-loop transitions into this path (the image): The order in which red, green and blue vertices appears in this path does not affect the number of ways of insertion, and can be arbitrary. The number of ways to insert 2 self-loop transitions will be equal to the number of the path of length ⌈N / 2⌉ = 6 from START to GOAL in this automaton (we have to take into account the non-self-loop transitions in it), which can be calculated by matrix exponentiation.Are we done? No! Consider the case s = \"abbb..(|s| - 1 times)..bb\". There are |s| - 1 possible values of n24 (n24 = 1 corresponds to the case where you match and discard the 'a' first, and n24 = |s| - 1 corresponds to the case where you keep the 'a' until s becomes \"ab\"). Thus, you need to perform matrix exponentiation |s| - 1 times, which results in a total of time, which will be too much under the given constraints.There is still hope, though, and here is the climax. Notice that these automata are very similar to each other, and they differ only in the number of the red and green vertices. We can combine these automata into one larger automaton like this (the image): The combined automaton should have |s| - 1 red, ⌈|s| / 2⌉ green and ⌈|s| / 2⌉ blue vertices.By performing matrix exponentiation on this automaton instead of many small automata, we can find all the required value in time, which should be enough. We recommend speeding up matrix multiplication by noticing that the matrix will be upper triangular (6 times faster on paper), since the time limit is not so generous (in order to reject solutions).The problem is almost solved, but there is one more challenge. When N is odd, the situation becomes a little complicated: as we have seen at the beginning, in the last (⌈N / 2⌉-th) step of producing a palindrome we choose a letter for only one position of the resulting string, that is, the center of that string. In other words, the last transition in the path in the automaton we have first built must not be one from a green vertex with a string of length 2 (for example, \"aa\") to GOAL.Let us find the number of the paths that violates this condition and subtract it from the answer. As previously mentioned, for each path n24 + 2·n25 will be equal to either |s| or |s| + 1, and if we fix the value of n24, n25 will be uniquely determined by n25 = ⌈(|s| - n24) / 2⌉. If |s| - n24 is odd, then it means that the last non-self-loop transition is one from a green vertex with a string of length 1, therefore in this case no path will violate the condition. If |s| - n24 is even, then the last non-self-loop trantision is from a green vertex with a string of length 2, thus the paths that does not contain the self-loop from GOAL to itself violate the condition. It will be equal to the number of the paths of length ⌈N / 2⌉ - 1 from START to the vertex just before GOAL, which can be found in a similar way to the second part of the solution.The journey has finally come to an end. Actually, it is also possible to solve this problem in time without matrix exponentiation, but this margin is too small to explain it. I will just paste the link to the code.The writer's code (matrix exponentiation, C++): 9501164The writer's code (without matrix exponentiation, C++): 9501177Congratulations again to Petr who was the only participant to solve this problem in 108 minutes. Also, I would like to give a special mention to rng_58, who was VERY close to solving it in only 63 minutes. He was just one byte away from getting AC (compare 9460984 and 9465440)! If you find a possible error, or have a question, please feel free to ask here. Alternative solutions are also welcome.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/15889",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 505\\s*A"
          },
          "content_length": 23595
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #286 - Codeforces - Code 1",
          "code": "This is the 3rd time(following #162 and #263) for me",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #286 - Codeforces - Code 2",
          "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N = 1e2 + 5;\n\nint parent[N][N];\n\nint find(int c, int v) {\n    if (parent[c][v] == -1)\n        return v;\n    return parent[c][v] = find(c, parent[c][v]);\n}\n\nvoid unite(int c, int u, int v) {\n    parent[c][find(c, u)] = find(c, v);\n}\n\nint main() {\n    memset(parent, -1, sizeof parent);\n    int n, m;\n    cin >> n >> m;\n    for (int i = 0; i < m; ++i) {\n        int a, b, c;\n        cin >> a >> b >> c;\n        unite(c, a, b);\n    }\n    int q;\n    cin >> q;\n    while (q--) {\n        int u, v, ans = 0;\n        cin >> u >> v;\n        for (int i = 1; i <= 100; ++i)\n            if (find(i, u) == find(i, v))\n                ++ans;\n        cout << ans << '\\n';\n    }\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/15842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #286 - Codeforces - Code 3",
          "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N = 1e2 + 5;\n\nint parent[N][N];\n\nint find(int c, int v) {\n    if (parent[c][v] == -1)\n        return v;\n    return parent[c][v] = find(c, parent[c][v]);\n}\n\nvoid unite(int c, int u, int v) {\n    parent[c][find(c, u)] = find(c, v);\n}\n\nint main() {\n    memset(parent, -1, sizeof parent);\n    int n, m;\n    cin >> n >> m;\n    for (int i = 0; i < m; ++i) {\n        int a, b, c;\n        cin >> a >> b >> c;\n        unite(c, a, b);\n    }\n    int q;\n    cin >> q;\n    while (q--) {\n        int u, v, ans = 0;\n        cin >> u >> v;\n        for (int i = 1; i <= 100; ++i)\n            if (find(i, u) == find(i, v))\n                ++ans;\n        cout << ans << '\\n';\n    }\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/15842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #286 - Codeforces - Code 4",
          "code": "Runtime Error",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #286 - Codeforces - Code 5",
          "code": "Memory Limit Exceeded",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #286 - Codeforces - Code 6",
          "code": "7 8\n1 2\n1 3\n2 4\n3 4\n4 5\n4 6\n5 7\n6 7",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #286 - Codeforces - Code 7",
          "code": "7 8\n1 2\n1 3\n2 4\n3 4\n4 5\n4 6\n5 7\n6 7",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #286 - Codeforces - Code 8",
          "code": "Test: #12 ... verdict: WRONG_ANSWER\nInput\n1 30000\n30000\nOutput\n0\nAnswer\n1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #286 - Codeforces - Code 9",
          "code": "Test: #12 ... verdict: WRONG_ANSWER\nInput\n1 30000\n30000\nOutput\n0\nAnswer\n1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #286 - Codeforces - Code 10",
          "code": "unordered_map",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #286 - Codeforces - Code 11",
          "code": "res += (pars[c][u] == pars[c][v]);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #286 - Codeforces - Code 12",
          "code": "res += (pars[c][u] == pars[c][v]);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #286 - Codeforces - Code 13",
          "code": "if (pars[c].find(v) != pars[c].end() && pars[c][u] == pars[c][v]) {\n    res++;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #286 - Codeforces - Code 14",
          "code": "if (pars[c].find(v) != pars[c].end() && pars[c][u] == pars[c][v]) {\n    res++;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #286 Editorial (Complete) - Codeforces - Code 1",
          "code": "dp[i][j - offset]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15889",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #286 Editorial (Complete) - Codeforces - Code 2",
          "code": "components[x] & components[y]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15889",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #286 Editorial (Complete) - Codeforces - Code 3",
          "code": "7 8\n1 2\n2 3\n3 4\n4 1\n4 7\n7 6\n6 5\n5 2\n\nAuthor's Code on my Pc returns 7",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15889",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #286 Editorial (Complete) - Codeforces - Code 4",
          "code": "7 8\n1 2\n2 3\n3 4\n4 1\n4 7\n7 6\n6 5\n5 2\n\nAuthor's Code on my Pc returns 7",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15889",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #286 Editorial (Complete) - Codeforces - Code 5",
          "code": "Also, for each j (1 ≤ j ≤ ti), find the day di, j such that, if the j-th beat on the i-th bamboo is performed before day di, it will be no longer possible to keep the i-th bamboo's height after m days at most X (it can be found by doing simple math).",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15889",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #286 Editorial (Complete) - Codeforces - Code 6",
          "code": "if(target - h[i] <= 0){\n\tt[0]++;\n}else if(target - h[i] > a[i] * (m-1)){\n\tok = 0;\n\tgoto end;\n}else{\n\tt[(target - h[i] + a[i] - 1) / a[i]]++;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15889",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #286 Editorial (Complete) - Codeforces - Code 7",
          "code": "if(target - h[i] <= 0){\n\tt[0]++;\n}else if(target - h[i] > a[i] * (m-1)){\n\tok = 0;\n\tgoto end;\n}else{\n\tt[(target - h[i] + a[i] - 1) / a[i]]++;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15889",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #286 Editorial (Complete) - Codeforces - Code 8",
          "code": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\n#define pb push_back\n#define __addEdge(u, v) [u].push_back(v)\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<vi> vmi;\n\nint n, m;\nvmi G[111];\nvb mark;\n\nvoid dfs(vmi &SG, int u)\n{\n    mark[u] = true;\n    for (int i = 0; i < SG[u].size(); ++i)\n    {\n        int v = SG[u][i];\n        if (!mark[v])\n            dfs(SG, v);\n    }\n}\n\nint main()\n{\n    cin >> n >> m;\n\n    fill(G, G + 111, vmi(n + 1));\n    mark.assign(n + 1, false);\n    for (int i = 0; i < m; ++i)\n    {\n        int u, v, c;\n        cin >> u >> v >> c;\n        G[c]__addEdge(u, v);\n        G[c]__addEdge(v, u);\n    }\n\n    int q;\n    cin >> q;\n\n    while (q--)\n    {\n        int u, v;\n        cin >> u >> v;\n\n        int cnt = 0;\n        for (int k = 1; k <= 100; ++k)\n        {\n            fill(mark.begin(), mark.end(), false);\n            dfs(G[k], u);\n            cnt += mark[v];\n        }\n\n        cout << cnt << endl;\n    }   \n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/15889",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #286 Editorial (Complete) - Codeforces - Code 9",
          "code": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\n#define pb push_back\n#define __addEdge(u, v) [u].push_back(v)\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<vi> vmi;\n\nint n, m;\nvmi G[111];\nvb mark;\n\nvoid dfs(vmi &SG, int u)\n{\n    mark[u] = true;\n    for (int i = 0; i < SG[u].size(); ++i)\n    {\n        int v = SG[u][i];\n        if (!mark[v])\n            dfs(SG, v);\n    }\n}\n\nint main()\n{\n    cin >> n >> m;\n\n    fill(G, G + 111, vmi(n + 1));\n    mark.assign(n + 1, false);\n    for (int i = 0; i < m; ++i)\n    {\n        int u, v, c;\n        cin >> u >> v >> c;\n        G[c]__addEdge(u, v);\n        G[c]__addEdge(v, u);\n    }\n\n    int q;\n    cin >> q;\n\n    while (q--)\n    {\n        int u, v;\n        cin >> u >> v;\n\n        int cnt = 0;\n        for (int k = 1; k <= 100; ++k)\n        {\n            fill(mark.begin(), mark.end(), false);\n            dfs(G[k], u);\n            cnt += mark[v];\n        }\n\n        cout << cnt << endl;\n    }   \n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/15889",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    string s = inf.readLine(\"[a-z]{1,10}\", \"s\");\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    string s = inf.readLine(\"[a-z]{1,10}\", \"s\");\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    string s = inf.readLine(\"[a-z]{1,10}\", \"s\");\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nbool is_palindrome(const string &s)\n{\n    int l = 0, r = int(s.length()) - 1;\n    while (l < r)\n    {\n        if (s[l] != s[r]) return false;\n        ++l; --r;\n    }\n    return true;\n}\n\nbool can_make_palindrome_by_inserting_one_letter(const string &s)\n{\n    int n = int(s.length());\n    for (int pos = 0; pos <= n; ++pos)\n    {\n        for (char c = 'a'; c <= 'z'; ++c)\n        {\n            string t = s.substr(0, pos) + c + s.substr(pos);\n            if (is_palindrome(t))\n            {\n                return true;\n            }\n        }\n    }\n    return false;\n}\n\nbool can_obtain_s_by_deleting_one_char(const string &t, const string &s)\n{\n    if (t.length() != s.length() + 1) return false;\n    for (int i = 0; i < (int)t.length(); ++i)\n    {\n        string u = t.substr(0, i) + t.substr(i + 1);\n        if (u == s) return true;\n    }\n    return false;\n}\n\nint main(int argc, char *argv[])\n{\n    registerTestlibCmd(argc, argv);\n\n    string s = inf.readToken(\"[a-z]{1,10}\", \"s\");\n\n    string t = ouf.readToken();\n\n    if (t == \"NA\")\n    {\n        if (can_make_palindrome_by_inserting_one_letter(s))\n        {\n            quitf(_wa, \"Contestant output NA but it's possible to make a palindrome\");\n        }\n        else\n        {\n            quitf(_ok, \"Correctly output NA\");\n        }\n    }\n    else\n    {\n        int desired_length = s.length() + 1;\n        if ((int)t.length() != desired_length)\n        {\n            quitf(_wa, \"Output string should have length %d\", desired_length);\n        }\n        if (!regex_match(t, regex(\"^[a-z]+$\")))\n        {\n            quitf(_wa, \"Output string should consist of lowercase letters\");\n        }\n        if (!is_palindrome(t))\n        {\n            quitf(_wa, \"Output string is not a palindrome\");\n        }\n        if (!can_obtain_s_by_deleting_one_char(t, s))\n        {\n            quitf(_wa, \"Output string is not formed by inserting exactly one character into s\");\n        }\n        quitf(_ok, \"Correct output\");\n    }\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nbool is_palindrome(const string& s) {\n    int n = s.size();\n    for (int i=0; i<n/2; ++i) {\n        if (s[i] != s[n-1-i])\n            return false;\n    }\n    return true;\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    string s;\n\n    if (type == \"palindrome\") {\n        // Generate palindrome of length n\n        int half = n / 2;\n        for (int i = 0; i < half; ++i) {\n            char c = rnd.next('a', 'z');\n            s.push_back(c);\n        }\n        string t = s;\n        if (n % 2 == 1) {\n            char c = rnd.next('a', 'z');\n            s.push_back(c);\n        }\n        reverse(t.begin(), t.end());\n        s += t;\n\n    } else if (type == \"one_insert_palindrome\") {\n        // Generate palindrome of length n+1 and remove one character\n        int len = n + 1;\n        string s_pal;\n        int half = len / 2;\n        for (int i = 0; i < half; ++i) {\n            char c = rnd.next('a', 'z');\n            s_pal.push_back(c);\n        }\n        string t_pal = s_pal;\n        if (len % 2 == 1) {\n            char c = rnd.next('a', 'z');\n            s_pal.push_back(c);\n        }\n        reverse(t_pal.begin(), t_pal.end());\n        s_pal += t_pal;\n\n        // Remove one character\n        int remove_pos = rnd.next(0, len - 1);\n        for (int i = 0; i < len; ++i) {\n            if (i != remove_pos) {\n                s.push_back(s_pal[i]);\n            }\n        }\n\n    } else if (type == \"no_solution\") {\n        // Generate random strings until one satisfies the condition\n        int max_tries = 10000;\n        bool found_suitable = false;\n        for (int tries = 0; tries < max_tries; ++tries) {\n            s.clear();\n            for (int i=0; i<n; ++i) {\n                char c = rnd.next('a', 'z');\n                s.push_back(c);\n            }\n            bool can_make_palindrome = false;\n            for (int pos = 0; pos <= n && !can_make_palindrome; ++pos) {\n                for (char c = 'a'; c <= 'z'; ++c) {\n                    string s_new = s.substr(0, pos) + c + s.substr(pos);\n                    if (is_palindrome(s_new)) {\n                        can_make_palindrome = true;\n                        break;\n                    }\n                }\n            }\n            if (!can_make_palindrome) {\n                // Found suitable s\n                found_suitable = true;\n                break;\n            }\n            // Else, try again\n        }\n        if (!found_suitable) {\n            // Unable to find suitable string, output any random string as per constraints\n            s.clear();\n            for (int i=0; i<n; ++i) {\n                char c = rnd.next('a', 'z');\n                s.push_back(c);\n            }\n        }\n\n    } else if (type == \"random\") {\n        // Generate random string of length n\n        for (int i=0; i<n; ++i) {\n            char c = rnd.next('a', 'z');\n            s.push_back(c);\n        }\n\n    } else {\n        // Handle unknown type\n        cerr << \"Unknown type: \" << type << endl;\n        return 1;\n    }\n\n    // Output s\n    printf(\"%s\\n\", s.c_str());\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nbool is_palindrome(const string& s) {\n    int n = s.size();\n    for (int i=0; i<n/2; ++i) {\n        if (s[i] != s[n-1-i])\n            return false;\n    }\n    return true;\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    string s;\n\n    if (type == \"palindrome\") {\n        // Generate palindrome of length n\n        int half = n / 2;\n        for (int i = 0; i < half; ++i) {\n            char c = rnd.next('a', 'z');\n            s.push_back(c);\n        }\n        string t = s;\n        if (n % 2 == 1) {\n            char c = rnd.next('a', 'z');\n            s.push_back(c);\n        }\n        reverse(t.begin(), t.end());\n        s += t;\n\n    } else if (type == \"one_insert_palindrome\") {\n        // Generate palindrome of length n+1 and remove one character\n        int len = n + 1;\n        string s_pal;\n        int half = len / 2;\n        for (int i = 0; i < half; ++i) {\n            char c = rnd.next('a', 'z');\n            s_pal.push_back(c);\n        }\n        string t_pal = s_pal;\n        if (len % 2 == 1) {\n            char c = rnd.next('a', 'z');\n            s_pal.push_back(c);\n        }\n        reverse(t_pal.begin(), t_pal.end());\n        s_pal += t_pal;\n\n        // Remove one character\n        int remove_pos = rnd.next(0, len - 1);\n        for (int i = 0; i < len; ++i) {\n            if (i != remove_pos) {\n                s.push_back(s_pal[i]);\n            }\n        }\n\n    } else if (type == \"no_solution\") {\n        // Generate random strings until one satisfies the condition\n        int max_tries = 10000;\n        bool found_suitable = false;\n        for (int tries = 0; tries < max_tries; ++tries) {\n            s.clear();\n            for (int i=0; i<n; ++i) {\n                char c = rnd.next('a', 'z');\n                s.push_back(c);\n            }\n            bool can_make_palindrome = false;\n            for (int pos = 0; pos <= n && !can_make_palindrome; ++pos) {\n                for (char c = 'a'; c <= 'z'; ++c) {\n                    string s_new = s.substr(0, pos) + c + s.substr(pos);\n                    if (is_palindrome(s_new)) {\n                        can_make_palindrome = true;\n                        break;\n                    }\n                }\n            }\n            if (!can_make_palindrome) {\n                // Found suitable s\n                found_suitable = true;\n                break;\n            }\n            // Else, try again\n        }\n        if (!found_suitable) {\n            // Unable to find suitable string, output any random string as per constraints\n            s.clear();\n            for (int i=0; i<n; ++i) {\n                char c = rnd.next('a', 'z');\n                s.push_back(c);\n            }\n        }\n\n    } else if (type == \"random\") {\n        // Generate random string of length n\n        for (int i=0; i<n; ++i) {\n            char c = rnd.next('a', 'z');\n            s.push_back(c);\n        }\n\n    } else {\n        // Handle unknown type\n        cerr << \"Unknown type: \" << type << endl;\n        return 1;\n    }\n\n    // Output s\n    printf(\"%s\\n\", s.c_str());\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -type palindrome\r\n./gen -n 2 -type palindrome\r\n./gen -n 3 -type palindrome\r\n./gen -n 4 -type palindrome\r\n./gen -n 5 -type palindrome\r\n./gen -n 10 -type palindrome\r\n\r\n./gen -n 1 -type one_insert_palindrome\r\n./gen -n 2 -type one_insert_palindrome\r\n./gen -n 3 -type one_insert_palindrome\r\n./gen -n 4 -type one_insert_palindrome\r\n./gen -n 5 -type one_insert_palindrome\r\n./gen -n 10 -type one_insert_palindrome\r\n\r\n./gen -n 2 -type no_solution\r\n./gen -n 3 -type no_solution\r\n./gen -n 5 -type no_solution\r\n./gen -n 6 -type no_solution\r\n./gen -n 7 -type no_solution\r\n./gen -n 8 -type no_solution\r\n./gen -n 10 -type no_solution\r\n\r\n./gen -n 1 -type random\r\n./gen -n 2 -type random\r\n./gen -n 5 -type random\r\n./gen -n 8 -type random\r\n./gen -n 9 -type random\r\n./gen -n 10 -type random",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:40:33.815876",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "505/B",
      "title": "B. Цветной граф мистера Китаюта",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест1 секунда",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеВ первой строке следуют два целых числа через пробел — n и m (2 ≤ n ≤ 100, 1 ≤ m ≤ 100), обозначающие количество вершин и количество ребер, соответственно.В следующих m строках следуют три целых числа через пробел — ai, bi (1 ≤ ai < bi ≤ n) и ci (1 ≤ ci ≤ m). Обратите внимание, что между двумя вершинами может быть несколько ребер. Однако между двумя вершинами не может быть нескольких ребер одного цвета, таким образом, если i ≠ j, то (ai, bi, ci) ≠ (aj, bj, cj).В следующей строке записано целое число — q (1 ≤ q ≤ 100), обозначающее количество запросов.Затем следует q строк по два целых числа через пробел — ui и vi (1 ≤ ui, vi ≤ n). Гарантируется, что ui ≠ vi.",
      "output_spec": "Выходные данныеДля каждого запроса выведите ответ в отдельной строке.",
      "sample_tests": "ПримерыВходные данныеСкопировать4 51 2 11 2 22 3 12 3 32 4 331 23 41 4Выходные данныеСкопировать210Входные данныеСкопировать5 71 5 12 5 13 5 14 5 11 2 22 3 23 4 251 55 12 51 51 4Выходные данныеСкопировать11112",
      "description": "B. Цветной граф мистера Китаюта\n\nограничение по времени на тест1 секунда\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвыводstdout\n\nВходные данныеВ первой строке следуют два целых числа через пробел — n и m (2 ≤ n ≤ 100, 1 ≤ m ≤ 100), обозначающие количество вершин и количество ребер, соответственно.В следующих m строках следуют три целых числа через пробел — ai, bi (1 ≤ ai < bi ≤ n) и ci (1 ≤ ci ≤ m). Обратите внимание, что между двумя вершинами может быть несколько ребер. Однако между двумя вершинами не может быть нескольких ребер одного цвета, таким образом, если i ≠ j, то (ai, bi, ci) ≠ (aj, bj, cj).В следующей строке записано целое число — q (1 ≤ q ≤ 100), обозначающее количество запросов.Затем следует q строк по два целых числа через пробел — ui и vi (1 ≤ ui, vi ≤ n). Гарантируется, что ui ≠ vi.\n\nВходные данные\n\nВыходные данныеДля каждого запроса выведите ответ в отдельной строке.\n\nВыходные данные\n\nВходные данныеСкопировать4 51 2 11 2 22 3 12 3 32 4 331 23 41 4Выходные данныеСкопировать210Входные данныеСкопировать5 71 5 12 5 13 5 14 5 11 2 22 3 23 4 251 55 12 51 51 4Выходные данныеСкопировать11112\n\nВходные данныеСкопировать4 51 2 11 2 22 3 12 3 32 4 331 23 41 4\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать210\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать5 71 5 12 5 13 5 14 5 11 2 22 3 23 4 251 55 12 51 51 4\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать11112\n\nВыходные данныеСкопировать\n\nСкопировать\n\nПримечаниеРассмотрим первый пример.     Рисунок выше иллюстрирует первый пример.    Вершина 1 и вершина 2 соединены цветами 1 и 2.  Вершина 3 и вершина 4 соединены цветом 3.  Вершина 1 и вершина 4 не соединены никаким цветом.",
      "solutions": [
        {
          "title": "Codeforces Round #286 - Codeforces",
          "content": "Hello Codeforces!evima, yosupo and I would like you to participate in Codeforces Round #286. It will be held on Sunday, January 18th at 16:00 MSK. Please note that this round starts on unusual time.Great thanks to Zlobober who helped us prepare this round, Delinur who translated statements into Russian and MikeMirzayanov who created Codeforces and polygon.This is the 3rd time(following #162 and #263) for me, and the 1st time for evima and yosupo to prepare a Codeforces Round.Scores of the problems will be500-1000-1750-1750-2500 for Div.1, and500-1000-1500-2000-2750 for Div.2.In this round, you'll help a man named Mr. kitayuta. I hope he will participate :)The system tests are now over! The top-5 are as follows:Div.1:1.ilyakor2.kcm17003.LayCurse4.RomaWhite5.TankEngineerDiv.2:1.Konijntje2.cpcpc3.zgzjsxshycxksxhsh4.Ronnie0075.sha384Also, special congrats on Petr, who solved problem E in Div.1, which anyone else could not solve.Here are the editorials",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/15842",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 961
        },
        {
          "title": "Codeforces Round #286 Editorial (Complete) - Codeforces",
          "content": "Edit (Jan 22, 2:45 AM UTC): Added Div1E and the editorial is now complete. I am sorry for the delay.Edit (Jan 21, 9:45 AM UTC): Added the explanation for Div1C/2E, and the problem setters' codes. Div1E will need several more hours. Thank you again for your patience.First, here are some statistics on this round: Division Registrants Participants A Accepted B Accepted C Accepted D Accepted E Accepted 1 1364 572 (*) 294 199 8 113 1 (Estimated number of AC by me) 800 (wrong) 500 (wrong) 70 (FAIL) 90 (ok) 5 (wrong) 2 4016 2028 1355 945 41 5 0 (*) Where did the remaining 792 people go? :) We are sorry for terribly underestimating the difficulty of the problems (except Div1D), especially Div1A/2C and Div1C/2E. Div.2 A: 505A - Mr. Kitayuta's Gift[Problem] Given a string, turn it into a palindrome by inserting one letter or state that it is impossible.(Problem by evima)Since the string is short (at most 10 characters), you can simply try every possible way of inserting a letter (\"where\" and \"what\" to insert), and check if the resulting string is a palindrome.The writer's code (C++): 9501249Note: For some strange reason, we (contest managers) cannot submit solutions so that everyone can see them. PraveenDhinwa told us how to do so. Thank you! Div.2 B: 505B - Mr. Kitayuta's Colorful Graph[Problem] Given an undirected graph whose edges are painted in colors, process the queries of the following form: Given two vertices ui and vi, find the number of the colors that satisfies the following condition: the edges of that color connect ui and vi (possibly indirectly). (Problem by hogloid)Since neither the graph nor the number of queries is too large, for each query you can simply count the number of the \"good\" colors (the colors that satisfies the condition) by checking if each color is \"good\". To do that, you can perform Depth First Search (or Breadth First Search) and verify whether you can reach vi from ui traversing only the edges of that color. If you prefer using Union-Find, it will also do the job.The writer's code (DFS, C++)The writer's code (Union-Find, C++) Div.2 C / Div.1 A: 505C - Mr. Kitayuta, the Treasure Hunter[Problem] Since it is hard to summarize this problem, please refer to the official statement.(Problem by yosupo)Below is the explanation from yosupo, translated by me.[From here]Let m be the number of the islands (that is, 30001). First, let us describe a solution with time and memory complexity of O(m2).We will apply Dynamic Programming. let dp[i][j] be the number of the gems that Mr. Kitayuta can collect after he jumps to island i, when the length of his previous jump is j (let us assume that he have not collect the gems on island i). Then, you can calculate the values of the table dp by the following: dp[i][j] = 0, if i ≥ m(actually these islands do not exist, but we can suppose that they exist and when Mr. Kitayuta jumps to these islands, he stops jumping) dp[i][j] =  (the number of the gems on island i)  + max(dp[i + j][j], dp[i + j + 1][j + 1]), if i < m, j = 1(he cannot perform a jump of length 0) dp[i][j] =  (the number of the gems on island i)  + max(dp[i + j - 1][j - 1], dp[i + j][j], dp[i + j + 1][j + 1]), if i < m, j ≥ 2 This solution is unfeasible in terms of both time and memory. However, the following observation makes it an Accepted solution: there are only 491 values of j that we have to consider, which are d - 245, d - 244, d - 243, ..., d + 244 and d + 245.Why? First, let us find the upper bound of j. Suppose Mr. Kitayuta always performs the \"l + 1\" jump (l: the length of the previous jump). Then, he will reach the end of the islands before he performs a jump of length d + 246, becaused + (d + 1) + (d + 2) + ... + (d + 245) ≥ 1 + 2 + ... + 245 = 245·(245 + 1) / 2 = 30135 > 30000. Thus, he will never be able to perform a jump of length d + 246 or longer.Next, let us consider the lower bound of j in a similar way. If d ≤ 246, then obviously he will not be able to perform a jump of length d - 246 or shorter, because the length of a jump must be positive. Suppose Mr. Kitayuta always performs the \"l - 1\" jump, where d ≥ 247. Then, again he will reach the end of the islands before he performs a jump of length d - 246, becaused + (d - 1) + (d - 2) + ... + (d - 245) ≥ 245 + 244 + ... + 1 = 245·(245 + 1) / 2 = 30135 > 30000. Thus, he will never be able to perform a jump of length d - 246 or shorter.Therefore, we have obtained a working solution: similar to the O(m2) one, but we will only consider the value of j between d - 245 and d + 245. The time and memory complexity of this solution will be O(m1.5), since the value \"245\" is slightly larger than .This solution can be implemented by, for example, using a \"normal\" two dimensional array with a offset like this: dp[i][j - offset]. The time limit is set tight in order to fail most of naive solutions with search using std::map or something, so using hash maps (unordered_map) will be risky although the complexity will be the same as the described solution.[End]The writer's code (memoized recursion, C++) Div.2 D / Div.1 B: 505D - Mr. Kitayuta's Technology[Problem] Given an integer n and m pairs of integers (ai, bi) (1 ≤ ai, bi ≤ n), find the minimum number of edges in a directed graph that satisfies the following condition: For each i, there exists a path from vertex ai to vertex bi. (Problem from evima)Let G1 be the directed graph built from the input, and G2 be a directed graph that satisfies the given conditions. What we seek is the minimum number of edges in G2. Also, we say that two vertices u and v in a directed graph are \"weakly connected\" if we can reach v from u by traversing edges, not considering their directions.If a pair (u, v) is present in the input, then vertices u and v must be weakly connected in G2. Therefore, for each weakly connected component (abbreviated to wcc) in G1, the vertices in that component must also be in the same wcc in G2. We can \"merge\" multiple wccs in G1 and create a larger wcc in G2, but for now, let us find the minimum number of edges required in G2 for each wcc in G1 when we do not \"merge\" them. There are two cases to consider: If a wcc in G1 does not have cycles, then we can perform topological sort on that wcc, and we can make a \"chain\" (see the image below) using the topological order to satisfy the conditions. We need (the number of the vertices in the wcc)  - 1 edges, which is the minimum required number since any connected graph with V vertices has at least V - 1 edges. If a wcc in G1 has cycles, then topological sort cannot be applied. We need at least (the number of the vertices in the wcc) edges this time, since any connected graph with V vertices and V - 1 edges is a tree, which does not contain cycles. Actually, this number (the number of the vertices in the wcc) is always achievable by connecting the vertices into a \"ring\" (see the image below), thus it is the minimum required number that we seek. We have found the minimum required number of edges for each wcc in G1 when we do not \"merge\" them. Let us show that \"merging\" wccs in G1 do not reduce the number of required edges. Suppose we combine k( > 1) wccs C1, C2, ..., Ck in G1 into one wcc C in G2. Again, there are two cases to consider: If none of C1, C2, ..., Ck contains cycles, then C will need |C1| + |C2| + ... + |Ck| - 1 edges. However, if we do not combine them, we will only need (|C1| - 1) + (|C2| - 1) + ... + (|Ck| - 1) edges in total, which is fewer. If some of C1, C2, ..., Ck contain cycles, then C will need |C1| + |C2| + ... + |Ck| edges. However, if we do not combine them, we will need(|C1| - noCycles(C1)) + (|C2| - noCycles(C2)) + ... + (|Ck| - noCycles(Ck)  ≤ |C1| + |C2| + ... + |Ck| edges(here, noCycles(Ci) is 1 if Ci do not contain cycles, otherwise 0), thus combining them does not reduce the number of required edges. Thus, we do not need to combine multiple wccs into one wcc in G2 in order to obtain the optimal solution. That is, the final answer to the problem is the sum of the minimum required number of edges for each wcc in G1, when they are considered separately.As for the implementation, detecting cycles in a directed graph with 105 vertices and edges might be a problem if this is your first encounter with it. One possible way is to paste a code that decomposes a graph into strongly connected components. If the size of a strongly connected component is more than one, then that means the component contains cycles.The writer's code (strongly connected component decomposition, C++): 9501202 Div.2 E / Div.1 C: 505E - Mr. Kitayuta vs. Bamboos[Problem] Since it is hard to summarize this problem, please refer to the official statement.(Problem from yosupo)Below is the explanation from yosupo, translated by me.[From here]Let us begin by applying Binary Search. The problem becomes: \"is it possible that all the bamboos are at most X meters after m days?\" It is complicated by the fact that the height does not become negative; the excessive decrease will be wasted. We have found two approaches to this problem. Solution 1 Mr. Kitayuta must beat the i-th bamboo at least max(0, ⌈(hi + m·ai - X) / P⌉) times (let this number ti). Actually, it is not necessary for him to beat it more than this number of times. Thus, let us assume that he beat the i-th bamboo exactly ti times. Also, for each j (1 ≤ j ≤ ti), find the day di, j such that, if the j-th beat on the i-th bamboo is performed before day di, it will be no longer possible to keep the i-th bamboo's height after m days at most X (it can be found by doing simple math). If Mr. Kitayuta can beat the bamboos under this constraint, all the bamboos' heights will become X meters or less after m days. Otherwise, some bamboos' heights will exceed X meters.The time complexity of this solution will be , if we first calculate only ti, then if the sum of ti exceeds km, we skip finding di, j (the answer is \"NO\"). Solution 2 This problem becomes simpler if we simulate Mr. Kitayuta's fight backwards, that is, from day m to day 1. It looks like this:[Problem'] There are n bamboos. At the moment, the height of the i-th bamboo is X meters, and it shrinks ai meters at the beginning of each day. Mr. Kitayuta will play a game. He can use Magic Hammer at most k times per day to increase the height of a bamboo by p meters. If some bamboo's height becomes negative at any moment, he will lose the game immediately. Also, in order for him to win the game, the i-th bamboo's height must be at least hi meters after m days. Is victory possible?Below is an illustration of this \"reverse simulation\": This version is simpler because he is increasing the heights instead of decreasing, thus we do not need to take into account the \"excessive decrease beyond 0 meters\" which will be wasted. Let us consider an optimal strategy. If there exist bamboos whose heights would become negative after day m, he should beat the one that is the earliest to make him lose. Otherwise, he can choose any bamboo whose height would be less than hi meters after day m. Repeat beating the bamboos following this strategy, and see if he can actually claim victory.The writer's implementation of this solution uses a priority queue, and its time complexity is .[End]The tester's code (Solution 1, C++): 9501229The writer's code (Solution 2, C++) Div.1 D: 506D - Mr. Kitayuta's Colorful Graph[Problem] Given an undirected graph whose edges are painted in colors, process the queries of the following form: Given two vertices ui and vi, find the number of the colors that satisfies the following condition: the edges of that color connect ui and vi (possibly indirectly). Note: this is the exact same problem as Div.2 B except the constraints, which are 105 instead of 100.(Problem from hogloid)Below is the explanation from hogloid.[From here]For each color, make a new graph that consists of the edges of the color and vertices connected by the edges. Make UnionFind for each graph, and you can check whether a color connects vertex A and B , using it. For each query, find a vertex which has smaller degree(let this vertex A, and the other vertex B) For each colors such that a edge of the color connects to A, check whether A and B is connected by the color. After answering the query, memorize its tuple — (A, B, answer). If the same query is requested, answer using this information.This will lead to solution.For each query, the complexity is (For each color connects A, find a vertex of B of the color & check whether they are connected) The queries that require longest computing time are, to ask every pair among vertices which have largest degrees. Let the indices of the vertices be , and degrees of the vertices be d1, d2, ...dk. Now, let's fix vertex B as i. The total computing time of the queries such that B is vertex i is . Vertex B can vary from 2 to k. Hence, the total complexity is at most . This complexity is at most .By the way, in C++, using unordered_map, total complexity would be .[End]There will be many other solutions. I will briefly explain one of them which I think is typical.Let ci be the number of colors of the edges incident to vertex i. The sum of all ci does not exceed 2m since each edge increases this sum by at most 2. Thus, there will be at most 450 values of i such that ci ≥ 450 (let B = 450). We will call these vertices large, and the remaining ones small. Using O(m / B·m) = O(m2 / B) time and memory, we can precalculate and store the answer for all the possible queries where at least one of ui and vi is large, then we can immediately answer these queries. For the remaining queries, both ui and vi will be small, therefore it is enough to directly count the color that connects vertices ui and vi in O(B) time. The total time required will be O(m2 / B + Bq). If we choose , we can solve the problem in time.The writer's code (the first solution, C++)The tester's code (the second solution, C++): 9501240 Div.1 E: 506E - Mr. Kitayuta's Gift[Problem] Given a string s and an integer n, find the number of the palindromes that can be obtained by inserting exactly n letters into s.Note: Div.2 A is a similar problem, where n is fixed to 1.(Problem from evima)First of all, let us note that we are asked to count the resulting palindromes, not the ways to obtain them. For example, if we are to insert \"b\" into \"abba\", there are 5 possible positions, but only 3 strings will be produced (\"babba\", \"abbba\" and \"abbab\"). Rather than trying to count the ways of inserting a letter n times and removing the duplicated results, we should directly count the resulting palindrome. To do that, let us reformulate the problem:[Problem'] Given a string s and an integer n, find the number of the palindromes of length |s| + n (let this number be N) that contains s as a subsequence (not necessarily contiguous).Consider constructing a palindrome from both ends, and matching it to s from both left and right. For example, let s = \"abaac\" and N = 11. Let us call the final resulting string t. We first decide what letter to use as t1 and t11 (they must be equal in order for t to be a palindrome). Let us say 'c' is chosen. Now, we have to construct the remaining part of t, that is, t2..t10, so that t2..t10 contains \"abaa\" as a substring (note that the 'c' at the end of s is discarded). Again, we decide what letter to use as t2 and t10. This time we choose 'a'. Then, we have to construct t3..t9, so that it contains \"ba\" as a substring (this time the two 'a's at the both ends of s are discarded). We choose t3 = t9 = 'c'. Next, we construct t4..t8, so that it contains \"ba\" as a substring (this time s remains unchanged). We choose t4 = t8 = 'b'. Then, we construct t5..t7, so that it contains \"a\" as a substring. We choose t5 = t7 = 'a' (it is becoming repetitive, isn't it?). The last part of t, that is, t6, has no restriction (this time we choose a letter for only one position of t, not two). We choose 'd', and we have obtained a palindrome \"cacbadabcac\" that contains s = \"abaac\" as a subsequence.This problem is mostly about analyzing this process carefully.The most naive solution other than literally enumerating all palindromes of length N would be the following Dynamic Programming: let dp[i][left][right] be the number of the palindromes t that can be obtained if you have already decided the leftmost and the rightmost i letters (2i in total), and the substring sleftsleft + 1..sright of s remains unmatched. Each value in this table can be computed in O(1) time. Of course, since i can be up to ⌊n / 2⌋ (n ≤ 109), this solution is far from our goal.Notice that the transitions from dp[i] to dp[i + 1] are the same regardless of i, thus we can calculate the table by matrix exponentiation. However, since there are O(|s|2) possible pairs for (left, right), we will need time, which is actually worse than the naive calculation considering that |s| can be up to 200.This is where we need to observe the process which we have gone through at the beginning more carefully. Let us build a automaton corresponding to the process (the image below). (*) An self-loop with a number means that there are actually that number of edges.A process of producing a palindrome of length N that contains s as a subsequence corresponds to a path of length ⌈N / 2⌉ from the upper-right vertex to the lower-left vertex. Each red vertex has 24 self-loops since the letters at the both ends of the remaining part of s is different, which correspond to two non-self-loop transitions. Similarly, each green vertex has 25 self-loops since the first letter and the last letter of the remaining string is the same, and the blue vertex, the destination, has 26 self-loops, as there are no more non-self-loop transitions available.Here is an important fact: there are not so many possible combination of (n24, n25), where n24 and n25 are the number of times a path from START to GOAL visits a red vertex (with 24 self-loops) and a green vertex (with 25 self-loops), respectively. Why? Each time we leave a red vertex, the length of the remaining unmatched part of s decreases by 1, since exactly one of the two letters at the ends of the remaining part is matched and discarded. Similarly, each time we leave a green vertex, the length of the remaining string decreases by 2, since both of the two letters at the ends are matched and discarded. There is a exception, however: if the length of the remaining string is 1, then it will be a green vertex, but in this case the length will decrease by 1. Thus, for any path from START to GOAL, n24 + 2·n25 will be equal to either |s| or |s| + 1. If we fix n24, then n25 will be uniquely determined by n25 = ⌈(|s| - n24) / 2⌉. Since n24 can only take the value between 0 and |s| - 1, there are at most |s| possible pairs of (n24, n25).With this fact, we are ready to count the paths: let us classify them by the value of n24. For each possible pair of (n24, n25), let us count the number of corresponding paths. To do that, we divide each paths into two parts: first we count the number of paths from START to GOAL, using only non-self-loop transitions. Then, we count the ways of inserting self-loop transitions into each of these paths. The product of these two numbers will be the number that we seek.The first part is straightforward to solve: let dp[left][right][n24] be the number of paths from the vertex that corresponds to the substring sleftsleft + 1..sright, visiting exactly n24 red vertices using only non-self-loop transitions. Each value of the table can be found in O(1) time, thus the whole table can be computed in O(|s|3) time, which is fast enough for the input size (|s| ≤ 200).The main obstacle will be the second part. For example, let us consider the case where s = \"abaac\", N = 11, n24 = 2, which corresponds to the example at the beginning. From the fact we found earlier, n25 = ⌈(|s| - n24) / 2⌉ = ⌈(5 - 2) / 2⌉ = 2. Thus, we have to insert ⌈N / 2⌉ - n24 - n25 = 6 - 2 - 2 = 2 self-loop transitions into this path (the image): The order in which red, green and blue vertices appears in this path does not affect the number of ways of insertion, and can be arbitrary. The number of ways to insert 2 self-loop transitions will be equal to the number of the path of length ⌈N / 2⌉ = 6 from START to GOAL in this automaton (we have to take into account the non-self-loop transitions in it), which can be calculated by matrix exponentiation.Are we done? No! Consider the case s = \"abbb..(|s| - 1 times)..bb\". There are |s| - 1 possible values of n24 (n24 = 1 corresponds to the case where you match and discard the 'a' first, and n24 = |s| - 1 corresponds to the case where you keep the 'a' until s becomes \"ab\"). Thus, you need to perform matrix exponentiation |s| - 1 times, which results in a total of time, which will be too much under the given constraints.There is still hope, though, and here is the climax. Notice that these automata are very similar to each other, and they differ only in the number of the red and green vertices. We can combine these automata into one larger automaton like this (the image): The combined automaton should have |s| - 1 red, ⌈|s| / 2⌉ green and ⌈|s| / 2⌉ blue vertices.By performing matrix exponentiation on this automaton instead of many small automata, we can find all the required value in time, which should be enough. We recommend speeding up matrix multiplication by noticing that the matrix will be upper triangular (6 times faster on paper), since the time limit is not so generous (in order to reject solutions).The problem is almost solved, but there is one more challenge. When N is odd, the situation becomes a little complicated: as we have seen at the beginning, in the last (⌈N / 2⌉-th) step of producing a palindrome we choose a letter for only one position of the resulting string, that is, the center of that string. In other words, the last transition in the path in the automaton we have first built must not be one from a green vertex with a string of length 2 (for example, \"aa\") to GOAL.Let us find the number of the paths that violates this condition and subtract it from the answer. As previously mentioned, for each path n24 + 2·n25 will be equal to either |s| or |s| + 1, and if we fix the value of n24, n25 will be uniquely determined by n25 = ⌈(|s| - n24) / 2⌉. If |s| - n24 is odd, then it means that the last non-self-loop transition is one from a green vertex with a string of length 1, therefore in this case no path will violate the condition. If |s| - n24 is even, then the last non-self-loop trantision is from a green vertex with a string of length 2, thus the paths that does not contain the self-loop from GOAL to itself violate the condition. It will be equal to the number of the paths of length ⌈N / 2⌉ - 1 from START to the vertex just before GOAL, which can be found in a similar way to the second part of the solution.The journey has finally come to an end. Actually, it is also possible to solve this problem in time without matrix exponentiation, but this margin is too small to explain it. I will just paste the link to the code.The writer's code (matrix exponentiation, C++): 9501164The writer's code (without matrix exponentiation, C++): 9501177Congratulations again to Petr who was the only participant to solve this problem in 108 minutes. Also, I would like to give a special mention to rng_58, who was VERY close to solving it in only 63 minutes. He was just one byte away from getting AC (compare 9460984 and 9465440)! If you find a possible error, or have a question, please feel free to ask here. Alternative solutions are also welcome.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/15889",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 505\\s*B"
          },
          "content_length": 23595
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #286 - Codeforces - Code 1",
          "code": "This is the 3rd time(following #162 and #263) for me",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #286 - Codeforces - Code 2",
          "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N = 1e2 + 5;\n\nint parent[N][N];\n\nint find(int c, int v) {\n    if (parent[c][v] == -1)\n        return v;\n    return parent[c][v] = find(c, parent[c][v]);\n}\n\nvoid unite(int c, int u, int v) {\n    parent[c][find(c, u)] = find(c, v);\n}\n\nint main() {\n    memset(parent, -1, sizeof parent);\n    int n, m;\n    cin >> n >> m;\n    for (int i = 0; i < m; ++i) {\n        int a, b, c;\n        cin >> a >> b >> c;\n        unite(c, a, b);\n    }\n    int q;\n    cin >> q;\n    while (q--) {\n        int u, v, ans = 0;\n        cin >> u >> v;\n        for (int i = 1; i <= 100; ++i)\n            if (find(i, u) == find(i, v))\n                ++ans;\n        cout << ans << '\\n';\n    }\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/15842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #286 - Codeforces - Code 3",
          "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N = 1e2 + 5;\n\nint parent[N][N];\n\nint find(int c, int v) {\n    if (parent[c][v] == -1)\n        return v;\n    return parent[c][v] = find(c, parent[c][v]);\n}\n\nvoid unite(int c, int u, int v) {\n    parent[c][find(c, u)] = find(c, v);\n}\n\nint main() {\n    memset(parent, -1, sizeof parent);\n    int n, m;\n    cin >> n >> m;\n    for (int i = 0; i < m; ++i) {\n        int a, b, c;\n        cin >> a >> b >> c;\n        unite(c, a, b);\n    }\n    int q;\n    cin >> q;\n    while (q--) {\n        int u, v, ans = 0;\n        cin >> u >> v;\n        for (int i = 1; i <= 100; ++i)\n            if (find(i, u) == find(i, v))\n                ++ans;\n        cout << ans << '\\n';\n    }\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/15842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #286 - Codeforces - Code 4",
          "code": "Runtime Error",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #286 - Codeforces - Code 5",
          "code": "Memory Limit Exceeded",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #286 - Codeforces - Code 6",
          "code": "7 8\n1 2\n1 3\n2 4\n3 4\n4 5\n4 6\n5 7\n6 7",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #286 - Codeforces - Code 7",
          "code": "7 8\n1 2\n1 3\n2 4\n3 4\n4 5\n4 6\n5 7\n6 7",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #286 - Codeforces - Code 8",
          "code": "Test: #12 ... verdict: WRONG_ANSWER\nInput\n1 30000\n30000\nOutput\n0\nAnswer\n1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #286 - Codeforces - Code 9",
          "code": "Test: #12 ... verdict: WRONG_ANSWER\nInput\n1 30000\n30000\nOutput\n0\nAnswer\n1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #286 - Codeforces - Code 10",
          "code": "unordered_map",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #286 - Codeforces - Code 11",
          "code": "res += (pars[c][u] == pars[c][v]);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #286 - Codeforces - Code 12",
          "code": "res += (pars[c][u] == pars[c][v]);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #286 - Codeforces - Code 13",
          "code": "if (pars[c].find(v) != pars[c].end() && pars[c][u] == pars[c][v]) {\n    res++;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #286 - Codeforces - Code 14",
          "code": "if (pars[c].find(v) != pars[c].end() && pars[c][u] == pars[c][v]) {\n    res++;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #286 Editorial (Complete) - Codeforces - Code 1",
          "code": "dp[i][j - offset]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15889",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #286 Editorial (Complete) - Codeforces - Code 2",
          "code": "components[x] & components[y]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15889",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #286 Editorial (Complete) - Codeforces - Code 3",
          "code": "7 8\n1 2\n2 3\n3 4\n4 1\n4 7\n7 6\n6 5\n5 2\n\nAuthor's Code on my Pc returns 7",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15889",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #286 Editorial (Complete) - Codeforces - Code 4",
          "code": "7 8\n1 2\n2 3\n3 4\n4 1\n4 7\n7 6\n6 5\n5 2\n\nAuthor's Code on my Pc returns 7",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15889",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #286 Editorial (Complete) - Codeforces - Code 5",
          "code": "Also, for each j (1 ≤ j ≤ ti), find the day di, j such that, if the j-th beat on the i-th bamboo is performed before day di, it will be no longer possible to keep the i-th bamboo's height after m days at most X (it can be found by doing simple math).",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15889",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #286 Editorial (Complete) - Codeforces - Code 6",
          "code": "if(target - h[i] <= 0){\n\tt[0]++;\n}else if(target - h[i] > a[i] * (m-1)){\n\tok = 0;\n\tgoto end;\n}else{\n\tt[(target - h[i] + a[i] - 1) / a[i]]++;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15889",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #286 Editorial (Complete) - Codeforces - Code 7",
          "code": "if(target - h[i] <= 0){\n\tt[0]++;\n}else if(target - h[i] > a[i] * (m-1)){\n\tok = 0;\n\tgoto end;\n}else{\n\tt[(target - h[i] + a[i] - 1) / a[i]]++;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15889",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #286 Editorial (Complete) - Codeforces - Code 8",
          "code": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\n#define pb push_back\n#define __addEdge(u, v) [u].push_back(v)\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<vi> vmi;\n\nint n, m;\nvmi G[111];\nvb mark;\n\nvoid dfs(vmi &SG, int u)\n{\n    mark[u] = true;\n    for (int i = 0; i < SG[u].size(); ++i)\n    {\n        int v = SG[u][i];\n        if (!mark[v])\n            dfs(SG, v);\n    }\n}\n\nint main()\n{\n    cin >> n >> m;\n\n    fill(G, G + 111, vmi(n + 1));\n    mark.assign(n + 1, false);\n    for (int i = 0; i < m; ++i)\n    {\n        int u, v, c;\n        cin >> u >> v >> c;\n        G[c]__addEdge(u, v);\n        G[c]__addEdge(v, u);\n    }\n\n    int q;\n    cin >> q;\n\n    while (q--)\n    {\n        int u, v;\n        cin >> u >> v;\n\n        int cnt = 0;\n        for (int k = 1; k <= 100; ++k)\n        {\n            fill(mark.begin(), mark.end(), false);\n            dfs(G[k], u);\n            cnt += mark[v];\n        }\n\n        cout << cnt << endl;\n    }   \n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/15889",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #286 Editorial (Complete) - Codeforces - Code 9",
          "code": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\n#define pb push_back\n#define __addEdge(u, v) [u].push_back(v)\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<vi> vmi;\n\nint n, m;\nvmi G[111];\nvb mark;\n\nvoid dfs(vmi &SG, int u)\n{\n    mark[u] = true;\n    for (int i = 0; i < SG[u].size(); ++i)\n    {\n        int v = SG[u][i];\n        if (!mark[v])\n            dfs(SG, v);\n    }\n}\n\nint main()\n{\n    cin >> n >> m;\n\n    fill(G, G + 111, vmi(n + 1));\n    mark.assign(n + 1, false);\n    for (int i = 0; i < m; ++i)\n    {\n        int u, v, c;\n        cin >> u >> v >> c;\n        G[c]__addEdge(u, v);\n        G[c]__addEdge(v, u);\n    }\n\n    int q;\n    cin >> q;\n\n    while (q--)\n    {\n        int u, v;\n        cin >> u >> v;\n\n        int cnt = 0;\n        for (int k = 1; k <= 100; ++k)\n        {\n            fill(mark.begin(), mark.end(), false);\n            dfs(G[k], u);\n            cnt += mark[v];\n        }\n\n        cout << cnt << endl;\n    }   \n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/15889",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(2, 100, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 100, \"m\");\n    inf.readEoln();\n\n    set<tuple<int, int, int>> edgeSet; // to check for duplicate edges\n    for (int i = 0; i < m; ++i) {\n        int ai = inf.readInt(1, n, \"ai\");\n        inf.readSpace();\n        int bi = inf.readInt(1, n, \"bi\");\n        inf.readSpace();\n        int ci = inf.readInt(1, m, \"ci\");\n        inf.readEoln();\n\n        ensuref(ai < bi, \"Edge endpoints ai should be less than bi, but ai=%d, bi=%d\", ai, bi);\n\n        // Check for duplicate edges with same color between two vertices\n        ensuref(edgeSet.count(make_tuple(ai, bi, ci)) == 0, \"Multiple edges with same color %d between vertices %d and %d\", ci, ai, bi);\n        edgeSet.insert(make_tuple(ai, bi, ci));\n    }\n\n    int q = inf.readInt(1, 100, \"q\");\n    inf.readEoln();\n\n    for (int i = 0; i < q; ++i) {\n        int ui = inf.readInt(1, n, \"ui\");\n        inf.readSpace();\n        int vi = inf.readInt(1, n, \"vi\");\n        inf.readEoln();\n\n        ensuref(ui != vi, \"It is guaranteed that ui != vi in query %d, but ui=%d, vi=%d\", i+1, ui, vi);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(2, 100, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 100, \"m\");\n    inf.readEoln();\n\n    set<tuple<int, int, int>> edgeSet; // to check for duplicate edges\n    for (int i = 0; i < m; ++i) {\n        int ai = inf.readInt(1, n, \"ai\");\n        inf.readSpace();\n        int bi = inf.readInt(1, n, \"bi\");\n        inf.readSpace();\n        int ci = inf.readInt(1, m, \"ci\");\n        inf.readEoln();\n\n        ensuref(ai < bi, \"Edge endpoints ai should be less than bi, but ai=%d, bi=%d\", ai, bi);\n\n        // Check for duplicate edges with same color between two vertices\n        ensuref(edgeSet.count(make_tuple(ai, bi, ci)) == 0, \"Multiple edges with same color %d between vertices %d and %d\", ci, ai, bi);\n        edgeSet.insert(make_tuple(ai, bi, ci));\n    }\n\n    int q = inf.readInt(1, 100, \"q\");\n    inf.readEoln();\n\n    for (int i = 0; i < q; ++i) {\n        int ui = inf.readInt(1, n, \"ui\");\n        inf.readSpace();\n        int vi = inf.readInt(1, n, \"vi\");\n        inf.readEoln();\n\n        ensuref(ui != vi, \"It is guaranteed that ui != vi in query %d, but ui=%d, vi=%d\", i+1, ui, vi);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(2, 100, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 100, \"m\");\n    inf.readEoln();\n\n    set<tuple<int, int, int>> edgeSet; // to check for duplicate edges\n    for (int i = 0; i < m; ++i) {\n        int ai = inf.readInt(1, n, \"ai\");\n        inf.readSpace();\n        int bi = inf.readInt(1, n, \"bi\");\n        inf.readSpace();\n        int ci = inf.readInt(1, m, \"ci\");\n        inf.readEoln();\n\n        ensuref(ai < bi, \"Edge endpoints ai should be less than bi, but ai=%d, bi=%d\", ai, bi);\n\n        // Check for duplicate edges with same color between two vertices\n        ensuref(edgeSet.count(make_tuple(ai, bi, ci)) == 0, \"Multiple edges with same color %d between vertices %d and %d\", ci, ai, bi);\n        edgeSet.insert(make_tuple(ai, bi, ci));\n    }\n\n    int q = inf.readInt(1, 100, \"q\");\n    inf.readEoln();\n\n    for (int i = 0; i < q; ++i) {\n        int ui = inf.readInt(1, n, \"ui\");\n        inf.readSpace();\n        int vi = inf.readInt(1, n, \"vi\");\n        inf.readEoln();\n\n        ensuref(ui != vi, \"It is guaranteed that ui != vi in query %d, but ui=%d, vi=%d\", i+1, ui, vi);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");          // Number of vertices\n    int m_param = opt<int>(\"m\");    // Number of edges (maximum)\n    int c_param = opt<int>(\"c\", m_param);   // Number of colors\n    int q = opt<int>(\"q\", 100);     // Number of queries (default 100)\n    string type = opt<string>(\"type\", \"random\");\n\n    // Enforce constraints\n    n = max(2, min(n, 100));\n    int m = m_param;\n    int c = c_param;\n\n    vector<pair<int,int>> edges;\n    set<tuple<int,int,int>> edge_set; // To avoid duplicate edges\n    vector<int> colors;\n\n    if (type == \"complete\") {\n        // Generate a complete graph\n        m = min(m_param, n * (n - 1) / 2);\n        c = min(c_param, m);\n        int color = 1;\n        for (int i = 1; i <= n && edges.size() < m; ++i) {\n            for (int j = i + 1; j <= n && edges.size() < m; ++j) {\n                edges.push_back({i, j});\n                colors.push_back(color);\n                if (c > 1) color = color % c + 1;\n            }\n        }\n    } else if (type == \"chain\") {\n        // Generate a chain\n        m = n - 1;\n        c = min(c_param, m);\n        vector<int> nodes(n);\n        for(int i=0;i<n;++i)\n            nodes[i]=i+1;\n        shuffle(nodes.begin(), nodes.end());\n        int color = 1;\n        for (int i = 0; i < n -1; ++i) {\n            int a = nodes[i];\n            int b = nodes[i+1];\n            if (a > b) swap(a,b);\n            edges.push_back({a,b});\n            colors.push_back(color);\n            if (c > 1) color = (color % c) + 1;\n        }\n    } else if (type == \"star\") {\n        // Generate a star graph\n        m = n - 1;\n        c = min(c_param, m);\n        int center = rnd.next(1, n);\n        vector<int> nodes;\n        for (int i = 1; i <= n; ++i)\n            if (i != center) nodes.push_back(i);\n        shuffle(nodes.begin(), nodes.end());\n        int color = 1;\n        for (int i = 0; i < nodes.size(); ++i) {\n            int a = min(center, nodes[i]);\n            int b = max(center, nodes[i]);\n            edges.push_back({a, b});\n            colors.push_back(color);\n            if (c > 1) color = (color % c) + 1;\n        }\n    } else if (type == \"same_color\") {\n        // All edges have the same color\n        c = 1;\n        m = min(m_param, n * (n - 1) / 2);\n        while (edges.size() < m) {\n            int a = rnd.next(1, n);\n            int b = rnd.next(1, n);\n            if (a == b) continue;\n            if (a > b) swap(a, b);\n            auto edge = make_tuple(a, b, 1);\n            if (edge_set.count(edge)) continue;\n            edges.push_back({a, b});\n            colors.push_back(1);\n            edge_set.insert(edge);\n        }\n    } else if (type == \"different_colors\") {\n        // Each edge has a different color\n        m = min(m_param, 100);\n        c = m;\n        for (int i = 0; i < m; ) {\n            int a = rnd.next(1, n);\n            int b = rnd.next(1, n);\n            if (a == b) continue;\n            if (a > b) swap(a, b);\n            int color = i + 1;\n            auto edge = make_tuple(a, b, color);\n            if (edge_set.count(edge)) continue;\n            edges.push_back({a, b});\n            colors.push_back(color);\n            edge_set.insert(edge);\n            ++i;\n        }\n    } else if (type == \"color_components\") {\n        // Each color forms its own connected component\n        int num_colors = c_param;\n        c = num_colors;\n        vector<int> nodes(n);\n        for (int i = 0; i < n; ++i)\n            nodes[i] = i+1;\n        shuffle(nodes.begin(), nodes.end());\n        int per_component = n / num_colors;\n        int left_over = n % num_colors;\n        int idx = 0;\n        int color = 1;\n        while (edges.size() < m && color <= num_colors) {\n            int cnt = per_component + (left_over > 0 ? 1 : 0);\n            if (left_over > 0) left_over--;\n            if (cnt >= 2) {\n                for (int j = 0; j < cnt - 1 && edges.size() < m; ++j) {\n                    int a = nodes[idx + j];\n                    int b = nodes[idx + j + 1];\n                    if (a > b) swap(a,b);\n                    edges.push_back({a,b});\n                    colors.push_back(color);\n                }\n            }\n            idx += cnt;\n            color++;\n        }\n    } else {\n        // Generate random edges\n        c = min(c_param, m_param);\n        while (edges.size() < m) {\n            int a = rnd.next(1, n);\n            int b = rnd.next(1, n);\n            if (a == b) continue;\n            if (a > b) swap(a, b);\n            int color = rnd.next(1, c);\n            auto edge = make_tuple(a, b, color);\n            if (edge_set.count(edge)) continue;\n            edges.push_back({a, b});\n            colors.push_back(color);\n            edge_set.insert(edge);\n        }\n    }\n\n    // Adjust m to actual number of edges\n    m = edges.size();\n\n    // Output n and m\n    printf(\"%d %d\\n\", n, m);\n    for (int i = 0; i < m; ++i) {\n        int a = edges[i].first;\n        int b = edges[i].second;\n        int color = colors[i];\n        printf(\"%d %d %d\\n\", a, b, color);\n    }\n\n    // Generate q queries\n    q = min(q, n*(n-1)/2);\n    printf(\"%d\\n\", q);\n    set<pair<int,int>> query_set;\n    for (int i = 0; i < q; ) {\n        int u = rnd.next(1, n);\n        int v = rnd.next(1, n);\n        if (u == v) continue;\n        if (query_set.count({u, v}) || query_set.count({v, u})) continue;\n        printf(\"%d %d\\n\", u, v);\n        query_set.insert({u, v});\n        ++i;\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");          // Number of vertices\n    int m_param = opt<int>(\"m\");    // Number of edges (maximum)\n    int c_param = opt<int>(\"c\", m_param);   // Number of colors\n    int q = opt<int>(\"q\", 100);     // Number of queries (default 100)\n    string type = opt<string>(\"type\", \"random\");\n\n    // Enforce constraints\n    n = max(2, min(n, 100));\n    int m = m_param;\n    int c = c_param;\n\n    vector<pair<int,int>> edges;\n    set<tuple<int,int,int>> edge_set; // To avoid duplicate edges\n    vector<int> colors;\n\n    if (type == \"complete\") {\n        // Generate a complete graph\n        m = min(m_param, n * (n - 1) / 2);\n        c = min(c_param, m);\n        int color = 1;\n        for (int i = 1; i <= n && edges.size() < m; ++i) {\n            for (int j = i + 1; j <= n && edges.size() < m; ++j) {\n                edges.push_back({i, j});\n                colors.push_back(color);\n                if (c > 1) color = color % c + 1;\n            }\n        }\n    } else if (type == \"chain\") {\n        // Generate a chain\n        m = n - 1;\n        c = min(c_param, m);\n        vector<int> nodes(n);\n        for(int i=0;i<n;++i)\n            nodes[i]=i+1;\n        shuffle(nodes.begin(), nodes.end());\n        int color = 1;\n        for (int i = 0; i < n -1; ++i) {\n            int a = nodes[i];\n            int b = nodes[i+1];\n            if (a > b) swap(a,b);\n            edges.push_back({a,b});\n            colors.push_back(color);\n            if (c > 1) color = (color % c) + 1;\n        }\n    } else if (type == \"star\") {\n        // Generate a star graph\n        m = n - 1;\n        c = min(c_param, m);\n        int center = rnd.next(1, n);\n        vector<int> nodes;\n        for (int i = 1; i <= n; ++i)\n            if (i != center) nodes.push_back(i);\n        shuffle(nodes.begin(), nodes.end());\n        int color = 1;\n        for (int i = 0; i < nodes.size(); ++i) {\n            int a = min(center, nodes[i]);\n            int b = max(center, nodes[i]);\n            edges.push_back({a, b});\n            colors.push_back(color);\n            if (c > 1) color = (color % c) + 1;\n        }\n    } else if (type == \"same_color\") {\n        // All edges have the same color\n        c = 1;\n        m = min(m_param, n * (n - 1) / 2);\n        while (edges.size() < m) {\n            int a = rnd.next(1, n);\n            int b = rnd.next(1, n);\n            if (a == b) continue;\n            if (a > b) swap(a, b);\n            auto edge = make_tuple(a, b, 1);\n            if (edge_set.count(edge)) continue;\n            edges.push_back({a, b});\n            colors.push_back(1);\n            edge_set.insert(edge);\n        }\n    } else if (type == \"different_colors\") {\n        // Each edge has a different color\n        m = min(m_param, 100);\n        c = m;\n        for (int i = 0; i < m; ) {\n            int a = rnd.next(1, n);\n            int b = rnd.next(1, n);\n            if (a == b) continue;\n            if (a > b) swap(a, b);\n            int color = i + 1;\n            auto edge = make_tuple(a, b, color);\n            if (edge_set.count(edge)) continue;\n            edges.push_back({a, b});\n            colors.push_back(color);\n            edge_set.insert(edge);\n            ++i;\n        }\n    } else if (type == \"color_components\") {\n        // Each color forms its own connected component\n        int num_colors = c_param;\n        c = num_colors;\n        vector<int> nodes(n);\n        for (int i = 0; i < n; ++i)\n            nodes[i] = i+1;\n        shuffle(nodes.begin(), nodes.end());\n        int per_component = n / num_colors;\n        int left_over = n % num_colors;\n        int idx = 0;\n        int color = 1;\n        while (edges.size() < m && color <= num_colors) {\n            int cnt = per_component + (left_over > 0 ? 1 : 0);\n            if (left_over > 0) left_over--;\n            if (cnt >= 2) {\n                for (int j = 0; j < cnt - 1 && edges.size() < m; ++j) {\n                    int a = nodes[idx + j];\n                    int b = nodes[idx + j + 1];\n                    if (a > b) swap(a,b);\n                    edges.push_back({a,b});\n                    colors.push_back(color);\n                }\n            }\n            idx += cnt;\n            color++;\n        }\n    } else {\n        // Generate random edges\n        c = min(c_param, m_param);\n        while (edges.size() < m) {\n            int a = rnd.next(1, n);\n            int b = rnd.next(1, n);\n            if (a == b) continue;\n            if (a > b) swap(a, b);\n            int color = rnd.next(1, c);\n            auto edge = make_tuple(a, b, color);\n            if (edge_set.count(edge)) continue;\n            edges.push_back({a, b});\n            colors.push_back(color);\n            edge_set.insert(edge);\n        }\n    }\n\n    // Adjust m to actual number of edges\n    m = edges.size();\n\n    // Output n and m\n    printf(\"%d %d\\n\", n, m);\n    for (int i = 0; i < m; ++i) {\n        int a = edges[i].first;\n        int b = edges[i].second;\n        int color = colors[i];\n        printf(\"%d %d %d\\n\", a, b, color);\n    }\n\n    // Generate q queries\n    q = min(q, n*(n-1)/2);\n    printf(\"%d\\n\", q);\n    set<pair<int,int>> query_set;\n    for (int i = 0; i < q; ) {\n        int u = rnd.next(1, n);\n        int v = rnd.next(1, n);\n        if (u == v) continue;\n        if (query_set.count({u, v}) || query_set.count({v, u})) continue;\n        printf(\"%d %d\\n\", u, v);\n        query_set.insert({u, v});\n        ++i;\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 2 -m 1 -c 1 -type chain\n./gen -n 5 -m 4 -c 1 -type chain\n./gen -n 100 -m 99 -c 1 -type chain\n\n./gen -n 100 -m 100 -c 1 -type complete\n./gen -n 15 -m 100 -c 100 -type complete\n./gen -n 100 -m 100 -c 100 -type complete\n\n./gen -n 100 -m 99 -c 99 -type star\n./gen -n 100 -m 99 -c 1 -type star\n./gen -n 10 -m 9 -c 1 -type star\n\n./gen -n 100 -m 90 -c 1 -type same_color\n./gen -n 100 -m 100 -c 1 -type same_color\n\n./gen -n 100 -m 100 -c 100 -type different_colors\n./gen -n 50 -m 50 -c 50 -type different_colors\n\n./gen -n 100 -m 100 -c 10 -type random\n./gen -n 100 -m 100 -c 100 -type random\n./gen -n 10 -m 20 -c 5 -type random\n./gen -n 2 -m 1 -c 1 -type random\n\n./gen -n 10 -m 9 -c 3 -type color_components -c 3\n./gen -n 100 -m 99 -c 99 -type color_components -c 99\n./gen -n 100 -m 100 -c 99 -type color_components -c 2\n\n./gen -n 100 -m 100 -c 50 -type random -q 100\n./gen -n 100 -m 50 -c 5 -type random -q 50\n\n./gen -n 2 -m 1 -c 1 -type same_color -q 1\n./gen -n 5 -m 4 -c 1 -type same_color -q 5\n\n./gen -n 100 -m 1 -c 1 -type random -q 100\n\n./gen -n 100 -m 100 -c 1 -type chain -q 100\n\n./gen -n 100 -m 100 -c 1 -type chain -q 100\n\n./gen -n 100 -m 100 -c 100 -type random -q 100\n\n./gen -n 100 -m 100 -c 1 -type same_color -q 100\n\n./gen -n 100 -m 50 -c 50 -type different_colors -q 50\n\n./gen -n 100 -m 100 -c 1 -type star -q 100\n\n# Edge cases for minimum n and m\n./gen -n 2 -m 1 -c 1 -type random -q 1\n./gen -n 2 -m 1 -c 1 -type same_color -q 1\n./gen -n 2 -m 1 -c 1 -type chain -q 1\n./gen -n 2 -m 1 -c 1 -type different_colors -q 1\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:40:35.873861",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "505/C",
      "title": "C. Mr. Kitayuta, the Treasure Hunter",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line of the input contains two space-separated integers n and d (1 ≤ n, d ≤ 30000), denoting the number of the gems in the Shuseki Islands and the length of the Mr. Kitayuta's first jump, respectively.The next n lines describe the location of the gems. The i-th of them (1 ≤ i ≤ n) contains a integer pi (d ≤ p1 ≤ p2 ≤ ... ≤ pn ≤ 30000), denoting the number of the island that contains the i-th gem.",
      "output_spec": "OutputPrint the maximum number of gems that Mr. Kitayuta can collect.",
      "sample_tests": "ExamplesInputCopy4 1010212727OutputCopy3InputCopy8 8919283645556678OutputCopy6InputCopy13 788916171718212324242630OutputCopy4",
      "description": "C. Mr. Kitayuta, the Treasure Hunter\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nThe Shuseki Islands are an archipelago of 30001 small islands in the Yutampo Sea. The islands are evenly spaced along a line, numbered from 0 to 30000 from the west to the east. These islands are known to contain many treasures. There are n gems in the Shuseki Islands in total, and the i-th gem is located on island pi.Mr. Kitayuta has just arrived at island 0. With his great jumping ability, he will repeatedly perform jumps between islands to the east according to the following process:   First, he will jump from island 0 to island d.  After that, he will continue jumping according to the following rule. Let l be the length of the previous jump, that is, if his previous jump was from island prev to island cur, let l = cur - prev. He will perform a jump of length l - 1, l or l + 1 to the east. That is, he will jump to island (cur + l - 1), (cur + l) or (cur + l + 1) (if they exist). The length of a jump must be positive, that is, he cannot perform a jump of length 0 when l = 1. If there is no valid destination, he will stop jumping. Mr. Kitayuta will collect the gems on the islands visited during the process. Find the maximum number of gems that he can collect.\n\nInputThe first line of the input contains two space-separated integers n and d (1 ≤ n, d ≤ 30000), denoting the number of the gems in the Shuseki Islands and the length of the Mr. Kitayuta's first jump, respectively.The next n lines describe the location of the gems. The i-th of them (1 ≤ i ≤ n) contains a integer pi (d ≤ p1 ≤ p2 ≤ ... ≤ pn ≤ 30000), denoting the number of the island that contains the i-th gem.\n\nOutputPrint the maximum number of gems that Mr. Kitayuta can collect.\n\nInputCopy4 1010212727OutputCopy3InputCopy8 8919283645556678OutputCopy6InputCopy13 788916171718212324242630OutputCopy4\n\nInputCopy4 1010212727\n\nOutputCopy3\n\nInputCopy8 8919283645556678\n\nOutputCopy6\n\nInputCopy13 788916171718212324242630\n\nOutputCopy4\n\nNoteIn the first sample, the optimal route is 0  →  10 (+1 gem)  →  19  →  27 (+2 gems)  → ...\u0001In the second sample, the optimal route is 0  →  8  →  15  →  21 →  28 (+1 gem)  →  36 (+1 gem)  →  45 (+1 gem)  →  55 (+1 gem)  →  66 (+1 gem)  →  78 (+1 gem)  → ...In the third sample, the optimal route is 0  →  7  →  13  →  18 (+1 gem)  →  24 (+2 gems)  →  30 (+1 gem)  → ...",
      "solutions": [
        {
          "title": "Codeforces Round #286 - Codeforces",
          "content": "Hello Codeforces!evima, yosupo and I would like you to participate in Codeforces Round #286. It will be held on Sunday, January 18th at 16:00 MSK. Please note that this round starts on unusual time.Great thanks to Zlobober who helped us prepare this round, Delinur who translated statements into Russian and MikeMirzayanov who created Codeforces and polygon.This is the 3rd time(following #162 and #263) for me, and the 1st time for evima and yosupo to prepare a Codeforces Round.Scores of the problems will be500-1000-1750-1750-2500 for Div.1, and500-1000-1500-2000-2750 for Div.2.In this round, you'll help a man named Mr. kitayuta. I hope he will participate :)The system tests are now over! The top-5 are as follows:Div.1:1.ilyakor2.kcm17003.LayCurse4.RomaWhite5.TankEngineerDiv.2:1.Konijntje2.cpcpc3.zgzjsxshycxksxhsh4.Ronnie0075.sha384Also, special congrats on Petr, who solved problem E in Div.1, which anyone else could not solve.Here are the editorials",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/15842",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 961
        },
        {
          "title": "Codeforces Round #286 Editorial (Complete) - Codeforces",
          "content": "Edit (Jan 22, 2:45 AM UTC): Added Div1E and the editorial is now complete. I am sorry for the delay.Edit (Jan 21, 9:45 AM UTC): Added the explanation for Div1C/2E, and the problem setters' codes. Div1E will need several more hours. Thank you again for your patience.First, here are some statistics on this round: Division Registrants Participants A Accepted B Accepted C Accepted D Accepted E Accepted 1 1364 572 (*) 294 199 8 113 1 (Estimated number of AC by me) 800 (wrong) 500 (wrong) 70 (FAIL) 90 (ok) 5 (wrong) 2 4016 2028 1355 945 41 5 0 (*) Where did the remaining 792 people go? :) We are sorry for terribly underestimating the difficulty of the problems (except Div1D), especially Div1A/2C and Div1C/2E. Div.2 A: 505A - Mr. Kitayuta's Gift[Problem] Given a string, turn it into a palindrome by inserting one letter or state that it is impossible.(Problem by evima)Since the string is short (at most 10 characters), you can simply try every possible way of inserting a letter (\"where\" and \"what\" to insert), and check if the resulting string is a palindrome.The writer's code (C++): 9501249Note: For some strange reason, we (contest managers) cannot submit solutions so that everyone can see them. PraveenDhinwa told us how to do so. Thank you! Div.2 B: 505B - Mr. Kitayuta's Colorful Graph[Problem] Given an undirected graph whose edges are painted in colors, process the queries of the following form: Given two vertices ui and vi, find the number of the colors that satisfies the following condition: the edges of that color connect ui and vi (possibly indirectly). (Problem by hogloid)Since neither the graph nor the number of queries is too large, for each query you can simply count the number of the \"good\" colors (the colors that satisfies the condition) by checking if each color is \"good\". To do that, you can perform Depth First Search (or Breadth First Search) and verify whether you can reach vi from ui traversing only the edges of that color. If you prefer using Union-Find, it will also do the job.The writer's code (DFS, C++)The writer's code (Union-Find, C++) Div.2 C / Div.1 A: 505C - Mr. Kitayuta, the Treasure Hunter[Problem] Since it is hard to summarize this problem, please refer to the official statement.(Problem by yosupo)Below is the explanation from yosupo, translated by me.[From here]Let m be the number of the islands (that is, 30001). First, let us describe a solution with time and memory complexity of O(m2).We will apply Dynamic Programming. let dp[i][j] be the number of the gems that Mr. Kitayuta can collect after he jumps to island i, when the length of his previous jump is j (let us assume that he have not collect the gems on island i). Then, you can calculate the values of the table dp by the following: dp[i][j] = 0, if i ≥ m(actually these islands do not exist, but we can suppose that they exist and when Mr. Kitayuta jumps to these islands, he stops jumping) dp[i][j] =  (the number of the gems on island i)  + max(dp[i + j][j], dp[i + j + 1][j + 1]), if i < m, j = 1(he cannot perform a jump of length 0) dp[i][j] =  (the number of the gems on island i)  + max(dp[i + j - 1][j - 1], dp[i + j][j], dp[i + j + 1][j + 1]), if i < m, j ≥ 2 This solution is unfeasible in terms of both time and memory. However, the following observation makes it an Accepted solution: there are only 491 values of j that we have to consider, which are d - 245, d - 244, d - 243, ..., d + 244 and d + 245.Why? First, let us find the upper bound of j. Suppose Mr. Kitayuta always performs the \"l + 1\" jump (l: the length of the previous jump). Then, he will reach the end of the islands before he performs a jump of length d + 246, becaused + (d + 1) + (d + 2) + ... + (d + 245) ≥ 1 + 2 + ... + 245 = 245·(245 + 1) / 2 = 30135 > 30000. Thus, he will never be able to perform a jump of length d + 246 or longer.Next, let us consider the lower bound of j in a similar way. If d ≤ 246, then obviously he will not be able to perform a jump of length d - 246 or shorter, because the length of a jump must be positive. Suppose Mr. Kitayuta always performs the \"l - 1\" jump, where d ≥ 247. Then, again he will reach the end of the islands before he performs a jump of length d - 246, becaused + (d - 1) + (d - 2) + ... + (d - 245) ≥ 245 + 244 + ... + 1 = 245·(245 + 1) / 2 = 30135 > 30000. Thus, he will never be able to perform a jump of length d - 246 or shorter.Therefore, we have obtained a working solution: similar to the O(m2) one, but we will only consider the value of j between d - 245 and d + 245. The time and memory complexity of this solution will be O(m1.5), since the value \"245\" is slightly larger than .This solution can be implemented by, for example, using a \"normal\" two dimensional array with a offset like this: dp[i][j - offset]. The time limit is set tight in order to fail most of naive solutions with search using std::map or something, so using hash maps (unordered_map) will be risky although the complexity will be the same as the described solution.[End]The writer's code (memoized recursion, C++) Div.2 D / Div.1 B: 505D - Mr. Kitayuta's Technology[Problem] Given an integer n and m pairs of integers (ai, bi) (1 ≤ ai, bi ≤ n), find the minimum number of edges in a directed graph that satisfies the following condition: For each i, there exists a path from vertex ai to vertex bi. (Problem from evima)Let G1 be the directed graph built from the input, and G2 be a directed graph that satisfies the given conditions. What we seek is the minimum number of edges in G2. Also, we say that two vertices u and v in a directed graph are \"weakly connected\" if we can reach v from u by traversing edges, not considering their directions.If a pair (u, v) is present in the input, then vertices u and v must be weakly connected in G2. Therefore, for each weakly connected component (abbreviated to wcc) in G1, the vertices in that component must also be in the same wcc in G2. We can \"merge\" multiple wccs in G1 and create a larger wcc in G2, but for now, let us find the minimum number of edges required in G2 for each wcc in G1 when we do not \"merge\" them. There are two cases to consider: If a wcc in G1 does not have cycles, then we can perform topological sort on that wcc, and we can make a \"chain\" (see the image below) using the topological order to satisfy the conditions. We need (the number of the vertices in the wcc)  - 1 edges, which is the minimum required number since any connected graph with V vertices has at least V - 1 edges. If a wcc in G1 has cycles, then topological sort cannot be applied. We need at least (the number of the vertices in the wcc) edges this time, since any connected graph with V vertices and V - 1 edges is a tree, which does not contain cycles. Actually, this number (the number of the vertices in the wcc) is always achievable by connecting the vertices into a \"ring\" (see the image below), thus it is the minimum required number that we seek. We have found the minimum required number of edges for each wcc in G1 when we do not \"merge\" them. Let us show that \"merging\" wccs in G1 do not reduce the number of required edges. Suppose we combine k( > 1) wccs C1, C2, ..., Ck in G1 into one wcc C in G2. Again, there are two cases to consider: If none of C1, C2, ..., Ck contains cycles, then C will need |C1| + |C2| + ... + |Ck| - 1 edges. However, if we do not combine them, we will only need (|C1| - 1) + (|C2| - 1) + ... + (|Ck| - 1) edges in total, which is fewer. If some of C1, C2, ..., Ck contain cycles, then C will need |C1| + |C2| + ... + |Ck| edges. However, if we do not combine them, we will need(|C1| - noCycles(C1)) + (|C2| - noCycles(C2)) + ... + (|Ck| - noCycles(Ck)  ≤ |C1| + |C2| + ... + |Ck| edges(here, noCycles(Ci) is 1 if Ci do not contain cycles, otherwise 0), thus combining them does not reduce the number of required edges. Thus, we do not need to combine multiple wccs into one wcc in G2 in order to obtain the optimal solution. That is, the final answer to the problem is the sum of the minimum required number of edges for each wcc in G1, when they are considered separately.As for the implementation, detecting cycles in a directed graph with 105 vertices and edges might be a problem if this is your first encounter with it. One possible way is to paste a code that decomposes a graph into strongly connected components. If the size of a strongly connected component is more than one, then that means the component contains cycles.The writer's code (strongly connected component decomposition, C++): 9501202 Div.2 E / Div.1 C: 505E - Mr. Kitayuta vs. Bamboos[Problem] Since it is hard to summarize this problem, please refer to the official statement.(Problem from yosupo)Below is the explanation from yosupo, translated by me.[From here]Let us begin by applying Binary Search. The problem becomes: \"is it possible that all the bamboos are at most X meters after m days?\" It is complicated by the fact that the height does not become negative; the excessive decrease will be wasted. We have found two approaches to this problem. Solution 1 Mr. Kitayuta must beat the i-th bamboo at least max(0, ⌈(hi + m·ai - X) / P⌉) times (let this number ti). Actually, it is not necessary for him to beat it more than this number of times. Thus, let us assume that he beat the i-th bamboo exactly ti times. Also, for each j (1 ≤ j ≤ ti), find the day di, j such that, if the j-th beat on the i-th bamboo is performed before day di, it will be no longer possible to keep the i-th bamboo's height after m days at most X (it can be found by doing simple math). If Mr. Kitayuta can beat the bamboos under this constraint, all the bamboos' heights will become X meters or less after m days. Otherwise, some bamboos' heights will exceed X meters.The time complexity of this solution will be , if we first calculate only ti, then if the sum of ti exceeds km, we skip finding di, j (the answer is \"NO\"). Solution 2 This problem becomes simpler if we simulate Mr. Kitayuta's fight backwards, that is, from day m to day 1. It looks like this:[Problem'] There are n bamboos. At the moment, the height of the i-th bamboo is X meters, and it shrinks ai meters at the beginning of each day. Mr. Kitayuta will play a game. He can use Magic Hammer at most k times per day to increase the height of a bamboo by p meters. If some bamboo's height becomes negative at any moment, he will lose the game immediately. Also, in order for him to win the game, the i-th bamboo's height must be at least hi meters after m days. Is victory possible?Below is an illustration of this \"reverse simulation\": This version is simpler because he is increasing the heights instead of decreasing, thus we do not need to take into account the \"excessive decrease beyond 0 meters\" which will be wasted. Let us consider an optimal strategy. If there exist bamboos whose heights would become negative after day m, he should beat the one that is the earliest to make him lose. Otherwise, he can choose any bamboo whose height would be less than hi meters after day m. Repeat beating the bamboos following this strategy, and see if he can actually claim victory.The writer's implementation of this solution uses a priority queue, and its time complexity is .[End]The tester's code (Solution 1, C++): 9501229The writer's code (Solution 2, C++) Div.1 D: 506D - Mr. Kitayuta's Colorful Graph[Problem] Given an undirected graph whose edges are painted in colors, process the queries of the following form: Given two vertices ui and vi, find the number of the colors that satisfies the following condition: the edges of that color connect ui and vi (possibly indirectly). Note: this is the exact same problem as Div.2 B except the constraints, which are 105 instead of 100.(Problem from hogloid)Below is the explanation from hogloid.[From here]For each color, make a new graph that consists of the edges of the color and vertices connected by the edges. Make UnionFind for each graph, and you can check whether a color connects vertex A and B , using it. For each query, find a vertex which has smaller degree(let this vertex A, and the other vertex B) For each colors such that a edge of the color connects to A, check whether A and B is connected by the color. After answering the query, memorize its tuple — (A, B, answer). If the same query is requested, answer using this information.This will lead to solution.For each query, the complexity is (For each color connects A, find a vertex of B of the color & check whether they are connected) The queries that require longest computing time are, to ask every pair among vertices which have largest degrees. Let the indices of the vertices be , and degrees of the vertices be d1, d2, ...dk. Now, let's fix vertex B as i. The total computing time of the queries such that B is vertex i is . Vertex B can vary from 2 to k. Hence, the total complexity is at most . This complexity is at most .By the way, in C++, using unordered_map, total complexity would be .[End]There will be many other solutions. I will briefly explain one of them which I think is typical.Let ci be the number of colors of the edges incident to vertex i. The sum of all ci does not exceed 2m since each edge increases this sum by at most 2. Thus, there will be at most 450 values of i such that ci ≥ 450 (let B = 450). We will call these vertices large, and the remaining ones small. Using O(m / B·m) = O(m2 / B) time and memory, we can precalculate and store the answer for all the possible queries where at least one of ui and vi is large, then we can immediately answer these queries. For the remaining queries, both ui and vi will be small, therefore it is enough to directly count the color that connects vertices ui and vi in O(B) time. The total time required will be O(m2 / B + Bq). If we choose , we can solve the problem in time.The writer's code (the first solution, C++)The tester's code (the second solution, C++): 9501240 Div.1 E: 506E - Mr. Kitayuta's Gift[Problem] Given a string s and an integer n, find the number of the palindromes that can be obtained by inserting exactly n letters into s.Note: Div.2 A is a similar problem, where n is fixed to 1.(Problem from evima)First of all, let us note that we are asked to count the resulting palindromes, not the ways to obtain them. For example, if we are to insert \"b\" into \"abba\", there are 5 possible positions, but only 3 strings will be produced (\"babba\", \"abbba\" and \"abbab\"). Rather than trying to count the ways of inserting a letter n times and removing the duplicated results, we should directly count the resulting palindrome. To do that, let us reformulate the problem:[Problem'] Given a string s and an integer n, find the number of the palindromes of length |s| + n (let this number be N) that contains s as a subsequence (not necessarily contiguous).Consider constructing a palindrome from both ends, and matching it to s from both left and right. For example, let s = \"abaac\" and N = 11. Let us call the final resulting string t. We first decide what letter to use as t1 and t11 (they must be equal in order for t to be a palindrome). Let us say 'c' is chosen. Now, we have to construct the remaining part of t, that is, t2..t10, so that t2..t10 contains \"abaa\" as a substring (note that the 'c' at the end of s is discarded). Again, we decide what letter to use as t2 and t10. This time we choose 'a'. Then, we have to construct t3..t9, so that it contains \"ba\" as a substring (this time the two 'a's at the both ends of s are discarded). We choose t3 = t9 = 'c'. Next, we construct t4..t8, so that it contains \"ba\" as a substring (this time s remains unchanged). We choose t4 = t8 = 'b'. Then, we construct t5..t7, so that it contains \"a\" as a substring. We choose t5 = t7 = 'a' (it is becoming repetitive, isn't it?). The last part of t, that is, t6, has no restriction (this time we choose a letter for only one position of t, not two). We choose 'd', and we have obtained a palindrome \"cacbadabcac\" that contains s = \"abaac\" as a subsequence.This problem is mostly about analyzing this process carefully.The most naive solution other than literally enumerating all palindromes of length N would be the following Dynamic Programming: let dp[i][left][right] be the number of the palindromes t that can be obtained if you have already decided the leftmost and the rightmost i letters (2i in total), and the substring sleftsleft + 1..sright of s remains unmatched. Each value in this table can be computed in O(1) time. Of course, since i can be up to ⌊n / 2⌋ (n ≤ 109), this solution is far from our goal.Notice that the transitions from dp[i] to dp[i + 1] are the same regardless of i, thus we can calculate the table by matrix exponentiation. However, since there are O(|s|2) possible pairs for (left, right), we will need time, which is actually worse than the naive calculation considering that |s| can be up to 200.This is where we need to observe the process which we have gone through at the beginning more carefully. Let us build a automaton corresponding to the process (the image below). (*) An self-loop with a number means that there are actually that number of edges.A process of producing a palindrome of length N that contains s as a subsequence corresponds to a path of length ⌈N / 2⌉ from the upper-right vertex to the lower-left vertex. Each red vertex has 24 self-loops since the letters at the both ends of the remaining part of s is different, which correspond to two non-self-loop transitions. Similarly, each green vertex has 25 self-loops since the first letter and the last letter of the remaining string is the same, and the blue vertex, the destination, has 26 self-loops, as there are no more non-self-loop transitions available.Here is an important fact: there are not so many possible combination of (n24, n25), where n24 and n25 are the number of times a path from START to GOAL visits a red vertex (with 24 self-loops) and a green vertex (with 25 self-loops), respectively. Why? Each time we leave a red vertex, the length of the remaining unmatched part of s decreases by 1, since exactly one of the two letters at the ends of the remaining part is matched and discarded. Similarly, each time we leave a green vertex, the length of the remaining string decreases by 2, since both of the two letters at the ends are matched and discarded. There is a exception, however: if the length of the remaining string is 1, then it will be a green vertex, but in this case the length will decrease by 1. Thus, for any path from START to GOAL, n24 + 2·n25 will be equal to either |s| or |s| + 1. If we fix n24, then n25 will be uniquely determined by n25 = ⌈(|s| - n24) / 2⌉. Since n24 can only take the value between 0 and |s| - 1, there are at most |s| possible pairs of (n24, n25).With this fact, we are ready to count the paths: let us classify them by the value of n24. For each possible pair of (n24, n25), let us count the number of corresponding paths. To do that, we divide each paths into two parts: first we count the number of paths from START to GOAL, using only non-self-loop transitions. Then, we count the ways of inserting self-loop transitions into each of these paths. The product of these two numbers will be the number that we seek.The first part is straightforward to solve: let dp[left][right][n24] be the number of paths from the vertex that corresponds to the substring sleftsleft + 1..sright, visiting exactly n24 red vertices using only non-self-loop transitions. Each value of the table can be found in O(1) time, thus the whole table can be computed in O(|s|3) time, which is fast enough for the input size (|s| ≤ 200).The main obstacle will be the second part. For example, let us consider the case where s = \"abaac\", N = 11, n24 = 2, which corresponds to the example at the beginning. From the fact we found earlier, n25 = ⌈(|s| - n24) / 2⌉ = ⌈(5 - 2) / 2⌉ = 2. Thus, we have to insert ⌈N / 2⌉ - n24 - n25 = 6 - 2 - 2 = 2 self-loop transitions into this path (the image): The order in which red, green and blue vertices appears in this path does not affect the number of ways of insertion, and can be arbitrary. The number of ways to insert 2 self-loop transitions will be equal to the number of the path of length ⌈N / 2⌉ = 6 from START to GOAL in this automaton (we have to take into account the non-self-loop transitions in it), which can be calculated by matrix exponentiation.Are we done? No! Consider the case s = \"abbb..(|s| - 1 times)..bb\". There are |s| - 1 possible values of n24 (n24 = 1 corresponds to the case where you match and discard the 'a' first, and n24 = |s| - 1 corresponds to the case where you keep the 'a' until s becomes \"ab\"). Thus, you need to perform matrix exponentiation |s| - 1 times, which results in a total of time, which will be too much under the given constraints.There is still hope, though, and here is the climax. Notice that these automata are very similar to each other, and they differ only in the number of the red and green vertices. We can combine these automata into one larger automaton like this (the image): The combined automaton should have |s| - 1 red, ⌈|s| / 2⌉ green and ⌈|s| / 2⌉ blue vertices.By performing matrix exponentiation on this automaton instead of many small automata, we can find all the required value in time, which should be enough. We recommend speeding up matrix multiplication by noticing that the matrix will be upper triangular (6 times faster on paper), since the time limit is not so generous (in order to reject solutions).The problem is almost solved, but there is one more challenge. When N is odd, the situation becomes a little complicated: as we have seen at the beginning, in the last (⌈N / 2⌉-th) step of producing a palindrome we choose a letter for only one position of the resulting string, that is, the center of that string. In other words, the last transition in the path in the automaton we have first built must not be one from a green vertex with a string of length 2 (for example, \"aa\") to GOAL.Let us find the number of the paths that violates this condition and subtract it from the answer. As previously mentioned, for each path n24 + 2·n25 will be equal to either |s| or |s| + 1, and if we fix the value of n24, n25 will be uniquely determined by n25 = ⌈(|s| - n24) / 2⌉. If |s| - n24 is odd, then it means that the last non-self-loop transition is one from a green vertex with a string of length 1, therefore in this case no path will violate the condition. If |s| - n24 is even, then the last non-self-loop trantision is from a green vertex with a string of length 2, thus the paths that does not contain the self-loop from GOAL to itself violate the condition. It will be equal to the number of the paths of length ⌈N / 2⌉ - 1 from START to the vertex just before GOAL, which can be found in a similar way to the second part of the solution.The journey has finally come to an end. Actually, it is also possible to solve this problem in time without matrix exponentiation, but this margin is too small to explain it. I will just paste the link to the code.The writer's code (matrix exponentiation, C++): 9501164The writer's code (without matrix exponentiation, C++): 9501177Congratulations again to Petr who was the only participant to solve this problem in 108 minutes. Also, I would like to give a special mention to rng_58, who was VERY close to solving it in only 63 minutes. He was just one byte away from getting AC (compare 9460984 and 9465440)! If you find a possible error, or have a question, please feel free to ask here. Alternative solutions are also welcome.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/15889",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 505\\s*C"
          },
          "content_length": 23595
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #286 - Codeforces - Code 1",
          "code": "This is the 3rd time(following #162 and #263) for me",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #286 - Codeforces - Code 2",
          "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N = 1e2 + 5;\n\nint parent[N][N];\n\nint find(int c, int v) {\n    if (parent[c][v] == -1)\n        return v;\n    return parent[c][v] = find(c, parent[c][v]);\n}\n\nvoid unite(int c, int u, int v) {\n    parent[c][find(c, u)] = find(c, v);\n}\n\nint main() {\n    memset(parent, -1, sizeof parent);\n    int n, m;\n    cin >> n >> m;\n    for (int i = 0; i < m; ++i) {\n        int a, b, c;\n        cin >> a >> b >> c;\n        unite(c, a, b);\n    }\n    int q;\n    cin >> q;\n    while (q--) {\n        int u, v, ans = 0;\n        cin >> u >> v;\n        for (int i = 1; i <= 100; ++i)\n            if (find(i, u) == find(i, v))\n                ++ans;\n        cout << ans << '\\n';\n    }\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/15842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #286 - Codeforces - Code 3",
          "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N = 1e2 + 5;\n\nint parent[N][N];\n\nint find(int c, int v) {\n    if (parent[c][v] == -1)\n        return v;\n    return parent[c][v] = find(c, parent[c][v]);\n}\n\nvoid unite(int c, int u, int v) {\n    parent[c][find(c, u)] = find(c, v);\n}\n\nint main() {\n    memset(parent, -1, sizeof parent);\n    int n, m;\n    cin >> n >> m;\n    for (int i = 0; i < m; ++i) {\n        int a, b, c;\n        cin >> a >> b >> c;\n        unite(c, a, b);\n    }\n    int q;\n    cin >> q;\n    while (q--) {\n        int u, v, ans = 0;\n        cin >> u >> v;\n        for (int i = 1; i <= 100; ++i)\n            if (find(i, u) == find(i, v))\n                ++ans;\n        cout << ans << '\\n';\n    }\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/15842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #286 - Codeforces - Code 4",
          "code": "Runtime Error",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #286 - Codeforces - Code 5",
          "code": "Memory Limit Exceeded",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #286 - Codeforces - Code 6",
          "code": "7 8\n1 2\n1 3\n2 4\n3 4\n4 5\n4 6\n5 7\n6 7",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #286 - Codeforces - Code 7",
          "code": "7 8\n1 2\n1 3\n2 4\n3 4\n4 5\n4 6\n5 7\n6 7",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #286 - Codeforces - Code 8",
          "code": "Test: #12 ... verdict: WRONG_ANSWER\nInput\n1 30000\n30000\nOutput\n0\nAnswer\n1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #286 - Codeforces - Code 9",
          "code": "Test: #12 ... verdict: WRONG_ANSWER\nInput\n1 30000\n30000\nOutput\n0\nAnswer\n1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #286 - Codeforces - Code 10",
          "code": "unordered_map",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #286 - Codeforces - Code 11",
          "code": "res += (pars[c][u] == pars[c][v]);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #286 - Codeforces - Code 12",
          "code": "res += (pars[c][u] == pars[c][v]);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #286 - Codeforces - Code 13",
          "code": "if (pars[c].find(v) != pars[c].end() && pars[c][u] == pars[c][v]) {\n    res++;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #286 - Codeforces - Code 14",
          "code": "if (pars[c].find(v) != pars[c].end() && pars[c][u] == pars[c][v]) {\n    res++;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #286 Editorial (Complete) - Codeforces - Code 1",
          "code": "dp[i][j - offset]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15889",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #286 Editorial (Complete) - Codeforces - Code 2",
          "code": "components[x] & components[y]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15889",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #286 Editorial (Complete) - Codeforces - Code 3",
          "code": "7 8\n1 2\n2 3\n3 4\n4 1\n4 7\n7 6\n6 5\n5 2\n\nAuthor's Code on my Pc returns 7",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15889",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #286 Editorial (Complete) - Codeforces - Code 4",
          "code": "7 8\n1 2\n2 3\n3 4\n4 1\n4 7\n7 6\n6 5\n5 2\n\nAuthor's Code on my Pc returns 7",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15889",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #286 Editorial (Complete) - Codeforces - Code 5",
          "code": "Also, for each j (1 ≤ j ≤ ti), find the day di, j such that, if the j-th beat on the i-th bamboo is performed before day di, it will be no longer possible to keep the i-th bamboo's height after m days at most X (it can be found by doing simple math).",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15889",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #286 Editorial (Complete) - Codeforces - Code 6",
          "code": "if(target - h[i] <= 0){\n\tt[0]++;\n}else if(target - h[i] > a[i] * (m-1)){\n\tok = 0;\n\tgoto end;\n}else{\n\tt[(target - h[i] + a[i] - 1) / a[i]]++;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15889",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #286 Editorial (Complete) - Codeforces - Code 7",
          "code": "if(target - h[i] <= 0){\n\tt[0]++;\n}else if(target - h[i] > a[i] * (m-1)){\n\tok = 0;\n\tgoto end;\n}else{\n\tt[(target - h[i] + a[i] - 1) / a[i]]++;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15889",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #286 Editorial (Complete) - Codeforces - Code 8",
          "code": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\n#define pb push_back\n#define __addEdge(u, v) [u].push_back(v)\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<vi> vmi;\n\nint n, m;\nvmi G[111];\nvb mark;\n\nvoid dfs(vmi &SG, int u)\n{\n    mark[u] = true;\n    for (int i = 0; i < SG[u].size(); ++i)\n    {\n        int v = SG[u][i];\n        if (!mark[v])\n            dfs(SG, v);\n    }\n}\n\nint main()\n{\n    cin >> n >> m;\n\n    fill(G, G + 111, vmi(n + 1));\n    mark.assign(n + 1, false);\n    for (int i = 0; i < m; ++i)\n    {\n        int u, v, c;\n        cin >> u >> v >> c;\n        G[c]__addEdge(u, v);\n        G[c]__addEdge(v, u);\n    }\n\n    int q;\n    cin >> q;\n\n    while (q--)\n    {\n        int u, v;\n        cin >> u >> v;\n\n        int cnt = 0;\n        for (int k = 1; k <= 100; ++k)\n        {\n            fill(mark.begin(), mark.end(), false);\n            dfs(G[k], u);\n            cnt += mark[v];\n        }\n\n        cout << cnt << endl;\n    }   \n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/15889",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #286 Editorial (Complete) - Codeforces - Code 9",
          "code": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\n#define pb push_back\n#define __addEdge(u, v) [u].push_back(v)\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<vi> vmi;\n\nint n, m;\nvmi G[111];\nvb mark;\n\nvoid dfs(vmi &SG, int u)\n{\n    mark[u] = true;\n    for (int i = 0; i < SG[u].size(); ++i)\n    {\n        int v = SG[u][i];\n        if (!mark[v])\n            dfs(SG, v);\n    }\n}\n\nint main()\n{\n    cin >> n >> m;\n\n    fill(G, G + 111, vmi(n + 1));\n    mark.assign(n + 1, false);\n    for (int i = 0; i < m; ++i)\n    {\n        int u, v, c;\n        cin >> u >> v >> c;\n        G[c]__addEdge(u, v);\n        G[c]__addEdge(v, u);\n    }\n\n    int q;\n    cin >> q;\n\n    while (q--)\n    {\n        int u, v;\n        cin >> u >> v;\n\n        int cnt = 0;\n        for (int k = 1; k <= 100; ++k)\n        {\n            fill(mark.begin(), mark.end(), false);\n            dfs(G[k], u);\n            cnt += mark[v];\n        }\n\n        cout << cnt << endl;\n    }   \n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/15889",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 30000, \"n\");\n    inf.readSpace();\n    int d = inf.readInt(1, 30000, \"d\");\n    inf.readEoln();\n    int prev_p = -1;\n    for (int i = 1; i <= n; i++) {\n        int pi = inf.readInt(d, 30000);\n        inf.readEoln();\n        if (i > 1) {\n            ensuref(prev_p <= pi, \"p[%d]=%d is greater than p[%d]=%d\", i - 1, prev_p, i, pi);\n        }\n        prev_p = pi;\n    }\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 30000, \"n\");\n    inf.readSpace();\n    int d = inf.readInt(1, 30000, \"d\");\n    inf.readEoln();\n    int prev_p = -1;\n    for (int i = 1; i <= n; i++) {\n        int pi = inf.readInt(d, 30000);\n        inf.readEoln();\n        if (i > 1) {\n            ensuref(prev_p <= pi, \"p[%d]=%d is greater than p[%d]=%d\", i - 1, prev_p, i, pi);\n        }\n        prev_p = pi;\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 30000, \"n\");\n    inf.readSpace();\n    int d = inf.readInt(1, 30000, \"d\");\n    inf.readEoln();\n    int prev_p = -1;\n    for (int i = 1; i <= n; i++) {\n        int pi = inf.readInt(d, 30000);\n        inf.readEoln();\n        if (i > 1) {\n            ensuref(prev_p <= pi, \"p[%d]=%d is greater than p[%d]=%d\", i - 1, prev_p, i, pi);\n        }\n        prev_p = pi;\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAX_P = 30000;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int d = opt<int>(\"d\");\n    string type = opt<string>(\"type\", \"random\");\n\n    assert(1 <= n && n <= 30000);\n    assert(1 <= d && d <= MAX_P);\n\n    vector<int> p;\n\n    if (type == \"min_n\") {\n        // Minimal n\n        n = 1;\n        p.push_back(d);\n    } else if (type == \"max_n\") {\n        // Maximal n\n        n = 30000;\n        p.resize(n);\n        for(int i = 0; i < n; ++i) {\n            p[i] = rnd.next(d, MAX_P);\n        }\n        sort(p.begin(), p.end());\n    } else if (type == \"max_d\") {\n        // Maximal d\n        d = MAX_P;\n        n = min(n, MAX_P - d + 1);\n        p.resize(n);\n        for(int i = 0; i < n; ++i) {\n            p[i] = d;\n        }\n    } else if (type == \"random\") {\n        p.resize(n);\n        for(int i = 0; i < n; ++i) {\n            p[i] = rnd.next(d, MAX_P);\n        }\n        sort(p.begin(), p.end());\n    } else if (type == \"duplicates\") {\n        p.resize(n);\n        int num_unique = rnd.next(1, min(n, 10));\n        vector<int> unique_positions(num_unique);\n        for(int i = 0; i < num_unique; ++i) {\n            unique_positions[i] = rnd.next(d, MAX_P);\n        }\n        sort(unique_positions.begin(), unique_positions.end());\n        for(int i = 0; i < n; ++i) {\n            p[i] = unique_positions[rnd.next(0, num_unique - 1)];\n        }\n        sort(p.begin(), p.end());\n    } else if (type == \"clustered\") {\n        p.resize(n);\n        int cluster_center = rnd.next(d, MAX_P - 100);\n        for(int i = 0; i < n; ++i) {\n            p[i] = rnd.next(cluster_center, cluster_center + 100);\n        }\n        sort(p.begin(), p.end());\n    } else if (type == \"sparse\") {\n        p.resize(n);\n        for(int i = 0; i < n; ++i) {\n            p[i] = d + i * ((MAX_P - d) / n);\n        }\n        sort(p.begin(), p.end());\n    } else if (type == \"increasing_sequence\") {\n        p.resize(n);\n        int start_pos = d;\n        int step = 1;\n        for(int i = 0; i < n; ++i) {\n            p[i] = start_pos + i * step;\n            if (p[i] > MAX_P) {\n                n = i;\n                p.resize(n);\n                break;\n            }\n        }\n    } else if (type == \"l_equal_1\") {\n        p.resize(n);\n        int pos = d;\n        int l = rnd.next(2, 10);\n        for(int i = 0; i < n; ++i) {\n            pos += l;\n            if (pos > MAX_P) {\n                n = i;\n                p.resize(n);\n                break;\n            }\n            p[i] = pos;\n            if (l > 1)\n                l--;\n        }\n        sort(p.begin(), p.end());\n    } else {\n        // Default to random\n        p.resize(n);\n        for(int i = 0; i < n; ++i) {\n            p[i] = rnd.next(d, MAX_P);\n        }\n        sort(p.begin(), p.end());\n    }\n\n    // Output\n    printf(\"%d %d\\n\", n, d);\n    for(int i = 0; i < n; ++i) {\n        printf(\"%d\\n\", p[i]);\n    }\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAX_P = 30000;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int d = opt<int>(\"d\");\n    string type = opt<string>(\"type\", \"random\");\n\n    assert(1 <= n && n <= 30000);\n    assert(1 <= d && d <= MAX_P);\n\n    vector<int> p;\n\n    if (type == \"min_n\") {\n        // Minimal n\n        n = 1;\n        p.push_back(d);\n    } else if (type == \"max_n\") {\n        // Maximal n\n        n = 30000;\n        p.resize(n);\n        for(int i = 0; i < n; ++i) {\n            p[i] = rnd.next(d, MAX_P);\n        }\n        sort(p.begin(), p.end());\n    } else if (type == \"max_d\") {\n        // Maximal d\n        d = MAX_P;\n        n = min(n, MAX_P - d + 1);\n        p.resize(n);\n        for(int i = 0; i < n; ++i) {\n            p[i] = d;\n        }\n    } else if (type == \"random\") {\n        p.resize(n);\n        for(int i = 0; i < n; ++i) {\n            p[i] = rnd.next(d, MAX_P);\n        }\n        sort(p.begin(), p.end());\n    } else if (type == \"duplicates\") {\n        p.resize(n);\n        int num_unique = rnd.next(1, min(n, 10));\n        vector<int> unique_positions(num_unique);\n        for(int i = 0; i < num_unique; ++i) {\n            unique_positions[i] = rnd.next(d, MAX_P);\n        }\n        sort(unique_positions.begin(), unique_positions.end());\n        for(int i = 0; i < n; ++i) {\n            p[i] = unique_positions[rnd.next(0, num_unique - 1)];\n        }\n        sort(p.begin(), p.end());\n    } else if (type == \"clustered\") {\n        p.resize(n);\n        int cluster_center = rnd.next(d, MAX_P - 100);\n        for(int i = 0; i < n; ++i) {\n            p[i] = rnd.next(cluster_center, cluster_center + 100);\n        }\n        sort(p.begin(), p.end());\n    } else if (type == \"sparse\") {\n        p.resize(n);\n        for(int i = 0; i < n; ++i) {\n            p[i] = d + i * ((MAX_P - d) / n);\n        }\n        sort(p.begin(), p.end());\n    } else if (type == \"increasing_sequence\") {\n        p.resize(n);\n        int start_pos = d;\n        int step = 1;\n        for(int i = 0; i < n; ++i) {\n            p[i] = start_pos + i * step;\n            if (p[i] > MAX_P) {\n                n = i;\n                p.resize(n);\n                break;\n            }\n        }\n    } else if (type == \"l_equal_1\") {\n        p.resize(n);\n        int pos = d;\n        int l = rnd.next(2, 10);\n        for(int i = 0; i < n; ++i) {\n            pos += l;\n            if (pos > MAX_P) {\n                n = i;\n                p.resize(n);\n                break;\n            }\n            p[i] = pos;\n            if (l > 1)\n                l--;\n        }\n        sort(p.begin(), p.end());\n    } else {\n        // Default to random\n        p.resize(n);\n        for(int i = 0; i < n; ++i) {\n            p[i] = rnd.next(d, MAX_P);\n        }\n        sort(p.begin(), p.end());\n    }\n\n    // Output\n    printf(\"%d %d\\n\", n, d);\n    for(int i = 0; i < n; ++i) {\n        printf(\"%d\\n\", p[i]);\n    }\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Minimal test case\n./gen -n 1 -d 1 -type min_n\n\n# Max n\n./gen -n 30000 -d 1 -type max_n\n\n# Max n, max d\n./gen -n 30000 -d 30000 -type max_d\n\n# Random tests with varying n and d\n./gen -n 10 -d 1 -type random\n./gen -n 100 -d 10 -type random\n./gen -n 1000 -d 500 -type random\n./gen -n 5000 -d 1000 -type random\n./gen -n 10000 -d 2000 -type random\n./gen -n 20000 -d 5000 -type random\n./gen -n 30000 -d 1 -type random\n\n# Duplicates types\n./gen -n 10 -d 1 -type duplicates\n./gen -n 100 -d 10 -type duplicates\n./gen -n 1000 -d 500 -type duplicates\n./gen -n 10000 -d 1000 -type duplicates\n./gen -n 30000 -d 1 -type duplicates\n\n# Clustered gems\n./gen -n 100 -d 1 -type clustered\n./gen -n 1000 -d 500 -type clustered\n./gen -n 10000 -d 1000 -type clustered\n./gen -n 30000 -d 1 -type clustered\n\n# Sparse gems\n./gen -n 10000 -d 1 -type sparse\n./gen -n 30000 -d 1 -type sparse\n\n# Increasing sequence\n./gen -n 10 -d 1 -type increasing_sequence\n./gen -n 100 -d 10 -type increasing_sequence\n./gen -n 1000 -d 500 -type increasing_sequence\n./gen -n 10000 -d 1000 -type increasing_sequence\n./gen -n 30000 -d 1 -type increasing_sequence\n\n# Decreasing l to 1\n./gen -n 10 -d 1 -type l_equal_1\n./gen -n 100 -d 10 -type l_equal_1\n./gen -n 1000 -d 500 -type l_equal_1\n./gen -n 10000 -d 1000 -type l_equal_1\n./gen -n 30000 -d 1 -type l_equal_1\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:40:37.657478",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "505/D",
      "title": "D. Mr. Kitayuta's Technology",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains two space-separated integers n and m (2 ≤ n ≤ 105, 1 ≤ m ≤ 105), denoting the number of the cities in Shuseki Kingdom and the number of the important pairs, respectively.The following m lines describe the important pairs. The i-th of them (1 ≤ i ≤ m) contains two space-separated integers ai and bi (1 ≤ ai, bi ≤ n, ai ≠ bi), denoting that it must be possible to travel from city ai to city bi by using one or more teleportation pipes (but not necessarily from city bi to city ai). It is guaranteed that all pairs (ai, bi) are distinct.",
      "output_spec": "OutputPrint the minimum required number of teleportation pipes to fulfill Mr. Kitayuta's purpose.",
      "sample_tests": "ExamplesInputCopy4 51 21 31 42 32 4OutputCopy3InputCopy4 61 21 42 32 43 23 4OutputCopy4",
      "description": "D. Mr. Kitayuta's Technology\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains two space-separated integers n and m (2 ≤ n ≤ 105, 1 ≤ m ≤ 105), denoting the number of the cities in Shuseki Kingdom and the number of the important pairs, respectively.The following m lines describe the important pairs. The i-th of them (1 ≤ i ≤ m) contains two space-separated integers ai and bi (1 ≤ ai, bi ≤ n, ai ≠ bi), denoting that it must be possible to travel from city ai to city bi by using one or more teleportation pipes (but not necessarily from city bi to city ai). It is guaranteed that all pairs (ai, bi) are distinct.\n\nOutputPrint the minimum required number of teleportation pipes to fulfill Mr. Kitayuta's purpose.\n\nInputCopy4 51 21 31 42 32 4OutputCopy3InputCopy4 61 21 42 32 43 23 4OutputCopy4\n\nInputCopy4 51 21 31 42 32 4\n\nOutputCopy3\n\nInputCopy4 61 21 42 32 43 23 4\n\nOutputCopy4\n\nNoteFor the first sample, one of the optimal ways to construct pipes is shown in the image below:   For the second sample, one of the optimal ways is shown below:",
      "solutions": [
        {
          "title": "Codeforces Round #286 - Codeforces",
          "content": "Hello Codeforces!evima, yosupo and I would like you to participate in Codeforces Round #286. It will be held on Sunday, January 18th at 16:00 MSK. Please note that this round starts on unusual time.Great thanks to Zlobober who helped us prepare this round, Delinur who translated statements into Russian and MikeMirzayanov who created Codeforces and polygon.This is the 3rd time(following #162 and #263) for me, and the 1st time for evima and yosupo to prepare a Codeforces Round.Scores of the problems will be500-1000-1750-1750-2500 for Div.1, and500-1000-1500-2000-2750 for Div.2.In this round, you'll help a man named Mr. kitayuta. I hope he will participate :)The system tests are now over! The top-5 are as follows:Div.1:1.ilyakor2.kcm17003.LayCurse4.RomaWhite5.TankEngineerDiv.2:1.Konijntje2.cpcpc3.zgzjsxshycxksxhsh4.Ronnie0075.sha384Also, special congrats on Petr, who solved problem E in Div.1, which anyone else could not solve.Here are the editorials",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/15842",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 961
        },
        {
          "title": "Codeforces Round #286 Editorial (Complete) - Codeforces",
          "content": "Edit (Jan 22, 2:45 AM UTC): Added Div1E and the editorial is now complete. I am sorry for the delay.Edit (Jan 21, 9:45 AM UTC): Added the explanation for Div1C/2E, and the problem setters' codes. Div1E will need several more hours. Thank you again for your patience.First, here are some statistics on this round: Division Registrants Participants A Accepted B Accepted C Accepted D Accepted E Accepted 1 1364 572 (*) 294 199 8 113 1 (Estimated number of AC by me) 800 (wrong) 500 (wrong) 70 (FAIL) 90 (ok) 5 (wrong) 2 4016 2028 1355 945 41 5 0 (*) Where did the remaining 792 people go? :) We are sorry for terribly underestimating the difficulty of the problems (except Div1D), especially Div1A/2C and Div1C/2E. Div.2 A: 505A - Mr. Kitayuta's Gift[Problem] Given a string, turn it into a palindrome by inserting one letter or state that it is impossible.(Problem by evima)Since the string is short (at most 10 characters), you can simply try every possible way of inserting a letter (\"where\" and \"what\" to insert), and check if the resulting string is a palindrome.The writer's code (C++): 9501249Note: For some strange reason, we (contest managers) cannot submit solutions so that everyone can see them. PraveenDhinwa told us how to do so. Thank you! Div.2 B: 505B - Mr. Kitayuta's Colorful Graph[Problem] Given an undirected graph whose edges are painted in colors, process the queries of the following form: Given two vertices ui and vi, find the number of the colors that satisfies the following condition: the edges of that color connect ui and vi (possibly indirectly). (Problem by hogloid)Since neither the graph nor the number of queries is too large, for each query you can simply count the number of the \"good\" colors (the colors that satisfies the condition) by checking if each color is \"good\". To do that, you can perform Depth First Search (or Breadth First Search) and verify whether you can reach vi from ui traversing only the edges of that color. If you prefer using Union-Find, it will also do the job.The writer's code (DFS, C++)The writer's code (Union-Find, C++) Div.2 C / Div.1 A: 505C - Mr. Kitayuta, the Treasure Hunter[Problem] Since it is hard to summarize this problem, please refer to the official statement.(Problem by yosupo)Below is the explanation from yosupo, translated by me.[From here]Let m be the number of the islands (that is, 30001). First, let us describe a solution with time and memory complexity of O(m2).We will apply Dynamic Programming. let dp[i][j] be the number of the gems that Mr. Kitayuta can collect after he jumps to island i, when the length of his previous jump is j (let us assume that he have not collect the gems on island i). Then, you can calculate the values of the table dp by the following: dp[i][j] = 0, if i ≥ m(actually these islands do not exist, but we can suppose that they exist and when Mr. Kitayuta jumps to these islands, he stops jumping) dp[i][j] =  (the number of the gems on island i)  + max(dp[i + j][j], dp[i + j + 1][j + 1]), if i < m, j = 1(he cannot perform a jump of length 0) dp[i][j] =  (the number of the gems on island i)  + max(dp[i + j - 1][j - 1], dp[i + j][j], dp[i + j + 1][j + 1]), if i < m, j ≥ 2 This solution is unfeasible in terms of both time and memory. However, the following observation makes it an Accepted solution: there are only 491 values of j that we have to consider, which are d - 245, d - 244, d - 243, ..., d + 244 and d + 245.Why? First, let us find the upper bound of j. Suppose Mr. Kitayuta always performs the \"l + 1\" jump (l: the length of the previous jump). Then, he will reach the end of the islands before he performs a jump of length d + 246, becaused + (d + 1) + (d + 2) + ... + (d + 245) ≥ 1 + 2 + ... + 245 = 245·(245 + 1) / 2 = 30135 > 30000. Thus, he will never be able to perform a jump of length d + 246 or longer.Next, let us consider the lower bound of j in a similar way. If d ≤ 246, then obviously he will not be able to perform a jump of length d - 246 or shorter, because the length of a jump must be positive. Suppose Mr. Kitayuta always performs the \"l - 1\" jump, where d ≥ 247. Then, again he will reach the end of the islands before he performs a jump of length d - 246, becaused + (d - 1) + (d - 2) + ... + (d - 245) ≥ 245 + 244 + ... + 1 = 245·(245 + 1) / 2 = 30135 > 30000. Thus, he will never be able to perform a jump of length d - 246 or shorter.Therefore, we have obtained a working solution: similar to the O(m2) one, but we will only consider the value of j between d - 245 and d + 245. The time and memory complexity of this solution will be O(m1.5), since the value \"245\" is slightly larger than .This solution can be implemented by, for example, using a \"normal\" two dimensional array with a offset like this: dp[i][j - offset]. The time limit is set tight in order to fail most of naive solutions with search using std::map or something, so using hash maps (unordered_map) will be risky although the complexity will be the same as the described solution.[End]The writer's code (memoized recursion, C++) Div.2 D / Div.1 B: 505D - Mr. Kitayuta's Technology[Problem] Given an integer n and m pairs of integers (ai, bi) (1 ≤ ai, bi ≤ n), find the minimum number of edges in a directed graph that satisfies the following condition: For each i, there exists a path from vertex ai to vertex bi. (Problem from evima)Let G1 be the directed graph built from the input, and G2 be a directed graph that satisfies the given conditions. What we seek is the minimum number of edges in G2. Also, we say that two vertices u and v in a directed graph are \"weakly connected\" if we can reach v from u by traversing edges, not considering their directions.If a pair (u, v) is present in the input, then vertices u and v must be weakly connected in G2. Therefore, for each weakly connected component (abbreviated to wcc) in G1, the vertices in that component must also be in the same wcc in G2. We can \"merge\" multiple wccs in G1 and create a larger wcc in G2, but for now, let us find the minimum number of edges required in G2 for each wcc in G1 when we do not \"merge\" them. There are two cases to consider: If a wcc in G1 does not have cycles, then we can perform topological sort on that wcc, and we can make a \"chain\" (see the image below) using the topological order to satisfy the conditions. We need (the number of the vertices in the wcc)  - 1 edges, which is the minimum required number since any connected graph with V vertices has at least V - 1 edges. If a wcc in G1 has cycles, then topological sort cannot be applied. We need at least (the number of the vertices in the wcc) edges this time, since any connected graph with V vertices and V - 1 edges is a tree, which does not contain cycles. Actually, this number (the number of the vertices in the wcc) is always achievable by connecting the vertices into a \"ring\" (see the image below), thus it is the minimum required number that we seek. We have found the minimum required number of edges for each wcc in G1 when we do not \"merge\" them. Let us show that \"merging\" wccs in G1 do not reduce the number of required edges. Suppose we combine k( > 1) wccs C1, C2, ..., Ck in G1 into one wcc C in G2. Again, there are two cases to consider: If none of C1, C2, ..., Ck contains cycles, then C will need |C1| + |C2| + ... + |Ck| - 1 edges. However, if we do not combine them, we will only need (|C1| - 1) + (|C2| - 1) + ... + (|Ck| - 1) edges in total, which is fewer. If some of C1, C2, ..., Ck contain cycles, then C will need |C1| + |C2| + ... + |Ck| edges. However, if we do not combine them, we will need(|C1| - noCycles(C1)) + (|C2| - noCycles(C2)) + ... + (|Ck| - noCycles(Ck)  ≤ |C1| + |C2| + ... + |Ck| edges(here, noCycles(Ci) is 1 if Ci do not contain cycles, otherwise 0), thus combining them does not reduce the number of required edges. Thus, we do not need to combine multiple wccs into one wcc in G2 in order to obtain the optimal solution. That is, the final answer to the problem is the sum of the minimum required number of edges for each wcc in G1, when they are considered separately.As for the implementation, detecting cycles in a directed graph with 105 vertices and edges might be a problem if this is your first encounter with it. One possible way is to paste a code that decomposes a graph into strongly connected components. If the size of a strongly connected component is more than one, then that means the component contains cycles.The writer's code (strongly connected component decomposition, C++): 9501202 Div.2 E / Div.1 C: 505E - Mr. Kitayuta vs. Bamboos[Problem] Since it is hard to summarize this problem, please refer to the official statement.(Problem from yosupo)Below is the explanation from yosupo, translated by me.[From here]Let us begin by applying Binary Search. The problem becomes: \"is it possible that all the bamboos are at most X meters after m days?\" It is complicated by the fact that the height does not become negative; the excessive decrease will be wasted. We have found two approaches to this problem. Solution 1 Mr. Kitayuta must beat the i-th bamboo at least max(0, ⌈(hi + m·ai - X) / P⌉) times (let this number ti). Actually, it is not necessary for him to beat it more than this number of times. Thus, let us assume that he beat the i-th bamboo exactly ti times. Also, for each j (1 ≤ j ≤ ti), find the day di, j such that, if the j-th beat on the i-th bamboo is performed before day di, it will be no longer possible to keep the i-th bamboo's height after m days at most X (it can be found by doing simple math). If Mr. Kitayuta can beat the bamboos under this constraint, all the bamboos' heights will become X meters or less after m days. Otherwise, some bamboos' heights will exceed X meters.The time complexity of this solution will be , if we first calculate only ti, then if the sum of ti exceeds km, we skip finding di, j (the answer is \"NO\"). Solution 2 This problem becomes simpler if we simulate Mr. Kitayuta's fight backwards, that is, from day m to day 1. It looks like this:[Problem'] There are n bamboos. At the moment, the height of the i-th bamboo is X meters, and it shrinks ai meters at the beginning of each day. Mr. Kitayuta will play a game. He can use Magic Hammer at most k times per day to increase the height of a bamboo by p meters. If some bamboo's height becomes negative at any moment, he will lose the game immediately. Also, in order for him to win the game, the i-th bamboo's height must be at least hi meters after m days. Is victory possible?Below is an illustration of this \"reverse simulation\": This version is simpler because he is increasing the heights instead of decreasing, thus we do not need to take into account the \"excessive decrease beyond 0 meters\" which will be wasted. Let us consider an optimal strategy. If there exist bamboos whose heights would become negative after day m, he should beat the one that is the earliest to make him lose. Otherwise, he can choose any bamboo whose height would be less than hi meters after day m. Repeat beating the bamboos following this strategy, and see if he can actually claim victory.The writer's implementation of this solution uses a priority queue, and its time complexity is .[End]The tester's code (Solution 1, C++): 9501229The writer's code (Solution 2, C++) Div.1 D: 506D - Mr. Kitayuta's Colorful Graph[Problem] Given an undirected graph whose edges are painted in colors, process the queries of the following form: Given two vertices ui and vi, find the number of the colors that satisfies the following condition: the edges of that color connect ui and vi (possibly indirectly). Note: this is the exact same problem as Div.2 B except the constraints, which are 105 instead of 100.(Problem from hogloid)Below is the explanation from hogloid.[From here]For each color, make a new graph that consists of the edges of the color and vertices connected by the edges. Make UnionFind for each graph, and you can check whether a color connects vertex A and B , using it. For each query, find a vertex which has smaller degree(let this vertex A, and the other vertex B) For each colors such that a edge of the color connects to A, check whether A and B is connected by the color. After answering the query, memorize its tuple — (A, B, answer). If the same query is requested, answer using this information.This will lead to solution.For each query, the complexity is (For each color connects A, find a vertex of B of the color & check whether they are connected) The queries that require longest computing time are, to ask every pair among vertices which have largest degrees. Let the indices of the vertices be , and degrees of the vertices be d1, d2, ...dk. Now, let's fix vertex B as i. The total computing time of the queries such that B is vertex i is . Vertex B can vary from 2 to k. Hence, the total complexity is at most . This complexity is at most .By the way, in C++, using unordered_map, total complexity would be .[End]There will be many other solutions. I will briefly explain one of them which I think is typical.Let ci be the number of colors of the edges incident to vertex i. The sum of all ci does not exceed 2m since each edge increases this sum by at most 2. Thus, there will be at most 450 values of i such that ci ≥ 450 (let B = 450). We will call these vertices large, and the remaining ones small. Using O(m / B·m) = O(m2 / B) time and memory, we can precalculate and store the answer for all the possible queries where at least one of ui and vi is large, then we can immediately answer these queries. For the remaining queries, both ui and vi will be small, therefore it is enough to directly count the color that connects vertices ui and vi in O(B) time. The total time required will be O(m2 / B + Bq). If we choose , we can solve the problem in time.The writer's code (the first solution, C++)The tester's code (the second solution, C++): 9501240 Div.1 E: 506E - Mr. Kitayuta's Gift[Problem] Given a string s and an integer n, find the number of the palindromes that can be obtained by inserting exactly n letters into s.Note: Div.2 A is a similar problem, where n is fixed to 1.(Problem from evima)First of all, let us note that we are asked to count the resulting palindromes, not the ways to obtain them. For example, if we are to insert \"b\" into \"abba\", there are 5 possible positions, but only 3 strings will be produced (\"babba\", \"abbba\" and \"abbab\"). Rather than trying to count the ways of inserting a letter n times and removing the duplicated results, we should directly count the resulting palindrome. To do that, let us reformulate the problem:[Problem'] Given a string s and an integer n, find the number of the palindromes of length |s| + n (let this number be N) that contains s as a subsequence (not necessarily contiguous).Consider constructing a palindrome from both ends, and matching it to s from both left and right. For example, let s = \"abaac\" and N = 11. Let us call the final resulting string t. We first decide what letter to use as t1 and t11 (they must be equal in order for t to be a palindrome). Let us say 'c' is chosen. Now, we have to construct the remaining part of t, that is, t2..t10, so that t2..t10 contains \"abaa\" as a substring (note that the 'c' at the end of s is discarded). Again, we decide what letter to use as t2 and t10. This time we choose 'a'. Then, we have to construct t3..t9, so that it contains \"ba\" as a substring (this time the two 'a's at the both ends of s are discarded). We choose t3 = t9 = 'c'. Next, we construct t4..t8, so that it contains \"ba\" as a substring (this time s remains unchanged). We choose t4 = t8 = 'b'. Then, we construct t5..t7, so that it contains \"a\" as a substring. We choose t5 = t7 = 'a' (it is becoming repetitive, isn't it?). The last part of t, that is, t6, has no restriction (this time we choose a letter for only one position of t, not two). We choose 'd', and we have obtained a palindrome \"cacbadabcac\" that contains s = \"abaac\" as a subsequence.This problem is mostly about analyzing this process carefully.The most naive solution other than literally enumerating all palindromes of length N would be the following Dynamic Programming: let dp[i][left][right] be the number of the palindromes t that can be obtained if you have already decided the leftmost and the rightmost i letters (2i in total), and the substring sleftsleft + 1..sright of s remains unmatched. Each value in this table can be computed in O(1) time. Of course, since i can be up to ⌊n / 2⌋ (n ≤ 109), this solution is far from our goal.Notice that the transitions from dp[i] to dp[i + 1] are the same regardless of i, thus we can calculate the table by matrix exponentiation. However, since there are O(|s|2) possible pairs for (left, right), we will need time, which is actually worse than the naive calculation considering that |s| can be up to 200.This is where we need to observe the process which we have gone through at the beginning more carefully. Let us build a automaton corresponding to the process (the image below). (*) An self-loop with a number means that there are actually that number of edges.A process of producing a palindrome of length N that contains s as a subsequence corresponds to a path of length ⌈N / 2⌉ from the upper-right vertex to the lower-left vertex. Each red vertex has 24 self-loops since the letters at the both ends of the remaining part of s is different, which correspond to two non-self-loop transitions. Similarly, each green vertex has 25 self-loops since the first letter and the last letter of the remaining string is the same, and the blue vertex, the destination, has 26 self-loops, as there are no more non-self-loop transitions available.Here is an important fact: there are not so many possible combination of (n24, n25), where n24 and n25 are the number of times a path from START to GOAL visits a red vertex (with 24 self-loops) and a green vertex (with 25 self-loops), respectively. Why? Each time we leave a red vertex, the length of the remaining unmatched part of s decreases by 1, since exactly one of the two letters at the ends of the remaining part is matched and discarded. Similarly, each time we leave a green vertex, the length of the remaining string decreases by 2, since both of the two letters at the ends are matched and discarded. There is a exception, however: if the length of the remaining string is 1, then it will be a green vertex, but in this case the length will decrease by 1. Thus, for any path from START to GOAL, n24 + 2·n25 will be equal to either |s| or |s| + 1. If we fix n24, then n25 will be uniquely determined by n25 = ⌈(|s| - n24) / 2⌉. Since n24 can only take the value between 0 and |s| - 1, there are at most |s| possible pairs of (n24, n25).With this fact, we are ready to count the paths: let us classify them by the value of n24. For each possible pair of (n24, n25), let us count the number of corresponding paths. To do that, we divide each paths into two parts: first we count the number of paths from START to GOAL, using only non-self-loop transitions. Then, we count the ways of inserting self-loop transitions into each of these paths. The product of these two numbers will be the number that we seek.The first part is straightforward to solve: let dp[left][right][n24] be the number of paths from the vertex that corresponds to the substring sleftsleft + 1..sright, visiting exactly n24 red vertices using only non-self-loop transitions. Each value of the table can be found in O(1) time, thus the whole table can be computed in O(|s|3) time, which is fast enough for the input size (|s| ≤ 200).The main obstacle will be the second part. For example, let us consider the case where s = \"abaac\", N = 11, n24 = 2, which corresponds to the example at the beginning. From the fact we found earlier, n25 = ⌈(|s| - n24) / 2⌉ = ⌈(5 - 2) / 2⌉ = 2. Thus, we have to insert ⌈N / 2⌉ - n24 - n25 = 6 - 2 - 2 = 2 self-loop transitions into this path (the image): The order in which red, green and blue vertices appears in this path does not affect the number of ways of insertion, and can be arbitrary. The number of ways to insert 2 self-loop transitions will be equal to the number of the path of length ⌈N / 2⌉ = 6 from START to GOAL in this automaton (we have to take into account the non-self-loop transitions in it), which can be calculated by matrix exponentiation.Are we done? No! Consider the case s = \"abbb..(|s| - 1 times)..bb\". There are |s| - 1 possible values of n24 (n24 = 1 corresponds to the case where you match and discard the 'a' first, and n24 = |s| - 1 corresponds to the case where you keep the 'a' until s becomes \"ab\"). Thus, you need to perform matrix exponentiation |s| - 1 times, which results in a total of time, which will be too much under the given constraints.There is still hope, though, and here is the climax. Notice that these automata are very similar to each other, and they differ only in the number of the red and green vertices. We can combine these automata into one larger automaton like this (the image): The combined automaton should have |s| - 1 red, ⌈|s| / 2⌉ green and ⌈|s| / 2⌉ blue vertices.By performing matrix exponentiation on this automaton instead of many small automata, we can find all the required value in time, which should be enough. We recommend speeding up matrix multiplication by noticing that the matrix will be upper triangular (6 times faster on paper), since the time limit is not so generous (in order to reject solutions).The problem is almost solved, but there is one more challenge. When N is odd, the situation becomes a little complicated: as we have seen at the beginning, in the last (⌈N / 2⌉-th) step of producing a palindrome we choose a letter for only one position of the resulting string, that is, the center of that string. In other words, the last transition in the path in the automaton we have first built must not be one from a green vertex with a string of length 2 (for example, \"aa\") to GOAL.Let us find the number of the paths that violates this condition and subtract it from the answer. As previously mentioned, for each path n24 + 2·n25 will be equal to either |s| or |s| + 1, and if we fix the value of n24, n25 will be uniquely determined by n25 = ⌈(|s| - n24) / 2⌉. If |s| - n24 is odd, then it means that the last non-self-loop transition is one from a green vertex with a string of length 1, therefore in this case no path will violate the condition. If |s| - n24 is even, then the last non-self-loop trantision is from a green vertex with a string of length 2, thus the paths that does not contain the self-loop from GOAL to itself violate the condition. It will be equal to the number of the paths of length ⌈N / 2⌉ - 1 from START to the vertex just before GOAL, which can be found in a similar way to the second part of the solution.The journey has finally come to an end. Actually, it is also possible to solve this problem in time without matrix exponentiation, but this margin is too small to explain it. I will just paste the link to the code.The writer's code (matrix exponentiation, C++): 9501164The writer's code (without matrix exponentiation, C++): 9501177Congratulations again to Petr who was the only participant to solve this problem in 108 minutes. Also, I would like to give a special mention to rng_58, who was VERY close to solving it in only 63 minutes. He was just one byte away from getting AC (compare 9460984 and 9465440)! If you find a possible error, or have a question, please feel free to ask here. Alternative solutions are also welcome.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/15889",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 505\\s*D"
          },
          "content_length": 23595
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #286 - Codeforces - Code 1",
          "code": "This is the 3rd time(following #162 and #263) for me",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #286 - Codeforces - Code 2",
          "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N = 1e2 + 5;\n\nint parent[N][N];\n\nint find(int c, int v) {\n    if (parent[c][v] == -1)\n        return v;\n    return parent[c][v] = find(c, parent[c][v]);\n}\n\nvoid unite(int c, int u, int v) {\n    parent[c][find(c, u)] = find(c, v);\n}\n\nint main() {\n    memset(parent, -1, sizeof parent);\n    int n, m;\n    cin >> n >> m;\n    for (int i = 0; i < m; ++i) {\n        int a, b, c;\n        cin >> a >> b >> c;\n        unite(c, a, b);\n    }\n    int q;\n    cin >> q;\n    while (q--) {\n        int u, v, ans = 0;\n        cin >> u >> v;\n        for (int i = 1; i <= 100; ++i)\n            if (find(i, u) == find(i, v))\n                ++ans;\n        cout << ans << '\\n';\n    }\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/15842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #286 - Codeforces - Code 3",
          "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N = 1e2 + 5;\n\nint parent[N][N];\n\nint find(int c, int v) {\n    if (parent[c][v] == -1)\n        return v;\n    return parent[c][v] = find(c, parent[c][v]);\n}\n\nvoid unite(int c, int u, int v) {\n    parent[c][find(c, u)] = find(c, v);\n}\n\nint main() {\n    memset(parent, -1, sizeof parent);\n    int n, m;\n    cin >> n >> m;\n    for (int i = 0; i < m; ++i) {\n        int a, b, c;\n        cin >> a >> b >> c;\n        unite(c, a, b);\n    }\n    int q;\n    cin >> q;\n    while (q--) {\n        int u, v, ans = 0;\n        cin >> u >> v;\n        for (int i = 1; i <= 100; ++i)\n            if (find(i, u) == find(i, v))\n                ++ans;\n        cout << ans << '\\n';\n    }\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/15842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #286 - Codeforces - Code 4",
          "code": "Runtime Error",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #286 - Codeforces - Code 5",
          "code": "Memory Limit Exceeded",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #286 - Codeforces - Code 6",
          "code": "7 8\n1 2\n1 3\n2 4\n3 4\n4 5\n4 6\n5 7\n6 7",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #286 - Codeforces - Code 7",
          "code": "7 8\n1 2\n1 3\n2 4\n3 4\n4 5\n4 6\n5 7\n6 7",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #286 - Codeforces - Code 8",
          "code": "Test: #12 ... verdict: WRONG_ANSWER\nInput\n1 30000\n30000\nOutput\n0\nAnswer\n1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #286 - Codeforces - Code 9",
          "code": "Test: #12 ... verdict: WRONG_ANSWER\nInput\n1 30000\n30000\nOutput\n0\nAnswer\n1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #286 - Codeforces - Code 10",
          "code": "unordered_map",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #286 - Codeforces - Code 11",
          "code": "res += (pars[c][u] == pars[c][v]);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #286 - Codeforces - Code 12",
          "code": "res += (pars[c][u] == pars[c][v]);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #286 - Codeforces - Code 13",
          "code": "if (pars[c].find(v) != pars[c].end() && pars[c][u] == pars[c][v]) {\n    res++;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #286 - Codeforces - Code 14",
          "code": "if (pars[c].find(v) != pars[c].end() && pars[c][u] == pars[c][v]) {\n    res++;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #286 Editorial (Complete) - Codeforces - Code 1",
          "code": "dp[i][j - offset]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15889",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #286 Editorial (Complete) - Codeforces - Code 2",
          "code": "components[x] & components[y]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15889",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #286 Editorial (Complete) - Codeforces - Code 3",
          "code": "7 8\n1 2\n2 3\n3 4\n4 1\n4 7\n7 6\n6 5\n5 2\n\nAuthor's Code on my Pc returns 7",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15889",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #286 Editorial (Complete) - Codeforces - Code 4",
          "code": "7 8\n1 2\n2 3\n3 4\n4 1\n4 7\n7 6\n6 5\n5 2\n\nAuthor's Code on my Pc returns 7",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15889",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #286 Editorial (Complete) - Codeforces - Code 5",
          "code": "Also, for each j (1 ≤ j ≤ ti), find the day di, j such that, if the j-th beat on the i-th bamboo is performed before day di, it will be no longer possible to keep the i-th bamboo's height after m days at most X (it can be found by doing simple math).",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15889",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #286 Editorial (Complete) - Codeforces - Code 6",
          "code": "if(target - h[i] <= 0){\n\tt[0]++;\n}else if(target - h[i] > a[i] * (m-1)){\n\tok = 0;\n\tgoto end;\n}else{\n\tt[(target - h[i] + a[i] - 1) / a[i]]++;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15889",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #286 Editorial (Complete) - Codeforces - Code 7",
          "code": "if(target - h[i] <= 0){\n\tt[0]++;\n}else if(target - h[i] > a[i] * (m-1)){\n\tok = 0;\n\tgoto end;\n}else{\n\tt[(target - h[i] + a[i] - 1) / a[i]]++;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15889",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #286 Editorial (Complete) - Codeforces - Code 8",
          "code": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\n#define pb push_back\n#define __addEdge(u, v) [u].push_back(v)\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<vi> vmi;\n\nint n, m;\nvmi G[111];\nvb mark;\n\nvoid dfs(vmi &SG, int u)\n{\n    mark[u] = true;\n    for (int i = 0; i < SG[u].size(); ++i)\n    {\n        int v = SG[u][i];\n        if (!mark[v])\n            dfs(SG, v);\n    }\n}\n\nint main()\n{\n    cin >> n >> m;\n\n    fill(G, G + 111, vmi(n + 1));\n    mark.assign(n + 1, false);\n    for (int i = 0; i < m; ++i)\n    {\n        int u, v, c;\n        cin >> u >> v >> c;\n        G[c]__addEdge(u, v);\n        G[c]__addEdge(v, u);\n    }\n\n    int q;\n    cin >> q;\n\n    while (q--)\n    {\n        int u, v;\n        cin >> u >> v;\n\n        int cnt = 0;\n        for (int k = 1; k <= 100; ++k)\n        {\n            fill(mark.begin(), mark.end(), false);\n            dfs(G[k], u);\n            cnt += mark[v];\n        }\n\n        cout << cnt << endl;\n    }   \n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/15889",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #286 Editorial (Complete) - Codeforces - Code 9",
          "code": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\n#define pb push_back\n#define __addEdge(u, v) [u].push_back(v)\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<vi> vmi;\n\nint n, m;\nvmi G[111];\nvb mark;\n\nvoid dfs(vmi &SG, int u)\n{\n    mark[u] = true;\n    for (int i = 0; i < SG[u].size(); ++i)\n    {\n        int v = SG[u][i];\n        if (!mark[v])\n            dfs(SG, v);\n    }\n}\n\nint main()\n{\n    cin >> n >> m;\n\n    fill(G, G + 111, vmi(n + 1));\n    mark.assign(n + 1, false);\n    for (int i = 0; i < m; ++i)\n    {\n        int u, v, c;\n        cin >> u >> v >> c;\n        G[c]__addEdge(u, v);\n        G[c]__addEdge(v, u);\n    }\n\n    int q;\n    cin >> q;\n\n    while (q--)\n    {\n        int u, v;\n        cin >> u >> v;\n\n        int cnt = 0;\n        for (int k = 1; k <= 100; ++k)\n        {\n            fill(mark.begin(), mark.end(), false);\n            dfs(G[k], u);\n            cnt += mark[v];\n        }\n\n        cout << cnt << endl;\n    }   \n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/15889",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(2, 100000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 100000, \"m\");\n    inf.readEoln();\n    set<pair<int, int>> s;\n    for (int i = 0; i < m; ++i) {\n        int ai = inf.readInt(1, n, \"ai\");\n        inf.readSpace();\n        int bi = inf.readInt(1, n, \"bi\");\n        inf.readEoln();\n        ensuref(ai != bi, \"ai and bi should be different on line %d\", i + 2);\n        pair<int, int> p = make_pair(ai, bi);\n        ensuref(s.count(p) == 0, \"Pair (%d, %d) appears more than once (line %d)\", ai, bi, i + 2);\n        s.insert(p);\n    }\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(2, 100000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 100000, \"m\");\n    inf.readEoln();\n    set<pair<int, int>> s;\n    for (int i = 0; i < m; ++i) {\n        int ai = inf.readInt(1, n, \"ai\");\n        inf.readSpace();\n        int bi = inf.readInt(1, n, \"bi\");\n        inf.readEoln();\n        ensuref(ai != bi, \"ai and bi should be different on line %d\", i + 2);\n        pair<int, int> p = make_pair(ai, bi);\n        ensuref(s.count(p) == 0, \"Pair (%d, %d) appears more than once (line %d)\", ai, bi, i + 2);\n        s.insert(p);\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(2, 100000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 100000, \"m\");\n    inf.readEoln();\n    set<pair<int, int>> s;\n    for (int i = 0; i < m; ++i) {\n        int ai = inf.readInt(1, n, \"ai\");\n        inf.readSpace();\n        int bi = inf.readInt(1, n, \"bi\");\n        inf.readEoln();\n        ensuref(ai != bi, \"ai and bi should be different on line %d\", i + 2);\n        pair<int, int> p = make_pair(ai, bi);\n        ensuref(s.count(p) == 0, \"Pair (%d, %d) appears more than once (line %d)\", ai, bi, i + 2);\n        s.insert(p);\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef pair<int,int> pii;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string type = opt<string>(\"type\", \"random\");\n    int s = opt<int>(\"s\", 1); // optional parameter for certain types\n\n    vector<pii> pairs;\n\n    if (type == \"random\") {\n        set<pii> used;\n        while ((int)pairs.size() < m) {\n            int a = rnd.next(1, n);\n            int b = rnd.next(1, n);\n            if (a == b)\n                continue;\n            pii p(a, b);\n            if (used.insert(p).second)\n                pairs.push_back(p);\n        }\n    } else if (type == \"one_to_all\") {\n        int a = s; // default 1\n        for (int b = 1; b <= n; ++b) {\n            if (a == b)\n                continue;\n            pairs.push_back(pii(a, b));\n            if ((int)pairs.size() == m)\n                break;\n        }\n    } else if (type == \"all_to_one\") {\n        int b = s; // default 1\n        for (int a = 1; a <= n; ++a) {\n            if (a == b)\n                continue;\n            pairs.push_back(pii(a, b));\n            if ((int)pairs.size() == m)\n                break;\n        }\n    } else if (type == \"chain\") {\n        for (int i = 1; i < n; ++i) {\n            pairs.push_back(pii(i, i+1));\n            if ((int)pairs.size() == m)\n                break;\n        }\n    } else if (type == \"star\") {\n        int center = s;\n        for (int i = 1; i <= n; ++i) {\n            if (i == center)\n                continue;\n            pairs.push_back(pii(center, i));\n            if ((int)pairs.size() == m)\n                break;\n        }\n    } else if (type == \"complete\") {\n        for (int a = 1; a <= n; ++a) {\n            for (int b = 1; b <= n; ++b) {\n                if (a == b)\n                    continue;\n                pairs.push_back(pii(a, b));\n                if ((int)pairs.size() == m)\n                    break;\n            }\n            if ((int)pairs.size() == m)\n                break;\n        }\n    } else {\n        // default to random if unrecognized type\n        set<pii> used;\n        while ((int)pairs.size() < m) {\n            int a = rnd.next(1, n);\n            int b = rnd.next(1, n);\n            if (a == b)\n                continue;\n            pii p(a, b);\n            if (used.insert(p).second)\n                pairs.push_back(p);\n        }\n    }\n    // Adjust m if necessary\n    if ((int)pairs.size() < m) {\n        m = (int)pairs.size();\n    }\n\n    printf(\"%d %d\\n\", n, m);\n    for (int i = 0; i < m; ++i) {\n        printf(\"%d %d\\n\", pairs[i].first, pairs[i].second);\n    }\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef pair<int,int> pii;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string type = opt<string>(\"type\", \"random\");\n    int s = opt<int>(\"s\", 1); // optional parameter for certain types\n\n    vector<pii> pairs;\n\n    if (type == \"random\") {\n        set<pii> used;\n        while ((int)pairs.size() < m) {\n            int a = rnd.next(1, n);\n            int b = rnd.next(1, n);\n            if (a == b)\n                continue;\n            pii p(a, b);\n            if (used.insert(p).second)\n                pairs.push_back(p);\n        }\n    } else if (type == \"one_to_all\") {\n        int a = s; // default 1\n        for (int b = 1; b <= n; ++b) {\n            if (a == b)\n                continue;\n            pairs.push_back(pii(a, b));\n            if ((int)pairs.size() == m)\n                break;\n        }\n    } else if (type == \"all_to_one\") {\n        int b = s; // default 1\n        for (int a = 1; a <= n; ++a) {\n            if (a == b)\n                continue;\n            pairs.push_back(pii(a, b));\n            if ((int)pairs.size() == m)\n                break;\n        }\n    } else if (type == \"chain\") {\n        for (int i = 1; i < n; ++i) {\n            pairs.push_back(pii(i, i+1));\n            if ((int)pairs.size() == m)\n                break;\n        }\n    } else if (type == \"star\") {\n        int center = s;\n        for (int i = 1; i <= n; ++i) {\n            if (i == center)\n                continue;\n            pairs.push_back(pii(center, i));\n            if ((int)pairs.size() == m)\n                break;\n        }\n    } else if (type == \"complete\") {\n        for (int a = 1; a <= n; ++a) {\n            for (int b = 1; b <= n; ++b) {\n                if (a == b)\n                    continue;\n                pairs.push_back(pii(a, b));\n                if ((int)pairs.size() == m)\n                    break;\n            }\n            if ((int)pairs.size() == m)\n                break;\n        }\n    } else {\n        // default to random if unrecognized type\n        set<pii> used;\n        while ((int)pairs.size() < m) {\n            int a = rnd.next(1, n);\n            int b = rnd.next(1, n);\n            if (a == b)\n                continue;\n            pii p(a, b);\n            if (used.insert(p).second)\n                pairs.push_back(p);\n        }\n    }\n    // Adjust m if necessary\n    if ((int)pairs.size() < m) {\n        m = (int)pairs.size();\n    }\n\n    printf(\"%d %d\\n\", n, m);\n    for (int i = 0; i < m; ++i) {\n        printf(\"%d %d\\n\", pairs[i].first, pairs[i].second);\n    }\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Small sizes\n./gen -n 2 -m 1 -type random\n./gen -n 5 -m 4 -type chain\n./gen -n 5 -m 4 -type star -s 3\n./gen -n 5 -m 4 -type one_to_all -s 2\n./gen -n 5 -m 4 -type all_to_one -s 5\n./gen -n 5 -m 20 -type complete\n\n# Medium sizes\n./gen -n 100 -m 200 -type random\n./gen -n 100 -m 99 -type chain\n./gen -n 100 -m 99 -type star\n./gen -n 100 -m 99 -type one_to_all -s 50\n./gen -n 100 -m 99 -type all_to_one -s 50\n\n# Large sizes\n./gen -n 1000 -m 5000 -type random\n./gen -n 1000 -m 999 -type chain\n./gen -n 1000 -m 999 -type star\n./gen -n 1000 -m 999 -type one_to_all -s 500\n./gen -n 1000 -m 999 -type all_to_one -s 500\n\n# Edge cases\n./gen -n 100000 -m 100000 -type random\n./gen -n 100000 -m 99999 -type chain\n./gen -n 100000 -m 99999 -type star -s 100000\n./gen -n 100000 -m 99999 -type one_to_all -s 1\n./gen -n 100000 -m 99999 -type all_to_one -s 100000\n\n# Maximum possible\n./gen -n 100000 -m 100000 -type one_to_all -s 1\n./gen -n 100000 -m 100000 -type all_to_one -s 100000\n\n# Special cases\n./gen -n 100000 -m 100000 -type star -s 1\n./gen -n 100000 -m 99999 -type chain\n\n# Complete graph (small n)\n./gen -n 100 -m 9900 -type complete\n\n# Random with maximum m for small n\n./gen -n 1000 -m 100000 -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:40:39.307314",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "505/E",
      "title": "E. Mr. Kitayuta vs. Bamboos",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line of the input contains four space-separated integers n, m, k and p (1 ≤ n ≤ 105, 1 ≤ m ≤ 5000, 1 ≤ k ≤ 10, 1 ≤ p ≤ 109). They represent the number of the bamboos in Mr. Kitayuta's garden, the duration of Mr. Kitayuta's fight in days, the maximum number of times that Mr. Kitayuta beat the bamboos during each day, and the power of Magic Hammer, respectively.The following n lines describe the properties of the bamboos. The i-th of them (1 ≤ i ≤ n) contains two space-separated integers hi and ai (0 ≤ hi ≤ 109, 1 ≤ ai ≤ 109), denoting the initial height and the growth rate of the i-th bamboo, respectively.",
      "output_spec": "OutputPrint the lowest possible height of the tallest bamboo after m days.",
      "sample_tests": "ExamplesInputCopy3 1 2 510 1010 1015 2OutputCopy17InputCopy2 10 10 10000000000 100 10OutputCopy10InputCopy5 3 3 109 59 24 79 103 8OutputCopy14",
      "description": "E. Mr. Kitayuta vs. Bamboos\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line of the input contains four space-separated integers n, m, k and p (1 ≤ n ≤ 105, 1 ≤ m ≤ 5000, 1 ≤ k ≤ 10, 1 ≤ p ≤ 109). They represent the number of the bamboos in Mr. Kitayuta's garden, the duration of Mr. Kitayuta's fight in days, the maximum number of times that Mr. Kitayuta beat the bamboos during each day, and the power of Magic Hammer, respectively.The following n lines describe the properties of the bamboos. The i-th of them (1 ≤ i ≤ n) contains two space-separated integers hi and ai (0 ≤ hi ≤ 109, 1 ≤ ai ≤ 109), denoting the initial height and the growth rate of the i-th bamboo, respectively.\n\nOutputPrint the lowest possible height of the tallest bamboo after m days.\n\nInputCopy3 1 2 510 1010 1015 2OutputCopy17InputCopy2 10 10 10000000000 100 10OutputCopy10InputCopy5 3 3 109 59 24 79 103 8OutputCopy14\n\nInputCopy3 1 2 510 1010 1015 2\n\nOutputCopy17\n\nInputCopy2 10 10 10000000000 100 10\n\nOutputCopy10\n\nInputCopy5 3 3 109 59 24 79 103 8\n\nOutputCopy14",
      "solutions": [
        {
          "title": "Codeforces Round #286 - Codeforces",
          "content": "Hello Codeforces!evima, yosupo and I would like you to participate in Codeforces Round #286. It will be held on Sunday, January 18th at 16:00 MSK. Please note that this round starts on unusual time.Great thanks to Zlobober who helped us prepare this round, Delinur who translated statements into Russian and MikeMirzayanov who created Codeforces and polygon.This is the 3rd time(following #162 and #263) for me, and the 1st time for evima and yosupo to prepare a Codeforces Round.Scores of the problems will be500-1000-1750-1750-2500 for Div.1, and500-1000-1500-2000-2750 for Div.2.In this round, you'll help a man named Mr. kitayuta. I hope he will participate :)The system tests are now over! The top-5 are as follows:Div.1:1.ilyakor2.kcm17003.LayCurse4.RomaWhite5.TankEngineerDiv.2:1.Konijntje2.cpcpc3.zgzjsxshycxksxhsh4.Ronnie0075.sha384Also, special congrats on Petr, who solved problem E in Div.1, which anyone else could not solve.Here are the editorials",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/15842",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 961
        },
        {
          "title": "Codeforces Round #286 Editorial (Complete) - Codeforces",
          "content": "Edit (Jan 22, 2:45 AM UTC): Added Div1E and the editorial is now complete. I am sorry for the delay.Edit (Jan 21, 9:45 AM UTC): Added the explanation for Div1C/2E, and the problem setters' codes. Div1E will need several more hours. Thank you again for your patience.First, here are some statistics on this round: Division Registrants Participants A Accepted B Accepted C Accepted D Accepted E Accepted 1 1364 572 (*) 294 199 8 113 1 (Estimated number of AC by me) 800 (wrong) 500 (wrong) 70 (FAIL) 90 (ok) 5 (wrong) 2 4016 2028 1355 945 41 5 0 (*) Where did the remaining 792 people go? :) We are sorry for terribly underestimating the difficulty of the problems (except Div1D), especially Div1A/2C and Div1C/2E. Div.2 A: 505A - Mr. Kitayuta's Gift[Problem] Given a string, turn it into a palindrome by inserting one letter or state that it is impossible.(Problem by evima)Since the string is short (at most 10 characters), you can simply try every possible way of inserting a letter (\"where\" and \"what\" to insert), and check if the resulting string is a palindrome.The writer's code (C++): 9501249Note: For some strange reason, we (contest managers) cannot submit solutions so that everyone can see them. PraveenDhinwa told us how to do so. Thank you! Div.2 B: 505B - Mr. Kitayuta's Colorful Graph[Problem] Given an undirected graph whose edges are painted in colors, process the queries of the following form: Given two vertices ui and vi, find the number of the colors that satisfies the following condition: the edges of that color connect ui and vi (possibly indirectly). (Problem by hogloid)Since neither the graph nor the number of queries is too large, for each query you can simply count the number of the \"good\" colors (the colors that satisfies the condition) by checking if each color is \"good\". To do that, you can perform Depth First Search (or Breadth First Search) and verify whether you can reach vi from ui traversing only the edges of that color. If you prefer using Union-Find, it will also do the job.The writer's code (DFS, C++)The writer's code (Union-Find, C++) Div.2 C / Div.1 A: 505C - Mr. Kitayuta, the Treasure Hunter[Problem] Since it is hard to summarize this problem, please refer to the official statement.(Problem by yosupo)Below is the explanation from yosupo, translated by me.[From here]Let m be the number of the islands (that is, 30001). First, let us describe a solution with time and memory complexity of O(m2).We will apply Dynamic Programming. let dp[i][j] be the number of the gems that Mr. Kitayuta can collect after he jumps to island i, when the length of his previous jump is j (let us assume that he have not collect the gems on island i). Then, you can calculate the values of the table dp by the following: dp[i][j] = 0, if i ≥ m(actually these islands do not exist, but we can suppose that they exist and when Mr. Kitayuta jumps to these islands, he stops jumping) dp[i][j] =  (the number of the gems on island i)  + max(dp[i + j][j], dp[i + j + 1][j + 1]), if i < m, j = 1(he cannot perform a jump of length 0) dp[i][j] =  (the number of the gems on island i)  + max(dp[i + j - 1][j - 1], dp[i + j][j], dp[i + j + 1][j + 1]), if i < m, j ≥ 2 This solution is unfeasible in terms of both time and memory. However, the following observation makes it an Accepted solution: there are only 491 values of j that we have to consider, which are d - 245, d - 244, d - 243, ..., d + 244 and d + 245.Why? First, let us find the upper bound of j. Suppose Mr. Kitayuta always performs the \"l + 1\" jump (l: the length of the previous jump). Then, he will reach the end of the islands before he performs a jump of length d + 246, becaused + (d + 1) + (d + 2) + ... + (d + 245) ≥ 1 + 2 + ... + 245 = 245·(245 + 1) / 2 = 30135 > 30000. Thus, he will never be able to perform a jump of length d + 246 or longer.Next, let us consider the lower bound of j in a similar way. If d ≤ 246, then obviously he will not be able to perform a jump of length d - 246 or shorter, because the length of a jump must be positive. Suppose Mr. Kitayuta always performs the \"l - 1\" jump, where d ≥ 247. Then, again he will reach the end of the islands before he performs a jump of length d - 246, becaused + (d - 1) + (d - 2) + ... + (d - 245) ≥ 245 + 244 + ... + 1 = 245·(245 + 1) / 2 = 30135 > 30000. Thus, he will never be able to perform a jump of length d - 246 or shorter.Therefore, we have obtained a working solution: similar to the O(m2) one, but we will only consider the value of j between d - 245 and d + 245. The time and memory complexity of this solution will be O(m1.5), since the value \"245\" is slightly larger than .This solution can be implemented by, for example, using a \"normal\" two dimensional array with a offset like this: dp[i][j - offset]. The time limit is set tight in order to fail most of naive solutions with search using std::map or something, so using hash maps (unordered_map) will be risky although the complexity will be the same as the described solution.[End]The writer's code (memoized recursion, C++) Div.2 D / Div.1 B: 505D - Mr. Kitayuta's Technology[Problem] Given an integer n and m pairs of integers (ai, bi) (1 ≤ ai, bi ≤ n), find the minimum number of edges in a directed graph that satisfies the following condition: For each i, there exists a path from vertex ai to vertex bi. (Problem from evima)Let G1 be the directed graph built from the input, and G2 be a directed graph that satisfies the given conditions. What we seek is the minimum number of edges in G2. Also, we say that two vertices u and v in a directed graph are \"weakly connected\" if we can reach v from u by traversing edges, not considering their directions.If a pair (u, v) is present in the input, then vertices u and v must be weakly connected in G2. Therefore, for each weakly connected component (abbreviated to wcc) in G1, the vertices in that component must also be in the same wcc in G2. We can \"merge\" multiple wccs in G1 and create a larger wcc in G2, but for now, let us find the minimum number of edges required in G2 for each wcc in G1 when we do not \"merge\" them. There are two cases to consider: If a wcc in G1 does not have cycles, then we can perform topological sort on that wcc, and we can make a \"chain\" (see the image below) using the topological order to satisfy the conditions. We need (the number of the vertices in the wcc)  - 1 edges, which is the minimum required number since any connected graph with V vertices has at least V - 1 edges. If a wcc in G1 has cycles, then topological sort cannot be applied. We need at least (the number of the vertices in the wcc) edges this time, since any connected graph with V vertices and V - 1 edges is a tree, which does not contain cycles. Actually, this number (the number of the vertices in the wcc) is always achievable by connecting the vertices into a \"ring\" (see the image below), thus it is the minimum required number that we seek. We have found the minimum required number of edges for each wcc in G1 when we do not \"merge\" them. Let us show that \"merging\" wccs in G1 do not reduce the number of required edges. Suppose we combine k( > 1) wccs C1, C2, ..., Ck in G1 into one wcc C in G2. Again, there are two cases to consider: If none of C1, C2, ..., Ck contains cycles, then C will need |C1| + |C2| + ... + |Ck| - 1 edges. However, if we do not combine them, we will only need (|C1| - 1) + (|C2| - 1) + ... + (|Ck| - 1) edges in total, which is fewer. If some of C1, C2, ..., Ck contain cycles, then C will need |C1| + |C2| + ... + |Ck| edges. However, if we do not combine them, we will need(|C1| - noCycles(C1)) + (|C2| - noCycles(C2)) + ... + (|Ck| - noCycles(Ck)  ≤ |C1| + |C2| + ... + |Ck| edges(here, noCycles(Ci) is 1 if Ci do not contain cycles, otherwise 0), thus combining them does not reduce the number of required edges. Thus, we do not need to combine multiple wccs into one wcc in G2 in order to obtain the optimal solution. That is, the final answer to the problem is the sum of the minimum required number of edges for each wcc in G1, when they are considered separately.As for the implementation, detecting cycles in a directed graph with 105 vertices and edges might be a problem if this is your first encounter with it. One possible way is to paste a code that decomposes a graph into strongly connected components. If the size of a strongly connected component is more than one, then that means the component contains cycles.The writer's code (strongly connected component decomposition, C++): 9501202 Div.2 E / Div.1 C: 505E - Mr. Kitayuta vs. Bamboos[Problem] Since it is hard to summarize this problem, please refer to the official statement.(Problem from yosupo)Below is the explanation from yosupo, translated by me.[From here]Let us begin by applying Binary Search. The problem becomes: \"is it possible that all the bamboos are at most X meters after m days?\" It is complicated by the fact that the height does not become negative; the excessive decrease will be wasted. We have found two approaches to this problem. Solution 1 Mr. Kitayuta must beat the i-th bamboo at least max(0, ⌈(hi + m·ai - X) / P⌉) times (let this number ti). Actually, it is not necessary for him to beat it more than this number of times. Thus, let us assume that he beat the i-th bamboo exactly ti times. Also, for each j (1 ≤ j ≤ ti), find the day di, j such that, if the j-th beat on the i-th bamboo is performed before day di, it will be no longer possible to keep the i-th bamboo's height after m days at most X (it can be found by doing simple math). If Mr. Kitayuta can beat the bamboos under this constraint, all the bamboos' heights will become X meters or less after m days. Otherwise, some bamboos' heights will exceed X meters.The time complexity of this solution will be , if we first calculate only ti, then if the sum of ti exceeds km, we skip finding di, j (the answer is \"NO\"). Solution 2 This problem becomes simpler if we simulate Mr. Kitayuta's fight backwards, that is, from day m to day 1. It looks like this:[Problem'] There are n bamboos. At the moment, the height of the i-th bamboo is X meters, and it shrinks ai meters at the beginning of each day. Mr. Kitayuta will play a game. He can use Magic Hammer at most k times per day to increase the height of a bamboo by p meters. If some bamboo's height becomes negative at any moment, he will lose the game immediately. Also, in order for him to win the game, the i-th bamboo's height must be at least hi meters after m days. Is victory possible?Below is an illustration of this \"reverse simulation\": This version is simpler because he is increasing the heights instead of decreasing, thus we do not need to take into account the \"excessive decrease beyond 0 meters\" which will be wasted. Let us consider an optimal strategy. If there exist bamboos whose heights would become negative after day m, he should beat the one that is the earliest to make him lose. Otherwise, he can choose any bamboo whose height would be less than hi meters after day m. Repeat beating the bamboos following this strategy, and see if he can actually claim victory.The writer's implementation of this solution uses a priority queue, and its time complexity is .[End]The tester's code (Solution 1, C++): 9501229The writer's code (Solution 2, C++) Div.1 D: 506D - Mr. Kitayuta's Colorful Graph[Problem] Given an undirected graph whose edges are painted in colors, process the queries of the following form: Given two vertices ui and vi, find the number of the colors that satisfies the following condition: the edges of that color connect ui and vi (possibly indirectly). Note: this is the exact same problem as Div.2 B except the constraints, which are 105 instead of 100.(Problem from hogloid)Below is the explanation from hogloid.[From here]For each color, make a new graph that consists of the edges of the color and vertices connected by the edges. Make UnionFind for each graph, and you can check whether a color connects vertex A and B , using it. For each query, find a vertex which has smaller degree(let this vertex A, and the other vertex B) For each colors such that a edge of the color connects to A, check whether A and B is connected by the color. After answering the query, memorize its tuple — (A, B, answer). If the same query is requested, answer using this information.This will lead to solution.For each query, the complexity is (For each color connects A, find a vertex of B of the color & check whether they are connected) The queries that require longest computing time are, to ask every pair among vertices which have largest degrees. Let the indices of the vertices be , and degrees of the vertices be d1, d2, ...dk. Now, let's fix vertex B as i. The total computing time of the queries such that B is vertex i is . Vertex B can vary from 2 to k. Hence, the total complexity is at most . This complexity is at most .By the way, in C++, using unordered_map, total complexity would be .[End]There will be many other solutions. I will briefly explain one of them which I think is typical.Let ci be the number of colors of the edges incident to vertex i. The sum of all ci does not exceed 2m since each edge increases this sum by at most 2. Thus, there will be at most 450 values of i such that ci ≥ 450 (let B = 450). We will call these vertices large, and the remaining ones small. Using O(m / B·m) = O(m2 / B) time and memory, we can precalculate and store the answer for all the possible queries where at least one of ui and vi is large, then we can immediately answer these queries. For the remaining queries, both ui and vi will be small, therefore it is enough to directly count the color that connects vertices ui and vi in O(B) time. The total time required will be O(m2 / B + Bq). If we choose , we can solve the problem in time.The writer's code (the first solution, C++)The tester's code (the second solution, C++): 9501240 Div.1 E: 506E - Mr. Kitayuta's Gift[Problem] Given a string s and an integer n, find the number of the palindromes that can be obtained by inserting exactly n letters into s.Note: Div.2 A is a similar problem, where n is fixed to 1.(Problem from evima)First of all, let us note that we are asked to count the resulting palindromes, not the ways to obtain them. For example, if we are to insert \"b\" into \"abba\", there are 5 possible positions, but only 3 strings will be produced (\"babba\", \"abbba\" and \"abbab\"). Rather than trying to count the ways of inserting a letter n times and removing the duplicated results, we should directly count the resulting palindrome. To do that, let us reformulate the problem:[Problem'] Given a string s and an integer n, find the number of the palindromes of length |s| + n (let this number be N) that contains s as a subsequence (not necessarily contiguous).Consider constructing a palindrome from both ends, and matching it to s from both left and right. For example, let s = \"abaac\" and N = 11. Let us call the final resulting string t. We first decide what letter to use as t1 and t11 (they must be equal in order for t to be a palindrome). Let us say 'c' is chosen. Now, we have to construct the remaining part of t, that is, t2..t10, so that t2..t10 contains \"abaa\" as a substring (note that the 'c' at the end of s is discarded). Again, we decide what letter to use as t2 and t10. This time we choose 'a'. Then, we have to construct t3..t9, so that it contains \"ba\" as a substring (this time the two 'a's at the both ends of s are discarded). We choose t3 = t9 = 'c'. Next, we construct t4..t8, so that it contains \"ba\" as a substring (this time s remains unchanged). We choose t4 = t8 = 'b'. Then, we construct t5..t7, so that it contains \"a\" as a substring. We choose t5 = t7 = 'a' (it is becoming repetitive, isn't it?). The last part of t, that is, t6, has no restriction (this time we choose a letter for only one position of t, not two). We choose 'd', and we have obtained a palindrome \"cacbadabcac\" that contains s = \"abaac\" as a subsequence.This problem is mostly about analyzing this process carefully.The most naive solution other than literally enumerating all palindromes of length N would be the following Dynamic Programming: let dp[i][left][right] be the number of the palindromes t that can be obtained if you have already decided the leftmost and the rightmost i letters (2i in total), and the substring sleftsleft + 1..sright of s remains unmatched. Each value in this table can be computed in O(1) time. Of course, since i can be up to ⌊n / 2⌋ (n ≤ 109), this solution is far from our goal.Notice that the transitions from dp[i] to dp[i + 1] are the same regardless of i, thus we can calculate the table by matrix exponentiation. However, since there are O(|s|2) possible pairs for (left, right), we will need time, which is actually worse than the naive calculation considering that |s| can be up to 200.This is where we need to observe the process which we have gone through at the beginning more carefully. Let us build a automaton corresponding to the process (the image below). (*) An self-loop with a number means that there are actually that number of edges.A process of producing a palindrome of length N that contains s as a subsequence corresponds to a path of length ⌈N / 2⌉ from the upper-right vertex to the lower-left vertex. Each red vertex has 24 self-loops since the letters at the both ends of the remaining part of s is different, which correspond to two non-self-loop transitions. Similarly, each green vertex has 25 self-loops since the first letter and the last letter of the remaining string is the same, and the blue vertex, the destination, has 26 self-loops, as there are no more non-self-loop transitions available.Here is an important fact: there are not so many possible combination of (n24, n25), where n24 and n25 are the number of times a path from START to GOAL visits a red vertex (with 24 self-loops) and a green vertex (with 25 self-loops), respectively. Why? Each time we leave a red vertex, the length of the remaining unmatched part of s decreases by 1, since exactly one of the two letters at the ends of the remaining part is matched and discarded. Similarly, each time we leave a green vertex, the length of the remaining string decreases by 2, since both of the two letters at the ends are matched and discarded. There is a exception, however: if the length of the remaining string is 1, then it will be a green vertex, but in this case the length will decrease by 1. Thus, for any path from START to GOAL, n24 + 2·n25 will be equal to either |s| or |s| + 1. If we fix n24, then n25 will be uniquely determined by n25 = ⌈(|s| - n24) / 2⌉. Since n24 can only take the value between 0 and |s| - 1, there are at most |s| possible pairs of (n24, n25).With this fact, we are ready to count the paths: let us classify them by the value of n24. For each possible pair of (n24, n25), let us count the number of corresponding paths. To do that, we divide each paths into two parts: first we count the number of paths from START to GOAL, using only non-self-loop transitions. Then, we count the ways of inserting self-loop transitions into each of these paths. The product of these two numbers will be the number that we seek.The first part is straightforward to solve: let dp[left][right][n24] be the number of paths from the vertex that corresponds to the substring sleftsleft + 1..sright, visiting exactly n24 red vertices using only non-self-loop transitions. Each value of the table can be found in O(1) time, thus the whole table can be computed in O(|s|3) time, which is fast enough for the input size (|s| ≤ 200).The main obstacle will be the second part. For example, let us consider the case where s = \"abaac\", N = 11, n24 = 2, which corresponds to the example at the beginning. From the fact we found earlier, n25 = ⌈(|s| - n24) / 2⌉ = ⌈(5 - 2) / 2⌉ = 2. Thus, we have to insert ⌈N / 2⌉ - n24 - n25 = 6 - 2 - 2 = 2 self-loop transitions into this path (the image): The order in which red, green and blue vertices appears in this path does not affect the number of ways of insertion, and can be arbitrary. The number of ways to insert 2 self-loop transitions will be equal to the number of the path of length ⌈N / 2⌉ = 6 from START to GOAL in this automaton (we have to take into account the non-self-loop transitions in it), which can be calculated by matrix exponentiation.Are we done? No! Consider the case s = \"abbb..(|s| - 1 times)..bb\". There are |s| - 1 possible values of n24 (n24 = 1 corresponds to the case where you match and discard the 'a' first, and n24 = |s| - 1 corresponds to the case where you keep the 'a' until s becomes \"ab\"). Thus, you need to perform matrix exponentiation |s| - 1 times, which results in a total of time, which will be too much under the given constraints.There is still hope, though, and here is the climax. Notice that these automata are very similar to each other, and they differ only in the number of the red and green vertices. We can combine these automata into one larger automaton like this (the image): The combined automaton should have |s| - 1 red, ⌈|s| / 2⌉ green and ⌈|s| / 2⌉ blue vertices.By performing matrix exponentiation on this automaton instead of many small automata, we can find all the required value in time, which should be enough. We recommend speeding up matrix multiplication by noticing that the matrix will be upper triangular (6 times faster on paper), since the time limit is not so generous (in order to reject solutions).The problem is almost solved, but there is one more challenge. When N is odd, the situation becomes a little complicated: as we have seen at the beginning, in the last (⌈N / 2⌉-th) step of producing a palindrome we choose a letter for only one position of the resulting string, that is, the center of that string. In other words, the last transition in the path in the automaton we have first built must not be one from a green vertex with a string of length 2 (for example, \"aa\") to GOAL.Let us find the number of the paths that violates this condition and subtract it from the answer. As previously mentioned, for each path n24 + 2·n25 will be equal to either |s| or |s| + 1, and if we fix the value of n24, n25 will be uniquely determined by n25 = ⌈(|s| - n24) / 2⌉. If |s| - n24 is odd, then it means that the last non-self-loop transition is one from a green vertex with a string of length 1, therefore in this case no path will violate the condition. If |s| - n24 is even, then the last non-self-loop trantision is from a green vertex with a string of length 2, thus the paths that does not contain the self-loop from GOAL to itself violate the condition. It will be equal to the number of the paths of length ⌈N / 2⌉ - 1 from START to the vertex just before GOAL, which can be found in a similar way to the second part of the solution.The journey has finally come to an end. Actually, it is also possible to solve this problem in time without matrix exponentiation, but this margin is too small to explain it. I will just paste the link to the code.The writer's code (matrix exponentiation, C++): 9501164The writer's code (without matrix exponentiation, C++): 9501177Congratulations again to Petr who was the only participant to solve this problem in 108 minutes. Also, I would like to give a special mention to rng_58, who was VERY close to solving it in only 63 minutes. He was just one byte away from getting AC (compare 9460984 and 9465440)! If you find a possible error, or have a question, please feel free to ask here. Alternative solutions are also welcome.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/15889",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 505\\s*E"
          },
          "content_length": 23595
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #286 - Codeforces - Code 1",
          "code": "This is the 3rd time(following #162 and #263) for me",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #286 - Codeforces - Code 2",
          "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N = 1e2 + 5;\n\nint parent[N][N];\n\nint find(int c, int v) {\n    if (parent[c][v] == -1)\n        return v;\n    return parent[c][v] = find(c, parent[c][v]);\n}\n\nvoid unite(int c, int u, int v) {\n    parent[c][find(c, u)] = find(c, v);\n}\n\nint main() {\n    memset(parent, -1, sizeof parent);\n    int n, m;\n    cin >> n >> m;\n    for (int i = 0; i < m; ++i) {\n        int a, b, c;\n        cin >> a >> b >> c;\n        unite(c, a, b);\n    }\n    int q;\n    cin >> q;\n    while (q--) {\n        int u, v, ans = 0;\n        cin >> u >> v;\n        for (int i = 1; i <= 100; ++i)\n            if (find(i, u) == find(i, v))\n                ++ans;\n        cout << ans << '\\n';\n    }\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/15842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #286 - Codeforces - Code 3",
          "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N = 1e2 + 5;\n\nint parent[N][N];\n\nint find(int c, int v) {\n    if (parent[c][v] == -1)\n        return v;\n    return parent[c][v] = find(c, parent[c][v]);\n}\n\nvoid unite(int c, int u, int v) {\n    parent[c][find(c, u)] = find(c, v);\n}\n\nint main() {\n    memset(parent, -1, sizeof parent);\n    int n, m;\n    cin >> n >> m;\n    for (int i = 0; i < m; ++i) {\n        int a, b, c;\n        cin >> a >> b >> c;\n        unite(c, a, b);\n    }\n    int q;\n    cin >> q;\n    while (q--) {\n        int u, v, ans = 0;\n        cin >> u >> v;\n        for (int i = 1; i <= 100; ++i)\n            if (find(i, u) == find(i, v))\n                ++ans;\n        cout << ans << '\\n';\n    }\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/15842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #286 - Codeforces - Code 4",
          "code": "Runtime Error",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #286 - Codeforces - Code 5",
          "code": "Memory Limit Exceeded",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #286 - Codeforces - Code 6",
          "code": "7 8\n1 2\n1 3\n2 4\n3 4\n4 5\n4 6\n5 7\n6 7",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #286 - Codeforces - Code 7",
          "code": "7 8\n1 2\n1 3\n2 4\n3 4\n4 5\n4 6\n5 7\n6 7",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #286 - Codeforces - Code 8",
          "code": "Test: #12 ... verdict: WRONG_ANSWER\nInput\n1 30000\n30000\nOutput\n0\nAnswer\n1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #286 - Codeforces - Code 9",
          "code": "Test: #12 ... verdict: WRONG_ANSWER\nInput\n1 30000\n30000\nOutput\n0\nAnswer\n1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #286 - Codeforces - Code 10",
          "code": "unordered_map",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #286 - Codeforces - Code 11",
          "code": "res += (pars[c][u] == pars[c][v]);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #286 - Codeforces - Code 12",
          "code": "res += (pars[c][u] == pars[c][v]);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #286 - Codeforces - Code 13",
          "code": "if (pars[c].find(v) != pars[c].end() && pars[c][u] == pars[c][v]) {\n    res++;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #286 - Codeforces - Code 14",
          "code": "if (pars[c].find(v) != pars[c].end() && pars[c][u] == pars[c][v]) {\n    res++;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #286 Editorial (Complete) - Codeforces - Code 1",
          "code": "dp[i][j - offset]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15889",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #286 Editorial (Complete) - Codeforces - Code 2",
          "code": "components[x] & components[y]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15889",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #286 Editorial (Complete) - Codeforces - Code 3",
          "code": "7 8\n1 2\n2 3\n3 4\n4 1\n4 7\n7 6\n6 5\n5 2\n\nAuthor's Code on my Pc returns 7",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15889",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #286 Editorial (Complete) - Codeforces - Code 4",
          "code": "7 8\n1 2\n2 3\n3 4\n4 1\n4 7\n7 6\n6 5\n5 2\n\nAuthor's Code on my Pc returns 7",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15889",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #286 Editorial (Complete) - Codeforces - Code 5",
          "code": "Also, for each j (1 ≤ j ≤ ti), find the day di, j such that, if the j-th beat on the i-th bamboo is performed before day di, it will be no longer possible to keep the i-th bamboo's height after m days at most X (it can be found by doing simple math).",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15889",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #286 Editorial (Complete) - Codeforces - Code 6",
          "code": "if(target - h[i] <= 0){\n\tt[0]++;\n}else if(target - h[i] > a[i] * (m-1)){\n\tok = 0;\n\tgoto end;\n}else{\n\tt[(target - h[i] + a[i] - 1) / a[i]]++;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15889",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #286 Editorial (Complete) - Codeforces - Code 7",
          "code": "if(target - h[i] <= 0){\n\tt[0]++;\n}else if(target - h[i] > a[i] * (m-1)){\n\tok = 0;\n\tgoto end;\n}else{\n\tt[(target - h[i] + a[i] - 1) / a[i]]++;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15889",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #286 Editorial (Complete) - Codeforces - Code 8",
          "code": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\n#define pb push_back\n#define __addEdge(u, v) [u].push_back(v)\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<vi> vmi;\n\nint n, m;\nvmi G[111];\nvb mark;\n\nvoid dfs(vmi &SG, int u)\n{\n    mark[u] = true;\n    for (int i = 0; i < SG[u].size(); ++i)\n    {\n        int v = SG[u][i];\n        if (!mark[v])\n            dfs(SG, v);\n    }\n}\n\nint main()\n{\n    cin >> n >> m;\n\n    fill(G, G + 111, vmi(n + 1));\n    mark.assign(n + 1, false);\n    for (int i = 0; i < m; ++i)\n    {\n        int u, v, c;\n        cin >> u >> v >> c;\n        G[c]__addEdge(u, v);\n        G[c]__addEdge(v, u);\n    }\n\n    int q;\n    cin >> q;\n\n    while (q--)\n    {\n        int u, v;\n        cin >> u >> v;\n\n        int cnt = 0;\n        for (int k = 1; k <= 100; ++k)\n        {\n            fill(mark.begin(), mark.end(), false);\n            dfs(G[k], u);\n            cnt += mark[v];\n        }\n\n        cout << cnt << endl;\n    }   \n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/15889",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #286 Editorial (Complete) - Codeforces - Code 9",
          "code": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\n#define pb push_back\n#define __addEdge(u, v) [u].push_back(v)\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<vi> vmi;\n\nint n, m;\nvmi G[111];\nvb mark;\n\nvoid dfs(vmi &SG, int u)\n{\n    mark[u] = true;\n    for (int i = 0; i < SG[u].size(); ++i)\n    {\n        int v = SG[u][i];\n        if (!mark[v])\n            dfs(SG, v);\n    }\n}\n\nint main()\n{\n    cin >> n >> m;\n\n    fill(G, G + 111, vmi(n + 1));\n    mark.assign(n + 1, false);\n    for (int i = 0; i < m; ++i)\n    {\n        int u, v, c;\n        cin >> u >> v >> c;\n        G[c]__addEdge(u, v);\n        G[c]__addEdge(v, u);\n    }\n\n    int q;\n    cin >> q;\n\n    while (q--)\n    {\n        int u, v;\n        cin >> u >> v;\n\n        int cnt = 0;\n        for (int k = 1; k <= 100; ++k)\n        {\n            fill(mark.begin(), mark.end(), false);\n            dfs(G[k], u);\n            cnt += mark[v];\n        }\n\n        cout << cnt << endl;\n    }   \n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/15889",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 5000, \"m\");\n    inf.readSpace();\n    int k = inf.readInt(1, 10, \"k\");\n    inf.readSpace();\n    int p = inf.readInt(1, 1000000000, \"p\");\n    inf.readEoln();\n    for (int i = 0; i < n; ++i) {\n        int hi = inf.readInt(0, 1000000000, \"hi\");\n        inf.readSpace();\n        int ai = inf.readInt(1, 1000000000, \"ai\");\n        inf.readEoln();\n    }\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 5000, \"m\");\n    inf.readSpace();\n    int k = inf.readInt(1, 10, \"k\");\n    inf.readSpace();\n    int p = inf.readInt(1, 1000000000, \"p\");\n    inf.readEoln();\n    for (int i = 0; i < n; ++i) {\n        int hi = inf.readInt(0, 1000000000, \"hi\");\n        inf.readSpace();\n        int ai = inf.readInt(1, 1000000000, \"ai\");\n        inf.readEoln();\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 5000, \"m\");\n    inf.readSpace();\n    int k = inf.readInt(1, 10, \"k\");\n    inf.readSpace();\n    int p = inf.readInt(1, 1000000000, \"p\");\n    inf.readEoln();\n    for (int i = 0; i < n; ++i) {\n        int hi = inf.readInt(0, 1000000000, \"hi\");\n        inf.readSpace();\n        int ai = inf.readInt(1, 1000000000, \"ai\");\n        inf.readEoln();\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    int k = opt<int>(\"k\");\n    int p = opt<int>(\"p\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> h(n);\n    vector<int> a(n);\n\n    if (type == \"min\") {\n        // Minimal input values\n        for (int i = 0; i < n; ++i) {\n            h[i] = 0;\n            a[i] = 1;\n        }\n    } else if (type == \"max\") {\n        // Maximal input values\n        for (int i = 0; i < n; ++i) {\n            h[i] = 1000000000;\n            a[i] = 1000000000;\n        }\n    } else if (type == \"h_zero\") {\n        // h_i = 0, a_i random\n        for (int i = 0; i < n; ++i) {\n            h[i] = 0;\n            a[i] = rnd.next(1, 1000000000);\n        }\n    } else if (type == \"a_max\") {\n        // a_i = maximum, h_i random\n        for (int i = 0; i < n; ++i) {\n            h[i] = rnd.next(0, 1000000000);\n            a[i] = 1000000000;\n        }\n    } else if (type == \"h_p_equal\") {\n        // h_i = p, a_i random\n        for (int i = 0; i < n; ++i) {\n            h[i] = p;\n            a[i] = rnd.next(1, 1000000000);\n        }\n    } else if (type == \"h_p_minus1\") {\n        // h_i = max(0, p - 1), a_i random\n        for (int i = 0; i < n; ++i) {\n            h[i] = max(0, p - 1);\n            a[i] = rnd.next(1, 1000000000);\n        }\n    } else if (type == \"h_p_plus1\") {\n        // h_i = p + 1, a_i random\n        for (int i = 0; i < n; ++i) {\n            h[i] = p + 1;\n            a[i] = rnd.next(1, 1000000000);\n        }\n    } else if (type == \"low_growth\") {\n        // a_i = 1, h_i random\n        for (int i = 0; i < n; ++i) {\n            h[i] = rnd.next(0, 1000000000);\n            a[i] = 1;\n        }\n    } else if (type == \"high_growth\") {\n        // a_i = maximum, h_i random\n        for (int i = 0; i < n; ++i) {\n            h[i] = rnd.next(0, 1000000000);\n            a[i] = 1000000000;\n        }\n    } else if (type == \"random\") {\n        // Random h_i and a_i within constraints\n        for (int i = 0; i < n; ++i) {\n            h[i] = rnd.next(0, 1000000000);\n            a[i] = rnd.next(1, 1000000000);\n        }\n    } else if (type == \"all_same\") {\n        // All bamboos have the same h_i and a_i\n        int h_val = rnd.next(0, 1000000000);\n        int a_val = rnd.next(1, 1000000000);\n        for (int i = 0; i < n; ++i) {\n            h[i] = h_val;\n            a[i] = a_val;\n        }\n    } else {\n        cerr << \"Unknown type: \" << type << endl;\n        return 1;\n    }\n\n    // Output the test case\n    printf(\"%d %d %d %d\\n\", n, m, k, p);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d %d\\n\", h[i], a[i]);\n    }\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    int k = opt<int>(\"k\");\n    int p = opt<int>(\"p\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> h(n);\n    vector<int> a(n);\n\n    if (type == \"min\") {\n        // Minimal input values\n        for (int i = 0; i < n; ++i) {\n            h[i] = 0;\n            a[i] = 1;\n        }\n    } else if (type == \"max\") {\n        // Maximal input values\n        for (int i = 0; i < n; ++i) {\n            h[i] = 1000000000;\n            a[i] = 1000000000;\n        }\n    } else if (type == \"h_zero\") {\n        // h_i = 0, a_i random\n        for (int i = 0; i < n; ++i) {\n            h[i] = 0;\n            a[i] = rnd.next(1, 1000000000);\n        }\n    } else if (type == \"a_max\") {\n        // a_i = maximum, h_i random\n        for (int i = 0; i < n; ++i) {\n            h[i] = rnd.next(0, 1000000000);\n            a[i] = 1000000000;\n        }\n    } else if (type == \"h_p_equal\") {\n        // h_i = p, a_i random\n        for (int i = 0; i < n; ++i) {\n            h[i] = p;\n            a[i] = rnd.next(1, 1000000000);\n        }\n    } else if (type == \"h_p_minus1\") {\n        // h_i = max(0, p - 1), a_i random\n        for (int i = 0; i < n; ++i) {\n            h[i] = max(0, p - 1);\n            a[i] = rnd.next(1, 1000000000);\n        }\n    } else if (type == \"h_p_plus1\") {\n        // h_i = p + 1, a_i random\n        for (int i = 0; i < n; ++i) {\n            h[i] = p + 1;\n            a[i] = rnd.next(1, 1000000000);\n        }\n    } else if (type == \"low_growth\") {\n        // a_i = 1, h_i random\n        for (int i = 0; i < n; ++i) {\n            h[i] = rnd.next(0, 1000000000);\n            a[i] = 1;\n        }\n    } else if (type == \"high_growth\") {\n        // a_i = maximum, h_i random\n        for (int i = 0; i < n; ++i) {\n            h[i] = rnd.next(0, 1000000000);\n            a[i] = 1000000000;\n        }\n    } else if (type == \"random\") {\n        // Random h_i and a_i within constraints\n        for (int i = 0; i < n; ++i) {\n            h[i] = rnd.next(0, 1000000000);\n            a[i] = rnd.next(1, 1000000000);\n        }\n    } else if (type == \"all_same\") {\n        // All bamboos have the same h_i and a_i\n        int h_val = rnd.next(0, 1000000000);\n        int a_val = rnd.next(1, 1000000000);\n        for (int i = 0; i < n; ++i) {\n            h[i] = h_val;\n            a[i] = a_val;\n        }\n    } else {\n        cerr << \"Unknown type: \" << type << endl;\n        return 1;\n    }\n\n    // Output the test case\n    printf(\"%d %d %d %d\\n\", n, m, k, p);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d %d\\n\", h[i], a[i]);\n    }\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -m 1 -k 1 -p 1 -type min\n./gen -n 1 -m 1 -k 1 -p 1 -type max\n\n./gen -n 10 -m 10 -k 1 -p 1000000000 -type h_zero\n./gen -n 10 -m 10 -k 10 -p 1000000000 -type a_max\n\n./gen -n 100 -m 100 -k 5 -p 500000000 -type h_p_equal\n./gen -n 100 -m 100 -k 5 -p 500000000 -type h_p_minus1\n./gen -n 100 -m 100 -k 5 -p 500000000 -type h_p_plus1\n\n./gen -n 1000 -m 500 -k 10 -p 1000000000 -type low_growth\n./gen -n 1000 -m 500 -k 10 -p 1000000000 -type high_growth\n\n./gen -n 10000 -m 1000 -k 10 -p 1000000000 -type random\n./gen -n 10000 -m 1000 -k 1 -p 1 -type random\n\n./gen -n 100000 -m 5000 -k 1 -p 1000000000 -type random\n./gen -n 100000 -m 5000 -k 10 -p 1 -type random\n\n./gen -n 100000 -m 5000 -k 10 -p 1000000000 -type min\n./gen -n 100000 -m 5000 -k 1 -p 1 -type max\n\n./gen -n 50000 -m 2500 -k 5 -p 500000000 -type all_same\n./gen -n 50000 -m 2500 -k 5 -p 500000000 -type h_zero\n\n./gen -n 1 -m 5000 -k 10 -p 1000000000 -type random\n./gen -n 1 -m 5000 -k 1 -p 1 -type random\n\n./gen -n 2 -m 2 -k 2 -p 2 -type h_p_equal\n./gen -n 2 -m 2 -k 2 -p 2 -type h_p_minus1\n./gen -n 2 -m 2 -k 2 -p 2 -type h_p_plus1\n\n./gen -n 99999 -m 4999 -k 9 -p 999999999 -type random\n./gen -n 100000 -m 5000 -k 10 -p 1000000000 -type random\n\n./gen -n 100000 -m 1 -k 1 -p 1000000000 -type high_growth\n./gen -n 100000 -m 1 -k 1 -p 1000000000 -type low_growth\n\n./gen -n 100000 -m 5000 -k 10 -p 1000000000 -type a_max\n./gen -n 100000 -m 5000 -k 10 -p 1000000000 -type h_zero\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:40:41.410917",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "506/A",
      "title": "A. Mr. Kitayuta, the Treasure Hunter",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line of the input contains two space-separated integers n and d (1 ≤ n, d ≤ 30000), denoting the number of the gems in the Shuseki Islands and the length of the Mr. Kitayuta's first jump, respectively.The next n lines describe the location of the gems. The i-th of them (1 ≤ i ≤ n) contains a integer pi (d ≤ p1 ≤ p2 ≤ ... ≤ pn ≤ 30000), denoting the number of the island that contains the i-th gem.",
      "output_spec": "OutputPrint the maximum number of gems that Mr. Kitayuta can collect.",
      "sample_tests": "ExamplesInputCopy4 1010212727OutputCopy3InputCopy8 8919283645556678OutputCopy6InputCopy13 788916171718212324242630OutputCopy4",
      "description": "A. Mr. Kitayuta, the Treasure Hunter\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nThe Shuseki Islands are an archipelago of 30001 small islands in the Yutampo Sea. The islands are evenly spaced along a line, numbered from 0 to 30000 from the west to the east. These islands are known to contain many treasures. There are n gems in the Shuseki Islands in total, and the i-th gem is located on island pi.Mr. Kitayuta has just arrived at island 0. With his great jumping ability, he will repeatedly perform jumps between islands to the east according to the following process:   First, he will jump from island 0 to island d.  After that, he will continue jumping according to the following rule. Let l be the length of the previous jump, that is, if his previous jump was from island prev to island cur, let l = cur - prev. He will perform a jump of length l - 1, l or l + 1 to the east. That is, he will jump to island (cur + l - 1), (cur + l) or (cur + l + 1) (if they exist). The length of a jump must be positive, that is, he cannot perform a jump of length 0 when l = 1. If there is no valid destination, he will stop jumping. Mr. Kitayuta will collect the gems on the islands visited during the process. Find the maximum number of gems that he can collect.\n\nInputThe first line of the input contains two space-separated integers n and d (1 ≤ n, d ≤ 30000), denoting the number of the gems in the Shuseki Islands and the length of the Mr. Kitayuta's first jump, respectively.The next n lines describe the location of the gems. The i-th of them (1 ≤ i ≤ n) contains a integer pi (d ≤ p1 ≤ p2 ≤ ... ≤ pn ≤ 30000), denoting the number of the island that contains the i-th gem.\n\nOutputPrint the maximum number of gems that Mr. Kitayuta can collect.\n\nInputCopy4 1010212727OutputCopy3InputCopy8 8919283645556678OutputCopy6InputCopy13 788916171718212324242630OutputCopy4\n\nInputCopy4 1010212727\n\nOutputCopy3\n\nInputCopy8 8919283645556678\n\nOutputCopy6\n\nInputCopy13 788916171718212324242630\n\nOutputCopy4\n\nNoteIn the first sample, the optimal route is 0  →  10 (+1 gem)  →  19  →  27 (+2 gems)  → ...\u0001In the second sample, the optimal route is 0  →  8  →  15  →  21 →  28 (+1 gem)  →  36 (+1 gem)  →  45 (+1 gem)  →  55 (+1 gem)  →  66 (+1 gem)  →  78 (+1 gem)  → ...In the third sample, the optimal route is 0  →  7  →  13  →  18 (+1 gem)  →  24 (+2 gems)  →  30 (+1 gem)  → ...",
      "solutions": [
        {
          "title": "Codeforces Round #286 - Codeforces",
          "content": "Hello Codeforces!evima, yosupo and I would like you to participate in Codeforces Round #286. It will be held on Sunday, January 18th at 16:00 MSK. Please note that this round starts on unusual time.Great thanks to Zlobober who helped us prepare this round, Delinur who translated statements into Russian and MikeMirzayanov who created Codeforces and polygon.This is the 3rd time(following #162 and #263) for me, and the 1st time for evima and yosupo to prepare a Codeforces Round.Scores of the problems will be500-1000-1750-1750-2500 for Div.1, and500-1000-1500-2000-2750 for Div.2.In this round, you'll help a man named Mr. kitayuta. I hope he will participate :)The system tests are now over! The top-5 are as follows:Div.1:1.ilyakor2.kcm17003.LayCurse4.RomaWhite5.TankEngineerDiv.2:1.Konijntje2.cpcpc3.zgzjsxshycxksxhsh4.Ronnie0075.sha384Also, special congrats on Petr, who solved problem E in Div.1, which anyone else could not solve.Here are the editorials",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/15842",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 961
        },
        {
          "title": "Codeforces Round #286 Editorial (Complete) - Codeforces",
          "content": "Edit (Jan 22, 2:45 AM UTC): Added Div1E and the editorial is now complete. I am sorry for the delay.Edit (Jan 21, 9:45 AM UTC): Added the explanation for Div1C/2E, and the problem setters' codes. Div1E will need several more hours. Thank you again for your patience.First, here are some statistics on this round: Division Registrants Participants A Accepted B Accepted C Accepted D Accepted E Accepted 1 1364 572 (*) 294 199 8 113 1 (Estimated number of AC by me) 800 (wrong) 500 (wrong) 70 (FAIL) 90 (ok) 5 (wrong) 2 4016 2028 1355 945 41 5 0 (*) Where did the remaining 792 people go? :) We are sorry for terribly underestimating the difficulty of the problems (except Div1D), especially Div1A/2C and Div1C/2E. Div.2 A: 505A - Mr. Kitayuta's Gift[Problem] Given a string, turn it into a palindrome by inserting one letter or state that it is impossible.(Problem by evima)Since the string is short (at most 10 characters), you can simply try every possible way of inserting a letter (\"where\" and \"what\" to insert), and check if the resulting string is a palindrome.The writer's code (C++): 9501249Note: For some strange reason, we (contest managers) cannot submit solutions so that everyone can see them. PraveenDhinwa told us how to do so. Thank you! Div.2 B: 505B - Mr. Kitayuta's Colorful Graph[Problem] Given an undirected graph whose edges are painted in colors, process the queries of the following form: Given two vertices ui and vi, find the number of the colors that satisfies the following condition: the edges of that color connect ui and vi (possibly indirectly). (Problem by hogloid)Since neither the graph nor the number of queries is too large, for each query you can simply count the number of the \"good\" colors (the colors that satisfies the condition) by checking if each color is \"good\". To do that, you can perform Depth First Search (or Breadth First Search) and verify whether you can reach vi from ui traversing only the edges of that color. If you prefer using Union-Find, it will also do the job.The writer's code (DFS, C++)The writer's code (Union-Find, C++) Div.2 C / Div.1 A: 505C - Mr. Kitayuta, the Treasure Hunter[Problem] Since it is hard to summarize this problem, please refer to the official statement.(Problem by yosupo)Below is the explanation from yosupo, translated by me.[From here]Let m be the number of the islands (that is, 30001). First, let us describe a solution with time and memory complexity of O(m2).We will apply Dynamic Programming. let dp[i][j] be the number of the gems that Mr. Kitayuta can collect after he jumps to island i, when the length of his previous jump is j (let us assume that he have not collect the gems on island i). Then, you can calculate the values of the table dp by the following: dp[i][j] = 0, if i ≥ m(actually these islands do not exist, but we can suppose that they exist and when Mr. Kitayuta jumps to these islands, he stops jumping) dp[i][j] =  (the number of the gems on island i)  + max(dp[i + j][j], dp[i + j + 1][j + 1]), if i < m, j = 1(he cannot perform a jump of length 0) dp[i][j] =  (the number of the gems on island i)  + max(dp[i + j - 1][j - 1], dp[i + j][j], dp[i + j + 1][j + 1]), if i < m, j ≥ 2 This solution is unfeasible in terms of both time and memory. However, the following observation makes it an Accepted solution: there are only 491 values of j that we have to consider, which are d - 245, d - 244, d - 243, ..., d + 244 and d + 245.Why? First, let us find the upper bound of j. Suppose Mr. Kitayuta always performs the \"l + 1\" jump (l: the length of the previous jump). Then, he will reach the end of the islands before he performs a jump of length d + 246, becaused + (d + 1) + (d + 2) + ... + (d + 245) ≥ 1 + 2 + ... + 245 = 245·(245 + 1) / 2 = 30135 > 30000. Thus, he will never be able to perform a jump of length d + 246 or longer.Next, let us consider the lower bound of j in a similar way. If d ≤ 246, then obviously he will not be able to perform a jump of length d - 246 or shorter, because the length of a jump must be positive. Suppose Mr. Kitayuta always performs the \"l - 1\" jump, where d ≥ 247. Then, again he will reach the end of the islands before he performs a jump of length d - 246, becaused + (d - 1) + (d - 2) + ... + (d - 245) ≥ 245 + 244 + ... + 1 = 245·(245 + 1) / 2 = 30135 > 30000. Thus, he will never be able to perform a jump of length d - 246 or shorter.Therefore, we have obtained a working solution: similar to the O(m2) one, but we will only consider the value of j between d - 245 and d + 245. The time and memory complexity of this solution will be O(m1.5), since the value \"245\" is slightly larger than .This solution can be implemented by, for example, using a \"normal\" two dimensional array with a offset like this: dp[i][j - offset]. The time limit is set tight in order to fail most of naive solutions with search using std::map or something, so using hash maps (unordered_map) will be risky although the complexity will be the same as the described solution.[End]The writer's code (memoized recursion, C++) Div.2 D / Div.1 B: 505D - Mr. Kitayuta's Technology[Problem] Given an integer n and m pairs of integers (ai, bi) (1 ≤ ai, bi ≤ n), find the minimum number of edges in a directed graph that satisfies the following condition: For each i, there exists a path from vertex ai to vertex bi. (Problem from evima)Let G1 be the directed graph built from the input, and G2 be a directed graph that satisfies the given conditions. What we seek is the minimum number of edges in G2. Also, we say that two vertices u and v in a directed graph are \"weakly connected\" if we can reach v from u by traversing edges, not considering their directions.If a pair (u, v) is present in the input, then vertices u and v must be weakly connected in G2. Therefore, for each weakly connected component (abbreviated to wcc) in G1, the vertices in that component must also be in the same wcc in G2. We can \"merge\" multiple wccs in G1 and create a larger wcc in G2, but for now, let us find the minimum number of edges required in G2 for each wcc in G1 when we do not \"merge\" them. There are two cases to consider: If a wcc in G1 does not have cycles, then we can perform topological sort on that wcc, and we can make a \"chain\" (see the image below) using the topological order to satisfy the conditions. We need (the number of the vertices in the wcc)  - 1 edges, which is the minimum required number since any connected graph with V vertices has at least V - 1 edges. If a wcc in G1 has cycles, then topological sort cannot be applied. We need at least (the number of the vertices in the wcc) edges this time, since any connected graph with V vertices and V - 1 edges is a tree, which does not contain cycles. Actually, this number (the number of the vertices in the wcc) is always achievable by connecting the vertices into a \"ring\" (see the image below), thus it is the minimum required number that we seek. We have found the minimum required number of edges for each wcc in G1 when we do not \"merge\" them. Let us show that \"merging\" wccs in G1 do not reduce the number of required edges. Suppose we combine k( > 1) wccs C1, C2, ..., Ck in G1 into one wcc C in G2. Again, there are two cases to consider: If none of C1, C2, ..., Ck contains cycles, then C will need |C1| + |C2| + ... + |Ck| - 1 edges. However, if we do not combine them, we will only need (|C1| - 1) + (|C2| - 1) + ... + (|Ck| - 1) edges in total, which is fewer. If some of C1, C2, ..., Ck contain cycles, then C will need |C1| + |C2| + ... + |Ck| edges. However, if we do not combine them, we will need(|C1| - noCycles(C1)) + (|C2| - noCycles(C2)) + ... + (|Ck| - noCycles(Ck)  ≤ |C1| + |C2| + ... + |Ck| edges(here, noCycles(Ci) is 1 if Ci do not contain cycles, otherwise 0), thus combining them does not reduce the number of required edges. Thus, we do not need to combine multiple wccs into one wcc in G2 in order to obtain the optimal solution. That is, the final answer to the problem is the sum of the minimum required number of edges for each wcc in G1, when they are considered separately.As for the implementation, detecting cycles in a directed graph with 105 vertices and edges might be a problem if this is your first encounter with it. One possible way is to paste a code that decomposes a graph into strongly connected components. If the size of a strongly connected component is more than one, then that means the component contains cycles.The writer's code (strongly connected component decomposition, C++): 9501202 Div.2 E / Div.1 C: 505E - Mr. Kitayuta vs. Bamboos[Problem] Since it is hard to summarize this problem, please refer to the official statement.(Problem from yosupo)Below is the explanation from yosupo, translated by me.[From here]Let us begin by applying Binary Search. The problem becomes: \"is it possible that all the bamboos are at most X meters after m days?\" It is complicated by the fact that the height does not become negative; the excessive decrease will be wasted. We have found two approaches to this problem. Solution 1 Mr. Kitayuta must beat the i-th bamboo at least max(0, ⌈(hi + m·ai - X) / P⌉) times (let this number ti). Actually, it is not necessary for him to beat it more than this number of times. Thus, let us assume that he beat the i-th bamboo exactly ti times. Also, for each j (1 ≤ j ≤ ti), find the day di, j such that, if the j-th beat on the i-th bamboo is performed before day di, it will be no longer possible to keep the i-th bamboo's height after m days at most X (it can be found by doing simple math). If Mr. Kitayuta can beat the bamboos under this constraint, all the bamboos' heights will become X meters or less after m days. Otherwise, some bamboos' heights will exceed X meters.The time complexity of this solution will be , if we first calculate only ti, then if the sum of ti exceeds km, we skip finding di, j (the answer is \"NO\"). Solution 2 This problem becomes simpler if we simulate Mr. Kitayuta's fight backwards, that is, from day m to day 1. It looks like this:[Problem'] There are n bamboos. At the moment, the height of the i-th bamboo is X meters, and it shrinks ai meters at the beginning of each day. Mr. Kitayuta will play a game. He can use Magic Hammer at most k times per day to increase the height of a bamboo by p meters. If some bamboo's height becomes negative at any moment, he will lose the game immediately. Also, in order for him to win the game, the i-th bamboo's height must be at least hi meters after m days. Is victory possible?Below is an illustration of this \"reverse simulation\": This version is simpler because he is increasing the heights instead of decreasing, thus we do not need to take into account the \"excessive decrease beyond 0 meters\" which will be wasted. Let us consider an optimal strategy. If there exist bamboos whose heights would become negative after day m, he should beat the one that is the earliest to make him lose. Otherwise, he can choose any bamboo whose height would be less than hi meters after day m. Repeat beating the bamboos following this strategy, and see if he can actually claim victory.The writer's implementation of this solution uses a priority queue, and its time complexity is .[End]The tester's code (Solution 1, C++): 9501229The writer's code (Solution 2, C++) Div.1 D: 506D - Mr. Kitayuta's Colorful Graph[Problem] Given an undirected graph whose edges are painted in colors, process the queries of the following form: Given two vertices ui and vi, find the number of the colors that satisfies the following condition: the edges of that color connect ui and vi (possibly indirectly). Note: this is the exact same problem as Div.2 B except the constraints, which are 105 instead of 100.(Problem from hogloid)Below is the explanation from hogloid.[From here]For each color, make a new graph that consists of the edges of the color and vertices connected by the edges. Make UnionFind for each graph, and you can check whether a color connects vertex A and B , using it. For each query, find a vertex which has smaller degree(let this vertex A, and the other vertex B) For each colors such that a edge of the color connects to A, check whether A and B is connected by the color. After answering the query, memorize its tuple — (A, B, answer). If the same query is requested, answer using this information.This will lead to solution.For each query, the complexity is (For each color connects A, find a vertex of B of the color & check whether they are connected) The queries that require longest computing time are, to ask every pair among vertices which have largest degrees. Let the indices of the vertices be , and degrees of the vertices be d1, d2, ...dk. Now, let's fix vertex B as i. The total computing time of the queries such that B is vertex i is . Vertex B can vary from 2 to k. Hence, the total complexity is at most . This complexity is at most .By the way, in C++, using unordered_map, total complexity would be .[End]There will be many other solutions. I will briefly explain one of them which I think is typical.Let ci be the number of colors of the edges incident to vertex i. The sum of all ci does not exceed 2m since each edge increases this sum by at most 2. Thus, there will be at most 450 values of i such that ci ≥ 450 (let B = 450). We will call these vertices large, and the remaining ones small. Using O(m / B·m) = O(m2 / B) time and memory, we can precalculate and store the answer for all the possible queries where at least one of ui and vi is large, then we can immediately answer these queries. For the remaining queries, both ui and vi will be small, therefore it is enough to directly count the color that connects vertices ui and vi in O(B) time. The total time required will be O(m2 / B + Bq). If we choose , we can solve the problem in time.The writer's code (the first solution, C++)The tester's code (the second solution, C++): 9501240 Div.1 E: 506E - Mr. Kitayuta's Gift[Problem] Given a string s and an integer n, find the number of the palindromes that can be obtained by inserting exactly n letters into s.Note: Div.2 A is a similar problem, where n is fixed to 1.(Problem from evima)First of all, let us note that we are asked to count the resulting palindromes, not the ways to obtain them. For example, if we are to insert \"b\" into \"abba\", there are 5 possible positions, but only 3 strings will be produced (\"babba\", \"abbba\" and \"abbab\"). Rather than trying to count the ways of inserting a letter n times and removing the duplicated results, we should directly count the resulting palindrome. To do that, let us reformulate the problem:[Problem'] Given a string s and an integer n, find the number of the palindromes of length |s| + n (let this number be N) that contains s as a subsequence (not necessarily contiguous).Consider constructing a palindrome from both ends, and matching it to s from both left and right. For example, let s = \"abaac\" and N = 11. Let us call the final resulting string t. We first decide what letter to use as t1 and t11 (they must be equal in order for t to be a palindrome). Let us say 'c' is chosen. Now, we have to construct the remaining part of t, that is, t2..t10, so that t2..t10 contains \"abaa\" as a substring (note that the 'c' at the end of s is discarded). Again, we decide what letter to use as t2 and t10. This time we choose 'a'. Then, we have to construct t3..t9, so that it contains \"ba\" as a substring (this time the two 'a's at the both ends of s are discarded). We choose t3 = t9 = 'c'. Next, we construct t4..t8, so that it contains \"ba\" as a substring (this time s remains unchanged). We choose t4 = t8 = 'b'. Then, we construct t5..t7, so that it contains \"a\" as a substring. We choose t5 = t7 = 'a' (it is becoming repetitive, isn't it?). The last part of t, that is, t6, has no restriction (this time we choose a letter for only one position of t, not two). We choose 'd', and we have obtained a palindrome \"cacbadabcac\" that contains s = \"abaac\" as a subsequence.This problem is mostly about analyzing this process carefully.The most naive solution other than literally enumerating all palindromes of length N would be the following Dynamic Programming: let dp[i][left][right] be the number of the palindromes t that can be obtained if you have already decided the leftmost and the rightmost i letters (2i in total), and the substring sleftsleft + 1..sright of s remains unmatched. Each value in this table can be computed in O(1) time. Of course, since i can be up to ⌊n / 2⌋ (n ≤ 109), this solution is far from our goal.Notice that the transitions from dp[i] to dp[i + 1] are the same regardless of i, thus we can calculate the table by matrix exponentiation. However, since there are O(|s|2) possible pairs for (left, right), we will need time, which is actually worse than the naive calculation considering that |s| can be up to 200.This is where we need to observe the process which we have gone through at the beginning more carefully. Let us build a automaton corresponding to the process (the image below). (*) An self-loop with a number means that there are actually that number of edges.A process of producing a palindrome of length N that contains s as a subsequence corresponds to a path of length ⌈N / 2⌉ from the upper-right vertex to the lower-left vertex. Each red vertex has 24 self-loops since the letters at the both ends of the remaining part of s is different, which correspond to two non-self-loop transitions. Similarly, each green vertex has 25 self-loops since the first letter and the last letter of the remaining string is the same, and the blue vertex, the destination, has 26 self-loops, as there are no more non-self-loop transitions available.Here is an important fact: there are not so many possible combination of (n24, n25), where n24 and n25 are the number of times a path from START to GOAL visits a red vertex (with 24 self-loops) and a green vertex (with 25 self-loops), respectively. Why? Each time we leave a red vertex, the length of the remaining unmatched part of s decreases by 1, since exactly one of the two letters at the ends of the remaining part is matched and discarded. Similarly, each time we leave a green vertex, the length of the remaining string decreases by 2, since both of the two letters at the ends are matched and discarded. There is a exception, however: if the length of the remaining string is 1, then it will be a green vertex, but in this case the length will decrease by 1. Thus, for any path from START to GOAL, n24 + 2·n25 will be equal to either |s| or |s| + 1. If we fix n24, then n25 will be uniquely determined by n25 = ⌈(|s| - n24) / 2⌉. Since n24 can only take the value between 0 and |s| - 1, there are at most |s| possible pairs of (n24, n25).With this fact, we are ready to count the paths: let us classify them by the value of n24. For each possible pair of (n24, n25), let us count the number of corresponding paths. To do that, we divide each paths into two parts: first we count the number of paths from START to GOAL, using only non-self-loop transitions. Then, we count the ways of inserting self-loop transitions into each of these paths. The product of these two numbers will be the number that we seek.The first part is straightforward to solve: let dp[left][right][n24] be the number of paths from the vertex that corresponds to the substring sleftsleft + 1..sright, visiting exactly n24 red vertices using only non-self-loop transitions. Each value of the table can be found in O(1) time, thus the whole table can be computed in O(|s|3) time, which is fast enough for the input size (|s| ≤ 200).The main obstacle will be the second part. For example, let us consider the case where s = \"abaac\", N = 11, n24 = 2, which corresponds to the example at the beginning. From the fact we found earlier, n25 = ⌈(|s| - n24) / 2⌉ = ⌈(5 - 2) / 2⌉ = 2. Thus, we have to insert ⌈N / 2⌉ - n24 - n25 = 6 - 2 - 2 = 2 self-loop transitions into this path (the image): The order in which red, green and blue vertices appears in this path does not affect the number of ways of insertion, and can be arbitrary. The number of ways to insert 2 self-loop transitions will be equal to the number of the path of length ⌈N / 2⌉ = 6 from START to GOAL in this automaton (we have to take into account the non-self-loop transitions in it), which can be calculated by matrix exponentiation.Are we done? No! Consider the case s = \"abbb..(|s| - 1 times)..bb\". There are |s| - 1 possible values of n24 (n24 = 1 corresponds to the case where you match and discard the 'a' first, and n24 = |s| - 1 corresponds to the case where you keep the 'a' until s becomes \"ab\"). Thus, you need to perform matrix exponentiation |s| - 1 times, which results in a total of time, which will be too much under the given constraints.There is still hope, though, and here is the climax. Notice that these automata are very similar to each other, and they differ only in the number of the red and green vertices. We can combine these automata into one larger automaton like this (the image): The combined automaton should have |s| - 1 red, ⌈|s| / 2⌉ green and ⌈|s| / 2⌉ blue vertices.By performing matrix exponentiation on this automaton instead of many small automata, we can find all the required value in time, which should be enough. We recommend speeding up matrix multiplication by noticing that the matrix will be upper triangular (6 times faster on paper), since the time limit is not so generous (in order to reject solutions).The problem is almost solved, but there is one more challenge. When N is odd, the situation becomes a little complicated: as we have seen at the beginning, in the last (⌈N / 2⌉-th) step of producing a palindrome we choose a letter for only one position of the resulting string, that is, the center of that string. In other words, the last transition in the path in the automaton we have first built must not be one from a green vertex with a string of length 2 (for example, \"aa\") to GOAL.Let us find the number of the paths that violates this condition and subtract it from the answer. As previously mentioned, for each path n24 + 2·n25 will be equal to either |s| or |s| + 1, and if we fix the value of n24, n25 will be uniquely determined by n25 = ⌈(|s| - n24) / 2⌉. If |s| - n24 is odd, then it means that the last non-self-loop transition is one from a green vertex with a string of length 1, therefore in this case no path will violate the condition. If |s| - n24 is even, then the last non-self-loop trantision is from a green vertex with a string of length 2, thus the paths that does not contain the self-loop from GOAL to itself violate the condition. It will be equal to the number of the paths of length ⌈N / 2⌉ - 1 from START to the vertex just before GOAL, which can be found in a similar way to the second part of the solution.The journey has finally come to an end. Actually, it is also possible to solve this problem in time without matrix exponentiation, but this margin is too small to explain it. I will just paste the link to the code.The writer's code (matrix exponentiation, C++): 9501164The writer's code (without matrix exponentiation, C++): 9501177Congratulations again to Petr who was the only participant to solve this problem in 108 minutes. Also, I would like to give a special mention to rng_58, who was VERY close to solving it in only 63 minutes. He was just one byte away from getting AC (compare 9460984 and 9465440)! If you find a possible error, or have a question, please feel free to ask here. Alternative solutions are also welcome.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/15889",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.6,
            "reason": "宽松匹配: 包含题目编号 506 和字母"
          },
          "content_length": 23595
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #286 - Codeforces - Code 1",
          "code": "This is the 3rd time(following #162 and #263) for me",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #286 - Codeforces - Code 2",
          "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N = 1e2 + 5;\n\nint parent[N][N];\n\nint find(int c, int v) {\n    if (parent[c][v] == -1)\n        return v;\n    return parent[c][v] = find(c, parent[c][v]);\n}\n\nvoid unite(int c, int u, int v) {\n    parent[c][find(c, u)] = find(c, v);\n}\n\nint main() {\n    memset(parent, -1, sizeof parent);\n    int n, m;\n    cin >> n >> m;\n    for (int i = 0; i < m; ++i) {\n        int a, b, c;\n        cin >> a >> b >> c;\n        unite(c, a, b);\n    }\n    int q;\n    cin >> q;\n    while (q--) {\n        int u, v, ans = 0;\n        cin >> u >> v;\n        for (int i = 1; i <= 100; ++i)\n            if (find(i, u) == find(i, v))\n                ++ans;\n        cout << ans << '\\n';\n    }\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/15842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #286 - Codeforces - Code 3",
          "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N = 1e2 + 5;\n\nint parent[N][N];\n\nint find(int c, int v) {\n    if (parent[c][v] == -1)\n        return v;\n    return parent[c][v] = find(c, parent[c][v]);\n}\n\nvoid unite(int c, int u, int v) {\n    parent[c][find(c, u)] = find(c, v);\n}\n\nint main() {\n    memset(parent, -1, sizeof parent);\n    int n, m;\n    cin >> n >> m;\n    for (int i = 0; i < m; ++i) {\n        int a, b, c;\n        cin >> a >> b >> c;\n        unite(c, a, b);\n    }\n    int q;\n    cin >> q;\n    while (q--) {\n        int u, v, ans = 0;\n        cin >> u >> v;\n        for (int i = 1; i <= 100; ++i)\n            if (find(i, u) == find(i, v))\n                ++ans;\n        cout << ans << '\\n';\n    }\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/15842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #286 - Codeforces - Code 4",
          "code": "Runtime Error",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #286 - Codeforces - Code 5",
          "code": "Memory Limit Exceeded",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #286 - Codeforces - Code 6",
          "code": "7 8\n1 2\n1 3\n2 4\n3 4\n4 5\n4 6\n5 7\n6 7",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #286 - Codeforces - Code 7",
          "code": "7 8\n1 2\n1 3\n2 4\n3 4\n4 5\n4 6\n5 7\n6 7",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #286 - Codeforces - Code 8",
          "code": "Test: #12 ... verdict: WRONG_ANSWER\nInput\n1 30000\n30000\nOutput\n0\nAnswer\n1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #286 - Codeforces - Code 9",
          "code": "Test: #12 ... verdict: WRONG_ANSWER\nInput\n1 30000\n30000\nOutput\n0\nAnswer\n1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #286 - Codeforces - Code 10",
          "code": "unordered_map",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #286 - Codeforces - Code 11",
          "code": "res += (pars[c][u] == pars[c][v]);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #286 - Codeforces - Code 12",
          "code": "res += (pars[c][u] == pars[c][v]);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #286 - Codeforces - Code 13",
          "code": "if (pars[c].find(v) != pars[c].end() && pars[c][u] == pars[c][v]) {\n    res++;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #286 - Codeforces - Code 14",
          "code": "if (pars[c].find(v) != pars[c].end() && pars[c][u] == pars[c][v]) {\n    res++;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #286 Editorial (Complete) - Codeforces - Code 1",
          "code": "dp[i][j - offset]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15889",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #286 Editorial (Complete) - Codeforces - Code 2",
          "code": "components[x] & components[y]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15889",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #286 Editorial (Complete) - Codeforces - Code 3",
          "code": "7 8\n1 2\n2 3\n3 4\n4 1\n4 7\n7 6\n6 5\n5 2\n\nAuthor's Code on my Pc returns 7",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15889",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #286 Editorial (Complete) - Codeforces - Code 4",
          "code": "7 8\n1 2\n2 3\n3 4\n4 1\n4 7\n7 6\n6 5\n5 2\n\nAuthor's Code on my Pc returns 7",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15889",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #286 Editorial (Complete) - Codeforces - Code 5",
          "code": "Also, for each j (1 ≤ j ≤ ti), find the day di, j such that, if the j-th beat on the i-th bamboo is performed before day di, it will be no longer possible to keep the i-th bamboo's height after m days at most X (it can be found by doing simple math).",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15889",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #286 Editorial (Complete) - Codeforces - Code 6",
          "code": "if(target - h[i] <= 0){\n\tt[0]++;\n}else if(target - h[i] > a[i] * (m-1)){\n\tok = 0;\n\tgoto end;\n}else{\n\tt[(target - h[i] + a[i] - 1) / a[i]]++;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15889",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #286 Editorial (Complete) - Codeforces - Code 7",
          "code": "if(target - h[i] <= 0){\n\tt[0]++;\n}else if(target - h[i] > a[i] * (m-1)){\n\tok = 0;\n\tgoto end;\n}else{\n\tt[(target - h[i] + a[i] - 1) / a[i]]++;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15889",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #286 Editorial (Complete) - Codeforces - Code 8",
          "code": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\n#define pb push_back\n#define __addEdge(u, v) [u].push_back(v)\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<vi> vmi;\n\nint n, m;\nvmi G[111];\nvb mark;\n\nvoid dfs(vmi &SG, int u)\n{\n    mark[u] = true;\n    for (int i = 0; i < SG[u].size(); ++i)\n    {\n        int v = SG[u][i];\n        if (!mark[v])\n            dfs(SG, v);\n    }\n}\n\nint main()\n{\n    cin >> n >> m;\n\n    fill(G, G + 111, vmi(n + 1));\n    mark.assign(n + 1, false);\n    for (int i = 0; i < m; ++i)\n    {\n        int u, v, c;\n        cin >> u >> v >> c;\n        G[c]__addEdge(u, v);\n        G[c]__addEdge(v, u);\n    }\n\n    int q;\n    cin >> q;\n\n    while (q--)\n    {\n        int u, v;\n        cin >> u >> v;\n\n        int cnt = 0;\n        for (int k = 1; k <= 100; ++k)\n        {\n            fill(mark.begin(), mark.end(), false);\n            dfs(G[k], u);\n            cnt += mark[v];\n        }\n\n        cout << cnt << endl;\n    }   \n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/15889",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #286 Editorial (Complete) - Codeforces - Code 9",
          "code": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\n#define pb push_back\n#define __addEdge(u, v) [u].push_back(v)\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<vi> vmi;\n\nint n, m;\nvmi G[111];\nvb mark;\n\nvoid dfs(vmi &SG, int u)\n{\n    mark[u] = true;\n    for (int i = 0; i < SG[u].size(); ++i)\n    {\n        int v = SG[u][i];\n        if (!mark[v])\n            dfs(SG, v);\n    }\n}\n\nint main()\n{\n    cin >> n >> m;\n\n    fill(G, G + 111, vmi(n + 1));\n    mark.assign(n + 1, false);\n    for (int i = 0; i < m; ++i)\n    {\n        int u, v, c;\n        cin >> u >> v >> c;\n        G[c]__addEdge(u, v);\n        G[c]__addEdge(v, u);\n    }\n\n    int q;\n    cin >> q;\n\n    while (q--)\n    {\n        int u, v;\n        cin >> u >> v;\n\n        int cnt = 0;\n        for (int k = 1; k <= 100; ++k)\n        {\n            fill(mark.begin(), mark.end(), false);\n            dfs(G[k], u);\n            cnt += mark[v];\n        }\n\n        cout << cnt << endl;\n    }   \n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/15889",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 30000, \"n\");\n    inf.readSpace();\n    int d = inf.readInt(1, 30000, \"d\");\n    inf.readEoln();\n    vector<int> p(n);\n    for (int i = 0; i < n; i++) {\n        p[i] = inf.readInt(d, 30000, \"pi\");\n        inf.readEoln();\n        if (i > 0) {\n            ensuref(p[i - 1] <= p[i], \"pi should be non-decreasing: p[%d]=%d > p[%d]=%d\", i - 1, p[i - 1], i, p[i]);\n        }\n    }\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 30000, \"n\");\n    inf.readSpace();\n    int d = inf.readInt(1, 30000, \"d\");\n    inf.readEoln();\n    vector<int> p(n);\n    for (int i = 0; i < n; i++) {\n        p[i] = inf.readInt(d, 30000, \"pi\");\n        inf.readEoln();\n        if (i > 0) {\n            ensuref(p[i - 1] <= p[i], \"pi should be non-decreasing: p[%d]=%d > p[%d]=%d\", i - 1, p[i - 1], i, p[i]);\n        }\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 30000, \"n\");\n    inf.readSpace();\n    int d = inf.readInt(1, 30000, \"d\");\n    inf.readEoln();\n    vector<int> p(n);\n    for (int i = 0; i < n; i++) {\n        p[i] = inf.readInt(d, 30000, \"pi\");\n        inf.readEoln();\n        if (i > 0) {\n            ensuref(p[i - 1] <= p[i], \"pi should be non-decreasing: p[%d]=%d > p[%d]=%d\", i - 1, p[i - 1], i, p[i]);\n        }\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int d = opt<int>(\"d\");\n    string type = opt<string>(\"type\", \"random\");\n\n    if (n < 1 || n > 30000) {\n        fprintf(stderr, \"Error: n must be between 1 and 30000\\n\");\n        exit(1);\n    }\n    if (d < 1 || d > 30000) {\n        fprintf(stderr, \"Error: d must be between 1 and 30000\\n\");\n        exit(1);\n    }\n\n    vector<int> p(n);\n\n    if (type == \"random\") {\n        for (int i = 0; i < n; ++i) {\n            p[i] = rnd.next(d, 30000);\n        }\n        sort(p.begin(), p.end());\n    } else if (type == \"close\") {\n        // Positions are close together, within a small range\n        int start = d;\n        int end = min(30000, start + n - 1);\n        if (end - start + 1 < n) {\n            start = max(d, 30000 - n + 1);\n            end = 30000;\n        }\n        for (int i = 0; i < n; ++i) {\n            p[i] = start + i;\n            if (p[i] > 30000) p[i] = 30000;\n        }\n    } else if (type == \"cluster\") {\n        int k = opt<int>(\"k\", 5); // default clusters\n        if (k < 1) k = 1;\n        vector<int> centers(k);\n        // Generate k random centers between d and 30000\n        for(int i = 0; i < k; ++i){\n            centers[i] = rnd.next(d, 30000);\n        }\n        sort(centers.begin(), centers.end());\n        // Assign positions around cluster centers\n        for(int i = 0; i < n; ++i){\n            int c = centers[rnd.next(0, k - 1)];\n            int delta = rnd.next(-10, 10); // positions around center +/- 10\n            int pos = c + delta;\n            pos = max(d, min(pos, 30000));\n            p[i] = pos;\n        }\n        sort(p.begin(), p.end());\n    } else if (type == \"max_states\") {\n        // Designed to maximize the number of DP states\n        int pos = d;\n        int l = d;\n        for (int i = 0; i < n; ++i) {\n            p[i] = pos;\n            // Let's vary l between 1 and 1000\n            l = max(1, l + rnd.next(-1, 1));\n            pos += l;\n            if (pos > 30000) pos = 30000;\n        }\n        sort(p.begin(), p.end());\n    } else if (type == \"l1_pitfall\") {\n        // Generate positions such that l reaches 1\n        int pos = d;\n        int l = d;\n        for (int i = 0; i < n; ++i) {\n            if (l > 1) {\n                l--;\n            } else {\n                l = 1;\n            }\n            pos += l;\n            if (pos > 30000) pos = 30000;\n            p[i] = pos;\n        }\n        sort(p.begin(), p.end());\n    } else {\n        fprintf(stderr, \"Error: Unknown type '%s'\\n\", type.c_str());\n        exit(1);\n    }\n\n    printf(\"%d %d\\n\", n, d);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d\\n\", p[i]);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int d = opt<int>(\"d\");\n    string type = opt<string>(\"type\", \"random\");\n\n    if (n < 1 || n > 30000) {\n        fprintf(stderr, \"Error: n must be between 1 and 30000\\n\");\n        exit(1);\n    }\n    if (d < 1 || d > 30000) {\n        fprintf(stderr, \"Error: d must be between 1 and 30000\\n\");\n        exit(1);\n    }\n\n    vector<int> p(n);\n\n    if (type == \"random\") {\n        for (int i = 0; i < n; ++i) {\n            p[i] = rnd.next(d, 30000);\n        }\n        sort(p.begin(), p.end());\n    } else if (type == \"close\") {\n        // Positions are close together, within a small range\n        int start = d;\n        int end = min(30000, start + n - 1);\n        if (end - start + 1 < n) {\n            start = max(d, 30000 - n + 1);\n            end = 30000;\n        }\n        for (int i = 0; i < n; ++i) {\n            p[i] = start + i;\n            if (p[i] > 30000) p[i] = 30000;\n        }\n    } else if (type == \"cluster\") {\n        int k = opt<int>(\"k\", 5); // default clusters\n        if (k < 1) k = 1;\n        vector<int> centers(k);\n        // Generate k random centers between d and 30000\n        for(int i = 0; i < k; ++i){\n            centers[i] = rnd.next(d, 30000);\n        }\n        sort(centers.begin(), centers.end());\n        // Assign positions around cluster centers\n        for(int i = 0; i < n; ++i){\n            int c = centers[rnd.next(0, k - 1)];\n            int delta = rnd.next(-10, 10); // positions around center +/- 10\n            int pos = c + delta;\n            pos = max(d, min(pos, 30000));\n            p[i] = pos;\n        }\n        sort(p.begin(), p.end());\n    } else if (type == \"max_states\") {\n        // Designed to maximize the number of DP states\n        int pos = d;\n        int l = d;\n        for (int i = 0; i < n; ++i) {\n            p[i] = pos;\n            // Let's vary l between 1 and 1000\n            l = max(1, l + rnd.next(-1, 1));\n            pos += l;\n            if (pos > 30000) pos = 30000;\n        }\n        sort(p.begin(), p.end());\n    } else if (type == \"l1_pitfall\") {\n        // Generate positions such that l reaches 1\n        int pos = d;\n        int l = d;\n        for (int i = 0; i < n; ++i) {\n            if (l > 1) {\n                l--;\n            } else {\n                l = 1;\n            }\n            pos += l;\n            if (pos > 30000) pos = 30000;\n            p[i] = pos;\n        }\n        sort(p.begin(), p.end());\n    } else {\n        fprintf(stderr, \"Error: Unknown type '%s'\\n\", type.c_str());\n        exit(1);\n    }\n\n    printf(\"%d %d\\n\", n, d);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d\\n\", p[i]);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -d 1 -type random\n./gen -n 1 -d 1 -type close\n./gen -n 1 -d 30000 -type random\n\n./gen -n 10 -d 1 -type random\n./gen -n 10 -d 1 -type cluster -k 2\n./gen -n 10 -d 1 -type close\n\n./gen -n 100 -d 1000 -type random\n./gen -n 100 -d 1 -type l1_pitfall\n\n./gen -n 1000 -d 1 -type random\n./gen -n 1000 -d 10000 -type close\n./gen -n 1000 -d 1 -type cluster -k 3\n\n./gen -n 10000 -d 1 -type random\n./gen -n 10000 -d 1 -type close\n./gen -n 10000 -d 1 -type cluster -k 5\n./gen -n 10000 -d 1 -type l1_pitfall\n\n./gen -n 30000 -d 1 -type random\n./gen -n 30000 -d 1 -type close\n./gen -n 30000 -d 1 -type cluster -k 10\n./gen -n 30000 -d 10000 -type max_states\n./gen -n 30000 -d 1 -type max_states\n./gen -n 30000 -d 1 -type l1_pitfall\n\n./gen -n 30000 -d 30000 -type random\n\n./gen -n 30000 -d 15000 -type random\n\n./gen -n 30000 -d 1 -type max_states\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:40:43.497138",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "506/B",
      "title": "B. Технология мистера Китаюта",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест1 секунда",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеВ первой строке записано два целых числа через пробел, n и m (2 ≤ n ≤ 105, 1 ≤ m ≤ 105), обозначающих количество городов в королевстве Шусеки и количество важных пар, соответственно.В следующих m строках описаны важные пары. В i-й из них (1 ≤ i ≤ m) записано два целых числа через пробел, ai и bi (1 ≤ ai, bi ≤ n, ai ≠ bi), обозначающих, что должно быть возможно путешествовать из города ai в город bi через один или более телепортационных туннелей. Гарантируется, что все пары (ai, bi) различны.",
      "output_spec": "Выходные данныеВыведите минимальное требуемое количество телепортационных туннелей для выполнения цели мистера Китаюты.",
      "sample_tests": "ПримерыВходные данныеСкопировать4 51 21 31 42 32 4Выходные данныеСкопировать3Входные данныеСкопировать4 61 21 42 32 43 23 4Выходные данныеСкопировать4",
      "description": "B. Технология мистера Китаюта\n\nограничение по времени на тест1 секунда\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвыводstdout\n\nВходные данныеВ первой строке записано два целых числа через пробел, n и m (2 ≤ n ≤ 105, 1 ≤ m ≤ 105), обозначающих количество городов в королевстве Шусеки и количество важных пар, соответственно.В следующих m строках описаны важные пары. В i-й из них (1 ≤ i ≤ m) записано два целых числа через пробел, ai и bi (1 ≤ ai, bi ≤ n, ai ≠ bi), обозначающих, что должно быть возможно путешествовать из города ai в город bi через один или более телепортационных туннелей. Гарантируется, что все пары (ai, bi) различны.\n\nВходные данные\n\nВыходные данныеВыведите минимальное требуемое количество телепортационных туннелей для выполнения цели мистера Китаюты.\n\nВыходные данные\n\nВходные данныеСкопировать4 51 21 31 42 32 4Выходные данныеСкопировать3Входные данныеСкопировать4 61 21 42 32 43 23 4Выходные данныеСкопировать4\n\nВходные данныеСкопировать4 51 21 31 42 32 4\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать3\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать4 61 21 42 32 43 23 4\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать4\n\nВыходные данныеСкопировать\n\nСкопировать\n\nПримечаниеВ первом примере один из оптимальных способов построить туннели показан на рисунке ниже:   Для второго примера один из оптимальных способов указан ниже:",
      "solutions": [
        {
          "title": "Codeforces Round #286 - Codeforces",
          "content": "Hello Codeforces!evima, yosupo and I would like you to participate in Codeforces Round #286. It will be held on Sunday, January 18th at 16:00 MSK. Please note that this round starts on unusual time.Great thanks to Zlobober who helped us prepare this round, Delinur who translated statements into Russian and MikeMirzayanov who created Codeforces and polygon.This is the 3rd time(following #162 and #263) for me, and the 1st time for evima and yosupo to prepare a Codeforces Round.Scores of the problems will be500-1000-1750-1750-2500 for Div.1, and500-1000-1500-2000-2750 for Div.2.In this round, you'll help a man named Mr. kitayuta. I hope he will participate :)The system tests are now over! The top-5 are as follows:Div.1:1.ilyakor2.kcm17003.LayCurse4.RomaWhite5.TankEngineerDiv.2:1.Konijntje2.cpcpc3.zgzjsxshycxksxhsh4.Ronnie0075.sha384Also, special congrats on Petr, who solved problem E in Div.1, which anyone else could not solve.Here are the editorials",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/15842",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 961
        },
        {
          "title": "Codeforces Round #286 Editorial (Complete) - Codeforces",
          "content": "Edit (Jan 22, 2:45 AM UTC): Added Div1E and the editorial is now complete. I am sorry for the delay.Edit (Jan 21, 9:45 AM UTC): Added the explanation for Div1C/2E, and the problem setters' codes. Div1E will need several more hours. Thank you again for your patience.First, here are some statistics on this round: Division Registrants Participants A Accepted B Accepted C Accepted D Accepted E Accepted 1 1364 572 (*) 294 199 8 113 1 (Estimated number of AC by me) 800 (wrong) 500 (wrong) 70 (FAIL) 90 (ok) 5 (wrong) 2 4016 2028 1355 945 41 5 0 (*) Where did the remaining 792 people go? :) We are sorry for terribly underestimating the difficulty of the problems (except Div1D), especially Div1A/2C and Div1C/2E. Div.2 A: 505A - Mr. Kitayuta's Gift[Problem] Given a string, turn it into a palindrome by inserting one letter or state that it is impossible.(Problem by evima)Since the string is short (at most 10 characters), you can simply try every possible way of inserting a letter (\"where\" and \"what\" to insert), and check if the resulting string is a palindrome.The writer's code (C++): 9501249Note: For some strange reason, we (contest managers) cannot submit solutions so that everyone can see them. PraveenDhinwa told us how to do so. Thank you! Div.2 B: 505B - Mr. Kitayuta's Colorful Graph[Problem] Given an undirected graph whose edges are painted in colors, process the queries of the following form: Given two vertices ui and vi, find the number of the colors that satisfies the following condition: the edges of that color connect ui and vi (possibly indirectly). (Problem by hogloid)Since neither the graph nor the number of queries is too large, for each query you can simply count the number of the \"good\" colors (the colors that satisfies the condition) by checking if each color is \"good\". To do that, you can perform Depth First Search (or Breadth First Search) and verify whether you can reach vi from ui traversing only the edges of that color. If you prefer using Union-Find, it will also do the job.The writer's code (DFS, C++)The writer's code (Union-Find, C++) Div.2 C / Div.1 A: 505C - Mr. Kitayuta, the Treasure Hunter[Problem] Since it is hard to summarize this problem, please refer to the official statement.(Problem by yosupo)Below is the explanation from yosupo, translated by me.[From here]Let m be the number of the islands (that is, 30001). First, let us describe a solution with time and memory complexity of O(m2).We will apply Dynamic Programming. let dp[i][j] be the number of the gems that Mr. Kitayuta can collect after he jumps to island i, when the length of his previous jump is j (let us assume that he have not collect the gems on island i). Then, you can calculate the values of the table dp by the following: dp[i][j] = 0, if i ≥ m(actually these islands do not exist, but we can suppose that they exist and when Mr. Kitayuta jumps to these islands, he stops jumping) dp[i][j] =  (the number of the gems on island i)  + max(dp[i + j][j], dp[i + j + 1][j + 1]), if i < m, j = 1(he cannot perform a jump of length 0) dp[i][j] =  (the number of the gems on island i)  + max(dp[i + j - 1][j - 1], dp[i + j][j], dp[i + j + 1][j + 1]), if i < m, j ≥ 2 This solution is unfeasible in terms of both time and memory. However, the following observation makes it an Accepted solution: there are only 491 values of j that we have to consider, which are d - 245, d - 244, d - 243, ..., d + 244 and d + 245.Why? First, let us find the upper bound of j. Suppose Mr. Kitayuta always performs the \"l + 1\" jump (l: the length of the previous jump). Then, he will reach the end of the islands before he performs a jump of length d + 246, becaused + (d + 1) + (d + 2) + ... + (d + 245) ≥ 1 + 2 + ... + 245 = 245·(245 + 1) / 2 = 30135 > 30000. Thus, he will never be able to perform a jump of length d + 246 or longer.Next, let us consider the lower bound of j in a similar way. If d ≤ 246, then obviously he will not be able to perform a jump of length d - 246 or shorter, because the length of a jump must be positive. Suppose Mr. Kitayuta always performs the \"l - 1\" jump, where d ≥ 247. Then, again he will reach the end of the islands before he performs a jump of length d - 246, becaused + (d - 1) + (d - 2) + ... + (d - 245) ≥ 245 + 244 + ... + 1 = 245·(245 + 1) / 2 = 30135 > 30000. Thus, he will never be able to perform a jump of length d - 246 or shorter.Therefore, we have obtained a working solution: similar to the O(m2) one, but we will only consider the value of j between d - 245 and d + 245. The time and memory complexity of this solution will be O(m1.5), since the value \"245\" is slightly larger than .This solution can be implemented by, for example, using a \"normal\" two dimensional array with a offset like this: dp[i][j - offset]. The time limit is set tight in order to fail most of naive solutions with search using std::map or something, so using hash maps (unordered_map) will be risky although the complexity will be the same as the described solution.[End]The writer's code (memoized recursion, C++) Div.2 D / Div.1 B: 505D - Mr. Kitayuta's Technology[Problem] Given an integer n and m pairs of integers (ai, bi) (1 ≤ ai, bi ≤ n), find the minimum number of edges in a directed graph that satisfies the following condition: For each i, there exists a path from vertex ai to vertex bi. (Problem from evima)Let G1 be the directed graph built from the input, and G2 be a directed graph that satisfies the given conditions. What we seek is the minimum number of edges in G2. Also, we say that two vertices u and v in a directed graph are \"weakly connected\" if we can reach v from u by traversing edges, not considering their directions.If a pair (u, v) is present in the input, then vertices u and v must be weakly connected in G2. Therefore, for each weakly connected component (abbreviated to wcc) in G1, the vertices in that component must also be in the same wcc in G2. We can \"merge\" multiple wccs in G1 and create a larger wcc in G2, but for now, let us find the minimum number of edges required in G2 for each wcc in G1 when we do not \"merge\" them. There are two cases to consider: If a wcc in G1 does not have cycles, then we can perform topological sort on that wcc, and we can make a \"chain\" (see the image below) using the topological order to satisfy the conditions. We need (the number of the vertices in the wcc)  - 1 edges, which is the minimum required number since any connected graph with V vertices has at least V - 1 edges. If a wcc in G1 has cycles, then topological sort cannot be applied. We need at least (the number of the vertices in the wcc) edges this time, since any connected graph with V vertices and V - 1 edges is a tree, which does not contain cycles. Actually, this number (the number of the vertices in the wcc) is always achievable by connecting the vertices into a \"ring\" (see the image below), thus it is the minimum required number that we seek. We have found the minimum required number of edges for each wcc in G1 when we do not \"merge\" them. Let us show that \"merging\" wccs in G1 do not reduce the number of required edges. Suppose we combine k( > 1) wccs C1, C2, ..., Ck in G1 into one wcc C in G2. Again, there are two cases to consider: If none of C1, C2, ..., Ck contains cycles, then C will need |C1| + |C2| + ... + |Ck| - 1 edges. However, if we do not combine them, we will only need (|C1| - 1) + (|C2| - 1) + ... + (|Ck| - 1) edges in total, which is fewer. If some of C1, C2, ..., Ck contain cycles, then C will need |C1| + |C2| + ... + |Ck| edges. However, if we do not combine them, we will need(|C1| - noCycles(C1)) + (|C2| - noCycles(C2)) + ... + (|Ck| - noCycles(Ck)  ≤ |C1| + |C2| + ... + |Ck| edges(here, noCycles(Ci) is 1 if Ci do not contain cycles, otherwise 0), thus combining them does not reduce the number of required edges. Thus, we do not need to combine multiple wccs into one wcc in G2 in order to obtain the optimal solution. That is, the final answer to the problem is the sum of the minimum required number of edges for each wcc in G1, when they are considered separately.As for the implementation, detecting cycles in a directed graph with 105 vertices and edges might be a problem if this is your first encounter with it. One possible way is to paste a code that decomposes a graph into strongly connected components. If the size of a strongly connected component is more than one, then that means the component contains cycles.The writer's code (strongly connected component decomposition, C++): 9501202 Div.2 E / Div.1 C: 505E - Mr. Kitayuta vs. Bamboos[Problem] Since it is hard to summarize this problem, please refer to the official statement.(Problem from yosupo)Below is the explanation from yosupo, translated by me.[From here]Let us begin by applying Binary Search. The problem becomes: \"is it possible that all the bamboos are at most X meters after m days?\" It is complicated by the fact that the height does not become negative; the excessive decrease will be wasted. We have found two approaches to this problem. Solution 1 Mr. Kitayuta must beat the i-th bamboo at least max(0, ⌈(hi + m·ai - X) / P⌉) times (let this number ti). Actually, it is not necessary for him to beat it more than this number of times. Thus, let us assume that he beat the i-th bamboo exactly ti times. Also, for each j (1 ≤ j ≤ ti), find the day di, j such that, if the j-th beat on the i-th bamboo is performed before day di, it will be no longer possible to keep the i-th bamboo's height after m days at most X (it can be found by doing simple math). If Mr. Kitayuta can beat the bamboos under this constraint, all the bamboos' heights will become X meters or less after m days. Otherwise, some bamboos' heights will exceed X meters.The time complexity of this solution will be , if we first calculate only ti, then if the sum of ti exceeds km, we skip finding di, j (the answer is \"NO\"). Solution 2 This problem becomes simpler if we simulate Mr. Kitayuta's fight backwards, that is, from day m to day 1. It looks like this:[Problem'] There are n bamboos. At the moment, the height of the i-th bamboo is X meters, and it shrinks ai meters at the beginning of each day. Mr. Kitayuta will play a game. He can use Magic Hammer at most k times per day to increase the height of a bamboo by p meters. If some bamboo's height becomes negative at any moment, he will lose the game immediately. Also, in order for him to win the game, the i-th bamboo's height must be at least hi meters after m days. Is victory possible?Below is an illustration of this \"reverse simulation\": This version is simpler because he is increasing the heights instead of decreasing, thus we do not need to take into account the \"excessive decrease beyond 0 meters\" which will be wasted. Let us consider an optimal strategy. If there exist bamboos whose heights would become negative after day m, he should beat the one that is the earliest to make him lose. Otherwise, he can choose any bamboo whose height would be less than hi meters after day m. Repeat beating the bamboos following this strategy, and see if he can actually claim victory.The writer's implementation of this solution uses a priority queue, and its time complexity is .[End]The tester's code (Solution 1, C++): 9501229The writer's code (Solution 2, C++) Div.1 D: 506D - Mr. Kitayuta's Colorful Graph[Problem] Given an undirected graph whose edges are painted in colors, process the queries of the following form: Given two vertices ui and vi, find the number of the colors that satisfies the following condition: the edges of that color connect ui and vi (possibly indirectly). Note: this is the exact same problem as Div.2 B except the constraints, which are 105 instead of 100.(Problem from hogloid)Below is the explanation from hogloid.[From here]For each color, make a new graph that consists of the edges of the color and vertices connected by the edges. Make UnionFind for each graph, and you can check whether a color connects vertex A and B , using it. For each query, find a vertex which has smaller degree(let this vertex A, and the other vertex B) For each colors such that a edge of the color connects to A, check whether A and B is connected by the color. After answering the query, memorize its tuple — (A, B, answer). If the same query is requested, answer using this information.This will lead to solution.For each query, the complexity is (For each color connects A, find a vertex of B of the color & check whether they are connected) The queries that require longest computing time are, to ask every pair among vertices which have largest degrees. Let the indices of the vertices be , and degrees of the vertices be d1, d2, ...dk. Now, let's fix vertex B as i. The total computing time of the queries such that B is vertex i is . Vertex B can vary from 2 to k. Hence, the total complexity is at most . This complexity is at most .By the way, in C++, using unordered_map, total complexity would be .[End]There will be many other solutions. I will briefly explain one of them which I think is typical.Let ci be the number of colors of the edges incident to vertex i. The sum of all ci does not exceed 2m since each edge increases this sum by at most 2. Thus, there will be at most 450 values of i such that ci ≥ 450 (let B = 450). We will call these vertices large, and the remaining ones small. Using O(m / B·m) = O(m2 / B) time and memory, we can precalculate and store the answer for all the possible queries where at least one of ui and vi is large, then we can immediately answer these queries. For the remaining queries, both ui and vi will be small, therefore it is enough to directly count the color that connects vertices ui and vi in O(B) time. The total time required will be O(m2 / B + Bq). If we choose , we can solve the problem in time.The writer's code (the first solution, C++)The tester's code (the second solution, C++): 9501240 Div.1 E: 506E - Mr. Kitayuta's Gift[Problem] Given a string s and an integer n, find the number of the palindromes that can be obtained by inserting exactly n letters into s.Note: Div.2 A is a similar problem, where n is fixed to 1.(Problem from evima)First of all, let us note that we are asked to count the resulting palindromes, not the ways to obtain them. For example, if we are to insert \"b\" into \"abba\", there are 5 possible positions, but only 3 strings will be produced (\"babba\", \"abbba\" and \"abbab\"). Rather than trying to count the ways of inserting a letter n times and removing the duplicated results, we should directly count the resulting palindrome. To do that, let us reformulate the problem:[Problem'] Given a string s and an integer n, find the number of the palindromes of length |s| + n (let this number be N) that contains s as a subsequence (not necessarily contiguous).Consider constructing a palindrome from both ends, and matching it to s from both left and right. For example, let s = \"abaac\" and N = 11. Let us call the final resulting string t. We first decide what letter to use as t1 and t11 (they must be equal in order for t to be a palindrome). Let us say 'c' is chosen. Now, we have to construct the remaining part of t, that is, t2..t10, so that t2..t10 contains \"abaa\" as a substring (note that the 'c' at the end of s is discarded). Again, we decide what letter to use as t2 and t10. This time we choose 'a'. Then, we have to construct t3..t9, so that it contains \"ba\" as a substring (this time the two 'a's at the both ends of s are discarded). We choose t3 = t9 = 'c'. Next, we construct t4..t8, so that it contains \"ba\" as a substring (this time s remains unchanged). We choose t4 = t8 = 'b'. Then, we construct t5..t7, so that it contains \"a\" as a substring. We choose t5 = t7 = 'a' (it is becoming repetitive, isn't it?). The last part of t, that is, t6, has no restriction (this time we choose a letter for only one position of t, not two). We choose 'd', and we have obtained a palindrome \"cacbadabcac\" that contains s = \"abaac\" as a subsequence.This problem is mostly about analyzing this process carefully.The most naive solution other than literally enumerating all palindromes of length N would be the following Dynamic Programming: let dp[i][left][right] be the number of the palindromes t that can be obtained if you have already decided the leftmost and the rightmost i letters (2i in total), and the substring sleftsleft + 1..sright of s remains unmatched. Each value in this table can be computed in O(1) time. Of course, since i can be up to ⌊n / 2⌋ (n ≤ 109), this solution is far from our goal.Notice that the transitions from dp[i] to dp[i + 1] are the same regardless of i, thus we can calculate the table by matrix exponentiation. However, since there are O(|s|2) possible pairs for (left, right), we will need time, which is actually worse than the naive calculation considering that |s| can be up to 200.This is where we need to observe the process which we have gone through at the beginning more carefully. Let us build a automaton corresponding to the process (the image below). (*) An self-loop with a number means that there are actually that number of edges.A process of producing a palindrome of length N that contains s as a subsequence corresponds to a path of length ⌈N / 2⌉ from the upper-right vertex to the lower-left vertex. Each red vertex has 24 self-loops since the letters at the both ends of the remaining part of s is different, which correspond to two non-self-loop transitions. Similarly, each green vertex has 25 self-loops since the first letter and the last letter of the remaining string is the same, and the blue vertex, the destination, has 26 self-loops, as there are no more non-self-loop transitions available.Here is an important fact: there are not so many possible combination of (n24, n25), where n24 and n25 are the number of times a path from START to GOAL visits a red vertex (with 24 self-loops) and a green vertex (with 25 self-loops), respectively. Why? Each time we leave a red vertex, the length of the remaining unmatched part of s decreases by 1, since exactly one of the two letters at the ends of the remaining part is matched and discarded. Similarly, each time we leave a green vertex, the length of the remaining string decreases by 2, since both of the two letters at the ends are matched and discarded. There is a exception, however: if the length of the remaining string is 1, then it will be a green vertex, but in this case the length will decrease by 1. Thus, for any path from START to GOAL, n24 + 2·n25 will be equal to either |s| or |s| + 1. If we fix n24, then n25 will be uniquely determined by n25 = ⌈(|s| - n24) / 2⌉. Since n24 can only take the value between 0 and |s| - 1, there are at most |s| possible pairs of (n24, n25).With this fact, we are ready to count the paths: let us classify them by the value of n24. For each possible pair of (n24, n25), let us count the number of corresponding paths. To do that, we divide each paths into two parts: first we count the number of paths from START to GOAL, using only non-self-loop transitions. Then, we count the ways of inserting self-loop transitions into each of these paths. The product of these two numbers will be the number that we seek.The first part is straightforward to solve: let dp[left][right][n24] be the number of paths from the vertex that corresponds to the substring sleftsleft + 1..sright, visiting exactly n24 red vertices using only non-self-loop transitions. Each value of the table can be found in O(1) time, thus the whole table can be computed in O(|s|3) time, which is fast enough for the input size (|s| ≤ 200).The main obstacle will be the second part. For example, let us consider the case where s = \"abaac\", N = 11, n24 = 2, which corresponds to the example at the beginning. From the fact we found earlier, n25 = ⌈(|s| - n24) / 2⌉ = ⌈(5 - 2) / 2⌉ = 2. Thus, we have to insert ⌈N / 2⌉ - n24 - n25 = 6 - 2 - 2 = 2 self-loop transitions into this path (the image): The order in which red, green and blue vertices appears in this path does not affect the number of ways of insertion, and can be arbitrary. The number of ways to insert 2 self-loop transitions will be equal to the number of the path of length ⌈N / 2⌉ = 6 from START to GOAL in this automaton (we have to take into account the non-self-loop transitions in it), which can be calculated by matrix exponentiation.Are we done? No! Consider the case s = \"abbb..(|s| - 1 times)..bb\". There are |s| - 1 possible values of n24 (n24 = 1 corresponds to the case where you match and discard the 'a' first, and n24 = |s| - 1 corresponds to the case where you keep the 'a' until s becomes \"ab\"). Thus, you need to perform matrix exponentiation |s| - 1 times, which results in a total of time, which will be too much under the given constraints.There is still hope, though, and here is the climax. Notice that these automata are very similar to each other, and they differ only in the number of the red and green vertices. We can combine these automata into one larger automaton like this (the image): The combined automaton should have |s| - 1 red, ⌈|s| / 2⌉ green and ⌈|s| / 2⌉ blue vertices.By performing matrix exponentiation on this automaton instead of many small automata, we can find all the required value in time, which should be enough. We recommend speeding up matrix multiplication by noticing that the matrix will be upper triangular (6 times faster on paper), since the time limit is not so generous (in order to reject solutions).The problem is almost solved, but there is one more challenge. When N is odd, the situation becomes a little complicated: as we have seen at the beginning, in the last (⌈N / 2⌉-th) step of producing a palindrome we choose a letter for only one position of the resulting string, that is, the center of that string. In other words, the last transition in the path in the automaton we have first built must not be one from a green vertex with a string of length 2 (for example, \"aa\") to GOAL.Let us find the number of the paths that violates this condition and subtract it from the answer. As previously mentioned, for each path n24 + 2·n25 will be equal to either |s| or |s| + 1, and if we fix the value of n24, n25 will be uniquely determined by n25 = ⌈(|s| - n24) / 2⌉. If |s| - n24 is odd, then it means that the last non-self-loop transition is one from a green vertex with a string of length 1, therefore in this case no path will violate the condition. If |s| - n24 is even, then the last non-self-loop trantision is from a green vertex with a string of length 2, thus the paths that does not contain the self-loop from GOAL to itself violate the condition. It will be equal to the number of the paths of length ⌈N / 2⌉ - 1 from START to the vertex just before GOAL, which can be found in a similar way to the second part of the solution.The journey has finally come to an end. Actually, it is also possible to solve this problem in time without matrix exponentiation, but this margin is too small to explain it. I will just paste the link to the code.The writer's code (matrix exponentiation, C++): 9501164The writer's code (without matrix exponentiation, C++): 9501177Congratulations again to Petr who was the only participant to solve this problem in 108 minutes. Also, I would like to give a special mention to rng_58, who was VERY close to solving it in only 63 minutes. He was just one byte away from getting AC (compare 9460984 and 9465440)! If you find a possible error, or have a question, please feel free to ask here. Alternative solutions are also welcome.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/15889",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.6,
            "reason": "宽松匹配: 包含题目编号 506 和字母"
          },
          "content_length": 23595
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #286 - Codeforces - Code 1",
          "code": "This is the 3rd time(following #162 and #263) for me",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #286 - Codeforces - Code 2",
          "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N = 1e2 + 5;\n\nint parent[N][N];\n\nint find(int c, int v) {\n    if (parent[c][v] == -1)\n        return v;\n    return parent[c][v] = find(c, parent[c][v]);\n}\n\nvoid unite(int c, int u, int v) {\n    parent[c][find(c, u)] = find(c, v);\n}\n\nint main() {\n    memset(parent, -1, sizeof parent);\n    int n, m;\n    cin >> n >> m;\n    for (int i = 0; i < m; ++i) {\n        int a, b, c;\n        cin >> a >> b >> c;\n        unite(c, a, b);\n    }\n    int q;\n    cin >> q;\n    while (q--) {\n        int u, v, ans = 0;\n        cin >> u >> v;\n        for (int i = 1; i <= 100; ++i)\n            if (find(i, u) == find(i, v))\n                ++ans;\n        cout << ans << '\\n';\n    }\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/15842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #286 - Codeforces - Code 3",
          "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N = 1e2 + 5;\n\nint parent[N][N];\n\nint find(int c, int v) {\n    if (parent[c][v] == -1)\n        return v;\n    return parent[c][v] = find(c, parent[c][v]);\n}\n\nvoid unite(int c, int u, int v) {\n    parent[c][find(c, u)] = find(c, v);\n}\n\nint main() {\n    memset(parent, -1, sizeof parent);\n    int n, m;\n    cin >> n >> m;\n    for (int i = 0; i < m; ++i) {\n        int a, b, c;\n        cin >> a >> b >> c;\n        unite(c, a, b);\n    }\n    int q;\n    cin >> q;\n    while (q--) {\n        int u, v, ans = 0;\n        cin >> u >> v;\n        for (int i = 1; i <= 100; ++i)\n            if (find(i, u) == find(i, v))\n                ++ans;\n        cout << ans << '\\n';\n    }\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/15842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #286 - Codeforces - Code 4",
          "code": "Runtime Error",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #286 - Codeforces - Code 5",
          "code": "Memory Limit Exceeded",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #286 - Codeforces - Code 6",
          "code": "7 8\n1 2\n1 3\n2 4\n3 4\n4 5\n4 6\n5 7\n6 7",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #286 - Codeforces - Code 7",
          "code": "7 8\n1 2\n1 3\n2 4\n3 4\n4 5\n4 6\n5 7\n6 7",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #286 - Codeforces - Code 8",
          "code": "Test: #12 ... verdict: WRONG_ANSWER\nInput\n1 30000\n30000\nOutput\n0\nAnswer\n1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #286 - Codeforces - Code 9",
          "code": "Test: #12 ... verdict: WRONG_ANSWER\nInput\n1 30000\n30000\nOutput\n0\nAnswer\n1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #286 - Codeforces - Code 10",
          "code": "unordered_map",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #286 - Codeforces - Code 11",
          "code": "res += (pars[c][u] == pars[c][v]);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #286 - Codeforces - Code 12",
          "code": "res += (pars[c][u] == pars[c][v]);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #286 - Codeforces - Code 13",
          "code": "if (pars[c].find(v) != pars[c].end() && pars[c][u] == pars[c][v]) {\n    res++;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #286 - Codeforces - Code 14",
          "code": "if (pars[c].find(v) != pars[c].end() && pars[c][u] == pars[c][v]) {\n    res++;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #286 Editorial (Complete) - Codeforces - Code 1",
          "code": "dp[i][j - offset]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15889",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #286 Editorial (Complete) - Codeforces - Code 2",
          "code": "components[x] & components[y]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15889",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #286 Editorial (Complete) - Codeforces - Code 3",
          "code": "7 8\n1 2\n2 3\n3 4\n4 1\n4 7\n7 6\n6 5\n5 2\n\nAuthor's Code on my Pc returns 7",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15889",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #286 Editorial (Complete) - Codeforces - Code 4",
          "code": "7 8\n1 2\n2 3\n3 4\n4 1\n4 7\n7 6\n6 5\n5 2\n\nAuthor's Code on my Pc returns 7",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15889",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #286 Editorial (Complete) - Codeforces - Code 5",
          "code": "Also, for each j (1 ≤ j ≤ ti), find the day di, j such that, if the j-th beat on the i-th bamboo is performed before day di, it will be no longer possible to keep the i-th bamboo's height after m days at most X (it can be found by doing simple math).",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15889",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #286 Editorial (Complete) - Codeforces - Code 6",
          "code": "if(target - h[i] <= 0){\n\tt[0]++;\n}else if(target - h[i] > a[i] * (m-1)){\n\tok = 0;\n\tgoto end;\n}else{\n\tt[(target - h[i] + a[i] - 1) / a[i]]++;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15889",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #286 Editorial (Complete) - Codeforces - Code 7",
          "code": "if(target - h[i] <= 0){\n\tt[0]++;\n}else if(target - h[i] > a[i] * (m-1)){\n\tok = 0;\n\tgoto end;\n}else{\n\tt[(target - h[i] + a[i] - 1) / a[i]]++;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15889",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #286 Editorial (Complete) - Codeforces - Code 8",
          "code": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\n#define pb push_back\n#define __addEdge(u, v) [u].push_back(v)\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<vi> vmi;\n\nint n, m;\nvmi G[111];\nvb mark;\n\nvoid dfs(vmi &SG, int u)\n{\n    mark[u] = true;\n    for (int i = 0; i < SG[u].size(); ++i)\n    {\n        int v = SG[u][i];\n        if (!mark[v])\n            dfs(SG, v);\n    }\n}\n\nint main()\n{\n    cin >> n >> m;\n\n    fill(G, G + 111, vmi(n + 1));\n    mark.assign(n + 1, false);\n    for (int i = 0; i < m; ++i)\n    {\n        int u, v, c;\n        cin >> u >> v >> c;\n        G[c]__addEdge(u, v);\n        G[c]__addEdge(v, u);\n    }\n\n    int q;\n    cin >> q;\n\n    while (q--)\n    {\n        int u, v;\n        cin >> u >> v;\n\n        int cnt = 0;\n        for (int k = 1; k <= 100; ++k)\n        {\n            fill(mark.begin(), mark.end(), false);\n            dfs(G[k], u);\n            cnt += mark[v];\n        }\n\n        cout << cnt << endl;\n    }   \n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/15889",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #286 Editorial (Complete) - Codeforces - Code 9",
          "code": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\n#define pb push_back\n#define __addEdge(u, v) [u].push_back(v)\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<vi> vmi;\n\nint n, m;\nvmi G[111];\nvb mark;\n\nvoid dfs(vmi &SG, int u)\n{\n    mark[u] = true;\n    for (int i = 0; i < SG[u].size(); ++i)\n    {\n        int v = SG[u][i];\n        if (!mark[v])\n            dfs(SG, v);\n    }\n}\n\nint main()\n{\n    cin >> n >> m;\n\n    fill(G, G + 111, vmi(n + 1));\n    mark.assign(n + 1, false);\n    for (int i = 0; i < m; ++i)\n    {\n        int u, v, c;\n        cin >> u >> v >> c;\n        G[c]__addEdge(u, v);\n        G[c]__addEdge(v, u);\n    }\n\n    int q;\n    cin >> q;\n\n    while (q--)\n    {\n        int u, v;\n        cin >> u >> v;\n\n        int cnt = 0;\n        for (int k = 1; k <= 100; ++k)\n        {\n            fill(mark.begin(), mark.end(), false);\n            dfs(G[k], u);\n            cnt += mark[v];\n        }\n\n        cout << cnt << endl;\n    }   \n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/15889",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char *argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(2, 100000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 100000, \"m\");\n    inf.readEoln();\n\n    set<pair<int, int>> pairs;\n\n    for (int i = 0; i < m; i++) {\n        int a = inf.readInt(1, n, \"a_i\");\n        inf.readSpace();\n        int b = inf.readInt(1, n, \"b_i\");\n        inf.readEoln();\n\n        ensuref(a != b, \"a_i (%d) should not be equal to b_i (%d)\", a, b);\n\n        ensuref(pairs.insert({a, b}).second, \"The pair (%d, %d) is duplicated\", a, b);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char *argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(2, 100000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 100000, \"m\");\n    inf.readEoln();\n\n    set<pair<int, int>> pairs;\n\n    for (int i = 0; i < m; i++) {\n        int a = inf.readInt(1, n, \"a_i\");\n        inf.readSpace();\n        int b = inf.readInt(1, n, \"b_i\");\n        inf.readEoln();\n\n        ensuref(a != b, \"a_i (%d) should not be equal to b_i (%d)\", a, b);\n\n        ensuref(pairs.insert({a, b}).second, \"The pair (%d, %d) is duplicated\", a, b);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char *argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(2, 100000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 100000, \"m\");\n    inf.readEoln();\n\n    set<pair<int, int>> pairs;\n\n    for (int i = 0; i < m; i++) {\n        int a = inf.readInt(1, n, \"a_i\");\n        inf.readSpace();\n        int b = inf.readInt(1, n, \"b_i\");\n        inf.readEoln();\n\n        ensuref(a != b, \"a_i (%d) should not be equal to b_i (%d)\", a, b);\n\n        ensuref(pairs.insert({a, b}).second, \"The pair (%d, %d) is duplicated\", a, b);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string type = opt<string>(\"type\", \"random\");\n\n    printf(\"%d %d\\n\", n, m);\n\n    set<pair<int, int>> edges;\n\n    if (type == \"chain\") {\n        // m = n - 1\n        if (m != n - 1) {\n            m = n - 1;\n        }\n        for (int i = 1; i <= m; ++i) {\n            printf(\"%d %d\\n\", i, i+1);\n        }\n    } else if (type == \"reverse_chain\") {\n        // m = n - 1\n        if (m != n - 1) {\n            m = n - 1;\n        }\n        for (int i = n; i >= 2; --i) {\n            printf(\"%d %d\\n\", i, i-1);\n        }\n    } else if (type == \"star\") {\n        // m = n - 1\n        if (m != n - 1) {\n            m = n - 1;\n        }\n        for (int i = 2; i <= n; ++i) {\n            printf(\"%d %d\\n\", 1, i);\n        }\n    } else if (type == \"reverse_star\") {\n        // m = n - 1\n        if (m != n -1) {\n            m = n - 1;\n        }\n        for (int i = 2; i <= n; ++i) {\n            printf(\"%d %d\\n\", i, 1);\n        }\n    } else if (type == \"complete\") {\n        // For small n, output all possible pairs (ai, bi), ai != bi\n        if (n <= 500 && m >= n*(n-1)) {\n            m = n*(n-1);\n            for (int i = 1; i <= n; ++i) {\n                for (int j = 1; j <= n; ++j) {\n                    if (i != j) {\n                        printf(\"%d %d\\n\", i, j);\n                    }\n                }\n            }\n        } else {\n            // n is too big for complete type, output random distinct pairs\n            for (int i = 0; i < m; ++i) {\n                int ai, bi;\n                do {\n                    ai = rnd.next(1, n);\n                    bi = rnd.next(1, n);\n                } while (ai == bi || edges.count({ai, bi}));\n                edges.insert({ai, bi});\n                printf(\"%d %d\\n\", ai, bi);\n            }\n        }\n    } else if (type == \"random\") {\n        // Generate m random distinct pairs\n        for (int i = 0; i < m; ++i) {\n            int ai, bi;\n            do {\n                ai = rnd.next(1, n);\n                bi = rnd.next(1, n);\n            } while (ai == bi || edges.count({ai, bi}));\n            edges.insert({ai, bi});\n            printf(\"%d %d\\n\", ai, bi);\n        }\n    } else {\n        // Default to random\n        for (int i = 0; i < m; ++i) {\n            int ai, bi;\n            do {\n                ai = rnd.next(1, n);\n                bi = rnd.next(1, n);\n            } while (ai == bi || edges.count({ai, bi}));\n            edges.insert({ai, bi});\n            printf(\"%d %d\\n\", ai, bi);\n        }\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string type = opt<string>(\"type\", \"random\");\n\n    printf(\"%d %d\\n\", n, m);\n\n    set<pair<int, int>> edges;\n\n    if (type == \"chain\") {\n        // m = n - 1\n        if (m != n - 1) {\n            m = n - 1;\n        }\n        for (int i = 1; i <= m; ++i) {\n            printf(\"%d %d\\n\", i, i+1);\n        }\n    } else if (type == \"reverse_chain\") {\n        // m = n - 1\n        if (m != n - 1) {\n            m = n - 1;\n        }\n        for (int i = n; i >= 2; --i) {\n            printf(\"%d %d\\n\", i, i-1);\n        }\n    } else if (type == \"star\") {\n        // m = n - 1\n        if (m != n - 1) {\n            m = n - 1;\n        }\n        for (int i = 2; i <= n; ++i) {\n            printf(\"%d %d\\n\", 1, i);\n        }\n    } else if (type == \"reverse_star\") {\n        // m = n - 1\n        if (m != n -1) {\n            m = n - 1;\n        }\n        for (int i = 2; i <= n; ++i) {\n            printf(\"%d %d\\n\", i, 1);\n        }\n    } else if (type == \"complete\") {\n        // For small n, output all possible pairs (ai, bi), ai != bi\n        if (n <= 500 && m >= n*(n-1)) {\n            m = n*(n-1);\n            for (int i = 1; i <= n; ++i) {\n                for (int j = 1; j <= n; ++j) {\n                    if (i != j) {\n                        printf(\"%d %d\\n\", i, j);\n                    }\n                }\n            }\n        } else {\n            // n is too big for complete type, output random distinct pairs\n            for (int i = 0; i < m; ++i) {\n                int ai, bi;\n                do {\n                    ai = rnd.next(1, n);\n                    bi = rnd.next(1, n);\n                } while (ai == bi || edges.count({ai, bi}));\n                edges.insert({ai, bi});\n                printf(\"%d %d\\n\", ai, bi);\n            }\n        }\n    } else if (type == \"random\") {\n        // Generate m random distinct pairs\n        for (int i = 0; i < m; ++i) {\n            int ai, bi;\n            do {\n                ai = rnd.next(1, n);\n                bi = rnd.next(1, n);\n            } while (ai == bi || edges.count({ai, bi}));\n            edges.insert({ai, bi});\n            printf(\"%d %d\\n\", ai, bi);\n        }\n    } else {\n        // Default to random\n        for (int i = 0; i < m; ++i) {\n            int ai, bi;\n            do {\n                ai = rnd.next(1, n);\n                bi = rnd.next(1, n);\n            } while (ai == bi || edges.count({ai, bi}));\n            edges.insert({ai, bi});\n            printf(\"%d %d\\n\", ai, bi);\n        }\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 2 -m 1 -type chain\n./gen -n 2 -m 1 -type random\n\n./gen -n 10 -m 9 -type chain\n./gen -n 10 -m 20 -type random\n./gen -n 10 -m 9 -type star\n\n./gen -n 100 -m 99 -type chain\n./gen -n 1000 -m 1000 -type random\n./gen -n 1000 -m 999 -type chain\n\n./gen -n 5000 -m 5000 -type random\n./gen -n 10000 -m 9999 -type reverse_chain\n./gen -n 10000 -m 20000 -type random\n\n./gen -n 100000 -m 100000 -type random\n./gen -n 100000 -m 99999 -type chain\n./gen -n 100000 -m 50000 -type random\n./gen -n 100000 -m 1000 -type random\n\n./gen -n 100000 -m 100000 -type star\n./gen -n 100000 -m 100000 -type reverse_star\n\n# Special small complete graph\n./gen -n 100 -m 9900 -type complete\n\n# Edge cases with minimal m\n./gen -n 100000 -m 1 -type random\n./gen -n 2 -m 1 -type random\n\n# Edge cases with maximal m\n./gen -n 100000 -m 100000 -type random\n\n# Edge case with duplicate pairs (should ensure no duplicates)\n./gen -n 10000 -m 100000 -type random\n\n# Edge case with ai always equal to a constant\n./gen -n 100000 -m 100000 -type star\n\n# Edge case with bi always equal to a constant\n./gen -n 100000 -m 100000 -type reverse_star\n\n# Edge case where m is less than n-1\n./gen -n 100000 -m 10 -type random\n\n# Edge case where n is minimal\n./gen -n 2 -m 1 -type star\n\n# Edge case with maximum n and minimum m\n./gen -n 100000 -m 1 -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:40:45.688929",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "506/C",
      "title": "C. Mr. Kitayuta vs. Bamboos",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line of the input contains four space-separated integers n, m, k and p (1 ≤ n ≤ 105, 1 ≤ m ≤ 5000, 1 ≤ k ≤ 10, 1 ≤ p ≤ 109). They represent the number of the bamboos in Mr. Kitayuta's garden, the duration of Mr. Kitayuta's fight in days, the maximum number of times that Mr. Kitayuta beat the bamboos during each day, and the power of Magic Hammer, respectively.The following n lines describe the properties of the bamboos. The i-th of them (1 ≤ i ≤ n) contains two space-separated integers hi and ai (0 ≤ hi ≤ 109, 1 ≤ ai ≤ 109), denoting the initial height and the growth rate of the i-th bamboo, respectively.",
      "output_spec": "OutputPrint the lowest possible height of the tallest bamboo after m days.",
      "sample_tests": "ExamplesInputCopy3 1 2 510 1010 1015 2OutputCopy17InputCopy2 10 10 10000000000 100 10OutputCopy10InputCopy5 3 3 109 59 24 79 103 8OutputCopy14",
      "description": "C. Mr. Kitayuta vs. Bamboos\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line of the input contains four space-separated integers n, m, k and p (1 ≤ n ≤ 105, 1 ≤ m ≤ 5000, 1 ≤ k ≤ 10, 1 ≤ p ≤ 109). They represent the number of the bamboos in Mr. Kitayuta's garden, the duration of Mr. Kitayuta's fight in days, the maximum number of times that Mr. Kitayuta beat the bamboos during each day, and the power of Magic Hammer, respectively.The following n lines describe the properties of the bamboos. The i-th of them (1 ≤ i ≤ n) contains two space-separated integers hi and ai (0 ≤ hi ≤ 109, 1 ≤ ai ≤ 109), denoting the initial height and the growth rate of the i-th bamboo, respectively.\n\nOutputPrint the lowest possible height of the tallest bamboo after m days.\n\nInputCopy3 1 2 510 1010 1015 2OutputCopy17InputCopy2 10 10 10000000000 100 10OutputCopy10InputCopy5 3 3 109 59 24 79 103 8OutputCopy14\n\nInputCopy3 1 2 510 1010 1015 2\n\nOutputCopy17\n\nInputCopy2 10 10 10000000000 100 10\n\nOutputCopy10\n\nInputCopy5 3 3 109 59 24 79 103 8\n\nOutputCopy14",
      "solutions": [
        {
          "title": "Codeforces Round #286 - Codeforces",
          "content": "Hello Codeforces!evima, yosupo and I would like you to participate in Codeforces Round #286. It will be held on Sunday, January 18th at 16:00 MSK. Please note that this round starts on unusual time.Great thanks to Zlobober who helped us prepare this round, Delinur who translated statements into Russian and MikeMirzayanov who created Codeforces and polygon.This is the 3rd time(following #162 and #263) for me, and the 1st time for evima and yosupo to prepare a Codeforces Round.Scores of the problems will be500-1000-1750-1750-2500 for Div.1, and500-1000-1500-2000-2750 for Div.2.In this round, you'll help a man named Mr. kitayuta. I hope he will participate :)The system tests are now over! The top-5 are as follows:Div.1:1.ilyakor2.kcm17003.LayCurse4.RomaWhite5.TankEngineerDiv.2:1.Konijntje2.cpcpc3.zgzjsxshycxksxhsh4.Ronnie0075.sha384Also, special congrats on Petr, who solved problem E in Div.1, which anyone else could not solve.Here are the editorials",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/15842",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 961
        },
        {
          "title": "Codeforces Round #286 Editorial (Complete) - Codeforces",
          "content": "Edit (Jan 22, 2:45 AM UTC): Added Div1E and the editorial is now complete. I am sorry for the delay.Edit (Jan 21, 9:45 AM UTC): Added the explanation for Div1C/2E, and the problem setters' codes. Div1E will need several more hours. Thank you again for your patience.First, here are some statistics on this round: Division Registrants Participants A Accepted B Accepted C Accepted D Accepted E Accepted 1 1364 572 (*) 294 199 8 113 1 (Estimated number of AC by me) 800 (wrong) 500 (wrong) 70 (FAIL) 90 (ok) 5 (wrong) 2 4016 2028 1355 945 41 5 0 (*) Where did the remaining 792 people go? :) We are sorry for terribly underestimating the difficulty of the problems (except Div1D), especially Div1A/2C and Div1C/2E. Div.2 A: 505A - Mr. Kitayuta's Gift[Problem] Given a string, turn it into a palindrome by inserting one letter or state that it is impossible.(Problem by evima)Since the string is short (at most 10 characters), you can simply try every possible way of inserting a letter (\"where\" and \"what\" to insert), and check if the resulting string is a palindrome.The writer's code (C++): 9501249Note: For some strange reason, we (contest managers) cannot submit solutions so that everyone can see them. PraveenDhinwa told us how to do so. Thank you! Div.2 B: 505B - Mr. Kitayuta's Colorful Graph[Problem] Given an undirected graph whose edges are painted in colors, process the queries of the following form: Given two vertices ui and vi, find the number of the colors that satisfies the following condition: the edges of that color connect ui and vi (possibly indirectly). (Problem by hogloid)Since neither the graph nor the number of queries is too large, for each query you can simply count the number of the \"good\" colors (the colors that satisfies the condition) by checking if each color is \"good\". To do that, you can perform Depth First Search (or Breadth First Search) and verify whether you can reach vi from ui traversing only the edges of that color. If you prefer using Union-Find, it will also do the job.The writer's code (DFS, C++)The writer's code (Union-Find, C++) Div.2 C / Div.1 A: 505C - Mr. Kitayuta, the Treasure Hunter[Problem] Since it is hard to summarize this problem, please refer to the official statement.(Problem by yosupo)Below is the explanation from yosupo, translated by me.[From here]Let m be the number of the islands (that is, 30001). First, let us describe a solution with time and memory complexity of O(m2).We will apply Dynamic Programming. let dp[i][j] be the number of the gems that Mr. Kitayuta can collect after he jumps to island i, when the length of his previous jump is j (let us assume that he have not collect the gems on island i). Then, you can calculate the values of the table dp by the following: dp[i][j] = 0, if i ≥ m(actually these islands do not exist, but we can suppose that they exist and when Mr. Kitayuta jumps to these islands, he stops jumping) dp[i][j] =  (the number of the gems on island i)  + max(dp[i + j][j], dp[i + j + 1][j + 1]), if i < m, j = 1(he cannot perform a jump of length 0) dp[i][j] =  (the number of the gems on island i)  + max(dp[i + j - 1][j - 1], dp[i + j][j], dp[i + j + 1][j + 1]), if i < m, j ≥ 2 This solution is unfeasible in terms of both time and memory. However, the following observation makes it an Accepted solution: there are only 491 values of j that we have to consider, which are d - 245, d - 244, d - 243, ..., d + 244 and d + 245.Why? First, let us find the upper bound of j. Suppose Mr. Kitayuta always performs the \"l + 1\" jump (l: the length of the previous jump). Then, he will reach the end of the islands before he performs a jump of length d + 246, becaused + (d + 1) + (d + 2) + ... + (d + 245) ≥ 1 + 2 + ... + 245 = 245·(245 + 1) / 2 = 30135 > 30000. Thus, he will never be able to perform a jump of length d + 246 or longer.Next, let us consider the lower bound of j in a similar way. If d ≤ 246, then obviously he will not be able to perform a jump of length d - 246 or shorter, because the length of a jump must be positive. Suppose Mr. Kitayuta always performs the \"l - 1\" jump, where d ≥ 247. Then, again he will reach the end of the islands before he performs a jump of length d - 246, becaused + (d - 1) + (d - 2) + ... + (d - 245) ≥ 245 + 244 + ... + 1 = 245·(245 + 1) / 2 = 30135 > 30000. Thus, he will never be able to perform a jump of length d - 246 or shorter.Therefore, we have obtained a working solution: similar to the O(m2) one, but we will only consider the value of j between d - 245 and d + 245. The time and memory complexity of this solution will be O(m1.5), since the value \"245\" is slightly larger than .This solution can be implemented by, for example, using a \"normal\" two dimensional array with a offset like this: dp[i][j - offset]. The time limit is set tight in order to fail most of naive solutions with search using std::map or something, so using hash maps (unordered_map) will be risky although the complexity will be the same as the described solution.[End]The writer's code (memoized recursion, C++) Div.2 D / Div.1 B: 505D - Mr. Kitayuta's Technology[Problem] Given an integer n and m pairs of integers (ai, bi) (1 ≤ ai, bi ≤ n), find the minimum number of edges in a directed graph that satisfies the following condition: For each i, there exists a path from vertex ai to vertex bi. (Problem from evima)Let G1 be the directed graph built from the input, and G2 be a directed graph that satisfies the given conditions. What we seek is the minimum number of edges in G2. Also, we say that two vertices u and v in a directed graph are \"weakly connected\" if we can reach v from u by traversing edges, not considering their directions.If a pair (u, v) is present in the input, then vertices u and v must be weakly connected in G2. Therefore, for each weakly connected component (abbreviated to wcc) in G1, the vertices in that component must also be in the same wcc in G2. We can \"merge\" multiple wccs in G1 and create a larger wcc in G2, but for now, let us find the minimum number of edges required in G2 for each wcc in G1 when we do not \"merge\" them. There are two cases to consider: If a wcc in G1 does not have cycles, then we can perform topological sort on that wcc, and we can make a \"chain\" (see the image below) using the topological order to satisfy the conditions. We need (the number of the vertices in the wcc)  - 1 edges, which is the minimum required number since any connected graph with V vertices has at least V - 1 edges. If a wcc in G1 has cycles, then topological sort cannot be applied. We need at least (the number of the vertices in the wcc) edges this time, since any connected graph with V vertices and V - 1 edges is a tree, which does not contain cycles. Actually, this number (the number of the vertices in the wcc) is always achievable by connecting the vertices into a \"ring\" (see the image below), thus it is the minimum required number that we seek. We have found the minimum required number of edges for each wcc in G1 when we do not \"merge\" them. Let us show that \"merging\" wccs in G1 do not reduce the number of required edges. Suppose we combine k( > 1) wccs C1, C2, ..., Ck in G1 into one wcc C in G2. Again, there are two cases to consider: If none of C1, C2, ..., Ck contains cycles, then C will need |C1| + |C2| + ... + |Ck| - 1 edges. However, if we do not combine them, we will only need (|C1| - 1) + (|C2| - 1) + ... + (|Ck| - 1) edges in total, which is fewer. If some of C1, C2, ..., Ck contain cycles, then C will need |C1| + |C2| + ... + |Ck| edges. However, if we do not combine them, we will need(|C1| - noCycles(C1)) + (|C2| - noCycles(C2)) + ... + (|Ck| - noCycles(Ck)  ≤ |C1| + |C2| + ... + |Ck| edges(here, noCycles(Ci) is 1 if Ci do not contain cycles, otherwise 0), thus combining them does not reduce the number of required edges. Thus, we do not need to combine multiple wccs into one wcc in G2 in order to obtain the optimal solution. That is, the final answer to the problem is the sum of the minimum required number of edges for each wcc in G1, when they are considered separately.As for the implementation, detecting cycles in a directed graph with 105 vertices and edges might be a problem if this is your first encounter with it. One possible way is to paste a code that decomposes a graph into strongly connected components. If the size of a strongly connected component is more than one, then that means the component contains cycles.The writer's code (strongly connected component decomposition, C++): 9501202 Div.2 E / Div.1 C: 505E - Mr. Kitayuta vs. Bamboos[Problem] Since it is hard to summarize this problem, please refer to the official statement.(Problem from yosupo)Below is the explanation from yosupo, translated by me.[From here]Let us begin by applying Binary Search. The problem becomes: \"is it possible that all the bamboos are at most X meters after m days?\" It is complicated by the fact that the height does not become negative; the excessive decrease will be wasted. We have found two approaches to this problem. Solution 1 Mr. Kitayuta must beat the i-th bamboo at least max(0, ⌈(hi + m·ai - X) / P⌉) times (let this number ti). Actually, it is not necessary for him to beat it more than this number of times. Thus, let us assume that he beat the i-th bamboo exactly ti times. Also, for each j (1 ≤ j ≤ ti), find the day di, j such that, if the j-th beat on the i-th bamboo is performed before day di, it will be no longer possible to keep the i-th bamboo's height after m days at most X (it can be found by doing simple math). If Mr. Kitayuta can beat the bamboos under this constraint, all the bamboos' heights will become X meters or less after m days. Otherwise, some bamboos' heights will exceed X meters.The time complexity of this solution will be , if we first calculate only ti, then if the sum of ti exceeds km, we skip finding di, j (the answer is \"NO\"). Solution 2 This problem becomes simpler if we simulate Mr. Kitayuta's fight backwards, that is, from day m to day 1. It looks like this:[Problem'] There are n bamboos. At the moment, the height of the i-th bamboo is X meters, and it shrinks ai meters at the beginning of each day. Mr. Kitayuta will play a game. He can use Magic Hammer at most k times per day to increase the height of a bamboo by p meters. If some bamboo's height becomes negative at any moment, he will lose the game immediately. Also, in order for him to win the game, the i-th bamboo's height must be at least hi meters after m days. Is victory possible?Below is an illustration of this \"reverse simulation\": This version is simpler because he is increasing the heights instead of decreasing, thus we do not need to take into account the \"excessive decrease beyond 0 meters\" which will be wasted. Let us consider an optimal strategy. If there exist bamboos whose heights would become negative after day m, he should beat the one that is the earliest to make him lose. Otherwise, he can choose any bamboo whose height would be less than hi meters after day m. Repeat beating the bamboos following this strategy, and see if he can actually claim victory.The writer's implementation of this solution uses a priority queue, and its time complexity is .[End]The tester's code (Solution 1, C++): 9501229The writer's code (Solution 2, C++) Div.1 D: 506D - Mr. Kitayuta's Colorful Graph[Problem] Given an undirected graph whose edges are painted in colors, process the queries of the following form: Given two vertices ui and vi, find the number of the colors that satisfies the following condition: the edges of that color connect ui and vi (possibly indirectly). Note: this is the exact same problem as Div.2 B except the constraints, which are 105 instead of 100.(Problem from hogloid)Below is the explanation from hogloid.[From here]For each color, make a new graph that consists of the edges of the color and vertices connected by the edges. Make UnionFind for each graph, and you can check whether a color connects vertex A and B , using it. For each query, find a vertex which has smaller degree(let this vertex A, and the other vertex B) For each colors such that a edge of the color connects to A, check whether A and B is connected by the color. After answering the query, memorize its tuple — (A, B, answer). If the same query is requested, answer using this information.This will lead to solution.For each query, the complexity is (For each color connects A, find a vertex of B of the color & check whether they are connected) The queries that require longest computing time are, to ask every pair among vertices which have largest degrees. Let the indices of the vertices be , and degrees of the vertices be d1, d2, ...dk. Now, let's fix vertex B as i. The total computing time of the queries such that B is vertex i is . Vertex B can vary from 2 to k. Hence, the total complexity is at most . This complexity is at most .By the way, in C++, using unordered_map, total complexity would be .[End]There will be many other solutions. I will briefly explain one of them which I think is typical.Let ci be the number of colors of the edges incident to vertex i. The sum of all ci does not exceed 2m since each edge increases this sum by at most 2. Thus, there will be at most 450 values of i such that ci ≥ 450 (let B = 450). We will call these vertices large, and the remaining ones small. Using O(m / B·m) = O(m2 / B) time and memory, we can precalculate and store the answer for all the possible queries where at least one of ui and vi is large, then we can immediately answer these queries. For the remaining queries, both ui and vi will be small, therefore it is enough to directly count the color that connects vertices ui and vi in O(B) time. The total time required will be O(m2 / B + Bq). If we choose , we can solve the problem in time.The writer's code (the first solution, C++)The tester's code (the second solution, C++): 9501240 Div.1 E: 506E - Mr. Kitayuta's Gift[Problem] Given a string s and an integer n, find the number of the palindromes that can be obtained by inserting exactly n letters into s.Note: Div.2 A is a similar problem, where n is fixed to 1.(Problem from evima)First of all, let us note that we are asked to count the resulting palindromes, not the ways to obtain them. For example, if we are to insert \"b\" into \"abba\", there are 5 possible positions, but only 3 strings will be produced (\"babba\", \"abbba\" and \"abbab\"). Rather than trying to count the ways of inserting a letter n times and removing the duplicated results, we should directly count the resulting palindrome. To do that, let us reformulate the problem:[Problem'] Given a string s and an integer n, find the number of the palindromes of length |s| + n (let this number be N) that contains s as a subsequence (not necessarily contiguous).Consider constructing a palindrome from both ends, and matching it to s from both left and right. For example, let s = \"abaac\" and N = 11. Let us call the final resulting string t. We first decide what letter to use as t1 and t11 (they must be equal in order for t to be a palindrome). Let us say 'c' is chosen. Now, we have to construct the remaining part of t, that is, t2..t10, so that t2..t10 contains \"abaa\" as a substring (note that the 'c' at the end of s is discarded). Again, we decide what letter to use as t2 and t10. This time we choose 'a'. Then, we have to construct t3..t9, so that it contains \"ba\" as a substring (this time the two 'a's at the both ends of s are discarded). We choose t3 = t9 = 'c'. Next, we construct t4..t8, so that it contains \"ba\" as a substring (this time s remains unchanged). We choose t4 = t8 = 'b'. Then, we construct t5..t7, so that it contains \"a\" as a substring. We choose t5 = t7 = 'a' (it is becoming repetitive, isn't it?). The last part of t, that is, t6, has no restriction (this time we choose a letter for only one position of t, not two). We choose 'd', and we have obtained a palindrome \"cacbadabcac\" that contains s = \"abaac\" as a subsequence.This problem is mostly about analyzing this process carefully.The most naive solution other than literally enumerating all palindromes of length N would be the following Dynamic Programming: let dp[i][left][right] be the number of the palindromes t that can be obtained if you have already decided the leftmost and the rightmost i letters (2i in total), and the substring sleftsleft + 1..sright of s remains unmatched. Each value in this table can be computed in O(1) time. Of course, since i can be up to ⌊n / 2⌋ (n ≤ 109), this solution is far from our goal.Notice that the transitions from dp[i] to dp[i + 1] are the same regardless of i, thus we can calculate the table by matrix exponentiation. However, since there are O(|s|2) possible pairs for (left, right), we will need time, which is actually worse than the naive calculation considering that |s| can be up to 200.This is where we need to observe the process which we have gone through at the beginning more carefully. Let us build a automaton corresponding to the process (the image below). (*) An self-loop with a number means that there are actually that number of edges.A process of producing a palindrome of length N that contains s as a subsequence corresponds to a path of length ⌈N / 2⌉ from the upper-right vertex to the lower-left vertex. Each red vertex has 24 self-loops since the letters at the both ends of the remaining part of s is different, which correspond to two non-self-loop transitions. Similarly, each green vertex has 25 self-loops since the first letter and the last letter of the remaining string is the same, and the blue vertex, the destination, has 26 self-loops, as there are no more non-self-loop transitions available.Here is an important fact: there are not so many possible combination of (n24, n25), where n24 and n25 are the number of times a path from START to GOAL visits a red vertex (with 24 self-loops) and a green vertex (with 25 self-loops), respectively. Why? Each time we leave a red vertex, the length of the remaining unmatched part of s decreases by 1, since exactly one of the two letters at the ends of the remaining part is matched and discarded. Similarly, each time we leave a green vertex, the length of the remaining string decreases by 2, since both of the two letters at the ends are matched and discarded. There is a exception, however: if the length of the remaining string is 1, then it will be a green vertex, but in this case the length will decrease by 1. Thus, for any path from START to GOAL, n24 + 2·n25 will be equal to either |s| or |s| + 1. If we fix n24, then n25 will be uniquely determined by n25 = ⌈(|s| - n24) / 2⌉. Since n24 can only take the value between 0 and |s| - 1, there are at most |s| possible pairs of (n24, n25).With this fact, we are ready to count the paths: let us classify them by the value of n24. For each possible pair of (n24, n25), let us count the number of corresponding paths. To do that, we divide each paths into two parts: first we count the number of paths from START to GOAL, using only non-self-loop transitions. Then, we count the ways of inserting self-loop transitions into each of these paths. The product of these two numbers will be the number that we seek.The first part is straightforward to solve: let dp[left][right][n24] be the number of paths from the vertex that corresponds to the substring sleftsleft + 1..sright, visiting exactly n24 red vertices using only non-self-loop transitions. Each value of the table can be found in O(1) time, thus the whole table can be computed in O(|s|3) time, which is fast enough for the input size (|s| ≤ 200).The main obstacle will be the second part. For example, let us consider the case where s = \"abaac\", N = 11, n24 = 2, which corresponds to the example at the beginning. From the fact we found earlier, n25 = ⌈(|s| - n24) / 2⌉ = ⌈(5 - 2) / 2⌉ = 2. Thus, we have to insert ⌈N / 2⌉ - n24 - n25 = 6 - 2 - 2 = 2 self-loop transitions into this path (the image): The order in which red, green and blue vertices appears in this path does not affect the number of ways of insertion, and can be arbitrary. The number of ways to insert 2 self-loop transitions will be equal to the number of the path of length ⌈N / 2⌉ = 6 from START to GOAL in this automaton (we have to take into account the non-self-loop transitions in it), which can be calculated by matrix exponentiation.Are we done? No! Consider the case s = \"abbb..(|s| - 1 times)..bb\". There are |s| - 1 possible values of n24 (n24 = 1 corresponds to the case where you match and discard the 'a' first, and n24 = |s| - 1 corresponds to the case where you keep the 'a' until s becomes \"ab\"). Thus, you need to perform matrix exponentiation |s| - 1 times, which results in a total of time, which will be too much under the given constraints.There is still hope, though, and here is the climax. Notice that these automata are very similar to each other, and they differ only in the number of the red and green vertices. We can combine these automata into one larger automaton like this (the image): The combined automaton should have |s| - 1 red, ⌈|s| / 2⌉ green and ⌈|s| / 2⌉ blue vertices.By performing matrix exponentiation on this automaton instead of many small automata, we can find all the required value in time, which should be enough. We recommend speeding up matrix multiplication by noticing that the matrix will be upper triangular (6 times faster on paper), since the time limit is not so generous (in order to reject solutions).The problem is almost solved, but there is one more challenge. When N is odd, the situation becomes a little complicated: as we have seen at the beginning, in the last (⌈N / 2⌉-th) step of producing a palindrome we choose a letter for only one position of the resulting string, that is, the center of that string. In other words, the last transition in the path in the automaton we have first built must not be one from a green vertex with a string of length 2 (for example, \"aa\") to GOAL.Let us find the number of the paths that violates this condition and subtract it from the answer. As previously mentioned, for each path n24 + 2·n25 will be equal to either |s| or |s| + 1, and if we fix the value of n24, n25 will be uniquely determined by n25 = ⌈(|s| - n24) / 2⌉. If |s| - n24 is odd, then it means that the last non-self-loop transition is one from a green vertex with a string of length 1, therefore in this case no path will violate the condition. If |s| - n24 is even, then the last non-self-loop trantision is from a green vertex with a string of length 2, thus the paths that does not contain the self-loop from GOAL to itself violate the condition. It will be equal to the number of the paths of length ⌈N / 2⌉ - 1 from START to the vertex just before GOAL, which can be found in a similar way to the second part of the solution.The journey has finally come to an end. Actually, it is also possible to solve this problem in time without matrix exponentiation, but this margin is too small to explain it. I will just paste the link to the code.The writer's code (matrix exponentiation, C++): 9501164The writer's code (without matrix exponentiation, C++): 9501177Congratulations again to Petr who was the only participant to solve this problem in 108 minutes. Also, I would like to give a special mention to rng_58, who was VERY close to solving it in only 63 minutes. He was just one byte away from getting AC (compare 9460984 and 9465440)! If you find a possible error, or have a question, please feel free to ask here. Alternative solutions are also welcome.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/15889",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.6,
            "reason": "宽松匹配: 包含题目编号 506 和字母"
          },
          "content_length": 23595
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #286 - Codeforces - Code 1",
          "code": "This is the 3rd time(following #162 and #263) for me",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #286 - Codeforces - Code 2",
          "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N = 1e2 + 5;\n\nint parent[N][N];\n\nint find(int c, int v) {\n    if (parent[c][v] == -1)\n        return v;\n    return parent[c][v] = find(c, parent[c][v]);\n}\n\nvoid unite(int c, int u, int v) {\n    parent[c][find(c, u)] = find(c, v);\n}\n\nint main() {\n    memset(parent, -1, sizeof parent);\n    int n, m;\n    cin >> n >> m;\n    for (int i = 0; i < m; ++i) {\n        int a, b, c;\n        cin >> a >> b >> c;\n        unite(c, a, b);\n    }\n    int q;\n    cin >> q;\n    while (q--) {\n        int u, v, ans = 0;\n        cin >> u >> v;\n        for (int i = 1; i <= 100; ++i)\n            if (find(i, u) == find(i, v))\n                ++ans;\n        cout << ans << '\\n';\n    }\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/15842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #286 - Codeforces - Code 3",
          "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N = 1e2 + 5;\n\nint parent[N][N];\n\nint find(int c, int v) {\n    if (parent[c][v] == -1)\n        return v;\n    return parent[c][v] = find(c, parent[c][v]);\n}\n\nvoid unite(int c, int u, int v) {\n    parent[c][find(c, u)] = find(c, v);\n}\n\nint main() {\n    memset(parent, -1, sizeof parent);\n    int n, m;\n    cin >> n >> m;\n    for (int i = 0; i < m; ++i) {\n        int a, b, c;\n        cin >> a >> b >> c;\n        unite(c, a, b);\n    }\n    int q;\n    cin >> q;\n    while (q--) {\n        int u, v, ans = 0;\n        cin >> u >> v;\n        for (int i = 1; i <= 100; ++i)\n            if (find(i, u) == find(i, v))\n                ++ans;\n        cout << ans << '\\n';\n    }\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/15842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #286 - Codeforces - Code 4",
          "code": "Runtime Error",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #286 - Codeforces - Code 5",
          "code": "Memory Limit Exceeded",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #286 - Codeforces - Code 6",
          "code": "7 8\n1 2\n1 3\n2 4\n3 4\n4 5\n4 6\n5 7\n6 7",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #286 - Codeforces - Code 7",
          "code": "7 8\n1 2\n1 3\n2 4\n3 4\n4 5\n4 6\n5 7\n6 7",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #286 - Codeforces - Code 8",
          "code": "Test: #12 ... verdict: WRONG_ANSWER\nInput\n1 30000\n30000\nOutput\n0\nAnswer\n1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #286 - Codeforces - Code 9",
          "code": "Test: #12 ... verdict: WRONG_ANSWER\nInput\n1 30000\n30000\nOutput\n0\nAnswer\n1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #286 - Codeforces - Code 10",
          "code": "unordered_map",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #286 - Codeforces - Code 11",
          "code": "res += (pars[c][u] == pars[c][v]);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #286 - Codeforces - Code 12",
          "code": "res += (pars[c][u] == pars[c][v]);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #286 - Codeforces - Code 13",
          "code": "if (pars[c].find(v) != pars[c].end() && pars[c][u] == pars[c][v]) {\n    res++;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #286 - Codeforces - Code 14",
          "code": "if (pars[c].find(v) != pars[c].end() && pars[c][u] == pars[c][v]) {\n    res++;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #286 Editorial (Complete) - Codeforces - Code 1",
          "code": "dp[i][j - offset]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15889",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #286 Editorial (Complete) - Codeforces - Code 2",
          "code": "components[x] & components[y]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15889",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #286 Editorial (Complete) - Codeforces - Code 3",
          "code": "7 8\n1 2\n2 3\n3 4\n4 1\n4 7\n7 6\n6 5\n5 2\n\nAuthor's Code on my Pc returns 7",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15889",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #286 Editorial (Complete) - Codeforces - Code 4",
          "code": "7 8\n1 2\n2 3\n3 4\n4 1\n4 7\n7 6\n6 5\n5 2\n\nAuthor's Code on my Pc returns 7",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15889",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #286 Editorial (Complete) - Codeforces - Code 5",
          "code": "Also, for each j (1 ≤ j ≤ ti), find the day di, j such that, if the j-th beat on the i-th bamboo is performed before day di, it will be no longer possible to keep the i-th bamboo's height after m days at most X (it can be found by doing simple math).",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15889",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #286 Editorial (Complete) - Codeforces - Code 6",
          "code": "if(target - h[i] <= 0){\n\tt[0]++;\n}else if(target - h[i] > a[i] * (m-1)){\n\tok = 0;\n\tgoto end;\n}else{\n\tt[(target - h[i] + a[i] - 1) / a[i]]++;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15889",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #286 Editorial (Complete) - Codeforces - Code 7",
          "code": "if(target - h[i] <= 0){\n\tt[0]++;\n}else if(target - h[i] > a[i] * (m-1)){\n\tok = 0;\n\tgoto end;\n}else{\n\tt[(target - h[i] + a[i] - 1) / a[i]]++;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15889",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #286 Editorial (Complete) - Codeforces - Code 8",
          "code": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\n#define pb push_back\n#define __addEdge(u, v) [u].push_back(v)\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<vi> vmi;\n\nint n, m;\nvmi G[111];\nvb mark;\n\nvoid dfs(vmi &SG, int u)\n{\n    mark[u] = true;\n    for (int i = 0; i < SG[u].size(); ++i)\n    {\n        int v = SG[u][i];\n        if (!mark[v])\n            dfs(SG, v);\n    }\n}\n\nint main()\n{\n    cin >> n >> m;\n\n    fill(G, G + 111, vmi(n + 1));\n    mark.assign(n + 1, false);\n    for (int i = 0; i < m; ++i)\n    {\n        int u, v, c;\n        cin >> u >> v >> c;\n        G[c]__addEdge(u, v);\n        G[c]__addEdge(v, u);\n    }\n\n    int q;\n    cin >> q;\n\n    while (q--)\n    {\n        int u, v;\n        cin >> u >> v;\n\n        int cnt = 0;\n        for (int k = 1; k <= 100; ++k)\n        {\n            fill(mark.begin(), mark.end(), false);\n            dfs(G[k], u);\n            cnt += mark[v];\n        }\n\n        cout << cnt << endl;\n    }   \n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/15889",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #286 Editorial (Complete) - Codeforces - Code 9",
          "code": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\n#define pb push_back\n#define __addEdge(u, v) [u].push_back(v)\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<vi> vmi;\n\nint n, m;\nvmi G[111];\nvb mark;\n\nvoid dfs(vmi &SG, int u)\n{\n    mark[u] = true;\n    for (int i = 0; i < SG[u].size(); ++i)\n    {\n        int v = SG[u][i];\n        if (!mark[v])\n            dfs(SG, v);\n    }\n}\n\nint main()\n{\n    cin >> n >> m;\n\n    fill(G, G + 111, vmi(n + 1));\n    mark.assign(n + 1, false);\n    for (int i = 0; i < m; ++i)\n    {\n        int u, v, c;\n        cin >> u >> v >> c;\n        G[c]__addEdge(u, v);\n        G[c]__addEdge(v, u);\n    }\n\n    int q;\n    cin >> q;\n\n    while (q--)\n    {\n        int u, v;\n        cin >> u >> v;\n\n        int cnt = 0;\n        for (int k = 1; k <= 100; ++k)\n        {\n            fill(mark.begin(), mark.end(), false);\n            dfs(G[k], u);\n            cnt += mark[v];\n        }\n\n        cout << cnt << endl;\n    }   \n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/15889",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100000); // n, number of bamboos\n    inf.readSpace();\n    int m = inf.readInt(1, 5000); // m, number of days\n    inf.readSpace();\n    int k = inf.readInt(1, 10); // k, maximum number of times\n    inf.readSpace();\n    int p = inf.readInt(1, 1000000000); // p, power of Magic Hammer\n    inf.readEoln();\n\n    for (int i = 0; i < n; ++i) {\n        int hi = inf.readInt(0, 1000000000);\n        inf.readSpace();\n        int ai = inf.readInt(1, 1000000000);\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100000); // n, number of bamboos\n    inf.readSpace();\n    int m = inf.readInt(1, 5000); // m, number of days\n    inf.readSpace();\n    int k = inf.readInt(1, 10); // k, maximum number of times\n    inf.readSpace();\n    int p = inf.readInt(1, 1000000000); // p, power of Magic Hammer\n    inf.readEoln();\n\n    for (int i = 0; i < n; ++i) {\n        int hi = inf.readInt(0, 1000000000);\n        inf.readSpace();\n        int ai = inf.readInt(1, 1000000000);\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100000); // n, number of bamboos\n    inf.readSpace();\n    int m = inf.readInt(1, 5000); // m, number of days\n    inf.readSpace();\n    int k = inf.readInt(1, 10); // k, maximum number of times\n    inf.readSpace();\n    int p = inf.readInt(1, 1000000000); // p, power of Magic Hammer\n    inf.readEoln();\n\n    for (int i = 0; i < n; ++i) {\n        int hi = inf.readInt(0, 1000000000);\n        inf.readSpace();\n        int ai = inf.readInt(1, 1000000000);\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    int k = opt<int>(\"k\");\n    int p = opt<int>(\"p\");\n    string type = opt<string>(\"type\", \"random\");\n\n    if (n < 1 || n > 100000) {\n        fprintf(stderr, \"Error: n must be between 1 and 100000 inclusive.\\n\");\n        exit(1);\n    }\n    if (m < 1 || m > 5000) {\n        fprintf(stderr, \"Error: m must be between 1 and 5000 inclusive.\\n\");\n        exit(1);\n    }\n    if (k < 1 || k > 10) {\n        fprintf(stderr, \"Error: k must be between 1 and 10 inclusive.\\n\");\n        exit(1);\n    }\n    if (p < 1 || p > 1000000000) {\n        fprintf(stderr, \"Error: p must be between 1 and 1e9 inclusive.\\n\");\n        exit(1);\n    }\n\n    vector<int> h(n);\n    vector<int> a(n);\n\n    if (type == \"random\") {\n        // Generate random h_i and a_i\n        for (int i = 0; i < n; ++i) {\n            h[i] = rnd.next(0, 1000000000);\n            a[i] = rnd.next(1, 1000000000);\n        }\n    } else if (type == \"h_zero\") {\n        for (int i = 0; i < n; ++i) {\n            h[i] = 0;\n            a[i] = rnd.next(1, 1000000000);\n        }\n    } else if (type == \"h_max\") {\n        for (int i = 0; i < n; ++i) {\n            h[i] = 1000000000;\n            a[i] = rnd.next(1, 1000000000);\n        }\n    } else if (type == \"a_one\") {\n        for (int i = 0; i < n; ++i) {\n            h[i] = rnd.next(0, 1000000000);\n            a[i] = 1;\n        }\n    } else if (type == \"a_max\") {\n        for (int i = 0; i < n; ++i) {\n            h[i] = rnd.next(0, 1000000000);\n            a[i] = 1000000000;\n        }\n    } else if (type == \"max_parameters\") {\n        for (int i = 0; i < n; ++i) {\n            h[i] = 1000000000;\n            a[i] = 1000000000;\n        }\n    } else if (type == \"min_parameters\") {\n        for (int i = 0; i < n; ++i) {\n            h[i] = 0;\n            a[i] = 1;\n        }\n    } else if (type == \"special_case\") {\n        // Create bamboos with alternating high initial height and low growth rate, and vice versa\n        for (int i = 0; i < n; ++i) {\n            if (i % 2 == 0) {\n                h[i] = 1000000000 - rnd.next(0, 10); // High h_i\n                a[i] = rnd.next(1, 10); // Low a_i\n            } else {\n                h[i] = rnd.next(0, 10); // Low h_i\n                a[i] = 1000000000 - rnd.next(0, 10); // High a_i\n            }\n        }\n    } else {\n        fprintf(stderr, \"Unknown type: %s\\n\", type.c_str());\n        exit(1);\n    }\n\n    // Shuffle the order of the bamboos\n    vector<int> indices(n);\n    for(int i = 0; i < n; ++i)\n        indices[i] = i;\n    shuffle(indices.begin(), indices.end());\n\n    // Output n, m, k, p\n    printf(\"%d %d %d %d\\n\", n, m, k, p);\n    for(int idx = 0; idx < n; ++idx) {\n        int i = indices[idx];\n        printf(\"%d %d\\n\", h[i], a[i]);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    int k = opt<int>(\"k\");\n    int p = opt<int>(\"p\");\n    string type = opt<string>(\"type\", \"random\");\n\n    if (n < 1 || n > 100000) {\n        fprintf(stderr, \"Error: n must be between 1 and 100000 inclusive.\\n\");\n        exit(1);\n    }\n    if (m < 1 || m > 5000) {\n        fprintf(stderr, \"Error: m must be between 1 and 5000 inclusive.\\n\");\n        exit(1);\n    }\n    if (k < 1 || k > 10) {\n        fprintf(stderr, \"Error: k must be between 1 and 10 inclusive.\\n\");\n        exit(1);\n    }\n    if (p < 1 || p > 1000000000) {\n        fprintf(stderr, \"Error: p must be between 1 and 1e9 inclusive.\\n\");\n        exit(1);\n    }\n\n    vector<int> h(n);\n    vector<int> a(n);\n\n    if (type == \"random\") {\n        // Generate random h_i and a_i\n        for (int i = 0; i < n; ++i) {\n            h[i] = rnd.next(0, 1000000000);\n            a[i] = rnd.next(1, 1000000000);\n        }\n    } else if (type == \"h_zero\") {\n        for (int i = 0; i < n; ++i) {\n            h[i] = 0;\n            a[i] = rnd.next(1, 1000000000);\n        }\n    } else if (type == \"h_max\") {\n        for (int i = 0; i < n; ++i) {\n            h[i] = 1000000000;\n            a[i] = rnd.next(1, 1000000000);\n        }\n    } else if (type == \"a_one\") {\n        for (int i = 0; i < n; ++i) {\n            h[i] = rnd.next(0, 1000000000);\n            a[i] = 1;\n        }\n    } else if (type == \"a_max\") {\n        for (int i = 0; i < n; ++i) {\n            h[i] = rnd.next(0, 1000000000);\n            a[i] = 1000000000;\n        }\n    } else if (type == \"max_parameters\") {\n        for (int i = 0; i < n; ++i) {\n            h[i] = 1000000000;\n            a[i] = 1000000000;\n        }\n    } else if (type == \"min_parameters\") {\n        for (int i = 0; i < n; ++i) {\n            h[i] = 0;\n            a[i] = 1;\n        }\n    } else if (type == \"special_case\") {\n        // Create bamboos with alternating high initial height and low growth rate, and vice versa\n        for (int i = 0; i < n; ++i) {\n            if (i % 2 == 0) {\n                h[i] = 1000000000 - rnd.next(0, 10); // High h_i\n                a[i] = rnd.next(1, 10); // Low a_i\n            } else {\n                h[i] = rnd.next(0, 10); // Low h_i\n                a[i] = 1000000000 - rnd.next(0, 10); // High a_i\n            }\n        }\n    } else {\n        fprintf(stderr, \"Unknown type: %s\\n\", type.c_str());\n        exit(1);\n    }\n\n    // Shuffle the order of the bamboos\n    vector<int> indices(n);\n    for(int i = 0; i < n; ++i)\n        indices[i] = i;\n    shuffle(indices.begin(), indices.end());\n\n    // Output n, m, k, p\n    printf(\"%d %d %d %d\\n\", n, m, k, p);\n    for(int idx = 0; idx < n; ++idx) {\n        int i = indices[idx];\n        printf(\"%d %d\\n\", h[i], a[i]);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 10 -m 1 -k 1 -p 1 -type min_parameters\n./gen -n 100000 -m 5000 -k 10 -p 1000000000 -type max_parameters\n./gen -n 100000 -m 5000 -k 10 -p 1000000000 -type random\n./gen -n 1 -m 1 -k 1 -p 1 -type random\n./gen -n 1 -m 5000 -k 10 -p 1000000000 -type random\n./gen -n 50000 -m 2500 -k 5 -p 500000000 -type h_zero\n./gen -n 50000 -m 2500 -k 5 -p 500000000 -type h_max\n./gen -n 100000 -m 5000 -k 1 -p 1 -type a_max\n./gen -n 100000 -m 5000 -k 10 -p 1 -type a_one\n./gen -n 100000 -m 1 -k 10 -p 1000000000 -type random\n./gen -n 100 -m 100 -k 10 -p 1000000000 -type special_case\n./gen -n 100000 -m 5000 -k 5 -p 500000000 -type special_case\n./gen -n 100000 -m 5000 -k 10 -p 1 -type special_case\n./gen -n 100000 -m 1 -k 1 -p 1000000000 -type special_case\n./gen -n 100000 -m 5000 -k 10 -p 1000000000 -type h_zero\n./gen -n 100 -m 5000 -k 10 -p 1000000000 -type h_zero\n./gen -n 100000 -m 5000 -k 10 -p 1000000000 -type h_max\n./gen -n 10 -m 1 -k 1 -p 1 -type min_parameters\n./gen -n 10 -m 10 -k 1 -p 1 -type min_parameters\n./gen -n 100000 -m 1 -k 10 -p 1000000000 -type special_case\n./gen -n 5 -m 3 -k 3 -p 10 -type random\n./gen -n 3 -m 1 -k 2 -p 5 -type random\n./gen -n 75000 -m 2500 -k 5 -p 250000000 -type random\n./gen -n 100000 -m 5000 -k 10 -p 1000000000 -type a_max\n./gen -n 100000 -m 5000 -k 1 -p 1000000000 -type h_zero\n./gen -n 100000 -m 5000 -k 1 -p 1 -type h_max\n./gen -n 50000 -m 2500 -k 5 -p 500000000 -type a_one\n./gen -n 50000 -m 2500 -k 5 -p 500000000 -type a_max\n./gen -n 100000 -m 5000 -k 1 -p 1000000000 -type special_case\n./gen -n 100000 -m 5000 -k 10 -p 1000000000 -type special_case\n./gen -n 100 -m 100 -k 10 -p 1 -type random\n./gen -n 100000 -m 5000 -k 5 -p 1000000000 -type special_case\n./gen -n 100000 -m 5000 -k 1 -p 1 -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:40:47.838170",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "506/D",
      "title": "D. Mr. Kitayuta's Colorful Graph",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test4 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line of the input contains space-separated two integers - n and m(2 ≤ n ≤ 105, 1 ≤ m ≤ 105), denoting the number of the vertices and the number of the edges, respectively.The next m lines contain space-separated three integers - ai, bi(1 ≤ ai < bi ≤ n) and ci(1 ≤ ci ≤ m). Note that there can be multiple edges between two vertices. However, there are no multiple edges of the same color between two vertices, that is, if i ≠ j, (ai, bi, ci) ≠ (aj, bj, cj).The next line contains a integer- q(1 ≤ q ≤ 105), denoting the number of the queries.Then follows q lines, containing space-separated two integers - ui and vi(1 ≤ ui, vi ≤ n). It is guaranteed that ui ≠ vi.",
      "output_spec": "OutputFor each query, print the answer in a separate line.",
      "sample_tests": "ExamplesInputCopy4 51 2 11 2 22 3 12 3 32 4 331 23 41 4OutputCopy210InputCopy5 71 5 12 5 13 5 14 5 11 2 22 3 23 4 251 55 12 51 51 4OutputCopy11112",
      "description": "D. Mr. Kitayuta's Colorful Graph\n\ntime limit per test4 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line of the input contains space-separated two integers - n and m(2 ≤ n ≤ 105, 1 ≤ m ≤ 105), denoting the number of the vertices and the number of the edges, respectively.The next m lines contain space-separated three integers - ai, bi(1 ≤ ai < bi ≤ n) and ci(1 ≤ ci ≤ m). Note that there can be multiple edges between two vertices. However, there are no multiple edges of the same color between two vertices, that is, if i ≠ j, (ai, bi, ci) ≠ (aj, bj, cj).The next line contains a integer- q(1 ≤ q ≤ 105), denoting the number of the queries.Then follows q lines, containing space-separated two integers - ui and vi(1 ≤ ui, vi ≤ n). It is guaranteed that ui ≠ vi.\n\nOutputFor each query, print the answer in a separate line.\n\nInputCopy4 51 2 11 2 22 3 12 3 32 4 331 23 41 4OutputCopy210InputCopy5 71 5 12 5 13 5 14 5 11 2 22 3 23 4 251 55 12 51 51 4OutputCopy11112\n\nInputCopy4 51 2 11 2 22 3 12 3 32 4 331 23 41 4\n\nOutputCopy210\n\nInputCopy5 71 5 12 5 13 5 14 5 11 2 22 3 23 4 251 55 12 51 51 4\n\nOutputCopy11112\n\nNoteLet's consider the first sample.     The figure above shows the first sample.    Vertex 1 and vertex 2 are connected by color 1 and 2.  Vertex 3 and vertex 4 are connected by color 3.  Vertex 1 and vertex 4 are not connected by any single color.",
      "solutions": [
        {
          "title": "Codeforces Round #286 - Codeforces",
          "content": "Hello Codeforces!evima, yosupo and I would like you to participate in Codeforces Round #286. It will be held on Sunday, January 18th at 16:00 MSK. Please note that this round starts on unusual time.Great thanks to Zlobober who helped us prepare this round, Delinur who translated statements into Russian and MikeMirzayanov who created Codeforces and polygon.This is the 3rd time(following #162 and #263) for me, and the 1st time for evima and yosupo to prepare a Codeforces Round.Scores of the problems will be500-1000-1750-1750-2500 for Div.1, and500-1000-1500-2000-2750 for Div.2.In this round, you'll help a man named Mr. kitayuta. I hope he will participate :)The system tests are now over! The top-5 are as follows:Div.1:1.ilyakor2.kcm17003.LayCurse4.RomaWhite5.TankEngineerDiv.2:1.Konijntje2.cpcpc3.zgzjsxshycxksxhsh4.Ronnie0075.sha384Also, special congrats on Petr, who solved problem E in Div.1, which anyone else could not solve.Here are the editorials",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/15842",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 961
        },
        {
          "title": "Codeforces Round #286 Editorial (Complete) - Codeforces",
          "content": "Edit (Jan 22, 2:45 AM UTC): Added Div1E and the editorial is now complete. I am sorry for the delay.Edit (Jan 21, 9:45 AM UTC): Added the explanation for Div1C/2E, and the problem setters' codes. Div1E will need several more hours. Thank you again for your patience.First, here are some statistics on this round: Division Registrants Participants A Accepted B Accepted C Accepted D Accepted E Accepted 1 1364 572 (*) 294 199 8 113 1 (Estimated number of AC by me) 800 (wrong) 500 (wrong) 70 (FAIL) 90 (ok) 5 (wrong) 2 4016 2028 1355 945 41 5 0 (*) Where did the remaining 792 people go? :) We are sorry for terribly underestimating the difficulty of the problems (except Div1D), especially Div1A/2C and Div1C/2E. Div.2 A: 505A - Mr. Kitayuta's Gift[Problem] Given a string, turn it into a palindrome by inserting one letter or state that it is impossible.(Problem by evima)Since the string is short (at most 10 characters), you can simply try every possible way of inserting a letter (\"where\" and \"what\" to insert), and check if the resulting string is a palindrome.The writer's code (C++): 9501249Note: For some strange reason, we (contest managers) cannot submit solutions so that everyone can see them. PraveenDhinwa told us how to do so. Thank you! Div.2 B: 505B - Mr. Kitayuta's Colorful Graph[Problem] Given an undirected graph whose edges are painted in colors, process the queries of the following form: Given two vertices ui and vi, find the number of the colors that satisfies the following condition: the edges of that color connect ui and vi (possibly indirectly). (Problem by hogloid)Since neither the graph nor the number of queries is too large, for each query you can simply count the number of the \"good\" colors (the colors that satisfies the condition) by checking if each color is \"good\". To do that, you can perform Depth First Search (or Breadth First Search) and verify whether you can reach vi from ui traversing only the edges of that color. If you prefer using Union-Find, it will also do the job.The writer's code (DFS, C++)The writer's code (Union-Find, C++) Div.2 C / Div.1 A: 505C - Mr. Kitayuta, the Treasure Hunter[Problem] Since it is hard to summarize this problem, please refer to the official statement.(Problem by yosupo)Below is the explanation from yosupo, translated by me.[From here]Let m be the number of the islands (that is, 30001). First, let us describe a solution with time and memory complexity of O(m2).We will apply Dynamic Programming. let dp[i][j] be the number of the gems that Mr. Kitayuta can collect after he jumps to island i, when the length of his previous jump is j (let us assume that he have not collect the gems on island i). Then, you can calculate the values of the table dp by the following: dp[i][j] = 0, if i ≥ m(actually these islands do not exist, but we can suppose that they exist and when Mr. Kitayuta jumps to these islands, he stops jumping) dp[i][j] =  (the number of the gems on island i)  + max(dp[i + j][j], dp[i + j + 1][j + 1]), if i < m, j = 1(he cannot perform a jump of length 0) dp[i][j] =  (the number of the gems on island i)  + max(dp[i + j - 1][j - 1], dp[i + j][j], dp[i + j + 1][j + 1]), if i < m, j ≥ 2 This solution is unfeasible in terms of both time and memory. However, the following observation makes it an Accepted solution: there are only 491 values of j that we have to consider, which are d - 245, d - 244, d - 243, ..., d + 244 and d + 245.Why? First, let us find the upper bound of j. Suppose Mr. Kitayuta always performs the \"l + 1\" jump (l: the length of the previous jump). Then, he will reach the end of the islands before he performs a jump of length d + 246, becaused + (d + 1) + (d + 2) + ... + (d + 245) ≥ 1 + 2 + ... + 245 = 245·(245 + 1) / 2 = 30135 > 30000. Thus, he will never be able to perform a jump of length d + 246 or longer.Next, let us consider the lower bound of j in a similar way. If d ≤ 246, then obviously he will not be able to perform a jump of length d - 246 or shorter, because the length of a jump must be positive. Suppose Mr. Kitayuta always performs the \"l - 1\" jump, where d ≥ 247. Then, again he will reach the end of the islands before he performs a jump of length d - 246, becaused + (d - 1) + (d - 2) + ... + (d - 245) ≥ 245 + 244 + ... + 1 = 245·(245 + 1) / 2 = 30135 > 30000. Thus, he will never be able to perform a jump of length d - 246 or shorter.Therefore, we have obtained a working solution: similar to the O(m2) one, but we will only consider the value of j between d - 245 and d + 245. The time and memory complexity of this solution will be O(m1.5), since the value \"245\" is slightly larger than .This solution can be implemented by, for example, using a \"normal\" two dimensional array with a offset like this: dp[i][j - offset]. The time limit is set tight in order to fail most of naive solutions with search using std::map or something, so using hash maps (unordered_map) will be risky although the complexity will be the same as the described solution.[End]The writer's code (memoized recursion, C++) Div.2 D / Div.1 B: 505D - Mr. Kitayuta's Technology[Problem] Given an integer n and m pairs of integers (ai, bi) (1 ≤ ai, bi ≤ n), find the minimum number of edges in a directed graph that satisfies the following condition: For each i, there exists a path from vertex ai to vertex bi. (Problem from evima)Let G1 be the directed graph built from the input, and G2 be a directed graph that satisfies the given conditions. What we seek is the minimum number of edges in G2. Also, we say that two vertices u and v in a directed graph are \"weakly connected\" if we can reach v from u by traversing edges, not considering their directions.If a pair (u, v) is present in the input, then vertices u and v must be weakly connected in G2. Therefore, for each weakly connected component (abbreviated to wcc) in G1, the vertices in that component must also be in the same wcc in G2. We can \"merge\" multiple wccs in G1 and create a larger wcc in G2, but for now, let us find the minimum number of edges required in G2 for each wcc in G1 when we do not \"merge\" them. There are two cases to consider: If a wcc in G1 does not have cycles, then we can perform topological sort on that wcc, and we can make a \"chain\" (see the image below) using the topological order to satisfy the conditions. We need (the number of the vertices in the wcc)  - 1 edges, which is the minimum required number since any connected graph with V vertices has at least V - 1 edges. If a wcc in G1 has cycles, then topological sort cannot be applied. We need at least (the number of the vertices in the wcc) edges this time, since any connected graph with V vertices and V - 1 edges is a tree, which does not contain cycles. Actually, this number (the number of the vertices in the wcc) is always achievable by connecting the vertices into a \"ring\" (see the image below), thus it is the minimum required number that we seek. We have found the minimum required number of edges for each wcc in G1 when we do not \"merge\" them. Let us show that \"merging\" wccs in G1 do not reduce the number of required edges. Suppose we combine k( > 1) wccs C1, C2, ..., Ck in G1 into one wcc C in G2. Again, there are two cases to consider: If none of C1, C2, ..., Ck contains cycles, then C will need |C1| + |C2| + ... + |Ck| - 1 edges. However, if we do not combine them, we will only need (|C1| - 1) + (|C2| - 1) + ... + (|Ck| - 1) edges in total, which is fewer. If some of C1, C2, ..., Ck contain cycles, then C will need |C1| + |C2| + ... + |Ck| edges. However, if we do not combine them, we will need(|C1| - noCycles(C1)) + (|C2| - noCycles(C2)) + ... + (|Ck| - noCycles(Ck)  ≤ |C1| + |C2| + ... + |Ck| edges(here, noCycles(Ci) is 1 if Ci do not contain cycles, otherwise 0), thus combining them does not reduce the number of required edges. Thus, we do not need to combine multiple wccs into one wcc in G2 in order to obtain the optimal solution. That is, the final answer to the problem is the sum of the minimum required number of edges for each wcc in G1, when they are considered separately.As for the implementation, detecting cycles in a directed graph with 105 vertices and edges might be a problem if this is your first encounter with it. One possible way is to paste a code that decomposes a graph into strongly connected components. If the size of a strongly connected component is more than one, then that means the component contains cycles.The writer's code (strongly connected component decomposition, C++): 9501202 Div.2 E / Div.1 C: 505E - Mr. Kitayuta vs. Bamboos[Problem] Since it is hard to summarize this problem, please refer to the official statement.(Problem from yosupo)Below is the explanation from yosupo, translated by me.[From here]Let us begin by applying Binary Search. The problem becomes: \"is it possible that all the bamboos are at most X meters after m days?\" It is complicated by the fact that the height does not become negative; the excessive decrease will be wasted. We have found two approaches to this problem. Solution 1 Mr. Kitayuta must beat the i-th bamboo at least max(0, ⌈(hi + m·ai - X) / P⌉) times (let this number ti). Actually, it is not necessary for him to beat it more than this number of times. Thus, let us assume that he beat the i-th bamboo exactly ti times. Also, for each j (1 ≤ j ≤ ti), find the day di, j such that, if the j-th beat on the i-th bamboo is performed before day di, it will be no longer possible to keep the i-th bamboo's height after m days at most X (it can be found by doing simple math). If Mr. Kitayuta can beat the bamboos under this constraint, all the bamboos' heights will become X meters or less after m days. Otherwise, some bamboos' heights will exceed X meters.The time complexity of this solution will be , if we first calculate only ti, then if the sum of ti exceeds km, we skip finding di, j (the answer is \"NO\"). Solution 2 This problem becomes simpler if we simulate Mr. Kitayuta's fight backwards, that is, from day m to day 1. It looks like this:[Problem'] There are n bamboos. At the moment, the height of the i-th bamboo is X meters, and it shrinks ai meters at the beginning of each day. Mr. Kitayuta will play a game. He can use Magic Hammer at most k times per day to increase the height of a bamboo by p meters. If some bamboo's height becomes negative at any moment, he will lose the game immediately. Also, in order for him to win the game, the i-th bamboo's height must be at least hi meters after m days. Is victory possible?Below is an illustration of this \"reverse simulation\": This version is simpler because he is increasing the heights instead of decreasing, thus we do not need to take into account the \"excessive decrease beyond 0 meters\" which will be wasted. Let us consider an optimal strategy. If there exist bamboos whose heights would become negative after day m, he should beat the one that is the earliest to make him lose. Otherwise, he can choose any bamboo whose height would be less than hi meters after day m. Repeat beating the bamboos following this strategy, and see if he can actually claim victory.The writer's implementation of this solution uses a priority queue, and its time complexity is .[End]The tester's code (Solution 1, C++): 9501229The writer's code (Solution 2, C++) Div.1 D: 506D - Mr. Kitayuta's Colorful Graph[Problem] Given an undirected graph whose edges are painted in colors, process the queries of the following form: Given two vertices ui and vi, find the number of the colors that satisfies the following condition: the edges of that color connect ui and vi (possibly indirectly). Note: this is the exact same problem as Div.2 B except the constraints, which are 105 instead of 100.(Problem from hogloid)Below is the explanation from hogloid.[From here]For each color, make a new graph that consists of the edges of the color and vertices connected by the edges. Make UnionFind for each graph, and you can check whether a color connects vertex A and B , using it. For each query, find a vertex which has smaller degree(let this vertex A, and the other vertex B) For each colors such that a edge of the color connects to A, check whether A and B is connected by the color. After answering the query, memorize its tuple — (A, B, answer). If the same query is requested, answer using this information.This will lead to solution.For each query, the complexity is (For each color connects A, find a vertex of B of the color & check whether they are connected) The queries that require longest computing time are, to ask every pair among vertices which have largest degrees. Let the indices of the vertices be , and degrees of the vertices be d1, d2, ...dk. Now, let's fix vertex B as i. The total computing time of the queries such that B is vertex i is . Vertex B can vary from 2 to k. Hence, the total complexity is at most . This complexity is at most .By the way, in C++, using unordered_map, total complexity would be .[End]There will be many other solutions. I will briefly explain one of them which I think is typical.Let ci be the number of colors of the edges incident to vertex i. The sum of all ci does not exceed 2m since each edge increases this sum by at most 2. Thus, there will be at most 450 values of i such that ci ≥ 450 (let B = 450). We will call these vertices large, and the remaining ones small. Using O(m / B·m) = O(m2 / B) time and memory, we can precalculate and store the answer for all the possible queries where at least one of ui and vi is large, then we can immediately answer these queries. For the remaining queries, both ui and vi will be small, therefore it is enough to directly count the color that connects vertices ui and vi in O(B) time. The total time required will be O(m2 / B + Bq). If we choose , we can solve the problem in time.The writer's code (the first solution, C++)The tester's code (the second solution, C++): 9501240 Div.1 E: 506E - Mr. Kitayuta's Gift[Problem] Given a string s and an integer n, find the number of the palindromes that can be obtained by inserting exactly n letters into s.Note: Div.2 A is a similar problem, where n is fixed to 1.(Problem from evima)First of all, let us note that we are asked to count the resulting palindromes, not the ways to obtain them. For example, if we are to insert \"b\" into \"abba\", there are 5 possible positions, but only 3 strings will be produced (\"babba\", \"abbba\" and \"abbab\"). Rather than trying to count the ways of inserting a letter n times and removing the duplicated results, we should directly count the resulting palindrome. To do that, let us reformulate the problem:[Problem'] Given a string s and an integer n, find the number of the palindromes of length |s| + n (let this number be N) that contains s as a subsequence (not necessarily contiguous).Consider constructing a palindrome from both ends, and matching it to s from both left and right. For example, let s = \"abaac\" and N = 11. Let us call the final resulting string t. We first decide what letter to use as t1 and t11 (they must be equal in order for t to be a palindrome). Let us say 'c' is chosen. Now, we have to construct the remaining part of t, that is, t2..t10, so that t2..t10 contains \"abaa\" as a substring (note that the 'c' at the end of s is discarded). Again, we decide what letter to use as t2 and t10. This time we choose 'a'. Then, we have to construct t3..t9, so that it contains \"ba\" as a substring (this time the two 'a's at the both ends of s are discarded). We choose t3 = t9 = 'c'. Next, we construct t4..t8, so that it contains \"ba\" as a substring (this time s remains unchanged). We choose t4 = t8 = 'b'. Then, we construct t5..t7, so that it contains \"a\" as a substring. We choose t5 = t7 = 'a' (it is becoming repetitive, isn't it?). The last part of t, that is, t6, has no restriction (this time we choose a letter for only one position of t, not two). We choose 'd', and we have obtained a palindrome \"cacbadabcac\" that contains s = \"abaac\" as a subsequence.This problem is mostly about analyzing this process carefully.The most naive solution other than literally enumerating all palindromes of length N would be the following Dynamic Programming: let dp[i][left][right] be the number of the palindromes t that can be obtained if you have already decided the leftmost and the rightmost i letters (2i in total), and the substring sleftsleft + 1..sright of s remains unmatched. Each value in this table can be computed in O(1) time. Of course, since i can be up to ⌊n / 2⌋ (n ≤ 109), this solution is far from our goal.Notice that the transitions from dp[i] to dp[i + 1] are the same regardless of i, thus we can calculate the table by matrix exponentiation. However, since there are O(|s|2) possible pairs for (left, right), we will need time, which is actually worse than the naive calculation considering that |s| can be up to 200.This is where we need to observe the process which we have gone through at the beginning more carefully. Let us build a automaton corresponding to the process (the image below). (*) An self-loop with a number means that there are actually that number of edges.A process of producing a palindrome of length N that contains s as a subsequence corresponds to a path of length ⌈N / 2⌉ from the upper-right vertex to the lower-left vertex. Each red vertex has 24 self-loops since the letters at the both ends of the remaining part of s is different, which correspond to two non-self-loop transitions. Similarly, each green vertex has 25 self-loops since the first letter and the last letter of the remaining string is the same, and the blue vertex, the destination, has 26 self-loops, as there are no more non-self-loop transitions available.Here is an important fact: there are not so many possible combination of (n24, n25), where n24 and n25 are the number of times a path from START to GOAL visits a red vertex (with 24 self-loops) and a green vertex (with 25 self-loops), respectively. Why? Each time we leave a red vertex, the length of the remaining unmatched part of s decreases by 1, since exactly one of the two letters at the ends of the remaining part is matched and discarded. Similarly, each time we leave a green vertex, the length of the remaining string decreases by 2, since both of the two letters at the ends are matched and discarded. There is a exception, however: if the length of the remaining string is 1, then it will be a green vertex, but in this case the length will decrease by 1. Thus, for any path from START to GOAL, n24 + 2·n25 will be equal to either |s| or |s| + 1. If we fix n24, then n25 will be uniquely determined by n25 = ⌈(|s| - n24) / 2⌉. Since n24 can only take the value between 0 and |s| - 1, there are at most |s| possible pairs of (n24, n25).With this fact, we are ready to count the paths: let us classify them by the value of n24. For each possible pair of (n24, n25), let us count the number of corresponding paths. To do that, we divide each paths into two parts: first we count the number of paths from START to GOAL, using only non-self-loop transitions. Then, we count the ways of inserting self-loop transitions into each of these paths. The product of these two numbers will be the number that we seek.The first part is straightforward to solve: let dp[left][right][n24] be the number of paths from the vertex that corresponds to the substring sleftsleft + 1..sright, visiting exactly n24 red vertices using only non-self-loop transitions. Each value of the table can be found in O(1) time, thus the whole table can be computed in O(|s|3) time, which is fast enough for the input size (|s| ≤ 200).The main obstacle will be the second part. For example, let us consider the case where s = \"abaac\", N = 11, n24 = 2, which corresponds to the example at the beginning. From the fact we found earlier, n25 = ⌈(|s| - n24) / 2⌉ = ⌈(5 - 2) / 2⌉ = 2. Thus, we have to insert ⌈N / 2⌉ - n24 - n25 = 6 - 2 - 2 = 2 self-loop transitions into this path (the image): The order in which red, green and blue vertices appears in this path does not affect the number of ways of insertion, and can be arbitrary. The number of ways to insert 2 self-loop transitions will be equal to the number of the path of length ⌈N / 2⌉ = 6 from START to GOAL in this automaton (we have to take into account the non-self-loop transitions in it), which can be calculated by matrix exponentiation.Are we done? No! Consider the case s = \"abbb..(|s| - 1 times)..bb\". There are |s| - 1 possible values of n24 (n24 = 1 corresponds to the case where you match and discard the 'a' first, and n24 = |s| - 1 corresponds to the case where you keep the 'a' until s becomes \"ab\"). Thus, you need to perform matrix exponentiation |s| - 1 times, which results in a total of time, which will be too much under the given constraints.There is still hope, though, and here is the climax. Notice that these automata are very similar to each other, and they differ only in the number of the red and green vertices. We can combine these automata into one larger automaton like this (the image): The combined automaton should have |s| - 1 red, ⌈|s| / 2⌉ green and ⌈|s| / 2⌉ blue vertices.By performing matrix exponentiation on this automaton instead of many small automata, we can find all the required value in time, which should be enough. We recommend speeding up matrix multiplication by noticing that the matrix will be upper triangular (6 times faster on paper), since the time limit is not so generous (in order to reject solutions).The problem is almost solved, but there is one more challenge. When N is odd, the situation becomes a little complicated: as we have seen at the beginning, in the last (⌈N / 2⌉-th) step of producing a palindrome we choose a letter for only one position of the resulting string, that is, the center of that string. In other words, the last transition in the path in the automaton we have first built must not be one from a green vertex with a string of length 2 (for example, \"aa\") to GOAL.Let us find the number of the paths that violates this condition and subtract it from the answer. As previously mentioned, for each path n24 + 2·n25 will be equal to either |s| or |s| + 1, and if we fix the value of n24, n25 will be uniquely determined by n25 = ⌈(|s| - n24) / 2⌉. If |s| - n24 is odd, then it means that the last non-self-loop transition is one from a green vertex with a string of length 1, therefore in this case no path will violate the condition. If |s| - n24 is even, then the last non-self-loop trantision is from a green vertex with a string of length 2, thus the paths that does not contain the self-loop from GOAL to itself violate the condition. It will be equal to the number of the paths of length ⌈N / 2⌉ - 1 from START to the vertex just before GOAL, which can be found in a similar way to the second part of the solution.The journey has finally come to an end. Actually, it is also possible to solve this problem in time without matrix exponentiation, but this margin is too small to explain it. I will just paste the link to the code.The writer's code (matrix exponentiation, C++): 9501164The writer's code (without matrix exponentiation, C++): 9501177Congratulations again to Petr who was the only participant to solve this problem in 108 minutes. Also, I would like to give a special mention to rng_58, who was VERY close to solving it in only 63 minutes. He was just one byte away from getting AC (compare 9460984 and 9465440)! If you find a possible error, or have a question, please feel free to ask here. Alternative solutions are also welcome.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/15889",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 506\\s*D"
          },
          "content_length": 23595
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #286 - Codeforces - Code 1",
          "code": "This is the 3rd time(following #162 and #263) for me",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #286 - Codeforces - Code 2",
          "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N = 1e2 + 5;\n\nint parent[N][N];\n\nint find(int c, int v) {\n    if (parent[c][v] == -1)\n        return v;\n    return parent[c][v] = find(c, parent[c][v]);\n}\n\nvoid unite(int c, int u, int v) {\n    parent[c][find(c, u)] = find(c, v);\n}\n\nint main() {\n    memset(parent, -1, sizeof parent);\n    int n, m;\n    cin >> n >> m;\n    for (int i = 0; i < m; ++i) {\n        int a, b, c;\n        cin >> a >> b >> c;\n        unite(c, a, b);\n    }\n    int q;\n    cin >> q;\n    while (q--) {\n        int u, v, ans = 0;\n        cin >> u >> v;\n        for (int i = 1; i <= 100; ++i)\n            if (find(i, u) == find(i, v))\n                ++ans;\n        cout << ans << '\\n';\n    }\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/15842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #286 - Codeforces - Code 3",
          "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N = 1e2 + 5;\n\nint parent[N][N];\n\nint find(int c, int v) {\n    if (parent[c][v] == -1)\n        return v;\n    return parent[c][v] = find(c, parent[c][v]);\n}\n\nvoid unite(int c, int u, int v) {\n    parent[c][find(c, u)] = find(c, v);\n}\n\nint main() {\n    memset(parent, -1, sizeof parent);\n    int n, m;\n    cin >> n >> m;\n    for (int i = 0; i < m; ++i) {\n        int a, b, c;\n        cin >> a >> b >> c;\n        unite(c, a, b);\n    }\n    int q;\n    cin >> q;\n    while (q--) {\n        int u, v, ans = 0;\n        cin >> u >> v;\n        for (int i = 1; i <= 100; ++i)\n            if (find(i, u) == find(i, v))\n                ++ans;\n        cout << ans << '\\n';\n    }\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/15842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #286 - Codeforces - Code 4",
          "code": "Runtime Error",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #286 - Codeforces - Code 5",
          "code": "Memory Limit Exceeded",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #286 - Codeforces - Code 6",
          "code": "7 8\n1 2\n1 3\n2 4\n3 4\n4 5\n4 6\n5 7\n6 7",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #286 - Codeforces - Code 7",
          "code": "7 8\n1 2\n1 3\n2 4\n3 4\n4 5\n4 6\n5 7\n6 7",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #286 - Codeforces - Code 8",
          "code": "Test: #12 ... verdict: WRONG_ANSWER\nInput\n1 30000\n30000\nOutput\n0\nAnswer\n1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #286 - Codeforces - Code 9",
          "code": "Test: #12 ... verdict: WRONG_ANSWER\nInput\n1 30000\n30000\nOutput\n0\nAnswer\n1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #286 - Codeforces - Code 10",
          "code": "unordered_map",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #286 - Codeforces - Code 11",
          "code": "res += (pars[c][u] == pars[c][v]);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #286 - Codeforces - Code 12",
          "code": "res += (pars[c][u] == pars[c][v]);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #286 - Codeforces - Code 13",
          "code": "if (pars[c].find(v) != pars[c].end() && pars[c][u] == pars[c][v]) {\n    res++;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #286 - Codeforces - Code 14",
          "code": "if (pars[c].find(v) != pars[c].end() && pars[c][u] == pars[c][v]) {\n    res++;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #286 Editorial (Complete) - Codeforces - Code 1",
          "code": "dp[i][j - offset]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15889",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #286 Editorial (Complete) - Codeforces - Code 2",
          "code": "components[x] & components[y]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15889",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #286 Editorial (Complete) - Codeforces - Code 3",
          "code": "7 8\n1 2\n2 3\n3 4\n4 1\n4 7\n7 6\n6 5\n5 2\n\nAuthor's Code on my Pc returns 7",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15889",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #286 Editorial (Complete) - Codeforces - Code 4",
          "code": "7 8\n1 2\n2 3\n3 4\n4 1\n4 7\n7 6\n6 5\n5 2\n\nAuthor's Code on my Pc returns 7",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15889",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #286 Editorial (Complete) - Codeforces - Code 5",
          "code": "Also, for each j (1 ≤ j ≤ ti), find the day di, j such that, if the j-th beat on the i-th bamboo is performed before day di, it will be no longer possible to keep the i-th bamboo's height after m days at most X (it can be found by doing simple math).",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15889",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #286 Editorial (Complete) - Codeforces - Code 6",
          "code": "if(target - h[i] <= 0){\n\tt[0]++;\n}else if(target - h[i] > a[i] * (m-1)){\n\tok = 0;\n\tgoto end;\n}else{\n\tt[(target - h[i] + a[i] - 1) / a[i]]++;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15889",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #286 Editorial (Complete) - Codeforces - Code 7",
          "code": "if(target - h[i] <= 0){\n\tt[0]++;\n}else if(target - h[i] > a[i] * (m-1)){\n\tok = 0;\n\tgoto end;\n}else{\n\tt[(target - h[i] + a[i] - 1) / a[i]]++;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15889",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #286 Editorial (Complete) - Codeforces - Code 8",
          "code": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\n#define pb push_back\n#define __addEdge(u, v) [u].push_back(v)\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<vi> vmi;\n\nint n, m;\nvmi G[111];\nvb mark;\n\nvoid dfs(vmi &SG, int u)\n{\n    mark[u] = true;\n    for (int i = 0; i < SG[u].size(); ++i)\n    {\n        int v = SG[u][i];\n        if (!mark[v])\n            dfs(SG, v);\n    }\n}\n\nint main()\n{\n    cin >> n >> m;\n\n    fill(G, G + 111, vmi(n + 1));\n    mark.assign(n + 1, false);\n    for (int i = 0; i < m; ++i)\n    {\n        int u, v, c;\n        cin >> u >> v >> c;\n        G[c]__addEdge(u, v);\n        G[c]__addEdge(v, u);\n    }\n\n    int q;\n    cin >> q;\n\n    while (q--)\n    {\n        int u, v;\n        cin >> u >> v;\n\n        int cnt = 0;\n        for (int k = 1; k <= 100; ++k)\n        {\n            fill(mark.begin(), mark.end(), false);\n            dfs(G[k], u);\n            cnt += mark[v];\n        }\n\n        cout << cnt << endl;\n    }   \n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/15889",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #286 Editorial (Complete) - Codeforces - Code 9",
          "code": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\n#define pb push_back\n#define __addEdge(u, v) [u].push_back(v)\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<vi> vmi;\n\nint n, m;\nvmi G[111];\nvb mark;\n\nvoid dfs(vmi &SG, int u)\n{\n    mark[u] = true;\n    for (int i = 0; i < SG[u].size(); ++i)\n    {\n        int v = SG[u][i];\n        if (!mark[v])\n            dfs(SG, v);\n    }\n}\n\nint main()\n{\n    cin >> n >> m;\n\n    fill(G, G + 111, vmi(n + 1));\n    mark.assign(n + 1, false);\n    for (int i = 0; i < m; ++i)\n    {\n        int u, v, c;\n        cin >> u >> v >> c;\n        G[c]__addEdge(u, v);\n        G[c]__addEdge(v, u);\n    }\n\n    int q;\n    cin >> q;\n\n    while (q--)\n    {\n        int u, v;\n        cin >> u >> v;\n\n        int cnt = 0;\n        for (int k = 1; k <= 100; ++k)\n        {\n            fill(mark.begin(), mark.end(), false);\n            dfs(G[k], u);\n            cnt += mark[v];\n        }\n\n        cout << cnt << endl;\n    }   \n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/15889",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(2, 100000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 100000, \"m\");\n    inf.readEoln();\n    \n    set< tuple<int, int, int> > edgeSet;\n    for(int i = 0; i < m; ++i) {\n        int ai = inf.readInt(1, n-1, \"ai\");\n        inf.readSpace();\n        int bi = inf.readInt(ai+1, n, \"bi\");\n        inf.readSpace();\n        int ci = inf.readInt(1, m, \"ci\");\n        inf.readEoln();\n\n        auto edge = make_tuple(ai, bi, ci);\n        ensuref(edgeSet.find(edge) == edgeSet.end(), \"Duplicate edge between ai=%d and bi=%d with color ci=%d\", ai, bi, ci);\n        edgeSet.insert(edge);\n    }\n    \n    int q = inf.readInt(1, 100000, \"q\");\n    inf.readEoln();\n    for (int i = 0; i < q; ++i) {\n        int ui = inf.readInt(1, n, \"ui\");\n        inf.readSpace();\n        int vi = inf.readInt(1, n, \"vi\");\n        inf.readEoln();\n        ensuref(ui != vi, \"ui (%d) should not equal vi (%d)\", ui, vi);\n    }\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(2, 100000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 100000, \"m\");\n    inf.readEoln();\n    \n    set< tuple<int, int, int> > edgeSet;\n    for(int i = 0; i < m; ++i) {\n        int ai = inf.readInt(1, n-1, \"ai\");\n        inf.readSpace();\n        int bi = inf.readInt(ai+1, n, \"bi\");\n        inf.readSpace();\n        int ci = inf.readInt(1, m, \"ci\");\n        inf.readEoln();\n\n        auto edge = make_tuple(ai, bi, ci);\n        ensuref(edgeSet.find(edge) == edgeSet.end(), \"Duplicate edge between ai=%d and bi=%d with color ci=%d\", ai, bi, ci);\n        edgeSet.insert(edge);\n    }\n    \n    int q = inf.readInt(1, 100000, \"q\");\n    inf.readEoln();\n    for (int i = 0; i < q; ++i) {\n        int ui = inf.readInt(1, n, \"ui\");\n        inf.readSpace();\n        int vi = inf.readInt(1, n, \"vi\");\n        inf.readEoln();\n        ensuref(ui != vi, \"ui (%d) should not equal vi (%d)\", ui, vi);\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(2, 100000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 100000, \"m\");\n    inf.readEoln();\n    \n    set< tuple<int, int, int> > edgeSet;\n    for(int i = 0; i < m; ++i) {\n        int ai = inf.readInt(1, n-1, \"ai\");\n        inf.readSpace();\n        int bi = inf.readInt(ai+1, n, \"bi\");\n        inf.readSpace();\n        int ci = inf.readInt(1, m, \"ci\");\n        inf.readEoln();\n\n        auto edge = make_tuple(ai, bi, ci);\n        ensuref(edgeSet.find(edge) == edgeSet.end(), \"Duplicate edge between ai=%d and bi=%d with color ci=%d\", ai, bi, ci);\n        edgeSet.insert(edge);\n    }\n    \n    int q = inf.readInt(1, 100000, \"q\");\n    inf.readEoln();\n    for (int i = 0; i < q; ++i) {\n        int ui = inf.readInt(1, n, \"ui\");\n        inf.readSpace();\n        int vi = inf.readInt(1, n, \"vi\");\n        inf.readEoln();\n        ensuref(ui != vi, \"ui (%d) should not equal vi (%d)\", ui, vi);\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nnamespace std {\n    template <>\n    struct hash<std::pair<int, int>> {\n        size_t operator()(const std::pair<int, int>& k) const {\n            return ((size_t)k.first) ^ (((size_t)k.second) << 16);\n        }\n    };\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    int q = opt<int>(\"q\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<tuple<int, int, int>> edges;\n    unordered_map<pair<int,int>, unordered_set<int>> edge_colors;\n\n    if (type == \"random\") {\n        // Generate random edges with random colors\n        for (int i = 0; i < m; ) {\n            int ai = rnd.next(1, n);\n            int bi = rnd.next(1, n);\n            if (ai > bi) swap(ai, bi);\n            if (ai == bi) continue;\n            int ci = rnd.next(1, m);  // colors between 1 and m\n            pair<int, int> edge = {ai, bi};\n            if (edge_colors[edge].count(ci) == 0) {\n                edge_colors[edge].insert(ci);\n                edges.emplace_back(ai, bi, ci);\n                i++;\n            }\n        }\n    } else if (type == \"max_colors\") {\n        // Use maximum number of colors (ci from 1 to m)\n        m = min(m, n * (n - 1) / 2);\n        int idx = 0;\n        for (int ai = 1; ai <= n; ++ai) {\n            for (int bi = ai + 1; bi <= n; ++bi) {\n                if (idx >= m) break;\n                int ci = idx + 1; // ci from 1 to m\n                edges.emplace_back(ai, bi, ci);\n                idx++;\n            }\n            if (idx >= m) break;\n        }\n    } else if (type == \"min_colors\") {\n        // Use only one color for all edges\n        for (int i = 0; i < m; ) {\n            int ai = rnd.next(1, n);\n            int bi = rnd.next(1, n);\n            if (ai > bi) swap(ai, bi);\n            if (ai == bi) continue;\n            pair<int, int> edge = {ai, bi};\n            if (edge_colors[edge].count(1) == 0) {\n                edge_colors[edge].insert(1);\n                edges.emplace_back(ai, bi, 1);\n                i++;\n            }\n        }\n    } else if (type == \"single_component\") {\n        // Build a connected graph with edges of the same color\n        int ci = 1;\n        // Build a tree first\n        for (int i = 2; i <= n; i++) {\n            int ai = rnd.next(1, i - 1);\n            int bi = i;\n            edges.emplace_back(ai, bi, ci);\n            edge_colors[{min(ai, bi), max(ai, bi)}].insert(ci);\n        }\n        // Add extra edges up to m\n        for (int i = n - 1; i < m; ) {\n            int ai = rnd.next(1, n);\n            int bi = rnd.next(1, n);\n            if (ai > bi) swap(ai, bi);\n            if (ai == bi) continue;\n            pair<int, int> edge = {ai, bi};\n            if (edge_colors[edge].count(ci) == 0) {\n                edge_colors[edge].insert(ci);\n                edges.emplace_back(ai, bi, ci);\n                i++;\n            }\n        }\n    } else if (type == \"disconnected\") {\n        // Build multiple components with different colors\n        int k = opt<int>(\"k\", max(1, n / 10)); // default number of components\n        vector<int> component(n + 1);\n        for (int i = 1; i <= n; ++i) {\n            component[i] = i % k + 1;\n        }\n        shuffle(component.begin() + 1, component.end());\n        int current_ci = 1;\n        for (int c = 1; c <= k; ++c) {\n            vector<int> nodes;\n            for (int i = 1; i <= n; ++i)\n                if (component[i] == c)\n                    nodes.push_back(i);\n            // Build a tree among these nodes\n            for (int i = 1; i < nodes.size(); ++i) {\n                int ai = nodes[i - 1];\n                int bi = nodes[i];\n                if (ai > bi) swap(ai, bi);\n                edges.emplace_back(ai, bi, current_ci);\n                edge_colors[{ai, bi}].insert(current_ci);\n            }\n            current_ci++;\n        }\n        // Add extra edges up to m\n        for (int i = edges.size(); i < m; ) {\n            int ai = rnd.next(1, n);\n            int bi = rnd.next(1, n);\n            if (ai > bi) swap(ai, bi);\n            if (ai == bi) continue;\n            int ci = rnd.next(1, current_ci - 1);\n            pair<int, int> edge = {ai, bi};\n            if (edge_colors[edge].count(ci) == 0) {\n                edge_colors[edge].insert(ci);\n                edges.emplace_back(ai, bi, ci);\n                i++;\n            }\n        }\n    } else {\n        fprintf(stderr, \"Unrecognized type: %s\\n\", type.c_str());\n        return 1;\n    }\n\n    // Output the graph\n    printf(\"%d %d\\n\", n, (int)edges.size());\n    for (auto &e : edges) {\n        int ai, bi, ci;\n        tie(ai, bi, ci) = e;\n        printf(\"%d %d %d\\n\", ai, bi, ci);\n    }\n\n    // Generate queries\n    printf(\"%d\\n\", q);\n    for (int i = 0; i < q; ++i) {\n        int ui = rnd.next(1, n);\n        int vi = rnd.next(1, n);\n        while (ui == vi) {\n            vi = rnd.next(1, n);\n        }\n        printf(\"%d %d\\n\", ui, vi);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nnamespace std {\n    template <>\n    struct hash<std::pair<int, int>> {\n        size_t operator()(const std::pair<int, int>& k) const {\n            return ((size_t)k.first) ^ (((size_t)k.second) << 16);\n        }\n    };\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    int q = opt<int>(\"q\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<tuple<int, int, int>> edges;\n    unordered_map<pair<int,int>, unordered_set<int>> edge_colors;\n\n    if (type == \"random\") {\n        // Generate random edges with random colors\n        for (int i = 0; i < m; ) {\n            int ai = rnd.next(1, n);\n            int bi = rnd.next(1, n);\n            if (ai > bi) swap(ai, bi);\n            if (ai == bi) continue;\n            int ci = rnd.next(1, m);  // colors between 1 and m\n            pair<int, int> edge = {ai, bi};\n            if (edge_colors[edge].count(ci) == 0) {\n                edge_colors[edge].insert(ci);\n                edges.emplace_back(ai, bi, ci);\n                i++;\n            }\n        }\n    } else if (type == \"max_colors\") {\n        // Use maximum number of colors (ci from 1 to m)\n        m = min(m, n * (n - 1) / 2);\n        int idx = 0;\n        for (int ai = 1; ai <= n; ++ai) {\n            for (int bi = ai + 1; bi <= n; ++bi) {\n                if (idx >= m) break;\n                int ci = idx + 1; // ci from 1 to m\n                edges.emplace_back(ai, bi, ci);\n                idx++;\n            }\n            if (idx >= m) break;\n        }\n    } else if (type == \"min_colors\") {\n        // Use only one color for all edges\n        for (int i = 0; i < m; ) {\n            int ai = rnd.next(1, n);\n            int bi = rnd.next(1, n);\n            if (ai > bi) swap(ai, bi);\n            if (ai == bi) continue;\n            pair<int, int> edge = {ai, bi};\n            if (edge_colors[edge].count(1) == 0) {\n                edge_colors[edge].insert(1);\n                edges.emplace_back(ai, bi, 1);\n                i++;\n            }\n        }\n    } else if (type == \"single_component\") {\n        // Build a connected graph with edges of the same color\n        int ci = 1;\n        // Build a tree first\n        for (int i = 2; i <= n; i++) {\n            int ai = rnd.next(1, i - 1);\n            int bi = i;\n            edges.emplace_back(ai, bi, ci);\n            edge_colors[{min(ai, bi), max(ai, bi)}].insert(ci);\n        }\n        // Add extra edges up to m\n        for (int i = n - 1; i < m; ) {\n            int ai = rnd.next(1, n);\n            int bi = rnd.next(1, n);\n            if (ai > bi) swap(ai, bi);\n            if (ai == bi) continue;\n            pair<int, int> edge = {ai, bi};\n            if (edge_colors[edge].count(ci) == 0) {\n                edge_colors[edge].insert(ci);\n                edges.emplace_back(ai, bi, ci);\n                i++;\n            }\n        }\n    } else if (type == \"disconnected\") {\n        // Build multiple components with different colors\n        int k = opt<int>(\"k\", max(1, n / 10)); // default number of components\n        vector<int> component(n + 1);\n        for (int i = 1; i <= n; ++i) {\n            component[i] = i % k + 1;\n        }\n        shuffle(component.begin() + 1, component.end());\n        int current_ci = 1;\n        for (int c = 1; c <= k; ++c) {\n            vector<int> nodes;\n            for (int i = 1; i <= n; ++i)\n                if (component[i] == c)\n                    nodes.push_back(i);\n            // Build a tree among these nodes\n            for (int i = 1; i < nodes.size(); ++i) {\n                int ai = nodes[i - 1];\n                int bi = nodes[i];\n                if (ai > bi) swap(ai, bi);\n                edges.emplace_back(ai, bi, current_ci);\n                edge_colors[{ai, bi}].insert(current_ci);\n            }\n            current_ci++;\n        }\n        // Add extra edges up to m\n        for (int i = edges.size(); i < m; ) {\n            int ai = rnd.next(1, n);\n            int bi = rnd.next(1, n);\n            if (ai > bi) swap(ai, bi);\n            if (ai == bi) continue;\n            int ci = rnd.next(1, current_ci - 1);\n            pair<int, int> edge = {ai, bi};\n            if (edge_colors[edge].count(ci) == 0) {\n                edge_colors[edge].insert(ci);\n                edges.emplace_back(ai, bi, ci);\n                i++;\n            }\n        }\n    } else {\n        fprintf(stderr, \"Unrecognized type: %s\\n\", type.c_str());\n        return 1;\n    }\n\n    // Output the graph\n    printf(\"%d %d\\n\", n, (int)edges.size());\n    for (auto &e : edges) {\n        int ai, bi, ci;\n        tie(ai, bi, ci) = e;\n        printf(\"%d %d %d\\n\", ai, bi, ci);\n    }\n\n    // Generate queries\n    printf(\"%d\\n\", q);\n    for (int i = 0; i < q; ++i) {\n        int ui = rnd.next(1, n);\n        int vi = rnd.next(1, n);\n        while (ui == vi) {\n            vi = rnd.next(1, n);\n        }\n        printf(\"%d %d\\n\", ui, vi);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 4 -m 5 -q 3 -type random\n./gen -n 5 -m 7 -q 5 -type random\n\n./gen -n 10 -m 15 -q 20 -type random\n./gen -n 10 -m 15 -q 20 -type max_colors\n./gen -n 10 -m 15 -q 20 -type min_colors\n./gen -n 10 -m 15 -q 20 -type single_component\n./gen -n 10 -m 15 -q 20 -type disconnected -k 2\n\n./gen -n 100 -m 150 -q 200 -type random\n./gen -n 100 -m 150 -q 200 -type max_colors\n./gen -n 100 -m 150 -q 200 -type min_colors\n./gen -n 100 -m 150 -q 200 -type single_component\n./gen -n 100 -m 150 -q 200 -type disconnected -k 5\n\n./gen -n 1000 -m 5000 -q 500 -type random\n./gen -n 1000 -m 5000 -q 500 -type max_colors\n./gen -n 1000 -m 5000 -q 500 -type min_colors\n./gen -n 1000 -m 5000 -q 500 -type single_component\n./gen -n 1000 -m 5000 -q 500 -type disconnected -k 10\n\n./gen -n 10000 -m 50000 -q 1000 -type random\n./gen -n 10000 -m 50000 -q 1000 -type max_colors\n./gen -n 10000 -m 50000 -q 1000 -type min_colors\n./gen -n 10000 -m 50000 -q 1000 -type single_component\n./gen -n 10000 -m 50000 -q 1000 -type disconnected -k 20\n\n./gen -n 100000 -m 100000 -q 100000 -type random\n./gen -n 100000 -m 100000 -q 100000 -type max_colors\n./gen -n 100000 -m 100000 -q 100000 -type min_colors\n./gen -n 100000 -m 100000 -q 100000 -type single_component\n./gen -n 100000 -m 100000 -q 100000 -type disconnected -k 100\n\n# Special cases\n./gen -n 2 -m 1 -q 1 -type random\n./gen -n 100000 -m 1 -q 1 -type random\n./gen -n 100000 -m 100000 -q 1 -type single_component\n./gen -n 100000 -m 100000 -q 100000 -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:40:49.822921",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "507/A",
      "title": "A. Amr and Music",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains two numbers n, k (1 ≤ n ≤ 100, 0 ≤ k ≤ 10 000), the number of instruments and number of days respectively.The second line contains n integers ai (1 ≤ ai ≤ 100), representing number of days required to learn the i-th instrument.",
      "output_spec": "OutputIn the first line output one integer m representing the maximum number of instruments Amr can learn.In the second line output m space-separated integers: the indices of instruments to be learnt. You may output indices in any order.if there are multiple optimal solutions output any. It is not necessary to use all days for studying.",
      "sample_tests": "ExamplesInputCopy4 104 3 1 2OutputCopy41 2 3 4InputCopy5 64 3 1 1 2OutputCopy31 3 4InputCopy1 34OutputCopy0",
      "description": "A. Amr and Music\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains two numbers n, k (1 ≤ n ≤ 100, 0 ≤ k ≤ 10 000), the number of instruments and number of days respectively.The second line contains n integers ai (1 ≤ ai ≤ 100), representing number of days required to learn the i-th instrument.\n\nOutputIn the first line output one integer m representing the maximum number of instruments Amr can learn.In the second line output m space-separated integers: the indices of instruments to be learnt. You may output indices in any order.if there are multiple optimal solutions output any. It is not necessary to use all days for studying.\n\nInputCopy4 104 3 1 2OutputCopy41 2 3 4InputCopy5 64 3 1 1 2OutputCopy31 3 4InputCopy1 34OutputCopy0\n\nInputCopy4 104 3 1 2\n\nOutputCopy41 2 3 4\n\nInputCopy5 64 3 1 1 2\n\nOutputCopy31 3 4\n\nInputCopy1 34\n\nOutputCopy0\n\nNoteIn the first test Amr can learn all 4 instruments.In the second test other possible solutions are: {2, 3, 5} or {3, 4, 5}.In the third test Amr doesn't have enough time to learn the only presented instrument.",
      "solutions": [
        {
          "title": "Codeforces Round #287 (Div. 2) - Codeforces",
          "content": "Hello Codeforces!I'd like to invite you to Codeforces Round #287 (Div. 2). It'll be held on Friday, January 23rd at 19:00 MSK. and as usual Div. 1 participants can join out of competition.This is my first round so wish me luck! :)Great thanks to Maxim Akhmedov (Zlobober) for helping me preparing the contest, Alex Fetisov (AlexFetisov) for testing and giving useful tips regarding statements, Maria Belova (Delinur) for translating the statements into Russian and Mike Mirzayanov (MikeMirzayanov) for the great Polygon platform.The scoring distribution will be announced later.Good luck everyone and I hope you'll find the problems interesting.UPD #1 Score distribution will be standard 500-1000-1500-2000-2500.UPD #2 Contest finished, hope you enjoyed the problems. :)UPD #3 System testing finished.Winner of the contest is going to be disqualified due to \"Do not use harsh, rude or misleading handle.\" part of Codeforces rules.So congratulations to the winners:chickennethsnowqcrqgx175mikeyue_tcDennordKilluaZoldyckUPD #4 You can find the editorial here.",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/15930",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1057
        },
        {
          "title": "Codeforces Round #287 (Div. 2) Editorial - Codeforces",
          "content": "507A - Amr and MusicProblem: We have to split the number k into maximum number of elements of ai such that their sum is less than or equal to k.Hint: To maximize the answer we have to split the number into the smallest numbers possible.Solution: So and since the limits are small we can pick up the smallest element of the array and subtract it from k, and we keep doing this n times or until the smallest number is larger than k. Another solution is to sort the array in non-decreasing order and go on the same way.Time complexity: or Implementation: 9529124 .507B - Amr and PinsProblem: We have a circle with radius R at position (x, y) and we want to move it to (x', y') with minimum moves possible. A move is to choose an arbitrary point on the border of the circle and rotate the circle around it with arbitrary angle.Hint: What is the shortest path between two points? A direct line. So moving the center on that line with maximum move possible each time will guarantee minimal number of moves.Solution: Let's draw a straight line between the two centers.Clearly to move the center with maximum distance we need to rotate it around the intersection of the line and the circle with 180 degrees. So the maximum distance we can move the center each time is 2 * R. Let's continue moving the center with 2 * R distance each time until the two circles intersects. Now obviously we can make the center moves into its final position by rotating it around one of the intersection points of the two circles until it reaches the final destination.Every time we make the circle moves 2 * R times except the last move it'll be  ≤ 2 * R. Assume that the initial distance between the two points is d So the solution to the problem will be .Time complexity: You have to be careful of precision errors. Here is a code that used only integer arithmetic operations 9529147.507C - Guess Your Way Out!Hint: Simulate the algorithm until we reach a leaf node assume that it's not the exit. Now the question is Are there some nodes that are guaranteed to be visited before trying to reach the exit again?Solution: The first observation is that in order to return to a parent we will have to visit all nodes of the right or the left subtree of some node first. Now imagine we are in the situation below where E is the exit.By applying the algorithm we'll reach node X. Both the E and X are in different subtrees of the root. Which means before going to the proper subtree in which the Exit exists we'll have to visit all the nodes of the left subtree (marked in red).This means we have to get the node which the Exit and the current leaf node X are in different subtrees which will be the least common ancestor (LCA) of the two nodes. Assume the subtree height is h1. This means we visited node. By adding the nodes above the subtree which we visited during executing the string for the first time the total number of visited nodes will be . Now let's go to the other subtree. Obviously we don't need any other nodes except this subtree. So let's do the same we did to the original tree to this subtree. Execute the algorithm until we reach a leaf node, get the LCA, add to the solution where h2 is the height of the subtree of the LCA node where the leaf node exists. And so on we keep applying the rules until after executing the algorithm we will reach the exit.Also we can do the same operations in O(h) by beginning to move from the root, if the exit is located to the left we go to the left and ans++ and then set the next command to 'R' else if it is located to the right we will visited the whole left subtree so we add the left subtree nodes to the answer and then set the next command to 'L' and so on.Time complexity: or Challenge: What if the pattern is given as an input (e.g. \"LRRLLRRRLRLRLRR...\"), How can this problem be solved?Implementation: 9529181507D - The Maths LectureHint: Dynamic programming problem. To handle repetitions we have to construct the number from right to the left and calculate the answer when we reach a number equivalent to 0 modulo k.Solution: Let's define as a recursive functions calculates the number of numbers consisting of n digits satisfying the conditions of the problem and with a specific suffix of length i Si such that .We want to avoid repetition so by constructing the number from the right to the left when we reach a state with j = 0 with suffix  ≠ 0 we return the answer immediately so any other suffix that contains this suffix won't b calculated.So the base cases are , .So state transitions will be (We add a digit to the left).And we can handle j = 0 case coming from a zero suffix easily with a boolean variable we set to true when we use a digit  ≠ 0 in constructing the number.Time complexity: Implementation: 9529210507E - Breaking GoodHint: Consider we've chosen a certain path with length d where d is the length of the shortest path from 1 to n and it has x edges that are working. Assume that y is the total number of edges that are working in the whole country. So we need to make d - x changes (to make the malfunctioning edges on the path work) and y - x changes (to blow up all other edges that don't lie on the path). So we will totally make d + y - 2 * x changes where d and y are constants. So the optimal solution will depend only on number of working edges along the path. So we'll have to maximize this number!Solution: We will use dynamic programming on all nodes that lies on some shortest path. In other words, every node x that satisfies that the shortest path from 1 to x + the shortest path from x to n equals d where d is the length of the shortest path from 1 to n. Let's define Max[x] is the maximum number of working edges along some shortest path from 1 to x. We can calculate the value Max[x] for all nodes by dynamic programming by traversing the nodes in order of increasing shortest path from node 1. So at the end we'll make d + y - 2 * Max[n] changes. We can get them easily by retrieving the chosen optimal path.Time complexity: Implementation: 9529272",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/15975",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 507\\s*A"
          },
          "content_length": 6032
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #287 (Div. 2) - Codeforces - Code 1",
          "code": "your                                               eyes",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15930",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #287 (Div. 2) - Codeforces - Code 2",
          "code": "are                                                moving",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15930",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #287 (Div. 2) - Codeforces - Code 3",
          "code": "from                                               left",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15930",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #287 (Div. 2) - Codeforces - Code 4",
          "code": "to                                                 right",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15930",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #287 (Div. 2) - Codeforces - Code 5",
          "code": "and                                                then",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15930",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #287 (Div. 2) - Codeforces - Code 6",
          "code": "from                                               right",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15930",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #287 (Div. 2) - Codeforces - Code 7",
          "code": "to                                                 left",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15930",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #287 (Div. 2) - Codeforces - Code 8",
          "code": "again                                              and",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15930",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #287 (Div. 2) - Codeforces - Code 9",
          "code": "again                                              to",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15930",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #287 (Div. 2) - Codeforces - Code 10",
          "code": "read                                               this",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15930",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #287 (Div. 2) - Codeforces - Code 11",
          "code": "x = (1LL << (h-1)) + 1; y = 1 << h;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15930",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #287 (Div. 2) - Codeforces - Code 12",
          "code": "x = (1LL << (h-1)) + 1; y = 1 << h;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15930",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #287 (Div. 2) - Codeforces - Code 13",
          "code": "dist-=1e-12;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15930",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #287 (Div. 2) - Codeforces - Code 14",
          "code": "100000 100000 1 -100000 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15930",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #287 (Div. 2) - Codeforces - Code 15",
          "code": "100000 100000 0 -100000 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15930",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #287 (Div. 2) - Codeforces - Code 16",
          "code": "100000 100000 0 -100000 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15930",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #287 (Div. 2) - Codeforces - Code 17",
          "code": "dist = 200000;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15930",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #287 (Div. 2) - Codeforces - Code 18",
          "code": "cerr << dist;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15930",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #287 (Div. 2) - Codeforces - Code 19",
          "code": "2) Add cerr << dist; after subtracting 1e-12 from dist.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15930",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #287 (Div. 2) - Codeforces - Code 20",
          "code": "printf(\"%d\\n\", (int) ceil(hypot(x1 - x2, y1 - y2) / (2 * r)));",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15930",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #287 (Div. 2) - Codeforces - Code 21",
          "code": "6.28009e-012",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15930",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #287 (Div. 2) - Codeforces - Code 22",
          "code": "141081 99263 99774 -100000 -100000",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15930",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #287 (Div. 2) - Codeforces - Code 23",
          "code": "830699159852",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15930",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #287 (Div. 2) - Codeforces - Code 24",
          "code": "39 457181784666",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15930",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #287 (Div. 2) - Codeforces - Code 25",
          "code": "547231318312",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15930",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #287 (Div. 2) - Codeforces - Code 26",
          "code": "scanf(\"%lld\", &n);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15930",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #287 (Div. 2) - Codeforces - Code 27",
          "code": "integer value (2)\nC++98: bitset (unsigned long val);\nC++11: constexpr bitset (unsigned long long val) noexcept;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15930",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #287 (Div. 2) - Codeforces - Code 28",
          "code": "integer value (2)\nC++98: bitset (unsigned long val);\nC++11: constexpr bitset (unsigned long long val) noexcept;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15930",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #287 (Div. 2) - Codeforces - Code 29",
          "code": "1024 is on the right side",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15930",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #287 (Div. 2) Editorial - Codeforces - Code 1",
          "code": "public void solve(int testNumber, InputReader in, PrintWriter out) {\n        int h = in.nextInt();\n        long n = in.nextLong() - 1;\n        long res = 0;\n        for(int i = h - 1; 1; i >= 0; i--) {\n            if ((n >> i & 1L) == 1) {\n                res += 1L << i + 1;\n            } else {\n                res += 1;\n                n = ~n; //inversion\n            }\n        }\n        out.println(res);\n    }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15975",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #287 (Div. 2) Editorial - Codeforces - Code 2",
          "code": "public void solve(int testNumber, InputReader in, PrintWriter out) {\n        int h = in.nextInt();\n        long n = in.nextLong() - 1;\n        long res = 0;\n        for(int i = h - 1; 1; i >= 0; i--) {\n            if ((n >> i & 1L) == 1) {\n                res += 1L << i + 1;\n            } else {\n                res += 1;\n                n = ~n; //inversion\n            }\n        }\n        out.println(res);\n    }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15975",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #287 (Div. 2) Editorial - Codeforces - Code 3",
          "code": "for(int j = 1; j < K; j++)\n  for(int d = 0; d <= 9; d++)\n  {\n        long long modulo = (pow(10,i)*d + j) % K;\n        DP[i+1][modulo] += DP[i][j];\n        DP[i+1][modulo] %= M;\n  }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15975",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #287 (Div. 2) Editorial - Codeforces - Code 4",
          "code": "for(int j = 1; j < K; j++)\n  for(int d = 0; d <= 9; d++)\n  {\n        long long modulo = (pow(10,i)*d + j) % K;\n        DP[i+1][modulo] += DP[i][j];\n        DP[i+1][modulo] %= M;\n  }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15975",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #287 (Div. 2) Editorial - Codeforces - Code 5",
          "code": "cal[i][j] = sum x = 0..9 cal[i - 1][(j - x * 10 ^ (i - 1)) mod k]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15975",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #287 (Div. 2) Editorial - Codeforces - Code 6",
          "code": "cal[i][j] = sum l=0..k-1 p[i][l] * cal[i - 1][(j - l) mod k]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15975",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #287 (Div. 2) Editorial - Codeforces - Code 7",
          "code": "// handle base cases\nfor(int i = 1;i <= n;i++)\n  for(int j = 1;j < k-1;j++)\n     for(int x = 0;x < 10;x++)\n      count[i+1][(j+(x*10^i))%k]+=count[i][j]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15975",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #287 (Div. 2) Editorial - Codeforces - Code 8",
          "code": "// handle base cases\nfor(int i = 1;i <= n;i++)\n  for(int j = 1;j < k-1;j++)\n     for(int x = 0;x < 10;x++)\n      count[i+1][(j+(x*10^i))%k]+=count[i][j]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15975",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #287 (Div. 2) Editorial - Codeforces - Code 9",
          "code": "if(ind == n || (rem == 0 && change)) return 0;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15975",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #287 (Div. 2) Editorial - Codeforces - Code 10",
          "code": "if(ind == n) return 0;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15975",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #287 (Div. 2) Editorial - Codeforces - Code 11",
          "code": "(rem==0&&change) is true",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15975",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #287 (Div. 2) Editorial - Codeforces - Code 12",
          "code": "We want to avoid repetition so by constructing the number from the right to the left when we reach a state with j = 0 with suffix  ≠ 0 we return the answer immediately so any other suffix that contains this suffix won't b calculated.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15975",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #287 (Div. 2) Editorial - Codeforces - Code 13",
          "code": "We want to avoid repetition so by constructing the number from the right to the left when we reach a state with j = 0 with suffix  ≠ 0 we return the answer immediately so any other suffix that contains this suffix won't b calculated.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15975",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #287 (Div. 2) Editorial - Codeforces - Code 14",
          "code": "pair<pair<int, int>, int>",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15975",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #287 (Div. 2) Editorial - Codeforces - Code 15",
          "code": "{{distance from 1, no. of bad roads in the shortest path from 1}, node}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15975",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #287 (Div. 2) Editorial - Codeforces - Code 16",
          "code": "#include<bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp> \nusing namespace std;\nusing namespace __gnu_pbds;\n#define intt int64_t \n \n\nvoid solve()\n{\n    intt n, m;\n    cin>>n>>m;\n    intt a, b, c;\n    vector<vector<pair<intt, intt>>> v(n+1);\n    set<pair<intt, intt>> good, ngood;\n    for(int i=0;i<m;i++) \n    {\n        cin>>a>>b>>c;\n        v[a].push_back({b, c});\n        v[b].push_back({a, c});\n        if(a>b) swap(a, b);\n        if(c==1) good.insert({a, b});\n    }\n    \n    set<pair<pair<intt, intt>, intt>> q;\n    // {{distance from 1, bad roads in shortest path}, node number}\n    q.insert({{0, 0}, 1});\n    vector<intt> dis(n+1, 2e9), sp(n+1, 2e9);\n    dis[1]=0;\n    sp[1]=0;\n\n    // dijkstras with (priority : min distance > min bad roads)\n    while(!q.empty())\n    {\n        auto k = *q.begin();\n        q.erase(q.begin());\n        if(dis[k.second]<k.first.first) continue;\n        else if(dis[k.second]<k.first.first and sp[k.second]<k.first.second) continue;\n        for(auto i:v[k.second])\n        {\n            if(dis[k.second]+1<dis[i.first])\n            {\n                dis[i.first]=dis[k.second]+1;\n                sp[i.first]=sp[k.second];\n                if(i.second==0) sp[i.first]++;\n                q.insert({{dis[i.first], sp[i.first]}, i.first});\n            }\n            else if(dis[k.second]+1==dis[i.first])\n            {\n                if(i.second==1 and sp[k.second]<sp[i.first])\n                {\n                    sp[i.first] = sp[k.second];\n                    q.insert({{dis[i.first], sp[i.first]}, i.first});\n                }\n                else if(i.second==0 and sp[k.second]+1<sp[i.first])\n                {\n                    sp[i.first] = sp[k.second]+1;\n                    q.insert({{dis[i.first], sp[i.first]}, i.first});\n                }\n            }\n        }        \n    }\n    intt curr = n;\n    while(curr>1)\n    {\n        intt mn = 2e9, z;\n        for(auto i:v[curr])\n        {\n            if(dis[i.first]==dis[curr]-1 and sp[i.first]<mn) z = i.first;\n        }\n        if(z<curr)\n        {\n            if(sp[curr]-1==sp[z]) ngood.insert({z, curr});\n            else if(sp[curr]==sp[z]) good.erase({z, curr});\n        }\n        else\n        {\n            if(sp[curr]-1==sp[z]) ngood.insert({curr, z});\n            else if(sp[curr]==sp[z]) good.erase({curr, z});\n        }\n        curr = z;\n    }\n    intt ans = good.size();\n    ans += ngood.size();\n    cout<<ans<<\"\\n\";\n    for(auto i:good) cout<<i.first<<\" \"<<i.second<<\" 0\\n\";\n    for(auto i:ngood) cout<<i.first<<\" \"<<i.second<<\" 1\\n\";\n}\n \nint main()\n{\n    // ios_base::sync_with_stdio(false);\n    // cin.tie(NULL);\n    int t=1;\n    // cin>>t;\n    while(t--)\n    {\n        solve();\n    }\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/15975",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #287 (Div. 2) Editorial - Codeforces - Code 17",
          "code": "#include<bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp> \nusing namespace std;\nusing namespace __gnu_pbds;\n#define intt int64_t \n \n\nvoid solve()\n{\n    intt n, m;\n    cin>>n>>m;\n    intt a, b, c;\n    vector<vector<pair<intt, intt>>> v(n+1);\n    set<pair<intt, intt>> good, ngood;\n    for(int i=0;i<m;i++) \n    {\n        cin>>a>>b>>c;\n        v[a].push_back({b, c});\n        v[b].push_back({a, c});\n        if(a>b) swap(a, b);\n        if(c==1) good.insert({a, b});\n    }\n    \n    set<pair<pair<intt, intt>, intt>> q;\n    // {{distance from 1, bad roads in shortest path}, node number}\n    q.insert({{0, 0}, 1});\n    vector<intt> dis(n+1, 2e9), sp(n+1, 2e9);\n    dis[1]=0;\n    sp[1]=0;\n\n    // dijkstras with (priority : min distance > min bad roads)\n    while(!q.empty())\n    {\n        auto k = *q.begin();\n        q.erase(q.begin());\n        if(dis[k.second]<k.first.first) continue;\n        else if(dis[k.second]<k.first.first and sp[k.second]<k.first.second) continue;\n        for(auto i:v[k.second])\n        {\n            if(dis[k.second]+1<dis[i.first])\n            {\n                dis[i.first]=dis[k.second]+1;\n                sp[i.first]=sp[k.second];\n                if(i.second==0) sp[i.first]++;\n                q.insert({{dis[i.first], sp[i.first]}, i.first});\n            }\n            else if(dis[k.second]+1==dis[i.first])\n            {\n                if(i.second==1 and sp[k.second]<sp[i.first])\n                {\n                    sp[i.first] = sp[k.second];\n                    q.insert({{dis[i.first], sp[i.first]}, i.first});\n                }\n                else if(i.second==0 and sp[k.second]+1<sp[i.first])\n                {\n                    sp[i.first] = sp[k.second]+1;\n                    q.insert({{dis[i.first], sp[i.first]}, i.first});\n                }\n            }\n        }        \n    }\n    intt curr = n;\n    while(curr>1)\n    {\n        intt mn = 2e9, z;\n        for(auto i:v[curr])\n        {\n            if(dis[i.first]==dis[curr]-1 and sp[i.first]<mn) z = i.first;\n        }\n        if(z<curr)\n        {\n            if(sp[curr]-1==sp[z]) ngood.insert({z, curr});\n            else if(sp[curr]==sp[z]) good.erase({z, curr});\n        }\n        else\n        {\n            if(sp[curr]-1==sp[z]) ngood.insert({curr, z});\n            else if(sp[curr]==sp[z]) good.erase({curr, z});\n        }\n        curr = z;\n    }\n    intt ans = good.size();\n    ans += ngood.size();\n    cout<<ans<<\"\\n\";\n    for(auto i:good) cout<<i.first<<\" \"<<i.second<<\" 0\\n\";\n    for(auto i:ngood) cout<<i.first<<\" \"<<i.second<<\" 1\\n\";\n}\n \nint main()\n{\n    // ios_base::sync_with_stdio(false);\n    // cin.tie(NULL);\n    int t=1;\n    // cin>>t;\n    while(t--)\n    {\n        solve();\n    }\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/15975",
          "author": "Qingyu"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(0, 10000, \"k\");\n    inf.readEoln();\n    vector<int> a = inf.readInts(n, 1, 100, \"a_i\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(0, 10000, \"k\");\n    inf.readEoln();\n    vector<int> a = inf.readInts(n, 1, 100, \"a_i\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(0, 10000, \"k\");\n    inf.readEoln();\n    vector<int> a = inf.readInts(n, 1, 100, \"a_i\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint n, k;\nvector<int> ai;\n\nint readAns(InStream& stream) {\n    int m = stream.readInt(0, n, \"number of instruments\");\n    vector<int> indices;\n    if(m > 0) {\n        indices.resize(m);\n        for(int i = 0; i < m; ++i) {\n            int idx = stream.readInt(1, n, format(\"index[%d]\", i+1).c_str());\n            indices[i] = idx;\n        }\n    }\n    set<int> indices_set(indices.begin(), indices.end());\n    if((int)indices_set.size() != m) {\n        stream.quitf(_wa, \"duplicate indices in the list\");\n    }\n    int total_days = 0;\n    for(int idx : indices) {\n        total_days += ai[idx - 1];\n    }\n    if(total_days > k) {\n        stream.quitf(_wa, \"total days %d exceed k = %d\", total_days, k);\n    }\n    if (!stream.seekEof()) {\n        stream.quitf(_pe, \"extra tokens in the output\");\n    }\n    return m;\n}\n\nint main(int argc, char *argv[]) {\n    registerTestlibCmd(argc, argv);\n\n    // Read input\n    n = inf.readInt(1, 100);\n    k = inf.readInt(0, 10000);\n    ai.resize(n);\n    for(int i = 0; i < n; ++i)\n        ai[i] = inf.readInt(1, 100);\n\n    int m_jury = readAns(ans);\n    int m_contestant = readAns(ouf);\n\n    if(m_contestant > m_jury) {\n        quitf(_fail, \"participant has better answer: jury's m = %d, participant's m = %d\", m_jury, m_contestant);\n    }\n    else if (m_contestant < m_jury) {\n        quitf(_wa, \"answer is not optimal: jury's m = %d, participant's m = %d\", m_jury, m_contestant);\n    }\n    else {\n        quitf(_ok, \"correct answer with %d instruments\", m_contestant);\n    }\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int k = opt<int>(\"k\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> a(n);\n\n    if (type == \"min_ai\") {\n        /* All ai are minimum (1) */\n        for (int i = 0; i < n; ++i)\n            a[i] = 1;\n    } else if (type == \"max_ai\") {\n        /* All ai are maximum (100) */\n        for (int i = 0; i < n; ++i)\n            a[i] = 100;\n    } else if (type == \"ascending\") {\n        /* ai are in ascending order from 1 to n */\n        for (int i = 0; i < n; ++i)\n            a[i] = i + 1;\n    } else if (type == \"descending\") {\n        /* ai are in descending order from n to 1 */\n        for (int i = 0; i < n; ++i)\n            a[i] = n - i;\n    } else if (type == \"max_instruments\") {\n        /* All ai are minimum (1), aiming to maximize the number of instruments */\n        for (int i = 0; i < n; ++i)\n            a[i] = 1;\n        /* k remains as input; may or may not be sufficient to learn all instruments */\n    } else if (type == \"min_instruments\") {\n        /* All ai are maximum (100), aiming to minimize the number of instruments */\n        for (int i = 0; i < n; ++i)\n            a[i] = 100;\n    } else if (type == \"zero_k\") {\n        /* Random ai, k assumed to be zero from input */\n        for (int i = 0; i < n; ++i)\n            a[i] = rnd.next(1, 100);\n    } else if (type == \"large_k\") {\n        /* Random ai, k assumed to be large from input */\n        for (int i = 0; i < n; ++i)\n            a[i] = rnd.next(1, 100);\n    } else {\n        /* Default: random ai */\n        for (int i = 0; i < n; ++i)\n            a[i] = rnd.next(1, 100);\n    }\n\n    /* Output n and k */\n    printf(\"%d %d\\n\", n, k);\n\n    /* Output ai's */\n    for (int i = 0; i < n; ++i)\n        printf(\"%d%c\", a[i], (i == n - 1 ? '\\n' : ' '));\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int k = opt<int>(\"k\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> a(n);\n\n    if (type == \"min_ai\") {\n        /* All ai are minimum (1) */\n        for (int i = 0; i < n; ++i)\n            a[i] = 1;\n    } else if (type == \"max_ai\") {\n        /* All ai are maximum (100) */\n        for (int i = 0; i < n; ++i)\n            a[i] = 100;\n    } else if (type == \"ascending\") {\n        /* ai are in ascending order from 1 to n */\n        for (int i = 0; i < n; ++i)\n            a[i] = i + 1;\n    } else if (type == \"descending\") {\n        /* ai are in descending order from n to 1 */\n        for (int i = 0; i < n; ++i)\n            a[i] = n - i;\n    } else if (type == \"max_instruments\") {\n        /* All ai are minimum (1), aiming to maximize the number of instruments */\n        for (int i = 0; i < n; ++i)\n            a[i] = 1;\n        /* k remains as input; may or may not be sufficient to learn all instruments */\n    } else if (type == \"min_instruments\") {\n        /* All ai are maximum (100), aiming to minimize the number of instruments */\n        for (int i = 0; i < n; ++i)\n            a[i] = 100;\n    } else if (type == \"zero_k\") {\n        /* Random ai, k assumed to be zero from input */\n        for (int i = 0; i < n; ++i)\n            a[i] = rnd.next(1, 100);\n    } else if (type == \"large_k\") {\n        /* Random ai, k assumed to be large from input */\n        for (int i = 0; i < n; ++i)\n            a[i] = rnd.next(1, 100);\n    } else {\n        /* Default: random ai */\n        for (int i = 0; i < n; ++i)\n            a[i] = rnd.next(1, 100);\n    }\n\n    /* Output n and k */\n    printf(\"%d %d\\n\", n, k);\n\n    /* Output ai's */\n    for (int i = 0; i < n; ++i)\n        printf(\"%d%c\", a[i], (i == n - 1 ? '\\n' : ' '));\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Minimum n (1)\n./gen -n 1 -k 0 -type zero_k\n./gen -n 1 -k 1 -type min_ai\n./gen -n 1 -k 1 -type random\n./gen -n 1 -k 10000 -type max_ai\n\n# Small n (10)\n./gen -n 10 -k 0 -type zero_k\n./gen -n 10 -k 10 -type min_ai\n./gen -n 10 -k 100 -type max_ai\n./gen -n 10 -k 20 -type random\n./gen -n 10 -k 50 -type ascending\n./gen -n 10 -k 50 -type descending\n\n# Middle n (50)\n./gen -n 50 -k 0 -type zero_k\n./gen -n 50 -k 50 -type min_ai\n./gen -n 50 -k 5000 -type large_k\n./gen -n 50 -k 100 -type random\n./gen -n 50 -k 500 -type max_instruments\n./gen -n 50 -k 50 -type min_instruments\n\n# Maximum n (100)\n./gen -n 100 -k 0 -type zero_k\n./gen -n 100 -k 100 -type min_ai\n./gen -n 100 -k 10000 -type large_k\n./gen -n 100 -k 5000 -type random\n./gen -n 100 -k 1000 -type ascending\n./gen -n 100 -k 1000 -type descending\n./gen -n 100 -k 1000 -type min_ai\n./gen -n 100 -k 1000 -type max_ai\n./gen -n 100 -k 100 -type max_instruments\n./gen -n 100 -k 50 -type min_instruments\n\n# Edge cases\n./gen -n 1 -k 10000 -type min_ai\n./gen -n 100 -k 1 -type max_ai\n./gen -n 1 -k 0 -type random\n./gen -n 100 -k 0 -type random\n./gen -n 100 -k 10000 -type min_ai\n./gen -n 100 -k 10000 -type random\n\n# Additional diverse random tests\n./gen -n 50 -k 250 -type random\n./gen -n 50 -k 250 -type max_instruments\n./gen -n 50 -k 2 -type min_ai\n./gen -n 50 -k 500 -type min_instruments\n./gen -n 50 -k 2500 -type descending\n\n./gen -n 80 -k 4000 -type random\n./gen -n 80 -k 0 -type zero_k\n./gen -n 80 -k 80 -type min_ai\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:40:51.870548",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "507/B",
      "title": "Problem 507/B",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "",
      "memory_limit": "",
      "input_spec": "",
      "output_spec": "",
      "sample_tests": "",
      "description": "",
      "solutions": [],
      "code_examples": [],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int r = inf.readInt(1, 100000, \"r\");\n    inf.readSpace();\n    int x = inf.readInt(-100000, 100000, \"x\");\n    inf.readSpace();\n    int y = inf.readInt(-100000, 100000, \"y\");\n    inf.readSpace();\n    int x_prime = inf.readInt(-100000, 100000, \"x'\");\n    inf.readSpace();\n    int y_prime = inf.readInt(-100000, 100000, \"y'\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int r = inf.readInt(1, 100000, \"r\");\n    inf.readSpace();\n    int x = inf.readInt(-100000, 100000, \"x\");\n    inf.readSpace();\n    int y = inf.readInt(-100000, 100000, \"y\");\n    inf.readSpace();\n    int x_prime = inf.readInt(-100000, 100000, \"x'\");\n    inf.readSpace();\n    int y_prime = inf.readInt(-100000, 100000, \"y'\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int r = inf.readInt(1, 100000, \"r\");\n    inf.readSpace();\n    int x = inf.readInt(-100000, 100000, \"x\");\n    inf.readSpace();\n    int y = inf.readInt(-100000, 100000, \"y\");\n    inf.readSpace();\n    int x_prime = inf.readInt(-100000, 100000, \"x'\");\n    inf.readSpace();\n    int y_prime = inf.readInt(-100000, 100000, \"y'\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    // Read parameters\n    string type = opt<string>(\"type\", \"random\");\n    int r = opt<int>(\"r\", -1);\n    int x0 = opt<int>(\"x0\", -1e6);\n    int y0 = opt<int>(\"y0\", -1e6);\n\n    // Generate or validate r\n    if (r == -1)\n        r = rnd.next(1, 100000);\n    else\n        ensure(1 <= r && r <= 100000);\n\n    // Generate or validate x0, y0\n    if (x0 == (int)-1e6)\n        x0 = rnd.next(-100000, 100000);\n    else\n        ensure(-100000 <= x0 && x0 <= 100000);\n\n    if (y0 == (int)-1e6)\n        y0 = rnd.next(-100000, 100000);\n    else\n        ensure(-100000 <= y0 && y0 <= 100000);\n\n    // x1, y1 will be computed based on type\n    int x1, y1;\n\n    if (type == \"zero\") {\n        // Destination is the same as starting point\n        x1 = x0;\n        y1 = y0;\n    } else if (type == \"exact\") {\n        // D = 2*r*k, k is integer\n        int k = rnd.next(1, 1000);\n        int D = 2 * r * k;\n\n        // Generate a point at distance D from (x0,y0)\n        double angle = rnd.next(0.0, 2 * M_PI);\n        double dx = D * cos(angle);\n        double dy = D * sin(angle);\n        x1 = x0 + int(round(dx));\n        y1 = y0 + int(round(dy));\n\n        // Ensure x1, y1 within bounds\n        int attempts = 0;\n        while ((x1 < -100000 || x1 > 100000 || y1 < -100000 || y1 > 100000) && attempts < 10) {\n            angle = rnd.next(0.0, 2 * M_PI);\n            dx = D * cos(angle);\n            dy = D * sin(angle);\n            x1 = x0 + int(round(dx));\n            y1 = y0 + int(round(dy));\n            attempts++;\n        }\n        if ((x1 < -100000 || x1 > 100000 || y1 < -100000 || y1 > 100000)) {\n            x1 = x0;\n            y1 = y0;\n        }\n    } else if (type == \"off_by_one_above\") {\n        // D = 2*r*k + epsilon\n        int k = rnd.next(1,1000);\n        double epsilon = rnd.next(1e-6, 1.0);\n        double D = 2.0 * r * k + epsilon;\n        double angle = rnd.next(0.0, 2 * M_PI);\n        double dx = D * cos(angle);\n        double dy = D * sin(angle);\n        x1 = x0 + int(round(dx));\n        y1 = y0 + int(round(dy));\n\n        // Ensure x1, y1 within bounds\n        int attempts = 0;\n        while ((x1 < -100000 || x1 > 100000 || y1 < -100000 || y1 > 100000) && attempts < 10) {\n            angle = rnd.next(0.0, 2 * M_PI);\n            dx = D * cos(angle);\n            dy = D * sin(angle);\n            x1 = x0 + int(round(dx));\n            y1 = y0 + int(round(dy));\n            attempts++;\n        }\n        if ((x1 < -100000 || x1 > 100000 || y1 < -100000 || y1 > 100000)) {\n            x1 = x0;\n            y1 = y0;\n        }\n    } else if (type == \"off_by_one_below\") {\n        // D = 2*r*k - epsilon\n        int k = rnd.next(1,1000);\n        double epsilon = rnd.next(1e-6, 1.0);\n        double D = max(0.0, 2.0 * r * k - epsilon);\n        double angle = rnd.next(0.0, 2 * M_PI);\n        double dx = D * cos(angle);\n        double dy = D * sin(angle);\n        x1 = x0 + int(round(dx));\n        y1 = y0 + int(round(dy));\n\n        // Ensure x1, y1 within bounds\n        int attempts = 0;\n        while ((x1 < -100000 || x1 > 100000 || y1 < -100000 || y1 > 100000) && attempts < 10) {\n            angle = rnd.next(0.0, 2 * M_PI);\n            dx = D * cos(angle);\n            dy = D * sin(angle);\n            x1 = x0 + int(round(dx));\n            y1 = y0 + int(round(dy));\n            attempts++;\n        }\n        if ((x1 < -100000 || x1 > 100000 || y1 < -100000 || y1 > 100000)) {\n            x1 = x0;\n            y1 = y0;\n        }\n    } else if (type == \"max_values\") {\n        r = 100000;\n        x0 = 100000;\n        y0 = 100000;\n        x1 = -100000;\n        y1 = -100000;\n    } else if (type == \"min_values\") {\n        r = 1;\n        x0 = -100000;\n        y0 = -100000;\n        x1 = 100000;\n        y1 = 100000;\n    } else if (type == \"random\") {\n        x1 = rnd.next(-100000, 100000);\n        y1 = rnd.next(-100000, 100000);\n    } else {\n        x1 = x0;\n        y1 = y0;\n    }\n\n    // Output the test case\n    printf(\"%d %d %d %d %d\\n\", r, x0, y0, x1, y1);\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    // Read parameters\n    string type = opt<string>(\"type\", \"random\");\n    int r = opt<int>(\"r\", -1);\n    int x0 = opt<int>(\"x0\", -1e6);\n    int y0 = opt<int>(\"y0\", -1e6);\n\n    // Generate or validate r\n    if (r == -1)\n        r = rnd.next(1, 100000);\n    else\n        ensure(1 <= r && r <= 100000);\n\n    // Generate or validate x0, y0\n    if (x0 == (int)-1e6)\n        x0 = rnd.next(-100000, 100000);\n    else\n        ensure(-100000 <= x0 && x0 <= 100000);\n\n    if (y0 == (int)-1e6)\n        y0 = rnd.next(-100000, 100000);\n    else\n        ensure(-100000 <= y0 && y0 <= 100000);\n\n    // x1, y1 will be computed based on type\n    int x1, y1;\n\n    if (type == \"zero\") {\n        // Destination is the same as starting point\n        x1 = x0;\n        y1 = y0;\n    } else if (type == \"exact\") {\n        // D = 2*r*k, k is integer\n        int k = rnd.next(1, 1000);\n        int D = 2 * r * k;\n\n        // Generate a point at distance D from (x0,y0)\n        double angle = rnd.next(0.0, 2 * M_PI);\n        double dx = D * cos(angle);\n        double dy = D * sin(angle);\n        x1 = x0 + int(round(dx));\n        y1 = y0 + int(round(dy));\n\n        // Ensure x1, y1 within bounds\n        int attempts = 0;\n        while ((x1 < -100000 || x1 > 100000 || y1 < -100000 || y1 > 100000) && attempts < 10) {\n            angle = rnd.next(0.0, 2 * M_PI);\n            dx = D * cos(angle);\n            dy = D * sin(angle);\n            x1 = x0 + int(round(dx));\n            y1 = y0 + int(round(dy));\n            attempts++;\n        }\n        if ((x1 < -100000 || x1 > 100000 || y1 < -100000 || y1 > 100000)) {\n            x1 = x0;\n            y1 = y0;\n        }\n    } else if (type == \"off_by_one_above\") {\n        // D = 2*r*k + epsilon\n        int k = rnd.next(1,1000);\n        double epsilon = rnd.next(1e-6, 1.0);\n        double D = 2.0 * r * k + epsilon;\n        double angle = rnd.next(0.0, 2 * M_PI);\n        double dx = D * cos(angle);\n        double dy = D * sin(angle);\n        x1 = x0 + int(round(dx));\n        y1 = y0 + int(round(dy));\n\n        // Ensure x1, y1 within bounds\n        int attempts = 0;\n        while ((x1 < -100000 || x1 > 100000 || y1 < -100000 || y1 > 100000) && attempts < 10) {\n            angle = rnd.next(0.0, 2 * M_PI);\n            dx = D * cos(angle);\n            dy = D * sin(angle);\n            x1 = x0 + int(round(dx));\n            y1 = y0 + int(round(dy));\n            attempts++;\n        }\n        if ((x1 < -100000 || x1 > 100000 || y1 < -100000 || y1 > 100000)) {\n            x1 = x0;\n            y1 = y0;\n        }\n    } else if (type == \"off_by_one_below\") {\n        // D = 2*r*k - epsilon\n        int k = rnd.next(1,1000);\n        double epsilon = rnd.next(1e-6, 1.0);\n        double D = max(0.0, 2.0 * r * k - epsilon);\n        double angle = rnd.next(0.0, 2 * M_PI);\n        double dx = D * cos(angle);\n        double dy = D * sin(angle);\n        x1 = x0 + int(round(dx));\n        y1 = y0 + int(round(dy));\n\n        // Ensure x1, y1 within bounds\n        int attempts = 0;\n        while ((x1 < -100000 || x1 > 100000 || y1 < -100000 || y1 > 100000) && attempts < 10) {\n            angle = rnd.next(0.0, 2 * M_PI);\n            dx = D * cos(angle);\n            dy = D * sin(angle);\n            x1 = x0 + int(round(dx));\n            y1 = y0 + int(round(dy));\n            attempts++;\n        }\n        if ((x1 < -100000 || x1 > 100000 || y1 < -100000 || y1 > 100000)) {\n            x1 = x0;\n            y1 = y0;\n        }\n    } else if (type == \"max_values\") {\n        r = 100000;\n        x0 = 100000;\n        y0 = 100000;\n        x1 = -100000;\n        y1 = -100000;\n    } else if (type == \"min_values\") {\n        r = 1;\n        x0 = -100000;\n        y0 = -100000;\n        x1 = 100000;\n        y1 = 100000;\n    } else if (type == \"random\") {\n        x1 = rnd.next(-100000, 100000);\n        y1 = rnd.next(-100000, 100000);\n    } else {\n        x1 = x0;\n        y1 = y0;\n    }\n\n    // Output the test case\n    printf(\"%d %d %d %d %d\\n\", r, x0, y0, x1, y1);\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -type zero\n./gen -type exact\n./gen -type exact -r 1\n./gen -type exact -r 100000\n./gen -type exact -r 50000\n./gen -type off_by_one_above\n./gen -type off_by_one_above -r 1\n./gen -type off_by_one_above -r 100000\n./gen -type off_by_one_below\n./gen -type off_by_one_below -r 1\n./gen -type off_by_one_below -r 100000\n./gen -type max_values\n./gen -type min_values\n./gen -type random\n./gen -type random\n./gen -type random\n./gen -type random\n./gen -type random\n./gen -type random\n./gen -type exact\n./gen -type off_by_one_below\n./gen -type off_by_one_above\n./gen -type random\n./gen -type random\n./gen -type random\n./gen -type zero\n./gen -type max_values\n./gen -type off_by_one_above -r 100000 -x0 0 -y0 0\n./gen -type off_by_one_below -r 50000 -x0 -50000 -y0 50000\n./gen -type exact -r 25000 -x0 30000 -y0 -30000\n./gen -type random\n./gen -type random\n./gen -type random\n./gen -type min_values\n./gen -type zero\n./gen -type exact -r 2 -x0 0 -y0 0\n./gen -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:40:53.818713",
        "total_tutorials": 0,
        "has_ai_judgment": false,
        "has_code_files": true
      }
    },
    {
      "problem_id": "507/C",
      "title": "C. Угадай, где выход!",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест1 секунда",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеВвод состоит из двух целых чисел, h, n (1 ≤ h ≤ 50, 1 ≤ n ≤ 2h).",
      "output_spec": "Выходные данныеВыведите единственное целое число, обозначающее количество вершин (не включая лист, в котором расположен выход), которые Amr посетит перед тем, как добраться до выхода, следуя этому алгоритму.",
      "sample_tests": "ПримерыВходные данныеСкопировать1 2Выходные данныеСкопировать2Входные данныеСкопировать2 3Выходные данныеСкопировать5Входные данныеСкопировать3 6Выходные данныеСкопировать10Входные данныеСкопировать10 1024Выходные данныеСкопировать2046",
      "description": "C. Угадай, где выход!\n\nограничение по времени на тест1 секунда\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвыводstdout\n\nВходные данныеВвод состоит из двух целых чисел, h, n (1 ≤ h ≤ 50, 1 ≤ n ≤ 2h).\n\nВходные данные\n\nВыходные данныеВыведите единственное целое число, обозначающее количество вершин (не включая лист, в котором расположен выход), которые Amr посетит перед тем, как добраться до выхода, следуя этому алгоритму.\n\nВыходные данные\n\nВходные данныеСкопировать1 2Выходные данныеСкопировать2Входные данныеСкопировать2 3Выходные данныеСкопировать5Входные данныеСкопировать3 6Выходные данныеСкопировать10Входные данныеСкопировать10 1024Выходные данныеСкопировать2046\n\nВходные данныеСкопировать1 2\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать2\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать2 3\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать5\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать3 6\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать10\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать10 1024\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать2046\n\nВыходные данныеСкопировать\n\nСкопировать\n\nПримечаниеПолное двоичное дерево высоты h— это двоичное дерево, состоящее из h + 1 уровня. Уровень 0 состоит из единственной вершины, которая называется корень, уровень h состоит из 2h вершин, которые называются листьями. Каждая вершина, не являющаяся листом, имеет ровно двух потомков, левого и правого. Следующая картина иллюстрирует третий тест из условия. Вершины помечены в порядке их посещения.",
      "solutions": [
        {
          "title": "Codeforces Round #287 (Div. 2) - Codeforces",
          "content": "Hello Codeforces!I'd like to invite you to Codeforces Round #287 (Div. 2). It'll be held on Friday, January 23rd at 19:00 MSK. and as usual Div. 1 participants can join out of competition.This is my first round so wish me luck! :)Great thanks to Maxim Akhmedov (Zlobober) for helping me preparing the contest, Alex Fetisov (AlexFetisov) for testing and giving useful tips regarding statements, Maria Belova (Delinur) for translating the statements into Russian and Mike Mirzayanov (MikeMirzayanov) for the great Polygon platform.The scoring distribution will be announced later.Good luck everyone and I hope you'll find the problems interesting.UPD #1 Score distribution will be standard 500-1000-1500-2000-2500.UPD #2 Contest finished, hope you enjoyed the problems. :)UPD #3 System testing finished.Winner of the contest is going to be disqualified due to \"Do not use harsh, rude or misleading handle.\" part of Codeforces rules.So congratulations to the winners:chickennethsnowqcrqgx175mikeyue_tcDennordKilluaZoldyckUPD #4 You can find the editorial here.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/15930",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1057
        },
        {
          "title": "Codeforces Round #287 (Div. 2) Editorial - Codeforces",
          "content": "507A - Amr and MusicProblem: We have to split the number k into maximum number of elements of ai such that their sum is less than or equal to k.Hint: To maximize the answer we have to split the number into the smallest numbers possible.Solution: So and since the limits are small we can pick up the smallest element of the array and subtract it from k, and we keep doing this n times or until the smallest number is larger than k. Another solution is to sort the array in non-decreasing order and go on the same way.Time complexity: or Implementation: 9529124 .507B - Amr and PinsProblem: We have a circle with radius R at position (x, y) and we want to move it to (x', y') with minimum moves possible. A move is to choose an arbitrary point on the border of the circle and rotate the circle around it with arbitrary angle.Hint: What is the shortest path between two points? A direct line. So moving the center on that line with maximum move possible each time will guarantee minimal number of moves.Solution: Let's draw a straight line between the two centers.Clearly to move the center with maximum distance we need to rotate it around the intersection of the line and the circle with 180 degrees. So the maximum distance we can move the center each time is 2 * R. Let's continue moving the center with 2 * R distance each time until the two circles intersects. Now obviously we can make the center moves into its final position by rotating it around one of the intersection points of the two circles until it reaches the final destination.Every time we make the circle moves 2 * R times except the last move it'll be  ≤ 2 * R. Assume that the initial distance between the two points is d So the solution to the problem will be .Time complexity: You have to be careful of precision errors. Here is a code that used only integer arithmetic operations 9529147.507C - Guess Your Way Out!Hint: Simulate the algorithm until we reach a leaf node assume that it's not the exit. Now the question is Are there some nodes that are guaranteed to be visited before trying to reach the exit again?Solution: The first observation is that in order to return to a parent we will have to visit all nodes of the right or the left subtree of some node first. Now imagine we are in the situation below where E is the exit.By applying the algorithm we'll reach node X. Both the E and X are in different subtrees of the root. Which means before going to the proper subtree in which the Exit exists we'll have to visit all the nodes of the left subtree (marked in red).This means we have to get the node which the Exit and the current leaf node X are in different subtrees which will be the least common ancestor (LCA) of the two nodes. Assume the subtree height is h1. This means we visited node. By adding the nodes above the subtree which we visited during executing the string for the first time the total number of visited nodes will be . Now let's go to the other subtree. Obviously we don't need any other nodes except this subtree. So let's do the same we did to the original tree to this subtree. Execute the algorithm until we reach a leaf node, get the LCA, add to the solution where h2 is the height of the subtree of the LCA node where the leaf node exists. And so on we keep applying the rules until after executing the algorithm we will reach the exit.Also we can do the same operations in O(h) by beginning to move from the root, if the exit is located to the left we go to the left and ans++ and then set the next command to 'R' else if it is located to the right we will visited the whole left subtree so we add the left subtree nodes to the answer and then set the next command to 'L' and so on.Time complexity: or Challenge: What if the pattern is given as an input (e.g. \"LRRLLRRRLRLRLRR...\"), How can this problem be solved?Implementation: 9529181507D - The Maths LectureHint: Dynamic programming problem. To handle repetitions we have to construct the number from right to the left and calculate the answer when we reach a number equivalent to 0 modulo k.Solution: Let's define as a recursive functions calculates the number of numbers consisting of n digits satisfying the conditions of the problem and with a specific suffix of length i Si such that .We want to avoid repetition so by constructing the number from the right to the left when we reach a state with j = 0 with suffix  ≠ 0 we return the answer immediately so any other suffix that contains this suffix won't b calculated.So the base cases are , .So state transitions will be (We add a digit to the left).And we can handle j = 0 case coming from a zero suffix easily with a boolean variable we set to true when we use a digit  ≠ 0 in constructing the number.Time complexity: Implementation: 9529210507E - Breaking GoodHint: Consider we've chosen a certain path with length d where d is the length of the shortest path from 1 to n and it has x edges that are working. Assume that y is the total number of edges that are working in the whole country. So we need to make d - x changes (to make the malfunctioning edges on the path work) and y - x changes (to blow up all other edges that don't lie on the path). So we will totally make d + y - 2 * x changes where d and y are constants. So the optimal solution will depend only on number of working edges along the path. So we'll have to maximize this number!Solution: We will use dynamic programming on all nodes that lies on some shortest path. In other words, every node x that satisfies that the shortest path from 1 to x + the shortest path from x to n equals d where d is the length of the shortest path from 1 to n. Let's define Max[x] is the maximum number of working edges along some shortest path from 1 to x. We can calculate the value Max[x] for all nodes by dynamic programming by traversing the nodes in order of increasing shortest path from node 1. So at the end we'll make d + y - 2 * Max[n] changes. We can get them easily by retrieving the chosen optimal path.Time complexity: Implementation: 9529272",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/15975",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 507\\s*C"
          },
          "content_length": 6032
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #287 (Div. 2) - Codeforces - Code 1",
          "code": "your                                               eyes",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15930",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #287 (Div. 2) - Codeforces - Code 2",
          "code": "are                                                moving",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15930",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #287 (Div. 2) - Codeforces - Code 3",
          "code": "from                                               left",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15930",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #287 (Div. 2) - Codeforces - Code 4",
          "code": "to                                                 right",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15930",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #287 (Div. 2) - Codeforces - Code 5",
          "code": "and                                                then",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15930",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #287 (Div. 2) - Codeforces - Code 6",
          "code": "from                                               right",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15930",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #287 (Div. 2) - Codeforces - Code 7",
          "code": "to                                                 left",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15930",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #287 (Div. 2) - Codeforces - Code 8",
          "code": "again                                              and",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15930",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #287 (Div. 2) - Codeforces - Code 9",
          "code": "again                                              to",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15930",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #287 (Div. 2) - Codeforces - Code 10",
          "code": "read                                               this",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15930",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #287 (Div. 2) - Codeforces - Code 11",
          "code": "лишь остаток после деления результата на номер m.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15930",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #287 (Div. 2) - Codeforces - Code 12",
          "code": "x = (1LL << (h-1)) + 1; y = 1 << h;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15930",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #287 (Div. 2) - Codeforces - Code 13",
          "code": "x = (1LL << (h-1)) + 1; y = 1 << h;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15930",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #287 (Div. 2) - Codeforces - Code 14",
          "code": "dist-=1e-12;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15930",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #287 (Div. 2) - Codeforces - Code 15",
          "code": "100000 100000 1 -100000 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15930",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #287 (Div. 2) - Codeforces - Code 16",
          "code": "100000 100000 0 -100000 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15930",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #287 (Div. 2) - Codeforces - Code 17",
          "code": "100000 100000 0 -100000 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15930",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #287 (Div. 2) - Codeforces - Code 18",
          "code": "dist = 200000;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15930",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #287 (Div. 2) - Codeforces - Code 19",
          "code": "cerr << dist;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15930",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #287 (Div. 2) - Codeforces - Code 20",
          "code": "2) Add cerr << dist; after subtracting 1e-12 from dist.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15930",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #287 (Div. 2) - Codeforces - Code 21",
          "code": "printf(\"%d\\n\", (int) ceil(hypot(x1 - x2, y1 - y2) / (2 * r)));",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15930",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #287 (Div. 2) - Codeforces - Code 22",
          "code": "6.28009e-012",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15930",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #287 (Div. 2) - Codeforces - Code 23",
          "code": "141081 99263 99774 -100000 -100000",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15930",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #287 (Div. 2) - Codeforces - Code 24",
          "code": "830699159852",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15930",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #287 (Div. 2) - Codeforces - Code 25",
          "code": "39 457181784666",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15930",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #287 (Div. 2) - Codeforces - Code 26",
          "code": "547231318312",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15930",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #287 (Div. 2) - Codeforces - Code 27",
          "code": "scanf(\"%lld\", &n);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15930",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #287 (Div. 2) - Codeforces - Code 28",
          "code": "integer value (2)\nC++98: bitset (unsigned long val);\nC++11: constexpr bitset (unsigned long long val) noexcept;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15930",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #287 (Div. 2) - Codeforces - Code 29",
          "code": "integer value (2)\nC++98: bitset (unsigned long val);\nC++11: constexpr bitset (unsigned long long val) noexcept;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15930",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #287 (Div. 2) - Codeforces - Code 30",
          "code": "1024 is on the right side",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15930",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #287 (Div. 2) Editorial - Codeforces - Code 1",
          "code": "public void solve(int testNumber, InputReader in, PrintWriter out) {\n        int h = in.nextInt();\n        long n = in.nextLong() - 1;\n        long res = 0;\n        for(int i = h - 1; 1; i >= 0; i--) {\n            if ((n >> i & 1L) == 1) {\n                res += 1L << i + 1;\n            } else {\n                res += 1;\n                n = ~n; //inversion\n            }\n        }\n        out.println(res);\n    }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15975",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #287 (Div. 2) Editorial - Codeforces - Code 2",
          "code": "public void solve(int testNumber, InputReader in, PrintWriter out) {\n        int h = in.nextInt();\n        long n = in.nextLong() - 1;\n        long res = 0;\n        for(int i = h - 1; 1; i >= 0; i--) {\n            if ((n >> i & 1L) == 1) {\n                res += 1L << i + 1;\n            } else {\n                res += 1;\n                n = ~n; //inversion\n            }\n        }\n        out.println(res);\n    }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15975",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #287 (Div. 2) Editorial - Codeforces - Code 3",
          "code": "for(int j = 1; j < K; j++)\n  for(int d = 0; d <= 9; d++)\n  {\n        long long modulo = (pow(10,i)*d + j) % K;\n        DP[i+1][modulo] += DP[i][j];\n        DP[i+1][modulo] %= M;\n  }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15975",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #287 (Div. 2) Editorial - Codeforces - Code 4",
          "code": "for(int j = 1; j < K; j++)\n  for(int d = 0; d <= 9; d++)\n  {\n        long long modulo = (pow(10,i)*d + j) % K;\n        DP[i+1][modulo] += DP[i][j];\n        DP[i+1][modulo] %= M;\n  }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15975",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #287 (Div. 2) Editorial - Codeforces - Code 5",
          "code": "cal[i][j] = sum x = 0..9 cal[i - 1][(j - x * 10 ^ (i - 1)) mod k]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15975",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #287 (Div. 2) Editorial - Codeforces - Code 6",
          "code": "cal[i][j] = sum l=0..k-1 p[i][l] * cal[i - 1][(j - l) mod k]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15975",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #287 (Div. 2) Editorial - Codeforces - Code 7",
          "code": "// handle base cases\nfor(int i = 1;i <= n;i++)\n  for(int j = 1;j < k-1;j++)\n     for(int x = 0;x < 10;x++)\n      count[i+1][(j+(x*10^i))%k]+=count[i][j]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15975",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #287 (Div. 2) Editorial - Codeforces - Code 8",
          "code": "// handle base cases\nfor(int i = 1;i <= n;i++)\n  for(int j = 1;j < k-1;j++)\n     for(int x = 0;x < 10;x++)\n      count[i+1][(j+(x*10^i))%k]+=count[i][j]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15975",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #287 (Div. 2) Editorial - Codeforces - Code 9",
          "code": "if(ind == n || (rem == 0 && change)) return 0;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15975",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #287 (Div. 2) Editorial - Codeforces - Code 10",
          "code": "if(ind == n) return 0;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15975",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #287 (Div. 2) Editorial - Codeforces - Code 11",
          "code": "(rem==0&&change) is true",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15975",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #287 (Div. 2) Editorial - Codeforces - Code 12",
          "code": "We want to avoid repetition so by constructing the number from the right to the left when we reach a state with j = 0 with suffix  ≠ 0 we return the answer immediately so any other suffix that contains this suffix won't b calculated.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15975",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #287 (Div. 2) Editorial - Codeforces - Code 13",
          "code": "We want to avoid repetition so by constructing the number from the right to the left when we reach a state with j = 0 with suffix  ≠ 0 we return the answer immediately so any other suffix that contains this suffix won't b calculated.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15975",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #287 (Div. 2) Editorial - Codeforces - Code 14",
          "code": "pair<pair<int, int>, int>",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15975",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #287 (Div. 2) Editorial - Codeforces - Code 15",
          "code": "{{distance from 1, no. of bad roads in the shortest path from 1}, node}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15975",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #287 (Div. 2) Editorial - Codeforces - Code 16",
          "code": "#include<bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp> \nusing namespace std;\nusing namespace __gnu_pbds;\n#define intt int64_t \n \n\nvoid solve()\n{\n    intt n, m;\n    cin>>n>>m;\n    intt a, b, c;\n    vector<vector<pair<intt, intt>>> v(n+1);\n    set<pair<intt, intt>> good, ngood;\n    for(int i=0;i<m;i++) \n    {\n        cin>>a>>b>>c;\n        v[a].push_back({b, c});\n        v[b].push_back({a, c});\n        if(a>b) swap(a, b);\n        if(c==1) good.insert({a, b});\n    }\n    \n    set<pair<pair<intt, intt>, intt>> q;\n    // {{distance from 1, bad roads in shortest path}, node number}\n    q.insert({{0, 0}, 1});\n    vector<intt> dis(n+1, 2e9), sp(n+1, 2e9);\n    dis[1]=0;\n    sp[1]=0;\n\n    // dijkstras with (priority : min distance > min bad roads)\n    while(!q.empty())\n    {\n        auto k = *q.begin();\n        q.erase(q.begin());\n        if(dis[k.second]<k.first.first) continue;\n        else if(dis[k.second]<k.first.first and sp[k.second]<k.first.second) continue;\n        for(auto i:v[k.second])\n        {\n            if(dis[k.second]+1<dis[i.first])\n            {\n                dis[i.first]=dis[k.second]+1;\n                sp[i.first]=sp[k.second];\n                if(i.second==0) sp[i.first]++;\n                q.insert({{dis[i.first], sp[i.first]}, i.first});\n            }\n            else if(dis[k.second]+1==dis[i.first])\n            {\n                if(i.second==1 and sp[k.second]<sp[i.first])\n                {\n                    sp[i.first] = sp[k.second];\n                    q.insert({{dis[i.first], sp[i.first]}, i.first});\n                }\n                else if(i.second==0 and sp[k.second]+1<sp[i.first])\n                {\n                    sp[i.first] = sp[k.second]+1;\n                    q.insert({{dis[i.first], sp[i.first]}, i.first});\n                }\n            }\n        }        \n    }\n    intt curr = n;\n    while(curr>1)\n    {\n        intt mn = 2e9, z;\n        for(auto i:v[curr])\n        {\n            if(dis[i.first]==dis[curr]-1 and sp[i.first]<mn) z = i.first;\n        }\n        if(z<curr)\n        {\n            if(sp[curr]-1==sp[z]) ngood.insert({z, curr});\n            else if(sp[curr]==sp[z]) good.erase({z, curr});\n        }\n        else\n        {\n            if(sp[curr]-1==sp[z]) ngood.insert({curr, z});\n            else if(sp[curr]==sp[z]) good.erase({curr, z});\n        }\n        curr = z;\n    }\n    intt ans = good.size();\n    ans += ngood.size();\n    cout<<ans<<\"\\n\";\n    for(auto i:good) cout<<i.first<<\" \"<<i.second<<\" 0\\n\";\n    for(auto i:ngood) cout<<i.first<<\" \"<<i.second<<\" 1\\n\";\n}\n \nint main()\n{\n    // ios_base::sync_with_stdio(false);\n    // cin.tie(NULL);\n    int t=1;\n    // cin>>t;\n    while(t--)\n    {\n        solve();\n    }\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/15975",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #287 (Div. 2) Editorial - Codeforces - Code 17",
          "code": "#include<bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp> \nusing namespace std;\nusing namespace __gnu_pbds;\n#define intt int64_t \n \n\nvoid solve()\n{\n    intt n, m;\n    cin>>n>>m;\n    intt a, b, c;\n    vector<vector<pair<intt, intt>>> v(n+1);\n    set<pair<intt, intt>> good, ngood;\n    for(int i=0;i<m;i++) \n    {\n        cin>>a>>b>>c;\n        v[a].push_back({b, c});\n        v[b].push_back({a, c});\n        if(a>b) swap(a, b);\n        if(c==1) good.insert({a, b});\n    }\n    \n    set<pair<pair<intt, intt>, intt>> q;\n    // {{distance from 1, bad roads in shortest path}, node number}\n    q.insert({{0, 0}, 1});\n    vector<intt> dis(n+1, 2e9), sp(n+1, 2e9);\n    dis[1]=0;\n    sp[1]=0;\n\n    // dijkstras with (priority : min distance > min bad roads)\n    while(!q.empty())\n    {\n        auto k = *q.begin();\n        q.erase(q.begin());\n        if(dis[k.second]<k.first.first) continue;\n        else if(dis[k.second]<k.first.first and sp[k.second]<k.first.second) continue;\n        for(auto i:v[k.second])\n        {\n            if(dis[k.second]+1<dis[i.first])\n            {\n                dis[i.first]=dis[k.second]+1;\n                sp[i.first]=sp[k.second];\n                if(i.second==0) sp[i.first]++;\n                q.insert({{dis[i.first], sp[i.first]}, i.first});\n            }\n            else if(dis[k.second]+1==dis[i.first])\n            {\n                if(i.second==1 and sp[k.second]<sp[i.first])\n                {\n                    sp[i.first] = sp[k.second];\n                    q.insert({{dis[i.first], sp[i.first]}, i.first});\n                }\n                else if(i.second==0 and sp[k.second]+1<sp[i.first])\n                {\n                    sp[i.first] = sp[k.second]+1;\n                    q.insert({{dis[i.first], sp[i.first]}, i.first});\n                }\n            }\n        }        \n    }\n    intt curr = n;\n    while(curr>1)\n    {\n        intt mn = 2e9, z;\n        for(auto i:v[curr])\n        {\n            if(dis[i.first]==dis[curr]-1 and sp[i.first]<mn) z = i.first;\n        }\n        if(z<curr)\n        {\n            if(sp[curr]-1==sp[z]) ngood.insert({z, curr});\n            else if(sp[curr]==sp[z]) good.erase({z, curr});\n        }\n        else\n        {\n            if(sp[curr]-1==sp[z]) ngood.insert({curr, z});\n            else if(sp[curr]==sp[z]) good.erase({curr, z});\n        }\n        curr = z;\n    }\n    intt ans = good.size();\n    ans += ngood.size();\n    cout<<ans<<\"\\n\";\n    for(auto i:good) cout<<i.first<<\" \"<<i.second<<\" 0\\n\";\n    for(auto i:ngood) cout<<i.first<<\" \"<<i.second<<\" 1\\n\";\n}\n \nint main()\n{\n    // ios_base::sync_with_stdio(false);\n    // cin.tie(NULL);\n    int t=1;\n    // cin>>t;\n    while(t--)\n    {\n        solve();\n    }\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/15975",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int h = inf.readInt(1, 50, \"h\");\n    inf.readSpace();\n    long long maxN = (1LL << h);\n    long long n = inf.readLong(1LL, maxN, \"n\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int h = inf.readInt(1, 50, \"h\");\n    inf.readSpace();\n    long long maxN = (1LL << h);\n    long long n = inf.readLong(1LL, maxN, \"n\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int h = inf.readInt(1, 50, \"h\");\n    inf.readSpace();\n    long long maxN = (1LL << h);\n    long long n = inf.readLong(1LL, maxN, \"n\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    \n    int h = opt<int>(\"h\");\n    // Optional parameters\n    long long n = opt<long long>(\"n\", -1LL); // default -1, meaning not provided\n    string type = opt<string>(\"type\", \"random\");\n    \n    // Check h\n    ensuref(1 <= h && h <= 50, \"h must be between 1 and 50 inclusive\");\n    \n    long long max_n = (1LL << h);\n    \n    if (n == -1) {\n        // n is not provided, determine n based on type\n        if (type == \"leftmost\") {\n            n = 1LL;\n        } else if (type == \"rightmost\") {\n            n = max_n;\n        } else if (type == \"middle\") {\n            n = max_n / 2;\n            if (n == 0) n = 1; // Handle the case when h=0\n        } else if (type == \"random\") {\n            n = rnd.next(1LL, max_n);\n        } else {\n            // Invalid type\n            fprintf(stderr, \"Invalid type: %s\\n\", type.c_str());\n            exit(1);\n        }\n    } else {\n        // n is provided, check its validity\n        ensuref(1LL <= n && n <= max_n, \"n must be between 1 and 2^h inclusive\");\n    }\n    \n    // Output h and n\n    printf(\"%d %lld\\n\", h, n);\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    \n    int h = opt<int>(\"h\");\n    // Optional parameters\n    long long n = opt<long long>(\"n\", -1LL); // default -1, meaning not provided\n    string type = opt<string>(\"type\", \"random\");\n    \n    // Check h\n    ensuref(1 <= h && h <= 50, \"h must be between 1 and 50 inclusive\");\n    \n    long long max_n = (1LL << h);\n    \n    if (n == -1) {\n        // n is not provided, determine n based on type\n        if (type == \"leftmost\") {\n            n = 1LL;\n        } else if (type == \"rightmost\") {\n            n = max_n;\n        } else if (type == \"middle\") {\n            n = max_n / 2;\n            if (n == 0) n = 1; // Handle the case when h=0\n        } else if (type == \"random\") {\n            n = rnd.next(1LL, max_n);\n        } else {\n            // Invalid type\n            fprintf(stderr, \"Invalid type: %s\\n\", type.c_str());\n            exit(1);\n        }\n    } else {\n        // n is provided, check its validity\n        ensuref(1LL <= n && n <= max_n, \"n must be between 1 and 2^h inclusive\");\n    }\n    \n    // Output h and n\n    printf(\"%d %lld\\n\", h, n);\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Test h at minimum and n at minimum\n./gen -h 1 -n 1\n\n# Test h at minimum and n at maximum\n./gen -h 1 -n 2\n\n# Test h at minimum and type specified\n./gen -h 1 -type leftmost\n./gen -h 1 -type rightmost\n./gen -h 1 -type random\n\n# Test h at maximum and n at minimum\n./gen -h 50 -n 1\n\n# Test h at maximum and n at maximum\n./gen -h 50 -n 1125899906842624  # 2^50\n\n# Test h at maximum and type specified\n./gen -h 50 -type leftmost\n./gen -h 50 -type rightmost\n./gen -h 50 -type middle\n./gen -h 50 -type random\n\n# Test h in the middle and n at middle\n./gen -h 25 -n 16777216  # 2^24\n\n# Test h in the middle and type specified\n./gen -h 25 -type leftmost\n./gen -h 25 -type rightmost\n./gen -h 25 -type middle\n./gen -h 25 -type random\n\n# Test h being small but not minimum\n./gen -h 10 -n 512\n\n./gen -h 10 -type leftmost\n./gen -h 10 -type rightmost\n./gen -h 10 -type middle\n./gen -h 10 -type random\n\n# Test h at maximum when n is random\n./gen -h 50 -type random\n\n# Test h random and n random\n./gen -h 20 -n 1\n./gen -h 20 -n 1048576  # 2^20\n\n./gen -h 20 -type leftmost\n./gen -h 20 -type rightmost\n./gen -h 20 -type middle\n./gen -h 20 -type random\n\n# Test h minimal and random n\n./gen -h 1 -type random\n\n# Additional random test cases with varying h\n./gen -h 30 -type random\n./gen -h 5 -type random\n./gen -h 49 -type random\n./gen -h 33 -type random\n./gen -h 17 -type random\n\n# Random test cases with h and n specified\n./gen -h 15 -n 16384  # 2^14\n./gen -h 15 -n 1\n./gen -h 15 -type middle\n\n./gen -h 40 -n 1\n./gen -h 40 -n 549755813888  # 2^39\n./gen -h 40 -type middle\n./gen -h 40 -type random\n\n# Test cases with h = 2\n./gen -h 2 -n 1\n./gen -h 2 -n 4\n./gen -h 2 -type leftmost\n./gen -h 2 -type rightmost\n./gen -h 2 -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:40:55.438255",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "507/D",
      "title": "D. The Maths Lecture",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputInput consists of three integers n, k, m (1 ≤ n ≤ 1000, 1 ≤ k ≤ 100, 1 ≤ m ≤ 109).",
      "output_spec": "OutputPrint the required number modulo m.",
      "sample_tests": "ExamplesInputCopy1 2 1000OutputCopy4InputCopy2 2 1000OutputCopy45InputCopy5 3 1103OutputCopy590",
      "description": "D. The Maths Lecture\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputInput consists of three integers n, k, m (1 ≤ n ≤ 1000, 1 ≤ k ≤ 100, 1 ≤ m ≤ 109).\n\nOutputPrint the required number modulo m.\n\nInputCopy1 2 1000OutputCopy4InputCopy2 2 1000OutputCopy45InputCopy5 3 1103OutputCopy590\n\nInputCopy1 2 1000\n\nOutputCopy4\n\nInputCopy2 2 1000\n\nOutputCopy45\n\nInputCopy5 3 1103\n\nOutputCopy590\n\nNoteA suffix of a string S is a non-empty string that can be obtained by removing some number (possibly, zero) of first characters from S.",
      "solutions": [
        {
          "title": "Codeforces Round #287 (Div. 2) - Codeforces",
          "content": "Hello Codeforces!I'd like to invite you to Codeforces Round #287 (Div. 2). It'll be held on Friday, January 23rd at 19:00 MSK. and as usual Div. 1 participants can join out of competition.This is my first round so wish me luck! :)Great thanks to Maxim Akhmedov (Zlobober) for helping me preparing the contest, Alex Fetisov (AlexFetisov) for testing and giving useful tips regarding statements, Maria Belova (Delinur) for translating the statements into Russian and Mike Mirzayanov (MikeMirzayanov) for the great Polygon platform.The scoring distribution will be announced later.Good luck everyone and I hope you'll find the problems interesting.UPD #1 Score distribution will be standard 500-1000-1500-2000-2500.UPD #2 Contest finished, hope you enjoyed the problems. :)UPD #3 System testing finished.Winner of the contest is going to be disqualified due to \"Do not use harsh, rude or misleading handle.\" part of Codeforces rules.So congratulations to the winners:chickennethsnowqcrqgx175mikeyue_tcDennordKilluaZoldyckUPD #4 You can find the editorial here.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/15930",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1057
        },
        {
          "title": "Codeforces Round #287 (Div. 2) Editorial - Codeforces",
          "content": "507A - Amr and MusicProblem: We have to split the number k into maximum number of elements of ai such that their sum is less than or equal to k.Hint: To maximize the answer we have to split the number into the smallest numbers possible.Solution: So and since the limits are small we can pick up the smallest element of the array and subtract it from k, and we keep doing this n times or until the smallest number is larger than k. Another solution is to sort the array in non-decreasing order and go on the same way.Time complexity: or Implementation: 9529124 .507B - Amr and PinsProblem: We have a circle with radius R at position (x, y) and we want to move it to (x', y') with minimum moves possible. A move is to choose an arbitrary point on the border of the circle and rotate the circle around it with arbitrary angle.Hint: What is the shortest path between two points? A direct line. So moving the center on that line with maximum move possible each time will guarantee minimal number of moves.Solution: Let's draw a straight line between the two centers.Clearly to move the center with maximum distance we need to rotate it around the intersection of the line and the circle with 180 degrees. So the maximum distance we can move the center each time is 2 * R. Let's continue moving the center with 2 * R distance each time until the two circles intersects. Now obviously we can make the center moves into its final position by rotating it around one of the intersection points of the two circles until it reaches the final destination.Every time we make the circle moves 2 * R times except the last move it'll be  ≤ 2 * R. Assume that the initial distance between the two points is d So the solution to the problem will be .Time complexity: You have to be careful of precision errors. Here is a code that used only integer arithmetic operations 9529147.507C - Guess Your Way Out!Hint: Simulate the algorithm until we reach a leaf node assume that it's not the exit. Now the question is Are there some nodes that are guaranteed to be visited before trying to reach the exit again?Solution: The first observation is that in order to return to a parent we will have to visit all nodes of the right or the left subtree of some node first. Now imagine we are in the situation below where E is the exit.By applying the algorithm we'll reach node X. Both the E and X are in different subtrees of the root. Which means before going to the proper subtree in which the Exit exists we'll have to visit all the nodes of the left subtree (marked in red).This means we have to get the node which the Exit and the current leaf node X are in different subtrees which will be the least common ancestor (LCA) of the two nodes. Assume the subtree height is h1. This means we visited node. By adding the nodes above the subtree which we visited during executing the string for the first time the total number of visited nodes will be . Now let's go to the other subtree. Obviously we don't need any other nodes except this subtree. So let's do the same we did to the original tree to this subtree. Execute the algorithm until we reach a leaf node, get the LCA, add to the solution where h2 is the height of the subtree of the LCA node where the leaf node exists. And so on we keep applying the rules until after executing the algorithm we will reach the exit.Also we can do the same operations in O(h) by beginning to move from the root, if the exit is located to the left we go to the left and ans++ and then set the next command to 'R' else if it is located to the right we will visited the whole left subtree so we add the left subtree nodes to the answer and then set the next command to 'L' and so on.Time complexity: or Challenge: What if the pattern is given as an input (e.g. \"LRRLLRRRLRLRLRR...\"), How can this problem be solved?Implementation: 9529181507D - The Maths LectureHint: Dynamic programming problem. To handle repetitions we have to construct the number from right to the left and calculate the answer when we reach a number equivalent to 0 modulo k.Solution: Let's define as a recursive functions calculates the number of numbers consisting of n digits satisfying the conditions of the problem and with a specific suffix of length i Si such that .We want to avoid repetition so by constructing the number from the right to the left when we reach a state with j = 0 with suffix  ≠ 0 we return the answer immediately so any other suffix that contains this suffix won't b calculated.So the base cases are , .So state transitions will be (We add a digit to the left).And we can handle j = 0 case coming from a zero suffix easily with a boolean variable we set to true when we use a digit  ≠ 0 in constructing the number.Time complexity: Implementation: 9529210507E - Breaking GoodHint: Consider we've chosen a certain path with length d where d is the length of the shortest path from 1 to n and it has x edges that are working. Assume that y is the total number of edges that are working in the whole country. So we need to make d - x changes (to make the malfunctioning edges on the path work) and y - x changes (to blow up all other edges that don't lie on the path). So we will totally make d + y - 2 * x changes where d and y are constants. So the optimal solution will depend only on number of working edges along the path. So we'll have to maximize this number!Solution: We will use dynamic programming on all nodes that lies on some shortest path. In other words, every node x that satisfies that the shortest path from 1 to x + the shortest path from x to n equals d where d is the length of the shortest path from 1 to n. Let's define Max[x] is the maximum number of working edges along some shortest path from 1 to x. We can calculate the value Max[x] for all nodes by dynamic programming by traversing the nodes in order of increasing shortest path from node 1. So at the end we'll make d + y - 2 * Max[n] changes. We can get them easily by retrieving the chosen optimal path.Time complexity: Implementation: 9529272",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/15975",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 507\\s*D"
          },
          "content_length": 6032
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #287 (Div. 2) - Codeforces - Code 1",
          "code": "your                                               eyes",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15930",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #287 (Div. 2) - Codeforces - Code 2",
          "code": "are                                                moving",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15930",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #287 (Div. 2) - Codeforces - Code 3",
          "code": "from                                               left",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15930",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #287 (Div. 2) - Codeforces - Code 4",
          "code": "to                                                 right",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15930",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #287 (Div. 2) - Codeforces - Code 5",
          "code": "and                                                then",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15930",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #287 (Div. 2) - Codeforces - Code 6",
          "code": "from                                               right",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15930",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #287 (Div. 2) - Codeforces - Code 7",
          "code": "to                                                 left",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15930",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #287 (Div. 2) - Codeforces - Code 8",
          "code": "again                                              and",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15930",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #287 (Div. 2) - Codeforces - Code 9",
          "code": "again                                              to",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15930",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #287 (Div. 2) - Codeforces - Code 10",
          "code": "read                                               this",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15930",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #287 (Div. 2) - Codeforces - Code 11",
          "code": "x = (1LL << (h-1)) + 1; y = 1 << h;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15930",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #287 (Div. 2) - Codeforces - Code 12",
          "code": "x = (1LL << (h-1)) + 1; y = 1 << h;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15930",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #287 (Div. 2) - Codeforces - Code 13",
          "code": "dist-=1e-12;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15930",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #287 (Div. 2) - Codeforces - Code 14",
          "code": "100000 100000 1 -100000 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15930",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #287 (Div. 2) - Codeforces - Code 15",
          "code": "100000 100000 0 -100000 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15930",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #287 (Div. 2) - Codeforces - Code 16",
          "code": "100000 100000 0 -100000 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15930",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #287 (Div. 2) - Codeforces - Code 17",
          "code": "dist = 200000;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15930",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #287 (Div. 2) - Codeforces - Code 18",
          "code": "cerr << dist;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15930",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #287 (Div. 2) - Codeforces - Code 19",
          "code": "2) Add cerr << dist; after subtracting 1e-12 from dist.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15930",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #287 (Div. 2) - Codeforces - Code 20",
          "code": "printf(\"%d\\n\", (int) ceil(hypot(x1 - x2, y1 - y2) / (2 * r)));",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15930",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #287 (Div. 2) - Codeforces - Code 21",
          "code": "6.28009e-012",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15930",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #287 (Div. 2) - Codeforces - Code 22",
          "code": "141081 99263 99774 -100000 -100000",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15930",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #287 (Div. 2) - Codeforces - Code 23",
          "code": "830699159852",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15930",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #287 (Div. 2) - Codeforces - Code 24",
          "code": "39 457181784666",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15930",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #287 (Div. 2) - Codeforces - Code 25",
          "code": "547231318312",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15930",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #287 (Div. 2) - Codeforces - Code 26",
          "code": "scanf(\"%lld\", &n);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15930",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #287 (Div. 2) - Codeforces - Code 27",
          "code": "integer value (2)\nC++98: bitset (unsigned long val);\nC++11: constexpr bitset (unsigned long long val) noexcept;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15930",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #287 (Div. 2) - Codeforces - Code 28",
          "code": "integer value (2)\nC++98: bitset (unsigned long val);\nC++11: constexpr bitset (unsigned long long val) noexcept;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15930",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #287 (Div. 2) - Codeforces - Code 29",
          "code": "1024 is on the right side",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15930",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #287 (Div. 2) Editorial - Codeforces - Code 1",
          "code": "public void solve(int testNumber, InputReader in, PrintWriter out) {\n        int h = in.nextInt();\n        long n = in.nextLong() - 1;\n        long res = 0;\n        for(int i = h - 1; 1; i >= 0; i--) {\n            if ((n >> i & 1L) == 1) {\n                res += 1L << i + 1;\n            } else {\n                res += 1;\n                n = ~n; //inversion\n            }\n        }\n        out.println(res);\n    }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15975",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #287 (Div. 2) Editorial - Codeforces - Code 2",
          "code": "public void solve(int testNumber, InputReader in, PrintWriter out) {\n        int h = in.nextInt();\n        long n = in.nextLong() - 1;\n        long res = 0;\n        for(int i = h - 1; 1; i >= 0; i--) {\n            if ((n >> i & 1L) == 1) {\n                res += 1L << i + 1;\n            } else {\n                res += 1;\n                n = ~n; //inversion\n            }\n        }\n        out.println(res);\n    }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15975",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #287 (Div. 2) Editorial - Codeforces - Code 3",
          "code": "for(int j = 1; j < K; j++)\n  for(int d = 0; d <= 9; d++)\n  {\n        long long modulo = (pow(10,i)*d + j) % K;\n        DP[i+1][modulo] += DP[i][j];\n        DP[i+1][modulo] %= M;\n  }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15975",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #287 (Div. 2) Editorial - Codeforces - Code 4",
          "code": "for(int j = 1; j < K; j++)\n  for(int d = 0; d <= 9; d++)\n  {\n        long long modulo = (pow(10,i)*d + j) % K;\n        DP[i+1][modulo] += DP[i][j];\n        DP[i+1][modulo] %= M;\n  }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15975",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #287 (Div. 2) Editorial - Codeforces - Code 5",
          "code": "cal[i][j] = sum x = 0..9 cal[i - 1][(j - x * 10 ^ (i - 1)) mod k]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15975",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #287 (Div. 2) Editorial - Codeforces - Code 6",
          "code": "cal[i][j] = sum l=0..k-1 p[i][l] * cal[i - 1][(j - l) mod k]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15975",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #287 (Div. 2) Editorial - Codeforces - Code 7",
          "code": "// handle base cases\nfor(int i = 1;i <= n;i++)\n  for(int j = 1;j < k-1;j++)\n     for(int x = 0;x < 10;x++)\n      count[i+1][(j+(x*10^i))%k]+=count[i][j]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15975",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #287 (Div. 2) Editorial - Codeforces - Code 8",
          "code": "// handle base cases\nfor(int i = 1;i <= n;i++)\n  for(int j = 1;j < k-1;j++)\n     for(int x = 0;x < 10;x++)\n      count[i+1][(j+(x*10^i))%k]+=count[i][j]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15975",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #287 (Div. 2) Editorial - Codeforces - Code 9",
          "code": "if(ind == n || (rem == 0 && change)) return 0;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15975",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #287 (Div. 2) Editorial - Codeforces - Code 10",
          "code": "if(ind == n) return 0;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15975",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #287 (Div. 2) Editorial - Codeforces - Code 11",
          "code": "(rem==0&&change) is true",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15975",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #287 (Div. 2) Editorial - Codeforces - Code 12",
          "code": "We want to avoid repetition so by constructing the number from the right to the left when we reach a state with j = 0 with suffix  ≠ 0 we return the answer immediately so any other suffix that contains this suffix won't b calculated.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15975",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #287 (Div. 2) Editorial - Codeforces - Code 13",
          "code": "We want to avoid repetition so by constructing the number from the right to the left when we reach a state with j = 0 with suffix  ≠ 0 we return the answer immediately so any other suffix that contains this suffix won't b calculated.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15975",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #287 (Div. 2) Editorial - Codeforces - Code 14",
          "code": "pair<pair<int, int>, int>",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15975",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #287 (Div. 2) Editorial - Codeforces - Code 15",
          "code": "{{distance from 1, no. of bad roads in the shortest path from 1}, node}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15975",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #287 (Div. 2) Editorial - Codeforces - Code 16",
          "code": "#include<bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp> \nusing namespace std;\nusing namespace __gnu_pbds;\n#define intt int64_t \n \n\nvoid solve()\n{\n    intt n, m;\n    cin>>n>>m;\n    intt a, b, c;\n    vector<vector<pair<intt, intt>>> v(n+1);\n    set<pair<intt, intt>> good, ngood;\n    for(int i=0;i<m;i++) \n    {\n        cin>>a>>b>>c;\n        v[a].push_back({b, c});\n        v[b].push_back({a, c});\n        if(a>b) swap(a, b);\n        if(c==1) good.insert({a, b});\n    }\n    \n    set<pair<pair<intt, intt>, intt>> q;\n    // {{distance from 1, bad roads in shortest path}, node number}\n    q.insert({{0, 0}, 1});\n    vector<intt> dis(n+1, 2e9), sp(n+1, 2e9);\n    dis[1]=0;\n    sp[1]=0;\n\n    // dijkstras with (priority : min distance > min bad roads)\n    while(!q.empty())\n    {\n        auto k = *q.begin();\n        q.erase(q.begin());\n        if(dis[k.second]<k.first.first) continue;\n        else if(dis[k.second]<k.first.first and sp[k.second]<k.first.second) continue;\n        for(auto i:v[k.second])\n        {\n            if(dis[k.second]+1<dis[i.first])\n            {\n                dis[i.first]=dis[k.second]+1;\n                sp[i.first]=sp[k.second];\n                if(i.second==0) sp[i.first]++;\n                q.insert({{dis[i.first], sp[i.first]}, i.first});\n            }\n            else if(dis[k.second]+1==dis[i.first])\n            {\n                if(i.second==1 and sp[k.second]<sp[i.first])\n                {\n                    sp[i.first] = sp[k.second];\n                    q.insert({{dis[i.first], sp[i.first]}, i.first});\n                }\n                else if(i.second==0 and sp[k.second]+1<sp[i.first])\n                {\n                    sp[i.first] = sp[k.second]+1;\n                    q.insert({{dis[i.first], sp[i.first]}, i.first});\n                }\n            }\n        }        \n    }\n    intt curr = n;\n    while(curr>1)\n    {\n        intt mn = 2e9, z;\n        for(auto i:v[curr])\n        {\n            if(dis[i.first]==dis[curr]-1 and sp[i.first]<mn) z = i.first;\n        }\n        if(z<curr)\n        {\n            if(sp[curr]-1==sp[z]) ngood.insert({z, curr});\n            else if(sp[curr]==sp[z]) good.erase({z, curr});\n        }\n        else\n        {\n            if(sp[curr]-1==sp[z]) ngood.insert({curr, z});\n            else if(sp[curr]==sp[z]) good.erase({curr, z});\n        }\n        curr = z;\n    }\n    intt ans = good.size();\n    ans += ngood.size();\n    cout<<ans<<\"\\n\";\n    for(auto i:good) cout<<i.first<<\" \"<<i.second<<\" 0\\n\";\n    for(auto i:ngood) cout<<i.first<<\" \"<<i.second<<\" 1\\n\";\n}\n \nint main()\n{\n    // ios_base::sync_with_stdio(false);\n    // cin.tie(NULL);\n    int t=1;\n    // cin>>t;\n    while(t--)\n    {\n        solve();\n    }\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/15975",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #287 (Div. 2) Editorial - Codeforces - Code 17",
          "code": "#include<bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp> \nusing namespace std;\nusing namespace __gnu_pbds;\n#define intt int64_t \n \n\nvoid solve()\n{\n    intt n, m;\n    cin>>n>>m;\n    intt a, b, c;\n    vector<vector<pair<intt, intt>>> v(n+1);\n    set<pair<intt, intt>> good, ngood;\n    for(int i=0;i<m;i++) \n    {\n        cin>>a>>b>>c;\n        v[a].push_back({b, c});\n        v[b].push_back({a, c});\n        if(a>b) swap(a, b);\n        if(c==1) good.insert({a, b});\n    }\n    \n    set<pair<pair<intt, intt>, intt>> q;\n    // {{distance from 1, bad roads in shortest path}, node number}\n    q.insert({{0, 0}, 1});\n    vector<intt> dis(n+1, 2e9), sp(n+1, 2e9);\n    dis[1]=0;\n    sp[1]=0;\n\n    // dijkstras with (priority : min distance > min bad roads)\n    while(!q.empty())\n    {\n        auto k = *q.begin();\n        q.erase(q.begin());\n        if(dis[k.second]<k.first.first) continue;\n        else if(dis[k.second]<k.first.first and sp[k.second]<k.first.second) continue;\n        for(auto i:v[k.second])\n        {\n            if(dis[k.second]+1<dis[i.first])\n            {\n                dis[i.first]=dis[k.second]+1;\n                sp[i.first]=sp[k.second];\n                if(i.second==0) sp[i.first]++;\n                q.insert({{dis[i.first], sp[i.first]}, i.first});\n            }\n            else if(dis[k.second]+1==dis[i.first])\n            {\n                if(i.second==1 and sp[k.second]<sp[i.first])\n                {\n                    sp[i.first] = sp[k.second];\n                    q.insert({{dis[i.first], sp[i.first]}, i.first});\n                }\n                else if(i.second==0 and sp[k.second]+1<sp[i.first])\n                {\n                    sp[i.first] = sp[k.second]+1;\n                    q.insert({{dis[i.first], sp[i.first]}, i.first});\n                }\n            }\n        }        \n    }\n    intt curr = n;\n    while(curr>1)\n    {\n        intt mn = 2e9, z;\n        for(auto i:v[curr])\n        {\n            if(dis[i.first]==dis[curr]-1 and sp[i.first]<mn) z = i.first;\n        }\n        if(z<curr)\n        {\n            if(sp[curr]-1==sp[z]) ngood.insert({z, curr});\n            else if(sp[curr]==sp[z]) good.erase({z, curr});\n        }\n        else\n        {\n            if(sp[curr]-1==sp[z]) ngood.insert({curr, z});\n            else if(sp[curr]==sp[z]) good.erase({curr, z});\n        }\n        curr = z;\n    }\n    intt ans = good.size();\n    ans += ngood.size();\n    cout<<ans<<\"\\n\";\n    for(auto i:good) cout<<i.first<<\" \"<<i.second<<\" 0\\n\";\n    for(auto i:ngood) cout<<i.first<<\" \"<<i.second<<\" 1\\n\";\n}\n \nint main()\n{\n    // ios_base::sync_with_stdio(false);\n    // cin.tie(NULL);\n    int t=1;\n    // cin>>t;\n    while(t--)\n    {\n        solve();\n    }\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/15975",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    \n    int n = inf.readInt(1, 1000, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(1, 100, \"k\");\n    inf.readSpace();\n    int m = inf.readInt(1, 1000000000, \"m\");\n    inf.readEoln();\n    \n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    \n    int n = inf.readInt(1, 1000, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(1, 100, \"k\");\n    inf.readSpace();\n    int m = inf.readInt(1, 1000000000, \"m\");\n    inf.readEoln();\n    \n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    \n    int n = inf.readInt(1, 1000, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(1, 100, \"k\");\n    inf.readSpace();\n    int m = inf.readInt(1, 1000000000, \"m\");\n    inf.readEoln();\n    \n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int k = opt<int>(\"k\");\n    int m = opt<int>(\"m\");\n\n    ensure(1 <= n && n <= 1000);\n    ensure(1 <= k && k <= 100);\n    ensure(1 <= m && m <= 1000000000);\n\n    printf(\"%d %d %d\\n\", n, k, m);\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int k = opt<int>(\"k\");\n    int m = opt<int>(\"m\");\n\n    ensure(1 <= n && n <= 1000);\n    ensure(1 <= k && k <= 100);\n    ensure(1 <= m && m <= 1000000000);\n\n    printf(\"%d %d %d\\n\", n, k, m);\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -k 1 -m 1\n./gen -n 1 -k 1 -m 1000000000\n./gen -n 1 -k 100 -m 1\n./gen -n 1 -k 100 -m 1000000000\n\n./gen -n 1000 -k 1 -m 1\n./gen -n 1000 -k 1 -m 1000000000\n./gen -n 1000 -k 100 -m 1\n./gen -n 1000 -k 100 -m 1000000000\n\n./gen -n 1000 -k 50 -m 500000000\n./gen -n 999 -k 99 -m 999999999\n\n./gen -n 999 -k 2 -m 1000000000\n./gen -n 500 -k 2 -m 1\n\n./gen -n 1 -k 2 -m 1\n./gen -n 1 -k 2 -m 1000000000\n./gen -n 500 -k 1 -m 500000000\n./gen -n 300 -k 3 -m 1000000000\n./gen -n 700 -k 10 -m 1\n./gen -n 100 -k 100 -m 1000000000\n./gen -n 1000 -k 99 -m 999999998\n\n./gen -n 50 -k 1 -m 1000000000\n\n./gen -n 1000 -k 100 -m 1\n\n./gen -n 100 -k 50 -m 5000000\n./gen -n 200 -k 75 -m 250000000\n./gen -n 300 -k 25 -m 750000000\n./gen -n 400 -k 50 -m 100000000\n./gen -n 500 -k 15 -m 900000000\n./gen -n 600 -k 80 -m 350000000\n./gen -n 700 -k 60 -m 150000000\n./gen -n 800 -k 99 -m 800000000\n./gen -n 900 -k 1 -m 950000000\n\n./gen -n 987 -k 1 -m 123456789\n./gen -n 1000 -k 100 -m 987654321\n./gen -n 1000 -k 1 -m 999999999\n\n./gen -n 500 -k 50 -m 1\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:40:57.248215",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "507/E",
      "title": "E. Breaking Good",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line of input contains two integers n, m (2 ≤ n ≤ 105, ), the number of cities and number of roads respectively.In following m lines there are descriptions of roads. Each description consists of three integers x, y, z (1 ≤ x, y ≤ n, ) meaning that there is a road connecting cities number x and y. If z = 1, this road is working, otherwise it is not.",
      "output_spec": "OutputIn the first line output one integer k, the minimum possible number of roads affected by gang.In the following k lines output three integers describing roads that should be affected. Each line should contain three integers x, y, z (1 ≤ x, y ≤ n, ), cities connected by a road and the new state of a road. z = 1 indicates that the road between cities x and y should be repaired and z = 0 means that road should be blown up. You may output roads in any order. Each affected road should appear exactly once. You may output cities connected by a single road in any order. If you output a road, it's original state should be different from z.After performing all operations accroding to your plan, there should remain working only roads lying on some certain shortest past between city 1 and n.If there are multiple optimal answers output any.",
      "sample_tests": "ExamplesInputCopy2 11 2 0OutputCopy11 2 1InputCopy4 41 2 11 3 02 3 13 4 1OutputCopy31 2 01 3 12 3 0InputCopy8 91 2 08 3 02 3 11 4 18 7 01 5 14 6 15 7 06 8 0OutputCopy32 3 01 5 06 8 1",
      "description": "E. Breaking Good\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line of input contains two integers n, m (2 ≤ n ≤ 105, ), the number of cities and number of roads respectively.In following m lines there are descriptions of roads. Each description consists of three integers x, y, z (1 ≤ x, y ≤ n, ) meaning that there is a road connecting cities number x and y. If z = 1, this road is working, otherwise it is not.\n\nOutputIn the first line output one integer k, the minimum possible number of roads affected by gang.In the following k lines output three integers describing roads that should be affected. Each line should contain three integers x, y, z (1 ≤ x, y ≤ n, ), cities connected by a road and the new state of a road. z = 1 indicates that the road between cities x and y should be repaired and z = 0 means that road should be blown up. You may output roads in any order. Each affected road should appear exactly once. You may output cities connected by a single road in any order. If you output a road, it's original state should be different from z.After performing all operations accroding to your plan, there should remain working only roads lying on some certain shortest past between city 1 and n.If there are multiple optimal answers output any.\n\nInputCopy2 11 2 0OutputCopy11 2 1InputCopy4 41 2 11 3 02 3 13 4 1OutputCopy31 2 01 3 12 3 0InputCopy8 91 2 08 3 02 3 11 4 18 7 01 5 14 6 15 7 06 8 0OutputCopy32 3 01 5 06 8 1\n\nInputCopy2 11 2 0\n\nOutputCopy11 2 1\n\nInputCopy4 41 2 11 3 02 3 13 4 1\n\nOutputCopy31 2 01 3 12 3 0\n\nInputCopy8 91 2 08 3 02 3 11 4 18 7 01 5 14 6 15 7 06 8 0\n\nOutputCopy32 3 01 5 06 8 1\n\nNoteIn the first test the only path is 1 - 2In the second test the only shortest path is 1 - 3 - 4In the third test there are multiple shortest paths but the optimal is 1 - 4 - 6 - 8",
      "solutions": [
        {
          "title": "Codeforces Round #287 (Div. 2) - Codeforces",
          "content": "Hello Codeforces!I'd like to invite you to Codeforces Round #287 (Div. 2). It'll be held on Friday, January 23rd at 19:00 MSK. and as usual Div. 1 participants can join out of competition.This is my first round so wish me luck! :)Great thanks to Maxim Akhmedov (Zlobober) for helping me preparing the contest, Alex Fetisov (AlexFetisov) for testing and giving useful tips regarding statements, Maria Belova (Delinur) for translating the statements into Russian and Mike Mirzayanov (MikeMirzayanov) for the great Polygon platform.The scoring distribution will be announced later.Good luck everyone and I hope you'll find the problems interesting.UPD #1 Score distribution will be standard 500-1000-1500-2000-2500.UPD #2 Contest finished, hope you enjoyed the problems. :)UPD #3 System testing finished.Winner of the contest is going to be disqualified due to \"Do not use harsh, rude or misleading handle.\" part of Codeforces rules.So congratulations to the winners:chickennethsnowqcrqgx175mikeyue_tcDennordKilluaZoldyckUPD #4 You can find the editorial here.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/15930",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1057
        },
        {
          "title": "Codeforces Round #287 (Div. 2) Editorial - Codeforces",
          "content": "507A - Amr and MusicProblem: We have to split the number k into maximum number of elements of ai such that their sum is less than or equal to k.Hint: To maximize the answer we have to split the number into the smallest numbers possible.Solution: So and since the limits are small we can pick up the smallest element of the array and subtract it from k, and we keep doing this n times or until the smallest number is larger than k. Another solution is to sort the array in non-decreasing order and go on the same way.Time complexity: or Implementation: 9529124 .507B - Amr and PinsProblem: We have a circle with radius R at position (x, y) and we want to move it to (x', y') with minimum moves possible. A move is to choose an arbitrary point on the border of the circle and rotate the circle around it with arbitrary angle.Hint: What is the shortest path between two points? A direct line. So moving the center on that line with maximum move possible each time will guarantee minimal number of moves.Solution: Let's draw a straight line between the two centers.Clearly to move the center with maximum distance we need to rotate it around the intersection of the line and the circle with 180 degrees. So the maximum distance we can move the center each time is 2 * R. Let's continue moving the center with 2 * R distance each time until the two circles intersects. Now obviously we can make the center moves into its final position by rotating it around one of the intersection points of the two circles until it reaches the final destination.Every time we make the circle moves 2 * R times except the last move it'll be  ≤ 2 * R. Assume that the initial distance between the two points is d So the solution to the problem will be .Time complexity: You have to be careful of precision errors. Here is a code that used only integer arithmetic operations 9529147.507C - Guess Your Way Out!Hint: Simulate the algorithm until we reach a leaf node assume that it's not the exit. Now the question is Are there some nodes that are guaranteed to be visited before trying to reach the exit again?Solution: The first observation is that in order to return to a parent we will have to visit all nodes of the right or the left subtree of some node first. Now imagine we are in the situation below where E is the exit.By applying the algorithm we'll reach node X. Both the E and X are in different subtrees of the root. Which means before going to the proper subtree in which the Exit exists we'll have to visit all the nodes of the left subtree (marked in red).This means we have to get the node which the Exit and the current leaf node X are in different subtrees which will be the least common ancestor (LCA) of the two nodes. Assume the subtree height is h1. This means we visited node. By adding the nodes above the subtree which we visited during executing the string for the first time the total number of visited nodes will be . Now let's go to the other subtree. Obviously we don't need any other nodes except this subtree. So let's do the same we did to the original tree to this subtree. Execute the algorithm until we reach a leaf node, get the LCA, add to the solution where h2 is the height of the subtree of the LCA node where the leaf node exists. And so on we keep applying the rules until after executing the algorithm we will reach the exit.Also we can do the same operations in O(h) by beginning to move from the root, if the exit is located to the left we go to the left and ans++ and then set the next command to 'R' else if it is located to the right we will visited the whole left subtree so we add the left subtree nodes to the answer and then set the next command to 'L' and so on.Time complexity: or Challenge: What if the pattern is given as an input (e.g. \"LRRLLRRRLRLRLRR...\"), How can this problem be solved?Implementation: 9529181507D - The Maths LectureHint: Dynamic programming problem. To handle repetitions we have to construct the number from right to the left and calculate the answer when we reach a number equivalent to 0 modulo k.Solution: Let's define as a recursive functions calculates the number of numbers consisting of n digits satisfying the conditions of the problem and with a specific suffix of length i Si such that .We want to avoid repetition so by constructing the number from the right to the left when we reach a state with j = 0 with suffix  ≠ 0 we return the answer immediately so any other suffix that contains this suffix won't b calculated.So the base cases are , .So state transitions will be (We add a digit to the left).And we can handle j = 0 case coming from a zero suffix easily with a boolean variable we set to true when we use a digit  ≠ 0 in constructing the number.Time complexity: Implementation: 9529210507E - Breaking GoodHint: Consider we've chosen a certain path with length d where d is the length of the shortest path from 1 to n and it has x edges that are working. Assume that y is the total number of edges that are working in the whole country. So we need to make d - x changes (to make the malfunctioning edges on the path work) and y - x changes (to blow up all other edges that don't lie on the path). So we will totally make d + y - 2 * x changes where d and y are constants. So the optimal solution will depend only on number of working edges along the path. So we'll have to maximize this number!Solution: We will use dynamic programming on all nodes that lies on some shortest path. In other words, every node x that satisfies that the shortest path from 1 to x + the shortest path from x to n equals d where d is the length of the shortest path from 1 to n. Let's define Max[x] is the maximum number of working edges along some shortest path from 1 to x. We can calculate the value Max[x] for all nodes by dynamic programming by traversing the nodes in order of increasing shortest path from node 1. So at the end we'll make d + y - 2 * Max[n] changes. We can get them easily by retrieving the chosen optimal path.Time complexity: Implementation: 9529272",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/15975",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 507\\s*E"
          },
          "content_length": 6032
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #287 (Div. 2) - Codeforces - Code 1",
          "code": "your                                               eyes",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15930",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #287 (Div. 2) - Codeforces - Code 2",
          "code": "are                                                moving",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15930",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #287 (Div. 2) - Codeforces - Code 3",
          "code": "from                                               left",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15930",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #287 (Div. 2) - Codeforces - Code 4",
          "code": "to                                                 right",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15930",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #287 (Div. 2) - Codeforces - Code 5",
          "code": "and                                                then",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15930",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #287 (Div. 2) - Codeforces - Code 6",
          "code": "from                                               right",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15930",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #287 (Div. 2) - Codeforces - Code 7",
          "code": "to                                                 left",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15930",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #287 (Div. 2) - Codeforces - Code 8",
          "code": "again                                              and",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15930",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #287 (Div. 2) - Codeforces - Code 9",
          "code": "again                                              to",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15930",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #287 (Div. 2) - Codeforces - Code 10",
          "code": "read                                               this",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15930",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #287 (Div. 2) - Codeforces - Code 11",
          "code": "x = (1LL << (h-1)) + 1; y = 1 << h;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15930",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #287 (Div. 2) - Codeforces - Code 12",
          "code": "x = (1LL << (h-1)) + 1; y = 1 << h;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15930",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #287 (Div. 2) - Codeforces - Code 13",
          "code": "dist-=1e-12;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15930",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #287 (Div. 2) - Codeforces - Code 14",
          "code": "100000 100000 1 -100000 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15930",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #287 (Div. 2) - Codeforces - Code 15",
          "code": "100000 100000 0 -100000 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15930",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #287 (Div. 2) - Codeforces - Code 16",
          "code": "100000 100000 0 -100000 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15930",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #287 (Div. 2) - Codeforces - Code 17",
          "code": "dist = 200000;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15930",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #287 (Div. 2) - Codeforces - Code 18",
          "code": "cerr << dist;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15930",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #287 (Div. 2) - Codeforces - Code 19",
          "code": "2) Add cerr << dist; after subtracting 1e-12 from dist.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15930",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #287 (Div. 2) - Codeforces - Code 20",
          "code": "printf(\"%d\\n\", (int) ceil(hypot(x1 - x2, y1 - y2) / (2 * r)));",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15930",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #287 (Div. 2) - Codeforces - Code 21",
          "code": "6.28009e-012",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15930",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #287 (Div. 2) - Codeforces - Code 22",
          "code": "141081 99263 99774 -100000 -100000",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15930",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #287 (Div. 2) - Codeforces - Code 23",
          "code": "830699159852",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15930",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #287 (Div. 2) - Codeforces - Code 24",
          "code": "39 457181784666",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15930",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #287 (Div. 2) - Codeforces - Code 25",
          "code": "547231318312",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15930",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #287 (Div. 2) - Codeforces - Code 26",
          "code": "scanf(\"%lld\", &n);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15930",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #287 (Div. 2) - Codeforces - Code 27",
          "code": "integer value (2)\nC++98: bitset (unsigned long val);\nC++11: constexpr bitset (unsigned long long val) noexcept;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15930",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #287 (Div. 2) - Codeforces - Code 28",
          "code": "integer value (2)\nC++98: bitset (unsigned long val);\nC++11: constexpr bitset (unsigned long long val) noexcept;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15930",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #287 (Div. 2) - Codeforces - Code 29",
          "code": "1024 is on the right side",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15930",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #287 (Div. 2) Editorial - Codeforces - Code 1",
          "code": "public void solve(int testNumber, InputReader in, PrintWriter out) {\n        int h = in.nextInt();\n        long n = in.nextLong() - 1;\n        long res = 0;\n        for(int i = h - 1; 1; i >= 0; i--) {\n            if ((n >> i & 1L) == 1) {\n                res += 1L << i + 1;\n            } else {\n                res += 1;\n                n = ~n; //inversion\n            }\n        }\n        out.println(res);\n    }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15975",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #287 (Div. 2) Editorial - Codeforces - Code 2",
          "code": "public void solve(int testNumber, InputReader in, PrintWriter out) {\n        int h = in.nextInt();\n        long n = in.nextLong() - 1;\n        long res = 0;\n        for(int i = h - 1; 1; i >= 0; i--) {\n            if ((n >> i & 1L) == 1) {\n                res += 1L << i + 1;\n            } else {\n                res += 1;\n                n = ~n; //inversion\n            }\n        }\n        out.println(res);\n    }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15975",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #287 (Div. 2) Editorial - Codeforces - Code 3",
          "code": "for(int j = 1; j < K; j++)\n  for(int d = 0; d <= 9; d++)\n  {\n        long long modulo = (pow(10,i)*d + j) % K;\n        DP[i+1][modulo] += DP[i][j];\n        DP[i+1][modulo] %= M;\n  }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15975",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #287 (Div. 2) Editorial - Codeforces - Code 4",
          "code": "for(int j = 1; j < K; j++)\n  for(int d = 0; d <= 9; d++)\n  {\n        long long modulo = (pow(10,i)*d + j) % K;\n        DP[i+1][modulo] += DP[i][j];\n        DP[i+1][modulo] %= M;\n  }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15975",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #287 (Div. 2) Editorial - Codeforces - Code 5",
          "code": "cal[i][j] = sum x = 0..9 cal[i - 1][(j - x * 10 ^ (i - 1)) mod k]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15975",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #287 (Div. 2) Editorial - Codeforces - Code 6",
          "code": "cal[i][j] = sum l=0..k-1 p[i][l] * cal[i - 1][(j - l) mod k]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15975",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #287 (Div. 2) Editorial - Codeforces - Code 7",
          "code": "// handle base cases\nfor(int i = 1;i <= n;i++)\n  for(int j = 1;j < k-1;j++)\n     for(int x = 0;x < 10;x++)\n      count[i+1][(j+(x*10^i))%k]+=count[i][j]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15975",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #287 (Div. 2) Editorial - Codeforces - Code 8",
          "code": "// handle base cases\nfor(int i = 1;i <= n;i++)\n  for(int j = 1;j < k-1;j++)\n     for(int x = 0;x < 10;x++)\n      count[i+1][(j+(x*10^i))%k]+=count[i][j]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15975",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #287 (Div. 2) Editorial - Codeforces - Code 9",
          "code": "if(ind == n || (rem == 0 && change)) return 0;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15975",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #287 (Div. 2) Editorial - Codeforces - Code 10",
          "code": "if(ind == n) return 0;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15975",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #287 (Div. 2) Editorial - Codeforces - Code 11",
          "code": "(rem==0&&change) is true",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15975",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #287 (Div. 2) Editorial - Codeforces - Code 12",
          "code": "We want to avoid repetition so by constructing the number from the right to the left when we reach a state with j = 0 with suffix  ≠ 0 we return the answer immediately so any other suffix that contains this suffix won't b calculated.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15975",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #287 (Div. 2) Editorial - Codeforces - Code 13",
          "code": "We want to avoid repetition so by constructing the number from the right to the left when we reach a state with j = 0 with suffix  ≠ 0 we return the answer immediately so any other suffix that contains this suffix won't b calculated.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15975",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #287 (Div. 2) Editorial - Codeforces - Code 14",
          "code": "pair<pair<int, int>, int>",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15975",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #287 (Div. 2) Editorial - Codeforces - Code 15",
          "code": "{{distance from 1, no. of bad roads in the shortest path from 1}, node}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/15975",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #287 (Div. 2) Editorial - Codeforces - Code 16",
          "code": "#include<bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp> \nusing namespace std;\nusing namespace __gnu_pbds;\n#define intt int64_t \n \n\nvoid solve()\n{\n    intt n, m;\n    cin>>n>>m;\n    intt a, b, c;\n    vector<vector<pair<intt, intt>>> v(n+1);\n    set<pair<intt, intt>> good, ngood;\n    for(int i=0;i<m;i++) \n    {\n        cin>>a>>b>>c;\n        v[a].push_back({b, c});\n        v[b].push_back({a, c});\n        if(a>b) swap(a, b);\n        if(c==1) good.insert({a, b});\n    }\n    \n    set<pair<pair<intt, intt>, intt>> q;\n    // {{distance from 1, bad roads in shortest path}, node number}\n    q.insert({{0, 0}, 1});\n    vector<intt> dis(n+1, 2e9), sp(n+1, 2e9);\n    dis[1]=0;\n    sp[1]=0;\n\n    // dijkstras with (priority : min distance > min bad roads)\n    while(!q.empty())\n    {\n        auto k = *q.begin();\n        q.erase(q.begin());\n        if(dis[k.second]<k.first.first) continue;\n        else if(dis[k.second]<k.first.first and sp[k.second]<k.first.second) continue;\n        for(auto i:v[k.second])\n        {\n            if(dis[k.second]+1<dis[i.first])\n            {\n                dis[i.first]=dis[k.second]+1;\n                sp[i.first]=sp[k.second];\n                if(i.second==0) sp[i.first]++;\n                q.insert({{dis[i.first], sp[i.first]}, i.first});\n            }\n            else if(dis[k.second]+1==dis[i.first])\n            {\n                if(i.second==1 and sp[k.second]<sp[i.first])\n                {\n                    sp[i.first] = sp[k.second];\n                    q.insert({{dis[i.first], sp[i.first]}, i.first});\n                }\n                else if(i.second==0 and sp[k.second]+1<sp[i.first])\n                {\n                    sp[i.first] = sp[k.second]+1;\n                    q.insert({{dis[i.first], sp[i.first]}, i.first});\n                }\n            }\n        }        \n    }\n    intt curr = n;\n    while(curr>1)\n    {\n        intt mn = 2e9, z;\n        for(auto i:v[curr])\n        {\n            if(dis[i.first]==dis[curr]-1 and sp[i.first]<mn) z = i.first;\n        }\n        if(z<curr)\n        {\n            if(sp[curr]-1==sp[z]) ngood.insert({z, curr});\n            else if(sp[curr]==sp[z]) good.erase({z, curr});\n        }\n        else\n        {\n            if(sp[curr]-1==sp[z]) ngood.insert({curr, z});\n            else if(sp[curr]==sp[z]) good.erase({curr, z});\n        }\n        curr = z;\n    }\n    intt ans = good.size();\n    ans += ngood.size();\n    cout<<ans<<\"\\n\";\n    for(auto i:good) cout<<i.first<<\" \"<<i.second<<\" 0\\n\";\n    for(auto i:ngood) cout<<i.first<<\" \"<<i.second<<\" 1\\n\";\n}\n \nint main()\n{\n    // ios_base::sync_with_stdio(false);\n    // cin.tie(NULL);\n    int t=1;\n    // cin>>t;\n    while(t--)\n    {\n        solve();\n    }\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/15975",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #287 (Div. 2) Editorial - Codeforces - Code 17",
          "code": "#include<bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp> \nusing namespace std;\nusing namespace __gnu_pbds;\n#define intt int64_t \n \n\nvoid solve()\n{\n    intt n, m;\n    cin>>n>>m;\n    intt a, b, c;\n    vector<vector<pair<intt, intt>>> v(n+1);\n    set<pair<intt, intt>> good, ngood;\n    for(int i=0;i<m;i++) \n    {\n        cin>>a>>b>>c;\n        v[a].push_back({b, c});\n        v[b].push_back({a, c});\n        if(a>b) swap(a, b);\n        if(c==1) good.insert({a, b});\n    }\n    \n    set<pair<pair<intt, intt>, intt>> q;\n    // {{distance from 1, bad roads in shortest path}, node number}\n    q.insert({{0, 0}, 1});\n    vector<intt> dis(n+1, 2e9), sp(n+1, 2e9);\n    dis[1]=0;\n    sp[1]=0;\n\n    // dijkstras with (priority : min distance > min bad roads)\n    while(!q.empty())\n    {\n        auto k = *q.begin();\n        q.erase(q.begin());\n        if(dis[k.second]<k.first.first) continue;\n        else if(dis[k.second]<k.first.first and sp[k.second]<k.first.second) continue;\n        for(auto i:v[k.second])\n        {\n            if(dis[k.second]+1<dis[i.first])\n            {\n                dis[i.first]=dis[k.second]+1;\n                sp[i.first]=sp[k.second];\n                if(i.second==0) sp[i.first]++;\n                q.insert({{dis[i.first], sp[i.first]}, i.first});\n            }\n            else if(dis[k.second]+1==dis[i.first])\n            {\n                if(i.second==1 and sp[k.second]<sp[i.first])\n                {\n                    sp[i.first] = sp[k.second];\n                    q.insert({{dis[i.first], sp[i.first]}, i.first});\n                }\n                else if(i.second==0 and sp[k.second]+1<sp[i.first])\n                {\n                    sp[i.first] = sp[k.second]+1;\n                    q.insert({{dis[i.first], sp[i.first]}, i.first});\n                }\n            }\n        }        \n    }\n    intt curr = n;\n    while(curr>1)\n    {\n        intt mn = 2e9, z;\n        for(auto i:v[curr])\n        {\n            if(dis[i.first]==dis[curr]-1 and sp[i.first]<mn) z = i.first;\n        }\n        if(z<curr)\n        {\n            if(sp[curr]-1==sp[z]) ngood.insert({z, curr});\n            else if(sp[curr]==sp[z]) good.erase({z, curr});\n        }\n        else\n        {\n            if(sp[curr]-1==sp[z]) ngood.insert({curr, z});\n            else if(sp[curr]==sp[z]) good.erase({curr, z});\n        }\n        curr = z;\n    }\n    intt ans = good.size();\n    ans += ngood.size();\n    cout<<ans<<\"\\n\";\n    for(auto i:good) cout<<i.first<<\" \"<<i.second<<\" 0\\n\";\n    for(auto i:ngood) cout<<i.first<<\" \"<<i.second<<\" 1\\n\";\n}\n \nint main()\n{\n    // ios_base::sync_with_stdio(false);\n    // cin.tie(NULL);\n    int t=1;\n    // cin>>t;\n    while(t--)\n    {\n        solve();\n    }\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/15975",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(2, 100000, \"n\");\n    inf.readSpace();\n    long long m_max = min(1000000LL, 1LL * n * (n - 1) / 2);\n    int m = inf.readInt(n - 1, m_max, \"m\");\n    inf.readEoln();\n\n    vector<vector<int> > adj(n + 1);\n    set<pair<int, int> > edges;\n\n    for (int i = 0; i < m; ++i) {\n        int x = inf.readInt(1, n, \"x_i\");\n        inf.readSpace();\n        int y = inf.readInt(1, n, \"y_i\");\n        inf.readSpace();\n        int z = inf.readInt(0, 1, \"z_i\");\n        inf.readEoln();\n\n        ensuref(x != y, \"Edge between node %d and itself is not allowed\", x);\n        int u = min(x, y);\n        int v = max(x, y);\n        pair<int, int> edge = make_pair(u, v);\n        ensuref(edges.count(edge) == 0, \"Multiple edges between node %d and node %d\", u, v);\n        edges.insert(edge);\n\n        adj[x].push_back(y);\n        adj[y].push_back(x);\n    }\n\n    vector<bool> visited(n + 1, false);\n    queue<int> q;\n    q.push(1);\n    visited[1] = true;\n    while (!q.empty()) {\n        int u = q.front(); q.pop();\n        for (int v : adj[u]) {\n            if (!visited[v]) {\n                visited[v] = true;\n                q.push(v);\n            }\n        }\n    }\n\n    for (int i = 1; i <= n; ++i) {\n        ensuref(visited[i], \"Graph is not connected: node %d is unreachable\", i);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(2, 100000, \"n\");\n    inf.readSpace();\n    long long m_max = min(1000000LL, 1LL * n * (n - 1) / 2);\n    int m = inf.readInt(n - 1, m_max, \"m\");\n    inf.readEoln();\n\n    vector<vector<int> > adj(n + 1);\n    set<pair<int, int> > edges;\n\n    for (int i = 0; i < m; ++i) {\n        int x = inf.readInt(1, n, \"x_i\");\n        inf.readSpace();\n        int y = inf.readInt(1, n, \"y_i\");\n        inf.readSpace();\n        int z = inf.readInt(0, 1, \"z_i\");\n        inf.readEoln();\n\n        ensuref(x != y, \"Edge between node %d and itself is not allowed\", x);\n        int u = min(x, y);\n        int v = max(x, y);\n        pair<int, int> edge = make_pair(u, v);\n        ensuref(edges.count(edge) == 0, \"Multiple edges between node %d and node %d\", u, v);\n        edges.insert(edge);\n\n        adj[x].push_back(y);\n        adj[y].push_back(x);\n    }\n\n    vector<bool> visited(n + 1, false);\n    queue<int> q;\n    q.push(1);\n    visited[1] = true;\n    while (!q.empty()) {\n        int u = q.front(); q.pop();\n        for (int v : adj[u]) {\n            if (!visited[v]) {\n                visited[v] = true;\n                q.push(v);\n            }\n        }\n    }\n\n    for (int i = 1; i <= n; ++i) {\n        ensuref(visited[i], \"Graph is not connected: node %d is unreachable\", i);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(2, 100000, \"n\");\n    inf.readSpace();\n    long long m_max = min(1000000LL, 1LL * n * (n - 1) / 2);\n    int m = inf.readInt(n - 1, m_max, \"m\");\n    inf.readEoln();\n\n    vector<vector<int> > adj(n + 1);\n    set<pair<int, int> > edges;\n\n    for (int i = 0; i < m; ++i) {\n        int x = inf.readInt(1, n, \"x_i\");\n        inf.readSpace();\n        int y = inf.readInt(1, n, \"y_i\");\n        inf.readSpace();\n        int z = inf.readInt(0, 1, \"z_i\");\n        inf.readEoln();\n\n        ensuref(x != y, \"Edge between node %d and itself is not allowed\", x);\n        int u = min(x, y);\n        int v = max(x, y);\n        pair<int, int> edge = make_pair(u, v);\n        ensuref(edges.count(edge) == 0, \"Multiple edges between node %d and node %d\", u, v);\n        edges.insert(edge);\n\n        adj[x].push_back(y);\n        adj[y].push_back(x);\n    }\n\n    vector<bool> visited(n + 1, false);\n    queue<int> q;\n    q.push(1);\n    visited[1] = true;\n    while (!q.empty()) {\n        int u = q.front(); q.pop();\n        for (int v : adj[u]) {\n            if (!visited[v]) {\n                visited[v] = true;\n                q.push(v);\n            }\n        }\n    }\n\n    for (int i = 1; i <= n; ++i) {\n        ensuref(visited[i], \"Graph is not connected: node %d is unreachable\", i);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\n/*\n   Since the problem explicitly states \"If there are multiple optimal answers output any\",\n   there may be more than one correct solution for a single input. Therefore, we must\n   implement a CUSTOM checker (rather than using a built-in checker) to verify:\n\n   1) The answer indeed leaves exactly one shortest path from city 1 to city n.\n   2) Only edges on that one shortest path remain working after the changes.\n   3) The total number of changed roads is minimal.\n\n   Key points for correctness:\n   - We denote Dist = the minimum number of edges on any path from 1 to n in the ORIGINAL graph.\n   - Let W = the total number of originally working edges.\n   - A correct solution must:\n       (a) End with exactly Dist edges working, forming a path of length Dist from 1 to n.\n       (b) All other edges must be not-working.\n       (c) The cost (number of changes) = the number of edges repaired on the path + the number of edges blown up off the path must be minimal.\n\n   Minimizing the changes is equivalent to choosing a path of length Dist that maximizes the\n   number of originally working edges among those Dist edges (or equivalently, minimizes the\n   number of originally broken edges in the path).  The absolute minimal number of changes can\n   be computed by:\n       minimalChanges = (# of originally working edges not on the path) + (# of originally broken edges on the path)\n                      = (W - numberOfWorkingOnChosenPath) + (Dist - numberOfWorkingOnChosenPath)\n                      = W + Dist - 2 * numberOfWorkingOnChosenPath.\n   Among all paths of length Dist, the path that maximizes the number of working edges yields\n   the minimal possible changes.\n\n   The checker outline:\n     - Read the input graph from inf.\n     - Compute Dist (the BFS distance from 1 to n in the original graph).\n     - Compute bestWorking[n]: the maximum number of working edges that can be used in a path of length Dist from 1 to n. We do this by:\n         1) BFS to find dist[u], the shortest distance from 1 to each u.\n         2) For each node u in order of increasing dist[u], update bestWorking[v] for v where dist[v] = dist[u] + 1.\n     - The minimal possible changes = W + Dist - 2 * bestWorking[n].\n\n     - Read the contestant's output from ouf.\n       * Let K = the number of roads they claim to change.\n       * If K > m, it's obviously wrong. (But typically you'd let testlib handle reading errors.)\n       * For each of the K changed edges (x, y, z):\n           + Check that (x, y) is actually in the original input, x != y, etc.\n           + Check that the new state z is indeed different from the original state.\n       * Apply these changes (repair or blow up) to form the \"final\" graph state.\n\n     - Verify the final graph has exactly Dist edges still working, and that there is a path\n       of length Dist from 1 to n, and no extra edges remain working.\n         + Count how many edges remain working = Dist?\n         + From city 1, do a BFS/DFS in the final graph. The distance to city n must be Dist.\n         + Also check that the total number of working edges in the connected component of 1\n           is exactly Dist (so there aren't any extra working edges forming cycles or\n           alternative routes).\n     - Compute changesUsed = K. Compare changesUsed with the minimal possible changes. If they do\n       not match, it's WA (the solution is correct in form but not minimal).\n     - Otherwise, _ok.\n\n   We only need to \"quitf(_fail)\" if something is truly wrong from the judge's perspective\n   (e.g., broken test files). Normal incorrect solutions get _wa.\n*/\n\nstatic const int MAXM = 100000;\n\nstruct Edge {\n    int u, v;\n    bool working; // original state: true => working, false => not working\n};\n\nint main(int argc, char* argv[])\n{\n    registerTestlibCmd(argc, argv);\n\n    // Read input\n    int n = inf.readInt(2, 100000, \"n\");\n    int m = inf.readInt(1, MAXM, \"m\");\n\n    // Store edges and adjacency\n    vector<Edge> edges(m);\n    vector<vector<int>> adj(n + 1);      // adjacency list: adj[u] holds indices of edges\n    // We'll also keep track: for edge i, edges[i].u <-> edges[i].v, edges[i].working\n    // Sum of originally working edges\n    long long W = 0; // total # of working edges\n\n    for(int i = 0; i < m; i++){\n        int x = inf.readInt(1, n, \"x\");\n        int y = inf.readInt(1, n, \"y\");\n        if(x == y){\n            quitf(_fail, \"Input has a self-loop, which shouldn't exist by problem statement.\");\n        }\n        int z = inf.readInt(0, 1, \"z\");\n        edges[i].u = x;\n        edges[i].v = y;\n        edges[i].working = (z == 1);\n\n        if(z == 1) W++;\n\n        // We'll store edge i in adjacency of x and y\n        adj[x].push_back(i);\n        adj[y].push_back(i);\n    }\n\n    // We need BFS distance from 1 to n in the original graph (unweighted).\n    // The graph is connected, so there's guaranteed to be a path.\n    // Dist = shortest number of edges from 1 to n.\n    // We'll do a standard BFS for that.\n    vector<int> dist(n + 1, -1);\n    queue<int>q;\n    dist[1] = 0;\n    q.push(1);\n\n    while(!q.empty()){\n        int cur = q.front(); q.pop();\n        for(int idx : adj[cur]){\n            int nxt = (edges[idx].u == cur ? edges[idx].v : edges[idx].u);\n            if(dist[nxt] == -1){\n                dist[nxt] = dist[cur] + 1;\n                q.push(nxt);\n            }\n        }\n    }\n    if(dist[n] == -1){\n        // The problem states the graph is connected, so this shouldn't happen.\n        quitf(_fail, \"No path between 1 and n found in a supposedly connected graph.\");\n    }\n\n    int Dist = dist[n];\n\n    // Next, we want bestWorking[u]: the maximum # of originally working edges\n    // used in any path of length dist[u] from 1->u.\n    // We'll process nodes in ascending order of dist[u].\n    // If dist[v] = dist[u] + 1, we can go u->v as part of a shortest path chain.\n    // bestWorking[v] = max( bestWorking[v], bestWorking[u] + (edge(u,v) is working?1:0) )\n    vector<int> bestWorking(n + 1, -1);\n    bestWorking[1] = 0;\n\n    // Bucket nodes by distance\n    vector<vector<int>> byDist(dist[n] + 1);\n    for(int i = 1; i <= n; i++){\n        if(dist[i] >= 0) {\n            byDist[dist[i]].push_back(i);\n        }\n    }\n\n    for(int d = 0; d <= Dist; d++){\n        for (int u: byDist[d]){\n            int curBest = bestWorking[u];\n            if(curBest < 0) continue; // not reachable\n            // Explore neighbors\n            for(int idx : adj[u]){\n                int v = (edges[idx].u == u ? edges[idx].v : edges[idx].u);\n                // We only proceed if dist[v] == dist[u]+1\n                if(dist[v] == d+1){\n                    int addVal = (edges[idx].working ? 1 : 0);\n                    bestWorking[v] = max(bestWorking[v], curBest + addVal);\n                }\n            }\n        }\n    }\n\n    // The maximum # of working edges on a shortest path from 1 to n\n    int maxWorkingOnShortest = bestWorking[n];\n    // Minimal changes = (W - x) + (Dist - x) = W + Dist - 2*x\n    long long minimalChanges = (long long)W + Dist - 2LL * maxWorkingOnShortest;\n\n    // Now read the contestant's output to check correctness\n    // 1) K lines describing changed edges\n    // 2) apply them, then verify the final state\n\n    int K = ouf.readInt(0, m, \"K\"); // they cannot change more roads than exist\n\n    // We'll keep track of final working state of each edge:\n    // initially finalWorking[i] = edges[i].working\n    vector<bool> finalWorking(m);\n    for(int i = 0; i < m; i++){\n        finalWorking[i] = edges[i].working;\n    }\n\n    // For quick lookup by unordered_map or map, let us store them in a map of (min(u,v), max(u,v)) -> idx\n    // but we have up to 100k edges, a map is fine if well-coded; or we can do a dictionary of vectors.\n    // We'll just store them in a map: we need to carefully handle repeated edges, but the statement says\n    // \"for any two cities there is at most one road between them\".\n    static const long long SHIFT = 1000000LL; \n\n    auto encodePair = [&](int a, int b){\n        if(a > b) std::swap(a, b);\n        // a <= b\n        return (long long)a * SHIFT + (long long)b;\n    };\n\n    unordered_map<long long, int> edgeIndex;\n    edgeIndex.reserve(m*2);\n    edgeIndex.max_load_factor(0.7f);\n    for(int i = 0; i < m; i++){\n        int x = edges[i].u;\n        int y = edges[i].v;\n        // encode\n        long long key = encodePair(x,y);\n        edgeIndex[key] = i;\n    }\n\n    for(int i = 0; i < K; i++){\n        int x = ouf.readInt(1, n, \"changedEdge_x\");\n        int y = ouf.readInt(1, n, \"changedEdge_y\");\n        if(x == y){\n            ouf.quitf(_wa, \"changed edge has x == y, which is invalid\");\n        }\n        int z = ouf.readInt(0, 1, \"changedEdge_z\");\n\n        long long key = encodePair(x,y);\n        if(!edgeIndex.count(key)){\n            ouf.quitf(_wa, \"changed edge (%d,%d) does not exist in the graph\", x, y);\n        }\n        int idx = edgeIndex[key];\n        bool original = edges[idx].working; // original state\n        bool desired = (z == 1);           // new state\n\n        if(original == desired){\n            ouf.quitf(_wa, \"changed edge (%d,%d) is set to the same state as original\", x, y);\n        }\n        // apply the change\n        finalWorking[idx] = desired;\n    }\n\n    // Now let's verify the final states:\n    // 1) Exactly Dist edges remain working.\n    // 2) There's a path of length Dist from 1 to n in the final subgraph.\n    // 3) No extra edges remain in that final subgraph beyond that path.\n\n    long long finalCountWorking = 0;\n    for(int i = 0; i < m; i++){\n        if(finalWorking[i]) finalCountWorking++;\n    }\n    if(finalCountWorking != Dist){\n        ouf.quitf(_wa,\n                  \"after changing roads, exactly Dist=%d edges must remain working, but found %lld\",\n                  Dist, finalCountWorking);\n    }\n\n    // Build adjacency for final subgraph of working edges only\n    vector<vector<int>> finalAdj(n+1);\n    for(int i = 0; i < m; i++){\n        if(finalWorking[i]){\n            int u = edges[i].u, v = edges[i].v;\n            finalAdj[u].push_back(v);\n            finalAdj[v].push_back(u);\n        }\n    }\n    // BFS in final subgraph from 1 to see distance to n\n    vector<int> distFinal(n+1, -1);\n    queue<int>qq;\n    distFinal[1] = 0;\n    qq.push(1);\n\n    while(!qq.empty()){\n        int cur = qq.front(); qq.pop();\n        for(int nxt: finalAdj[cur]){\n            if(distFinal[nxt] == -1){\n                distFinal[nxt] = distFinal[cur] + 1;\n                qq.push(nxt);\n            }\n        }\n    }\n\n    if(distFinal[n] != Dist){\n        ouf.quitf(_wa,\n            \"in final subgraph, distance from city 1 to city n is %d instead of %d\",\n            distFinal[n], Dist);\n    }\n\n    // We also must ensure no extra working edges form cycles or alternative paths.\n    // Because the statement says: \"After performing all operations, there should remain working\n    // only roads lying on some certain shortest path between city 1 and n.\"\n    // If the final subgraph is exactly Dist edges, and a BFS path from 1->n uses Dist edges,\n    // that path must be simple and there's nowhere else to go. But let's be sure there's no cycle:\n    // We'll do a DFS from 1 to see how many edges are in the connected component of 1.\n    // Each working edge is counted once. That should be Dist. If there's more, we have a cycle.\n    vector<bool> visited(n+1,false);\n    visited[1] = true;\n    stack<int> st;\n    st.push(1);\n    long long edgesInComp = 0;\n\n    while(!st.empty()){\n        int u = st.top(); st.pop();\n        for(int v : finalAdj[u]){\n            // Each edge (u,v) is effectively counted once from the \"smaller\" side to the \"bigger\"?\n            // It's simpler to just count every edge from one side and then divide by 2, or keep a visitedEdge approach.\n            // But we only need to see if the total # of edges in the comp is Dist. So let's do it carefully:\n            // We'll just store edges in a small set? That might be expensive for large graphs.\n            // Instead, we can do: for each (u->v) with u < v, count +1. We'll do that in a local scope.\n\n            if(u < v) {\n                edgesInComp++;\n            }\n            if(!visited[v]){\n                visited[v] = true;\n                st.push(v);\n            }\n        }\n    }\n\n    // Each undirected edge was counted exactly once (when u<v). So edgesInComp is the number of edges in the connected component of 1.\n    if(edgesInComp != Dist){\n        ouf.quitf(_wa,\n            \"final subgraph has %lld edges in the connected component of city 1, but expected %d\",\n            edgesInComp, Dist);\n    }\n    // Also check city n is indeed visited in the final subgraph\n    if(!visited[n]){\n        ouf.quitf(_wa,\"city n is not reachable in final subgraph but BFS said distFinal[n] = %d\", distFinal[n]);\n    }\n    // Also ensure that no other component has working edges. If there's a working edge connecting\n    // two nodes neither of which is in the visited set, that would violate the requirement that\n    // \"only roads on the path remain working.\" We'll just check if all working edges connect\n    // visited nodes.\n    for(int i=0;i<m;i++){\n        if(finalWorking[i]){\n            int u = edges[i].u, v = edges[i].v;\n            if(!visited[u] || !visited[v]){\n                ouf.quitf(_wa,\n                  \"the final subgraph has a working edge (%d,%d) outside the path's component\",\n                  u, v);\n            }\n        }\n    }\n\n    // Finally, check minimal changes == K\n    long long changesUsed = K; // participant claims they changed K roads\n    if(changesUsed != minimalChanges){\n        ouf.quitf(_wa,\n                  \"the number of changed roads = %lld but the minimal possible is %lld\",\n                  changesUsed, minimalChanges);\n    }\n\n    // If all checks passed, it's correct\n    ouf.quitf(_ok, \"correct solution with exactly %lld changes\", changesUsed);\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAX_N = 100000;\nconst int MAX_M = 300000;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\", -1);\n    string type = opt<string>(\"type\", \"random\");\n    double p = opt<double>(\"p\", 0.5);\n\n    ensure(2 <= n && n <= MAX_N);\n\n    vector<pair<int, int>> edges;\n    vector<int> z;\n\n    if (type == \"path\") {\n        // Generate a path from 1 to n\n\n        if (m == -1) m = n - 1;\n        ensure(m == n - 1);\n\n        for (int i = 1; i < n; ++i) {\n            edges.push_back({i, i + 1});\n        }\n\n    } else if (type == \"star\") {\n        // Generate a star graph with center at node 1\n\n        if (m == -1) m = n - 1;\n        ensure(m == n - 1);\n\n        for (int i = 2; i <= n; ++i) {\n            edges.push_back({1, i});\n        }\n\n    } else if (type == \"tree\") {\n        // Generate a random tree\n\n        if (m == -1) m = n - 1;\n        ensure(m == n - 1);\n\n        for (int i = 2; i <= n; ++i) {\n            int u = rnd.next(1, i - 1);\n            int v = i;\n            edges.push_back({u, v});\n        }\n\n    } else if (type == \"random\") {\n        // Generate a connected graph with m edges\n\n        if (m == -1) m = 2 * n; // default m\n        ensure(n - 1 <= m && m <= MAX_M);\n\n        // Generate initial tree\n        for (int i = 2; i <= n; ++i) {\n            int u = rnd.next(1, i - 1);\n            int v = i;\n            edges.push_back({u, v});\n        }\n\n        // Generate additional edges\n        set<pair<int, int>> edgeSet;\n        for (auto e : edges) {\n            int u = e.first;\n            int v = e.second;\n            if (u > v) swap(u, v);\n            edgeSet.insert({u, v});\n        }\n\n        while ((int)edges.size() < m) {\n            int u = rnd.next(1, n);\n            int v = rnd.next(1, n);\n            if (u == v) continue;\n            if (u > v) swap(u, v);\n            if (edgeSet.count({u, v})) continue;\n            edgeSet.insert({u, v});\n            edges.push_back({u, v});\n        }\n\n    } else {\n        quitf(_fail, \"Unknown type: %s\", type.c_str());\n    }\n\n    ensure((int)edges.size() == m);\n\n    // Assign edge statuses\n    for (size_t i = 0; i < edges.size(); ++i) {\n        int status = (rnd.next(0.0, 1.0) < p) ? 1 : 0;\n        z.push_back(status);\n    }\n\n    // Shuffle edges\n    shuffle(edges.begin(), edges.end());\n\n    // Output n and m\n    printf(\"%d %d\\n\", n, m);\n    // Output edges\n    for (size_t i = 0; i < edges.size(); ++i) {\n        int x = edges[i].first;\n        int y = edges[i].second;\n        int status = z[i];\n        printf(\"%d %d %d\\n\", x, y, status);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAX_N = 100000;\nconst int MAX_M = 300000;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\", -1);\n    string type = opt<string>(\"type\", \"random\");\n    double p = opt<double>(\"p\", 0.5);\n\n    ensure(2 <= n && n <= MAX_N);\n\n    vector<pair<int, int>> edges;\n    vector<int> z;\n\n    if (type == \"path\") {\n        // Generate a path from 1 to n\n\n        if (m == -1) m = n - 1;\n        ensure(m == n - 1);\n\n        for (int i = 1; i < n; ++i) {\n            edges.push_back({i, i + 1});\n        }\n\n    } else if (type == \"star\") {\n        // Generate a star graph with center at node 1\n\n        if (m == -1) m = n - 1;\n        ensure(m == n - 1);\n\n        for (int i = 2; i <= n; ++i) {\n            edges.push_back({1, i});\n        }\n\n    } else if (type == \"tree\") {\n        // Generate a random tree\n\n        if (m == -1) m = n - 1;\n        ensure(m == n - 1);\n\n        for (int i = 2; i <= n; ++i) {\n            int u = rnd.next(1, i - 1);\n            int v = i;\n            edges.push_back({u, v});\n        }\n\n    } else if (type == \"random\") {\n        // Generate a connected graph with m edges\n\n        if (m == -1) m = 2 * n; // default m\n        ensure(n - 1 <= m && m <= MAX_M);\n\n        // Generate initial tree\n        for (int i = 2; i <= n; ++i) {\n            int u = rnd.next(1, i - 1);\n            int v = i;\n            edges.push_back({u, v});\n        }\n\n        // Generate additional edges\n        set<pair<int, int>> edgeSet;\n        for (auto e : edges) {\n            int u = e.first;\n            int v = e.second;\n            if (u > v) swap(u, v);\n            edgeSet.insert({u, v});\n        }\n\n        while ((int)edges.size() < m) {\n            int u = rnd.next(1, n);\n            int v = rnd.next(1, n);\n            if (u == v) continue;\n            if (u > v) swap(u, v);\n            if (edgeSet.count({u, v})) continue;\n            edgeSet.insert({u, v});\n            edges.push_back({u, v});\n        }\n\n    } else {\n        quitf(_fail, \"Unknown type: %s\", type.c_str());\n    }\n\n    ensure((int)edges.size() == m);\n\n    // Assign edge statuses\n    for (size_t i = 0; i < edges.size(); ++i) {\n        int status = (rnd.next(0.0, 1.0) < p) ? 1 : 0;\n        z.push_back(status);\n    }\n\n    // Shuffle edges\n    shuffle(edges.begin(), edges.end());\n\n    // Output n and m\n    printf(\"%d %d\\n\", n, m);\n    // Output edges\n    for (size_t i = 0; i < edges.size(); ++i) {\n        int x = edges[i].first;\n        int y = edges[i].second;\n        int status = z[i];\n        printf(\"%d %d %d\\n\", x, y, status);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 2 -type path -p 0.0\n./gen -n 2 -type path -p 1.0\n./gen -n 2 -type star -p 0.0\n./gen -n 2 -type star -p 1.0\n\n./gen -n 10 -type path -p 0.5\n./gen -n 10 -type star -p 0.5\n./gen -n 10 -type tree -p 0.0\n./gen -n 10 -type tree -p 1.0\n./gen -n 10 -type random -m 20 -p 0.5\n\n./gen -n 100 -type path -p 0.2\n./gen -n 100 -type path -p 0.8\n./gen -n 100 -type tree -p 0.5\n./gen -n 100 -type random -m 300 -p 0.5\n\n./gen -n 1000 -type path -p 0.5\n./gen -n 1000 -type star -p 0.5\n./gen -n 1000 -type tree -p 0.1\n./gen -n 1000 -type tree -p 0.9\n./gen -n 1000 -type random -m 3000 -p 0.5\n\n./gen -n 10000 -type path -p 0.5\n./gen -n 10000 -type tree -p 0.5\n./gen -n 10000 -type random -m 30000 -p 0.5\n\n./gen -n 100000 -type path -p 0.5\n./gen -n 100000 -type tree -p 0.5\n./gen -n 100000 -type random -m 300000 -p 0.5\n\n./gen -n 100000 -type random -m 300000 -p 0.99\n./gen -n 100000 -type random -m 300000 -p 0.01\n\n# Edge cases with all edges working\n./gen -n 1000 -type tree -p 1.0\n\n# Edge cases with all edges broken\n./gen -n 1000 -type tree -p 0.0\n\n# Edge cases where the shortest path is functional, nothing needs to be changed\n./gen -n 1000 -type path -p 1.0\n\n# Edge cases where the shortest path is broken, all edges need to be repaired\n./gen -n 1000 -type path -p 0.0\n\n# Edge cases with minimal number of changes\n./gen -n 100000 -type path -p 1.0\n\n# Edge cases with maximal number of changes\n./gen -n 100000 -type path -p 0.0\n\n# Edge cases where almost all non-path edges are working, need to be blown up\n./gen -n 100000 -type path -p 0.99\n\n# Edge cases where almost all non-path edges are broken, no need to be blown up\n./gen -n 100000 -type random -m 300000 -p 0.01\n\n# Edge case where m = n - 1\n./gen -n 100000 -type tree -p 0.5\n\n# Edge case where m is maximal\n./gen -n 100000 -m 300000 -type random -p 0.5\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:40:59.417059",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "508/A",
      "title": "A. Pasha and Pixels",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line of the input contains three integers n, m, k (1 ≤ n, m ≤ 1000, 1 ≤ k ≤ 105) — the number of rows, the number of columns and the number of moves that Pasha is going to perform. The next k lines contain Pasha's moves in the order he makes them. Each line contains two integers i and j (1 ≤ i ≤ n, 1 ≤ j ≤ m), representing the row number and column number of the pixel that was painted during a move.",
      "output_spec": "OutputIf Pasha loses, print the number of the move when the 2 × 2 square consisting of black pixels is formed.If Pasha doesn't lose, that is, no 2 × 2 square consisting of black pixels is formed during the given k moves, print 0.",
      "sample_tests": "ExamplesInputCopy2 2 41 11 22 12 2OutputCopy4InputCopy2 3 62 32 21 32 21 21 1OutputCopy5InputCopy5 3 72 31 21 14 13 15 33 2OutputCopy0",
      "description": "A. Pasha and Pixels\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line of the input contains three integers n, m, k (1 ≤ n, m ≤ 1000, 1 ≤ k ≤ 105) — the number of rows, the number of columns and the number of moves that Pasha is going to perform. The next k lines contain Pasha's moves in the order he makes them. Each line contains two integers i and j (1 ≤ i ≤ n, 1 ≤ j ≤ m), representing the row number and column number of the pixel that was painted during a move.\n\nOutputIf Pasha loses, print the number of the move when the 2 × 2 square consisting of black pixels is formed.If Pasha doesn't lose, that is, no 2 × 2 square consisting of black pixels is formed during the given k moves, print 0.\n\nInputCopy2 2 41 11 22 12 2OutputCopy4InputCopy2 3 62 32 21 32 21 21 1OutputCopy5InputCopy5 3 72 31 21 14 13 15 33 2OutputCopy0\n\nInputCopy2 2 41 11 22 12 2\n\nOutputCopy4\n\nInputCopy2 3 62 32 21 32 21 21 1\n\nOutputCopy5\n\nInputCopy5 3 72 31 21 14 13 15 33 2\n\nOutputCopy0",
      "solutions": [
        {
          "title": "Codeforces Round #288 (Div. 2) - Codeforces",
          "content": "Hello, Codeforces!I'd like to invite you to Codeforces Round #288 (Div. 2). It'll be held on Tuesday, January 27 at 19:30 MSK and as usual Div. 1 participants can join out of competition.Great thanks to Maxim Akhmedov (Zlobober) for helping me preparing the contest, to Maria Belova (Delinur) for translating the statements into English, to Mike Mirzayanov (MikeMirzayanov) for the great Polygon platform and ideas of some problems and to my dear teammates Arthur Svechnikov (ikar) and Ilya Los (IlyaLos) for writing solutions.The scoring distribution will be announced later. Good luck everyone!UPD Score system is standart 500-1000-1500-2000-2500. UPD2 Competition completed! Thank you all!UPD3 You can find editorial here.UPD4 Congratulations to the winners! topcoder.2015 KimJongUn_JBYongDongJI atatomir pankaj_gudlani egor_bb",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/16035",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 830
        },
        {
          "title": "Codeforces Round #288 (Div.2) Editorial - Codeforces",
          "content": "508A — Pasha and PixelsTo solve this problem let's create matrix with type bool and dimensions n on m. Cell (x, y) of this matrix is true — if this cell painted in black color.Let on move number k Pasha paints pixel in position (i, j). Then game ending on this move, if square 2 × 2 formed from black cells appears, and cell (i, j) will upper-left, upper-right, bottom-left or bottom-right of this squares. Only this squares we need to check on current move. If we haven't such squares after k moves, print 0. Asymptotic behavior of this solution — O(k), where k — number of moves.508B — Anton and currency you all knowBecause of specified number is odd (that mean that last digit of this number is odd) we need to swap last digit with some even digit. How to maximize number after this swap?If number consists only from odd digits print  - 1.Else, we need to find first even digit, which less than last digit if we will iterate from most significant digit. If we find such digit — swap it with last digit and we have an answer. Else, we need to find first even digit, which more than last digit if we will iterate from less significant digit. If we find such digit — swap it with last digit and we have an answer.Asymptotic behavior of this solution — O(n), where n — count of digits in specified number.508C — Anya and GhostsThis problem can be solved with help of greedy algorithm. Let's iterate on moments when ghosts will appears.We need to use use array, in wich we will mark moments of time, in wich we lighted candles (for example, put in corresponding positions 1). Than for every new ghost will count how many candles lights in time of his visit from our array.If ghost appears in moment of time wi, iterate on out array from wi - 1 to wi - t, where t — count of seconds, which candle burns, and count the number of ones. If this count is not less than r, continue iterating on ghosts. Else, iterate on our array from wi - 1 to wi - t, and, if in current second candle didn't lighted — make it, and put in this position in array 1. We need to do such operation, while count of ones in this section of our array will not be equals to r. If we can't do this fore some ghost, we can print  - 1.Answer to this problem — count of ones in our array. Asymptotic behavior of this solution — O(mt), where m — count of ghosts, t — the duration of a candle's burning.508D — Tanya and PasswordAt first, let's convert data from input in directed graph. Vertexes in this graph will all strings with length equals to 2 and consisting of uppercase and lowercase letters of the latin alphabet. For all 3-letters strings from input — si's, let's add edge from vertex si[0]si[1] to si[1]si[2]. Now we need to find in this graph Euler path. For this we can use Fleury's algorithm. It is worth noting, that Euler path consists, if count of vertexes, in wich in-degree and out-degree differs by one, less then 3, and in-degree and out-degree of others vertexes — even. If we can't find Euler path — print NO. Asymptotic behavior of this solution — O(m), where m — count of different 3-letters strings from input. It equals to number of edges in graphs.508E — Arthur and BracketsThis problem can be solved with help of dynamic dynamic programming. Let's create squre matrix Z with sizes n × n, where n — count of open brackets in sequence. Main hint — if open bracket is in position l, and corresponding for her close bracket — in position r, than from position l + 1 to position r - 1 must stay a regular bracket sequence.In array Z first parametr lf — number of open bracket, second parametr rg — number of last open bracket, which can be in a regular bracket sequence, which will exists between open bracket with number lf and corresponding for it close bracket.Z[lf][rg] = true if it is possible to construct such sequence. Otherwise Z[lf][rg] = false.For current lf and rg let's iterate on cnt — how many open brackets and corresponding them close brackets in a regular bracket sequence will stay between open bracket number lf and corresponding for it close bracket. If this count falls in the given interval for open bracket lf, recurcively run dynamic from two segments — (lf + 1, lf + cnt) and (lf + cnt + 1, rg). If for both segments we can construct regular bracket sequences, appropriate to data-in from input, put in Z[lf][rg] value true. To restore answer, we must move from segment (lf, rg) in segments (lf + 1, lf + cnt) and (lf + cnt + 1, rg), if for both this segments we can construct regular bracket sequences and recursively restore asnwer. If Z[0][n - 1] equals to false, print IMPOSSIBLE. Asymptotic behavior of this solution — O(n3).UPD This problem can be solved with help of griddy algorithm. Asymptotic behavior of this solution — O(n). Here is example of such solution, participant matrix.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/16048?locale=en",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 508\\s*A"
          },
          "content_length": 4804
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #288 (Div. 2) - Codeforces - Code 1",
          "code": "int ip = 0, comp = 0, ini;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16035",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #288 (Div. 2) - Codeforces - Code 2",
          "code": "1000 1000 1000\n1000 1\n1000 2\n1000 3\n...\n1000 1000",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16035",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #288 (Div. 2) - Codeforces - Code 3",
          "code": "1000 1000 1000\n1000 1\n1000 2\n1000 3\n...\n1000 1000",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16035",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #288 (Div.2) Editorial - Codeforces - Code 1",
          "code": "3\n2 5\n1 4\n1 4",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16048?locale=en",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #288 (Div.2) Editorial - Codeforces - Code 2",
          "code": "3\n2 5\n1 4\n1 4",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16048?locale=en",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #288 (Div.2) Editorial - Codeforces - Code 3",
          "code": "j\n    v\n((()))\n ^^ \n ki",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16048?locale=en",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #288 (Div.2) Editorial - Codeforces - Code 4",
          "code": "j\n    v\n((()))\n ^^ \n ki",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16048?locale=en",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #288 (Div.2) Editorial - Codeforces - Code 5",
          "code": "j\n  --v\n((()))\n\nturns into\n\n  j \n  v--\n(()())",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16048?locale=en",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #288 (Div.2) Editorial - Codeforces - Code 6",
          "code": "j\n  --v\n((()))\n\nturns into\n\n  j \n  v--\n(()())",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16048?locale=en",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    // Read n, m, k\n    int n = inf.readInt(1, 1000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 1000, \"m\");\n    inf.readSpace();\n    int k = inf.readInt(1, 100000, \"k\");\n    inf.readEoln();\n\n    // Read each move\n    for (int move = 1; move <= k; ++move) {\n        int i = inf.readInt(1, n, \"i\");\n        inf.readSpace();\n        int j = inf.readInt(1, m, \"j\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    // Read n, m, k\n    int n = inf.readInt(1, 1000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 1000, \"m\");\n    inf.readSpace();\n    int k = inf.readInt(1, 100000, \"k\");\n    inf.readEoln();\n\n    // Read each move\n    for (int move = 1; move <= k; ++move) {\n        int i = inf.readInt(1, n, \"i\");\n        inf.readSpace();\n        int j = inf.readInt(1, m, \"j\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    // Read n, m, k\n    int n = inf.readInt(1, 1000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 1000, \"m\");\n    inf.readSpace();\n    int k = inf.readInt(1, 100000, \"k\");\n    inf.readEoln();\n\n    // Read each move\n    for (int move = 1; move <= k; ++move) {\n        int i = inf.readInt(1, n, \"i\");\n        inf.readSpace();\n        int j = inf.readInt(1, m, \"j\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    int k = opt<int>(\"k\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<pair<int,int>> moves;\n\n    if (type == \"immediate_loss\") {\n        // Create a test case where Pasha loses as soon as possible\n        if (n >=2 && m >=2 && k >=4) {\n            moves.push_back({1,1});\n            moves.push_back({1,2});\n            moves.push_back({2,1});\n            moves.push_back({2,2});\n            // Fill the rest with random moves if k > 4\n            for (int i = 5; i <= k; i++) {\n                int x = rnd.next(1, n);\n                int y = rnd.next(1, m);\n                moves.push_back({x, y});\n            }\n        } else {\n            // Generate random moves\n            for (int i = 0; i < k; i++) {\n                int x = rnd.next(1, n);\n                int y = rnd.next(1, m);\n                moves.push_back({x, y});\n            }\n        }\n\n\n    } else if (type == \"never_lose\") {\n        // Create a test case where Pasha never loses\n        set<pair<int,int>> painted;\n\n        int total_cells = n * m;\n\n        int max_moves = min(k, (n * m + 1) / 2);\n\n        // Generate all cells where (x + y) % 2 == 0\n\n        for (int x = 1; x <= n && painted.size() < max_moves; x++) {\n            for (int y = 1; y <= m && painted.size() < max_moves; y++) {\n                if ((x + y) % 2 == 0) {\n                    moves.push_back({x, y});\n                    painted.insert({x, y});\n                }\n            }\n        }\n\n        // If k > max_moves, fill rest with random moves\n        while (moves.size() < k) {\n            int x = rnd.next(1, n);\n            int y = rnd.next(1, m);\n            moves.push_back({x, y});\n        }\n\n    } else if (type == \"random\") {\n        // Generate random moves\n        for (int i = 0; i < k; i++) {\n            int x = rnd.next(1, n);\n            int y = rnd.next(1, m);\n            moves.push_back({x, y});\n        }\n    } else if (type == \"max_k\") {\n        // Generate test case with k maximal and random moves\n        k = min(k, 100000);\n        for (int i = 0; i < k; i++) {\n            int x = rnd.next(1, n);\n            int y = rnd.next(1, m);\n            moves.push_back({x, y});\n        }\n    } else if (type == \"repaint_same\") {\n        // Repaint the same cell multiple times\n        int x = rnd.next(1, n);\n        int y = rnd.next(1, m);\n\n        for (int i = 0; i < k; i++) {\n            moves.push_back({x, y});\n        }\n    } else if (type == \"single_move\") {\n        // Single move test case\n        k = min(k, 1);\n        int x = rnd.next(1, n);\n        int y = rnd.next(1, m);\n        moves.push_back({x, y});\n    } else {\n        // Default: generate random moves\n        for (int i = 0; i < k; i++) {\n            int x = rnd.next(1, n);\n            int y = rnd.next(1, m);\n            moves.push_back({x, y});\n        }\n    }\n\n    // Output\n    printf(\"%d %d %d\\n\", n, m, k);\n    for (int i = 0; i < moves.size(); i++) {\n        printf(\"%d %d\\n\", moves[i].first, moves[i].second);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    int k = opt<int>(\"k\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<pair<int,int>> moves;\n\n    if (type == \"immediate_loss\") {\n        // Create a test case where Pasha loses as soon as possible\n        if (n >=2 && m >=2 && k >=4) {\n            moves.push_back({1,1});\n            moves.push_back({1,2});\n            moves.push_back({2,1});\n            moves.push_back({2,2});\n            // Fill the rest with random moves if k > 4\n            for (int i = 5; i <= k; i++) {\n                int x = rnd.next(1, n);\n                int y = rnd.next(1, m);\n                moves.push_back({x, y});\n            }\n        } else {\n            // Generate random moves\n            for (int i = 0; i < k; i++) {\n                int x = rnd.next(1, n);\n                int y = rnd.next(1, m);\n                moves.push_back({x, y});\n            }\n        }\n\n\n    } else if (type == \"never_lose\") {\n        // Create a test case where Pasha never loses\n        set<pair<int,int>> painted;\n\n        int total_cells = n * m;\n\n        int max_moves = min(k, (n * m + 1) / 2);\n\n        // Generate all cells where (x + y) % 2 == 0\n\n        for (int x = 1; x <= n && painted.size() < max_moves; x++) {\n            for (int y = 1; y <= m && painted.size() < max_moves; y++) {\n                if ((x + y) % 2 == 0) {\n                    moves.push_back({x, y});\n                    painted.insert({x, y});\n                }\n            }\n        }\n\n        // If k > max_moves, fill rest with random moves\n        while (moves.size() < k) {\n            int x = rnd.next(1, n);\n            int y = rnd.next(1, m);\n            moves.push_back({x, y});\n        }\n\n    } else if (type == \"random\") {\n        // Generate random moves\n        for (int i = 0; i < k; i++) {\n            int x = rnd.next(1, n);\n            int y = rnd.next(1, m);\n            moves.push_back({x, y});\n        }\n    } else if (type == \"max_k\") {\n        // Generate test case with k maximal and random moves\n        k = min(k, 100000);\n        for (int i = 0; i < k; i++) {\n            int x = rnd.next(1, n);\n            int y = rnd.next(1, m);\n            moves.push_back({x, y});\n        }\n    } else if (type == \"repaint_same\") {\n        // Repaint the same cell multiple times\n        int x = rnd.next(1, n);\n        int y = rnd.next(1, m);\n\n        for (int i = 0; i < k; i++) {\n            moves.push_back({x, y});\n        }\n    } else if (type == \"single_move\") {\n        // Single move test case\n        k = min(k, 1);\n        int x = rnd.next(1, n);\n        int y = rnd.next(1, m);\n        moves.push_back({x, y});\n    } else {\n        // Default: generate random moves\n        for (int i = 0; i < k; i++) {\n            int x = rnd.next(1, n);\n            int y = rnd.next(1, m);\n            moves.push_back({x, y});\n        }\n    }\n\n    // Output\n    printf(\"%d %d %d\\n\", n, m, k);\n    for (int i = 0; i < moves.size(); i++) {\n        printf(\"%d %d\\n\", moves[i].first, moves[i].second);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 2 -m 2 -k 4 -type immediate_loss\n./gen -n 2 -m 2 -k 4 -type never_lose\n./gen -n 2 -m 2 -k 4 -type random\n\n./gen -n 1 -m 1 -k 1 -type immediate_loss\n./gen -n 1 -m 1 -k 1 -type never_lose\n\n./gen -n 1000 -m 1000 -k 100000 -type random\n./gen -n 1000 -m 1000 -k 100000 -type immediate_loss\n./gen -n 1000 -m 1000 -k 100000 -type never_lose\n\n./gen -n 999 -m 1000 -k 99999 -type random\n./gen -n 1000 -m 999 -k 100000 -type max_k\n\n./gen -n 500 -m 500 -k 10000 -type immediate_loss\n./gen -n 500 -m 500 -k 10000 -type never_lose\n\n./gen -n 1000 -m 1000 -k 50000 -type repaint_same\n\n./gen -n 1 -m 1000 -k 1000 -type random\n./gen -n 1000 -m 1 -k 1000 -type random\n\n./gen -n 1 -m 1000 -k 1000 -type never_lose\n./gen -n 1000 -m 1 -k 1000 -type never_lose\n\n./gen -n 1 -m 1 -k 100000 -type repaint_same\n./gen -n 1 -m 1 -k 1 -type single_move\n\n./gen -n 1000 -m 1000 -k 1 -type single_move\n\n./gen -n 2 -m 2 -k 100000 -type repaint_same\n\n./gen -n 1000 -m 1000 -k 100000 -type small_grid\n\n./gen -n 1 -m 1000 -k 100000 -type repaint_same\n\n./gen -n 2 -m 2 -k 3 -type immediate_loss\n./gen -n 2 -m 2 -k 3 -type never_lose\n./gen -n 2 -m 2 -k 3 -type random\n\n./gen -n 2 -m 2 -k 5 -type immediate_loss\n\n./gen -n 1000 -m 1000 -k 1 -type immediate_loss\n./gen -n 1000 -m 1000 -k 4 -type immediate_loss\n\n./gen -n 3 -m 3 -k 10 -type random\n\n./gen -n 1000 -m 1000 -k 100000 -type random\n\n./gen -n 1000 -m 1000 -k 100000 -type never_lose\n\n./gen -n 1000 -m 1000 -k 100000 -type repaint_same\n\n./gen -n 1000 -m 1000 -k 100000 -type single_move\n\n./gen -n 500 -m 500 -k 100000 -type max_k\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:41:01.063903",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "508/B",
      "title": "B. Anton and currency you all know",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test0.5 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains an odd positive integer n — the exchange rate of currency you all know for today. The length of number n's representation is within range from 2 to 105, inclusive. The representation of n doesn't contain any leading zeroes.",
      "output_spec": "OutputIf the information about tomorrow's exchange rate is inconsistent, that is, there is no integer that meets the condition, print  - 1.Otherwise, print the exchange rate of currency you all know against the burle for tomorrow. This should be the maximum possible number of those that are even and that are obtained from today's exchange rate by swapping exactly two digits. Exchange rate representation should not contain leading zeroes.",
      "sample_tests": "ExamplesInputCopy527OutputCopy572InputCopy4573OutputCopy3574InputCopy1357997531OutputCopy-1",
      "description": "B. Anton and currency you all know\n\ntime limit per test0.5 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains an odd positive integer n — the exchange rate of currency you all know for today. The length of number n's representation is within range from 2 to 105, inclusive. The representation of n doesn't contain any leading zeroes.\n\nOutputIf the information about tomorrow's exchange rate is inconsistent, that is, there is no integer that meets the condition, print  - 1.Otherwise, print the exchange rate of currency you all know against the burle for tomorrow. This should be the maximum possible number of those that are even and that are obtained from today's exchange rate by swapping exactly two digits. Exchange rate representation should not contain leading zeroes.\n\nInputCopy527OutputCopy572InputCopy4573OutputCopy3574InputCopy1357997531OutputCopy-1\n\nInputCopy527\n\nOutputCopy572\n\nInputCopy4573\n\nOutputCopy3574\n\nInputCopy1357997531\n\nOutputCopy-1",
      "solutions": [
        {
          "title": "Codeforces Round #288 (Div. 2) - Codeforces",
          "content": "Hello, Codeforces!I'd like to invite you to Codeforces Round #288 (Div. 2). It'll be held on Tuesday, January 27 at 19:30 MSK and as usual Div. 1 participants can join out of competition.Great thanks to Maxim Akhmedov (Zlobober) for helping me preparing the contest, to Maria Belova (Delinur) for translating the statements into English, to Mike Mirzayanov (MikeMirzayanov) for the great Polygon platform and ideas of some problems and to my dear teammates Arthur Svechnikov (ikar) and Ilya Los (IlyaLos) for writing solutions.The scoring distribution will be announced later. Good luck everyone!UPD Score system is standart 500-1000-1500-2000-2500. UPD2 Competition completed! Thank you all!UPD3 You can find editorial here.UPD4 Congratulations to the winners! topcoder.2015 KimJongUn_JBYongDongJI atatomir pankaj_gudlani egor_bb",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/16035",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 830
        },
        {
          "title": "Codeforces Round #288 (Div.2) Editorial - Codeforces",
          "content": "508A — Pasha and PixelsTo solve this problem let's create matrix with type bool and dimensions n on m. Cell (x, y) of this matrix is true — if this cell painted in black color.Let on move number k Pasha paints pixel in position (i, j). Then game ending on this move, if square 2 × 2 formed from black cells appears, and cell (i, j) will upper-left, upper-right, bottom-left or bottom-right of this squares. Only this squares we need to check on current move. If we haven't such squares after k moves, print 0. Asymptotic behavior of this solution — O(k), where k — number of moves.508B — Anton and currency you all knowBecause of specified number is odd (that mean that last digit of this number is odd) we need to swap last digit with some even digit. How to maximize number after this swap?If number consists only from odd digits print  - 1.Else, we need to find first even digit, which less than last digit if we will iterate from most significant digit. If we find such digit — swap it with last digit and we have an answer. Else, we need to find first even digit, which more than last digit if we will iterate from less significant digit. If we find such digit — swap it with last digit and we have an answer.Asymptotic behavior of this solution — O(n), where n — count of digits in specified number.508C — Anya and GhostsThis problem can be solved with help of greedy algorithm. Let's iterate on moments when ghosts will appears.We need to use use array, in wich we will mark moments of time, in wich we lighted candles (for example, put in corresponding positions 1). Than for every new ghost will count how many candles lights in time of his visit from our array.If ghost appears in moment of time wi, iterate on out array from wi - 1 to wi - t, where t — count of seconds, which candle burns, and count the number of ones. If this count is not less than r, continue iterating on ghosts. Else, iterate on our array from wi - 1 to wi - t, and, if in current second candle didn't lighted — make it, and put in this position in array 1. We need to do such operation, while count of ones in this section of our array will not be equals to r. If we can't do this fore some ghost, we can print  - 1.Answer to this problem — count of ones in our array. Asymptotic behavior of this solution — O(mt), where m — count of ghosts, t — the duration of a candle's burning.508D — Tanya and PasswordAt first, let's convert data from input in directed graph. Vertexes in this graph will all strings with length equals to 2 and consisting of uppercase and lowercase letters of the latin alphabet. For all 3-letters strings from input — si's, let's add edge from vertex si[0]si[1] to si[1]si[2]. Now we need to find in this graph Euler path. For this we can use Fleury's algorithm. It is worth noting, that Euler path consists, if count of vertexes, in wich in-degree and out-degree differs by one, less then 3, and in-degree and out-degree of others vertexes — even. If we can't find Euler path — print NO. Asymptotic behavior of this solution — O(m), where m — count of different 3-letters strings from input. It equals to number of edges in graphs.508E — Arthur and BracketsThis problem can be solved with help of dynamic dynamic programming. Let's create squre matrix Z with sizes n × n, where n — count of open brackets in sequence. Main hint — if open bracket is in position l, and corresponding for her close bracket — in position r, than from position l + 1 to position r - 1 must stay a regular bracket sequence.In array Z first parametr lf — number of open bracket, second parametr rg — number of last open bracket, which can be in a regular bracket sequence, which will exists between open bracket with number lf and corresponding for it close bracket.Z[lf][rg] = true if it is possible to construct such sequence. Otherwise Z[lf][rg] = false.For current lf and rg let's iterate on cnt — how many open brackets and corresponding them close brackets in a regular bracket sequence will stay between open bracket number lf and corresponding for it close bracket. If this count falls in the given interval for open bracket lf, recurcively run dynamic from two segments — (lf + 1, lf + cnt) and (lf + cnt + 1, rg). If for both segments we can construct regular bracket sequences, appropriate to data-in from input, put in Z[lf][rg] value true. To restore answer, we must move from segment (lf, rg) in segments (lf + 1, lf + cnt) and (lf + cnt + 1, rg), if for both this segments we can construct regular bracket sequences and recursively restore asnwer. If Z[0][n - 1] equals to false, print IMPOSSIBLE. Asymptotic behavior of this solution — O(n3).UPD This problem can be solved with help of griddy algorithm. Asymptotic behavior of this solution — O(n). Here is example of such solution, participant matrix.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/16048?locale=en",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 508\\s*B"
          },
          "content_length": 4804
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #288 (Div. 2) - Codeforces - Code 1",
          "code": "int ip = 0, comp = 0, ini;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16035",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #288 (Div. 2) - Codeforces - Code 2",
          "code": "1000 1000 1000\n1000 1\n1000 2\n1000 3\n...\n1000 1000",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16035",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #288 (Div. 2) - Codeforces - Code 3",
          "code": "1000 1000 1000\n1000 1\n1000 2\n1000 3\n...\n1000 1000",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16035",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #288 (Div.2) Editorial - Codeforces - Code 1",
          "code": "3\n2 5\n1 4\n1 4",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16048?locale=en",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #288 (Div.2) Editorial - Codeforces - Code 2",
          "code": "3\n2 5\n1 4\n1 4",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16048?locale=en",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #288 (Div.2) Editorial - Codeforces - Code 3",
          "code": "j\n    v\n((()))\n ^^ \n ki",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16048?locale=en",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #288 (Div.2) Editorial - Codeforces - Code 4",
          "code": "j\n    v\n((()))\n ^^ \n ki",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16048?locale=en",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #288 (Div.2) Editorial - Codeforces - Code 5",
          "code": "j\n  --v\n((()))\n\nturns into\n\n  j \n  v--\n(()())",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16048?locale=en",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #288 (Div.2) Editorial - Codeforces - Code 6",
          "code": "j\n  --v\n((()))\n\nturns into\n\n  j \n  v--\n(()())",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16048?locale=en",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    string n_str = inf.readToken(\"[1-9][0-9]{1,99999}\", \"n\");\n    inf.readEoln();\n\n    // Check that n is odd\n    char last_digit = n_str.back();\n    ensuref(last_digit == '1' || last_digit == '3' || last_digit == '5' || last_digit == '7' || last_digit == '9',\n            \"n must be odd, last digit=%c\", last_digit);\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    string n_str = inf.readToken(\"[1-9][0-9]{1,99999}\", \"n\");\n    inf.readEoln();\n\n    // Check that n is odd\n    char last_digit = n_str.back();\n    ensuref(last_digit == '1' || last_digit == '3' || last_digit == '5' || last_digit == '7' || last_digit == '9',\n            \"n must be odd, last digit=%c\", last_digit);\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    string n_str = inf.readToken(\"[1-9][0-9]{1,99999}\", \"n\");\n    inf.readEoln();\n\n    // Check that n is odd\n    char last_digit = n_str.back();\n    ensuref(last_digit == '1' || last_digit == '3' || last_digit == '5' || last_digit == '7' || last_digit == '9',\n            \"n must be odd, last digit=%c\", last_digit);\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n#include <string>\r\n\r\nusing namespace std;\r\n\r\npattern pnum(\"0|-?[1-9][0-9]*\");\r\n\r\nbool isNumeric(const string &p) {\r\n    return pnum.matches(p);\r\n}\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare two signed huge integers\");\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    string ja = ans.readWord();\r\n    string pa = ouf.readWord();\r\n\r\n    if (!isNumeric(ja))\r\n        quitf(_fail, \"%s is not a valid integer\", compress(ja).c_str());\r\n\r\n    if (!ans.seekEof())\r\n        quitf(_fail, \"expected exactly one token in the answer file\");\r\n\r\n    if (!isNumeric(pa))\r\n        quitf(_pe, \"%s is not a valid integer\", compress(pa).c_str());\r\n\r\n    if (ja != pa)\r\n        quitf(_wa, \"expected '%s', found '%s'\", compress(ja).c_str(), compress(pa).c_str());\r\n\r\n    quitf(_ok, \"answer is '%s'\", compress(ja).c_str());\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    int len = opt<int>(\"len\");\n    string type = opt<string>(\"type\", \"random\");\n\n    // Ensure length is within constraints\n    ensure(len >= 2 && len <= 100000);\n\n    string n_str;\n    if (type == \"random\") {\n        // Generate random n of length len, odd, no leading zeros\n        int first_digit = rnd.next(1, 9);\n        n_str += char('0' + first_digit);\n        if (len > 1) {\n            for (int i = 1; i < len -1; ++i) {\n                int digit = rnd.next(0,9);\n                n_str += char('0' + digit);\n            }\n            // Last digit must be odd\n            int last_digit = rnd.next(0, 4);\n            int odd_digit = last_digit * 2 + 1; // 1,3,5,7,9\n            n_str += char('0' + odd_digit);\n        }\n    } else if (type == \"all_odd\") {\n        // All digits are odd\n        vector<int> odd_digits = {1,3,5,7,9};\n        int first_digit = odd_digits[rnd.next(0,4)];\n        n_str += char('0' + first_digit);\n        for (int i = 1; i < len; ++i) {\n            int digit = odd_digits[rnd.next(0,4)];\n            n_str += char('0' + digit);\n        }\n    } else if (type == \"all_even\") {\n        // n is odd but have as many even digits as possible\n        vector<int> even_digits = {2,4,6,8};\n        int first_digit = even_digits[rnd.next(0,3)];\n        n_str += char('0' + first_digit);\n        for (int i = 1; i < len -1; ++i) {\n            int digit = even_digits[rnd.next(0,3)];\n            n_str += char('0' + digit);\n        }\n        // Last digit must be odd\n        vector<int> odd_digits = {1,3,5,7,9};\n        int last_digit = odd_digits[rnd.next(0,4)];\n        n_str += char('0' + last_digit);\n    } else if (type == \"maximum_case\") {\n        // n is the maximum possible odd number of length len\n        n_str += '9';\n        for (int i = 1; i < len - 1; ++i) {\n            n_str += '9';\n        }\n        // Last digit must be odd\n        n_str += '9';\n    } else if (type == \"minimum_case\") {\n        // n is the minimum possible odd number of length len\n        n_str += '1';\n        for (int i = 1; i < len - 1; ++i) {\n            n_str += '0';\n        }\n        // Last digit must be odd\n        n_str += '1';\n    } else if (type == \"leading_zero_after_swap\") {\n        // Only even digits at positions that would cause leading zero after swap\n        int even_digit = 2 * rnd.next(1, 4); // 2,4,6,8\n        n_str += char('0' + even_digit); // First digit is even\n        for(int i = 1; i < len - 1; ++i) {\n            n_str += '1'; // Middle digits are '1', all odd\n        }\n        // Last digit must be odd\n        int last_digit = rnd.next(0,4)*2+1; // Odd number 1-9\n        n_str += char('0' + last_digit);\n    } else if (type == \"special_no_even_possible\") {\n        // All digits odd, swapping any two digits cannot produce even number\n        vector<int> odd_digits = {1,3,5,7,9};\n        int first_digit = odd_digits[rnd.next(0,4)];\n        n_str += char('0' + first_digit);\n        for (int i = 1; i < len; ++i) {\n            int digit = odd_digits[rnd.next(0,4)];\n            n_str += char('0' + digit);\n        }\n    } else {\n        // Default case\n        n_str = \"11\";\n    }\n\n    // Output n\n    printf(\"%s\\n\", n_str.c_str());\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    int len = opt<int>(\"len\");\n    string type = opt<string>(\"type\", \"random\");\n\n    // Ensure length is within constraints\n    ensure(len >= 2 && len <= 100000);\n\n    string n_str;\n    if (type == \"random\") {\n        // Generate random n of length len, odd, no leading zeros\n        int first_digit = rnd.next(1, 9);\n        n_str += char('0' + first_digit);\n        if (len > 1) {\n            for (int i = 1; i < len -1; ++i) {\n                int digit = rnd.next(0,9);\n                n_str += char('0' + digit);\n            }\n            // Last digit must be odd\n            int last_digit = rnd.next(0, 4);\n            int odd_digit = last_digit * 2 + 1; // 1,3,5,7,9\n            n_str += char('0' + odd_digit);\n        }\n    } else if (type == \"all_odd\") {\n        // All digits are odd\n        vector<int> odd_digits = {1,3,5,7,9};\n        int first_digit = odd_digits[rnd.next(0,4)];\n        n_str += char('0' + first_digit);\n        for (int i = 1; i < len; ++i) {\n            int digit = odd_digits[rnd.next(0,4)];\n            n_str += char('0' + digit);\n        }\n    } else if (type == \"all_even\") {\n        // n is odd but have as many even digits as possible\n        vector<int> even_digits = {2,4,6,8};\n        int first_digit = even_digits[rnd.next(0,3)];\n        n_str += char('0' + first_digit);\n        for (int i = 1; i < len -1; ++i) {\n            int digit = even_digits[rnd.next(0,3)];\n            n_str += char('0' + digit);\n        }\n        // Last digit must be odd\n        vector<int> odd_digits = {1,3,5,7,9};\n        int last_digit = odd_digits[rnd.next(0,4)];\n        n_str += char('0' + last_digit);\n    } else if (type == \"maximum_case\") {\n        // n is the maximum possible odd number of length len\n        n_str += '9';\n        for (int i = 1; i < len - 1; ++i) {\n            n_str += '9';\n        }\n        // Last digit must be odd\n        n_str += '9';\n    } else if (type == \"minimum_case\") {\n        // n is the minimum possible odd number of length len\n        n_str += '1';\n        for (int i = 1; i < len - 1; ++i) {\n            n_str += '0';\n        }\n        // Last digit must be odd\n        n_str += '1';\n    } else if (type == \"leading_zero_after_swap\") {\n        // Only even digits at positions that would cause leading zero after swap\n        int even_digit = 2 * rnd.next(1, 4); // 2,4,6,8\n        n_str += char('0' + even_digit); // First digit is even\n        for(int i = 1; i < len - 1; ++i) {\n            n_str += '1'; // Middle digits are '1', all odd\n        }\n        // Last digit must be odd\n        int last_digit = rnd.next(0,4)*2+1; // Odd number 1-9\n        n_str += char('0' + last_digit);\n    } else if (type == \"special_no_even_possible\") {\n        // All digits odd, swapping any two digits cannot produce even number\n        vector<int> odd_digits = {1,3,5,7,9};\n        int first_digit = odd_digits[rnd.next(0,4)];\n        n_str += char('0' + first_digit);\n        for (int i = 1; i < len; ++i) {\n            int digit = odd_digits[rnd.next(0,4)];\n            n_str += char('0' + digit);\n        }\n    } else {\n        // Default case\n        n_str = \"11\";\n    }\n\n    // Output n\n    printf(\"%s\\n\", n_str.c_str());\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -len 2 -type random\n./gen -len 2 -type all_odd\n./gen -len 2 -type all_even\n./gen -len 2 -type leading_zero_after_swap\n./gen -len 2 -type special_no_even_possible\n\n./gen -len 3 -type random\n./gen -len 3 -type all_odd\n./gen -len 3 -type all_even\n./gen -len 3 -type leading_zero_after_swap\n./gen -len 3 -type special_no_even_possible\n\n./gen -len 10 -type random\n./gen -len 10 -type all_odd\n./gen -len 10 -type all_even\n./gen -len 10 -type leading_zero_after_swap\n./gen -len 10 -type special_no_even_possible\n\n./gen -len 100 -type random\n./gen -len 100 -type all_odd\n./gen -len 100 -type all_even\n./gen -len 100 -type leading_zero_after_swap\n./gen -len 100 -type special_no_even_possible\n\n./gen -len 1000 -type random\n./gen -len 1000 -type all_odd\n./gen -len 1000 -type all_even\n./gen -len 1000 -type leading_zero_after_swap\n./gen -len 1000 -type special_no_even_possible\n\n./gen -len 10000 -type random\n./gen -len 10000 -type all_odd\n./gen -len 10000 -type all_even\n./gen -len 10000 -type leading_zero_after_swap\n./gen -len 10000 -type special_no_even_possible\n\n./gen -len 100000 -type random\n./gen -len 100000 -type all_odd\n./gen -len 100000 -type all_even\n./gen -len 100000 -type leading_zero_after_swap\n./gen -len 100000 -type special_no_even_possible\n\n./gen -len 100000 -type maximum_case\n./gen -len 100000 -type minimum_case\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:41:03.077954",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "508/C",
      "title": "C. Anya and Ghosts",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains three integers m, t, r (1 ≤ m, t, r ≤ 300), representing the number of ghosts to visit Anya, the duration of a candle's burning and the minimum number of candles that should burn during each visit. The next line contains m space-separated numbers wi (1 ≤ i ≤ m, 1 ≤ wi ≤ 300), the i-th of them repesents at what second after the midnight the i-th ghost will come. All wi's are distinct, they follow in the strictly increasing order.",
      "output_spec": "OutputIf it is possible to make at least r candles burn during each visit, then print the minimum number of candles that Anya needs to light for that.If that is impossible, print  - 1.",
      "sample_tests": "ExamplesInputCopy1 8 310OutputCopy3InputCopy2 10 15 8OutputCopy1InputCopy1 1 310OutputCopy-1",
      "description": "C. Anya and Ghosts\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains three integers m, t, r (1 ≤ m, t, r ≤ 300), representing the number of ghosts to visit Anya, the duration of a candle's burning and the minimum number of candles that should burn during each visit. The next line contains m space-separated numbers wi (1 ≤ i ≤ m, 1 ≤ wi ≤ 300), the i-th of them repesents at what second after the midnight the i-th ghost will come. All wi's are distinct, they follow in the strictly increasing order.\n\nOutputIf it is possible to make at least r candles burn during each visit, then print the minimum number of candles that Anya needs to light for that.If that is impossible, print  - 1.\n\nInputCopy1 8 310OutputCopy3InputCopy2 10 15 8OutputCopy1InputCopy1 1 310OutputCopy-1\n\nInputCopy1 8 310\n\nOutputCopy3\n\nInputCopy2 10 15 8\n\nOutputCopy1\n\nInputCopy1 1 310\n\nOutputCopy-1\n\nNoteAnya can start lighting a candle in the same second with ghost visit. But this candle isn't counted as burning at this visit.It takes exactly one second to light up a candle and only after that second this candle is considered burning; it means that if Anya starts lighting candle at moment x, candle is buring from second x + 1 to second x + t inclusively.In the first sample test three candles are enough. For example, Anya can start lighting them at the 3-rd, 5-th and 7-th seconds after the midnight.In the second sample test one candle is enough. For example, Anya can start lighting it one second before the midnight.In the third sample test the answer is  - 1, since during each second at most one candle can burn but Anya needs three candles to light up the room at the moment when the ghost comes.",
      "solutions": [
        {
          "title": "Codeforces Round #288 (Div. 2) - Codeforces",
          "content": "Hello, Codeforces!I'd like to invite you to Codeforces Round #288 (Div. 2). It'll be held on Tuesday, January 27 at 19:30 MSK and as usual Div. 1 participants can join out of competition.Great thanks to Maxim Akhmedov (Zlobober) for helping me preparing the contest, to Maria Belova (Delinur) for translating the statements into English, to Mike Mirzayanov (MikeMirzayanov) for the great Polygon platform and ideas of some problems and to my dear teammates Arthur Svechnikov (ikar) and Ilya Los (IlyaLos) for writing solutions.The scoring distribution will be announced later. Good luck everyone!UPD Score system is standart 500-1000-1500-2000-2500. UPD2 Competition completed! Thank you all!UPD3 You can find editorial here.UPD4 Congratulations to the winners! topcoder.2015 KimJongUn_JBYongDongJI atatomir pankaj_gudlani egor_bb",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/16035",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 830
        },
        {
          "title": "Codeforces Round #288 (Div.2) Editorial - Codeforces",
          "content": "508A — Pasha and PixelsTo solve this problem let's create matrix with type bool and dimensions n on m. Cell (x, y) of this matrix is true — if this cell painted in black color.Let on move number k Pasha paints pixel in position (i, j). Then game ending on this move, if square 2 × 2 formed from black cells appears, and cell (i, j) will upper-left, upper-right, bottom-left or bottom-right of this squares. Only this squares we need to check on current move. If we haven't such squares after k moves, print 0. Asymptotic behavior of this solution — O(k), where k — number of moves.508B — Anton and currency you all knowBecause of specified number is odd (that mean that last digit of this number is odd) we need to swap last digit with some even digit. How to maximize number after this swap?If number consists only from odd digits print  - 1.Else, we need to find first even digit, which less than last digit if we will iterate from most significant digit. If we find such digit — swap it with last digit and we have an answer. Else, we need to find first even digit, which more than last digit if we will iterate from less significant digit. If we find such digit — swap it with last digit and we have an answer.Asymptotic behavior of this solution — O(n), where n — count of digits in specified number.508C — Anya and GhostsThis problem can be solved with help of greedy algorithm. Let's iterate on moments when ghosts will appears.We need to use use array, in wich we will mark moments of time, in wich we lighted candles (for example, put in corresponding positions 1). Than for every new ghost will count how many candles lights in time of his visit from our array.If ghost appears in moment of time wi, iterate on out array from wi - 1 to wi - t, where t — count of seconds, which candle burns, and count the number of ones. If this count is not less than r, continue iterating on ghosts. Else, iterate on our array from wi - 1 to wi - t, and, if in current second candle didn't lighted — make it, and put in this position in array 1. We need to do such operation, while count of ones in this section of our array will not be equals to r. If we can't do this fore some ghost, we can print  - 1.Answer to this problem — count of ones in our array. Asymptotic behavior of this solution — O(mt), where m — count of ghosts, t — the duration of a candle's burning.508D — Tanya and PasswordAt first, let's convert data from input in directed graph. Vertexes in this graph will all strings with length equals to 2 and consisting of uppercase and lowercase letters of the latin alphabet. For all 3-letters strings from input — si's, let's add edge from vertex si[0]si[1] to si[1]si[2]. Now we need to find in this graph Euler path. For this we can use Fleury's algorithm. It is worth noting, that Euler path consists, if count of vertexes, in wich in-degree and out-degree differs by one, less then 3, and in-degree and out-degree of others vertexes — even. If we can't find Euler path — print NO. Asymptotic behavior of this solution — O(m), where m — count of different 3-letters strings from input. It equals to number of edges in graphs.508E — Arthur and BracketsThis problem can be solved with help of dynamic dynamic programming. Let's create squre matrix Z with sizes n × n, where n — count of open brackets in sequence. Main hint — if open bracket is in position l, and corresponding for her close bracket — in position r, than from position l + 1 to position r - 1 must stay a regular bracket sequence.In array Z first parametr lf — number of open bracket, second parametr rg — number of last open bracket, which can be in a regular bracket sequence, which will exists between open bracket with number lf and corresponding for it close bracket.Z[lf][rg] = true if it is possible to construct such sequence. Otherwise Z[lf][rg] = false.For current lf and rg let's iterate on cnt — how many open brackets and corresponding them close brackets in a regular bracket sequence will stay between open bracket number lf and corresponding for it close bracket. If this count falls in the given interval for open bracket lf, recurcively run dynamic from two segments — (lf + 1, lf + cnt) and (lf + cnt + 1, rg). If for both segments we can construct regular bracket sequences, appropriate to data-in from input, put in Z[lf][rg] value true. To restore answer, we must move from segment (lf, rg) in segments (lf + 1, lf + cnt) and (lf + cnt + 1, rg), if for both this segments we can construct regular bracket sequences and recursively restore asnwer. If Z[0][n - 1] equals to false, print IMPOSSIBLE. Asymptotic behavior of this solution — O(n3).UPD This problem can be solved with help of griddy algorithm. Asymptotic behavior of this solution — O(n). Here is example of such solution, participant matrix.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/16048?locale=en",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 508\\s*C"
          },
          "content_length": 4804
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #288 (Div. 2) - Codeforces - Code 1",
          "code": "int ip = 0, comp = 0, ini;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16035",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #288 (Div. 2) - Codeforces - Code 2",
          "code": "1000 1000 1000\n1000 1\n1000 2\n1000 3\n...\n1000 1000",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16035",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #288 (Div. 2) - Codeforces - Code 3",
          "code": "1000 1000 1000\n1000 1\n1000 2\n1000 3\n...\n1000 1000",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16035",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #288 (Div.2) Editorial - Codeforces - Code 1",
          "code": "3\n2 5\n1 4\n1 4",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16048?locale=en",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #288 (Div.2) Editorial - Codeforces - Code 2",
          "code": "3\n2 5\n1 4\n1 4",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16048?locale=en",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #288 (Div.2) Editorial - Codeforces - Code 3",
          "code": "j\n    v\n((()))\n ^^ \n ki",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16048?locale=en",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #288 (Div.2) Editorial - Codeforces - Code 4",
          "code": "j\n    v\n((()))\n ^^ \n ki",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16048?locale=en",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #288 (Div.2) Editorial - Codeforces - Code 5",
          "code": "j\n  --v\n((()))\n\nturns into\n\n  j \n  v--\n(()())",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16048?locale=en",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #288 (Div.2) Editorial - Codeforces - Code 6",
          "code": "j\n  --v\n((()))\n\nturns into\n\n  j \n  v--\n(()())",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16048?locale=en",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int m = inf.readInt(1, 300, \"m\");\n    inf.readSpace();\n    int t = inf.readInt(1, 300, \"t\");\n    inf.readSpace();\n    int r = inf.readInt(1, 300, \"r\");\n    inf.readEoln();\n    vector<int> w = inf.readInts(m, 1, 300, \"w\");\n    inf.readEoln();\n    for (int i = 1; i < m; ++i) {\n        ensuref(w[i-1] < w[i], \"wi's are not strictly increasing at position %d: w[%d]=%d, w[%d]=%d\", i, i-1, w[i-1], i, w[i]);\n    }\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int m = inf.readInt(1, 300, \"m\");\n    inf.readSpace();\n    int t = inf.readInt(1, 300, \"t\");\n    inf.readSpace();\n    int r = inf.readInt(1, 300, \"r\");\n    inf.readEoln();\n    vector<int> w = inf.readInts(m, 1, 300, \"w\");\n    inf.readEoln();\n    for (int i = 1; i < m; ++i) {\n        ensuref(w[i-1] < w[i], \"wi's are not strictly increasing at position %d: w[%d]=%d, w[%d]=%d\", i, i-1, w[i-1], i, w[i]);\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int m = inf.readInt(1, 300, \"m\");\n    inf.readSpace();\n    int t = inf.readInt(1, 300, \"t\");\n    inf.readSpace();\n    int r = inf.readInt(1, 300, \"r\");\n    inf.readEoln();\n    vector<int> w = inf.readInts(m, 1, 300, \"w\");\n    inf.readEoln();\n    for (int i = 1; i < m; ++i) {\n        ensuref(w[i-1] < w[i], \"wi's are not strictly increasing at position %d: w[%d]=%d, w[%d]=%d\", i, i-1, w[i-1], i, w[i]);\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int m = opt<int>(\"m\");\n    int t = opt<int>(\"t\");\n    int r = opt<int>(\"r\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> wi;\n\n    if (type == \"random\") {\n        // Generate random wi's in increasing order between 1 and 300\n        set<int> times;\n        while ((int)times.size() < m) {\n            times.insert(rnd.next(1, 300));\n        }\n        wi.assign(times.begin(), times.end());\n    } else if (type == \"clustered\") {\n        // Generate clustered wi's\n        int start_time = rnd.next(1, 297);\n        for (int i = 0; i < m; ++i) {\n            wi.push_back(start_time + rnd.next(0, 2)); // Clustered within 3 seconds\n        }\n        sort(wi.begin(), wi.end());\n        wi.erase(unique(wi.begin(), wi.end()), wi.end());\n        while ((int)wi.size() < m) {\n            wi.push_back(wi.back() + 1);\n        }\n    } else if (type == \"spread\") {\n        // Generate wi's spread over the full range\n        for (int i = 0; i < m; ++i) {\n            wi.push_back(rnd.next(1, 300));\n        }\n        sort(wi.begin(), wi.end());\n        wi.erase(unique(wi.begin(), wi.end()), wi.end());\n        while ((int)wi.size() < m) {\n            int new_time = wi.back() + rnd.next(1, 5);\n            if (new_time <= 300)\n                wi.push_back(new_time);\n            else\n                wi.push_back(rnd.next(1, 300));\n        }\n    } else if (type == \"impossible\") {\n        // Set up parameters that make the problem impossible\n        // For example, t = 1, r > t\n        t = 1;\n        r = rnd.next(2, 300); // Since t < r, it's impossible\n        m = opt<int>(\"m\", 1);\n        wi.resize(m);\n        for (int i = 0; i < m; ++i) {\n            wi[i] = rnd.next(1, 300);\n        }\n    } else if (type == \"early\") {\n        // Ghosts come early\n        for (int i = 0; i < m; ++i) {\n            wi.push_back(rnd.next(1, 5));\n        }\n        sort(wi.begin(), wi.end());\n        wi.erase(unique(wi.begin(), wi.end()), wi.end());\n        while ((int)wi.size() < m) {\n            wi.push_back(wi.back() + 1);\n        }\n    } else if (type == \"late\") {\n        // Ghosts come late\n        for (int i = 0; i < m; ++i) {\n            wi.push_back(rnd.next(295, 300));\n        }\n        sort(wi.begin(), wi.end());\n        wi.erase(unique(wi.begin(), wi.end()), wi.end());\n        while ((int)wi.size() < m) {\n            wi.push_back(wi.front() - 1);\n        }\n    } else if (type == \"min_max\") {\n        // Test minimal and maximal values\n        m = 300;\n        t = 1;\n        r = 300;\n        wi.resize(m);\n        for (int i = 0; i < m; ++i) {\n            wi[i] = rnd.next(1, 300);\n        }\n    }\n    sort(wi.begin(), wi.end());\n    while ((int)wi.size() > m) wi.pop_back();\n\n    printf(\"%d %d %d\\n\", m, t, r);\n    for (int i = 0; i < m; ++i) {\n        printf(\"%d%c\", wi[i], \" \\n\"[i == m - 1]);\n    }\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int m = opt<int>(\"m\");\n    int t = opt<int>(\"t\");\n    int r = opt<int>(\"r\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> wi;\n\n    if (type == \"random\") {\n        // Generate random wi's in increasing order between 1 and 300\n        set<int> times;\n        while ((int)times.size() < m) {\n            times.insert(rnd.next(1, 300));\n        }\n        wi.assign(times.begin(), times.end());\n    } else if (type == \"clustered\") {\n        // Generate clustered wi's\n        int start_time = rnd.next(1, 297);\n        for (int i = 0; i < m; ++i) {\n            wi.push_back(start_time + rnd.next(0, 2)); // Clustered within 3 seconds\n        }\n        sort(wi.begin(), wi.end());\n        wi.erase(unique(wi.begin(), wi.end()), wi.end());\n        while ((int)wi.size() < m) {\n            wi.push_back(wi.back() + 1);\n        }\n    } else if (type == \"spread\") {\n        // Generate wi's spread over the full range\n        for (int i = 0; i < m; ++i) {\n            wi.push_back(rnd.next(1, 300));\n        }\n        sort(wi.begin(), wi.end());\n        wi.erase(unique(wi.begin(), wi.end()), wi.end());\n        while ((int)wi.size() < m) {\n            int new_time = wi.back() + rnd.next(1, 5);\n            if (new_time <= 300)\n                wi.push_back(new_time);\n            else\n                wi.push_back(rnd.next(1, 300));\n        }\n    } else if (type == \"impossible\") {\n        // Set up parameters that make the problem impossible\n        // For example, t = 1, r > t\n        t = 1;\n        r = rnd.next(2, 300); // Since t < r, it's impossible\n        m = opt<int>(\"m\", 1);\n        wi.resize(m);\n        for (int i = 0; i < m; ++i) {\n            wi[i] = rnd.next(1, 300);\n        }\n    } else if (type == \"early\") {\n        // Ghosts come early\n        for (int i = 0; i < m; ++i) {\n            wi.push_back(rnd.next(1, 5));\n        }\n        sort(wi.begin(), wi.end());\n        wi.erase(unique(wi.begin(), wi.end()), wi.end());\n        while ((int)wi.size() < m) {\n            wi.push_back(wi.back() + 1);\n        }\n    } else if (type == \"late\") {\n        // Ghosts come late\n        for (int i = 0; i < m; ++i) {\n            wi.push_back(rnd.next(295, 300));\n        }\n        sort(wi.begin(), wi.end());\n        wi.erase(unique(wi.begin(), wi.end()), wi.end());\n        while ((int)wi.size() < m) {\n            wi.push_back(wi.front() - 1);\n        }\n    } else if (type == \"min_max\") {\n        // Test minimal and maximal values\n        m = 300;\n        t = 1;\n        r = 300;\n        wi.resize(m);\n        for (int i = 0; i < m; ++i) {\n            wi[i] = rnd.next(1, 300);\n        }\n    }\n    sort(wi.begin(), wi.end());\n    while ((int)wi.size() > m) wi.pop_back();\n\n    printf(\"%d %d %d\\n\", m, t, r);\n    for (int i = 0; i < m; ++i) {\n        printf(\"%d%c\", wi[i], \" \\n\"[i == m - 1]);\n    }\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -m 10 -t 5 -r 3 -type random\n./gen -m 1 -t 1 -r 2 -type impossible\n./gen -m 100 -t 10 -r 10 -type clustered\n./gen -m 50 -t 300 -r 1 -type spread\n./gen -m 200 -t 50 -r 100 -type random\n./gen -m 299 -t 2 -r 300 -type impossible\n./gen -m 300 -t 1 -r 300 -type impossible\n./gen -m 10 -t 10 -r 1 -type early\n./gen -m 10 -t 10 -r 1 -type late\n./gen -m 50 -t 1 -r 1 -type random\n./gen -m 300 -t 300 -r 1 -type spread\n./gen -m 5 -t 2 -r 2 -type clustered\n./gen -m 5 -t 1 -r 1 -type clustered\n./gen -m 100 -t 5 -r 10 -type spread\n./gen -m 20 -t 20 -r 10 -type early\n./gen -m 20 -t 20 -r 10 -type late\n./gen -m 150 -t 10 -r 10 -type random\n./gen -m 100 -t 1 -r 50 -type impossible\n./gen -m 1 -t 300 -r 300 -type impossible\n./gen -m 300 -t 300 -r 300 -type random\n./gen -m 300 -t 300 -r 1 -type min_max\n./gen -m 1 -t 1 -r 1 -type random\n./gen -m 299 -t 2 -r 2 -type clustered\n./gen -m 3 -t 3 -r 3 -type random\n./gen -m 50 -t 20 -r 5 -type spread\n./gen -m 100 -t 50 -r 25 -type random\n./gen -m 10 -t 1 -r 1 -type early\n./gen -m 10 -t 1 -r 1 -type late\n./gen -m 300 -t 1 -r 1 -type clustered\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:41:04.734241",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "508/D",
      "title": "D. Tanya and Password",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains integer n (1 ≤ n ≤ 2·105), the number of three-letter substrings Tanya got. Next n lines contain three letters each, forming the substring of dad's password. Each character in the input is a lowercase or uppercase Latin letter or a digit.",
      "output_spec": "OutputIf Tanya made a mistake somewhere during the game and the strings that correspond to the given set of substrings don't exist, print \"NO\". If it is possible to restore the string that corresponds to given set of substrings, print \"YES\", and then print any suitable password option.",
      "sample_tests": "ExamplesInputCopy5acaabaabacabbacOutputCopyYESabacabaInputCopy4abcbCbcb1b13OutputCopyNOInputCopy7aaaaaaaaaaaaaaaaaaaaaOutputCopyYESaaaaaaaaa",
      "description": "D. Tanya and Password\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains integer n (1 ≤ n ≤ 2·105), the number of three-letter substrings Tanya got. Next n lines contain three letters each, forming the substring of dad's password. Each character in the input is a lowercase or uppercase Latin letter or a digit.\n\nOutputIf Tanya made a mistake somewhere during the game and the strings that correspond to the given set of substrings don't exist, print \"NO\". If it is possible to restore the string that corresponds to given set of substrings, print \"YES\", and then print any suitable password option.\n\nInputCopy5acaabaabacabbacOutputCopyYESabacabaInputCopy4abcbCbcb1b13OutputCopyNOInputCopy7aaaaaaaaaaaaaaaaaaaaaOutputCopyYESaaaaaaaaa\n\nInputCopy5acaabaabacabbac\n\nOutputCopyYESabacaba\n\nInputCopy4abcbCbcb1b13\n\nOutputCopyNO\n\nInputCopy7aaaaaaaaaaaaaaaaaaaaa\n\nOutputCopyYESaaaaaaaaa",
      "solutions": [
        {
          "title": "Codeforces Round #288 (Div. 2) - Codeforces",
          "content": "Hello, Codeforces!I'd like to invite you to Codeforces Round #288 (Div. 2). It'll be held on Tuesday, January 27 at 19:30 MSK and as usual Div. 1 participants can join out of competition.Great thanks to Maxim Akhmedov (Zlobober) for helping me preparing the contest, to Maria Belova (Delinur) for translating the statements into English, to Mike Mirzayanov (MikeMirzayanov) for the great Polygon platform and ideas of some problems and to my dear teammates Arthur Svechnikov (ikar) and Ilya Los (IlyaLos) for writing solutions.The scoring distribution will be announced later. Good luck everyone!UPD Score system is standart 500-1000-1500-2000-2500. UPD2 Competition completed! Thank you all!UPD3 You can find editorial here.UPD4 Congratulations to the winners! topcoder.2015 KimJongUn_JBYongDongJI atatomir pankaj_gudlani egor_bb",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/16035",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 830
        },
        {
          "title": "Codeforces Round #288 (Div.2) Editorial - Codeforces",
          "content": "508A — Pasha and PixelsTo solve this problem let's create matrix with type bool and dimensions n on m. Cell (x, y) of this matrix is true — if this cell painted in black color.Let on move number k Pasha paints pixel in position (i, j). Then game ending on this move, if square 2 × 2 formed from black cells appears, and cell (i, j) will upper-left, upper-right, bottom-left or bottom-right of this squares. Only this squares we need to check on current move. If we haven't such squares after k moves, print 0. Asymptotic behavior of this solution — O(k), where k — number of moves.508B — Anton and currency you all knowBecause of specified number is odd (that mean that last digit of this number is odd) we need to swap last digit with some even digit. How to maximize number after this swap?If number consists only from odd digits print  - 1.Else, we need to find first even digit, which less than last digit if we will iterate from most significant digit. If we find such digit — swap it with last digit and we have an answer. Else, we need to find first even digit, which more than last digit if we will iterate from less significant digit. If we find such digit — swap it with last digit and we have an answer.Asymptotic behavior of this solution — O(n), where n — count of digits in specified number.508C — Anya and GhostsThis problem can be solved with help of greedy algorithm. Let's iterate on moments when ghosts will appears.We need to use use array, in wich we will mark moments of time, in wich we lighted candles (for example, put in corresponding positions 1). Than for every new ghost will count how many candles lights in time of his visit from our array.If ghost appears in moment of time wi, iterate on out array from wi - 1 to wi - t, where t — count of seconds, which candle burns, and count the number of ones. If this count is not less than r, continue iterating on ghosts. Else, iterate on our array from wi - 1 to wi - t, and, if in current second candle didn't lighted — make it, and put in this position in array 1. We need to do such operation, while count of ones in this section of our array will not be equals to r. If we can't do this fore some ghost, we can print  - 1.Answer to this problem — count of ones in our array. Asymptotic behavior of this solution — O(mt), where m — count of ghosts, t — the duration of a candle's burning.508D — Tanya and PasswordAt first, let's convert data from input in directed graph. Vertexes in this graph will all strings with length equals to 2 and consisting of uppercase and lowercase letters of the latin alphabet. For all 3-letters strings from input — si's, let's add edge from vertex si[0]si[1] to si[1]si[2]. Now we need to find in this graph Euler path. For this we can use Fleury's algorithm. It is worth noting, that Euler path consists, if count of vertexes, in wich in-degree and out-degree differs by one, less then 3, and in-degree and out-degree of others vertexes — even. If we can't find Euler path — print NO. Asymptotic behavior of this solution — O(m), where m — count of different 3-letters strings from input. It equals to number of edges in graphs.508E — Arthur and BracketsThis problem can be solved with help of dynamic dynamic programming. Let's create squre matrix Z with sizes n × n, where n — count of open brackets in sequence. Main hint — if open bracket is in position l, and corresponding for her close bracket — in position r, than from position l + 1 to position r - 1 must stay a regular bracket sequence.In array Z first parametr lf — number of open bracket, second parametr rg — number of last open bracket, which can be in a regular bracket sequence, which will exists between open bracket with number lf and corresponding for it close bracket.Z[lf][rg] = true if it is possible to construct such sequence. Otherwise Z[lf][rg] = false.For current lf and rg let's iterate on cnt — how many open brackets and corresponding them close brackets in a regular bracket sequence will stay between open bracket number lf and corresponding for it close bracket. If this count falls in the given interval for open bracket lf, recurcively run dynamic from two segments — (lf + 1, lf + cnt) and (lf + cnt + 1, rg). If for both segments we can construct regular bracket sequences, appropriate to data-in from input, put in Z[lf][rg] value true. To restore answer, we must move from segment (lf, rg) in segments (lf + 1, lf + cnt) and (lf + cnt + 1, rg), if for both this segments we can construct regular bracket sequences and recursively restore asnwer. If Z[0][n - 1] equals to false, print IMPOSSIBLE. Asymptotic behavior of this solution — O(n3).UPD This problem can be solved with help of griddy algorithm. Asymptotic behavior of this solution — O(n). Here is example of such solution, participant matrix.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/16048?locale=en",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 508\\s*D"
          },
          "content_length": 4804
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #288 (Div. 2) - Codeforces - Code 1",
          "code": "int ip = 0, comp = 0, ini;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16035",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #288 (Div. 2) - Codeforces - Code 2",
          "code": "1000 1000 1000\n1000 1\n1000 2\n1000 3\n...\n1000 1000",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16035",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #288 (Div. 2) - Codeforces - Code 3",
          "code": "1000 1000 1000\n1000 1\n1000 2\n1000 3\n...\n1000 1000",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16035",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #288 (Div.2) Editorial - Codeforces - Code 1",
          "code": "3\n2 5\n1 4\n1 4",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16048?locale=en",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #288 (Div.2) Editorial - Codeforces - Code 2",
          "code": "3\n2 5\n1 4\n1 4",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16048?locale=en",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #288 (Div.2) Editorial - Codeforces - Code 3",
          "code": "j\n    v\n((()))\n ^^ \n ki",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16048?locale=en",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #288 (Div.2) Editorial - Codeforces - Code 4",
          "code": "j\n    v\n((()))\n ^^ \n ki",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16048?locale=en",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #288 (Div.2) Editorial - Codeforces - Code 5",
          "code": "j\n  --v\n((()))\n\nturns into\n\n  j \n  v--\n(()())",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16048?locale=en",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #288 (Div.2) Editorial - Codeforces - Code 6",
          "code": "j\n  --v\n((()))\n\nturns into\n\n  j \n  v--\n(()())",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16048?locale=en",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 200000, \"n\");\n    inf.readEoln();\n\n    for (int i = 0; i < n; ++i) {\n        string s = inf.readLine(\"[a-zA-Z0-9]{3}\", \"substring\");\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 200000, \"n\");\n    inf.readEoln();\n\n    for (int i = 0; i < n; ++i) {\n        string s = inf.readLine(\"[a-zA-Z0-9]{3}\", \"substring\");\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 200000, \"n\");\n    inf.readEoln();\n\n    for (int i = 0; i < n; ++i) {\n        string s = inf.readLine(\"[a-zA-Z0-9]{3}\", \"substring\");\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerTestlibCmd(argc, argv);\n\n    // Read input\n    int n = inf.readInt(1, 200000);\n    vector<string> substrings_input(n);\n    for (int i = 0; i < n; ++i) {\n        substrings_input[i] = inf.readToken(\"[0-9a-zA-Z]{3}\", format(\"substring %d\", i + 1).c_str());\n    }\n\n    multiset<string> input_substrings(substrings_input.begin(), substrings_input.end());\n\n    // Read jury's answer\n    string jury_res = ans.readToken();\n    if (jury_res != \"YES\" && jury_res != \"NO\")\n        ans.quitf(_fail, \"Jury's answer is neither YES nor NO, found '%s'\", jury_res.c_str());\n\n    string jury_password;\n    if (jury_res == \"YES\") {\n        jury_password = ans.readToken();\n        // No need to process jury's password further in the checker\n    }\n\n    // Read participant's answer\n    string part_res = ouf.readToken();\n    if (part_res != \"YES\" && part_res != \"NO\")\n        quitf(_wa, \"Participant's answer is neither YES nor NO, found '%s'\", part_res.c_str());\n\n    if (part_res == \"YES\") {\n        string part_password = ouf.readToken();\n        // Validate password length\n        if ((int)part_password.size() != n + 2) {\n            quitf(_wa, \"Password length is %d, expected %d\", (int)part_password.size(), n + 2);\n        }\n        // Validate password characters\n        for (char c : part_password) {\n            if (!isalnum(c)) {\n                quitf(_wa, \"Password contains invalid character '%c'\", c);\n            }\n        }\n        // Build multiset of substrings from participant's password\n        multiset<string> participant_substrings;\n        for (int i = 0; i + 2 < (int)part_password.size(); ++i) {\n            participant_substrings.insert(part_password.substr(i, 3));\n        }\n        if (participant_substrings != input_substrings) {\n            quitf(_wa, \"Substrings of password do not match the input.\");\n        }\n        if (jury_res == \"YES\") {\n            // Participant's answer is acceptable\n            quitf(_ok, \"Participant's password is acceptable.\");\n        } else {\n            // Jury says NO, participant says YES with valid password\n            quitf(_fail, \"Participant found a valid password when jury said impossible.\");\n        }\n    } else { // Participant's answer is NO\n        if (jury_res == \"NO\") {\n            // Both outputs are NO\n            quitf(_ok, \"Both outputs are NO.\");\n        } else {\n            // Jury says YES, participant says NO\n            quitf(_wa, \"Participant failed to find a password when one exists.\");\n        }\n    }\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<string> substrings; // To store generated substrings\n    string password; // The original password string of length n + 2\n\n    if (type == \"random\") {\n        // Generate random password of length n + 2 and extract substrings\n        int length = n + 2;\n        string charset = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789\";\n        password.resize(length);\n        for (int i = 0; i < length; ++i) {\n            password[i] = charset[rnd.next(62)];\n        }\n        for (int i = 0; i <= n - 1; ++i) {\n            substrings.push_back(password.substr(i, 3));\n        }\n    } else if (type == \"chain\") {\n        // Generate a chain-like password (e.g., \"abcde...\")\n        password.resize(n + 2);\n        password[0] = 'a'; // Starting character\n        for (int i = 1; i < n + 2; ++i) {\n            password[i] = 'a' + (i % 26); // Use lowercase letters cyclically\n        }\n        for (int i = 0; i <= n - 1; ++i) {\n            substrings.push_back(password.substr(i, 3));\n        }\n    } else if (type == \"cycle\") {\n        // Generate a password that forms a cycle\n        password.resize(n + 2);\n        for (int i = 0; i < n + 2; ++i) {\n            password[i] = 'a' + (i % 26); // Cycle through lowercase letters\n        }\n        for (int i = 0; i <= n - 1; ++i) {\n            substrings.push_back(password.substr(i, 3));\n        }\n    } else if (type == \"same_substrings\") {\n        // All substrings are the same (e.g., \"aaa\")\n        string s(3, 'a'); // \"aaa\"\n        substrings.assign(n, s);\n        password.assign(n + 2, 'a');\n    } else if (type == \"mixed_case\") {\n        // Use uppercase letters and digits in the password\n        password.resize(n + 2);\n        string charset = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789\";\n        for (int i = 0; i < n + 2; ++i) {\n            password[i] = charset[rnd.next(62)];\n        }\n        for (int i = 0; i <= n - 1; ++i) {\n            substrings.push_back(password.substr(i, 3));\n        }\n    } else if (type == \"impossible\") {\n        // Create an impossible case where reconstruction is not possible\n        substrings = {\"abc\", \"bca\", \"cab\"};\n        n = substrings.size();\n    } else if (type == \"impossible_degree_condition\") {\n        // Create a case where in-degree and out-degree conditions are not met\n        substrings = {\"aaa\", \"aab\", \"aab\"};\n        n = substrings.size();\n    } else if (type == \"impossible_disconnected\") {\n        // Generate substrings such that the graph is disconnected\n        substrings = {\"abc\", \"bcd\", \"def\", \"efg\"};\n        n = substrings.size();\n    } else if (type == \"small_n\") {\n        // Small n (e.g., n = 1)\n        n = 1;\n        password = \"abc\";\n        substrings.push_back(password);\n    } else {\n        // Default to random if the type is unknown\n        int length = n + 2;\n        string charset = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789\";\n        password.resize(length);\n        for (int i = 0; i < length; ++i) {\n            password[i] = charset[rnd.next(62)];\n        }\n        for (int i = 0; i <= n - 1; ++i) {\n            substrings.push_back(password.substr(i, 3));\n        }\n    }\n\n    // Shuffle substrings to avoid any specific order\n    shuffle(substrings.begin(), substrings.end());\n\n    // Output n\n    printf(\"%d\\n\", n);\n    // Output substrings\n    for (int i = 0; i < n; ++i) {\n        printf(\"%s\\n\", substrings[i].c_str());\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<string> substrings; // To store generated substrings\n    string password; // The original password string of length n + 2\n\n    if (type == \"random\") {\n        // Generate random password of length n + 2 and extract substrings\n        int length = n + 2;\n        string charset = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789\";\n        password.resize(length);\n        for (int i = 0; i < length; ++i) {\n            password[i] = charset[rnd.next(62)];\n        }\n        for (int i = 0; i <= n - 1; ++i) {\n            substrings.push_back(password.substr(i, 3));\n        }\n    } else if (type == \"chain\") {\n        // Generate a chain-like password (e.g., \"abcde...\")\n        password.resize(n + 2);\n        password[0] = 'a'; // Starting character\n        for (int i = 1; i < n + 2; ++i) {\n            password[i] = 'a' + (i % 26); // Use lowercase letters cyclically\n        }\n        for (int i = 0; i <= n - 1; ++i) {\n            substrings.push_back(password.substr(i, 3));\n        }\n    } else if (type == \"cycle\") {\n        // Generate a password that forms a cycle\n        password.resize(n + 2);\n        for (int i = 0; i < n + 2; ++i) {\n            password[i] = 'a' + (i % 26); // Cycle through lowercase letters\n        }\n        for (int i = 0; i <= n - 1; ++i) {\n            substrings.push_back(password.substr(i, 3));\n        }\n    } else if (type == \"same_substrings\") {\n        // All substrings are the same (e.g., \"aaa\")\n        string s(3, 'a'); // \"aaa\"\n        substrings.assign(n, s);\n        password.assign(n + 2, 'a');\n    } else if (type == \"mixed_case\") {\n        // Use uppercase letters and digits in the password\n        password.resize(n + 2);\n        string charset = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789\";\n        for (int i = 0; i < n + 2; ++i) {\n            password[i] = charset[rnd.next(62)];\n        }\n        for (int i = 0; i <= n - 1; ++i) {\n            substrings.push_back(password.substr(i, 3));\n        }\n    } else if (type == \"impossible\") {\n        // Create an impossible case where reconstruction is not possible\n        substrings = {\"abc\", \"bca\", \"cab\"};\n        n = substrings.size();\n    } else if (type == \"impossible_degree_condition\") {\n        // Create a case where in-degree and out-degree conditions are not met\n        substrings = {\"aaa\", \"aab\", \"aab\"};\n        n = substrings.size();\n    } else if (type == \"impossible_disconnected\") {\n        // Generate substrings such that the graph is disconnected\n        substrings = {\"abc\", \"bcd\", \"def\", \"efg\"};\n        n = substrings.size();\n    } else if (type == \"small_n\") {\n        // Small n (e.g., n = 1)\n        n = 1;\n        password = \"abc\";\n        substrings.push_back(password);\n    } else {\n        // Default to random if the type is unknown\n        int length = n + 2;\n        string charset = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789\";\n        password.resize(length);\n        for (int i = 0; i < length; ++i) {\n            password[i] = charset[rnd.next(62)];\n        }\n        for (int i = 0; i <= n - 1; ++i) {\n            substrings.push_back(password.substr(i, 3));\n        }\n    }\n\n    // Shuffle substrings to avoid any specific order\n    shuffle(substrings.begin(), substrings.end());\n\n    // Output n\n    printf(\"%d\\n\", n);\n    // Output substrings\n    for (int i = 0; i < n; ++i) {\n        printf(\"%s\\n\", substrings[i].c_str());\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -type small_n\n\n./gen -n 5 -type same_substrings\n\n./gen -n 5 -type impossible\n\n./gen -n 5 -type impossible_disconnected\n\n./gen -n 5 -type impossible_degree_condition\n\n./gen -n 5 -type chain\n\n./gen -n 5 -type cycle\n\n./gen -n 5 -type mixed_case\n\n./gen -n 1000 -type chain\n\n./gen -n 1000 -type cycle\n\n./gen -n 1000 -type random\n\n./gen -n 1000 -type same_substrings\n\n./gen -n 1000 -type mixed_case\n\n./gen -n 200000 -type chain\n\n./gen -n 200000 -type cycle\n\n./gen -n 200000 -type random\n\n./gen -n 200000 -type same_substrings\n\n./gen -n 200000 -type mixed_case\n\n./gen -n 200000 -type impossible\n\n./gen -n 200000 -type impossible_degree_condition\n\n./gen -n 200000 -type impossible_disconnected\n\n./gen -n 50000 -type random\n\n./gen -n 50000 -type cycle\n\n./gen -n 50000 -type chain\n\n./gen -n 50000 -type same_substrings\n\n./gen -n 50000 -type mixed_case\n\n./gen -n 50000 -type impossible\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:41:07.084031",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "508/E",
      "title": "E. Arthur and Brackets",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test128 megabytes",
      "input_spec": "InputThe first line contains integer n (1 ≤ n ≤ 600), the number of opening brackets in Arthur's favorite correct bracket sequence. Next n lines contain numbers li and ri (1 ≤ li ≤ ri < 2n), representing the segment where lies the distance from the i-th opening bracket and the corresponding closing one. The descriptions of the segments are given in the order in which the opening brackets occur in Arthur's favorite sequence if we list them from left to right.",
      "output_spec": "OutputIf it is possible to restore the correct bracket sequence by the given data, print any possible choice.If Arthur got something wrong, and there are no sequences corresponding to the given information, print a single line \"IMPOSSIBLE\" (without the quotes).",
      "sample_tests": "ExamplesInputCopy41 11 11 11 1OutputCopy()()()()InputCopy35 53 31 1OutputCopy((()))InputCopy35 53 32 2OutputCopyIMPOSSIBLEInputCopy32 31 41 4OutputCopy(())()",
      "description": "E. Arthur and Brackets\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test128 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains integer n (1 ≤ n ≤ 600), the number of opening brackets in Arthur's favorite correct bracket sequence. Next n lines contain numbers li and ri (1 ≤ li ≤ ri < 2n), representing the segment where lies the distance from the i-th opening bracket and the corresponding closing one. The descriptions of the segments are given in the order in which the opening brackets occur in Arthur's favorite sequence if we list them from left to right.\n\nOutputIf it is possible to restore the correct bracket sequence by the given data, print any possible choice.If Arthur got something wrong, and there are no sequences corresponding to the given information, print a single line \"IMPOSSIBLE\" (without the quotes).\n\nInputCopy41 11 11 11 1OutputCopy()()()()InputCopy35 53 31 1OutputCopy((()))InputCopy35 53 32 2OutputCopyIMPOSSIBLEInputCopy32 31 41 4OutputCopy(())()\n\nInputCopy41 11 11 11 1\n\nOutputCopy()()()()\n\nInputCopy35 53 31 1\n\nOutputCopy((()))\n\nInputCopy35 53 32 2\n\nOutputCopyIMPOSSIBLE\n\nInputCopy32 31 41 4\n\nOutputCopy(())()",
      "solutions": [
        {
          "title": "Codeforces Round #288 (Div. 2) - Codeforces",
          "content": "Hello, Codeforces!I'd like to invite you to Codeforces Round #288 (Div. 2). It'll be held on Tuesday, January 27 at 19:30 MSK and as usual Div. 1 participants can join out of competition.Great thanks to Maxim Akhmedov (Zlobober) for helping me preparing the contest, to Maria Belova (Delinur) for translating the statements into English, to Mike Mirzayanov (MikeMirzayanov) for the great Polygon platform and ideas of some problems and to my dear teammates Arthur Svechnikov (ikar) and Ilya Los (IlyaLos) for writing solutions.The scoring distribution will be announced later. Good luck everyone!UPD Score system is standart 500-1000-1500-2000-2500. UPD2 Competition completed! Thank you all!UPD3 You can find editorial here.UPD4 Congratulations to the winners! topcoder.2015 KimJongUn_JBYongDongJI atatomir pankaj_gudlani egor_bb",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/16035",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 830
        },
        {
          "title": "Codeforces Round #288 (Div.2) Editorial - Codeforces",
          "content": "508A — Pasha and PixelsTo solve this problem let's create matrix with type bool and dimensions n on m. Cell (x, y) of this matrix is true — if this cell painted in black color.Let on move number k Pasha paints pixel in position (i, j). Then game ending on this move, if square 2 × 2 formed from black cells appears, and cell (i, j) will upper-left, upper-right, bottom-left or bottom-right of this squares. Only this squares we need to check on current move. If we haven't such squares after k moves, print 0. Asymptotic behavior of this solution — O(k), where k — number of moves.508B — Anton and currency you all knowBecause of specified number is odd (that mean that last digit of this number is odd) we need to swap last digit with some even digit. How to maximize number after this swap?If number consists only from odd digits print  - 1.Else, we need to find first even digit, which less than last digit if we will iterate from most significant digit. If we find such digit — swap it with last digit and we have an answer. Else, we need to find first even digit, which more than last digit if we will iterate from less significant digit. If we find such digit — swap it with last digit and we have an answer.Asymptotic behavior of this solution — O(n), where n — count of digits in specified number.508C — Anya and GhostsThis problem can be solved with help of greedy algorithm. Let's iterate on moments when ghosts will appears.We need to use use array, in wich we will mark moments of time, in wich we lighted candles (for example, put in corresponding positions 1). Than for every new ghost will count how many candles lights in time of his visit from our array.If ghost appears in moment of time wi, iterate on out array from wi - 1 to wi - t, where t — count of seconds, which candle burns, and count the number of ones. If this count is not less than r, continue iterating on ghosts. Else, iterate on our array from wi - 1 to wi - t, and, if in current second candle didn't lighted — make it, and put in this position in array 1. We need to do such operation, while count of ones in this section of our array will not be equals to r. If we can't do this fore some ghost, we can print  - 1.Answer to this problem — count of ones in our array. Asymptotic behavior of this solution — O(mt), where m — count of ghosts, t — the duration of a candle's burning.508D — Tanya and PasswordAt first, let's convert data from input in directed graph. Vertexes in this graph will all strings with length equals to 2 and consisting of uppercase and lowercase letters of the latin alphabet. For all 3-letters strings from input — si's, let's add edge from vertex si[0]si[1] to si[1]si[2]. Now we need to find in this graph Euler path. For this we can use Fleury's algorithm. It is worth noting, that Euler path consists, if count of vertexes, in wich in-degree and out-degree differs by one, less then 3, and in-degree and out-degree of others vertexes — even. If we can't find Euler path — print NO. Asymptotic behavior of this solution — O(m), where m — count of different 3-letters strings from input. It equals to number of edges in graphs.508E — Arthur and BracketsThis problem can be solved with help of dynamic dynamic programming. Let's create squre matrix Z with sizes n × n, where n — count of open brackets in sequence. Main hint — if open bracket is in position l, and corresponding for her close bracket — in position r, than from position l + 1 to position r - 1 must stay a regular bracket sequence.In array Z first parametr lf — number of open bracket, second parametr rg — number of last open bracket, which can be in a regular bracket sequence, which will exists between open bracket with number lf and corresponding for it close bracket.Z[lf][rg] = true if it is possible to construct such sequence. Otherwise Z[lf][rg] = false.For current lf and rg let's iterate on cnt — how many open brackets and corresponding them close brackets in a regular bracket sequence will stay between open bracket number lf and corresponding for it close bracket. If this count falls in the given interval for open bracket lf, recurcively run dynamic from two segments — (lf + 1, lf + cnt) and (lf + cnt + 1, rg). If for both segments we can construct regular bracket sequences, appropriate to data-in from input, put in Z[lf][rg] value true. To restore answer, we must move from segment (lf, rg) in segments (lf + 1, lf + cnt) and (lf + cnt + 1, rg), if for both this segments we can construct regular bracket sequences and recursively restore asnwer. If Z[0][n - 1] equals to false, print IMPOSSIBLE. Asymptotic behavior of this solution — O(n3).UPD This problem can be solved with help of griddy algorithm. Asymptotic behavior of this solution — O(n). Here is example of such solution, participant matrix.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/16048?locale=en",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 508\\s*E"
          },
          "content_length": 4804
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #288 (Div. 2) - Codeforces - Code 1",
          "code": "int ip = 0, comp = 0, ini;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16035",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #288 (Div. 2) - Codeforces - Code 2",
          "code": "1000 1000 1000\n1000 1\n1000 2\n1000 3\n...\n1000 1000",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16035",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #288 (Div. 2) - Codeforces - Code 3",
          "code": "1000 1000 1000\n1000 1\n1000 2\n1000 3\n...\n1000 1000",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16035",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #288 (Div.2) Editorial - Codeforces - Code 1",
          "code": "3\n2 5\n1 4\n1 4",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16048?locale=en",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #288 (Div.2) Editorial - Codeforces - Code 2",
          "code": "3\n2 5\n1 4\n1 4",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16048?locale=en",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #288 (Div.2) Editorial - Codeforces - Code 3",
          "code": "j\n    v\n((()))\n ^^ \n ki",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16048?locale=en",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #288 (Div.2) Editorial - Codeforces - Code 4",
          "code": "j\n    v\n((()))\n ^^ \n ki",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16048?locale=en",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #288 (Div.2) Editorial - Codeforces - Code 5",
          "code": "j\n  --v\n((()))\n\nturns into\n\n  j \n  v--\n(()())",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16048?locale=en",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #288 (Div.2) Editorial - Codeforces - Code 6",
          "code": "j\n  --v\n((()))\n\nturns into\n\n  j \n  v--\n(()())",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16048?locale=en",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    \n    // Read n\n    int n = inf.readInt(1, 600);\n    inf.readEoln();\n    \n    // Read n pairs of li and ri\n    for (int i = 0; i < n; i++) {\n        int li = inf.readInt(1, 2 * n - 1);\n        inf.readSpace();\n        int ri = inf.readInt(li, 2 * n - 1);\n        inf.readEoln();\n    }\n    \n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    \n    // Read n\n    int n = inf.readInt(1, 600);\n    inf.readEoln();\n    \n    // Read n pairs of li and ri\n    for (int i = 0; i < n; i++) {\n        int li = inf.readInt(1, 2 * n - 1);\n        inf.readSpace();\n        int ri = inf.readInt(li, 2 * n - 1);\n        inf.readEoln();\n    }\n    \n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    \n    // Read n\n    int n = inf.readInt(1, 600);\n    inf.readEoln();\n    \n    // Read n pairs of li and ri\n    for (int i = 0; i < n; i++) {\n        int li = inf.readInt(1, 2 * n - 1);\n        inf.readSpace();\n        int ri = inf.readInt(li, 2 * n - 1);\n        inf.readEoln();\n    }\n    \n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint n;\nvector<int> l, r;\n\nint main(int argc, char* argv[]) {\n    registerTestlibCmd(argc, argv);\n\n    n = inf.readInt();\n    l.resize(n);\n    r.resize(n);\n    for (int i = 0; i < n; i++) {\n        l[i] = inf.readInt();\n        r[i] = inf.readInt();\n    }\n\n    string jury_output = ans.readString();\n    string contestant_output = ouf.readString();\n\n    jury_output = trim(jury_output);\n    contestant_output = trim(contestant_output);\n\n    if (contestant_output == \"IMPOSSIBLE\") {\n        if (jury_output == \"IMPOSSIBLE\")\n            quitf(_ok, \"Correctly found impossible\");\n        else\n            quitf(_wa, \"Contestant claims impossible when a solution exists\");\n    }\n    else {\n        if (jury_output == \"IMPOSSIBLE\")\n            quitf(_wa, \"Contestant found a solution when none exists\");\n\n        if (int(contestant_output.length()) != 2 * n)\n            quitf(_wa, \"Bracket sequence length is not 2n\");\n\n        for (int i = 0; i < 2 * n; i++) {\n            if (contestant_output[i] != '(' && contestant_output[i] != ')') {\n                quitf(_wa, \"Invalid character in bracket sequence at position %d\", i + 1);\n            }\n        }\n\n        stack<int> stk;\n        vector<pair<int, int>> matches;\n        for (int i = 0; i < 2 * n; i++) {\n            if (contestant_output[i] == '(') {\n                stk.push(i);\n            }\n            else {\n                if (stk.empty())\n                    quitf(_wa, \"Unmatched closing bracket at position %d\", i + 1);\n                int opening_pos = stk.top();\n                stk.pop();\n                matches.push_back({opening_pos, i});\n            }\n        }\n        if (!stk.empty())\n            quitf(_wa, \"Unmatched opening bracket at position %d\", stk.top() + 1);\n\n        sort(matches.begin(), matches.end());\n\n        if (int(matches.size()) != n)\n            quitf(_fail, \"Internal error: number of matches != n\");\n\n        for (int i = 0; i < n; i++) {\n            int dist = matches[i].second - matches[i].first;\n            if (dist < l[i] || dist > r[i]) {\n                quitf(_wa, \"Distance for bracket pair %d is %d, which is not in [%d, %d]\", i + 1, dist, l[i], r[i]);\n            }\n        }\n\n        quitf(_ok, \"Correct bracket sequence\");\n    }\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring generate_random_bracket_sequence(int n) {\n    int open = 0, close = 0, total = 2*n;\n    string s;\n    for (int i = 0; i < 2*n; ++i) {\n        if ((open < n && rnd.next(0,1)) || (close == open)) {\n            s += '(';\n            open++;\n        } else {\n            s += ')';\n            close++;\n        }\n    }\n    return s;\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    if (type == \"random\") {\n        // Generate a random valid bracket sequence\n        string s = generate_random_bracket_sequence(n);\n        vector<int> opening_positions;\n        vector<int> distances;\n        stack<int> stk;\n        int opening_index = 0;\n        vector<int> opening_indices(2*n, -1);\n        for (int i = 0; i < 2*n; ++i) {\n            if (s[i] == '(') {\n                stk.push(i);\n                opening_positions.push_back(i);\n                opening_indices[i] = opening_index++;\n            } else {\n                int open_pos = stk.top();\n                stk.pop();\n                int dist = i - open_pos;\n                distances.push_back(dist);\n            }\n        }\n        vector<int> li(n), ri(n);\n        int k = rnd.next(0, 5); // variation up to 5\n        for (int i = 0; i < n; ++i) {\n            int d = distances[i] + 1; // distances are 1-based\n            li[i] = max(1, d - k);\n            ri[i] = min(2*n -1, d + k);\n        }\n        printf(\"%d\\n\", n);\n        for (int i = 0; i < n; ++i) {\n            printf(\"%d %d\\n\", li[i], ri[i]);\n        }\n    } else if (type == \"impossible\") {\n        // Generate an impossible test case\n        vector<int> li(n), ri(n);\n        int sum_li = 0;\n        for (int i = 0; i < n; ++i) {\n            li[i] = rnd.next(n, n + 5); // Minimal distances are relatively large\n            ri[i] = li[i] + rnd.next(0, 5);\n            sum_li += li[i];\n        }\n        if (sum_li <= 2*n) {\n            // Force the sum to be greater than 2n\n            li[0] += (2*n - sum_li + 1);\n        }\n        printf(\"%d\\n\", n);\n        for (int i = 0; i < n; ++i) {\n            printf(\"%d %d\\n\", li[i], ri[i]);\n        }\n    } else if (type == \"maxdist\") {\n        // Maximal distances\n        printf(\"%d\\n\", n);\n        int remaining = 2*n;\n        for (int i = 0; i < n; ++i) {\n            int d = 2*n - (2*i + 1);\n            printf(\"%d %d\\n\", d, d);\n        }\n    } else if (type == \"mindist\") {\n        // Minimal distances\n        printf(\"%d\\n\", n);\n        for (int i = 0; i < n; ++i) {\n            printf(\"%d %d\\n\", 1, 1);\n        }\n    } else {\n        // Default to random\n        // You can repeat the random case or handle unknown types\n        string s = generate_random_bracket_sequence(n);\n        vector<int> opening_positions;\n        vector<int> distances;\n        stack<int> stk;\n        int opening_index = 0;\n        vector<int> opening_indices(2*n, -1);\n        for (int i = 0; i < 2*n; ++i) {\n            if (s[i] == '(') {\n                stk.push(i);\n                opening_positions.push_back(i);\n                opening_indices[i] = opening_index++;\n            } else {\n                int open_pos = stk.top();\n                stk.pop();\n                int dist = i - open_pos;\n                distances.push_back(dist);\n            }\n        }\n        vector<int> li(n), ri(n);\n        int k = rnd.next(0, 5); // variation up to 5\n        for (int i = 0; i < n; ++i) {\n            int d = distances[i] + 1; // distances are 1-based\n            li[i] = max(1, d - k);\n            ri[i] = min(2*n -1, d + k);\n        }\n        printf(\"%d\\n\", n);\n        for (int i = 0; i < n; ++i) {\n            printf(\"%d %d\\n\", li[i], ri[i]);\n        }\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring generate_random_bracket_sequence(int n) {\n    int open = 0, close = 0, total = 2*n;\n    string s;\n    for (int i = 0; i < 2*n; ++i) {\n        if ((open < n && rnd.next(0,1)) || (close == open)) {\n            s += '(';\n            open++;\n        } else {\n            s += ')';\n            close++;\n        }\n    }\n    return s;\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    if (type == \"random\") {\n        // Generate a random valid bracket sequence\n        string s = generate_random_bracket_sequence(n);\n        vector<int> opening_positions;\n        vector<int> distances;\n        stack<int> stk;\n        int opening_index = 0;\n        vector<int> opening_indices(2*n, -1);\n        for (int i = 0; i < 2*n; ++i) {\n            if (s[i] == '(') {\n                stk.push(i);\n                opening_positions.push_back(i);\n                opening_indices[i] = opening_index++;\n            } else {\n                int open_pos = stk.top();\n                stk.pop();\n                int dist = i - open_pos;\n                distances.push_back(dist);\n            }\n        }\n        vector<int> li(n), ri(n);\n        int k = rnd.next(0, 5); // variation up to 5\n        for (int i = 0; i < n; ++i) {\n            int d = distances[i] + 1; // distances are 1-based\n            li[i] = max(1, d - k);\n            ri[i] = min(2*n -1, d + k);\n        }\n        printf(\"%d\\n\", n);\n        for (int i = 0; i < n; ++i) {\n            printf(\"%d %d\\n\", li[i], ri[i]);\n        }\n    } else if (type == \"impossible\") {\n        // Generate an impossible test case\n        vector<int> li(n), ri(n);\n        int sum_li = 0;\n        for (int i = 0; i < n; ++i) {\n            li[i] = rnd.next(n, n + 5); // Minimal distances are relatively large\n            ri[i] = li[i] + rnd.next(0, 5);\n            sum_li += li[i];\n        }\n        if (sum_li <= 2*n) {\n            // Force the sum to be greater than 2n\n            li[0] += (2*n - sum_li + 1);\n        }\n        printf(\"%d\\n\", n);\n        for (int i = 0; i < n; ++i) {\n            printf(\"%d %d\\n\", li[i], ri[i]);\n        }\n    } else if (type == \"maxdist\") {\n        // Maximal distances\n        printf(\"%d\\n\", n);\n        int remaining = 2*n;\n        for (int i = 0; i < n; ++i) {\n            int d = 2*n - (2*i + 1);\n            printf(\"%d %d\\n\", d, d);\n        }\n    } else if (type == \"mindist\") {\n        // Minimal distances\n        printf(\"%d\\n\", n);\n        for (int i = 0; i < n; ++i) {\n            printf(\"%d %d\\n\", 1, 1);\n        }\n    } else {\n        // Default to random\n        // You can repeat the random case or handle unknown types\n        string s = generate_random_bracket_sequence(n);\n        vector<int> opening_positions;\n        vector<int> distances;\n        stack<int> stk;\n        int opening_index = 0;\n        vector<int> opening_indices(2*n, -1);\n        for (int i = 0; i < 2*n; ++i) {\n            if (s[i] == '(') {\n                stk.push(i);\n                opening_positions.push_back(i);\n                opening_indices[i] = opening_index++;\n            } else {\n                int open_pos = stk.top();\n                stk.pop();\n                int dist = i - open_pos;\n                distances.push_back(dist);\n            }\n        }\n        vector<int> li(n), ri(n);\n        int k = rnd.next(0, 5); // variation up to 5\n        for (int i = 0; i < n; ++i) {\n            int d = distances[i] + 1; // distances are 1-based\n            li[i] = max(1, d - k);\n            ri[i] = min(2*n -1, d + k);\n        }\n        printf(\"%d\\n\", n);\n        for (int i = 0; i < n; ++i) {\n            printf(\"%d %d\\n\", li[i], ri[i]);\n        }\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -type random\n./gen -n 2 -type random\n./gen -n 3 -type random\n./gen -n 4 -type random\n./gen -n 50 -type random\n./gen -n 100 -type random\n./gen -n 200 -type random\n./gen -n 300 -type random\n./gen -n 400 -type random\n./gen -n 500 -type random\n./gen -n 600 -type random\n\n./gen -n 1 -type mindist\n./gen -n 2 -type mindist\n./gen -n 3 -type mindist\n./gen -n 100 -type mindist\n./gen -n 300 -type mindist\n./gen -n 600 -type mindist\n\n./gen -n 1 -type maxdist\n./gen -n 2 -type maxdist\n./gen -n 3 -type maxdist\n./gen -n 100 -type maxdist\n./gen -n 300 -type maxdist\n./gen -n 600 -type maxdist\n\n./gen -n 1 -type impossible\n./gen -n 2 -type impossible\n./gen -n 3 -type impossible\n./gen -n 100 -type impossible\n./gen -n 300 -type impossible\n./gen -n 600 -type impossible\n\n./gen -n 400 -type random\n./gen -n 400 -type random\n./gen -n 400 -type impossible\n./gen -n 400 -type impossible\n./gen -n 500 -type mindist\n./gen -n 500 -type maxdist\n./gen -n 500 -type random\n./gen -n 500 -type impossible\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:41:09.013412",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "509/A",
      "title": "A. Maximum in Table",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe only line of input contains a positive integer n (1 ≤ n ≤ 10) — the number of rows and columns of the table.",
      "output_spec": "OutputPrint a single line containing a positive integer m — the maximum value in the table.",
      "sample_tests": "ExamplesInputCopy1OutputCopy1InputCopy5OutputCopy70",
      "description": "A. Maximum in Table\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe only line of input contains a positive integer n (1 ≤ n ≤ 10) — the number of rows and columns of the table.\n\nOutputPrint a single line containing a positive integer m — the maximum value in the table.\n\nInputCopy1OutputCopy1InputCopy5OutputCopy70\n\nOutputCopy1\n\nOutputCopy70\n\nNoteIn the second test the rows of the table look as follows: {1, 1, 1, 1, 1},  {1, 2, 3, 4, 5},  {1, 3, 6, 10, 15},  {1, 4, 10, 20, 35},  {1, 5, 15, 35, 70}.",
      "solutions": [
        {
          "title": "Codeforces Round #289 (Div. 2) + qualifying round for the WCC - Codeforces",
          "content": "Hello, Codeforces! I'd like to invite you to Codeforces Round #289 (Div. 2). It'll be held on Saturday, January 31 at 15:00 MSK and as usual Div. 1 participants can take part out of competition.This round will be carried out according to the ACM rules, which means that you get verdict of your solution on-line, and the duration time is 3 hours.These differences in the rules are caused by the fact that this round is the second qualifying round for the WCC, which stands for Winter Computer Camp and can be also mentioned as ZKSH. Official school website — hhttp://it-edu.mipt.ru/en/zksh2015. There you can find the selection rules for WCC.If you are a school student and you want to participate in the selection to WCC here are the steps: Sign up for the school at http://goo.gl/kz2qSf, if it was not done earlier. Create a free account at codeforces.com, if it was not done earlier. Sign up for the round on the link http://codeforces.com/contestRegistration/509. You should put a tick in the box \"Do you want to participate in the selection to WCC?\", and provide your last name, first name and email, which you entered for registration in the first step. If you have any questions feel free to write to the address of the organizing committee: zksh-team@phystech.edu.The authors of the contest (WCC technical committee) are really grateful to Max Akhmedov (Zlobober) for the help with preparation of this round, Maria Belova (Delinur) for translation of statements and Mike Mirzayanov (MikeMirzayanov) for contribution to the development of programming by creating systems Codeforces and Polygon.UPD. Tutorial — http://codeforces.com/blog/entry/16119",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/16083",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.6,
            "reason": "宽松匹配: 包含题目编号 509 和字母"
          },
          "content_length": 1654
        },
        {
          "title": "Tutorial CodeForces Round 289 (Div.2) (Second Winter Computer Camp Selection 2015) - Codeforces",
          "content": "509A - Maximum in TableIn this problem one needed to implement what was written in the statement: create matrix (two-dimensional array) using given rules and find maximal value in the table.It is also possible to see that maximal element is always in bottom-right corner.Easier solution with recursion also was enough to get AC: def elem(row, col):\n if row == 1 or col == 1:\n return 1\n return elem(row - 1, col) + elem(row, col - 1)One may see the Pascal's triangle in the given matrix and understand that answer is equal to Prepared by: riadwawAuthor of editorial: riadwaw509B - Painting PebblesSuppose there are two piles with number of pebbles differed by more than k, then there is no solution:Now let M = max ai ≤ min ai + k = m + k.There's a way to construct correct coloring: Chose m peebles from each pile and assign first color to them. In each pile assign different colors to all other pebbles (you may use first color once more) (It's possible bacause there are no more than k uncolored pebbles. Now there are m or m + 1 pebbles of first color and 0 or 1 pebbles of any other color in each pile.Prepared by: KostromaAuthor of editorial: riadwaw509C - Sums of DigitsThe algorithm is greedy: first, take the minimal number with sum of digits a1 — call it b1. Then, on the i-th step take bi as the minimal number with sum of digits ai, which is more than bi - 1. It can be easily proven that this algorithm gives an optimal answer. But how to solve the subproblem: given x and y, find the minimal number with sum of digits x, which is more than y? We use a standard approach: iterate through the digits of y from right to left, trying to increase the current digit and somehow change the digits to the right in order to reach the sum of digits equal to x. Note that if we are considering the (k + 1)-th digit from the right and increase it, we can make the sum of k least significant digits to be any number between 0 and 9k. When we find such position, that increasing a digit in it and changing the least significant digits gives us a number with sum of digits x, we stop the process and obtain the answer. Note that if k least significant digits should have sum m (where 0 ≤ m ≤ 9k), we should obtain the answer greedily, going from the right to the left and putting to the position the largest digit we can. Let us bound the maximal length of the answer, i.e. of bn. If some bi has at least 40 digits, than we take the minimal k such that 10k ≥ bi. Than between 10k and 10k + 1 there exist numbers with any sum of digits between 1 and 9k. If k ≥ 40, than 9k ≥ 300, which is the upper bound of all bi. So, in the constraints of the problem, bi + 1 will be less than 10k + 1. Than, similarly, bi + 2 < 10k + 2 and so on. So, the length of the answer increases by no more than one after reaching the length of 40. Consequently, the maximal length of the answer can't be more than 340. The complexity of solution is O(n·maxLen). Since n ≤ 300, maxLen ≤ 340, the solution runs much faster the time limit.Prepared by: EndagorionAuthor of editorial: Kostroma509D - Restoring NumbersFirst we note that if the sequences ai and bi are a valid solution, then so are the sequences ai - P and bi + P for any integer P. This means that we can consider a1 to be equal to 0 which allows us to recover the sequence bi by simply taking the first row of the matrix. Knowing bi we can also recover ai (for example by subtracting b1 from the first column of the matrix) At this stage we allow ai and bi to contain negative numbers, which can be later fixed by adding K a sufficient amount of times. Now we consider the “error” matrix e: .If e consists entirely of 0s, then we’ve found our solution by taking a sufficiently large K. That is: K > maxi, j(wi, j).Otherwise, we note that ei, j = 0(modK) which implies that K is a divisor of g = gcdi, j(ei, j). The greatest such number is g itself, so all that remains is to check if g is strictly greater than all the elements of the matrix w. If that is the case, then we’ve found our solution by setting K = g. Otherwise, there’s no solution.Prepared by: Kostroma, riadwawAuthor of editorial: riadwaw509E - Pretty SongWe first calculate the prefix sums of vowel(si) which allows to calculate the sum of vowel(si) on any substring in O(1) time.For all m from 1 to , we will calculate the sum of simple pretinesses of all substrings of that length, let’s call it SPm. For that purpose, let’s calculate the number of times the i-th character of the string s is included in this sum. For m = 1 and m = |s|, every character is included exactly 1 time. For m = 2 and m = |s| - 1, the first and the last character are included 1 time and all other characters are included 2 times. For m = 3 and m = |s| - 2 the first and the last character are included 1 time, the second and the pre-last character are included 2 times and all others are included 3 times, and so on.In general, the i-th character is included min(m, |s| - m + 1, i, |s| — i + 1) times. Note that when moving from substrings of length m to substrings of length m + 1, there are 2 ways in which the sum SP can change: If m > |s| - m + 1, then SP is decreased by the number of vowel occurrences in the substring from |s| - m + 1 to m. Otherwise, SP is increased by the number of vowel occurrences in the substring from m to |s| - m + 1. This way we can easily recalculate SPm + 1 using SPm by adding (subtracting) the number of vowel occurrences on a substring (which is done in O(1) time). The complexity of this solution is O(N).Prepared by: zemenAuthor of editorial: zemen509F - Progress MonitoringConsider a tree with n vertices rooted at vertex 1 and let b be the pseudocode’s (DFS) resulting sequence. Then b[lv..lv + sizev - 1], represents vertex v’s subtree, where lv is the index of v in b and sizev is the size of $v$’s subtree.Let’s solve the problem using this fact and Dynamic Programming. Let e[l, r] be the number of trees consisting of vertices a[l], a[l + 1], …, a[r] such that running DFS starting from a[l] will result in a sequence with vertices in the same order as their order in a. The base case is when l = r and e[l, r] = 1. Otherwise, where the sum is taken over all partitions of the segment [l + 1, r], that is, over all k;pos1, ..., posk + 1, such that l + 1 = pos1 < pos2 < ... < posk + 1 = r, 1 ≤ k ≤ r - l, a[pos1] < a[pos2] < ... < a[posk]. Each such partition represents a different way to distribute the vertices among a[l]’s children’s subtrees. A solution using this formula for calculating e[l, r] will have an exponential running time.The final idea is to introduce d[l, r]:  = e[l - 1, r], 2 ≤ l ≤ r ≤ n. It follows that: d[l, r] = ([statement] is equal to 1 if the statement is true, 0 otherwise) and e[l, r] = d[l + 1, r]. This way d[l, r] and e[l, r] can be calculated in linear time for any segment [l, r]. The answer to the problem is e[1, n]. Overall complexity is O(n3).Prepared by: DPR-pavlinAuthor of editorial: DPR-pavlin",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/16119",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 509\\s*A"
          },
          "content_length": 6968
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #289 (Div. 2) + qualifying round for the WCC - Codeforces - Code 1",
          "code": "FOR(K, 0, 102) {\n   if(abs(c1[K]- c2[K]) > 1) {\n     f = false;\n     break;\n   }\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16083",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #289 (Div. 2) + qualifying round for the WCC - Codeforces - Code 2",
          "code": "FOR(K, 0, 102) {\n   if(abs(c1[K]- c2[K]) > 1) {\n     f = false;\n     break;\n   }\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16083",
          "author": "jiangly"
        },
        {
          "title": "Tutorial CodeForces Round 289 (Div.2) (Second Winter Computer Camp Selection 2015) - Codeforces - Code 1",
          "code": "def elem(row, col):\n    if row == 1 or col == 1:\n        return 1\n    return elem(row - 1, col) + elem(row, col - 1)",
          "language": "Python",
          "source": "https://codeforces.com/blog/entry/16119",
          "author": "jiangly"
        },
        {
          "title": "Tutorial CodeForces Round 289 (Div.2) (Second Winter Computer Camp Selection 2015) - Codeforces - Code 2",
          "code": "def elem(row, col):\n    if row == 1 or col == 1:\n        return 1\n    return elem(row - 1, col) + elem(row, col - 1)",
          "language": "Python",
          "source": "https://codeforces.com/blog/entry/16119",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 10, \"n\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 10, \"n\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 10, \"n\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    // Since the problem specifies 1 <= n <= 10, we set defaults accordingly.\n    int minN = opt<int>(\"minN\", 1);\n    int maxN = opt<int>(\"maxN\", 10);\n    // type can be \"random\", or any custom value that forces n = minN or n = maxN, etc.\n    string type = opt<string>(\"type\", \"random\");\n\n    // Ensure minN and maxN do not exceed problem constraints [1..10].\n    minN = max(1, min(minN, 10));\n    maxN = max(1, min(maxN, 10));\n    if (minN > maxN) {\n        // In case of invalid parameter order, swap them\n        swap(minN, maxN);\n    }\n\n    int n;\n    if (type == \"min\") {\n        n = minN;\n    } else if (type == \"max\") {\n        n = maxN;\n    } else {\n        // Random n in [minN, maxN].\n        n = rnd.next(minN, maxN);\n    }\n\n    // Output only one integer n.\n    cout << n << \"\\n\";\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    // Since the problem specifies 1 <= n <= 10, we set defaults accordingly.\n    int minN = opt<int>(\"minN\", 1);\n    int maxN = opt<int>(\"maxN\", 10);\n    // type can be \"random\", or any custom value that forces n = minN or n = maxN, etc.\n    string type = opt<string>(\"type\", \"random\");\n\n    // Ensure minN and maxN do not exceed problem constraints [1..10].\n    minN = max(1, min(minN, 10));\n    maxN = max(1, min(maxN, 10));\n    if (minN > maxN) {\n        // In case of invalid parameter order, swap them\n        swap(minN, maxN);\n    }\n\n    int n;\n    if (type == \"min\") {\n        n = minN;\n    } else if (type == \"max\") {\n        n = maxN;\n    } else {\n        // Random n in [minN, maxN].\n        n = rnd.next(minN, maxN);\n    }\n\n    // Output only one integer n.\n    cout << n << \"\\n\";\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Below are ~20 distinct sample runs to produce different test cases.\n# Each run prints a single line with one valid n (1 <= n <= 10).\n\n./gen\n./gen -minN 1 -maxN 1\n./gen -minN 10 -maxN 10\n./gen -minN 1 -maxN 10\n./gen -minN 2 -maxN 2\n./gen -minN 1 -maxN 5\n./gen -minN 5 -maxN 10\n./gen -minN 1 -maxN 10 -type min\n./gen -minN 1 -maxN 10 -type max\n./gen -minN 1 -maxN 10 -type random\n./gen -minN 8 -maxN 10 -type random\n./gen -minN 1 -maxN 3 -type random\n./gen -minN 1 -maxN 4 -type random\n./gen -minN 7 -maxN 7 -type random\n./gen -minN 3 -maxN 3 -type random\n./gen -minN 2 -maxN 9 -type min\n./gen -minN 2 -maxN 9 -type max\n./gen -minN 1 -maxN 10 -type random\n./gen -minN 4 -maxN 10 -type random\n./gen -minN 1 -maxN 10 -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:41:10.606153",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "509/B",
      "title": "B. Раскраска шаров",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест1 секунда",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеВ первой строке входных данных заданы натуральные числа n и k (1 ≤ n, k ≤ 100), разделенные пробелом — количество кучек и количество цветов соответственно.Во второй строке заданы n натуральных чисел a1, a2, ..., an (1 ≤ ai ≤ 100), задающие количества камней в кучках.",
      "output_spec": "Выходные данныеЕсли раскраски камней, удовлетворяющей условию задачи, не существует, в единственной строке выведите «NO» (без кавычек).Иначе в первой строке «YES» (без кавыечек). Далее должны следовать n строк, в i-й из них должны находиться ai чисел, разделенных пробелами. j-е (1 ≤ j ≤ ai) из этих чисел должно равняться цвету j-го камня в i-й кучке. Если возможных ответов несколько, разрешается вывести любой.",
      "sample_tests": "ПримерыВходные данныеСкопировать4 41 2 3 4Выходные данныеСкопироватьYES11 41 2 41 2 3 4Входные данныеСкопировать5 23 2 4 1 3Выходные данныеСкопироватьNOВходные данныеСкопировать5 43 2 4 3 5Выходные данныеСкопироватьYES1 2 31 31 2 3 41 3 41 1 2 3 4",
      "description": "B. Раскраска шаров\n\nограничение по времени на тест1 секунда\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвыводstdout\n\nВходные данныеВ первой строке входных данных заданы натуральные числа n и k (1 ≤ n, k ≤ 100), разделенные пробелом — количество кучек и количество цветов соответственно.Во второй строке заданы n натуральных чисел a1, a2, ..., an (1 ≤ ai ≤ 100), задающие количества камней в кучках.\n\nВходные данные\n\nВыходные данныеЕсли раскраски камней, удовлетворяющей условию задачи, не существует, в единственной строке выведите «NO» (без кавычек).Иначе в первой строке «YES» (без кавыечек). Далее должны следовать n строк, в i-й из них должны находиться ai чисел, разделенных пробелами. j-е (1 ≤ j ≤ ai) из этих чисел должно равняться цвету j-го камня в i-й кучке. Если возможных ответов несколько, разрешается вывести любой.\n\nВыходные данные\n\nВходные данныеСкопировать4 41 2 3 4Выходные данныеСкопироватьYES11 41 2 41 2 3 4Входные данныеСкопировать5 23 2 4 1 3Выходные данныеСкопироватьNOВходные данныеСкопировать5 43 2 4 3 5Выходные данныеСкопироватьYES1 2 31 31 2 3 41 3 41 1 2 3 4\n\nВходные данныеСкопировать4 41 2 3 4\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопироватьYES11 41 2 41 2 3 4\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать5 23 2 4 1 3\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопироватьNO\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать5 43 2 4 3 5\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопироватьYES1 2 31 31 2 3 41 3 41 1 2 3 4\n\nВыходные данныеСкопировать\n\nСкопировать",
      "solutions": [
        {
          "title": "Codeforces Round #289 (Div. 2) + отборочный раунд на ЗКШ - Codeforces",
          "content": "Привет, Codeforces!31 января в 15:00 MSK состоится раунд #289 для участников из второго дивизиона. Традиционно, участники из первого дивизиона могут участвовать в соревновании вне конкурса.Этот раунд отличается от остальных тем, что он будет проведен по правилам АСМ, то есть результаты проверки на всех тестах вы получаете в режиме онлайн, а его продолжительность составит 3 часа. Данные отличия в правилах вызваны тем, что этот раунд является вторым отборочным раундом в ЗКШ. Официальный сайт школы — http://it-edu.mipt.ru/zksh2015. Там же вы можете найти правила отбора на ЗКШ.Алгоритм действий для школьника, желающего поучаствовать в отборе на ЗКШ (вне зависимости от дивизиона): Зарегистрироваться на школу по ссылке http://goo.gl/kz2qSf, если это не было сделано ранее. Зарегистрироваться на сайте codeforces.ru, если это не было сделано ранее. Зарегистрироваться на раунд по ссылке http://codeforces.com/contestRegistration/509. При регистрации требуется поставить галочку в поле \"Хотите ли вы участвовать в отборе на ЗКШ?\", а также указать фамилию, имя, отчество и email, которые вы указали при регистрации на школу в пункте №1. По всем возникающим вопросам пишите на адрес оргкомитета: zksh-team@phystech.edu.В заключение, наш коллектив авторов (тех. комитет ЗКШ) выражает свою благодарность Максиму Ахмедову (Zlobober) за помощь в подготовке задач, Марии Беловой (Delinur) за перевод условий на английский, Михаилу Мирзаянову (MikeMirzayanov) за вклад в развитие программирования путем создания систем Codeforces и Polygon.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/16083",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.5,
            "reason": "宽松匹配: 包含题目编号 509"
          },
          "content_length": 1534
        },
        {
          "title": "Разбор CodeForces Round 289 (Div.2) (Второй отборочный тур ЗКШ 2015) - Codeforces",
          "content": "509A - Максимум в таблицеВ этой задаче нужно было сделать то, что написано в условии: построить таблицу(двумерный массив) по указанным правилам и найти максимум в таблице.Можно было заметить также, что максимальный элемент находится в правом нижнем углу.Также проходило и просто решение рекурсией: def elem(row, col):\n if row == 1 or col == 1:\n return 1\n return elem(row - 1, col) + elem(row, col - 1)Кроме того, можно было заметить в таблице Треугольник Паскаля и понять, что ответ — это Готовил: riadwawРазбор от: riadwaw509B - Раскраска шаровПусть найдутся две кучки, в которых количество камней отличается строго больше чем на k, тогда решения не существует:Пусть теперь M = max ai ≤ min ai + k = m + k, покажем, как построить правильную раскраску: покрасим по m камней в каждой кучке в первый цвет в каждой кучке все оставшиеся камни покрасим в любые различные цвета(можно использовать первый еще один раз) (это можно сделать т.к осталось не более k камней. Заметим, что 1-ый цвет встречается в каждой кучке m или m + 1 раз, а остальные цвета — 0 или 1 разГотовил: KostromaРазбор от: riadwaw509C - Суммы цифрБудем действовать жадно. На первом шаге найдём минимальное число b1 с суммой цифр a1. Далее, на i-м шаге найдём минимальное число bi с суммой цифр ai, которое больше чем bi - 1. Почему это правильно? Поскольку b1 — минимальное число с суммой цифрой a1, то первое число не меньше чем b1. Далее по индукции: i-е число не меньше bi, поэтому (i + 1)-е число должно иметь сумму цифр ai + 1 и быть больше чем bi. Но минимальное такое число как раз bi + 1. Значит, построенный пример даёт оптимальное решение задачи. Осталось научиться решать подзадачу: найти минимальное число с суммой цифр x, которое больше y. Она решается стандартным подходом: идем по цифрам числа y с младших разрядов и пытаемся увеличить соответствующую цифру (считаем, что каждое число содержит бесконечно много нулей слева от своей старшей цифры). Пусть справа осталось k цифр, тогда сумма этих k цифр может быть любым натуральным числом от 0 до 9k. Если получилось увеличить текущую цифру так, что при каком-то выборе цифр справа от неё получилась сумма x, то мы получили ответ. Заметим, что цифры справа от текущей позиции в таком случае нужно заполнять жадно с младших разрядов, каждый раз используя максимально возможную цифру — таким образом мы действительно получим минимальный ответ.Оценим максимальную длину ответа, т.е. числа bn. Заметим, что если длина десятичной записи bi хотя бы 40, то в промежутке между 10k и 10k + 1, где k — наименьшее натуральное число, такое что 10k ≥ bi, есть числа со всеми суммами цифр от 1 до 9k. Так как все ai ≤ 300, то при в отрезке [10k, 10k + 1] есть любая из интересующих нас сумм цифр. Значит, при достижении 40-значного числа на каждом шаге количество цифр в десятичной записи bi увеличивается не более чем на 2, а значит итоговый ответ будет иметь десятичную записать не длиннее 640 цифр (еще немного подумав, можно понять, что эту оценку можно усилить до 340).Значит, получаем решение за O(n·maxLen), где maxLen — максимальная длина ответа. Поскольку n ≤ 300, maxLen ≤ 640, такое решение с запасом проходит.Готовил: EndagorionРазбор от: Kostroma509D - Восстановление чиселЗаметим, что если в корректном ответе ко всем bi добавить 1, а из всех ai вычесть 1 (и при необходимости добавив k), то ответ останется корректным. поэтому можно считать, что ai = 0, тогда из первой строки однозначно восстанавливаются bj, а по ним — ai (Можно пока разрешить им быть отрицательными, а потом добавить нужное число раз k). Теперь для любых i, j мы можем найти \"ошибку\" .Если все ошибки нулевые — всё отлично, возьмем k достаточно большим и ответ будет автоматически корректным.Для того, чтобы не нарушалось условие в клетке (i, j) необходимо и достаточно, чтобы ei, j делилось на k. Таким образом, k должно быть делителем gcdi, j(ei, j). При этом, k должно быть строго больше, чем все числа в таблице. Таким образом выгодно попытаться поставить k = gcdi, j(ei, j), что можно сделать, если k > maxi, j(wi, j). В противном случае ответа не существует.Готовили: Kostroma, riadwawРазбор от: riadwaw509E - Мелодичная песняПосчитаем суммы vowel(si) на всех префиксах строки, чтобы за O(1) можно было легко посчитать сумму vowel(si) на любой подстроке.Будем перебирать m с 1 до . При фиксированном m найдем сумму простых мелодичностей всех подстрок длины m. Для этого посмотрим, сколько раз i-й символ s входит в эту сумму.При m = 1 каждый символ входит ровно один раз. При m = 2 все символы, кроме крайних — 2 раза, крайние 1 раз. При m = 3 все 3 раза, кроме второго и предпоследнего(2 раза) и первого и последнего (1 раз).При m = |s| каждый символ входит один раз, как и в случае m = 1, а при m = |s| - 1— 2 раза кроме крайних, как и в случае m = 2.В общем случае, i-й символ входит min(m, |s| - m + 1, i, |s| — i + 1) раз. Можно заметить, что при переходе от m к m + 1 к сумме прибавляются вхождения символов на подотрезке с m по |s| - m + 1(если m > |s| - m + 1, то убавляются на подотрезке с |s| - m + 1 по m).Таким образом, можно легко пересчитать сумму вхождений гласных при переходе от m к m + 1, прибавив(убавив) сумму vowel на подстроке. Итоговое решение за O(N).Готовил: zemenРазбор от: zemen509F - Контроль успеваемостиРассмотрим произвольное дерево на n вершинах. Подвесим дерево за вершину 1, и пусть массив a — результат работы dfs-а. Тогда вершины поддерева с вершиной v, 1 ≤ v ≤ n, записаны в подмассив a[lv..lv + sizev - 1], где lv есть позиция вершины v в массиве, а sizev — размер поддерева.Решим задачу, используя сей факт и ДП на подотрезках. Пусть задан массив a, и пусть e[l, r] есть количество деревьев, составленных из вершин a[l], a[l + 1], ..., a[r], т.ч. dfs, запущенный из вершины a[l], выведет вершины в том же порядке, в котором они представлены в массиве a. Тогда, если l = r, то e[l, r] = 1; иначе , где сумма берется по всем возможным множествам детей a[l], т.е. по всем таким k;pos1, ..., posk + 1, что l + 1 = pos1 < pos2 < ... < posk + 1 = r + 1, 1 ≤ k ≤ r - l, a[pos1] < a[pos2] < ... < a[posk] (вспомним, что в dfs-е дети перебираются в порядке возрастания). Однако даже при наличии ответов для подотрезков отрезка [1..n] решение с использованием такой формулы будет работать экспоненциально долго.Финальная идея заключается во введении d[l, r]:  = e[l - 1, r], 2 ≤ l ≤ r ≤ n. Действительно, из вышеприведенной формулы следует, что d[l, r] = ([утверждение] определим как 1, если утверждение истинно, и 0, если ложно), а также e[l, r] = d[l + 1, r]. Таким образом, d[l, r] и e[l, r] для каждого отрезка вычисляются за линейное время; ответом же на задачу является e[1, n]. Итоговая асимптотика решения O(n3).Готовил: DPR-pavlinРазбор от: DPR-pavlin",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/16119",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 509\\s*B"
          },
          "content_length": 6696
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #289 (Div. 2) + отборочный раунд на ЗКШ - Codeforces - Code 1",
          "code": "FOR(K, 0, 102) {\n   if(abs(c1[K]- c2[K]) > 1) {\n     f = false;\n     break;\n   }\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16083",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #289 (Div. 2) + отборочный раунд на ЗКШ - Codeforces - Code 2",
          "code": "FOR(K, 0, 102) {\n   if(abs(c1[K]- c2[K]) > 1) {\n     f = false;\n     break;\n   }\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16083",
          "author": "jiangly"
        },
        {
          "title": "Разбор CodeForces Round 289 (Div.2) (Второй отборочный тур ЗКШ 2015) - Codeforces - Code 1",
          "code": "def elem(row, col):\n    if row == 1 or col == 1:\n        return 1\n    return elem(row - 1, col) + elem(row, col - 1)",
          "language": "Python",
          "source": "https://codeforces.com/blog/entry/16119",
          "author": "jiangly"
        },
        {
          "title": "Разбор CodeForces Round 289 (Div.2) (Второй отборочный тур ЗКШ 2015) - Codeforces - Code 2",
          "code": "def elem(row, col):\n    if row == 1 or col == 1:\n        return 1\n    return elem(row - 1, col) + elem(row, col - 1)",
          "language": "Python",
          "source": "https://codeforces.com/blog/entry/16119",
          "author": "jiangly"
        },
        {
          "title": "Разбор CodeForces Round 289 (Div.2) (Второй отборочный тур ЗКШ 2015) - Codeforces - Code 3",
          "code": "Тогда, если l ≤ r, то e[l, r] = 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16119",
          "author": "jiangly"
        },
        {
          "title": "Разбор CodeForces Round 289 (Div.2) (Второй отборочный тур ЗКШ 2015) - Codeforces - Code 4",
          "code": "d[l, r]:  = e[l - 1, n].",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16119",
          "author": "jiangly"
        },
        {
          "title": "Разбор CodeForces Round 289 (Div.2) (Второй отборочный тур ЗКШ 2015) - Codeforces - Code 5",
          "code": "На первом шаге найдём минимальное число b1 с суммой цифр a1. Далее, на i-м шаге найдём минимальное число bi с суммой цифр ai, которое больше чем bi - 1.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16119",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(1, 100, \"k\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, 1, 100, \"a_i\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(1, 100, \"k\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, 1, 100, \"a_i\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(1, 100, \"k\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, 1, 100, \"a_i\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <vector>\n#include <string>\n#include <cmath>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerTestlibCmd(argc, argv);\n\n    int n = inf.readInt();\n    int k = inf.readInt();\n    vector<int> a(n);\n    for (int i = 0; i < n; ++i) {\n        a[i] = inf.readInt();\n    }\n\n    string jans = ans.readToken();\n    string pans = ouf.readToken();\n\n    if (jans != \"YES\" && jans != \"NO\") {\n        quitf(_fail, \"Jury's answer is neither YES nor NO: '%s'\", compress(jans).c_str());\n    }\n\n    if (pans != \"YES\" && pans != \"NO\") {\n        quitf(_pe, \"Participant's answer is neither YES nor NO: '%s'\", compress(pans).c_str());\n    }\n\n    if (jans == \"NO\") {\n        if (pans == \"NO\") {\n            quitf(_ok, \"Correctly answered NO\");\n        } else {\n            // Participant outputs YES when jury says NO\n            quitf(_fail, \"Participant found a solution when jury says NO\");\n        }\n    } else { // jans == \"YES\"\n        if (pans == \"NO\") {\n            quitf(_wa, \"Participant claimed no solution exists when a solution exists\");\n        } else { // pans == \"YES\"\n            // Read participant's painting plan\n            vector< vector<int> > participant_colors(n);\n            for (int i = 0; i < n; ++i) {\n                participant_colors[i] = ouf.readInts(a[i], 1, k, format(\"colors in pile %d\", i+1).c_str());\n            }\n            // Initialize bi_c[i][c] = number of pebbles of color c in pile i\n            vector< vector<int> > bi_c(n, vector<int>(k+1, 0)); // colors from 1 to k\n            for (int i = 0; i < n; ++i) {\n                for (int color : participant_colors[i]) {\n                    bi_c[i][color]++;\n                }\n            }\n            // Check the condition for all colors c\n            for (int c = 1; c <= k; ++c) {\n                for (int i = 0; i < n; ++i) {\n                    for (int j = i+1; j < n; ++j) {\n                        if (abs(bi_c[i][c] - bi_c[j][c]) > 1) {\n                            quitf(_wa, \"Condition violated for color %d between piles %d and %d\", c, i+1, j+1);\n                        }\n                    }\n                }\n            }\n            // All conditions are satisfied\n            quitf(_ok, \"Participant's answer is correct\");\n        }\n    }\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int k = opt<int>(\"k\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> a(n);\n\n    if (type == \"max_ai_lt_k\") {\n        // Generate ai's where maximum ai ≤ k\n        for (int i = 0; i < n; ++i)\n            a[i] = rnd.next(1, k);\n    } else if (type == \"max_ai_gt_k\") {\n        // Generate ai's where maximum ai > k (expect NO output)\n        int max_ai = rnd.next(k + 1, 100);\n        for (int i = 0; i < n; ++i)\n            a[i] = rnd.next(1, 100);\n        a[rnd.next(0, n - 1)] = max_ai; // Ensure at least one ai > k\n    } else if (type == \"max_ai_eq_k\") {\n        // Generate ai's where ai = k\n        for (int i = 0; i < n; ++i)\n            a[i] = k;\n    } else if (type == \"min_ai\") {\n        // Generate ai's where ai = 1\n        for (int i = 0; i < n; ++i)\n            a[i] = 1;\n    } else if (type == \"max_ai\") {\n        // Generate ai's where ai = 100\n        for (int i = 0; i < n; ++i)\n            a[i] = 100;\n    } else if (type == \"incremental\") {\n        // ai's are increasing from 1 up to 100\n        for (int i = 0; i < n; ++i)\n            a[i] = min(i + 1, 100);\n    } else {\n        // Random ai's between 1 and 100\n        for (int i = 0; i < n; ++i)\n            a[i] = rnd.next(1, 100);\n    }\n\n    printf(\"%d %d\\n\", n, k);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d\", a[i]);\n        if (i + 1 < n) printf(\" \");\n    }\n    printf(\"\\n\");\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int k = opt<int>(\"k\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> a(n);\n\n    if (type == \"max_ai_lt_k\") {\n        // Generate ai's where maximum ai ≤ k\n        for (int i = 0; i < n; ++i)\n            a[i] = rnd.next(1, k);\n    } else if (type == \"max_ai_gt_k\") {\n        // Generate ai's where maximum ai > k (expect NO output)\n        int max_ai = rnd.next(k + 1, 100);\n        for (int i = 0; i < n; ++i)\n            a[i] = rnd.next(1, 100);\n        a[rnd.next(0, n - 1)] = max_ai; // Ensure at least one ai > k\n    } else if (type == \"max_ai_eq_k\") {\n        // Generate ai's where ai = k\n        for (int i = 0; i < n; ++i)\n            a[i] = k;\n    } else if (type == \"min_ai\") {\n        // Generate ai's where ai = 1\n        for (int i = 0; i < n; ++i)\n            a[i] = 1;\n    } else if (type == \"max_ai\") {\n        // Generate ai's where ai = 100\n        for (int i = 0; i < n; ++i)\n            a[i] = 100;\n    } else if (type == \"incremental\") {\n        // ai's are increasing from 1 up to 100\n        for (int i = 0; i < n; ++i)\n            a[i] = min(i + 1, 100);\n    } else {\n        // Random ai's between 1 and 100\n        for (int i = 0; i < n; ++i)\n            a[i] = rnd.next(1, 100);\n    }\n\n    printf(\"%d %d\\n\", n, k);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d\", a[i]);\n        if (i + 1 < n) printf(\" \");\n    }\n    printf(\"\\n\");\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 5 -k 2 -type max_ai_gt_k\n./gen -n 5 -k 2 -type max_ai_lt_k\n./gen -n 5 -k 4 -type max_ai_lt_k\n./gen -n 5 -k 4 -type max_ai_eq_k\n./gen -n 5 -k 4 -type min_ai\n./gen -n 1 -k 1 -type max_ai_lt_k\n./gen -n 1 -k 100 -type max_ai\n./gen -n 100 -k 1 -type min_ai\n./gen -n 100 -k 1 -type max_ai_gt_k\n./gen -n 100 -k 100 -type max_ai_lt_k\n./gen -n 100 -k 100 -type max_ai_eq_k\n./gen -n 100 -k 100 -type max_ai\n./gen -n 50 -k 25 -type random\n./gen -n 50 -k 25 -type max_ai_lt_k\n./gen -n 50 -k 25 -type max_ai_gt_k\n./gen -n 100 -k 50 -type incremental\n./gen -n 100 -k 50 -type random\n./gen -n 100 -k 30 -type random\n./gen -n 100 -k 20 -type max_ai_eq_k\n./gen -n 100 -k 20 -type max_ai_gt_k\n./gen -n 1 -k 100 -type min_ai\n./gen -n 1 -k 100 -type max_ai_eq_k\n./gen -n 100 -k 100 -type random\n./gen -n 100 -k 100 -type incremental\n./gen -n 99 -k 99 -type max_ai_gt_k\n./gen -n 2 -k 2 -type max_ai_gt_k\n./gen -n 2 -k 2 -type min_ai\n./gen -n 2 -k 2 -type max_ai_eq_k\n./gen -n 10 -k 5 -type random\n./gen -n 10 -k 5 -type max_ai_gt_k\n./gen -n 10 -k 5 -type max_ai_lt_k\n./gen -n 100 -k 10 -type random\n./gen -n 100 -k 10 -type min_ai\n./gen -n 100 -k 10 -type max_ai_eq_k\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:41:12.765567",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "509/C",
      "title": "Problem 509/C",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "",
      "memory_limit": "",
      "input_spec": "",
      "output_spec": "",
      "sample_tests": "",
      "description": "",
      "solutions": [],
      "code_examples": [],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 300, \"n\");\n    inf.readEoln();\n\n    for (int i = 0; i < n; ++i) {\n        int b_i = inf.readInt(1, 300, \"b_i\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 300, \"n\");\n    inf.readEoln();\n\n    for (int i = 0; i < n; ++i) {\n        int b_i = inf.readInt(1, 300, \"b_i\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 300, \"n\");\n    inf.readEoln();\n\n    for (int i = 0; i < n; ++i) {\n        int b_i = inf.readInt(1, 300, \"b_i\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint n;\nvector<int> b;\n\nstruct Answer {\n    vector<string> ai;\n    string an_str; // The last number in the sequence\n};\n\n// Function to read and validate the answer from a stream\nAnswer readAnswer(InStream& in) {\n    Answer res;\n    res.ai.resize(n);\n    // Read n numbers from the stream\n    for (int i = 0; i < n; ++i) {\n        res.ai[i] = in.readToken();\n        // Check that ai[i] is not empty\n        if (res.ai[i].empty()) {\n            in.quitf(_wa, \"ai[%d] is empty\", i + 1);\n        }\n        // Check that ai[i] consists of digits only\n        if (!all_of(res.ai[i].begin(), res.ai[i].end(), ::isdigit)) {\n            in.quitf(_wa, \"ai[%d] contains non-digit characters\", i + 1);\n        }\n        // Check that there are no leading zeros\n        if (res.ai[i][0] == '0') {\n            in.quitf(_wa, \"ai[%d] has leading zero\", i + 1);\n        }\n    }\n    // Check that the sequence is strictly increasing\n    for (int i = 1; i < n; ++i) {\n        string& prev_ai = res.ai[i - 1];\n        string& curr_ai = res.ai[i];\n        if (prev_ai.size() > curr_ai.size() ||\n            (prev_ai.size() == curr_ai.size() && prev_ai >= curr_ai)) {\n            in.quitf(_wa, \"ai[%d] is not strictly greater than ai[%d]\", i + 1, i);\n        }\n    }\n    // Check that the sum of digits of ai[i] equals b[i]\n    for (int i = 0; i < n; ++i) {\n        int sum_of_digits = 0;\n        for (char c : res.ai[i]) {\n            sum_of_digits += c - '0';\n        }\n        if (sum_of_digits != b[i]) {\n            in.quitf(_wa, \"sum of digits of ai[%d] is %d, but expected %d\", i + 1, sum_of_digits, b[i]);\n        }\n    }\n    res.an_str = res.ai[n - 1];\n    return res;\n}\n\nint main(int argc, char* argv[]) {\n    registerTestlibCmd(argc, argv);\n    // Read n and b[] from the input file\n    n = inf.readInt(1, 300);\n    b.resize(n);\n    for (int i = 0; i < n; ++i) {\n        b[i] = inf.readInt(1, 300);\n    }\n    // Read and validate the jury's answer\n    Answer jury_ans = readAnswer(ans);\n    // Read and validate the participant's answer\n    Answer participant_ans = readAnswer(ouf);\n\n    string jury_an_str = jury_ans.an_str;\n    string participant_an_str = participant_ans.an_str;\n\n    // Compare the last numbers of the sequences\n    int cmp;\n    if (participant_an_str.size() > jury_an_str.size()) {\n        cmp = 1;\n    } else if (participant_an_str.size() < jury_an_str.size()) {\n        cmp = -1;\n    } else {\n        cmp = participant_an_str.compare(jury_an_str);\n    }\n\n    if (cmp > 0) {\n        quitf(_wa, \"participant's an (%s) is greater than minimal possible an (%s)\", participant_an_str.c_str(), jury_an_str.c_str());\n    } else if (cmp == 0) {\n        quitf(_ok, \"Correct answer with minimal an (%s)\", participant_an_str.c_str());\n    } else {\n        quitf(_fail, \"participant's an (%s) is less than minimal possible an (%s)\", participant_an_str.c_str(), jury_an_str.c_str());\n    }\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n    int bi_value = opt<int>(\"value\", 1); // default value if needed\n\n    vector<int> bi(n);\n\n    if (type == \"random\") {\n        for (int i = 0; i < n; ++i) {\n            bi[i] = rnd.next(1, 300);\n        }\n    } else if (type == \"increasing\") {\n        int b = 1;\n        for (int i = 0; i < n; ++i) {\n            bi[i] = b;\n            int delta = rnd.next(1, 10); // increment by at least 1\n            b += delta;\n            if (b > 300) b = 300; // cap at 300\n        }\n    } else if (type == \"decreasing\") {\n        int b = 300;\n        for (int i = 0; i < n; ++i) {\n            bi[i] = b;\n            int delta = rnd.next(1, 10); // decrement by at least 1\n            b -= delta;\n            if (b < 1) b = 1; // bottom at 1\n        }\n    } else if (type == \"constant\") {\n        for (int i = 0; i < n; ++i) {\n            bi[i] = bi_value;\n        }\n    } else if (type == \"maximal\") {\n        for (int i = 0; i < n; ++i) {\n            bi[i] = 300;\n        }\n    } else if (type == \"minimal\") {\n        for (int i = 0; i < n; ++i) {\n            bi[i] = 1;\n        }\n    } else if (type == \"big\") {\n        // Big values of bi without exceeding 300\n        for (int i = 0; i < n; ++i) {\n            bi[i] = rnd.next(250, 300);\n        }\n    } else if (type == \"small\") {\n        // Small values of bi\n        for (int i = 0; i < n; ++i) {\n            bi[i] = rnd.next(1, 50);\n        }\n    } else if (type == \"mixed\") {\n        for (int i = 0; i < n; ++i) {\n            int choice = rnd.next(1, 4);\n            if (choice == 1) {\n                bi[i] = rnd.next(1, 50);\n            } else if (choice == 2) {\n                bi[i] = rnd.next(51, 150);\n            } else if (choice == 3) {\n                bi[i] = rnd.next(151, 250);\n            } else {\n                bi[i] = rnd.next(251, 300);\n            }\n        }\n    }\n\n    // Output\n    printf(\"%d\\n\", n);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d\\n\", bi[i]);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n    int bi_value = opt<int>(\"value\", 1); // default value if needed\n\n    vector<int> bi(n);\n\n    if (type == \"random\") {\n        for (int i = 0; i < n; ++i) {\n            bi[i] = rnd.next(1, 300);\n        }\n    } else if (type == \"increasing\") {\n        int b = 1;\n        for (int i = 0; i < n; ++i) {\n            bi[i] = b;\n            int delta = rnd.next(1, 10); // increment by at least 1\n            b += delta;\n            if (b > 300) b = 300; // cap at 300\n        }\n    } else if (type == \"decreasing\") {\n        int b = 300;\n        for (int i = 0; i < n; ++i) {\n            bi[i] = b;\n            int delta = rnd.next(1, 10); // decrement by at least 1\n            b -= delta;\n            if (b < 1) b = 1; // bottom at 1\n        }\n    } else if (type == \"constant\") {\n        for (int i = 0; i < n; ++i) {\n            bi[i] = bi_value;\n        }\n    } else if (type == \"maximal\") {\n        for (int i = 0; i < n; ++i) {\n            bi[i] = 300;\n        }\n    } else if (type == \"minimal\") {\n        for (int i = 0; i < n; ++i) {\n            bi[i] = 1;\n        }\n    } else if (type == \"big\") {\n        // Big values of bi without exceeding 300\n        for (int i = 0; i < n; ++i) {\n            bi[i] = rnd.next(250, 300);\n        }\n    } else if (type == \"small\") {\n        // Small values of bi\n        for (int i = 0; i < n; ++i) {\n            bi[i] = rnd.next(1, 50);\n        }\n    } else if (type == \"mixed\") {\n        for (int i = 0; i < n; ++i) {\n            int choice = rnd.next(1, 4);\n            if (choice == 1) {\n                bi[i] = rnd.next(1, 50);\n            } else if (choice == 2) {\n                bi[i] = rnd.next(51, 150);\n            } else if (choice == 3) {\n                bi[i] = rnd.next(151, 250);\n            } else {\n                bi[i] = rnd.next(251, 300);\n            }\n        }\n    }\n\n    // Output\n    printf(\"%d\\n\", n);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d\\n\", bi[i]);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -type minimal\n./gen -n 1 -type maximal\n\n./gen -n 10 -type random\n./gen -n 10 -type increasing\n./gen -n 10 -type decreasing\n./gen -n 10 -type constant -value 5\n\n./gen -n 100 -type random\n./gen -n 100 -type increasing\n./gen -n 100 -type decreasing\n./gen -n 100 -type constant -value 100\n\n./gen -n 300 -type random\n./gen -n 300 -type increasing\n./gen -n 300 -type decreasing\n./gen -n 300 -type constant -value 1\n./gen -n 300 -type maximal\n\n./gen -n 300 -type big\n./gen -n 300 -type minimal\n\n./gen -n 50 -type random\n./gen -n 150 -type random\n./gen -n 200 -type random\n\n./gen -n 300 -type constant -value 300\n./gen -n 300 -type constant -value 1\n\n./gen -n 300 -type decreasing\n\n./gen -n 300 -type increasing\n\n./gen -n 300 -type mixed\n\n./gen -n 300 -type small\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:41:14.384254",
        "total_tutorials": 0,
        "has_ai_judgment": false,
        "has_code_files": true
      }
    },
    {
      "problem_id": "509/D",
      "title": "D. Restoring Numbers",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains integers n and m (1 ≤ n, m ≤ 100), separated by a space — the number of rows and columns in the found matrix, respectively. The i-th of the following lines contains numbers wi, 1, wi, 2, ..., wi, m (0 ≤ wi, j ≤ 109), separated by spaces — the elements of the i-th row of matrix w.",
      "output_spec": "OutputIf the matrix w could not have been obtained in the manner described above, print \"NO\" (without quotes) in the single line of output.Otherwise, print four lines.In the first line print \"YES\" (without quotes).In the second line print an integer k (1 ≤ k ≤ 1018). Note that each element of table w should be in range between 0 and k - 1 inclusively.In the third line print n integers a1, a2, ..., an (0 ≤ ai ≤ 1018), separated by spaces.In the fourth line print m integers b1, b2, ..., bm (0 ≤ bi ≤ 1018), separated by spaces.",
      "sample_tests": "ExamplesInputCopy2 31 2 32 3 4OutputCopyYES10000000070 1 1 2 3 InputCopy2 21 22 0OutputCopyYES30 1 1 2 InputCopy2 21 22 1OutputCopyNO",
      "description": "D. Restoring Numbers\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains integers n and m (1 ≤ n, m ≤ 100), separated by a space — the number of rows and columns in the found matrix, respectively. The i-th of the following lines contains numbers wi, 1, wi, 2, ..., wi, m (0 ≤ wi, j ≤ 109), separated by spaces — the elements of the i-th row of matrix w.\n\nOutputIf the matrix w could not have been obtained in the manner described above, print \"NO\" (without quotes) in the single line of output.Otherwise, print four lines.In the first line print \"YES\" (without quotes).In the second line print an integer k (1 ≤ k ≤ 1018). Note that each element of table w should be in range between 0 and k - 1 inclusively.In the third line print n integers a1, a2, ..., an (0 ≤ ai ≤ 1018), separated by spaces.In the fourth line print m integers b1, b2, ..., bm (0 ≤ bi ≤ 1018), separated by spaces.\n\nInputCopy2 31 2 32 3 4OutputCopyYES10000000070 1 1 2 3 InputCopy2 21 22 0OutputCopyYES30 1 1 2 InputCopy2 21 22 1OutputCopyNO\n\nInputCopy2 31 2 32 3 4\n\nOutputCopyYES10000000070 1 1 2 3\n\nInputCopy2 21 22 0\n\nOutputCopyYES30 1 1 2\n\nInputCopy2 21 22 1\n\nOutputCopyNO\n\nNoteBy  we denote the remainder of integer division of b by c.It is guaranteed that if there exists some set of numbers k, a1, ..., an, b1, ..., bm, that you could use to make matrix w, then there also exists a set of numbers that meets the limits 1 ≤ k ≤ 1018, 1 ≤ ai ≤ 1018, 1 ≤ bi ≤ 1018 in the output format. In other words, these upper bounds are introduced only for checking convenience purposes.",
      "solutions": [
        {
          "title": "Codeforces Round #289 (Div. 2) + qualifying round for the WCC - Codeforces",
          "content": "Hello, Codeforces! I'd like to invite you to Codeforces Round #289 (Div. 2). It'll be held on Saturday, January 31 at 15:00 MSK and as usual Div. 1 participants can take part out of competition.This round will be carried out according to the ACM rules, which means that you get verdict of your solution on-line, and the duration time is 3 hours.These differences in the rules are caused by the fact that this round is the second qualifying round for the WCC, which stands for Winter Computer Camp and can be also mentioned as ZKSH. Official school website — hhttp://it-edu.mipt.ru/en/zksh2015. There you can find the selection rules for WCC.If you are a school student and you want to participate in the selection to WCC here are the steps: Sign up for the school at http://goo.gl/kz2qSf, if it was not done earlier. Create a free account at codeforces.com, if it was not done earlier. Sign up for the round on the link http://codeforces.com/contestRegistration/509. You should put a tick in the box \"Do you want to participate in the selection to WCC?\", and provide your last name, first name and email, which you entered for registration in the first step. If you have any questions feel free to write to the address of the organizing committee: zksh-team@phystech.edu.The authors of the contest (WCC technical committee) are really grateful to Max Akhmedov (Zlobober) for the help with preparation of this round, Maria Belova (Delinur) for translation of statements and Mike Mirzayanov (MikeMirzayanov) for contribution to the development of programming by creating systems Codeforces and Polygon.UPD. Tutorial — http://codeforces.com/blog/entry/16119",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/16083",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.6,
            "reason": "宽松匹配: 包含题目编号 509 和字母"
          },
          "content_length": 1654
        },
        {
          "title": "Tutorial CodeForces Round 289 (Div.2) (Second Winter Computer Camp Selection 2015) - Codeforces",
          "content": "509A - Maximum in TableIn this problem one needed to implement what was written in the statement: create matrix (two-dimensional array) using given rules and find maximal value in the table.It is also possible to see that maximal element is always in bottom-right corner.Easier solution with recursion also was enough to get AC: def elem(row, col):\n if row == 1 or col == 1:\n return 1\n return elem(row - 1, col) + elem(row, col - 1)One may see the Pascal's triangle in the given matrix and understand that answer is equal to Prepared by: riadwawAuthor of editorial: riadwaw509B - Painting PebblesSuppose there are two piles with number of pebbles differed by more than k, then there is no solution:Now let M = max ai ≤ min ai + k = m + k.There's a way to construct correct coloring: Chose m peebles from each pile and assign first color to them. In each pile assign different colors to all other pebbles (you may use first color once more) (It's possible bacause there are no more than k uncolored pebbles. Now there are m or m + 1 pebbles of first color and 0 or 1 pebbles of any other color in each pile.Prepared by: KostromaAuthor of editorial: riadwaw509C - Sums of DigitsThe algorithm is greedy: first, take the minimal number with sum of digits a1 — call it b1. Then, on the i-th step take bi as the minimal number with sum of digits ai, which is more than bi - 1. It can be easily proven that this algorithm gives an optimal answer. But how to solve the subproblem: given x and y, find the minimal number with sum of digits x, which is more than y? We use a standard approach: iterate through the digits of y from right to left, trying to increase the current digit and somehow change the digits to the right in order to reach the sum of digits equal to x. Note that if we are considering the (k + 1)-th digit from the right and increase it, we can make the sum of k least significant digits to be any number between 0 and 9k. When we find such position, that increasing a digit in it and changing the least significant digits gives us a number with sum of digits x, we stop the process and obtain the answer. Note that if k least significant digits should have sum m (where 0 ≤ m ≤ 9k), we should obtain the answer greedily, going from the right to the left and putting to the position the largest digit we can. Let us bound the maximal length of the answer, i.e. of bn. If some bi has at least 40 digits, than we take the minimal k such that 10k ≥ bi. Than between 10k and 10k + 1 there exist numbers with any sum of digits between 1 and 9k. If k ≥ 40, than 9k ≥ 300, which is the upper bound of all bi. So, in the constraints of the problem, bi + 1 will be less than 10k + 1. Than, similarly, bi + 2 < 10k + 2 and so on. So, the length of the answer increases by no more than one after reaching the length of 40. Consequently, the maximal length of the answer can't be more than 340. The complexity of solution is O(n·maxLen). Since n ≤ 300, maxLen ≤ 340, the solution runs much faster the time limit.Prepared by: EndagorionAuthor of editorial: Kostroma509D - Restoring NumbersFirst we note that if the sequences ai and bi are a valid solution, then so are the sequences ai - P and bi + P for any integer P. This means that we can consider a1 to be equal to 0 which allows us to recover the sequence bi by simply taking the first row of the matrix. Knowing bi we can also recover ai (for example by subtracting b1 from the first column of the matrix) At this stage we allow ai and bi to contain negative numbers, which can be later fixed by adding K a sufficient amount of times. Now we consider the “error” matrix e: .If e consists entirely of 0s, then we’ve found our solution by taking a sufficiently large K. That is: K > maxi, j(wi, j).Otherwise, we note that ei, j = 0(modK) which implies that K is a divisor of g = gcdi, j(ei, j). The greatest such number is g itself, so all that remains is to check if g is strictly greater than all the elements of the matrix w. If that is the case, then we’ve found our solution by setting K = g. Otherwise, there’s no solution.Prepared by: Kostroma, riadwawAuthor of editorial: riadwaw509E - Pretty SongWe first calculate the prefix sums of vowel(si) which allows to calculate the sum of vowel(si) on any substring in O(1) time.For all m from 1 to , we will calculate the sum of simple pretinesses of all substrings of that length, let’s call it SPm. For that purpose, let’s calculate the number of times the i-th character of the string s is included in this sum. For m = 1 and m = |s|, every character is included exactly 1 time. For m = 2 and m = |s| - 1, the first and the last character are included 1 time and all other characters are included 2 times. For m = 3 and m = |s| - 2 the first and the last character are included 1 time, the second and the pre-last character are included 2 times and all others are included 3 times, and so on.In general, the i-th character is included min(m, |s| - m + 1, i, |s| — i + 1) times. Note that when moving from substrings of length m to substrings of length m + 1, there are 2 ways in which the sum SP can change: If m > |s| - m + 1, then SP is decreased by the number of vowel occurrences in the substring from |s| - m + 1 to m. Otherwise, SP is increased by the number of vowel occurrences in the substring from m to |s| - m + 1. This way we can easily recalculate SPm + 1 using SPm by adding (subtracting) the number of vowel occurrences on a substring (which is done in O(1) time). The complexity of this solution is O(N).Prepared by: zemenAuthor of editorial: zemen509F - Progress MonitoringConsider a tree with n vertices rooted at vertex 1 and let b be the pseudocode’s (DFS) resulting sequence. Then b[lv..lv + sizev - 1], represents vertex v’s subtree, where lv is the index of v in b and sizev is the size of $v$’s subtree.Let’s solve the problem using this fact and Dynamic Programming. Let e[l, r] be the number of trees consisting of vertices a[l], a[l + 1], …, a[r] such that running DFS starting from a[l] will result in a sequence with vertices in the same order as their order in a. The base case is when l = r and e[l, r] = 1. Otherwise, where the sum is taken over all partitions of the segment [l + 1, r], that is, over all k;pos1, ..., posk + 1, such that l + 1 = pos1 < pos2 < ... < posk + 1 = r, 1 ≤ k ≤ r - l, a[pos1] < a[pos2] < ... < a[posk]. Each such partition represents a different way to distribute the vertices among a[l]’s children’s subtrees. A solution using this formula for calculating e[l, r] will have an exponential running time.The final idea is to introduce d[l, r]:  = e[l - 1, r], 2 ≤ l ≤ r ≤ n. It follows that: d[l, r] = ([statement] is equal to 1 if the statement is true, 0 otherwise) and e[l, r] = d[l + 1, r]. This way d[l, r] and e[l, r] can be calculated in linear time for any segment [l, r]. The answer to the problem is e[1, n]. Overall complexity is O(n3).Prepared by: DPR-pavlinAuthor of editorial: DPR-pavlin",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/16119",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 509\\s*D"
          },
          "content_length": 6968
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #289 (Div. 2) + qualifying round for the WCC - Codeforces - Code 1",
          "code": "FOR(K, 0, 102) {\n   if(abs(c1[K]- c2[K]) > 1) {\n     f = false;\n     break;\n   }\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16083",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #289 (Div. 2) + qualifying round for the WCC - Codeforces - Code 2",
          "code": "FOR(K, 0, 102) {\n   if(abs(c1[K]- c2[K]) > 1) {\n     f = false;\n     break;\n   }\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16083",
          "author": "jiangly"
        },
        {
          "title": "Tutorial CodeForces Round 289 (Div.2) (Second Winter Computer Camp Selection 2015) - Codeforces - Code 1",
          "code": "def elem(row, col):\n    if row == 1 or col == 1:\n        return 1\n    return elem(row - 1, col) + elem(row, col - 1)",
          "language": "Python",
          "source": "https://codeforces.com/blog/entry/16119",
          "author": "jiangly"
        },
        {
          "title": "Tutorial CodeForces Round 289 (Div.2) (Second Winter Computer Camp Selection 2015) - Codeforces - Code 2",
          "code": "def elem(row, col):\n    if row == 1 or col == 1:\n        return 1\n    return elem(row - 1, col) + elem(row, col - 1)",
          "language": "Python",
          "source": "https://codeforces.com/blog/entry/16119",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 100, \"m\");\n    inf.readEoln();\n\n    for (int i = 0; i < n; ++i) {\n        vector<int> w = inf.readInts(m, 0, 1000000000, \"wi_j\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 100, \"m\");\n    inf.readEoln();\n\n    for (int i = 0; i < n; ++i) {\n        vector<int> w = inf.readInts(m, 0, 1000000000, \"wi_j\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 100, \"m\");\n    inf.readEoln();\n\n    for (int i = 0; i < n; ++i) {\n        vector<int> w = inf.readInts(m, 0, 1000000000, \"wi_j\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <vector>\n#include <string>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerTestlibCmd(argc, argv);\n\n    // Read input data from the input file\n    int n = inf.readInt(1, 100);\n    int m = inf.readInt(1, 100);\n    vector< vector<int> > w(n, vector<int>(m));\n\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < m; ++j) {\n            w[i][j] = inf.readInt(0, 1000000000);\n        }\n    }\n\n    // Read jury's answer (correct answer)\n    string juryAnswer = ans.readWord();\n    if (juryAnswer != \"YES\" && juryAnswer != \"NO\") {\n        ans.quitf(_fail, \"Jury's answer is neither 'YES' nor 'NO'\");\n    }\n\n    // Read participant's answer\n    string participantAnswer = ouf.readWord();\n    if (participantAnswer != \"YES\" && participantAnswer != \"NO\") {\n        ouf.quitf(_wa, \"Your answer is neither 'YES' nor 'NO'\");\n    }\n\n    if (juryAnswer == \"NO\") {\n        if (participantAnswer == \"NO\") {\n            // Both the jury and participant agree that there is no solution\n            quitf(_ok, \"Correct - both answers are NO\");\n        } else {\n            // Participant claims a solution exists when the jury says none exists\n            ouf.quitf(_wa, \"Participant found a solution but jury says none exists\");\n        }\n    } else {\n        // Jury's answer is \"YES\"\n        if (participantAnswer == \"NO\") {\n            // Participant claims no solution exists when the jury found one\n            ouf.quitf(_wa, \"Participant says NO but jury found a solution\");\n        } else {\n            // Both answers are \"YES\"\n            // Read participant's k\n            long long k = ouf.readLong(1LL, 1000000000000000000LL, \"k\");\n\n            // Read participant's ai's\n            vector<long long> ai = ouf.readLongs(n, 0LL, 1000000000000000000LL, \"ai[]\");\n\n            // Read participant's bj's\n            vector<long long> bj = ouf.readLongs(m, 0LL, 1000000000000000000LL, \"bj[]\");\n\n            // Check that each element w[i][j] == (ai[i] + bj[j]) % k\n            for (int i = 0; i < n; ++i) {\n                for (int j = 0; j < m; ++j) {\n                    long long expected = (ai[i] + bj[j]) % k;\n                    if (expected != w[i][j]) {\n                        ouf.quitf(_wa, \"Element w[%d][%d]=%d does not match (a[%d] + b[%d]) mod k = (%lld + %lld) mod %lld = %lld\", \n                                  i+1, j+1, w[i][j], i+1, j+1, ai[i], bj[j], k, expected);\n                    }\n                }\n            }\n            // Participant's solution is correct\n            quitf(_ok, \"Correct solution\");\n        }\n    }\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string type = opt<string>(\"type\");\n\n    if (type == \"possible_random\") {\n        // Generate random k\n        long long k = rnd.next(1LL, (long long)1e18);\n\n        vector<long long> a(n);\n        vector<long long> b(m);\n\n        // Generate random a_i and b_j in [0, k-1]\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(0LL, k - 1);\n        }\n        for (int j = 0; j < m; ++j) {\n            b[j] = rnd.next(0LL, k - 1);\n        }\n\n        // Compute w_{i,j}\n        vector<vector<long long>> w(n, vector<long long>(m));\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < m; ++j) {\n                w[i][j] = (a[i] + b[j]) % k;\n            }\n        }\n\n        // Output n m\n        printf(\"%d %d\\n\", n, m);\n        // Output w\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < m; ++j) {\n                printf(\"%lld%c\", w[i][j], j + 1 == m ? '\\n' : ' ');\n            }\n        }\n\n    } else if (type == \"possible_special\") {\n        string subtype = opt<string>(\"subtype\");\n        long long k;\n        vector<long long> a(n);\n        vector<long long> b(m);\n\n        if (subtype == \"k_min\") {\n            k = 1;\n            // All a_i and b_j are 0\n            for (int i = 0; i < n; ++i) a[i] = 0;\n            for (int j = 0; j < m; ++j) b[j] = 0;\n        } else if (subtype == \"k_max\") {\n            k = (long long)1e18;\n            // Generate random a_i and b_j in [0, k-1]\n            for (int i = 0; i < n; ++i) a[i] = rnd.next(0LL, k - 1);\n            for (int j = 0; j < m; ++j) b[j] = rnd.next(0LL, k - 1);\n        } else if (subtype == \"a_zero\") {\n            k = rnd.next(1LL, (long long)1e18);\n            for (int i = 0; i < n; ++i) a[i] = 0;\n            for(int j = 0; j < m; ++j) b[j] = rnd.next(0LL, k -1);\n        } else if (subtype == \"b_zero\") {\n            k = rnd.next(1LL, (long long)1e18);\n            for (int i = 0; i < n; ++i) a[i] = rnd.next(0LL, k - 1);\n            for(int j = 0; j < m; ++j) b[j] = 0;\n        } else {\n            // Default to random if subtype is unknown\n            k = rnd.next(1LL, (long long)1e18);\n            for (int i = 0; i < n; ++i) a[i] = rnd.next(0LL, k - 1);\n            for (int j = 0; j < m; ++j) b[j] = rnd.next(0LL, k - 1);\n        }\n\n        // Compute w\n        vector<vector<long long>> w(n, vector<long long>(m));\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < m; ++j) {\n                w[i][j] = (a[i] + b[j]) % k;\n            }\n        }\n\n        // Output n m\n        printf(\"%d %d\\n\", n, m);\n        // Output w\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < m; ++j) {\n                printf(\"%lld%c\", w[i][j], j + 1 == m ? '\\n' : ' ');\n            }\n        }\n\n    } else if (type == \"impossible_random\") {\n        // Random w_{i,j}\n        vector<vector<long long>> w(n, vector<long long>(m));\n\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < m; ++j) {\n                w[i][j] = rnd.next(0LL, (long long)1e9);\n            }\n        }\n\n        // Output n m\n        printf(\"%d %d\\n\", n, m);\n        // Output w\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < m; ++j) {\n                printf(\"%lld%c\", w[i][j], j + 1 == m ? '\\n' : ' ');\n            }\n        }\n    } else if (type == \"impossible_special\") {\n        vector<vector<long long>> w(n, vector<long long>(m));\n        if (n >= 2 && m >= 2) {\n            w[0][0] = 0;\n            w[0][1] = 1;\n            w[1][0] = 1;\n            w[1][1] = 0;\n            // Fill the rest with random values\n            for (int i = 0; i < n; ++i) {\n                for (int j = 0; j < m; ++j) {\n                    if (i >= 2 || j >= 2) {\n                        w[i][j] = rnd.next(0LL, (long long)1e9);\n                    }\n                }\n            }\n        } else {\n            // If dimensions are too small, fill randomly\n            for (int i = 0; i < n; ++i) {\n                for (int j = 0; j < m; ++j) {\n                    w[i][j] = rnd.next(0LL, (long long)1e9);\n                }\n            }\n        }\n        // Output n m\n        printf(\"%d %d\\n\", n, m);\n        // Output w\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < m; ++j) {\n                printf(\"%lld%c\", w[i][j], j + 1 == m ? '\\n' : ' ');\n            }\n        }\n    }\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string type = opt<string>(\"type\");\n\n    if (type == \"possible_random\") {\n        // Generate random k\n        long long k = rnd.next(1LL, (long long)1e18);\n\n        vector<long long> a(n);\n        vector<long long> b(m);\n\n        // Generate random a_i and b_j in [0, k-1]\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(0LL, k - 1);\n        }\n        for (int j = 0; j < m; ++j) {\n            b[j] = rnd.next(0LL, k - 1);\n        }\n\n        // Compute w_{i,j}\n        vector<vector<long long>> w(n, vector<long long>(m));\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < m; ++j) {\n                w[i][j] = (a[i] + b[j]) % k;\n            }\n        }\n\n        // Output n m\n        printf(\"%d %d\\n\", n, m);\n        // Output w\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < m; ++j) {\n                printf(\"%lld%c\", w[i][j], j + 1 == m ? '\\n' : ' ');\n            }\n        }\n\n    } else if (type == \"possible_special\") {\n        string subtype = opt<string>(\"subtype\");\n        long long k;\n        vector<long long> a(n);\n        vector<long long> b(m);\n\n        if (subtype == \"k_min\") {\n            k = 1;\n            // All a_i and b_j are 0\n            for (int i = 0; i < n; ++i) a[i] = 0;\n            for (int j = 0; j < m; ++j) b[j] = 0;\n        } else if (subtype == \"k_max\") {\n            k = (long long)1e18;\n            // Generate random a_i and b_j in [0, k-1]\n            for (int i = 0; i < n; ++i) a[i] = rnd.next(0LL, k - 1);\n            for (int j = 0; j < m; ++j) b[j] = rnd.next(0LL, k - 1);\n        } else if (subtype == \"a_zero\") {\n            k = rnd.next(1LL, (long long)1e18);\n            for (int i = 0; i < n; ++i) a[i] = 0;\n            for(int j = 0; j < m; ++j) b[j] = rnd.next(0LL, k -1);\n        } else if (subtype == \"b_zero\") {\n            k = rnd.next(1LL, (long long)1e18);\n            for (int i = 0; i < n; ++i) a[i] = rnd.next(0LL, k - 1);\n            for(int j = 0; j < m; ++j) b[j] = 0;\n        } else {\n            // Default to random if subtype is unknown\n            k = rnd.next(1LL, (long long)1e18);\n            for (int i = 0; i < n; ++i) a[i] = rnd.next(0LL, k - 1);\n            for (int j = 0; j < m; ++j) b[j] = rnd.next(0LL, k - 1);\n        }\n\n        // Compute w\n        vector<vector<long long>> w(n, vector<long long>(m));\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < m; ++j) {\n                w[i][j] = (a[i] + b[j]) % k;\n            }\n        }\n\n        // Output n m\n        printf(\"%d %d\\n\", n, m);\n        // Output w\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < m; ++j) {\n                printf(\"%lld%c\", w[i][j], j + 1 == m ? '\\n' : ' ');\n            }\n        }\n\n    } else if (type == \"impossible_random\") {\n        // Random w_{i,j}\n        vector<vector<long long>> w(n, vector<long long>(m));\n\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < m; ++j) {\n                w[i][j] = rnd.next(0LL, (long long)1e9);\n            }\n        }\n\n        // Output n m\n        printf(\"%d %d\\n\", n, m);\n        // Output w\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < m; ++j) {\n                printf(\"%lld%c\", w[i][j], j + 1 == m ? '\\n' : ' ');\n            }\n        }\n    } else if (type == \"impossible_special\") {\n        vector<vector<long long>> w(n, vector<long long>(m));\n        if (n >= 2 && m >= 2) {\n            w[0][0] = 0;\n            w[0][1] = 1;\n            w[1][0] = 1;\n            w[1][1] = 0;\n            // Fill the rest with random values\n            for (int i = 0; i < n; ++i) {\n                for (int j = 0; j < m; ++j) {\n                    if (i >= 2 || j >= 2) {\n                        w[i][j] = rnd.next(0LL, (long long)1e9);\n                    }\n                }\n            }\n        } else {\n            // If dimensions are too small, fill randomly\n            for (int i = 0; i < n; ++i) {\n                for (int j = 0; j < m; ++j) {\n                    w[i][j] = rnd.next(0LL, (long long)1e9);\n                }\n            }\n        }\n        // Output n m\n        printf(\"%d %d\\n\", n, m);\n        // Output w\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < m; ++j) {\n                printf(\"%lld%c\", w[i][j], j + 1 == m ? '\\n' : ' ');\n            }\n        }\n    }\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Possible random matrices with various sizes\n./gen -n 1 -m 1 -type possible_random\n./gen -n 10 -m 10 -type possible_random\n./gen -n 50 -m 50 -type possible_random\n./gen -n 100 -m 100 -type possible_random\n\n# Possible special cases\n./gen -n 5 -m 5 -type possible_special -subtype k_min\n./gen -n 5 -m 5 -type possible_special -subtype k_max\n./gen -n 5 -m 5 -type possible_special -subtype a_zero\n./gen -n 5 -m 5 -type possible_special -subtype b_zero\n\n./gen -n 100 -m 100 -type possible_special -subtype k_min\n./gen -n 100 -m 100 -type possible_special -subtype k_max\n./gen -n 100 -m 100 -type possible_special -subtype a_zero\n./gen -n 100 -m 100 -type possible_special -subtype b_zero\n\n# Impossible random matrices with various sizes\n./gen -n 1 -m 1 -type impossible_random\n./gen -n 10 -m 10 -type impossible_random\n./gen -n 50 -m 50 -type impossible_random\n./gen -n 100 -m 100 -type impossible_random\n\n# Impossible special cases\n./gen -n 2 -m 2 -type impossible_special\n./gen -n 3 -m 3 -type impossible_special\n./gen -n 5 -m 5 -type impossible_special\n./gen -n 100 -m 100 -type impossible_special\n\n# Edge cases with small dimensions\n./gen -n 1 -m 100 -type possible_random\n./gen -n 100 -m 1 -type possible_random\n\n./gen -n 1 -m 100 -type impossible_random\n./gen -n 100 -m 1 -type impossible_random\n\n# Edge cases with maximum values\n./gen -n 1 -m 1 -type possible_special -subtype k_max\n./gen -n 1 -m 1 -type possible_special -subtype k_min\n\n# Mixed special cases\n./gen -n 2 -m 2 -type possible_special -subtype a_zero\n./gen -n 2 -m 2 -type possible_special -subtype b_zero\n\n# Large random possible matrices\n./gen -n 100 -m 100 -type possible_random\n./gen -n 100 -m 50 -type possible_random\n./gen -n 50 -m 100 -type possible_random\n\n# Large random impossible matrices\n./gen -n 100 -m 100 -type impossible_random\n./gen -n 100 -m 50 -type impossible_random\n./gen -n 50 -m 100 -type impossible_random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:41:16.483464",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "509/E",
      "title": "E. Мелодичная песня",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест1 секунда",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеНа ввод подаётся единственная строка s (1 ≤ |s| ≤ 5·105) — название песни.",
      "output_spec": "Выходные данныеОпределите мелодичность песни с абсолютной или относительной погрешностью не более 10 - 6.",
      "sample_tests": "ПримерыВходные данныеСкопироватьIEAIAIOВыходные данныеСкопировать28.0000000Входные данныеСкопироватьBYOBВыходные данныеСкопировать5.8333333Входные данныеСкопироватьYISVOWELВыходные данныеСкопировать17.0500000",
      "description": "E. Мелодичная песня\n\nограничение по времени на тест1 секунда\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвыводstdout\n\nВходные данныеНа ввод подаётся единственная строка s (1 ≤ |s| ≤ 5·105) — название песни.\n\nВходные данные\n\nВыходные данныеОпределите мелодичность песни с абсолютной или относительной погрешностью не более 10 - 6.\n\nВыходные данные\n\nВходные данныеСкопироватьIEAIAIOВыходные данныеСкопировать28.0000000Входные данныеСкопироватьBYOBВыходные данныеСкопировать5.8333333Входные данныеСкопироватьYISVOWELВыходные данныеСкопировать17.0500000\n\nВходные данныеСкопироватьIEAIAIO\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать28.0000000\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопироватьBYOB\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать5.8333333\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопироватьYISVOWEL\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать17.0500000\n\nВыходные данныеСкопировать\n\nСкопировать\n\nПримечаниеВ первом примере все буквы — гласные. Простая мелодичность каждой подстроки равна 1.Всего в слове длины 7 имеется 28 подстрок. Значит, мелодичность песни равна 28.",
      "solutions": [
        {
          "title": "Codeforces Round #289 (Div. 2) + отборочный раунд на ЗКШ - Codeforces",
          "content": "Привет, Codeforces!31 января в 15:00 MSK состоится раунд #289 для участников из второго дивизиона. Традиционно, участники из первого дивизиона могут участвовать в соревновании вне конкурса.Этот раунд отличается от остальных тем, что он будет проведен по правилам АСМ, то есть результаты проверки на всех тестах вы получаете в режиме онлайн, а его продолжительность составит 3 часа. Данные отличия в правилах вызваны тем, что этот раунд является вторым отборочным раундом в ЗКШ. Официальный сайт школы — http://it-edu.mipt.ru/zksh2015. Там же вы можете найти правила отбора на ЗКШ.Алгоритм действий для школьника, желающего поучаствовать в отборе на ЗКШ (вне зависимости от дивизиона): Зарегистрироваться на школу по ссылке http://goo.gl/kz2qSf, если это не было сделано ранее. Зарегистрироваться на сайте codeforces.ru, если это не было сделано ранее. Зарегистрироваться на раунд по ссылке http://codeforces.com/contestRegistration/509. При регистрации требуется поставить галочку в поле \"Хотите ли вы участвовать в отборе на ЗКШ?\", а также указать фамилию, имя, отчество и email, которые вы указали при регистрации на школу в пункте №1. По всем возникающим вопросам пишите на адрес оргкомитета: zksh-team@phystech.edu.В заключение, наш коллектив авторов (тех. комитет ЗКШ) выражает свою благодарность Максиму Ахмедову (Zlobober) за помощь в подготовке задач, Марии Беловой (Delinur) за перевод условий на английский, Михаилу Мирзаянову (MikeMirzayanov) за вклад в развитие программирования путем создания систем Codeforces и Polygon.",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/16083",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.5,
            "reason": "宽松匹配: 包含题目编号 509"
          },
          "content_length": 1534
        },
        {
          "title": "Разбор CodeForces Round 289 (Div.2) (Второй отборочный тур ЗКШ 2015) - Codeforces",
          "content": "509A - Максимум в таблицеВ этой задаче нужно было сделать то, что написано в условии: построить таблицу(двумерный массив) по указанным правилам и найти максимум в таблице.Можно было заметить также, что максимальный элемент находится в правом нижнем углу.Также проходило и просто решение рекурсией: def elem(row, col):\n if row == 1 or col == 1:\n return 1\n return elem(row - 1, col) + elem(row, col - 1)Кроме того, можно было заметить в таблице Треугольник Паскаля и понять, что ответ — это Готовил: riadwawРазбор от: riadwaw509B - Раскраска шаровПусть найдутся две кучки, в которых количество камней отличается строго больше чем на k, тогда решения не существует:Пусть теперь M = max ai ≤ min ai + k = m + k, покажем, как построить правильную раскраску: покрасим по m камней в каждой кучке в первый цвет в каждой кучке все оставшиеся камни покрасим в любые различные цвета(можно использовать первый еще один раз) (это можно сделать т.к осталось не более k камней. Заметим, что 1-ый цвет встречается в каждой кучке m или m + 1 раз, а остальные цвета — 0 или 1 разГотовил: KostromaРазбор от: riadwaw509C - Суммы цифрБудем действовать жадно. На первом шаге найдём минимальное число b1 с суммой цифр a1. Далее, на i-м шаге найдём минимальное число bi с суммой цифр ai, которое больше чем bi - 1. Почему это правильно? Поскольку b1 — минимальное число с суммой цифрой a1, то первое число не меньше чем b1. Далее по индукции: i-е число не меньше bi, поэтому (i + 1)-е число должно иметь сумму цифр ai + 1 и быть больше чем bi. Но минимальное такое число как раз bi + 1. Значит, построенный пример даёт оптимальное решение задачи. Осталось научиться решать подзадачу: найти минимальное число с суммой цифр x, которое больше y. Она решается стандартным подходом: идем по цифрам числа y с младших разрядов и пытаемся увеличить соответствующую цифру (считаем, что каждое число содержит бесконечно много нулей слева от своей старшей цифры). Пусть справа осталось k цифр, тогда сумма этих k цифр может быть любым натуральным числом от 0 до 9k. Если получилось увеличить текущую цифру так, что при каком-то выборе цифр справа от неё получилась сумма x, то мы получили ответ. Заметим, что цифры справа от текущей позиции в таком случае нужно заполнять жадно с младших разрядов, каждый раз используя максимально возможную цифру — таким образом мы действительно получим минимальный ответ.Оценим максимальную длину ответа, т.е. числа bn. Заметим, что если длина десятичной записи bi хотя бы 40, то в промежутке между 10k и 10k + 1, где k — наименьшее натуральное число, такое что 10k ≥ bi, есть числа со всеми суммами цифр от 1 до 9k. Так как все ai ≤ 300, то при в отрезке [10k, 10k + 1] есть любая из интересующих нас сумм цифр. Значит, при достижении 40-значного числа на каждом шаге количество цифр в десятичной записи bi увеличивается не более чем на 2, а значит итоговый ответ будет иметь десятичную записать не длиннее 640 цифр (еще немного подумав, можно понять, что эту оценку можно усилить до 340).Значит, получаем решение за O(n·maxLen), где maxLen — максимальная длина ответа. Поскольку n ≤ 300, maxLen ≤ 640, такое решение с запасом проходит.Готовил: EndagorionРазбор от: Kostroma509D - Восстановление чиселЗаметим, что если в корректном ответе ко всем bi добавить 1, а из всех ai вычесть 1 (и при необходимости добавив k), то ответ останется корректным. поэтому можно считать, что ai = 0, тогда из первой строки однозначно восстанавливаются bj, а по ним — ai (Можно пока разрешить им быть отрицательными, а потом добавить нужное число раз k). Теперь для любых i, j мы можем найти \"ошибку\" .Если все ошибки нулевые — всё отлично, возьмем k достаточно большим и ответ будет автоматически корректным.Для того, чтобы не нарушалось условие в клетке (i, j) необходимо и достаточно, чтобы ei, j делилось на k. Таким образом, k должно быть делителем gcdi, j(ei, j). При этом, k должно быть строго больше, чем все числа в таблице. Таким образом выгодно попытаться поставить k = gcdi, j(ei, j), что можно сделать, если k > maxi, j(wi, j). В противном случае ответа не существует.Готовили: Kostroma, riadwawРазбор от: riadwaw509E - Мелодичная песняПосчитаем суммы vowel(si) на всех префиксах строки, чтобы за O(1) можно было легко посчитать сумму vowel(si) на любой подстроке.Будем перебирать m с 1 до . При фиксированном m найдем сумму простых мелодичностей всех подстрок длины m. Для этого посмотрим, сколько раз i-й символ s входит в эту сумму.При m = 1 каждый символ входит ровно один раз. При m = 2 все символы, кроме крайних — 2 раза, крайние 1 раз. При m = 3 все 3 раза, кроме второго и предпоследнего(2 раза) и первого и последнего (1 раз).При m = |s| каждый символ входит один раз, как и в случае m = 1, а при m = |s| - 1— 2 раза кроме крайних, как и в случае m = 2.В общем случае, i-й символ входит min(m, |s| - m + 1, i, |s| — i + 1) раз. Можно заметить, что при переходе от m к m + 1 к сумме прибавляются вхождения символов на подотрезке с m по |s| - m + 1(если m > |s| - m + 1, то убавляются на подотрезке с |s| - m + 1 по m).Таким образом, можно легко пересчитать сумму вхождений гласных при переходе от m к m + 1, прибавив(убавив) сумму vowel на подстроке. Итоговое решение за O(N).Готовил: zemenРазбор от: zemen509F - Контроль успеваемостиРассмотрим произвольное дерево на n вершинах. Подвесим дерево за вершину 1, и пусть массив a — результат работы dfs-а. Тогда вершины поддерева с вершиной v, 1 ≤ v ≤ n, записаны в подмассив a[lv..lv + sizev - 1], где lv есть позиция вершины v в массиве, а sizev — размер поддерева.Решим задачу, используя сей факт и ДП на подотрезках. Пусть задан массив a, и пусть e[l, r] есть количество деревьев, составленных из вершин a[l], a[l + 1], ..., a[r], т.ч. dfs, запущенный из вершины a[l], выведет вершины в том же порядке, в котором они представлены в массиве a. Тогда, если l = r, то e[l, r] = 1; иначе , где сумма берется по всем возможным множествам детей a[l], т.е. по всем таким k;pos1, ..., posk + 1, что l + 1 = pos1 < pos2 < ... < posk + 1 = r + 1, 1 ≤ k ≤ r - l, a[pos1] < a[pos2] < ... < a[posk] (вспомним, что в dfs-е дети перебираются в порядке возрастания). Однако даже при наличии ответов для подотрезков отрезка [1..n] решение с использованием такой формулы будет работать экспоненциально долго.Финальная идея заключается во введении d[l, r]:  = e[l - 1, r], 2 ≤ l ≤ r ≤ n. Действительно, из вышеприведенной формулы следует, что d[l, r] = ([утверждение] определим как 1, если утверждение истинно, и 0, если ложно), а также e[l, r] = d[l + 1, r]. Таким образом, d[l, r] и e[l, r] для каждого отрезка вычисляются за линейное время; ответом же на задачу является e[1, n]. Итоговая асимптотика решения O(n3).Готовил: DPR-pavlinРазбор от: DPR-pavlin",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/16119",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 509\\s*E"
          },
          "content_length": 6696
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #289 (Div. 2) + отборочный раунд на ЗКШ - Codeforces - Code 1",
          "code": "FOR(K, 0, 102) {\n   if(abs(c1[K]- c2[K]) > 1) {\n     f = false;\n     break;\n   }\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16083",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #289 (Div. 2) + отборочный раунд на ЗКШ - Codeforces - Code 2",
          "code": "FOR(K, 0, 102) {\n   if(abs(c1[K]- c2[K]) > 1) {\n     f = false;\n     break;\n   }\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16083",
          "author": "Qingyu"
        },
        {
          "title": "Разбор CodeForces Round 289 (Div.2) (Второй отборочный тур ЗКШ 2015) - Codeforces - Code 1",
          "code": "def elem(row, col):\n    if row == 1 or col == 1:\n        return 1\n    return elem(row - 1, col) + elem(row, col - 1)",
          "language": "Python",
          "source": "https://codeforces.com/blog/entry/16119",
          "author": "Qingyu"
        },
        {
          "title": "Разбор CodeForces Round 289 (Div.2) (Второй отборочный тур ЗКШ 2015) - Codeforces - Code 2",
          "code": "def elem(row, col):\n    if row == 1 or col == 1:\n        return 1\n    return elem(row - 1, col) + elem(row, col - 1)",
          "language": "Python",
          "source": "https://codeforces.com/blog/entry/16119",
          "author": "Qingyu"
        },
        {
          "title": "Разбор CodeForces Round 289 (Div.2) (Второй отборочный тур ЗКШ 2015) - Codeforces - Code 3",
          "code": "Тогда, если l ≤ r, то e[l, r] = 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16119",
          "author": "Qingyu"
        },
        {
          "title": "Разбор CodeForces Round 289 (Div.2) (Второй отборочный тур ЗКШ 2015) - Codeforces - Code 4",
          "code": "d[l, r]:  = e[l - 1, n].",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16119",
          "author": "Qingyu"
        },
        {
          "title": "Разбор CodeForces Round 289 (Div.2) (Второй отборочный тур ЗКШ 2015) - Codeforces - Code 5",
          "code": "На первом шаге найдём минимальное число b1 с суммой цифр a1. Далее, на i-м шаге найдём минимальное число bi с суммой цифр ai, которое больше чем bi - 1.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16119",
          "author": "Qingyu"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    string s = inf.readLine(\"[A-Z]{1,500000}\", \"s\");\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    string s = inf.readLine(\"[A-Z]{1,500000}\", \"s\");\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    string s = inf.readLine(\"[A-Z]{1,500000}\", \"s\");\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nconst double EPS = 1E-6;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare two sequences of doubles, max absolute or relative  error = %.7f\", EPS);\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    double j = 0, p = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        n++;\r\n        j = ans.readDouble();\r\n        p = ouf.readDouble();\r\n        if (!doubleCompare(j, p, EPS)) {\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%.7f', found: '%.7f', error = '%.7f'\",\r\n                  n, englishEnding(n).c_str(), j, p, doubleDelta(j, p));\r\n        }\r\n    }\r\n\r\n    if (n == 1)\r\n        quitf(_ok, \"found '%.7f', expected '%.7f', error '%.7f'\", p, j, doubleDelta(j, p));\r\n\r\n    quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    string s(n, 'A'); // initialize as all 'A's\n\n    if (type == \"all_vowels\") {\n        // Fill with vowels\n        string vowels = \"IEAOUY\";\n        for (int i = 0; i < n; ++i) {\n            s[i] = vowels[rnd.next(0, 5)];\n        }\n    } else if (type == \"all_consonants\") {\n        // Fill with consonants\n        string consonants = \"BCDFGHJKLMNPQRSTVWXZ\"; // no Y\n        for (int i = 0; i < n; ++i) {\n            s[i] = consonants[rnd.next(0, (int)consonants.size()-1)];\n        }\n    } else if (type == \"random\") {\n        // Fill with random uppercase letters\n        for (int i = 0; i < n; ++i) {\n            s[i] = rnd.next('A', 'Z');\n        }\n    } else if (type == \"alternating\") {\n        string vowels = \"IEAOUY\";\n        string consonants = \"BCDFGHJKLMNPQRSTVWXZ\"; // no Y\n        for (int i = 0; i < n; ++i) {\n            if (i%2 == 0) {\n                s[i] = vowels[rnd.next(0, 5)];\n            } else {\n                s[i] = consonants[rnd.next(0, (int)consonants.size()-1)];\n            }\n        }\n    } else if (type == \"start_vowels\") {\n        int num_vowels = n/2;\n        int i = 0;\n        string vowels = \"IEAOUY\";\n        for (; i < num_vowels; ++i) {\n            s[i] = vowels[rnd.next(0, 5)];\n        }\n        string consonants = \"BCDFGHJKLMNPQRSTVWXZ\"; // no Y\n        for (; i < n; ++i) {\n            s[i] = consonants[rnd.next(0, (int)consonants.size()-1)];\n        }\n    } else if (type == \"end_vowels\") {\n        int num_vowels = n/2;\n        int i = 0;\n        string consonants = \"BCDFGHJKLMNPQRSTVWXZ\"; // no Y\n        for (; i < n - num_vowels; ++i) {\n            s[i] = consonants[rnd.next(0, (int)consonants.size()-1)];\n        }\n        string vowels = \"IEAOUY\";\n        for (; i < n; ++i) {\n            s[i] = vowels[rnd.next(0, 5)];\n        }\n    } else if (type == \"middle_vowels\") {\n        int middle_start = n/4;\n        int middle_end = n - n/4;\n        string consonants = \"BCDFGHJKLMNPQRSTVWXZ\"; // no Y\n        string vowels = \"IEAOUY\";\n        for (int i = 0; i < n; ++i) {\n            if (i >= middle_start && i < middle_end) {\n                s[i] = vowels[rnd.next(0, 5)];\n            } else {\n                s[i] = consonants[rnd.next(0, (int)consonants.size()-1)];\n            }\n        }\n    } else if (type == \"single_vowel\") {\n        int vowel_pos = rnd.next(0, n-1);\n        string consonants = \"BCDFGHJKLMNPQRSTVWXZ\"; // no Y\n        string vowels = \"IEAOUY\";\n        for (int i = 0; i < n; ++i) {\n            s[i] = consonants[rnd.next(0, (int)consonants.size()-1)];\n        }\n        s[vowel_pos] = vowels[rnd.next(0, 5)];\n    } else if (type == \"single_consonant\") {\n        int consonant_pos = rnd.next(0, n-1);\n        string consonants = \"BCDFGHJKLMNPQRSTVWXZ\"; // no Y\n        string vowels = \"IEAOUY\";\n        for (int i = 0; i < n; ++i) {\n            s[i] = vowels[rnd.next(0, 5)];\n        }\n        s[consonant_pos] = consonants[rnd.next(0, (int)consonants.size()-1)];\n    } else if (type == \"palindrome\") {\n        string vowels = \"IEAOUY\";\n        string consonants = \"BCDFGHJKLMNPQRSTVWXZ\"; // no Y\n        for (int i = 0; i < (n+1)/2; ++i) {\n            char c;\n            if (rnd.next(0,1) ==0) {\n                c = vowels[rnd.next(0,5)];\n            } else {\n                c = consonants[rnd.next(0,(int)consonants.size()-1)];\n            }\n            s[i] = c;\n            s[n - i -1] = c;\n        }\n    } else {\n        // default to random\n        for (int i = 0; i < n; ++i) {\n            s[i] = rnd.next('A', 'Z');\n        }\n    }\n\n    printf(\"%s\\n\", s.c_str());\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    string s(n, 'A'); // initialize as all 'A's\n\n    if (type == \"all_vowels\") {\n        // Fill with vowels\n        string vowels = \"IEAOUY\";\n        for (int i = 0; i < n; ++i) {\n            s[i] = vowels[rnd.next(0, 5)];\n        }\n    } else if (type == \"all_consonants\") {\n        // Fill with consonants\n        string consonants = \"BCDFGHJKLMNPQRSTVWXZ\"; // no Y\n        for (int i = 0; i < n; ++i) {\n            s[i] = consonants[rnd.next(0, (int)consonants.size()-1)];\n        }\n    } else if (type == \"random\") {\n        // Fill with random uppercase letters\n        for (int i = 0; i < n; ++i) {\n            s[i] = rnd.next('A', 'Z');\n        }\n    } else if (type == \"alternating\") {\n        string vowels = \"IEAOUY\";\n        string consonants = \"BCDFGHJKLMNPQRSTVWXZ\"; // no Y\n        for (int i = 0; i < n; ++i) {\n            if (i%2 == 0) {\n                s[i] = vowels[rnd.next(0, 5)];\n            } else {\n                s[i] = consonants[rnd.next(0, (int)consonants.size()-1)];\n            }\n        }\n    } else if (type == \"start_vowels\") {\n        int num_vowels = n/2;\n        int i = 0;\n        string vowels = \"IEAOUY\";\n        for (; i < num_vowels; ++i) {\n            s[i] = vowels[rnd.next(0, 5)];\n        }\n        string consonants = \"BCDFGHJKLMNPQRSTVWXZ\"; // no Y\n        for (; i < n; ++i) {\n            s[i] = consonants[rnd.next(0, (int)consonants.size()-1)];\n        }\n    } else if (type == \"end_vowels\") {\n        int num_vowels = n/2;\n        int i = 0;\n        string consonants = \"BCDFGHJKLMNPQRSTVWXZ\"; // no Y\n        for (; i < n - num_vowels; ++i) {\n            s[i] = consonants[rnd.next(0, (int)consonants.size()-1)];\n        }\n        string vowels = \"IEAOUY\";\n        for (; i < n; ++i) {\n            s[i] = vowels[rnd.next(0, 5)];\n        }\n    } else if (type == \"middle_vowels\") {\n        int middle_start = n/4;\n        int middle_end = n - n/4;\n        string consonants = \"BCDFGHJKLMNPQRSTVWXZ\"; // no Y\n        string vowels = \"IEAOUY\";\n        for (int i = 0; i < n; ++i) {\n            if (i >= middle_start && i < middle_end) {\n                s[i] = vowels[rnd.next(0, 5)];\n            } else {\n                s[i] = consonants[rnd.next(0, (int)consonants.size()-1)];\n            }\n        }\n    } else if (type == \"single_vowel\") {\n        int vowel_pos = rnd.next(0, n-1);\n        string consonants = \"BCDFGHJKLMNPQRSTVWXZ\"; // no Y\n        string vowels = \"IEAOUY\";\n        for (int i = 0; i < n; ++i) {\n            s[i] = consonants[rnd.next(0, (int)consonants.size()-1)];\n        }\n        s[vowel_pos] = vowels[rnd.next(0, 5)];\n    } else if (type == \"single_consonant\") {\n        int consonant_pos = rnd.next(0, n-1);\n        string consonants = \"BCDFGHJKLMNPQRSTVWXZ\"; // no Y\n        string vowels = \"IEAOUY\";\n        for (int i = 0; i < n; ++i) {\n            s[i] = vowels[rnd.next(0, 5)];\n        }\n        s[consonant_pos] = consonants[rnd.next(0, (int)consonants.size()-1)];\n    } else if (type == \"palindrome\") {\n        string vowels = \"IEAOUY\";\n        string consonants = \"BCDFGHJKLMNPQRSTVWXZ\"; // no Y\n        for (int i = 0; i < (n+1)/2; ++i) {\n            char c;\n            if (rnd.next(0,1) ==0) {\n                c = vowels[rnd.next(0,5)];\n            } else {\n                c = consonants[rnd.next(0,(int)consonants.size()-1)];\n            }\n            s[i] = c;\n            s[n - i -1] = c;\n        }\n    } else {\n        // default to random\n        for (int i = 0; i < n; ++i) {\n            s[i] = rnd.next('A', 'Z');\n        }\n    }\n\n    printf(\"%s\\n\", s.c_str());\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -type all_vowels\n./gen -n 1 -type all_consonants\n./gen -n 1 -type random\n./gen -n 1 -type alternating\n./gen -n 1 -type palindrome\n./gen -n 1 -type single_vowel\n./gen -n 1 -type single_consonant\n\n./gen -n 2 -type all_vowels\n./gen -n 2 -type all_consonants\n./gen -n 2 -type random\n./gen -n 2 -type alternating\n./gen -n 2 -type palindrome\n./gen -n 2 -type single_vowel\n./gen -n 2 -type single_consonant\n\n./gen -n 10 -type all_vowels\n./gen -n 10 -type all_consonants\n./gen -n 10 -type random\n./gen -n 10 -type alternating\n./gen -n 10 -type start_vowels\n./gen -n 10 -type end_vowels\n./gen -n 10 -type middle_vowels\n./gen -n 10 -type palindrome\n./gen -n 10 -type single_vowel\n./gen -n 10 -type single_consonant\n\n./gen -n 100 -type random\n./gen -n 1000 -type random\n./gen -n 500000 -type all_vowels\n./gen -n 500000 -type all_consonants\n./gen -n 500000 -type random\n./gen -n 500000 -type alternating\n./gen -n 500000 -type start_vowels\n./gen -n 500000 -type end_vowels\n./gen -n 500000 -type middle_vowels\n./gen -n 500000 -type palindrome\n./gen -n 500000 -type single_vowel\n./gen -n 500000 -type single_consonant\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:41:18.200108",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "509/F",
      "title": "F. Progress Monitoring",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains the positive integer n (1 ≤ n ≤ 500) — the length of sequence b. The second line contains n positive integers b1, b2, ..., bn (1 ≤ bi ≤ n). It is guaranteed that b is a permutation, or in other words, each of the numbers 1, 2, ..., n appears exactly once in the sequence b. Also it is guaranteed that b1 = 1.",
      "output_spec": "OutputOutput the number of trees satisfying the conditions above modulo 109 + 7.",
      "sample_tests": "ExamplesInputCopy31 2 3OutputCopy2InputCopy31 3 2OutputCopy1",
      "description": "F. Progress Monitoring\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains the positive integer n (1 ≤ n ≤ 500) — the length of sequence b. The second line contains n positive integers b1, b2, ..., bn (1 ≤ bi ≤ n). It is guaranteed that b is a permutation, or in other words, each of the numbers 1, 2, ..., n appears exactly once in the sequence b. Also it is guaranteed that b1 = 1.\n\nOutputOutput the number of trees satisfying the conditions above modulo 109 + 7.\n\nInputCopy31 2 3OutputCopy2InputCopy31 3 2OutputCopy1\n\nInputCopy31 2 3\n\nOutputCopy2\n\nInputCopy31 3 2\n\nOutputCopy1",
      "solutions": [
        {
          "title": "Codeforces Round #289 (Div. 2) + qualifying round for the WCC - Codeforces",
          "content": "Hello, Codeforces! I'd like to invite you to Codeforces Round #289 (Div. 2). It'll be held on Saturday, January 31 at 15:00 MSK and as usual Div. 1 participants can take part out of competition.This round will be carried out according to the ACM rules, which means that you get verdict of your solution on-line, and the duration time is 3 hours.These differences in the rules are caused by the fact that this round is the second qualifying round for the WCC, which stands for Winter Computer Camp and can be also mentioned as ZKSH. Official school website — hhttp://it-edu.mipt.ru/en/zksh2015. There you can find the selection rules for WCC.If you are a school student and you want to participate in the selection to WCC here are the steps: Sign up for the school at http://goo.gl/kz2qSf, if it was not done earlier. Create a free account at codeforces.com, if it was not done earlier. Sign up for the round on the link http://codeforces.com/contestRegistration/509. You should put a tick in the box \"Do you want to participate in the selection to WCC?\", and provide your last name, first name and email, which you entered for registration in the first step. If you have any questions feel free to write to the address of the organizing committee: zksh-team@phystech.edu.The authors of the contest (WCC technical committee) are really grateful to Max Akhmedov (Zlobober) for the help with preparation of this round, Maria Belova (Delinur) for translation of statements and Mike Mirzayanov (MikeMirzayanov) for contribution to the development of programming by creating systems Codeforces and Polygon.UPD. Tutorial — http://codeforces.com/blog/entry/16119",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/16083",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.6,
            "reason": "宽松匹配: 包含题目编号 509 和字母"
          },
          "content_length": 1654
        },
        {
          "title": "Tutorial CodeForces Round 289 (Div.2) (Second Winter Computer Camp Selection 2015) - Codeforces",
          "content": "509A - Maximum in TableIn this problem one needed to implement what was written in the statement: create matrix (two-dimensional array) using given rules and find maximal value in the table.It is also possible to see that maximal element is always in bottom-right corner.Easier solution with recursion also was enough to get AC: def elem(row, col):\n if row == 1 or col == 1:\n return 1\n return elem(row - 1, col) + elem(row, col - 1)One may see the Pascal's triangle in the given matrix and understand that answer is equal to Prepared by: riadwawAuthor of editorial: riadwaw509B - Painting PebblesSuppose there are two piles with number of pebbles differed by more than k, then there is no solution:Now let M = max ai ≤ min ai + k = m + k.There's a way to construct correct coloring: Chose m peebles from each pile and assign first color to them. In each pile assign different colors to all other pebbles (you may use first color once more) (It's possible bacause there are no more than k uncolored pebbles. Now there are m or m + 1 pebbles of first color and 0 or 1 pebbles of any other color in each pile.Prepared by: KostromaAuthor of editorial: riadwaw509C - Sums of DigitsThe algorithm is greedy: first, take the minimal number with sum of digits a1 — call it b1. Then, on the i-th step take bi as the minimal number with sum of digits ai, which is more than bi - 1. It can be easily proven that this algorithm gives an optimal answer. But how to solve the subproblem: given x and y, find the minimal number with sum of digits x, which is more than y? We use a standard approach: iterate through the digits of y from right to left, trying to increase the current digit and somehow change the digits to the right in order to reach the sum of digits equal to x. Note that if we are considering the (k + 1)-th digit from the right and increase it, we can make the sum of k least significant digits to be any number between 0 and 9k. When we find such position, that increasing a digit in it and changing the least significant digits gives us a number with sum of digits x, we stop the process and obtain the answer. Note that if k least significant digits should have sum m (where 0 ≤ m ≤ 9k), we should obtain the answer greedily, going from the right to the left and putting to the position the largest digit we can. Let us bound the maximal length of the answer, i.e. of bn. If some bi has at least 40 digits, than we take the minimal k such that 10k ≥ bi. Than between 10k and 10k + 1 there exist numbers with any sum of digits between 1 and 9k. If k ≥ 40, than 9k ≥ 300, which is the upper bound of all bi. So, in the constraints of the problem, bi + 1 will be less than 10k + 1. Than, similarly, bi + 2 < 10k + 2 and so on. So, the length of the answer increases by no more than one after reaching the length of 40. Consequently, the maximal length of the answer can't be more than 340. The complexity of solution is O(n·maxLen). Since n ≤ 300, maxLen ≤ 340, the solution runs much faster the time limit.Prepared by: EndagorionAuthor of editorial: Kostroma509D - Restoring NumbersFirst we note that if the sequences ai and bi are a valid solution, then so are the sequences ai - P and bi + P for any integer P. This means that we can consider a1 to be equal to 0 which allows us to recover the sequence bi by simply taking the first row of the matrix. Knowing bi we can also recover ai (for example by subtracting b1 from the first column of the matrix) At this stage we allow ai and bi to contain negative numbers, which can be later fixed by adding K a sufficient amount of times. Now we consider the “error” matrix e: .If e consists entirely of 0s, then we’ve found our solution by taking a sufficiently large K. That is: K > maxi, j(wi, j).Otherwise, we note that ei, j = 0(modK) which implies that K is a divisor of g = gcdi, j(ei, j). The greatest such number is g itself, so all that remains is to check if g is strictly greater than all the elements of the matrix w. If that is the case, then we’ve found our solution by setting K = g. Otherwise, there’s no solution.Prepared by: Kostroma, riadwawAuthor of editorial: riadwaw509E - Pretty SongWe first calculate the prefix sums of vowel(si) which allows to calculate the sum of vowel(si) on any substring in O(1) time.For all m from 1 to , we will calculate the sum of simple pretinesses of all substrings of that length, let’s call it SPm. For that purpose, let’s calculate the number of times the i-th character of the string s is included in this sum. For m = 1 and m = |s|, every character is included exactly 1 time. For m = 2 and m = |s| - 1, the first and the last character are included 1 time and all other characters are included 2 times. For m = 3 and m = |s| - 2 the first and the last character are included 1 time, the second and the pre-last character are included 2 times and all others are included 3 times, and so on.In general, the i-th character is included min(m, |s| - m + 1, i, |s| — i + 1) times. Note that when moving from substrings of length m to substrings of length m + 1, there are 2 ways in which the sum SP can change: If m > |s| - m + 1, then SP is decreased by the number of vowel occurrences in the substring from |s| - m + 1 to m. Otherwise, SP is increased by the number of vowel occurrences in the substring from m to |s| - m + 1. This way we can easily recalculate SPm + 1 using SPm by adding (subtracting) the number of vowel occurrences on a substring (which is done in O(1) time). The complexity of this solution is O(N).Prepared by: zemenAuthor of editorial: zemen509F - Progress MonitoringConsider a tree with n vertices rooted at vertex 1 and let b be the pseudocode’s (DFS) resulting sequence. Then b[lv..lv + sizev - 1], represents vertex v’s subtree, where lv is the index of v in b and sizev is the size of $v$’s subtree.Let’s solve the problem using this fact and Dynamic Programming. Let e[l, r] be the number of trees consisting of vertices a[l], a[l + 1], …, a[r] such that running DFS starting from a[l] will result in a sequence with vertices in the same order as their order in a. The base case is when l = r and e[l, r] = 1. Otherwise, where the sum is taken over all partitions of the segment [l + 1, r], that is, over all k;pos1, ..., posk + 1, such that l + 1 = pos1 < pos2 < ... < posk + 1 = r, 1 ≤ k ≤ r - l, a[pos1] < a[pos2] < ... < a[posk]. Each such partition represents a different way to distribute the vertices among a[l]’s children’s subtrees. A solution using this formula for calculating e[l, r] will have an exponential running time.The final idea is to introduce d[l, r]:  = e[l - 1, r], 2 ≤ l ≤ r ≤ n. It follows that: d[l, r] = ([statement] is equal to 1 if the statement is true, 0 otherwise) and e[l, r] = d[l + 1, r]. This way d[l, r] and e[l, r] can be calculated in linear time for any segment [l, r]. The answer to the problem is e[1, n]. Overall complexity is O(n3).Prepared by: DPR-pavlinAuthor of editorial: DPR-pavlin",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/16119",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 509\\s*F"
          },
          "content_length": 6968
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #289 (Div. 2) + qualifying round for the WCC - Codeforces - Code 1",
          "code": "FOR(K, 0, 102) {\n   if(abs(c1[K]- c2[K]) > 1) {\n     f = false;\n     break;\n   }\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16083",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #289 (Div. 2) + qualifying round for the WCC - Codeforces - Code 2",
          "code": "FOR(K, 0, 102) {\n   if(abs(c1[K]- c2[K]) > 1) {\n     f = false;\n     break;\n   }\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16083",
          "author": "jiangly"
        },
        {
          "title": "Tutorial CodeForces Round 289 (Div.2) (Second Winter Computer Camp Selection 2015) - Codeforces - Code 1",
          "code": "def elem(row, col):\n    if row == 1 or col == 1:\n        return 1\n    return elem(row - 1, col) + elem(row, col - 1)",
          "language": "Python",
          "source": "https://codeforces.com/blog/entry/16119",
          "author": "jiangly"
        },
        {
          "title": "Tutorial CodeForces Round 289 (Div.2) (Second Winter Computer Camp Selection 2015) - Codeforces - Code 2",
          "code": "def elem(row, col):\n    if row == 1 or col == 1:\n        return 1\n    return elem(row - 1, col) + elem(row, col - 1)",
          "language": "Python",
          "source": "https://codeforces.com/blog/entry/16119",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1,500,\"n\");\n    inf.readEoln();\n    vector<int> b = inf.readInts(n,1,n,\"b\");\n    inf.readEoln();\n\n    ensuref(b[0] == 1, \"First element of b must be 1\");\n\n    vector<int> cnt(n+1, 0); // index from 0..n\n    for (int i = 0; i < n; ++i) {\n        cnt[b[i]] += 1;\n    }\n    for (int i = 1; i <= n; ++i) {\n        ensuref(cnt[i] == 1, \"Number %d does not appear exactly once in sequence b\", i);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1,500,\"n\");\n    inf.readEoln();\n    vector<int> b = inf.readInts(n,1,n,\"b\");\n    inf.readEoln();\n\n    ensuref(b[0] == 1, \"First element of b must be 1\");\n\n    vector<int> cnt(n+1, 0); // index from 0..n\n    for (int i = 0; i < n; ++i) {\n        cnt[b[i]] += 1;\n    }\n    for (int i = 1; i <= n; ++i) {\n        ensuref(cnt[i] == 1, \"Number %d does not appear exactly once in sequence b\", i);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1,500,\"n\");\n    inf.readEoln();\n    vector<int> b = inf.readInts(n,1,n,\"b\");\n    inf.readEoln();\n\n    ensuref(b[0] == 1, \"First element of b must be 1\");\n\n    vector<int> cnt(n+1, 0); // index from 0..n\n    for (int i = 0; i < n; ++i) {\n        cnt[b[i]] += 1;\n    }\n    for (int i = 1; i <= n; ++i) {\n        ensuref(cnt[i] == 1, \"Number %d does not appear exactly once in sequence b\", i);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> b(n);\n    b[0] = 1; // Ensure b1 = 1\n\n    if (type == \"increasing\") {\n        // b = [1, 2, 3, ..., n]\n        for (int i = 1; i < n; ++i) {\n            b[i] = i + 1;\n        }\n    } else if (type == \"decreasing\") {\n        // b = [1, n, n-1, ..., 2]\n        for (int i = 1; i < n; ++i) {\n            b[i] = n - i + 1;\n        }\n    } else if (type == \"chain\") {\n        // Simulate DFS of a chain\n        // b = [1, 2, 3, ..., n]\n        for (int i = 1; i < n; ++i) {\n            b[i] = i + 1;\n        }\n    } else if (type == \"star\") {\n        // Simulate DFS of a star-shaped tree\n        // b = [1, shuffled 2..n]\n        vector<int> perm(n - 1);\n        for (int i = 0; i < n - 1; ++i) {\n            perm[i] = i + 2;\n        }\n        shuffle(perm.begin(), perm.end());\n        for (int i = 1; i < n; ++i) {\n            b[i] = perm[i - 1];\n        }\n    } else if (type == \"caterpillar\") {\n        // Create a specific sequence simulating a caterpillar tree\n        vector<int> left, right;\n        for (int i = 2; i <= n; ++i) {\n            if (i % 2 == 0)\n                left.push_back(i);\n            else\n                right.push_back(i);\n        }\n        b.clear();\n        b.push_back(1);\n        for (size_t i = 0; i < max(left.size(), right.size()); ++i) {\n            if (i < left.size())\n                b.push_back(left[i]);\n            if (i < right.size())\n                b.push_back(right[i]);\n        }\n    } else { // Default to \"random\"\n        // b[2..n] is a random permutation of 2..n\n        vector<int> perm(n - 1);\n        for (int i = 0; i < n - 1; ++i) {\n            perm[i] = i + 2;\n        }\n        shuffle(perm.begin(), perm.end());\n        for (int i = 1; i < n; ++i) {\n            b[i] = perm[i - 1];\n        }\n    }\n\n    // Output the sequence\n    printf(\"%d\\n\", n);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d\", b[i]);\n        if (i + 1 < n) {\n            printf(\" \");\n        }\n    }\n    printf(\"\\n\");\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> b(n);\n    b[0] = 1; // Ensure b1 = 1\n\n    if (type == \"increasing\") {\n        // b = [1, 2, 3, ..., n]\n        for (int i = 1; i < n; ++i) {\n            b[i] = i + 1;\n        }\n    } else if (type == \"decreasing\") {\n        // b = [1, n, n-1, ..., 2]\n        for (int i = 1; i < n; ++i) {\n            b[i] = n - i + 1;\n        }\n    } else if (type == \"chain\") {\n        // Simulate DFS of a chain\n        // b = [1, 2, 3, ..., n]\n        for (int i = 1; i < n; ++i) {\n            b[i] = i + 1;\n        }\n    } else if (type == \"star\") {\n        // Simulate DFS of a star-shaped tree\n        // b = [1, shuffled 2..n]\n        vector<int> perm(n - 1);\n        for (int i = 0; i < n - 1; ++i) {\n            perm[i] = i + 2;\n        }\n        shuffle(perm.begin(), perm.end());\n        for (int i = 1; i < n; ++i) {\n            b[i] = perm[i - 1];\n        }\n    } else if (type == \"caterpillar\") {\n        // Create a specific sequence simulating a caterpillar tree\n        vector<int> left, right;\n        for (int i = 2; i <= n; ++i) {\n            if (i % 2 == 0)\n                left.push_back(i);\n            else\n                right.push_back(i);\n        }\n        b.clear();\n        b.push_back(1);\n        for (size_t i = 0; i < max(left.size(), right.size()); ++i) {\n            if (i < left.size())\n                b.push_back(left[i]);\n            if (i < right.size())\n                b.push_back(right[i]);\n        }\n    } else { // Default to \"random\"\n        // b[2..n] is a random permutation of 2..n\n        vector<int> perm(n - 1);\n        for (int i = 0; i < n - 1; ++i) {\n            perm[i] = i + 2;\n        }\n        shuffle(perm.begin(), perm.end());\n        for (int i = 1; i < n; ++i) {\n            b[i] = perm[i - 1];\n        }\n    }\n\n    // Output the sequence\n    printf(\"%d\\n\", n);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d\", b[i]);\n        if (i + 1 < n) {\n            printf(\" \");\n        }\n    }\n    printf(\"\\n\");\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Small n with increasing sequence\n./gen -n 1 -type increasing\n./gen -n 2 -type increasing\n./gen -n 3 -type increasing\n\n# Small n with decreasing sequence\n./gen -n 2 -type decreasing\n./gen -n 3 -type decreasing\n\n# Small n with random sequence\n./gen -n 2 -type random\n./gen -n 3 -type random\n\n# Medium n with chain structure\n./gen -n 5 -type chain\n./gen -n 10 -type chain\n./gen -n 50 -type chain\n./gen -n 100 -type chain\n\n# Medium n with star structure\n./gen -n 5 -type star\n./gen -n 10 -type star\n./gen -n 50 -type star\n./gen -n 100 -type star\n\n# Medium n with caterpillar structure\n./gen -n 5 -type caterpillar\n./gen -n 10 -type caterpillar\n./gen -n 50 -type caterpillar\n./gen -n 100 -type caterpillar\n\n# Medium n with random sequence\n./gen -n 5 -type random\n./gen -n 10 -type random\n./gen -n 50 -type random\n./gen -n 100 -type random\n\n# Large n with increasing sequence\n./gen -n 200 -type increasing\n./gen -n 300 -type increasing\n./gen -n 400 -type increasing\n\n# Large n with decreasing sequence\n./gen -n 200 -type decreasing\n./gen -n 300 -type decreasing\n./gen -n 400 -type decreasing\n\n# Large n with random sequence\n./gen -n 200 -type random\n./gen -n 300 -type random\n./gen -n 400 -type random\n\n# Edge cases\n./gen -n 1 -type random\n./gen -n 500 -type chain\n./gen -n 500 -type star\n./gen -n 500 -type caterpillar\n./gen -n 500 -type random\n./gen -n 500 -type increasing\n./gen -n 500 -type decreasing\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:41:20.609463",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "51/A",
      "title": "A. Cheaterius's Problem",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains an integer n (1 ≤ n ≤ 1000), where n is the number of amulets. Then the amulet's descriptions are contained. Every description occupies two lines and contains two numbers (from 1 to 6) in each line. Between every pair of amulets the line \"**\" is located.",
      "output_spec": "OutputPrint the required number of piles.",
      "sample_tests": "ExamplesInputCopy43123**3123**1332**3213OutputCopy1InputCopy45126**5435**2561**4553OutputCopy2",
      "description": "A. Cheaterius's Problem\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains an integer n (1 ≤ n ≤ 1000), where n is the number of amulets. Then the amulet's descriptions are contained. Every description occupies two lines and contains two numbers (from 1 to 6) in each line. Between every pair of amulets the line \"**\" is located.\n\nOutputPrint the required number of piles.\n\nInputCopy43123**3123**1332**3213OutputCopy1InputCopy45126**5435**2561**4553OutputCopy2\n\nInputCopy43123**3123**1332**3213\n\nOutputCopy1\n\nInputCopy45126**5435**2561**4553\n\nOutputCopy2",
      "solutions": [
        {
          "title": "Codeforces Beta Round #48 - Codeforces",
          "content": "Hello!I invite you to participate in Codeforces Beta Round #48. This time I acted as the author of the contest. I believe it is really exciting too! I urge you to follow my example. Codeforces is happy to contest authors.With contest proposals please contact RAD (our problem coordinator).Participants are waiting for your problems!UPD:PDF statements will be also available after the contest start. Please, use the link.I wish you beautiful solutions,MikeMirzayanov",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/1030",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 465
        },
        {
          "title": "Разбор задачек R#48 - Codeforces",
          "content": "Еще вопрос: кто-нибудь знает, как поставить ссылку на профиль пользователя в посте? A. Задача ЧитериусаВ этой задаче теоретически могли быть следующие проблемы: считывание, сравнивание, \"я не прочитал, что n<=1000\" и \"электричка опоздала на 10 минут к началу раунда\". У меня была последняя :)Считывать можно было либо построчно, либо по токенам. Всё языки это умеют.Сравнивать два квадрата можно опять же как угодно. Я делал так: считал две строчки, соеденил в одну и поменял 3й и 4й местами. Получилась \"ленточка\". Две \"ленточки\" можно сравнить двумя циклами: первый перебирает сдвиг, второй проверяет, что всё совпало.Далее оставалось лишь посчитать количество стопок. Это можно было делать так: перебираем все непомеченные квадратики, добавляем один к ответу и помечаем все квадратики, которые равны текущему. B. Анализ таблиц bHTMLЗадача тоже не ахти какая сложнае, если знать, как строятся парсеры в общем виде.Для начала требовалось прочитать все строчки и склеить их в одну.После чего поступаем так: заводим указатель на текущий рассматриваемый символ. Изначально он равен нулю. Затем делаем вспомогательную процедуру \"прочитать строку\". Она пытается посимвольно прочитать что-нибудь, начиная с текущего символа, и, если удалось - возвращает True и перемещает указатель вправо, если нет - возвращает False, и указатель не трогает.После этого можно написать рекурсивные процедуры ReadCell, ReadRow и ReadTable - каждая из них возвращает количество ячеек в текущей таблице.ReadCell работает так: прочитать <td>, если дальше не удалось прочитать </td>, добавить к ответу ReadTable() и прочитать </td>. Вернуть 1.ReadRow: считали <tr>, пока не удаётся прочитать </tr>, делаем ReadCell. Вернуть сумму по всем ReadCell.ReadTable: считали <table>, пока не удаётся прочитать </table>, делаем ReadRow. Вернуть сумму по всем ReadRow.В конце надо посортировать количества ячеек во всех таблицах и вывести.Также можно было делать так: завести функцию getTag, которая возвращает какой из 6 тегов был, а далее разобрать три случая:\"table\" => stack.push_back(0)\"td\" => stack.top++\"/table\" => ans.push_back( stack.top() ), stack.pop_back()C. Три базовых станцииДля начала упростим себе задачу: посортируем дома и удалим одинаковые. Теперь давайте в цикле переберём самый правый дом, который покрывает первая станция.Этот дом однозначно определяет её минимальную мощность. Далее хочется быстро найти границу для второй станции. Что мы хотим минимизировать? Максимум из мощности второй и третьей станций (т.к. первая у нас уже фиксированна). При движении границы слева направо мощность второй растёт, а третьей - убывает. Соответственно, максимум из этих двух величин до какого-то времени невозрастает, а затем - неубывает. Хотим найти момент этого перехода - в нем и будет искомый минимум. Это можно сделать при помощи указателя, т.к. этот момент всегда движется только направо.Т.о. получаем решение за линейное время.D. Геометрическая задачаПервое, что требовалось вспомнить - бываю еще и нули.Давайте для начала научимся понимать, является ли последовательность геометрической прогрессией. У каждой прогресси либо есть знаменатель b  (возможно, 0), либо он может быть любым (c=0). Для каждых двух соседних элементов опять же, либо есть однозначные знаменатель, либо нет. Собирав эту информацию со всех элементов и проверив на непротиворечивость, мы убедимся что последовательнось - прогрессия.Побежим по последовательности слева направо. Заведём две переменные - знаменатель последовательности (b) и флаг, определили ли мы его уже (exb). Вначале exb=false.Далее мы обрабатываем элемент (a1) и предыдущий (a0). Мы должны проверить, что они не конфликтуют с уже известной информацией и что они вообще могут встретиться рядом хоть в какой-то последовательности. Если это так, то нам надо пересчитать знаменатель (если a0 != 0), иначе сразу возвращаем false.Для проверки на конфликты у меня была функция equal. Она работает следующим образом: если a0 = 0, то надо проверить, что a1 = 0 и вернуть true, иначе выбросить исключение. Иначе, если знаменатель еще не определён, то вернуть true. В противном случае проверить, что отношение элементов и знаменатель совпадают.Если в конце оказалось, что конфликтов и исключений не было, то да, такая геометрическая прогрессия есть.Теперь у нас есть функция проверки, является ли последовательность прогрессией. Мы уже можем написать квадратичное решение. Для получения OK нам требуется чуть-чуть изменить квадрат и сделать precalc.Как работает тупой квадрат? Выкидываем по очереди элементы и проверяем, что прогрессия есть. Теперь давайте заметим, что массив без одного элемента - это какой-то его префикс плюс суффикс.Что значит, это это объединение есть прогрессия? Что, во-первых, каждый из них является прогрессией, и, во-вторых, что их можно \"склеить\". Т.е. что пара (an, b1) не конфликтует ни с первой прогрессией, ни со второй.Теперь у нас есть цикл, внутри которого идёт куча вызовов вида check(0, 0), check(0, 1), check(0, 2) и т.д. Их можно объединить в один и с запоминанием результатов на каждом шаге. Это даёт линейное решение со всеми разобранными случаями.E. Пентагон (спасибо, @Sereja)Пускай массив Q означает наличие ребра между двумя вершинами, а st - степень вершины.Для начала для каждой пары посчитаем количество вершин которые \"лежат между ними\", иными словами, достижимы от обоих из них. Запишем эти данные в массив A (это можно сделать за кубическое время).После того, как мы знаем эти данные, переберем 3 вершины из цикла, две из которых будут лежать \"рядом\" в цикле. Назовём их i, j и l (Q[i,j]=1). Тогда возьмем две переменные, которые будут отвечать за количество вершин \"между\" i и l , j и l. Это будут значения A[i, l] и A[j,l], но при этом, в случае Q[j, l] = 1 от первого нужно отнять 1, для второго - аналогично. Это делается для того, чтобы никакая вершина не входила в цикл два раза. К ответу добавим произведение этих значений. Есть еще один отдельный случай: когда Q[i, l]=1 и Q[j, l]=1, то от ответа нужно отнять st[l]-2? Чтобы понять это, нужно на листке бумажки расписать, как будут происходить добавления новых циклов, и через какие вершины мы их пропустим.Полученный ответ делим на 5 для удаления повторов (каждый цикл мы считаем из каждой его вершины), это и будет финальный ответ.В комментариях есть обобщённое решение на случай более длинных циклов.F. ГусеницаСсылка",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/1038",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 6340
        }
      ],
      "code_examples": [],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 1000, \"n\");\n    inf.readEoln();\n\n    for (int i = 0; i < n; i++) {\n        // Read first line of amulet\n        string s1 = inf.readLine();\n        ensuref(s1.size() == 2, \"First line of amulet %d must be length 2, but it's length %d\", i+1, int(s1.size()));\n        for (int j = 0; j < 2; j++) {\n            char c = s1[j];\n            ensuref('1' <= c && c <= '6', \"Character '%c' at position %d in first line of amulet %d is invalid, expected digit between '1' and '6'\", c, j+1, i+1);\n        }\n\n        // Read second line of amulet\n        string s2 = inf.readLine();\n        ensuref(s2.size() == 2, \"Second line of amulet %d must be length 2, but it's length %d\", i+1, int(s2.size()));\n        for (int j = 0; j < 2; j++) {\n            char c = s2[j];\n            ensuref('1' <= c && c <= '6', \"Character '%c' at position %d in second line of amulet %d is invalid, expected digit between '1' and '6'\", c, j+1, i+1);\n        }\n\n        if (i < n - 1) {\n            // Read separator line\n            string separator = inf.readLine();\n            ensuref(separator == \"**\", \"Expected separator '**' between amulet %d and amulet %d, but found '%s'\", i+1, i+2, separator.c_str());\n        }\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 1000, \"n\");\n    inf.readEoln();\n\n    for (int i = 0; i < n; i++) {\n        // Read first line of amulet\n        string s1 = inf.readLine();\n        ensuref(s1.size() == 2, \"First line of amulet %d must be length 2, but it's length %d\", i+1, int(s1.size()));\n        for (int j = 0; j < 2; j++) {\n            char c = s1[j];\n            ensuref('1' <= c && c <= '6', \"Character '%c' at position %d in first line of amulet %d is invalid, expected digit between '1' and '6'\", c, j+1, i+1);\n        }\n\n        // Read second line of amulet\n        string s2 = inf.readLine();\n        ensuref(s2.size() == 2, \"Second line of amulet %d must be length 2, but it's length %d\", i+1, int(s2.size()));\n        for (int j = 0; j < 2; j++) {\n            char c = s2[j];\n            ensuref('1' <= c && c <= '6', \"Character '%c' at position %d in second line of amulet %d is invalid, expected digit between '1' and '6'\", c, j+1, i+1);\n        }\n\n        if (i < n - 1) {\n            // Read separator line\n            string separator = inf.readLine();\n            ensuref(separator == \"**\", \"Expected separator '**' between amulet %d and amulet %d, but found '%s'\", i+1, i+2, separator.c_str());\n        }\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 1000, \"n\");\n    inf.readEoln();\n\n    for (int i = 0; i < n; i++) {\n        // Read first line of amulet\n        string s1 = inf.readLine();\n        ensuref(s1.size() == 2, \"First line of amulet %d must be length 2, but it's length %d\", i+1, int(s1.size()));\n        for (int j = 0; j < 2; j++) {\n            char c = s1[j];\n            ensuref('1' <= c && c <= '6', \"Character '%c' at position %d in first line of amulet %d is invalid, expected digit between '1' and '6'\", c, j+1, i+1);\n        }\n\n        // Read second line of amulet\n        string s2 = inf.readLine();\n        ensuref(s2.size() == 2, \"Second line of amulet %d must be length 2, but it's length %d\", i+1, int(s2.size()));\n        for (int j = 0; j < 2; j++) {\n            char c = s2[j];\n            ensuref('1' <= c && c <= '6', \"Character '%c' at position %d in second line of amulet %d is invalid, expected digit between '1' and '6'\", c, j+1, i+1);\n        }\n\n        if (i < n - 1) {\n            // Read separator line\n            string separator = inf.readLine();\n            ensuref(separator == \"**\", \"Expected separator '**' between amulet %d and amulet %d, but found '%s'\", i+1, i+2, separator.c_str());\n        }\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\n// Function to rotate the amulet\nvector<int> rotateAmulet(const vector<int>& amulet, int rotation) {\n    // Rotations:\n    // 0 degrees: [0,1,2,3]\n    // 90 degrees: [2,0,3,1]\n    // 180 degrees: [3,2,1,0]\n    // 270 degrees: [1,3,0,2]\n    vector<int> rotated(4);\n    if (rotation == 0) { // 0 degrees\n        rotated = amulet;\n    } else if (rotation == 1) { // 90 degrees\n        rotated = { amulet[2], amulet[0], amulet[3], amulet[1] };\n    } else if (rotation == 2) { // 180 degrees\n        rotated = { amulet[3], amulet[2], amulet[1], amulet[0] };\n    } else if (rotation == 3) { // 270 degrees\n        rotated = { amulet[1], amulet[3], amulet[0], amulet[2] };\n    }\n    return rotated;\n}\n\n// Function to get the canonical form of an amulet\nvector<int> getCanonicalForm(const vector<int>& amulet) {\n    vector<int> minForm = amulet;\n    for (int i = 1; i < 4; ++i) {\n        vector<int> rotated = rotateAmulet(amulet, i);\n        if (rotated < minForm)\n            minForm = rotated;\n    }\n    return minForm;\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    // Maximum number of unique amulets modulo rotations\n    const int MAX_UNIQUE = 328;\n\n    vector<vector<int>> amulets;\n\n    if (type == \"all_same\") {\n        // Generate a random base amulet\n        vector<int> baseAmulet(4);\n        for (int i = 0; i < 4; ++i)\n            baseAmulet[i] = rnd.next(1, 6);\n\n        // Generate n amulets, possibly with random rotations\n        for (int i = 0; i < n; ++i) {\n            int rotation = rnd.next(0, 3); // Random rotation\n            vector<int> amulet = rotateAmulet(baseAmulet, rotation);\n            amulets.push_back(amulet);\n        }\n\n    } else if (type == \"all_different\") {\n        if (n > MAX_UNIQUE) {\n            fprintf(stderr, \"Maximum number of unique amulets is %d.\\n\", MAX_UNIQUE);\n            exit(1);\n        }\n        // Generate all unique canonical forms\n        set<vector<int>> uniqueAmuletsSet;\n        vector<vector<int>> allCanonicalForms;\n\n        for (int a = 1; a <= 6; ++a)\n            for (int b = 1; b <= 6; ++b)\n                for (int c = 1; c <= 6; ++c)\n                    for (int d = 1; d <= 6; ++d) {\n                        vector<int> amulet = { a, b, c, d };\n                        vector<int> canon = getCanonicalForm(amulet);\n                        if (uniqueAmuletsSet.insert(canon).second) {\n                            allCanonicalForms.push_back(canon);\n                        }\n                    }\n\n        // Shuffle and pick n canonical forms\n        shuffle(allCanonicalForms.begin(), allCanonicalForms.end());\n        for (int i = 0; i < n; ++i) {\n            // Random rotation for variety\n            int rotation = rnd.next(0, 3);\n            vector<int> amulet = rotateAmulet(allCanonicalForms[i], rotation);\n            amulets.push_back(amulet);\n        }\n\n    } else if (type == \"random\") {\n        // Generate n random amulets\n        for (int i = 0; i < n; ++i) {\n            vector<int> amulet(4);\n            for (int j = 0; j < 4; ++j)\n                amulet[j] = rnd.next(1, 6);\n            amulets.push_back(amulet);\n        }\n    } else if (type == \"tricky\") {\n        // Special test cases to catch mistakes\n        if (n < 4) {\n            fprintf(stderr, \"Need at least 4 amulets for tricky type.\\n\");\n            exit(1);\n        }\n        // First two amulets are similar under reflection but not rotation\n        vector<int> amulet1 = {1, 2, 3, 4};\n        vector<int> amulet2 = {2, 1, 4, 3}; // Reflection of amulet1\n        amulets.push_back(amulet1);\n        amulets.push_back(amulet2);\n\n        // Next two amulets are similar under rotation\n        vector<int> amulet3 = {5, 6, 1, 2};\n        vector<int> amulet4 = rotateAmulet(amulet3, rnd.next(1, 3));\n        amulets.push_back(amulet3);\n        amulets.push_back(amulet4);\n\n        // Fill the rest with random amulets\n        for (int i = 4; i < n; ++i) {\n            vector<int> amulet(4);\n            for (int j = 0; j < 4; ++j)\n                amulet[j] = rnd.next(1, 6);\n            amulets.push_back(amulet);\n        }\n        shuffle(amulets.begin(), amulets.end());\n    } else {\n        fprintf(stderr, \"Unknown type '%s'\\n\", type.c_str());\n        exit(1);\n    }\n\n    // Output the amulets in the required format\n    printf(\"%d\\n\", n);\n    for (size_t i = 0; i < amulets.size(); ++i) {\n        vector<int> &amulet = amulets[i];\n        printf(\"%d%d\\n\", amulet[0], amulet[1]);\n        printf(\"%d%d\\n\", amulet[2], amulet[3]);\n        if (i + 1 < amulets.size())\n            printf(\"**\\n\");\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\n// Function to rotate the amulet\nvector<int> rotateAmulet(const vector<int>& amulet, int rotation) {\n    // Rotations:\n    // 0 degrees: [0,1,2,3]\n    // 90 degrees: [2,0,3,1]\n    // 180 degrees: [3,2,1,0]\n    // 270 degrees: [1,3,0,2]\n    vector<int> rotated(4);\n    if (rotation == 0) { // 0 degrees\n        rotated = amulet;\n    } else if (rotation == 1) { // 90 degrees\n        rotated = { amulet[2], amulet[0], amulet[3], amulet[1] };\n    } else if (rotation == 2) { // 180 degrees\n        rotated = { amulet[3], amulet[2], amulet[1], amulet[0] };\n    } else if (rotation == 3) { // 270 degrees\n        rotated = { amulet[1], amulet[3], amulet[0], amulet[2] };\n    }\n    return rotated;\n}\n\n// Function to get the canonical form of an amulet\nvector<int> getCanonicalForm(const vector<int>& amulet) {\n    vector<int> minForm = amulet;\n    for (int i = 1; i < 4; ++i) {\n        vector<int> rotated = rotateAmulet(amulet, i);\n        if (rotated < minForm)\n            minForm = rotated;\n    }\n    return minForm;\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    // Maximum number of unique amulets modulo rotations\n    const int MAX_UNIQUE = 328;\n\n    vector<vector<int>> amulets;\n\n    if (type == \"all_same\") {\n        // Generate a random base amulet\n        vector<int> baseAmulet(4);\n        for (int i = 0; i < 4; ++i)\n            baseAmulet[i] = rnd.next(1, 6);\n\n        // Generate n amulets, possibly with random rotations\n        for (int i = 0; i < n; ++i) {\n            int rotation = rnd.next(0, 3); // Random rotation\n            vector<int> amulet = rotateAmulet(baseAmulet, rotation);\n            amulets.push_back(amulet);\n        }\n\n    } else if (type == \"all_different\") {\n        if (n > MAX_UNIQUE) {\n            fprintf(stderr, \"Maximum number of unique amulets is %d.\\n\", MAX_UNIQUE);\n            exit(1);\n        }\n        // Generate all unique canonical forms\n        set<vector<int>> uniqueAmuletsSet;\n        vector<vector<int>> allCanonicalForms;\n\n        for (int a = 1; a <= 6; ++a)\n            for (int b = 1; b <= 6; ++b)\n                for (int c = 1; c <= 6; ++c)\n                    for (int d = 1; d <= 6; ++d) {\n                        vector<int> amulet = { a, b, c, d };\n                        vector<int> canon = getCanonicalForm(amulet);\n                        if (uniqueAmuletsSet.insert(canon).second) {\n                            allCanonicalForms.push_back(canon);\n                        }\n                    }\n\n        // Shuffle and pick n canonical forms\n        shuffle(allCanonicalForms.begin(), allCanonicalForms.end());\n        for (int i = 0; i < n; ++i) {\n            // Random rotation for variety\n            int rotation = rnd.next(0, 3);\n            vector<int> amulet = rotateAmulet(allCanonicalForms[i], rotation);\n            amulets.push_back(amulet);\n        }\n\n    } else if (type == \"random\") {\n        // Generate n random amulets\n        for (int i = 0; i < n; ++i) {\n            vector<int> amulet(4);\n            for (int j = 0; j < 4; ++j)\n                amulet[j] = rnd.next(1, 6);\n            amulets.push_back(amulet);\n        }\n    } else if (type == \"tricky\") {\n        // Special test cases to catch mistakes\n        if (n < 4) {\n            fprintf(stderr, \"Need at least 4 amulets for tricky type.\\n\");\n            exit(1);\n        }\n        // First two amulets are similar under reflection but not rotation\n        vector<int> amulet1 = {1, 2, 3, 4};\n        vector<int> amulet2 = {2, 1, 4, 3}; // Reflection of amulet1\n        amulets.push_back(amulet1);\n        amulets.push_back(amulet2);\n\n        // Next two amulets are similar under rotation\n        vector<int> amulet3 = {5, 6, 1, 2};\n        vector<int> amulet4 = rotateAmulet(amulet3, rnd.next(1, 3));\n        amulets.push_back(amulet3);\n        amulets.push_back(amulet4);\n\n        // Fill the rest with random amulets\n        for (int i = 4; i < n; ++i) {\n            vector<int> amulet(4);\n            for (int j = 0; j < 4; ++j)\n                amulet[j] = rnd.next(1, 6);\n            amulets.push_back(amulet);\n        }\n        shuffle(amulets.begin(), amulets.end());\n    } else {\n        fprintf(stderr, \"Unknown type '%s'\\n\", type.c_str());\n        exit(1);\n    }\n\n    // Output the amulets in the required format\n    printf(\"%d\\n\", n);\n    for (size_t i = 0; i < amulets.size(); ++i) {\n        vector<int> &amulet = amulets[i];\n        printf(\"%d%d\\n\", amulet[0], amulet[1]);\n        printf(\"%d%d\\n\", amulet[2], amulet[3]);\n        if (i + 1 < amulets.size())\n            printf(\"**\\n\");\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Test cases with small n\n./gen -n 1 -type all_same\n./gen -n 2 -type all_same\n./gen -n 10 -type all_same\n\n./gen -n 1 -type all_different\n./gen -n 2 -type all_different\n./gen -n 10 -type all_different\n\n./gen -n 1 -type random\n./gen -n 2 -type random\n./gen -n 10 -type random\n\n./gen -n 4 -type tricky\n./gen -n 10 -type tricky\n\n# Test cases with medium n\n./gen -n 100 -type all_same\n./gen -n 100 -type random\n./gen -n 100 -type tricky\n\n# Test cases with maximum n for all_different\n./gen -n 328 -type all_different\n\n# Test cases with maximum n\n./gen -n 1000 -type all_same\n./gen -n 1000 -type random\n\n# Edge case: n equals maximum unique amulets\n./gen -n 328 -type all_same\n./gen -n 328 -type random\n\n# Test cases covering potential mistakes\n./gen -n 500 -type random\n./gen -n 1000 -type random\n\n# Additional tricky cases\n./gen -n 500 -type tricky\n./gen -n 1000 -type tricky\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:41:22.882192",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "51/B",
      "title": "B. Анализ таблиц bHTML",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест2 seconds",
      "memory_limit": "ограничение по памяти на тест256 megabytes",
      "input_spec": "Входные данныеДля удобства входные данные могут быть разбиты на непустые строки произвольным образом. Входные данные состоят из не более чем 10 строк. Объедините все строки входных данных в одну, чтобы получить текстовое представление s заданной таблицы. Текстовое s представление соответствует грамматике из условия (корневой элемент грамматики TABLE), длина s не превосходит 5000. Используются только строчные буквы при записи тегов, пробелов в строках нет.",
      "output_spec": "Выходные данныеВыведите размеры всех таблиц во входных данных в порядке неубывания.",
      "sample_tests": "ПримерыВходные данныеСкопировать<table><tr><td></td></tr></table>Выходные данныеСкопировать1 Входные данныеСкопировать<table><tr><td><table><tr><td></td></tr><tr><td></td></tr><tr><td></td></tr><tr><td></td></tr></table></td></tr></table>Выходные данныеСкопировать1 4 Входные данныеСкопировать<table><tr><td><table><tr><td><table><tr><td><table><tr><td></td><td></td></tr><tr><td></td></tr></table></td></tr></table></td></tr></table></td></tr></table>Выходные данныеСкопировать1 1 1 3",
      "description": "B. Анализ таблиц bHTML\n\nограничение по времени на тест2 seconds\n\nограничение по времени на тест\n\nограничение по памяти на тест256 megabytes\n\nограничение по памяти на тест\n\nвыводstdout\n\nВходные данныеДля удобства входные данные могут быть разбиты на непустые строки произвольным образом. Входные данные состоят из не более чем 10 строк. Объедините все строки входных данных в одну, чтобы получить текстовое представление s заданной таблицы. Текстовое s представление соответствует грамматике из условия (корневой элемент грамматики TABLE), длина s не превосходит 5000. Используются только строчные буквы при записи тегов, пробелов в строках нет.\n\nВходные данные\n\nВыходные данныеВыведите размеры всех таблиц во входных данных в порядке неубывания.\n\nВыходные данные\n\nВходные данныеСкопировать<table><tr><td></td></tr></table>Выходные данныеСкопировать1 Входные данныеСкопировать<table><tr><td><table><tr><td></td></tr><tr><td></td></tr><tr><td></td></tr><tr><td></td></tr></table></td></tr></table>Выходные данныеСкопировать1 4 Входные данныеСкопировать<table><tr><td><table><tr><td><table><tr><td><table><tr><td></td><td></td></tr><tr><td></td></tr></table></td></tr></table></td></tr></table></td></tr></table>Выходные данныеСкопировать1 1 1 3\n\nВходные данныеСкопировать<table><tr><td></td></tr></table>\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать1\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать<table><tr><td><table><tr><td></td></tr><tr><td></td></tr><tr><td></td></tr><tr><td></td></tr></table></td></tr></table>\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать1 4\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать<table><tr><td><table><tr><td><table><tr><td><table><tr><td></td><td></td></tr><tr><td></td></tr></table></td></tr></table></td></tr></table></td></tr></table>\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать1 1 1 3\n\nВыходные данныеСкопировать\n\nСкопировать",
      "solutions": [
        {
          "title": "Codeforces Beta Round #48 - Codeforces",
          "content": "Всем привет!Приглашаю вас принять участие в Codeforces Beta Round #48. В этот раз я выступил в роли автора контеста - приятно знаете ли иногда попридумывать задачки :) Вас же я призываю последовать моем примеру. Проект Codeforces всегда рад как новым авторам, так и тем, кто уже выступал в этой роли. С предложениями пишите Артему Рахову (координатору задач проекта). Участники ждут ваших задач!UPD:Для удобства и некоторой подстраховки, условия задач будут доступны по ссылке.А вам я желаю красивых решений,MikeMirzayanov",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/1030",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 522
        },
        {
          "title": "Разбор задачек R#48 - Codeforces",
          "content": "Еще вопрос: кто-нибудь знает, как поставить ссылку на профиль пользователя в посте? A. Задача ЧитериусаВ этой задаче теоретически могли быть следующие проблемы: считывание, сравнивание, \"я не прочитал, что n<=1000\" и \"электричка опоздала на 10 минут к началу раунда\". У меня была последняя :)Считывать можно было либо построчно, либо по токенам. Всё языки это умеют.Сравнивать два квадрата можно опять же как угодно. Я делал так: считал две строчки, соеденил в одну и поменял 3й и 4й местами. Получилась \"ленточка\". Две \"ленточки\" можно сравнить двумя циклами: первый перебирает сдвиг, второй проверяет, что всё совпало.Далее оставалось лишь посчитать количество стопок. Это можно было делать так: перебираем все непомеченные квадратики, добавляем один к ответу и помечаем все квадратики, которые равны текущему. B. Анализ таблиц bHTMLЗадача тоже не ахти какая сложнае, если знать, как строятся парсеры в общем виде.Для начала требовалось прочитать все строчки и склеить их в одну.После чего поступаем так: заводим указатель на текущий рассматриваемый символ. Изначально он равен нулю. Затем делаем вспомогательную процедуру \"прочитать строку\". Она пытается посимвольно прочитать что-нибудь, начиная с текущего символа, и, если удалось - возвращает True и перемещает указатель вправо, если нет - возвращает False, и указатель не трогает.После этого можно написать рекурсивные процедуры ReadCell, ReadRow и ReadTable - каждая из них возвращает количество ячеек в текущей таблице.ReadCell работает так: прочитать <td>, если дальше не удалось прочитать </td>, добавить к ответу ReadTable() и прочитать </td>. Вернуть 1.ReadRow: считали <tr>, пока не удаётся прочитать </tr>, делаем ReadCell. Вернуть сумму по всем ReadCell.ReadTable: считали <table>, пока не удаётся прочитать </table>, делаем ReadRow. Вернуть сумму по всем ReadRow.В конце надо посортировать количества ячеек во всех таблицах и вывести.Также можно было делать так: завести функцию getTag, которая возвращает какой из 6 тегов был, а далее разобрать три случая:\"table\" => stack.push_back(0)\"td\" => stack.top++\"/table\" => ans.push_back( stack.top() ), stack.pop_back()C. Три базовых станцииДля начала упростим себе задачу: посортируем дома и удалим одинаковые. Теперь давайте в цикле переберём самый правый дом, который покрывает первая станция.Этот дом однозначно определяет её минимальную мощность. Далее хочется быстро найти границу для второй станции. Что мы хотим минимизировать? Максимум из мощности второй и третьей станций (т.к. первая у нас уже фиксированна). При движении границы слева направо мощность второй растёт, а третьей - убывает. Соответственно, максимум из этих двух величин до какого-то времени невозрастает, а затем - неубывает. Хотим найти момент этого перехода - в нем и будет искомый минимум. Это можно сделать при помощи указателя, т.к. этот момент всегда движется только направо.Т.о. получаем решение за линейное время.D. Геометрическая задачаПервое, что требовалось вспомнить - бываю еще и нули.Давайте для начала научимся понимать, является ли последовательность геометрической прогрессией. У каждой прогресси либо есть знаменатель b  (возможно, 0), либо он может быть любым (c=0). Для каждых двух соседних элементов опять же, либо есть однозначные знаменатель, либо нет. Собирав эту информацию со всех элементов и проверив на непротиворечивость, мы убедимся что последовательнось - прогрессия.Побежим по последовательности слева направо. Заведём две переменные - знаменатель последовательности (b) и флаг, определили ли мы его уже (exb). Вначале exb=false.Далее мы обрабатываем элемент (a1) и предыдущий (a0). Мы должны проверить, что они не конфликтуют с уже известной информацией и что они вообще могут встретиться рядом хоть в какой-то последовательности. Если это так, то нам надо пересчитать знаменатель (если a0 != 0), иначе сразу возвращаем false.Для проверки на конфликты у меня была функция equal. Она работает следующим образом: если a0 = 0, то надо проверить, что a1 = 0 и вернуть true, иначе выбросить исключение. Иначе, если знаменатель еще не определён, то вернуть true. В противном случае проверить, что отношение элементов и знаменатель совпадают.Если в конце оказалось, что конфликтов и исключений не было, то да, такая геометрическая прогрессия есть.Теперь у нас есть функция проверки, является ли последовательность прогрессией. Мы уже можем написать квадратичное решение. Для получения OK нам требуется чуть-чуть изменить квадрат и сделать precalc.Как работает тупой квадрат? Выкидываем по очереди элементы и проверяем, что прогрессия есть. Теперь давайте заметим, что массив без одного элемента - это какой-то его префикс плюс суффикс.Что значит, это это объединение есть прогрессия? Что, во-первых, каждый из них является прогрессией, и, во-вторых, что их можно \"склеить\". Т.е. что пара (an, b1) не конфликтует ни с первой прогрессией, ни со второй.Теперь у нас есть цикл, внутри которого идёт куча вызовов вида check(0, 0), check(0, 1), check(0, 2) и т.д. Их можно объединить в один и с запоминанием результатов на каждом шаге. Это даёт линейное решение со всеми разобранными случаями.E. Пентагон (спасибо, @Sereja)Пускай массив Q означает наличие ребра между двумя вершинами, а st - степень вершины.Для начала для каждой пары посчитаем количество вершин которые \"лежат между ними\", иными словами, достижимы от обоих из них. Запишем эти данные в массив A (это можно сделать за кубическое время).После того, как мы знаем эти данные, переберем 3 вершины из цикла, две из которых будут лежать \"рядом\" в цикле. Назовём их i, j и l (Q[i,j]=1). Тогда возьмем две переменные, которые будут отвечать за количество вершин \"между\" i и l , j и l. Это будут значения A[i, l] и A[j,l], но при этом, в случае Q[j, l] = 1 от первого нужно отнять 1, для второго - аналогично. Это делается для того, чтобы никакая вершина не входила в цикл два раза. К ответу добавим произведение этих значений. Есть еще один отдельный случай: когда Q[i, l]=1 и Q[j, l]=1, то от ответа нужно отнять st[l]-2? Чтобы понять это, нужно на листке бумажки расписать, как будут происходить добавления новых циклов, и через какие вершины мы их пропустим.Полученный ответ делим на 5 для удаления повторов (каждый цикл мы считаем из каждой его вершины), это и будет финальный ответ.В комментариях есть обобщённое решение на случай более длинных циклов.F. ГусеницаСсылка",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/1038",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 6340
        }
      ],
      "code_examples": [],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring s;\nsize_t pos;\n\nbool parseTABLE();\nbool parseROWS();\nbool parseROW();\nbool parseCELLS();\nbool parseCELL();\nbool consume(const string& token);\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    vector<string> lines;\n    int line_count = 0;\n    while (!inf.seekEof()) {\n        ensuref(line_count < 10, \"Number of lines exceeds 10\");\n        string line = inf.readLine();\n        line_count++;\n        ensuref(!line.empty(), \"Line %d is empty\", line_count);\n        ensuref(line.find(' ') == string::npos, \"Line %d contains spaces\", line_count);\n        lines.push_back(line);\n    }\n    ensuref(line_count <= 10, \"Number of lines exceeds 10\");\n    inf.readEof();\n\n    // Concatenate lines to form s\n    s = \"\";\n    for (const auto& line : lines) {\n        s += line;\n    }\n    ensuref(s.size() <= 5000, \"Length of concatenated string exceeds 5000\");\n\n    // Check that s contains only allowed characters\n    for (char c : s) {\n        ensuref((c >= 'a' && c <= 'z') || c == '<' || c == '>' || c == '/', \"Invalid character '%c' in input\", c);\n    }\n\n    pos = 0;\n    ensuref(parseTABLE(), \"Input does not conform to TABLE grammar\");\n    ensuref(pos == s.size(), \"Extra characters after parsing at position %zu\", pos);\n\n    return 0;\n}\n\nbool consume(const string& token) {\n    if (pos + token.size() > s.size())\n        return false;\n    if (s.compare(pos, token.size(), token) == 0) {\n        pos += token.size();\n        return true;\n    }\n    return false;\n}\n\nbool parseTABLE() {\n    size_t startPos = pos;\n    if (!consume(\"<table>\"))\n        return false;\n    if (!parseROWS()) {\n        pos = startPos;\n        return false;\n    }\n    if (!consume(\"</table>\")) {\n        pos = startPos;\n        return false;\n    }\n    return true;\n}\n\nbool parseROWS() {\n    if (!parseROW())\n        return false;\n    while (true) {\n        size_t savedPos = pos;\n        if (!parseROW()) {\n            pos = savedPos;\n            break;\n        }\n    }\n    return true;\n}\n\nbool parseROW() {\n    size_t startPos = pos;\n    if (!consume(\"<tr>\"))\n        return false;\n    if (!parseCELLS()) {\n        pos = startPos;\n        return false;\n    }\n    if (!consume(\"</tr>\")) {\n        pos = startPos;\n        return false;\n    }\n    return true;\n}\n\nbool parseCELLS() {\n    if (!parseCELL())\n        return false;\n    while (true) {\n        size_t savedPos = pos;\n        if (!parseCELL()) {\n            pos = savedPos;\n            break;\n        }\n    }\n    return true;\n}\n\nbool parseCELL() {\n    size_t startPos = pos;\n    if (!consume(\"<td>\"))\n        return false;\n    if (consume(\"</td>\")) {\n        // Empty cell\n        return true;\n    } else {\n        if (!parseTABLE()) {\n            pos = startPos;\n            return false;\n        }\n        if (!consume(\"</td>\")) {\n            pos = startPos;\n            return false;\n        }\n        return true;\n    }\n}\n\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring s;\nsize_t pos;\n\nbool parseTABLE();\nbool parseROWS();\nbool parseROW();\nbool parseCELLS();\nbool parseCELL();\nbool consume(const string& token);\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    vector<string> lines;\n    int line_count = 0;\n    while (!inf.seekEof()) {\n        ensuref(line_count < 10, \"Number of lines exceeds 10\");\n        string line = inf.readLine();\n        line_count++;\n        ensuref(!line.empty(), \"Line %d is empty\", line_count);\n        ensuref(line.find(' ') == string::npos, \"Line %d contains spaces\", line_count);\n        lines.push_back(line);\n    }\n    ensuref(line_count <= 10, \"Number of lines exceeds 10\");\n    inf.readEof();\n\n    // Concatenate lines to form s\n    s = \"\";\n    for (const auto& line : lines) {\n        s += line;\n    }\n    ensuref(s.size() <= 5000, \"Length of concatenated string exceeds 5000\");\n\n    // Check that s contains only allowed characters\n    for (char c : s) {\n        ensuref((c >= 'a' && c <= 'z') || c == '<' || c == '>' || c == '/', \"Invalid character '%c' in input\", c);\n    }\n\n    pos = 0;\n    ensuref(parseTABLE(), \"Input does not conform to TABLE grammar\");\n    ensuref(pos == s.size(), \"Extra characters after parsing at position %zu\", pos);\n\n    return 0;\n}\n\nbool consume(const string& token) {\n    if (pos + token.size() > s.size())\n        return false;\n    if (s.compare(pos, token.size(), token) == 0) {\n        pos += token.size();\n        return true;\n    }\n    return false;\n}\n\nbool parseTABLE() {\n    size_t startPos = pos;\n    if (!consume(\"<table>\"))\n        return false;\n    if (!parseROWS()) {\n        pos = startPos;\n        return false;\n    }\n    if (!consume(\"</table>\")) {\n        pos = startPos;\n        return false;\n    }\n    return true;\n}\n\nbool parseROWS() {\n    if (!parseROW())\n        return false;\n    while (true) {\n        size_t savedPos = pos;\n        if (!parseROW()) {\n            pos = savedPos;\n            break;\n        }\n    }\n    return true;\n}\n\nbool parseROW() {\n    size_t startPos = pos;\n    if (!consume(\"<tr>\"))\n        return false;\n    if (!parseCELLS()) {\n        pos = startPos;\n        return false;\n    }\n    if (!consume(\"</tr>\")) {\n        pos = startPos;\n        return false;\n    }\n    return true;\n}\n\nbool parseCELLS() {\n    if (!parseCELL())\n        return false;\n    while (true) {\n        size_t savedPos = pos;\n        if (!parseCELL()) {\n            pos = savedPos;\n            break;\n        }\n    }\n    return true;\n}\n\nbool parseCELL() {\n    size_t startPos = pos;\n    if (!consume(\"<td>\"))\n        return false;\n    if (consume(\"</td>\")) {\n        // Empty cell\n        return true;\n    } else {\n        if (!parseTABLE()) {\n            pos = startPos;\n            return false;\n        }\n        if (!consume(\"</td>\")) {\n            pos = startPos;\n            return false;\n        }\n        return true;\n    }\n}\n\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring s;\nsize_t pos;\n\nbool parseTABLE();\nbool parseROWS();\nbool parseROW();\nbool parseCELLS();\nbool parseCELL();\nbool consume(const string& token);\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    vector<string> lines;\n    int line_count = 0;\n    while (!inf.seekEof()) {\n        ensuref(line_count < 10, \"Number of lines exceeds 10\");\n        string line = inf.readLine();\n        line_count++;\n        ensuref(!line.empty(), \"Line %d is empty\", line_count);\n        ensuref(line.find(' ') == string::npos, \"Line %d contains spaces\", line_count);\n        lines.push_back(line);\n    }\n    ensuref(line_count <= 10, \"Number of lines exceeds 10\");\n    inf.readEof();\n\n    // Concatenate lines to form s\n    s = \"\";\n    for (const auto& line : lines) {\n        s += line;\n    }\n    ensuref(s.size() <= 5000, \"Length of concatenated string exceeds 5000\");\n\n    // Check that s contains only allowed characters\n    for (char c : s) {\n        ensuref((c >= 'a' && c <= 'z') || c == '<' || c == '>' || c == '/', \"Invalid character '%c' in input\", c);\n    }\n\n    pos = 0;\n    ensuref(parseTABLE(), \"Input does not conform to TABLE grammar\");\n    ensuref(pos == s.size(), \"Extra characters after parsing at position %zu\", pos);\n\n    return 0;\n}\n\nbool consume(const string& token) {\n    if (pos + token.size() > s.size())\n        return false;\n    if (s.compare(pos, token.size(), token) == 0) {\n        pos += token.size();\n        return true;\n    }\n    return false;\n}\n\nbool parseTABLE() {\n    size_t startPos = pos;\n    if (!consume(\"<table>\"))\n        return false;\n    if (!parseROWS()) {\n        pos = startPos;\n        return false;\n    }\n    if (!consume(\"</table>\")) {\n        pos = startPos;\n        return false;\n    }\n    return true;\n}\n\nbool parseROWS() {\n    if (!parseROW())\n        return false;\n    while (true) {\n        size_t savedPos = pos;\n        if (!parseROW()) {\n            pos = savedPos;\n            break;\n        }\n    }\n    return true;\n}\n\nbool parseROW() {\n    size_t startPos = pos;\n    if (!consume(\"<tr>\"))\n        return false;\n    if (!parseCELLS()) {\n        pos = startPos;\n        return false;\n    }\n    if (!consume(\"</tr>\")) {\n        pos = startPos;\n        return false;\n    }\n    return true;\n}\n\nbool parseCELLS() {\n    if (!parseCELL())\n        return false;\n    while (true) {\n        size_t savedPos = pos;\n        if (!parseCELL()) {\n            pos = savedPos;\n            break;\n        }\n    }\n    return true;\n}\n\nbool parseCELL() {\n    size_t startPos = pos;\n    if (!consume(\"<td>\"))\n        return false;\n    if (consume(\"</td>\")) {\n        // Empty cell\n        return true;\n    } else {\n        if (!parseTABLE()) {\n            pos = startPos;\n            return false;\n        }\n        if (!consume(\"</td>\")) {\n            pos = startPos;\n            return false;\n        }\n        return true;\n    }\n}\n\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst int table_open_len = 7;    // <table>\nconst int table_close_len = 8;   // </table>\nconst int tr_open_len = 4;       // <tr>\nconst int tr_close_len = 5;      // </tr>\nconst int td_open_len = 4;       // <td>\nconst int td_close_len =5;       // </td>\n\nstring generate_table(int depth, int max_depth, int& total_length, int len, int type);\nstring generate_rows(int depth, int max_depth, int& total_length, int len, int type);\nstring generate_row(int depth, int max_depth, int& total_length, int len, int type);\nstring generate_cells(int depth, int max_depth, int& total_length, int len, int type);\nstring generate_cell(int depth, int max_depth, int& total_length, int len, int type);\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int len = opt<int>(\"len\", 5000);\n    int max_depth = opt<int>(\"depth\", 10);\n    string type_str = opt<string>(\"type\", \"random\");\n    int type = 0;  // 0: random, 1: max_depth, 2: max_cells, 3: max_size\n    if (type_str == \"max_depth\") type = 1;\n    else if (type_str == \"max_cells\") type = 2;\n    else if (type_str == \"max_size\") type = 3;\n\n    int total_length = 0;\n    string s = generate_table(0, max_depth, total_length, len, type);\n\n    // Split s into up to 10 non-empty lines arbitrarily\n    int max_lines = min(10, (int)s.size());\n    int num_lines = rnd.next(1, max_lines);\n    vector<int> split_pos = {0};\n    for (int i = 1; i < num_lines; ++i) {\n        int pos = rnd.next(split_pos.back() + 1, (int)s.size() - (num_lines - i));\n        split_pos.push_back(pos);\n    }\n    split_pos.push_back(s.size());\n    for (int i = 0; i < num_lines; ++i) {\n        cout << s.substr(split_pos[i], split_pos[i+1] - split_pos[i]) << endl;\n    }\n\n    return 0;\n}\n\nstring generate_table(int depth, int max_depth, int& total_length, int len, int type) {\n    if (total_length + table_open_len + table_close_len > len) {\n        return \"\"; // Can't add a table\n    }\n    string result = \"<table>\";\n    total_length += table_open_len;\n\n    string rows = generate_rows(depth, max_depth, total_length, len, type);\n    if (rows.empty()) {\n        // We must have at least one row\n        // Try to add an empty row\n        if (total_length + tr_open_len + tr_close_len + td_open_len + td_close_len > len) {\n            // Can't even add one row with one empty cell\n            total_length -= table_open_len; // Undo\n            return \"\"; // Can't add further\n        } else {\n            // Manually add one row with one empty cell\n            result += \"<tr><td></td></tr>\";\n            total_length += tr_open_len + tr_close_len + td_open_len + td_close_len;\n        }\n    } else {\n        result += rows;\n    }\n    result += \"</table>\";\n    total_length += table_close_len;\n\n    return result;\n}\n\nstring generate_rows(int depth, int max_depth, int& total_length, int len, int type) {\n    string result;\n    int num_rows;\n    if (type == 2 || type == 3) {\n        // Maximize number of rows for max_cells or max_size\n        num_rows = len; // Attempt to generate as many rows as possible within length\n    } else if (type == 0) {\n        num_rows = rnd.next(1, 3); // Random number of rows\n    } else {\n        num_rows = 1; // For max_depth, minimize rows\n    }\n    for (int i = 0; i < num_rows; ++i) {\n        string row = generate_row(depth, max_depth, total_length, len, type);\n        if (row.empty()) {\n            break;\n        }\n        result += row;\n    }\n    return result;\n}\n\nstring generate_row(int depth, int max_depth, int& total_length, int len, int type) {\n    if (total_length + tr_open_len + tr_close_len > len) {\n        return \"\";\n    }\n    string result = \"<tr>\";\n    total_length += tr_open_len;\n\n    string cells = generate_cells(depth, max_depth, total_length, len, type);\n    if (cells.empty()) {\n        // We must have at least one cell\n        if (total_length + td_open_len + td_close_len > len) {\n            total_length -= tr_open_len; // Undo\n            return \"\"; // Can't add a row with even one empty cell\n        } else {\n            // Manually add one empty cell\n            result += \"<td></td>\";\n            total_length += td_open_len + td_close_len;\n        }\n    } else {\n        result += cells;\n    }\n    result += \"</tr>\";\n    total_length += tr_close_len;\n    return result;\n}\n\nstring generate_cells(int depth, int max_depth, int& total_length, int len, int type) {\n    string result;\n    int num_cells;\n    if (type == 2 || type == 3) {\n        // Maximize number of cells\n        num_cells = len; // Attempt to generate as many cells as possible within length\n    } else if (type == 0) {\n        num_cells = rnd.next(1, 3); // Random number of cells\n    } else {\n        num_cells = 1; // For max_depth, minimize cells\n    }\n    for (int i = 0; i < num_cells; ++i) {\n        string cell = generate_cell(depth, max_depth, total_length, len, type);\n        if (cell.empty()) {\n            break;\n        }\n        result += cell;\n    }\n    return result;\n}\n\nstring generate_cell(int depth, int max_depth, int& total_length, int len, int type) {\n    if (total_length + td_open_len + td_close_len > len) {\n        return \"\";\n    }\n    string result = \"<td>\";\n    total_length += td_open_len;\n    if (type == 1) {\n        // Maximize depth\n        if (depth < max_depth) {\n            string nested_table = generate_table(depth + 1, max_depth, total_length, len, type);\n            if (!nested_table.empty()) {\n                result += nested_table;\n            }\n        }\n    } else if (type == 2) {\n        // Maximize number of cells, avoid nesting\n        // Do nothing, leave cell empty\n    } else if (type == 3) {\n        // Maximize size, random nesting\n        if (depth < max_depth && total_length + table_open_len + table_close_len + tr_open_len + tr_close_len + td_open_len + td_close_len <= len) {\n            string nested_table = generate_table(depth + 1, max_depth, total_length, len, type);\n            if (!nested_table.empty()) {\n                result += nested_table;\n            }\n        }\n    } else {\n        // Random\n        if (depth < max_depth && rnd.next(0, 1) == 0) {\n            // Randomly decide to generate nested table\n            string nested_table = generate_table(depth + 1, max_depth, total_length, len, type);\n            if (!nested_table.empty()) {\n                result += nested_table;\n            }\n        }\n    }\n    result += \"</td>\";\n    total_length += td_close_len;\n    return result;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst int table_open_len = 7;    // <table>\nconst int table_close_len = 8;   // </table>\nconst int tr_open_len = 4;       // <tr>\nconst int tr_close_len = 5;      // </tr>\nconst int td_open_len = 4;       // <td>\nconst int td_close_len =5;       // </td>\n\nstring generate_table(int depth, int max_depth, int& total_length, int len, int type);\nstring generate_rows(int depth, int max_depth, int& total_length, int len, int type);\nstring generate_row(int depth, int max_depth, int& total_length, int len, int type);\nstring generate_cells(int depth, int max_depth, int& total_length, int len, int type);\nstring generate_cell(int depth, int max_depth, int& total_length, int len, int type);\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int len = opt<int>(\"len\", 5000);\n    int max_depth = opt<int>(\"depth\", 10);\n    string type_str = opt<string>(\"type\", \"random\");\n    int type = 0;  // 0: random, 1: max_depth, 2: max_cells, 3: max_size\n    if (type_str == \"max_depth\") type = 1;\n    else if (type_str == \"max_cells\") type = 2;\n    else if (type_str == \"max_size\") type = 3;\n\n    int total_length = 0;\n    string s = generate_table(0, max_depth, total_length, len, type);\n\n    // Split s into up to 10 non-empty lines arbitrarily\n    int max_lines = min(10, (int)s.size());\n    int num_lines = rnd.next(1, max_lines);\n    vector<int> split_pos = {0};\n    for (int i = 1; i < num_lines; ++i) {\n        int pos = rnd.next(split_pos.back() + 1, (int)s.size() - (num_lines - i));\n        split_pos.push_back(pos);\n    }\n    split_pos.push_back(s.size());\n    for (int i = 0; i < num_lines; ++i) {\n        cout << s.substr(split_pos[i], split_pos[i+1] - split_pos[i]) << endl;\n    }\n\n    return 0;\n}\n\nstring generate_table(int depth, int max_depth, int& total_length, int len, int type) {\n    if (total_length + table_open_len + table_close_len > len) {\n        return \"\"; // Can't add a table\n    }\n    string result = \"<table>\";\n    total_length += table_open_len;\n\n    string rows = generate_rows(depth, max_depth, total_length, len, type);\n    if (rows.empty()) {\n        // We must have at least one row\n        // Try to add an empty row\n        if (total_length + tr_open_len + tr_close_len + td_open_len + td_close_len > len) {\n            // Can't even add one row with one empty cell\n            total_length -= table_open_len; // Undo\n            return \"\"; // Can't add further\n        } else {\n            // Manually add one row with one empty cell\n            result += \"<tr><td></td></tr>\";\n            total_length += tr_open_len + tr_close_len + td_open_len + td_close_len;\n        }\n    } else {\n        result += rows;\n    }\n    result += \"</table>\";\n    total_length += table_close_len;\n\n    return result;\n}\n\nstring generate_rows(int depth, int max_depth, int& total_length, int len, int type) {\n    string result;\n    int num_rows;\n    if (type == 2 || type == 3) {\n        // Maximize number of rows for max_cells or max_size\n        num_rows = len; // Attempt to generate as many rows as possible within length\n    } else if (type == 0) {\n        num_rows = rnd.next(1, 3); // Random number of rows\n    } else {\n        num_rows = 1; // For max_depth, minimize rows\n    }\n    for (int i = 0; i < num_rows; ++i) {\n        string row = generate_row(depth, max_depth, total_length, len, type);\n        if (row.empty()) {\n            break;\n        }\n        result += row;\n    }\n    return result;\n}\n\nstring generate_row(int depth, int max_depth, int& total_length, int len, int type) {\n    if (total_length + tr_open_len + tr_close_len > len) {\n        return \"\";\n    }\n    string result = \"<tr>\";\n    total_length += tr_open_len;\n\n    string cells = generate_cells(depth, max_depth, total_length, len, type);\n    if (cells.empty()) {\n        // We must have at least one cell\n        if (total_length + td_open_len + td_close_len > len) {\n            total_length -= tr_open_len; // Undo\n            return \"\"; // Can't add a row with even one empty cell\n        } else {\n            // Manually add one empty cell\n            result += \"<td></td>\";\n            total_length += td_open_len + td_close_len;\n        }\n    } else {\n        result += cells;\n    }\n    result += \"</tr>\";\n    total_length += tr_close_len;\n    return result;\n}\n\nstring generate_cells(int depth, int max_depth, int& total_length, int len, int type) {\n    string result;\n    int num_cells;\n    if (type == 2 || type == 3) {\n        // Maximize number of cells\n        num_cells = len; // Attempt to generate as many cells as possible within length\n    } else if (type == 0) {\n        num_cells = rnd.next(1, 3); // Random number of cells\n    } else {\n        num_cells = 1; // For max_depth, minimize cells\n    }\n    for (int i = 0; i < num_cells; ++i) {\n        string cell = generate_cell(depth, max_depth, total_length, len, type);\n        if (cell.empty()) {\n            break;\n        }\n        result += cell;\n    }\n    return result;\n}\n\nstring generate_cell(int depth, int max_depth, int& total_length, int len, int type) {\n    if (total_length + td_open_len + td_close_len > len) {\n        return \"\";\n    }\n    string result = \"<td>\";\n    total_length += td_open_len;\n    if (type == 1) {\n        // Maximize depth\n        if (depth < max_depth) {\n            string nested_table = generate_table(depth + 1, max_depth, total_length, len, type);\n            if (!nested_table.empty()) {\n                result += nested_table;\n            }\n        }\n    } else if (type == 2) {\n        // Maximize number of cells, avoid nesting\n        // Do nothing, leave cell empty\n    } else if (type == 3) {\n        // Maximize size, random nesting\n        if (depth < max_depth && total_length + table_open_len + table_close_len + tr_open_len + tr_close_len + td_open_len + td_close_len <= len) {\n            string nested_table = generate_table(depth + 1, max_depth, total_length, len, type);\n            if (!nested_table.empty()) {\n                result += nested_table;\n            }\n        }\n    } else {\n        // Random\n        if (depth < max_depth && rnd.next(0, 1) == 0) {\n            // Randomly decide to generate nested table\n            string nested_table = generate_table(depth + 1, max_depth, total_length, len, type);\n            if (!nested_table.empty()) {\n                result += nested_table;\n            }\n        }\n    }\n    result += \"</td>\";\n    total_length += td_close_len;\n    return result;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -len 50 -type random\n./gen -len 100 -type random\n./gen -len 200 -type random\n./gen -len 300 -type random\n\n./gen -len 500 -depth 5 -type random\n./gen -len 500 -depth 10 -type random\n./gen -len 500 -depth 15 -type random\n\n./gen -len 1000 -depth 5 -type random\n./gen -len 1000 -depth 10 -type random\n./gen -len 1000 -depth 15 -type random\n\n./gen -len 5000 -depth 10 -type random\n./gen -len 5000 -depth 20 -type random\n./gen -len 5000 -depth 30 -type random\n\n./gen -len 5000 -depth 100 -type max_depth\n\n./gen -len 5000 -type max_cells\n\n./gen -len 5000 -type max_size\n\n./gen -len 5000 -depth 1 -type max_cells\n\n./gen -len 5000 -depth 50 -type max_depth\n\n./gen -len 5000 -depth 1000 -type max_depth\n\n./gen -len 100 -depth 5 -type max_depth\n./gen -len 200 -depth 10 -type max_depth\n\n./gen -len 500 -type random\n./gen -len 1000 -type random\n./gen -len 2000 -type random\n./gen -len 3000 -type random\n./gen -len 4000 -type random\n./gen -len 5000 -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:41:24.822749",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "51/C",
      "title": "C. Three Base Stations",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains an integer n (1 ≤ n ≤ 2·105) which represents the number of houses in the village. The second line contains the coordinates of houses — the sequence x1, x2, ..., xn of integer numbers (1 ≤ xi ≤ 109). It is possible that two or more houses are located on one point. The coordinates are given in a arbitrary order.",
      "output_spec": "OutputPrint the required minimal power d. In the second line print three numbers — the possible coordinates of the base stations' location. Print the coordinates with 6 digits after the decimal point. The positions of the stations can be any from 0 to 2·109 inclusively. It is accepted for the base stations to have matching coordinates. If there are many solutions, print any of them.",
      "sample_tests": "ExamplesInputCopy41 2 3 4OutputCopy0.5000001.500000 2.500000 3.500000InputCopy310 20 30OutputCopy010.000000 20.000000 30.000000InputCopy510003 10004 10001 10002 1OutputCopy0.5000001.000000 10001.500000 10003.500000",
      "description": "C. Three Base Stations\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains an integer n (1 ≤ n ≤ 2·105) which represents the number of houses in the village. The second line contains the coordinates of houses — the sequence x1, x2, ..., xn of integer numbers (1 ≤ xi ≤ 109). It is possible that two or more houses are located on one point. The coordinates are given in a arbitrary order.\n\nOutputPrint the required minimal power d. In the second line print three numbers — the possible coordinates of the base stations' location. Print the coordinates with 6 digits after the decimal point. The positions of the stations can be any from 0 to 2·109 inclusively. It is accepted for the base stations to have matching coordinates. If there are many solutions, print any of them.\n\nInputCopy41 2 3 4OutputCopy0.5000001.500000 2.500000 3.500000InputCopy310 20 30OutputCopy010.000000 20.000000 30.000000InputCopy510003 10004 10001 10002 1OutputCopy0.5000001.000000 10001.500000 10003.500000\n\nInputCopy41 2 3 4\n\nOutputCopy0.5000001.500000 2.500000 3.500000\n\nInputCopy310 20 30\n\nOutputCopy010.000000 20.000000 30.000000\n\nInputCopy510003 10004 10001 10002 1\n\nOutputCopy0.5000001.000000 10001.500000 10003.500000",
      "solutions": [
        {
          "title": "Codeforces Beta Round #48 - Codeforces",
          "content": "Hello!I invite you to participate in Codeforces Beta Round #48. This time I acted as the author of the contest. I believe it is really exciting too! I urge you to follow my example. Codeforces is happy to contest authors.With contest proposals please contact RAD (our problem coordinator).Participants are waiting for your problems!UPD:PDF statements will be also available after the contest start. Please, use the link.I wish you beautiful solutions,MikeMirzayanov",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/1030",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 465
        },
        {
          "title": "Разбор задачек R#48 - Codeforces",
          "content": "Еще вопрос: кто-нибудь знает, как поставить ссылку на профиль пользователя в посте? A. Задача ЧитериусаВ этой задаче теоретически могли быть следующие проблемы: считывание, сравнивание, \"я не прочитал, что n<=1000\" и \"электричка опоздала на 10 минут к началу раунда\". У меня была последняя :)Считывать можно было либо построчно, либо по токенам. Всё языки это умеют.Сравнивать два квадрата можно опять же как угодно. Я делал так: считал две строчки, соеденил в одну и поменял 3й и 4й местами. Получилась \"ленточка\". Две \"ленточки\" можно сравнить двумя циклами: первый перебирает сдвиг, второй проверяет, что всё совпало.Далее оставалось лишь посчитать количество стопок. Это можно было делать так: перебираем все непомеченные квадратики, добавляем один к ответу и помечаем все квадратики, которые равны текущему. B. Анализ таблиц bHTMLЗадача тоже не ахти какая сложнае, если знать, как строятся парсеры в общем виде.Для начала требовалось прочитать все строчки и склеить их в одну.После чего поступаем так: заводим указатель на текущий рассматриваемый символ. Изначально он равен нулю. Затем делаем вспомогательную процедуру \"прочитать строку\". Она пытается посимвольно прочитать что-нибудь, начиная с текущего символа, и, если удалось - возвращает True и перемещает указатель вправо, если нет - возвращает False, и указатель не трогает.После этого можно написать рекурсивные процедуры ReadCell, ReadRow и ReadTable - каждая из них возвращает количество ячеек в текущей таблице.ReadCell работает так: прочитать <td>, если дальше не удалось прочитать </td>, добавить к ответу ReadTable() и прочитать </td>. Вернуть 1.ReadRow: считали <tr>, пока не удаётся прочитать </tr>, делаем ReadCell. Вернуть сумму по всем ReadCell.ReadTable: считали <table>, пока не удаётся прочитать </table>, делаем ReadRow. Вернуть сумму по всем ReadRow.В конце надо посортировать количества ячеек во всех таблицах и вывести.Также можно было делать так: завести функцию getTag, которая возвращает какой из 6 тегов был, а далее разобрать три случая:\"table\" => stack.push_back(0)\"td\" => stack.top++\"/table\" => ans.push_back( stack.top() ), stack.pop_back()C. Три базовых станцииДля начала упростим себе задачу: посортируем дома и удалим одинаковые. Теперь давайте в цикле переберём самый правый дом, который покрывает первая станция.Этот дом однозначно определяет её минимальную мощность. Далее хочется быстро найти границу для второй станции. Что мы хотим минимизировать? Максимум из мощности второй и третьей станций (т.к. первая у нас уже фиксированна). При движении границы слева направо мощность второй растёт, а третьей - убывает. Соответственно, максимум из этих двух величин до какого-то времени невозрастает, а затем - неубывает. Хотим найти момент этого перехода - в нем и будет искомый минимум. Это можно сделать при помощи указателя, т.к. этот момент всегда движется только направо.Т.о. получаем решение за линейное время.D. Геометрическая задачаПервое, что требовалось вспомнить - бываю еще и нули.Давайте для начала научимся понимать, является ли последовательность геометрической прогрессией. У каждой прогресси либо есть знаменатель b  (возможно, 0), либо он может быть любым (c=0). Для каждых двух соседних элементов опять же, либо есть однозначные знаменатель, либо нет. Собирав эту информацию со всех элементов и проверив на непротиворечивость, мы убедимся что последовательнось - прогрессия.Побежим по последовательности слева направо. Заведём две переменные - знаменатель последовательности (b) и флаг, определили ли мы его уже (exb). Вначале exb=false.Далее мы обрабатываем элемент (a1) и предыдущий (a0). Мы должны проверить, что они не конфликтуют с уже известной информацией и что они вообще могут встретиться рядом хоть в какой-то последовательности. Если это так, то нам надо пересчитать знаменатель (если a0 != 0), иначе сразу возвращаем false.Для проверки на конфликты у меня была функция equal. Она работает следующим образом: если a0 = 0, то надо проверить, что a1 = 0 и вернуть true, иначе выбросить исключение. Иначе, если знаменатель еще не определён, то вернуть true. В противном случае проверить, что отношение элементов и знаменатель совпадают.Если в конце оказалось, что конфликтов и исключений не было, то да, такая геометрическая прогрессия есть.Теперь у нас есть функция проверки, является ли последовательность прогрессией. Мы уже можем написать квадратичное решение. Для получения OK нам требуется чуть-чуть изменить квадрат и сделать precalc.Как работает тупой квадрат? Выкидываем по очереди элементы и проверяем, что прогрессия есть. Теперь давайте заметим, что массив без одного элемента - это какой-то его префикс плюс суффикс.Что значит, это это объединение есть прогрессия? Что, во-первых, каждый из них является прогрессией, и, во-вторых, что их можно \"склеить\". Т.е. что пара (an, b1) не конфликтует ни с первой прогрессией, ни со второй.Теперь у нас есть цикл, внутри которого идёт куча вызовов вида check(0, 0), check(0, 1), check(0, 2) и т.д. Их можно объединить в один и с запоминанием результатов на каждом шаге. Это даёт линейное решение со всеми разобранными случаями.E. Пентагон (спасибо, @Sereja)Пускай массив Q означает наличие ребра между двумя вершинами, а st - степень вершины.Для начала для каждой пары посчитаем количество вершин которые \"лежат между ними\", иными словами, достижимы от обоих из них. Запишем эти данные в массив A (это можно сделать за кубическое время).После того, как мы знаем эти данные, переберем 3 вершины из цикла, две из которых будут лежать \"рядом\" в цикле. Назовём их i, j и l (Q[i,j]=1). Тогда возьмем две переменные, которые будут отвечать за количество вершин \"между\" i и l , j и l. Это будут значения A[i, l] и A[j,l], но при этом, в случае Q[j, l] = 1 от первого нужно отнять 1, для второго - аналогично. Это делается для того, чтобы никакая вершина не входила в цикл два раза. К ответу добавим произведение этих значений. Есть еще один отдельный случай: когда Q[i, l]=1 и Q[j, l]=1, то от ответа нужно отнять st[l]-2? Чтобы понять это, нужно на листке бумажки расписать, как будут происходить добавления новых циклов, и через какие вершины мы их пропустим.Полученный ответ делим на 5 для удаления повторов (каждый цикл мы считаем из каждой его вершины), это и будет финальный ответ.В комментариях есть обобщённое решение на случай более длинных циклов.F. ГусеницаСсылка",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/1038",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 6340
        }
      ],
      "code_examples": [],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 200000, \"n\");\n    inf.readEoln();\n    vector<int> x = inf.readInts(n, 1, 1000000000, \"xi\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 200000, \"n\");\n    inf.readEoln();\n    vector<int> x = inf.readInts(n, 1, 1000000000, \"xi\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 200000, \"n\");\n    inf.readEoln();\n    vector<int> x = inf.readInts(n, 1, 1000000000, \"xi\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst double EPS = 1E-6;\n\nint n;\nvector<long long> xi;\n\nvoid readInput() {\n    n = inf.readInt();\n    xi.resize(n);\n    for (int i = 0; i < n; ++i) {\n        xi[i] = inf.readLong(1LL, 1000000000LL, \"xi\");\n    }\n}\n\nvoid readAnswer(InStream& inStream, double& d_ans, vector<double>& t_ans) {\n    d_ans = inStream.readReal(0.0, 2000000000.0, \"d\");\n    t_ans.resize(3);\n    for (int i = 0; i < 3; ++i) {\n        t_ans[i] = inStream.readReal(0.0, 2000000000.0, format(\"t[%d]\", i + 1).c_str());\n    }\n}\n\nbool isCovered(long long x, double t, double d) {\n    return x >= t - d - EPS && x <= t + d + EPS;\n}\n\nint main(int argc, char* argv[]) {\n    registerTestlibCmd(argc, argv);\n\n    readInput();\n\n    double d_judge;\n    vector<double> t_judge;\n    readAnswer(ans, d_judge, t_judge);\n\n    double d_contestant;\n    vector<double> t_contestant;\n    readAnswer(ouf, d_contestant, t_contestant);\n\n    // Check if d_contestant is not greater than d_judge + EPS\n    if (d_contestant > d_judge + EPS)\n        quitf(_wa, \"d = %.6f is not minimal, should be at most %.6f\", d_contestant, d_judge);\n    else if (d_contestant < d_judge - EPS)\n        quitf(_fail, \"Participant found better minimal d: participant d = %.6f, judge d = %.6f\", d_contestant, d_judge);\n\n    // Check that all houses are covered\n    for (int i = 0; i < n; ++i) {\n        bool covered = false;\n        for (int j = 0; j < 3; ++j) {\n            if (isCovered(xi[i], t_contestant[j], d_contestant)) {\n                covered = true;\n                break;\n            }\n        }\n        if (!covered)\n            quitf(_wa, \"House at position %lld is not covered\", xi[i]);\n    }\n\n    quitf(_ok, \"All houses are covered with d = %.6f\", d_contestant);\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n    int k = opt<int>(\"k\", 3); // number of clusters, default 3\n\n    vector<int> xi(n);\n\n    if (type == \"random\") {\n        for (int i = 0; i < n; ++i)\n            xi[i] = rnd.next(1, 1000000000); // [1, 1e9]\n    } else if (type == \"same_point\") {\n        int x = rnd.next(1, 1000000000);\n        for (int i = 0; i < n; ++i)\n            xi[i] = x;\n    } else if (type == \"cluster\") {\n        // Generate k clusters\n        vector<int> centers(k);\n        for (int i = 0; i < k; ++i)\n            centers[i] = rnd.next(1, 1000000000);\n        vector<int> cluster_sizes(k, n / k);\n        for (int i = 0; i < n % k; ++i)\n            cluster_sizes[i]++; // Distribute remaining houses\n\n        int idx = 0;\n        for (int i = 0; i < k; ++i) {\n            int cluster_size = cluster_sizes[i];\n            int center = centers[i];\n            for (int j = 0; j < cluster_size; ++j) {\n                // Generate xi around center\n                int deviation = rnd.next(-1000, 1000); // small deviation\n                xi[idx++] = max(1, min(1000000000, center + deviation));\n            }\n        }\n    } else if (type == \"max_min\") {\n        for (int i = 0; i < n; ++i) {\n            xi[i] = rnd.next(0,1) ? 1 : 1000000000;\n        }\n    } else if (type == \"heavy_left\") {\n        for (int i = 0; i < n; ++i)\n            xi[i] = rnd.next(1, 1000); // [1, 1000]\n    } else if (type == \"heavy_right\") {\n        for (int i = 0; i < n; ++i)\n            xi[i] = rnd.next(1000000000 - 1000, 1000000000); // [1e9 - 1000, 1e9]\n    } else if (type == \"duplicates\") {\n        for (int i = 0; i < n; ++i)\n            xi[i] = rnd.next(1, 1000000000); // [1, 1e9]\n        for (int i = 0; i < n / 2; ++i)\n            xi[i] = xi[0]; // Introduce duplicates\n    } else {\n        // Default to random\n        for (int i = 0; i < n; ++i)\n            xi[i] = rnd.next(1, 1000000000); // [1, 1e9]\n    }\n\n    // Now, shuffle xi to meet \"arbitrary order\" constraint\n    shuffle(xi.begin(), xi.end());\n\n    // Output\n    printf(\"%d\\n\", n);\n    for (int i = 0; i < n; ++i)\n        printf(\"%d%c\", xi[i], i+1 == n ? '\\n' : ' ');\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n    int k = opt<int>(\"k\", 3); // number of clusters, default 3\n\n    vector<int> xi(n);\n\n    if (type == \"random\") {\n        for (int i = 0; i < n; ++i)\n            xi[i] = rnd.next(1, 1000000000); // [1, 1e9]\n    } else if (type == \"same_point\") {\n        int x = rnd.next(1, 1000000000);\n        for (int i = 0; i < n; ++i)\n            xi[i] = x;\n    } else if (type == \"cluster\") {\n        // Generate k clusters\n        vector<int> centers(k);\n        for (int i = 0; i < k; ++i)\n            centers[i] = rnd.next(1, 1000000000);\n        vector<int> cluster_sizes(k, n / k);\n        for (int i = 0; i < n % k; ++i)\n            cluster_sizes[i]++; // Distribute remaining houses\n\n        int idx = 0;\n        for (int i = 0; i < k; ++i) {\n            int cluster_size = cluster_sizes[i];\n            int center = centers[i];\n            for (int j = 0; j < cluster_size; ++j) {\n                // Generate xi around center\n                int deviation = rnd.next(-1000, 1000); // small deviation\n                xi[idx++] = max(1, min(1000000000, center + deviation));\n            }\n        }\n    } else if (type == \"max_min\") {\n        for (int i = 0; i < n; ++i) {\n            xi[i] = rnd.next(0,1) ? 1 : 1000000000;\n        }\n    } else if (type == \"heavy_left\") {\n        for (int i = 0; i < n; ++i)\n            xi[i] = rnd.next(1, 1000); // [1, 1000]\n    } else if (type == \"heavy_right\") {\n        for (int i = 0; i < n; ++i)\n            xi[i] = rnd.next(1000000000 - 1000, 1000000000); // [1e9 - 1000, 1e9]\n    } else if (type == \"duplicates\") {\n        for (int i = 0; i < n; ++i)\n            xi[i] = rnd.next(1, 1000000000); // [1, 1e9]\n        for (int i = 0; i < n / 2; ++i)\n            xi[i] = xi[0]; // Introduce duplicates\n    } else {\n        // Default to random\n        for (int i = 0; i < n; ++i)\n            xi[i] = rnd.next(1, 1000000000); // [1, 1e9]\n    }\n\n    // Now, shuffle xi to meet \"arbitrary order\" constraint\n    shuffle(xi.begin(), xi.end());\n\n    // Output\n    printf(\"%d\\n\", n);\n    for (int i = 0; i < n; ++i)\n        printf(\"%d%c\", xi[i], i+1 == n ? '\\n' : ' ');\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 10 -type random\n./gen -n 10 -type same_point\n./gen -n 10 -type cluster -k 1\n./gen -n 10 -type cluster -k 2\n./gen -n 10 -type cluster -k 3\n./gen -n 10 -type cluster -k 4\n./gen -n 10 -type max_min\n./gen -n 10 -type heavy_left\n./gen -n 10 -type heavy_right\n./gen -n 10 -type duplicates\n\n./gen -n 1000 -type random\n./gen -n 1000 -type same_point\n./gen -n 1000 -type cluster -k 1\n./gen -n 1000 -type cluster -k 2\n./gen -n 1000 -type cluster -k 3\n./gen -n 1000 -type cluster -k 4\n./gen -n 1000 -type max_min\n./gen -n 1000 -type heavy_left\n./gen -n 1000 -type heavy_right\n./gen -n 1000 -type duplicates\n\n./gen -n 200000 -type random\n./gen -n 200000 -type same_point\n./gen -n 200000 -type cluster -k 1\n./gen -n 200000 -type cluster -k 2\n./gen -n 200000 -type cluster -k 3\n./gen -n 200000 -type cluster -k 4\n./gen -n 200000 -type max_min\n./gen -n 200000 -type heavy_left\n./gen -n 200000 -type heavy_right\n./gen -n 200000 -type duplicates\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:41:27.087764",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "51/D",
      "title": "D. Geometrical problem",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains an integer n (1 ≤ n ≤ 105) — the number of elements in the given sequence. The second line contains the given sequence. The numbers are space-separated. All the elements of the given sequence are integers and their absolute value does not exceed 104.",
      "output_spec": "OutputPrint 0, if the given sequence is a geometric progression. Otherwise, check if it is possible to make the sequence a geometric progression by deleting a single element. If it is possible, print 1. If it is impossible, print 2.",
      "sample_tests": "ExamplesInputCopy43 6 12 24OutputCopy0InputCopy4-8 -16 24 -32OutputCopy1InputCopy40 1 2 3OutputCopy2",
      "description": "D. Geometrical problem\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains an integer n (1 ≤ n ≤ 105) — the number of elements in the given sequence. The second line contains the given sequence. The numbers are space-separated. All the elements of the given sequence are integers and their absolute value does not exceed 104.\n\nOutputPrint 0, if the given sequence is a geometric progression. Otherwise, check if it is possible to make the sequence a geometric progression by deleting a single element. If it is possible, print 1. If it is impossible, print 2.\n\nInputCopy43 6 12 24OutputCopy0InputCopy4-8 -16 24 -32OutputCopy1InputCopy40 1 2 3OutputCopy2\n\nInputCopy43 6 12 24\n\nOutputCopy0\n\nInputCopy4-8 -16 24 -32\n\nOutputCopy1\n\nInputCopy40 1 2 3\n\nOutputCopy2",
      "solutions": [
        {
          "title": "Codeforces Beta Round #48 - Codeforces",
          "content": "Hello!I invite you to participate in Codeforces Beta Round #48. This time I acted as the author of the contest. I believe it is really exciting too! I urge you to follow my example. Codeforces is happy to contest authors.With contest proposals please contact RAD (our problem coordinator).Participants are waiting for your problems!UPD:PDF statements will be also available after the contest start. Please, use the link.I wish you beautiful solutions,MikeMirzayanov",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/1030",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 465
        },
        {
          "title": "Разбор задачек R#48 - Codeforces",
          "content": "Еще вопрос: кто-нибудь знает, как поставить ссылку на профиль пользователя в посте? A. Задача ЧитериусаВ этой задаче теоретически могли быть следующие проблемы: считывание, сравнивание, \"я не прочитал, что n<=1000\" и \"электричка опоздала на 10 минут к началу раунда\". У меня была последняя :)Считывать можно было либо построчно, либо по токенам. Всё языки это умеют.Сравнивать два квадрата можно опять же как угодно. Я делал так: считал две строчки, соеденил в одну и поменял 3й и 4й местами. Получилась \"ленточка\". Две \"ленточки\" можно сравнить двумя циклами: первый перебирает сдвиг, второй проверяет, что всё совпало.Далее оставалось лишь посчитать количество стопок. Это можно было делать так: перебираем все непомеченные квадратики, добавляем один к ответу и помечаем все квадратики, которые равны текущему. B. Анализ таблиц bHTMLЗадача тоже не ахти какая сложнае, если знать, как строятся парсеры в общем виде.Для начала требовалось прочитать все строчки и склеить их в одну.После чего поступаем так: заводим указатель на текущий рассматриваемый символ. Изначально он равен нулю. Затем делаем вспомогательную процедуру \"прочитать строку\". Она пытается посимвольно прочитать что-нибудь, начиная с текущего символа, и, если удалось - возвращает True и перемещает указатель вправо, если нет - возвращает False, и указатель не трогает.После этого можно написать рекурсивные процедуры ReadCell, ReadRow и ReadTable - каждая из них возвращает количество ячеек в текущей таблице.ReadCell работает так: прочитать <td>, если дальше не удалось прочитать </td>, добавить к ответу ReadTable() и прочитать </td>. Вернуть 1.ReadRow: считали <tr>, пока не удаётся прочитать </tr>, делаем ReadCell. Вернуть сумму по всем ReadCell.ReadTable: считали <table>, пока не удаётся прочитать </table>, делаем ReadRow. Вернуть сумму по всем ReadRow.В конце надо посортировать количества ячеек во всех таблицах и вывести.Также можно было делать так: завести функцию getTag, которая возвращает какой из 6 тегов был, а далее разобрать три случая:\"table\" => stack.push_back(0)\"td\" => stack.top++\"/table\" => ans.push_back( stack.top() ), stack.pop_back()C. Три базовых станцииДля начала упростим себе задачу: посортируем дома и удалим одинаковые. Теперь давайте в цикле переберём самый правый дом, который покрывает первая станция.Этот дом однозначно определяет её минимальную мощность. Далее хочется быстро найти границу для второй станции. Что мы хотим минимизировать? Максимум из мощности второй и третьей станций (т.к. первая у нас уже фиксированна). При движении границы слева направо мощность второй растёт, а третьей - убывает. Соответственно, максимум из этих двух величин до какого-то времени невозрастает, а затем - неубывает. Хотим найти момент этого перехода - в нем и будет искомый минимум. Это можно сделать при помощи указателя, т.к. этот момент всегда движется только направо.Т.о. получаем решение за линейное время.D. Геометрическая задачаПервое, что требовалось вспомнить - бываю еще и нули.Давайте для начала научимся понимать, является ли последовательность геометрической прогрессией. У каждой прогресси либо есть знаменатель b  (возможно, 0), либо он может быть любым (c=0). Для каждых двух соседних элементов опять же, либо есть однозначные знаменатель, либо нет. Собирав эту информацию со всех элементов и проверив на непротиворечивость, мы убедимся что последовательнось - прогрессия.Побежим по последовательности слева направо. Заведём две переменные - знаменатель последовательности (b) и флаг, определили ли мы его уже (exb). Вначале exb=false.Далее мы обрабатываем элемент (a1) и предыдущий (a0). Мы должны проверить, что они не конфликтуют с уже известной информацией и что они вообще могут встретиться рядом хоть в какой-то последовательности. Если это так, то нам надо пересчитать знаменатель (если a0 != 0), иначе сразу возвращаем false.Для проверки на конфликты у меня была функция equal. Она работает следующим образом: если a0 = 0, то надо проверить, что a1 = 0 и вернуть true, иначе выбросить исключение. Иначе, если знаменатель еще не определён, то вернуть true. В противном случае проверить, что отношение элементов и знаменатель совпадают.Если в конце оказалось, что конфликтов и исключений не было, то да, такая геометрическая прогрессия есть.Теперь у нас есть функция проверки, является ли последовательность прогрессией. Мы уже можем написать квадратичное решение. Для получения OK нам требуется чуть-чуть изменить квадрат и сделать precalc.Как работает тупой квадрат? Выкидываем по очереди элементы и проверяем, что прогрессия есть. Теперь давайте заметим, что массив без одного элемента - это какой-то его префикс плюс суффикс.Что значит, это это объединение есть прогрессия? Что, во-первых, каждый из них является прогрессией, и, во-вторых, что их можно \"склеить\". Т.е. что пара (an, b1) не конфликтует ни с первой прогрессией, ни со второй.Теперь у нас есть цикл, внутри которого идёт куча вызовов вида check(0, 0), check(0, 1), check(0, 2) и т.д. Их можно объединить в один и с запоминанием результатов на каждом шаге. Это даёт линейное решение со всеми разобранными случаями.E. Пентагон (спасибо, @Sereja)Пускай массив Q означает наличие ребра между двумя вершинами, а st - степень вершины.Для начала для каждой пары посчитаем количество вершин которые \"лежат между ними\", иными словами, достижимы от обоих из них. Запишем эти данные в массив A (это можно сделать за кубическое время).После того, как мы знаем эти данные, переберем 3 вершины из цикла, две из которых будут лежать \"рядом\" в цикле. Назовём их i, j и l (Q[i,j]=1). Тогда возьмем две переменные, которые будут отвечать за количество вершин \"между\" i и l , j и l. Это будут значения A[i, l] и A[j,l], но при этом, в случае Q[j, l] = 1 от первого нужно отнять 1, для второго - аналогично. Это делается для того, чтобы никакая вершина не входила в цикл два раза. К ответу добавим произведение этих значений. Есть еще один отдельный случай: когда Q[i, l]=1 и Q[j, l]=1, то от ответа нужно отнять st[l]-2? Чтобы понять это, нужно на листке бумажки расписать, как будут происходить добавления новых циклов, и через какие вершины мы их пропустим.Полученный ответ делим на 5 для удаления повторов (каждый цикл мы считаем из каждой его вершины), это и будет финальный ответ.В комментариях есть обобщённое решение на случай более длинных циклов.F. ГусеницаСсылка",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/1038",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 6340
        }
      ],
      "code_examples": [],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n    vector<int> a = inf.readInts(n, -10000, 10000, \"a_i\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n    vector<int> a = inf.readInts(n, -10000, 10000, \"a_i\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n    vector<int> a = inf.readInts(n, -10000, 10000, \"a_i\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]){\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\");\n\n    if (type == \"gp\") {\n        vector<int> seq(n);\n        int choice = rnd.next(1, 4);\n        int c;\n        if (choice == 1) {\n            // Constant sequence\n            c = rnd.next(-10000, 10000);\n            for (int i = 0; i < n; ++i) {\n                seq[i] = c;\n            }\n        } else if (choice == 2) {\n            // Alternating sequence\n            c = rnd.next(-10000, 10000);\n            for (int i = 0; i < n; ++i) {\n                seq[i] = (i % 2 == 0) ? c : -c;\n            }\n        } else if (choice == 3) {\n            // c followed by zeros\n            c = rnd.next(-10000, 10000);\n            seq[0] = c;\n            for (int i = 1; i < n; ++i) {\n                seq[i] = 0;\n            }\n        } else {\n            // All zeros\n            for (int i = 0; i < n; ++i) {\n                seq[i] = 0;\n            }\n        }\n        // Output n\n        printf(\"%d\\n\", n);\n        // Output sequence\n        for (int i = 0; i < n; ++i) {\n            printf(\"%d%c\", seq[i], i == n - 1 ? '\\n' : ' ');\n        }\n    } else if (type == \"almost_gp\") {\n        vector<int> seq(n - 1);\n        int choice = rnd.next(1, 4);\n        int c;\n        if (choice == 1) {\n            // Constant sequence\n            c = rnd.next(-10000, 10000);\n            for (int i = 0; i < n - 1; ++i) {\n                seq[i] = c;\n            }\n        } else if (choice == 2) {\n            // Alternating sequence\n            c = rnd.next(-10000, 10000);\n            for (int i = 0; i < n - 1; ++i) {\n                seq[i] = (i % 2 == 0) ? c : -c;\n            }\n        } else if (choice ==3) {\n            // c followed by zeros\n            c = rnd.next(-10000, 10000);\n            seq[0] = c;\n            for (int i = 1; i < n - 1; i++) {\n                seq[i] = 0;\n            }\n        } else {\n            // All zeros\n            for (int i = 0; i < n -1 ; i++) {\n                seq[i] = 0;\n            }\n            c = 0;\n        }\n        // Now insert an element at random position\n        int pos = rnd.next(0, n - 1);\n        vector<int> full_seq(n);\n        for (int i = 0; i < pos; ++i) {\n            full_seq[i] = seq[i];\n        }\n        // Generate a value that is different from c and breaks the GP\n        int bad_val;\n        do {\n            bad_val = rnd.next(-10000, 10000);\n        } while ((bad_val == c || bad_val == -c || bad_val == 0));\n        full_seq[pos] = bad_val;\n        for (int i = pos + 1; i < n; ++i) {\n            full_seq[i] = seq[i - 1];\n        }\n        // Output n\n        printf(\"%d\\n\", n);\n        // Output sequence\n        for (int i = 0; i < n; ++i) {\n            printf(\"%d%c\", full_seq[i], i == n - 1 ? '\\n' : ' ');\n        }\n    } else if (type == \"not_gp\") {\n        // Generate a random sequence where each element is random in [-10000, 10000]\n        vector<int> seq(n);\n        for (int i = 0; i < n; ++i) {\n            seq[i] = rnd.next(-10000, 10000);\n        }\n        // Output n\n        printf(\"%d\\n\", n);\n        // Output sequence\n        for (int i = 0; i < n; ++i) {\n            printf(\"%d%c\", seq[i], i == n - 1 ? '\\n' : ' ');\n        }\n    }\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]){\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\");\n\n    if (type == \"gp\") {\n        vector<int> seq(n);\n        int choice = rnd.next(1, 4);\n        int c;\n        if (choice == 1) {\n            // Constant sequence\n            c = rnd.next(-10000, 10000);\n            for (int i = 0; i < n; ++i) {\n                seq[i] = c;\n            }\n        } else if (choice == 2) {\n            // Alternating sequence\n            c = rnd.next(-10000, 10000);\n            for (int i = 0; i < n; ++i) {\n                seq[i] = (i % 2 == 0) ? c : -c;\n            }\n        } else if (choice == 3) {\n            // c followed by zeros\n            c = rnd.next(-10000, 10000);\n            seq[0] = c;\n            for (int i = 1; i < n; ++i) {\n                seq[i] = 0;\n            }\n        } else {\n            // All zeros\n            for (int i = 0; i < n; ++i) {\n                seq[i] = 0;\n            }\n        }\n        // Output n\n        printf(\"%d\\n\", n);\n        // Output sequence\n        for (int i = 0; i < n; ++i) {\n            printf(\"%d%c\", seq[i], i == n - 1 ? '\\n' : ' ');\n        }\n    } else if (type == \"almost_gp\") {\n        vector<int> seq(n - 1);\n        int choice = rnd.next(1, 4);\n        int c;\n        if (choice == 1) {\n            // Constant sequence\n            c = rnd.next(-10000, 10000);\n            for (int i = 0; i < n - 1; ++i) {\n                seq[i] = c;\n            }\n        } else if (choice == 2) {\n            // Alternating sequence\n            c = rnd.next(-10000, 10000);\n            for (int i = 0; i < n - 1; ++i) {\n                seq[i] = (i % 2 == 0) ? c : -c;\n            }\n        } else if (choice ==3) {\n            // c followed by zeros\n            c = rnd.next(-10000, 10000);\n            seq[0] = c;\n            for (int i = 1; i < n - 1; i++) {\n                seq[i] = 0;\n            }\n        } else {\n            // All zeros\n            for (int i = 0; i < n -1 ; i++) {\n                seq[i] = 0;\n            }\n            c = 0;\n        }\n        // Now insert an element at random position\n        int pos = rnd.next(0, n - 1);\n        vector<int> full_seq(n);\n        for (int i = 0; i < pos; ++i) {\n            full_seq[i] = seq[i];\n        }\n        // Generate a value that is different from c and breaks the GP\n        int bad_val;\n        do {\n            bad_val = rnd.next(-10000, 10000);\n        } while ((bad_val == c || bad_val == -c || bad_val == 0));\n        full_seq[pos] = bad_val;\n        for (int i = pos + 1; i < n; ++i) {\n            full_seq[i] = seq[i - 1];\n        }\n        // Output n\n        printf(\"%d\\n\", n);\n        // Output sequence\n        for (int i = 0; i < n; ++i) {\n            printf(\"%d%c\", full_seq[i], i == n - 1 ? '\\n' : ' ');\n        }\n    } else if (type == \"not_gp\") {\n        // Generate a random sequence where each element is random in [-10000, 10000]\n        vector<int> seq(n);\n        for (int i = 0; i < n; ++i) {\n            seq[i] = rnd.next(-10000, 10000);\n        }\n        // Output n\n        printf(\"%d\\n\", n);\n        // Output sequence\n        for (int i = 0; i < n; ++i) {\n            printf(\"%d%c\", seq[i], i == n - 1 ? '\\n' : ' ');\n        }\n    }\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -type gp\n./gen -n 2 -type gp\n./gen -n 3 -type gp\n./gen -n 5 -type gp\n./gen -n 10 -type gp\n./gen -n 1000 -type gp\n./gen -n 100000 -type gp\n\n./gen -n 1 -type almost_gp\n./gen -n 2 -type almost_gp\n./gen -n 3 -type almost_gp\n./gen -n 5 -type almost_gp\n./gen -n 10 -type almost_gp\n./gen -n 1000 -type almost_gp\n./gen -n 100000 -type almost_gp\n\n./gen -n 1 -type not_gp\n./gen -n 2 -type not_gp\n./gen -n 3 -type not_gp\n./gen -n 5 -type not_gp\n./gen -n 10 -type not_gp\n./gen -n 1000 -type not_gp\n./gen -n 100000 -type not_gp\n\n./gen -n 99999 -type gp\n./gen -n 99999 -type almost_gp\n./gen -n 99999 -type not_gp\n./gen -n 50000 -type gp\n./gen -n 50000 -type almost_gp\n./gen -n 50000 -type not_gp\n\n./gen -n 99998 -type gp\n./gen -n 99998 -type almost_gp\n./gen -n 99998 -type not_gp\n\n./gen -n 4 -type gp\n./gen -n 4 -type almost_gp\n./gen -n 4 -type not_gp\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:41:29.132977",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "51/E",
      "title": "E. Пентагон",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест10 seconds",
      "memory_limit": "ограничение по памяти на тест256 megabytes",
      "input_spec": "Входные данныеВ первой строке записаны два целых числа n и m (1 ≤ n ≤ 700;0 ≤ m ≤ n·(n - 1) / 2), n — количество перекрестков, а m — количество дорог в городе. Далее в m строках содержатся описания дорог, по одной дороге в строке. Каждая дорога задана парой целых чисел ai, bi (1 ≤ ai, bi ≤ n;ai ≠ bi), где ai и bi — номера соединяемых дорогой перекрестков. Перекрестки занумерованы от 1 до n. Не гарантируется, что из любого перекрестка можно добраться в любой другой, двигаясь по дорогам.",
      "output_spec": "Выходные данныеВыведите единственное число — искомое количество способов. Пожалуйста, не используйте спецификатор %lld для чтения или записи 64-х битовых чисел на С++. Рекомендуется использовать поток cout (также вы можете использовать спецификатор %I64d).",
      "sample_tests": "ПримерыВходные данныеСкопировать5 51 22 33 44 55 1Выходные данныеСкопировать1Входные данныеСкопировать5 101 21 31 41 52 32 42 53 43 54 5Выходные данныеСкопировать12",
      "description": "E. Пентагон\n\nограничение по времени на тест10 seconds\n\nограничение по времени на тест\n\nограничение по памяти на тест256 megabytes\n\nограничение по памяти на тест\n\nвыводstdout\n\nВходные данныеВ первой строке записаны два целых числа n и m (1 ≤ n ≤ 700;0 ≤ m ≤ n·(n - 1) / 2), n — количество перекрестков, а m — количество дорог в городе. Далее в m строках содержатся описания дорог, по одной дороге в строке. Каждая дорога задана парой целых чисел ai, bi (1 ≤ ai, bi ≤ n;ai ≠ bi), где ai и bi — номера соединяемых дорогой перекрестков. Перекрестки занумерованы от 1 до n. Не гарантируется, что из любого перекрестка можно добраться в любой другой, двигаясь по дорогам.\n\nВходные данные\n\nВыходные данныеВыведите единственное число — искомое количество способов. Пожалуйста, не используйте спецификатор %lld для чтения или записи 64-х битовых чисел на С++. Рекомендуется использовать поток cout (также вы можете использовать спецификатор %I64d).\n\nВыходные данные\n\nВходные данныеСкопировать5 51 22 33 44 55 1Выходные данныеСкопировать1Входные данныеСкопировать5 101 21 31 41 52 32 42 53 43 54 5Выходные данныеСкопировать12\n\nВходные данныеСкопировать5 51 22 33 44 55 1\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать1\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать5 101 21 31 41 52 32 42 53 43 54 5\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать12\n\nВыходные данныеСкопировать\n\nСкопировать",
      "solutions": [
        {
          "title": "Codeforces Beta Round #48 - Codeforces",
          "content": "Всем привет!Приглашаю вас принять участие в Codeforces Beta Round #48. В этот раз я выступил в роли автора контеста - приятно знаете ли иногда попридумывать задачки :) Вас же я призываю последовать моем примеру. Проект Codeforces всегда рад как новым авторам, так и тем, кто уже выступал в этой роли. С предложениями пишите Артему Рахову (координатору задач проекта). Участники ждут ваших задач!UPD:Для удобства и некоторой подстраховки, условия задач будут доступны по ссылке.А вам я желаю красивых решений,MikeMirzayanov",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/1030",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 522
        },
        {
          "title": "Разбор задачек R#48 - Codeforces",
          "content": "Еще вопрос: кто-нибудь знает, как поставить ссылку на профиль пользователя в посте? A. Задача ЧитериусаВ этой задаче теоретически могли быть следующие проблемы: считывание, сравнивание, \"я не прочитал, что n<=1000\" и \"электричка опоздала на 10 минут к началу раунда\". У меня была последняя :)Считывать можно было либо построчно, либо по токенам. Всё языки это умеют.Сравнивать два квадрата можно опять же как угодно. Я делал так: считал две строчки, соеденил в одну и поменял 3й и 4й местами. Получилась \"ленточка\". Две \"ленточки\" можно сравнить двумя циклами: первый перебирает сдвиг, второй проверяет, что всё совпало.Далее оставалось лишь посчитать количество стопок. Это можно было делать так: перебираем все непомеченные квадратики, добавляем один к ответу и помечаем все квадратики, которые равны текущему. B. Анализ таблиц bHTMLЗадача тоже не ахти какая сложнае, если знать, как строятся парсеры в общем виде.Для начала требовалось прочитать все строчки и склеить их в одну.После чего поступаем так: заводим указатель на текущий рассматриваемый символ. Изначально он равен нулю. Затем делаем вспомогательную процедуру \"прочитать строку\". Она пытается посимвольно прочитать что-нибудь, начиная с текущего символа, и, если удалось - возвращает True и перемещает указатель вправо, если нет - возвращает False, и указатель не трогает.После этого можно написать рекурсивные процедуры ReadCell, ReadRow и ReadTable - каждая из них возвращает количество ячеек в текущей таблице.ReadCell работает так: прочитать <td>, если дальше не удалось прочитать </td>, добавить к ответу ReadTable() и прочитать </td>. Вернуть 1.ReadRow: считали <tr>, пока не удаётся прочитать </tr>, делаем ReadCell. Вернуть сумму по всем ReadCell.ReadTable: считали <table>, пока не удаётся прочитать </table>, делаем ReadRow. Вернуть сумму по всем ReadRow.В конце надо посортировать количества ячеек во всех таблицах и вывести.Также можно было делать так: завести функцию getTag, которая возвращает какой из 6 тегов был, а далее разобрать три случая:\"table\" => stack.push_back(0)\"td\" => stack.top++\"/table\" => ans.push_back( stack.top() ), stack.pop_back()C. Три базовых станцииДля начала упростим себе задачу: посортируем дома и удалим одинаковые. Теперь давайте в цикле переберём самый правый дом, который покрывает первая станция.Этот дом однозначно определяет её минимальную мощность. Далее хочется быстро найти границу для второй станции. Что мы хотим минимизировать? Максимум из мощности второй и третьей станций (т.к. первая у нас уже фиксированна). При движении границы слева направо мощность второй растёт, а третьей - убывает. Соответственно, максимум из этих двух величин до какого-то времени невозрастает, а затем - неубывает. Хотим найти момент этого перехода - в нем и будет искомый минимум. Это можно сделать при помощи указателя, т.к. этот момент всегда движется только направо.Т.о. получаем решение за линейное время.D. Геометрическая задачаПервое, что требовалось вспомнить - бываю еще и нули.Давайте для начала научимся понимать, является ли последовательность геометрической прогрессией. У каждой прогресси либо есть знаменатель b  (возможно, 0), либо он может быть любым (c=0). Для каждых двух соседних элементов опять же, либо есть однозначные знаменатель, либо нет. Собирав эту информацию со всех элементов и проверив на непротиворечивость, мы убедимся что последовательнось - прогрессия.Побежим по последовательности слева направо. Заведём две переменные - знаменатель последовательности (b) и флаг, определили ли мы его уже (exb). Вначале exb=false.Далее мы обрабатываем элемент (a1) и предыдущий (a0). Мы должны проверить, что они не конфликтуют с уже известной информацией и что они вообще могут встретиться рядом хоть в какой-то последовательности. Если это так, то нам надо пересчитать знаменатель (если a0 != 0), иначе сразу возвращаем false.Для проверки на конфликты у меня была функция equal. Она работает следующим образом: если a0 = 0, то надо проверить, что a1 = 0 и вернуть true, иначе выбросить исключение. Иначе, если знаменатель еще не определён, то вернуть true. В противном случае проверить, что отношение элементов и знаменатель совпадают.Если в конце оказалось, что конфликтов и исключений не было, то да, такая геометрическая прогрессия есть.Теперь у нас есть функция проверки, является ли последовательность прогрессией. Мы уже можем написать квадратичное решение. Для получения OK нам требуется чуть-чуть изменить квадрат и сделать precalc.Как работает тупой квадрат? Выкидываем по очереди элементы и проверяем, что прогрессия есть. Теперь давайте заметим, что массив без одного элемента - это какой-то его префикс плюс суффикс.Что значит, это это объединение есть прогрессия? Что, во-первых, каждый из них является прогрессией, и, во-вторых, что их можно \"склеить\". Т.е. что пара (an, b1) не конфликтует ни с первой прогрессией, ни со второй.Теперь у нас есть цикл, внутри которого идёт куча вызовов вида check(0, 0), check(0, 1), check(0, 2) и т.д. Их можно объединить в один и с запоминанием результатов на каждом шаге. Это даёт линейное решение со всеми разобранными случаями.E. Пентагон (спасибо, @Sereja)Пускай массив Q означает наличие ребра между двумя вершинами, а st - степень вершины.Для начала для каждой пары посчитаем количество вершин которые \"лежат между ними\", иными словами, достижимы от обоих из них. Запишем эти данные в массив A (это можно сделать за кубическое время).После того, как мы знаем эти данные, переберем 3 вершины из цикла, две из которых будут лежать \"рядом\" в цикле. Назовём их i, j и l (Q[i,j]=1). Тогда возьмем две переменные, которые будут отвечать за количество вершин \"между\" i и l , j и l. Это будут значения A[i, l] и A[j,l], но при этом, в случае Q[j, l] = 1 от первого нужно отнять 1, для второго - аналогично. Это делается для того, чтобы никакая вершина не входила в цикл два раза. К ответу добавим произведение этих значений. Есть еще один отдельный случай: когда Q[i, l]=1 и Q[j, l]=1, то от ответа нужно отнять st[l]-2? Чтобы понять это, нужно на листке бумажки расписать, как будут происходить добавления новых циклов, и через какие вершины мы их пропустим.Полученный ответ делим на 5 для удаления повторов (каждый цикл мы считаем из каждой его вершины), это и будет финальный ответ.В комментариях есть обобщённое решение на случай более длинных циклов.F. ГусеницаСсылка",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/1038",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 6340
        }
      ],
      "code_examples": [],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 700, \"n\");\n    inf.readSpace();\n    int maxm = n * (n - 1) / 2;\n    int m = inf.readInt(0, maxm, \"m\");\n    inf.readEoln();\n\n    set<pair<int, int>> edges;\n\n    for (int i = 0; i < m; i++) {\n        int a = inf.readInt(1, n, \"ai\");\n        inf.readSpace();\n        int b = inf.readInt(1, n, \"bi\");\n        inf.readEoln();\n\n        ensuref(a != b, \"Edge %d: ai and bi must not be equal (ai=%d, bi=%d)\", i+1, a, b);\n\n        int u = min(a, b);\n        int v = max(a, b);\n        pair<int, int> edge = make_pair(u, v);\n\n        ensuref(edges.count(edge) == 0, \"Edge %d: duplicate edge between nodes %d and %d\", i+1, u, v);\n\n        edges.insert(edge);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 700, \"n\");\n    inf.readSpace();\n    int maxm = n * (n - 1) / 2;\n    int m = inf.readInt(0, maxm, \"m\");\n    inf.readEoln();\n\n    set<pair<int, int>> edges;\n\n    for (int i = 0; i < m; i++) {\n        int a = inf.readInt(1, n, \"ai\");\n        inf.readSpace();\n        int b = inf.readInt(1, n, \"bi\");\n        inf.readEoln();\n\n        ensuref(a != b, \"Edge %d: ai and bi must not be equal (ai=%d, bi=%d)\", i+1, a, b);\n\n        int u = min(a, b);\n        int v = max(a, b);\n        pair<int, int> edge = make_pair(u, v);\n\n        ensuref(edges.count(edge) == 0, \"Edge %d: duplicate edge between nodes %d and %d\", i+1, u, v);\n\n        edges.insert(edge);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 700, \"n\");\n    inf.readSpace();\n    int maxm = n * (n - 1) / 2;\n    int m = inf.readInt(0, maxm, \"m\");\n    inf.readEoln();\n\n    set<pair<int, int>> edges;\n\n    for (int i = 0; i < m; i++) {\n        int a = inf.readInt(1, n, \"ai\");\n        inf.readSpace();\n        int b = inf.readInt(1, n, \"bi\");\n        inf.readEoln();\n\n        ensuref(a != b, \"Edge %d: ai and bi must not be equal (ai=%d, bi=%d)\", i+1, a, b);\n\n        int u = min(a, b);\n        int v = max(a, b);\n        pair<int, int> edge = make_pair(u, v);\n\n        ensuref(edges.count(edge) == 0, \"Edge %d: duplicate edge between nodes %d and %d\", i+1, u, v);\n\n        edges.insert(edge);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n    int m = opt<int>(\"m\", -1); // total number of edges, default -1\n    int c = opt<int>(\"c\", 2);  // number of components for 'components' type\n\n    vector<pair<int, int>> edges;\n\n    if (type == \"empty\") {\n        // No edges\n        m = 0;\n    } else if (type == \"complete\") {\n        // All possible edges\n        m = n * (n - 1) / 2;\n        for (int i = 1; i <= n; ++i)\n            for (int j = i + 1; j <= n; ++j)\n                edges.push_back(make_pair(i, j));\n    } else if (type == \"path\") {\n        // A simple path from 1 to n\n        m = n - 1;\n        for (int i = 1; i < n; ++i)\n            edges.push_back(make_pair(i, i + 1));\n    } else if (type == \"star\") {\n        // A star graph centered at 1\n        m = n - 1;\n        for (int i = 2; i <= n; ++i)\n            edges.push_back(make_pair(1, i));\n    } else if (type == \"circle\") {\n        // A cycle graph\n        m = n;\n        for (int i = 1; i < n; ++i)\n            edges.push_back(make_pair(i, i + 1));\n        edges.push_back(make_pair(n, 1));\n    } else if (type == \"random\") {\n        // Random edges\n        int max_edges = n * (n - 1) / 2;\n        if (m == -1 || m > max_edges)\n            m = rnd.next(max_edges + 1);\n        set<pair<int, int>> edge_set;\n        while ((int)edge_set.size() < m) {\n            int u = rnd.next(1, n);\n            int v = rnd.next(1, n);\n            if (u == v) continue;\n            if (u > v) swap(u, v);\n            if (edge_set.count(make_pair(u, v)))\n                continue;\n            edge_set.insert(make_pair(u, v));\n        }\n        for (auto e : edge_set)\n            edges.push_back(e);\n    } else if (type == \"components\") {\n        // Graph with multiple components\n        if (c > n) c = n;\n        vector<int> component_sizes(c, n / c);\n        for (int i = 0; i < n % c; ++i)\n            component_sizes[i]++;\n        int node = 1;\n        for (int i = 0; i < c; ++i) {\n            vector<int> nodes;\n            for (int j = 0; j < component_sizes[i]; ++j)\n                nodes.push_back(node++);\n            // Create a random tree in this component\n            for (int j = 1; j < (int)nodes.size(); ++j) {\n                int u = nodes[j];\n                int v = nodes[rnd.next(0, j - 1)];\n                edges.push_back(make_pair(u, v));\n            }\n        }\n        m = edges.size();\n    } else {\n        // Default case: Random graph\n        int max_edges = n * (n - 1) / 2;\n        if (m == -1 || m > max_edges)\n            m = rnd.next(max_edges + 1);\n        set<pair<int, int>> edge_set;\n        while ((int)edge_set.size() < m) {\n            int u = rnd.next(1, n);\n            int v = rnd.next(1, n);\n            if (u == v) continue;\n            if (u > v) swap(u, v);\n            if (edge_set.count(make_pair(u, v)))\n                continue;\n            edge_set.insert(make_pair(u, v));\n        }\n        for (auto e : edge_set)\n            edges.push_back(e);\n    }\n\n    shuffle(edges.begin(), edges.end());\n\n    printf(\"%d %d\\n\", n, m);\n    for (auto e : edges) {\n        printf(\"%d %d\\n\", e.first, e.second);\n    }\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n    int m = opt<int>(\"m\", -1); // total number of edges, default -1\n    int c = opt<int>(\"c\", 2);  // number of components for 'components' type\n\n    vector<pair<int, int>> edges;\n\n    if (type == \"empty\") {\n        // No edges\n        m = 0;\n    } else if (type == \"complete\") {\n        // All possible edges\n        m = n * (n - 1) / 2;\n        for (int i = 1; i <= n; ++i)\n            for (int j = i + 1; j <= n; ++j)\n                edges.push_back(make_pair(i, j));\n    } else if (type == \"path\") {\n        // A simple path from 1 to n\n        m = n - 1;\n        for (int i = 1; i < n; ++i)\n            edges.push_back(make_pair(i, i + 1));\n    } else if (type == \"star\") {\n        // A star graph centered at 1\n        m = n - 1;\n        for (int i = 2; i <= n; ++i)\n            edges.push_back(make_pair(1, i));\n    } else if (type == \"circle\") {\n        // A cycle graph\n        m = n;\n        for (int i = 1; i < n; ++i)\n            edges.push_back(make_pair(i, i + 1));\n        edges.push_back(make_pair(n, 1));\n    } else if (type == \"random\") {\n        // Random edges\n        int max_edges = n * (n - 1) / 2;\n        if (m == -1 || m > max_edges)\n            m = rnd.next(max_edges + 1);\n        set<pair<int, int>> edge_set;\n        while ((int)edge_set.size() < m) {\n            int u = rnd.next(1, n);\n            int v = rnd.next(1, n);\n            if (u == v) continue;\n            if (u > v) swap(u, v);\n            if (edge_set.count(make_pair(u, v)))\n                continue;\n            edge_set.insert(make_pair(u, v));\n        }\n        for (auto e : edge_set)\n            edges.push_back(e);\n    } else if (type == \"components\") {\n        // Graph with multiple components\n        if (c > n) c = n;\n        vector<int> component_sizes(c, n / c);\n        for (int i = 0; i < n % c; ++i)\n            component_sizes[i]++;\n        int node = 1;\n        for (int i = 0; i < c; ++i) {\n            vector<int> nodes;\n            for (int j = 0; j < component_sizes[i]; ++j)\n                nodes.push_back(node++);\n            // Create a random tree in this component\n            for (int j = 1; j < (int)nodes.size(); ++j) {\n                int u = nodes[j];\n                int v = nodes[rnd.next(0, j - 1)];\n                edges.push_back(make_pair(u, v));\n            }\n        }\n        m = edges.size();\n    } else {\n        // Default case: Random graph\n        int max_edges = n * (n - 1) / 2;\n        if (m == -1 || m > max_edges)\n            m = rnd.next(max_edges + 1);\n        set<pair<int, int>> edge_set;\n        while ((int)edge_set.size() < m) {\n            int u = rnd.next(1, n);\n            int v = rnd.next(1, n);\n            if (u == v) continue;\n            if (u > v) swap(u, v);\n            if (edge_set.count(make_pair(u, v)))\n                continue;\n            edge_set.insert(make_pair(u, v));\n        }\n        for (auto e : edge_set)\n            edges.push_back(e);\n    }\n\n    shuffle(edges.begin(), edges.end());\n\n    printf(\"%d %d\\n\", n, m);\n    for (auto e : edges) {\n        printf(\"%d %d\\n\", e.first, e.second);\n    }\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 5 -type empty\n./gen -n 5 -type complete\n./gen -n 5 -type path\n./gen -n 5 -type star\n./gen -n 5 -type circle\n./gen -n 5 -type random -m 3\n./gen -n 5 -type components -c 2\n\n./gen -n 10 -type empty\n./gen -n 10 -type complete\n./gen -n 10 -type path\n./gen -n 10 -type star\n./gen -n 10 -type circle\n./gen -n 10 -type random -m 15\n./gen -n 10 -type components -c 3\n\n./gen -n 100 -type empty\n./gen -n 100 -type complete\n./gen -n 100 -type path\n./gen -n 100 -type star\n./gen -n 100 -type circle\n./gen -n 100 -type random -m 200\n./gen -n 100 -type random -m 1000\n./gen -n 100 -type random -m 4950\n./gen -n 100 -type components -c 5\n\n./gen -n 700 -type empty\n./gen -n 700 -type complete\n./gen -n 700 -type path\n./gen -n 700 -type star\n./gen -n 700 -type circle\n./gen -n 700 -type random -m 1000\n./gen -n 700 -type random -m 50000\n./gen -n 700 -type random -m 100000\n./gen -n 700 -type random -m 245000\n./gen -n 700 -type components -c 2\n./gen -n 700 -type components -c 10\n\n./gen -n 1 -type empty\n./gen -n 2 -type empty\n./gen -n 2 -type complete\n./gen -n 3 -type circle\n\n./gen -n 700 -type random -m 0\n./gen -n 700 -type random -m 1\n./gen -n 700 -type random -m 100\n./gen -n 700 -type components -c 700\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:41:31.254890",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "51/F",
      "title": "F. Гусеница",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест2 seconds",
      "memory_limit": "ограничение по памяти на тест256 megabytes",
      "input_spec": "Входные данныеВ первой строке содержится пара целых чисел n, m (1 ≤ n ≤ 2000;0 ≤ m ≤ 105), n — количество вершин в графе, а m — количество ребер в нем. Далее в m строках заданы ребра графа, по одному ребру в строке. Каждая строка содержит пару целых чисел ai, bi (1 ≤ ai, bi ≤ n;ai ≠ bi), ai, bi — номера соединяемых ребром вершин. Вершины пронумерованы от 1 до n. Между каждой парой вершин может быть не более одного ребра. Заданный граф не обязательно является связным.",
      "output_spec": "Выходные данныеВыведите искомое наименьшее число операций.",
      "sample_tests": "ПримерыВходные данныеСкопировать4 41 22 33 44 2Выходные данныеСкопировать2Входные данныеСкопировать6 31 23 45 6Выходные данныеСкопировать2Входные данныеСкопировать7 61 22 31 44 51 66 7Выходные данныеСкопировать1",
      "description": "F. Гусеница\n\nограничение по времени на тест2 seconds\n\nограничение по времени на тест\n\nограничение по памяти на тест256 megabytes\n\nограничение по памяти на тест\n\nвыводstdout\n\nВходные данныеВ первой строке содержится пара целых чисел n, m (1 ≤ n ≤ 2000;0 ≤ m ≤ 105), n — количество вершин в графе, а m — количество ребер в нем. Далее в m строках заданы ребра графа, по одному ребру в строке. Каждая строка содержит пару целых чисел ai, bi (1 ≤ ai, bi ≤ n;ai ≠ bi), ai, bi — номера соединяемых ребром вершин. Вершины пронумерованы от 1 до n. Между каждой парой вершин может быть не более одного ребра. Заданный граф не обязательно является связным.\n\nВходные данные\n\nВыходные данныеВыведите искомое наименьшее число операций.\n\nВыходные данные\n\nВходные данныеСкопировать4 41 22 33 44 2Выходные данныеСкопировать2Входные данныеСкопировать6 31 23 45 6Выходные данныеСкопировать2Входные данныеСкопировать7 61 22 31 44 51 66 7Выходные данныеСкопировать1\n\nВходные данныеСкопировать4 41 22 33 44 2\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать2\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать6 31 23 45 6\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать2\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать7 61 22 31 44 51 66 7\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать1\n\nВыходные данныеСкопировать\n\nСкопировать",
      "solutions": [
        {
          "title": "Codeforces Beta Round #48 - Codeforces",
          "content": "Всем привет!Приглашаю вас принять участие в Codeforces Beta Round #48. В этот раз я выступил в роли автора контеста - приятно знаете ли иногда попридумывать задачки :) Вас же я призываю последовать моем примеру. Проект Codeforces всегда рад как новым авторам, так и тем, кто уже выступал в этой роли. С предложениями пишите Артему Рахову (координатору задач проекта). Участники ждут ваших задач!UPD:Для удобства и некоторой подстраховки, условия задач будут доступны по ссылке.А вам я желаю красивых решений,MikeMirzayanov",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/1030",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 522
        },
        {
          "title": "Разбор задачек R#48 - Codeforces",
          "content": "Еще вопрос: кто-нибудь знает, как поставить ссылку на профиль пользователя в посте? A. Задача ЧитериусаВ этой задаче теоретически могли быть следующие проблемы: считывание, сравнивание, \"я не прочитал, что n<=1000\" и \"электричка опоздала на 10 минут к началу раунда\". У меня была последняя :)Считывать можно было либо построчно, либо по токенам. Всё языки это умеют.Сравнивать два квадрата можно опять же как угодно. Я делал так: считал две строчки, соеденил в одну и поменял 3й и 4й местами. Получилась \"ленточка\". Две \"ленточки\" можно сравнить двумя циклами: первый перебирает сдвиг, второй проверяет, что всё совпало.Далее оставалось лишь посчитать количество стопок. Это можно было делать так: перебираем все непомеченные квадратики, добавляем один к ответу и помечаем все квадратики, которые равны текущему. B. Анализ таблиц bHTMLЗадача тоже не ахти какая сложнае, если знать, как строятся парсеры в общем виде.Для начала требовалось прочитать все строчки и склеить их в одну.После чего поступаем так: заводим указатель на текущий рассматриваемый символ. Изначально он равен нулю. Затем делаем вспомогательную процедуру \"прочитать строку\". Она пытается посимвольно прочитать что-нибудь, начиная с текущего символа, и, если удалось - возвращает True и перемещает указатель вправо, если нет - возвращает False, и указатель не трогает.После этого можно написать рекурсивные процедуры ReadCell, ReadRow и ReadTable - каждая из них возвращает количество ячеек в текущей таблице.ReadCell работает так: прочитать <td>, если дальше не удалось прочитать </td>, добавить к ответу ReadTable() и прочитать </td>. Вернуть 1.ReadRow: считали <tr>, пока не удаётся прочитать </tr>, делаем ReadCell. Вернуть сумму по всем ReadCell.ReadTable: считали <table>, пока не удаётся прочитать </table>, делаем ReadRow. Вернуть сумму по всем ReadRow.В конце надо посортировать количества ячеек во всех таблицах и вывести.Также можно было делать так: завести функцию getTag, которая возвращает какой из 6 тегов был, а далее разобрать три случая:\"table\" => stack.push_back(0)\"td\" => stack.top++\"/table\" => ans.push_back( stack.top() ), stack.pop_back()C. Три базовых станцииДля начала упростим себе задачу: посортируем дома и удалим одинаковые. Теперь давайте в цикле переберём самый правый дом, который покрывает первая станция.Этот дом однозначно определяет её минимальную мощность. Далее хочется быстро найти границу для второй станции. Что мы хотим минимизировать? Максимум из мощности второй и третьей станций (т.к. первая у нас уже фиксированна). При движении границы слева направо мощность второй растёт, а третьей - убывает. Соответственно, максимум из этих двух величин до какого-то времени невозрастает, а затем - неубывает. Хотим найти момент этого перехода - в нем и будет искомый минимум. Это можно сделать при помощи указателя, т.к. этот момент всегда движется только направо.Т.о. получаем решение за линейное время.D. Геометрическая задачаПервое, что требовалось вспомнить - бываю еще и нули.Давайте для начала научимся понимать, является ли последовательность геометрической прогрессией. У каждой прогресси либо есть знаменатель b  (возможно, 0), либо он может быть любым (c=0). Для каждых двух соседних элементов опять же, либо есть однозначные знаменатель, либо нет. Собирав эту информацию со всех элементов и проверив на непротиворечивость, мы убедимся что последовательнось - прогрессия.Побежим по последовательности слева направо. Заведём две переменные - знаменатель последовательности (b) и флаг, определили ли мы его уже (exb). Вначале exb=false.Далее мы обрабатываем элемент (a1) и предыдущий (a0). Мы должны проверить, что они не конфликтуют с уже известной информацией и что они вообще могут встретиться рядом хоть в какой-то последовательности. Если это так, то нам надо пересчитать знаменатель (если a0 != 0), иначе сразу возвращаем false.Для проверки на конфликты у меня была функция equal. Она работает следующим образом: если a0 = 0, то надо проверить, что a1 = 0 и вернуть true, иначе выбросить исключение. Иначе, если знаменатель еще не определён, то вернуть true. В противном случае проверить, что отношение элементов и знаменатель совпадают.Если в конце оказалось, что конфликтов и исключений не было, то да, такая геометрическая прогрессия есть.Теперь у нас есть функция проверки, является ли последовательность прогрессией. Мы уже можем написать квадратичное решение. Для получения OK нам требуется чуть-чуть изменить квадрат и сделать precalc.Как работает тупой квадрат? Выкидываем по очереди элементы и проверяем, что прогрессия есть. Теперь давайте заметим, что массив без одного элемента - это какой-то его префикс плюс суффикс.Что значит, это это объединение есть прогрессия? Что, во-первых, каждый из них является прогрессией, и, во-вторых, что их можно \"склеить\". Т.е. что пара (an, b1) не конфликтует ни с первой прогрессией, ни со второй.Теперь у нас есть цикл, внутри которого идёт куча вызовов вида check(0, 0), check(0, 1), check(0, 2) и т.д. Их можно объединить в один и с запоминанием результатов на каждом шаге. Это даёт линейное решение со всеми разобранными случаями.E. Пентагон (спасибо, @Sereja)Пускай массив Q означает наличие ребра между двумя вершинами, а st - степень вершины.Для начала для каждой пары посчитаем количество вершин которые \"лежат между ними\", иными словами, достижимы от обоих из них. Запишем эти данные в массив A (это можно сделать за кубическое время).После того, как мы знаем эти данные, переберем 3 вершины из цикла, две из которых будут лежать \"рядом\" в цикле. Назовём их i, j и l (Q[i,j]=1). Тогда возьмем две переменные, которые будут отвечать за количество вершин \"между\" i и l , j и l. Это будут значения A[i, l] и A[j,l], но при этом, в случае Q[j, l] = 1 от первого нужно отнять 1, для второго - аналогично. Это делается для того, чтобы никакая вершина не входила в цикл два раза. К ответу добавим произведение этих значений. Есть еще один отдельный случай: когда Q[i, l]=1 и Q[j, l]=1, то от ответа нужно отнять st[l]-2? Чтобы понять это, нужно на листке бумажки расписать, как будут происходить добавления новых циклов, и через какие вершины мы их пропустим.Полученный ответ делим на 5 для удаления повторов (каждый цикл мы считаем из каждой его вершины), это и будет финальный ответ.В комментариях есть обобщённое решение на случай более длинных циклов.F. ГусеницаСсылка",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/1038",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 6340
        }
      ],
      "code_examples": [],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 2000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(0, 100000, \"m\");\n    inf.readEoln();\n\n    set<pair<int, int>> edges;\n    for (int i = 0; i < m; i++) {\n        int ai = inf.readInt(1, n, \"ai\");\n        inf.readSpace();\n        int bi = inf.readInt(1, n, \"bi\");\n        inf.readEoln();\n\n        ensuref(ai != bi, \"Self-loops are not allowed, but edge (%d, %d) is a loop.\", ai, bi);\n\n        int u = min(ai, bi);\n        int v = max(ai, bi);\n        pair<int, int> edge = make_pair(u, v);\n        ensuref(edges.find(edge) == edges.end(), \"Multiple edges between the same pair of vertices are not allowed, but edge between %d and %d appears multiple times.\", u, v);\n        edges.insert(edge);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 2000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(0, 100000, \"m\");\n    inf.readEoln();\n\n    set<pair<int, int>> edges;\n    for (int i = 0; i < m; i++) {\n        int ai = inf.readInt(1, n, \"ai\");\n        inf.readSpace();\n        int bi = inf.readInt(1, n, \"bi\");\n        inf.readEoln();\n\n        ensuref(ai != bi, \"Self-loops are not allowed, but edge (%d, %d) is a loop.\", ai, bi);\n\n        int u = min(ai, bi);\n        int v = max(ai, bi);\n        pair<int, int> edge = make_pair(u, v);\n        ensuref(edges.find(edge) == edges.end(), \"Multiple edges between the same pair of vertices are not allowed, but edge between %d and %d appears multiple times.\", u, v);\n        edges.insert(edge);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 2000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(0, 100000, \"m\");\n    inf.readEoln();\n\n    set<pair<int, int>> edges;\n    for (int i = 0; i < m; i++) {\n        int ai = inf.readInt(1, n, \"ai\");\n        inf.readSpace();\n        int bi = inf.readInt(1, n, \"bi\");\n        inf.readEoln();\n\n        ensuref(ai != bi, \"Self-loops are not allowed, but edge (%d, %d) is a loop.\", ai, bi);\n\n        int u = min(ai, bi);\n        int v = max(ai, bi);\n        pair<int, int> edge = make_pair(u, v);\n        ensuref(edges.find(edge) == edges.end(), \"Multiple edges between the same pair of vertices are not allowed, but edge between %d and %d appears multiple times.\", u, v);\n        edges.insert(edge);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nvoid gen_caterpillar(int n) {\n    // Generate a random caterpillar\n    // Randomly decide the length of the spine\n    int spine_length = rnd.next(1, n);\n    vector<int> spine(spine_length);\n\n    for(int i = 0; i < spine_length; ++i) {\n        spine[i] = i; // Assign node indices\n    }\n\n    vector<pair<int,int>> edges;\n\n    // Connect the spine\n    for(int i = 1; i < spine_length; ++i) {\n        edges.push_back({spine[i-1], spine[i]});\n    }\n\n    int next_node = spine_length;\n\n    // For remaining nodes, connect them to random nodes on the spine\n    while(next_node < n) {\n        int spine_node = rnd.next(0, spine_length - 1);\n        edges.push_back({spine_node, next_node});\n        ++next_node;\n    }\n\n    // Output the graph\n    int m = edges.size();\n    printf(\"%d %d\\n\", n, m);\n    for(auto e : edges) {\n        printf(\"%d %d\\n\", e.first + 1, e.second + 1);\n    }\n}\n\nvoid gen_random_connected(int n, int m) {\n    // Check that m is valid\n    int max_edges = n * (n - 1) / 2;\n    if (m < n - 1) {\n        printf(\"Error: m must be at least n - 1 for connected graph\\n\");\n        exit(1);\n    }\n    if (m > max_edges) {\n        m = max_edges; // Adjust m to max possible\n    }\n\n    // Generate a tree first\n    vector<pair<int,int>> edges;\n\n    vector<int> nodes(n);\n    for(int i = 0; i < n; ++i)\n        nodes[i] = i;\n    shuffle(nodes.begin(), nodes.end());\n\n    for(int i = 1; i < n; ++i) {\n        int u = nodes[i];\n        int v = nodes[rnd.next(0, i - 1)];\n        edges.push_back({u, v});\n    }\n\n    // Now add extra edges to reach m edges\n    set<pair<int,int>> existing_edges(edges.begin(), edges.end());\n    while((int)edges.size() < m) {\n        int u = rnd.next(0, n -1);\n        int v = rnd.next(0, n -1);\n        if(u == v)\n            continue;\n        pair<int,int> e = minmax(u,v);\n        if(existing_edges.count(e))\n            continue;\n        existing_edges.insert(e);\n        edges.push_back(e);\n    }\n\n    // Output the graph\n    printf(\"%d %d\\n\", n, m);\n    for(auto e : edges) {\n        printf(\"%d %d\\n\", e.first + 1, e.second + 1);\n    }\n}\n\nvoid gen_random_disconnected(int n, int m) {\n    int max_edges = n * (n - 1) / 2;\n    if (m > max_edges) {\n        m = max_edges; // Adjust m to max possible\n    }\n\n    set<pair<int,int>> existing_edges;\n    while((int)existing_edges.size() < m) {\n        int u = rnd.next(0, n -1);\n        int v = rnd.next(0, n -1);\n        if(u == v)\n            continue;\n        pair<int,int> e = minmax(u,v);\n        if(existing_edges.count(e))\n            continue;\n        existing_edges.insert(e);\n    }\n\n    printf(\"%d %d\\n\", n, m);\n    for(auto e : existing_edges) {\n        printf(\"%d %d\\n\", e.first + 1, e.second + 1);\n    }\n}\n\nvoid gen_cycle(int n) {\n    if(n < 3) {\n        printf(\"Error: n must be at least 3 for cycle\\n\");\n        exit(1);\n    }\n\n    vector<pair<int,int>> edges;\n    for(int i = 0; i < n; ++i) {\n        int u = i;\n        int v = (i+1)%n;\n        edges.push_back({u, v});\n    }\n\n    printf(\"%d %d\\n\", n, n);\n    for(auto e : edges) {\n        printf(\"%d %d\\n\", e.first +1, e.second+1);\n    }\n}\n\nvoid gen_complete(int n) {\n    int max_n = 447;\n    if(n > max_n) {\n        printf(\"Error: n must be <= %d for complete graph due to m ≤ 1e5\\n\", max_n);\n        exit(1);\n    }\n    vector<pair<int,int>> edges;\n    for(int u = 0; u < n; ++u) {\n        for(int v = u+1; v < n; ++v) {\n            edges.push_back({u,v});\n        }\n    }\n\n    int m = edges.size();\n    printf(\"%d %d\\n\", n, m);\n    for(auto e : edges) {\n        printf(\"%d %d\\n\", e.first +1, e.second+1);\n    }\n}\n\nvoid gen_star(int n) {\n    vector<pair<int,int>> edges;\n    int center = 0;\n    for(int i = 1; i < n; ++i) {\n        edges.push_back({center, i});\n    }\n\n    int m = edges.size();\n    printf(\"%d %d\\n\", n, m);\n    for(auto e : edges) {\n        printf(\"%d %d\\n\", e.first +1, e.second+1);\n    }\n}\n\nvoid gen_tree(int n) {\n    vector<pair<int,int>> edges;\n\n    vector<int> nodes(n);\n    for(int i = 0; i < n; ++i)\n        nodes[i] = i;\n    shuffle(nodes.begin(), nodes.end());\n\n    for(int i = 1; i < n; ++i) {\n        int u = nodes[i];\n        int v = nodes[rnd.next(0, i - 1)];\n        edges.push_back({u, v});\n    }\n\n    int m = edges.size();\n    printf(\"%d %d\\n\", n, m);\n    for(auto e : edges) {\n        printf(\"%d %d\\n\", e.first +1, e.second+1);\n    }\n}\n\nvoid gen_path(int n) {\n    vector<pair<int,int>> edges;\n    for(int i = 1; i < n; ++i) {\n        edges.push_back({i -1, i});\n    }\n\n    int m = edges.size();\n    printf(\"%d %d\\n\", n, m);\n    for(auto e : edges) {\n        printf(\"%d %d\\n\", e.first +1, e.second+1);\n    }\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\");\n\n    if (type == \"caterpillar\") {\n        gen_caterpillar(n);\n    } else if (type == \"random_connected\") {\n        int m = opt<int>(\"m\");\n        gen_random_connected(n, m);\n    } else if (type == \"random_disconnected\") {\n        int m = opt<int>(\"m\");\n        gen_random_disconnected(n, m);\n    } else if (type == \"cycle\") {\n        gen_cycle(n);\n    } else if (type == \"complete\") {\n        gen_complete(n);\n    } else if (type == \"star\") {\n        gen_star(n);\n    } else if (type == \"tree\") {\n        gen_tree(n);\n    } else if (type == \"path\") {\n        gen_path(n);\n    } else {\n        // Default: generate random connected graph\n        int m = opt<int>(\"m\");\n        gen_random_connected(n, m);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nvoid gen_caterpillar(int n) {\n    // Generate a random caterpillar\n    // Randomly decide the length of the spine\n    int spine_length = rnd.next(1, n);\n    vector<int> spine(spine_length);\n\n    for(int i = 0; i < spine_length; ++i) {\n        spine[i] = i; // Assign node indices\n    }\n\n    vector<pair<int,int>> edges;\n\n    // Connect the spine\n    for(int i = 1; i < spine_length; ++i) {\n        edges.push_back({spine[i-1], spine[i]});\n    }\n\n    int next_node = spine_length;\n\n    // For remaining nodes, connect them to random nodes on the spine\n    while(next_node < n) {\n        int spine_node = rnd.next(0, spine_length - 1);\n        edges.push_back({spine_node, next_node});\n        ++next_node;\n    }\n\n    // Output the graph\n    int m = edges.size();\n    printf(\"%d %d\\n\", n, m);\n    for(auto e : edges) {\n        printf(\"%d %d\\n\", e.first + 1, e.second + 1);\n    }\n}\n\nvoid gen_random_connected(int n, int m) {\n    // Check that m is valid\n    int max_edges = n * (n - 1) / 2;\n    if (m < n - 1) {\n        printf(\"Error: m must be at least n - 1 for connected graph\\n\");\n        exit(1);\n    }\n    if (m > max_edges) {\n        m = max_edges; // Adjust m to max possible\n    }\n\n    // Generate a tree first\n    vector<pair<int,int>> edges;\n\n    vector<int> nodes(n);\n    for(int i = 0; i < n; ++i)\n        nodes[i] = i;\n    shuffle(nodes.begin(), nodes.end());\n\n    for(int i = 1; i < n; ++i) {\n        int u = nodes[i];\n        int v = nodes[rnd.next(0, i - 1)];\n        edges.push_back({u, v});\n    }\n\n    // Now add extra edges to reach m edges\n    set<pair<int,int>> existing_edges(edges.begin(), edges.end());\n    while((int)edges.size() < m) {\n        int u = rnd.next(0, n -1);\n        int v = rnd.next(0, n -1);\n        if(u == v)\n            continue;\n        pair<int,int> e = minmax(u,v);\n        if(existing_edges.count(e))\n            continue;\n        existing_edges.insert(e);\n        edges.push_back(e);\n    }\n\n    // Output the graph\n    printf(\"%d %d\\n\", n, m);\n    for(auto e : edges) {\n        printf(\"%d %d\\n\", e.first + 1, e.second + 1);\n    }\n}\n\nvoid gen_random_disconnected(int n, int m) {\n    int max_edges = n * (n - 1) / 2;\n    if (m > max_edges) {\n        m = max_edges; // Adjust m to max possible\n    }\n\n    set<pair<int,int>> existing_edges;\n    while((int)existing_edges.size() < m) {\n        int u = rnd.next(0, n -1);\n        int v = rnd.next(0, n -1);\n        if(u == v)\n            continue;\n        pair<int,int> e = minmax(u,v);\n        if(existing_edges.count(e))\n            continue;\n        existing_edges.insert(e);\n    }\n\n    printf(\"%d %d\\n\", n, m);\n    for(auto e : existing_edges) {\n        printf(\"%d %d\\n\", e.first + 1, e.second + 1);\n    }\n}\n\nvoid gen_cycle(int n) {\n    if(n < 3) {\n        printf(\"Error: n must be at least 3 for cycle\\n\");\n        exit(1);\n    }\n\n    vector<pair<int,int>> edges;\n    for(int i = 0; i < n; ++i) {\n        int u = i;\n        int v = (i+1)%n;\n        edges.push_back({u, v});\n    }\n\n    printf(\"%d %d\\n\", n, n);\n    for(auto e : edges) {\n        printf(\"%d %d\\n\", e.first +1, e.second+1);\n    }\n}\n\nvoid gen_complete(int n) {\n    int max_n = 447;\n    if(n > max_n) {\n        printf(\"Error: n must be <= %d for complete graph due to m ≤ 1e5\\n\", max_n);\n        exit(1);\n    }\n    vector<pair<int,int>> edges;\n    for(int u = 0; u < n; ++u) {\n        for(int v = u+1; v < n; ++v) {\n            edges.push_back({u,v});\n        }\n    }\n\n    int m = edges.size();\n    printf(\"%d %d\\n\", n, m);\n    for(auto e : edges) {\n        printf(\"%d %d\\n\", e.first +1, e.second+1);\n    }\n}\n\nvoid gen_star(int n) {\n    vector<pair<int,int>> edges;\n    int center = 0;\n    for(int i = 1; i < n; ++i) {\n        edges.push_back({center, i});\n    }\n\n    int m = edges.size();\n    printf(\"%d %d\\n\", n, m);\n    for(auto e : edges) {\n        printf(\"%d %d\\n\", e.first +1, e.second+1);\n    }\n}\n\nvoid gen_tree(int n) {\n    vector<pair<int,int>> edges;\n\n    vector<int> nodes(n);\n    for(int i = 0; i < n; ++i)\n        nodes[i] = i;\n    shuffle(nodes.begin(), nodes.end());\n\n    for(int i = 1; i < n; ++i) {\n        int u = nodes[i];\n        int v = nodes[rnd.next(0, i - 1)];\n        edges.push_back({u, v});\n    }\n\n    int m = edges.size();\n    printf(\"%d %d\\n\", n, m);\n    for(auto e : edges) {\n        printf(\"%d %d\\n\", e.first +1, e.second+1);\n    }\n}\n\nvoid gen_path(int n) {\n    vector<pair<int,int>> edges;\n    for(int i = 1; i < n; ++i) {\n        edges.push_back({i -1, i});\n    }\n\n    int m = edges.size();\n    printf(\"%d %d\\n\", n, m);\n    for(auto e : edges) {\n        printf(\"%d %d\\n\", e.first +1, e.second+1);\n    }\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\");\n\n    if (type == \"caterpillar\") {\n        gen_caterpillar(n);\n    } else if (type == \"random_connected\") {\n        int m = opt<int>(\"m\");\n        gen_random_connected(n, m);\n    } else if (type == \"random_disconnected\") {\n        int m = opt<int>(\"m\");\n        gen_random_disconnected(n, m);\n    } else if (type == \"cycle\") {\n        gen_cycle(n);\n    } else if (type == \"complete\") {\n        gen_complete(n);\n    } else if (type == \"star\") {\n        gen_star(n);\n    } else if (type == \"tree\") {\n        gen_tree(n);\n    } else if (type == \"path\") {\n        gen_path(n);\n    } else {\n        // Default: generate random connected graph\n        int m = opt<int>(\"m\");\n        gen_random_connected(n, m);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 5 -type caterpillar\n./gen -n 5 -type path\n./gen -n 5 -type star\n./gen -n 5 -type cycle\n./gen -n 5 -type tree\n./gen -n 5 -type random_connected -m 6\n./gen -n 5 -type random_disconnected -m 3\n\n./gen -n 50 -type caterpillar\n./gen -n 50 -type path\n./gen -n 50 -type tree\n./gen -n 50 -type star\n./gen -n 50 -type cycle\n\n./gen -n 2000 -type caterpillar\n./gen -n 2000 -type path\n./gen -n 2000 -type star\n./gen -n 2000 -type tree\n\n./gen -n 447 -type complete\n\n./gen -n 500 -type random_connected -m 1000\n./gen -n 500 -type random_connected -m 5000\n./gen -n 500 -type random_connected -m 10000\n./gen -n 1000 -type random_connected -m 2000\n./gen -n 1000 -type random_connected -m 50000\n./gen -n 2000 -type random_connected -m 100000\n\n./gen -n 500 -type random_disconnected -m 1000\n./gen -n 500 -type random_disconnected -m 5000\n./gen -n 1000 -type random_disconnected -m 10000\n./gen -n 1000 -type random_disconnected -m 50000\n\n./gen -n 1 -type caterpillar\n\n./gen -n 2000 -type cycle\n\n./gen -n 2000 -type random_connected -m 1999\n\n./gen -n 2000 -type random_disconnected -m 0\n\n./gen -n 2000 -type random_disconnected -m 1\n\n./gen -n 2 -type complete\n\n./gen -n 447 -type complete\n\n./gen -n 100 -type caterpillar\n./gen -n 100 -type path\n./gen -n 100 -type star\n./gen -n 100 -type tree\n\n./gen -n 2000 -type path\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:41:32.947528",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "510/A",
      "title": "A. Лиса и змейка",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест2 секунды",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеВ единственной строке записано два целых числа: n и m (3 ≤ n, m ≤ 50). n — нечетное число.",
      "output_spec": "Выходные данныеВыведите n строк. В каждой строке должна быть записана последовательность из m символов. Не выводите пробелы.",
      "sample_tests": "ПримерыВходные данныеСкопировать3 3Выходные данныеСкопировать###..####Входные данныеСкопировать3 4Выходные данныеСкопировать####...#####Входные данныеСкопировать5 3Выходные данныеСкопировать###..#####..###Входные данныеСкопировать9 9Выходные данныеСкопировать#########........###########........#########........###########........#########",
      "description": "A. Лиса и змейка\n\nограничение по времени на тест2 секунды\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвыводstdout\n\nВходные данныеВ единственной строке записано два целых числа: n и m (3 ≤ n, m ≤ 50). n — нечетное число.\n\nВходные данные\n\nВыходные данныеВыведите n строк. В каждой строке должна быть записана последовательность из m символов. Не выводите пробелы.\n\nВыходные данные\n\nВходные данныеСкопировать3 3Выходные данныеСкопировать###..####Входные данныеСкопировать3 4Выходные данныеСкопировать####...#####Входные данныеСкопировать5 3Выходные данныеСкопировать###..#####..###Входные данныеСкопировать9 9Выходные данныеСкопировать#########........###########........#########........###########........#########\n\nВходные данныеСкопировать3 3\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать###..####\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать3 4\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать####...#####\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать5 3\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать###..#####..###\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать9 9\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать#########........###########........#########........###########........#########\n\nВыходные данныеСкопировать\n\nСкопировать",
      "solutions": [
        {
          "title": "Codeforces Round #290 - Codeforces",
          "content": "Лиса Ciel возвращается!Все приглашаются поучаствовать в Codeforces Round #290, который начинается в обычное время в ближайший понедельник.Это мой четвёртый раунд на Codeforces, можете ознакомиться с моими предыдущими раундами: #190, #228, #270.Последний Div1-раунд (#286) оказался очень непростым, поэтому мы решили уменьшить сложность раунда (например, Div1-E превратилась в Div1-D). Надеюсь, это позволит большому количеству людей насладиться всеми задачами раунда: в этот раз ни одна задача не требует продвинутых знаний наподобие линейной алгебры или преобразования Фурье.Главным персонажем раунда будет Лиса Ciel и её жизнь: она учится программировать, играет, путешествует, принимает ужин, а также делает многое другое.Как и на раунде #228, топ-20 участников, присутствующих на зимних сборах в Петрозаводске, будут награждены футболочками Codeforces. Футболку может получить любой участник сборов, член жюри, тренер, организатор или любой другой человек, так или иначе присутствующий на сборах.Как обычно, спасибо Zlobober за ценные советы и помощь в подготовке моего раунда, и MikeMirzayanov за платформы Codeforces и Polygon.Удачи! Update1: Score Distribution is ... Div2: Standard (500 — 1000 — 1500 — 2000 — 2500), Div1: a bit unusual ... (500 — 1000 — 1500 — 2250 — 2250)Update2: Editorial: http://codeforces.com/blog/entry/16173Update3: Congratulation to our winners:Div1: Petr Endagorion mmaxio jqdai0815 tourist They are all people who solved 5 tasks!Div2: SkullSkin joshkirstein gabrielinelus UnknownNooby Andrey_WK",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/16147",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1530
        },
        {
          "title": "Codeforces Round #290 Editorial - Codeforces",
          "content": "Update 1 : here are the reference solutions for this contest: Div2-A: http://ideone.com/JP1Ksj DIv2-B: http://ideone.com/udz3bN Div2-C / Div1-A: http://ideone.com/KVobNb Div2-D / Div1-B: http://ideone.com/7MQqOm Div2-E / Div1-C: http://ideone.com/z3FsU2 Div1-D: http://ideone.com/Y7j21a Div1-E: http://ideone.com/Orbacp Note that for Div2-E / Div1-C, it is for the harder version: we need to handle '1' in the cycle.510A - Fox And SnakeThere are 2 different ways to solve this kind of task:First one is to simulate the movement of the snake head, and you draw '#'s on the board. The code will look like: head = (1, 1)\nrepeat:\n\trepeat m-1 times: head move to right\n\trepeat 2 times: head move down\n\trepeat 2 times: head move down\n\trepeat m-1 times: head move to left\n\trepeat 2 times: head move down\n\trepeat 2 times: head move down\nuntil head is out of the boardAnother way is to do some observation about the result, you can find this pattern: (4k+1) / (4k+3) line: \"#######\"\n(4k+2) line: \".......#\"\n(4k+0) line: \"#.......\"510B - Fox And Two DotsThis task is essentially ask if there is a cycle in an undirected graph: treat each cell as a node, and add an edge if two cells are neighborhood and have some color.There are lots of ways to do this, for example: Run dfs / bfs, if an edge lead you to a visited node, then there must be a cycle. For each connected component, test if |#edges| = |#nodes| - 1, if not then there must be a cycle. 510C - Fox And Names / 512A - Fox And NamesLet's first think about what S < T can tell us: suppose S = abcxyz and T = abcuv. Then we know that S < T if and only if x < u by the definition.So we can transform the conditions name1 < name2, name2 < name3 ... into the order of letters.Then the question become: do we have a permutation that satisfy those conditions. It is actually the classic topological order question.One trick in this task is that, if we have something like xy < x then there is no solution. This is not covered in pretests. :)510D - Fox And Jumping / 512B - Fox And JumpingThis task equals to: what is the minimal sum of costs that we can select k cards, so their GCD is 1.First observation is that: GCD(x1, x2, ..., xk) = 1 means that for any prime p, there exist i such that xi is not dividable by p. So we only care about what prime factors a number contain. (So for example, 12 -> {2, 3}, 6 -> {2, 3}, 9 -> {3]})The second observation is: If x ≤ 109 then it has at most 9 prime factors.So after we select one number, we only care about these 9 or less primes. Then this problem equals to set covering problem (SCP), it can be done by mask DP. It can run in about O(2^9 * n^2).510E - Fox And Dinner / 512C - Fox And DinnerFirst finding is: if a + b is a prime, then one of them is an odd number, another is an even number. (that's why we set 2 ≤ xi)Then we could find: every odd number have exactly 2 even number as neighborhood, and every even number have exactly 2 odd number as neighborhood. And that means we need |#even| = |#odd| to have a solution.So it looks like bipartite graph matching, but every element matched 2 elements. And in fact it can be handled by maxflow: For each odd number, we add a node on the left side and link it from source with capacity equals to 2, and for each even number, we add a node on the right side and link it to sink with capacity equals to 2. And if sum of two numbers is a prime number, we link them with capacity equals to 1.Then we solve the max flow, it have solution if and only if maxflow = 2 * |#even|.We can construct the answer(cycles) from the matches.Note: Actually this task is still solvable if we allow ai = 1. But you need some clever way to deal with it. We think it is too hard so we removed this case. What do you think about this decision?512D - Fox And TravellingWe could find that some nodes cannot be visited. And more specific, if one node is in a cycle then it cannot be visited. So what about the structure of nodes that we can visit?Let's first find a way to get all nodes that could be visited. We can deal with this by something like biconnected decomposition, but that is not easy to implement. In fact we can use this simple method: each time we pick one node that have at most 1 neighborhood and delete it. Repeat this process until we can't do it anymore.We could find these nodes are actually belonging to these 2 kinds: 1. A tree. 2. Rooted tree. (that means, the root is attached to a cycle)The rooted tree case is simple: we can solve it by tree DP. The state will be dp[i][j] = the way to remove j nodes in the subtree rooted at i.Then how to solve the unrooted tree case? The way to deal with that is to transform it into rooted case. We have 2 solution: We select one unvisited node as the root by some rules: for example, we select one with minimal index. Then we just need to modify the DP a bit to adjust this additional condition. We could find if the tree has n nodes and we visit k nodes in the end, then there will be max(1, n-k) ways to choose the root. That means if we choose every node as the root and sum up them, we will count this case exactly max(1, n-k) times. So we just do the rooted DP for from node n times, and divide max(1, n-k) for ans[k]. The overall complicity is O(n4), and it can be optimize into O(n3) if you like.512E - Fox And PolygonTriangulation of polygon is something hard to think about. So the first key observation is that, we can transform this task into operations on rooted trees!One Triangulation of polygon can be mapping to one rooted tree. And the flip operation can be mapping to the rotation of trees. (It is the operation we used to balance our BST) You can find the mapping from above picture. The red lines indicate the edge that will be flipped and the nodes we rotated.Then we should find a standard shape of the tree, and solve this task: how to rotate any tree into this standard shape?My solution is to choose the balanced tree as standard shape. The way to do that is this: find the node that the index is the middle number, rotate it to the top(that what we did for splay tree), and do the same thing for each subtree.It is easy to see it could work in O(nlogn) steps.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/16173",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 510\\s*A"
          },
          "content_length": 6165
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #290 - Codeforces - Code 1",
          "code": "26\na\nb\nc\n...\nz",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16147",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #290 - Codeforces - Code 2",
          "code": "26\na\nb\nc\n...\nz",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16147",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #290 Editorial - Codeforces - Code 1",
          "code": "head = (1, 1)\nrepeat:\n\trepeat m-1 times: head move to right\n\trepeat 2 times: head move down\n\trepeat 2 times: head move down\n\trepeat m-1 times: head move to left\n\trepeat 2 times: head move down\n\trepeat 2 times: head move down\nuntil head is out of the board",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16173",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #290 Editorial - Codeforces - Code 2",
          "code": "head = (1, 1)\nrepeat:\n\trepeat m-1 times: head move to right\n\trepeat 2 times: head move down\n\trepeat 2 times: head move down\n\trepeat m-1 times: head move to left\n\trepeat 2 times: head move down\n\trepeat 2 times: head move down\nuntil head is out of the board",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16173",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #290 Editorial - Codeforces - Code 3",
          "code": "(4k+1) / (4k+3) line: \"#######\"\n(4k+2) line: \".......#\"\n(4k+0) line: \"#.......\"",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16173",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #290 Editorial - Codeforces - Code 4",
          "code": "(4k+1) / (4k+3) line: \"#######\"\n(4k+2) line: \".......#\"\n(4k+0) line: \"#.......\"",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16173",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #290 Editorial - Codeforces - Code 5",
          "code": "for (i64 i = 0; i < n; i++) {\n    hepsi[ l[i] ] = c[i];\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16173",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #290 Editorial - Codeforces - Code 6",
          "code": "for (i64 i = 0; i < n; i++) {\n    hepsi[ l[i] ] = c[i];\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16173",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #290 Editorial - Codeforces - Code 7",
          "code": "hepsi[ 0 ] = 0;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16173",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #290 Editorial - Codeforces - Code 8",
          "code": "hepsi[ 0 ] = 0;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16173",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #290 Editorial - Codeforces - Code 9",
          "code": "s = primes.size();\n\nfor(int mask = 0; mask < (1<<s); mask++){\n\tdp[mask] = INF;\n}\n\t\t\ndp[m[i]] = c[i];\n\t\t\nfor(int mask = 0; mask < (1<<s); mask++){\n\tfor(int j = 0; j < n; j++){\n\t\tif(dp[mask] != INF)\n\t\t\tdp[mask | m[j]] = min(dp[mask | m[j]], dp[mask] + c[j]);\n\t}\n}\n\nans = min(ans, dp[(1<<s) - 1]);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16173",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #290 Editorial - Codeforces - Code 10",
          "code": "s = primes.size();\n\nfor(int mask = 0; mask < (1<<s); mask++){\n\tdp[mask] = INF;\n}\n\t\t\ndp[m[i]] = c[i];\n\t\t\nfor(int mask = 0; mask < (1<<s); mask++){\n\tfor(int j = 0; j < n; j++){\n\t\tif(dp[mask] != INF)\n\t\t\tdp[mask | m[j]] = min(dp[mask | m[j]], dp[mask] + c[j]);\n\t}\n}\n\nans = min(ans, dp[(1<<s) - 1]);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16173",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #290 Editorial - Codeforces - Code 11",
          "code": "3 3\nBAB\nAAA\nBAB",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16173",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #290 Editorial - Codeforces - Code 12",
          "code": "3 3\nBAB\nAAA\nBAB",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16173",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #290 Editorial - Codeforces - Code 13",
          "code": "#include<Stdio.h>",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/16173",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #290 Editorial - Codeforces - Code 14",
          "code": "dp[i][sz[i]] = dp[i][sz[i] - 1]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16173",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #290 Editorial - Codeforces - Code 15",
          "code": "dpValue dfs(int cur, int from)\n{\n\tdpValue ret;\n\tret.x[0] = 1;\n\tfor(int i = 0; i < e[cur].size(); i++)\n\t{\n\t\tint t = e[cur][i];\n\t\tif(t == from) continue;\n\t\tret = combine(ret, dfs(t, cur));\n\t}\n\tfor(int i = 0; i < MAXN; i++)\n\t\tif(ret.x[i] == 0)\n\t\t{\n\t\t\tret.x[i] = ret.x[i-1];\n\t\t\tbreak;\n\t\t}\n\treturn ret;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16173",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #290 Editorial - Codeforces - Code 16",
          "code": "dpValue dfs(int cur, int from)\n{\n\tdpValue ret;\n\tret.x[0] = 1;\n\tfor(int i = 0; i < e[cur].size(); i++)\n\t{\n\t\tint t = e[cur][i];\n\t\tif(t == from) continue;\n\t\tret = combine(ret, dfs(t, cur));\n\t}\n\tfor(int i = 0; i < MAXN; i++)\n\t\tif(ret.x[i] == 0)\n\t\t{\n\t\t\tret.x[i] = ret.x[i-1];\n\t\t\tbreak;\n\t\t}\n\treturn ret;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16173",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #290 Editorial - Codeforces - Code 17",
          "code": "dpValue combine(dpValue A, dpValue B)\n{\n\tdpValue ret;\n\tfor(int i = 0; i < MAXN; i++)\n\t\tfor(int j = 0; i+j < MAXN; j++)\n\t\t{\n\t\t\tret.x[i+j] += ((A.x[i] * B.x[j]) % mod) * C(i+j, i);\n\t\t\tret.x[i+j] %= mod;\n\t\t}\n\treturn ret;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16173",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #290 Editorial - Codeforces - Code 18",
          "code": "dpValue combine(dpValue A, dpValue B)\n{\n\tdpValue ret;\n\tfor(int i = 0; i < MAXN; i++)\n\t\tfor(int j = 0; i+j < MAXN; j++)\n\t\t{\n\t\t\tret.x[i+j] += ((A.x[i] * B.x[j]) % mod) * C(i+j, i);\n\t\t\tret.x[i+j] %= mod;\n\t\t}\n\treturn ret;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16173",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #290 Editorial - Codeforces - Code 19",
          "code": "4\n2 4 5 7\n1 1 1 1000000000",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16173",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #290 Editorial - Codeforces - Code 20",
          "code": "4\n2 4 5 7\n1 1 1 1000000000",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16173",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(3, 50, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(3, 50, \"m\");\n    inf.readEoln();\n\n    ensuref(n % 2 == 1, \"n must be odd, but n=%d\", n);\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(3, 50, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(3, 50, \"m\");\n    inf.readEoln();\n\n    ensuref(n % 2 == 1, \"n must be odd, but n=%d\", n);\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(3, 50, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(3, 50, \"m\");\n    inf.readEoln();\n\n    ensuref(n % 2 == 1, \"n must be odd, but n=%d\", n);\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n#include <string>\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare files as sequence of lines\");\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    std::string strAnswer;\r\n\r\n    int n = 0;\r\n    while (!ans.eof()) {\r\n        std::string j = ans.readString();\r\n\r\n        if (j.empty() && ans.eof())\r\n            break;\r\n\r\n        strAnswer = j;\r\n        std::string p = ouf.readString();\r\n\r\n        n++;\r\n\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s lines differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  compress(j).c_str(), compress(p).c_str());\r\n    }\r\n\r\n    if (n == 1)\r\n        quitf(_ok, \"single line: '%s'\", compress(strAnswer).c_str());\r\n\r\n    quitf(_ok, \"%d lines\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\",-1);\n    int m = opt<int>(\"m\",-1);\n    string type = opt<string>(\"type\",\"random\");\n\n    if (n != -1) {\n        ensure(3 <= n && n <= 49);\n        ensure(n % 2 == 1);\n    }\n\n    if (m != -1) {\n        ensure(3 <= m && m <= 50);\n    }\n\n    if (type == \"min\") {\n        n = 3;\n        m = 3;\n    } else if (type == \"max\") {\n        n = 49;\n        m = 50;\n    } else if (type == \"n_greater_m\") {\n        if (n == -1) {\n            n = rnd.next(5,49); // n at least 5\n            if (n%2 == 0) n += 1;\n            if (n > 49) n -= 2;\n        }\n        if (m == -1) {\n            m = rnd.next(3, n-1); // m less than n\n        }\n    } else if (type == \"m_greater_n\") {\n        if (n == -1) {\n            n = rnd.next(3,47); // n at most 47 to ensure m <=50\n            if (n%2 == 0) n += 1;\n            if (n > 47) n -= 2;\n        }\n        if (m == -1) {\n            m = rnd.next(n+1,50); // m greater than n\n        }\n    } else if (type == \"equal\") {\n        if (n == -1) {\n            n = rnd.next(3,49);\n            if (n%2 == 0) n += 1;\n            if (n > 49) n -= 2;\n        }\n        m = n;\n    } else if (type == \"random\") {\n        if (n == -1) {\n            n = rnd.next(3,49);\n            if (n%2 == 0) n += 1;\n            if (n > 49) n -= 2;\n        }\n        if (m == -1) {\n            m = rnd.next(3,50);\n        }\n    } else {\n        quitf(_fail,\"Unknown type %s\", type.c_str());\n    }\n\n    // Ensure constraints\n    n = max(3, min(n,49));\n    if (n%2 == 0) n -=1;\n    m = max(3, min(m,50));\n\n    ensure(3 <= n && n <= 49);\n    ensure(3 <= m && m <= 50);\n    ensure(n % 2 == 1);\n\n    printf(\"%d %d\\n\", n, m);\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\",-1);\n    int m = opt<int>(\"m\",-1);\n    string type = opt<string>(\"type\",\"random\");\n\n    if (n != -1) {\n        ensure(3 <= n && n <= 49);\n        ensure(n % 2 == 1);\n    }\n\n    if (m != -1) {\n        ensure(3 <= m && m <= 50);\n    }\n\n    if (type == \"min\") {\n        n = 3;\n        m = 3;\n    } else if (type == \"max\") {\n        n = 49;\n        m = 50;\n    } else if (type == \"n_greater_m\") {\n        if (n == -1) {\n            n = rnd.next(5,49); // n at least 5\n            if (n%2 == 0) n += 1;\n            if (n > 49) n -= 2;\n        }\n        if (m == -1) {\n            m = rnd.next(3, n-1); // m less than n\n        }\n    } else if (type == \"m_greater_n\") {\n        if (n == -1) {\n            n = rnd.next(3,47); // n at most 47 to ensure m <=50\n            if (n%2 == 0) n += 1;\n            if (n > 47) n -= 2;\n        }\n        if (m == -1) {\n            m = rnd.next(n+1,50); // m greater than n\n        }\n    } else if (type == \"equal\") {\n        if (n == -1) {\n            n = rnd.next(3,49);\n            if (n%2 == 0) n += 1;\n            if (n > 49) n -= 2;\n        }\n        m = n;\n    } else if (type == \"random\") {\n        if (n == -1) {\n            n = rnd.next(3,49);\n            if (n%2 == 0) n += 1;\n            if (n > 49) n -= 2;\n        }\n        if (m == -1) {\n            m = rnd.next(3,50);\n        }\n    } else {\n        quitf(_fail,\"Unknown type %s\", type.c_str());\n    }\n\n    // Ensure constraints\n    n = max(3, min(n,49));\n    if (n%2 == 0) n -=1;\n    m = max(3, min(m,50));\n\n    ensure(3 <= n && n <= 49);\n    ensure(3 <= m && m <= 50);\n    ensure(n % 2 == 1);\n\n    printf(\"%d %d\\n\", n, m);\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -type min\n\n./gen -type max\n\n./gen -n 3 -type equal\n./gen -n 5 -type equal\n./gen -n 7 -type equal\n./gen -n 25 -type equal\n./gen -n 49 -type equal\n\n./gen -n 5 -type n_greater_m\n./gen -n 7 -type n_greater_m\n./gen -n 9 -type n_greater_m\n./gen -n 49 -type n_greater_m\n\n./gen -n 5 -type m_greater_n\n./gen -n 7 -type m_greater_n\n./gen -n 9 -type m_greater_n\n./gen -n 47 -type m_greater_n\n\n./gen -type random\n./gen -type random\n./gen -type random\n\n./gen -n 49 -m 50 -type random\n./gen -n 47 -m 3 -type random\n./gen -n 3 -m 50 -type random\n./gen -n 25 -m 25 -type random\n\n./gen -n 3 -type random\n./gen -n 5 -type random\n./gen -n 7 -type random\n./gen -n 49 -type random\n\n./gen -type random\n./gen -type random\n./gen -type random\n./gen -type random\n./gen -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:41:35.015292",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "510/B",
      "title": "B. Fox And Two Dots",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains two integers n and m (2 ≤ n, m ≤ 50): the number of rows and columns of the board.Then n lines follow, each line contains a string consisting of m characters, expressing colors of dots in each line. Each character is an uppercase Latin letter.",
      "output_spec": "OutputOutput \"Yes\" if there exists a cycle, and \"No\" otherwise.",
      "sample_tests": "ExamplesInputCopy3 4AAAAABCAAAAAOutputCopyYesInputCopy3 4AAAAABCAAADAOutputCopyNoInputCopy4 4YYYRBYBYBBBYBBBYOutputCopyYesInputCopy7 6AAAAABABBBABABAAABABABBBABAAABABBBABAAAAABOutputCopyYesInputCopy2 13ABCDEFGHIJKLMNOPQRSTUVWXYZOutputCopyNo",
      "description": "B. Fox And Two Dots\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains two integers n and m (2 ≤ n, m ≤ 50): the number of rows and columns of the board.Then n lines follow, each line contains a string consisting of m characters, expressing colors of dots in each line. Each character is an uppercase Latin letter.\n\nOutputOutput \"Yes\" if there exists a cycle, and \"No\" otherwise.\n\nInputCopy3 4AAAAABCAAAAAOutputCopyYesInputCopy3 4AAAAABCAAADAOutputCopyNoInputCopy4 4YYYRBYBYBBBYBBBYOutputCopyYesInputCopy7 6AAAAABABBBABABAAABABABBBABAAABABBBABAAAAABOutputCopyYesInputCopy2 13ABCDEFGHIJKLMNOPQRSTUVWXYZOutputCopyNo\n\nInputCopy3 4AAAAABCAAAAA\n\nOutputCopyYes\n\nInputCopy3 4AAAAABCAAADA\n\nOutputCopyNo\n\nInputCopy4 4YYYRBYBYBBBYBBBY\n\nOutputCopyYes\n\nInputCopy7 6AAAAABABBBABABAAABABABBBABAAABABBBABAAAAAB\n\nOutputCopyYes\n\nInputCopy2 13ABCDEFGHIJKLMNOPQRSTUVWXYZ\n\nOutputCopyNo\n\nNoteIn first sample test all 'A' form a cycle.In second sample there is no such cycle.The third sample is displayed on the picture above ('Y' = Yellow, 'B' = Blue, 'R' = Red).",
      "solutions": [
        {
          "title": "Codeforces Round #290 - Codeforces",
          "content": "Fox Ciel is back!I invite you to participate in Codeforces Round #290, which will start at the standard time on next Monday: This is my 4th round on Codeforces, my previous rounds: #190, #228, #270.Last Div1 Round (#286) is so hard, so after notice that, we decide to reduce the difficulty of this round. (For example, current Div1-E was used as Div1-D) I hope more people can enjoy all tasks in this round: this time no task requires advanced knowledge like linear space or Fourier Transform.The background story will be Fox Ciel's life: learning programming, play games, traveling, have dinner and so on.Like Round #228, top-20 contestants that are currently at Petrozavodsk training camp will be rewarded with nice Codefores T-Shirts. Contestant may be a team member, jury, coach, organizer, or whoever else involved in camp, no matter of status.As usual, thanks to Zlobober for giving great suggestions and test my round, and MikeMirzayanov for the platform (Codeforces and Polygon). Good luck and have fun!Update1: Score Distribution is ... Div2: Standard (500 — 1000 — 1500 — 2000 — 2500), Div1: a bit unusual ... (500 — 1000 — 1500 — 2250 — 2250)Update2: Editorial: http://codeforces.com/blog/entry/16173Update3: Congratulation to our winners:Div1: Petr Endagorion mmaxio jqdai0815 tourist They are all people who solved 5 tasks!Div2: SkullSkin joshkirstein gabrielinelus UnknownNooby Andrey_WK",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/16147",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1401
        },
        {
          "title": "Codeforces Round #290 Editorial - Codeforces",
          "content": "Update 1 : here are the reference solutions for this contest: Div2-A: http://ideone.com/JP1Ksj DIv2-B: http://ideone.com/udz3bN Div2-C / Div1-A: http://ideone.com/KVobNb Div2-D / Div1-B: http://ideone.com/7MQqOm Div2-E / Div1-C: http://ideone.com/z3FsU2 Div1-D: http://ideone.com/Y7j21a Div1-E: http://ideone.com/Orbacp Note that for Div2-E / Div1-C, it is for the harder version: we need to handle '1' in the cycle.510A - Fox And SnakeThere are 2 different ways to solve this kind of task:First one is to simulate the movement of the snake head, and you draw '#'s on the board. The code will look like: head = (1, 1)\nrepeat:\n\trepeat m-1 times: head move to right\n\trepeat 2 times: head move down\n\trepeat 2 times: head move down\n\trepeat m-1 times: head move to left\n\trepeat 2 times: head move down\n\trepeat 2 times: head move down\nuntil head is out of the boardAnother way is to do some observation about the result, you can find this pattern: (4k+1) / (4k+3) line: \"#######\"\n(4k+2) line: \".......#\"\n(4k+0) line: \"#.......\"510B - Fox And Two DotsThis task is essentially ask if there is a cycle in an undirected graph: treat each cell as a node, and add an edge if two cells are neighborhood and have some color.There are lots of ways to do this, for example: Run dfs / bfs, if an edge lead you to a visited node, then there must be a cycle. For each connected component, test if |#edges| = |#nodes| - 1, if not then there must be a cycle. 510C - Fox And Names / 512A - Fox And NamesLet's first think about what S < T can tell us: suppose S = abcxyz and T = abcuv. Then we know that S < T if and only if x < u by the definition.So we can transform the conditions name1 < name2, name2 < name3 ... into the order of letters.Then the question become: do we have a permutation that satisfy those conditions. It is actually the classic topological order question.One trick in this task is that, if we have something like xy < x then there is no solution. This is not covered in pretests. :)510D - Fox And Jumping / 512B - Fox And JumpingThis task equals to: what is the minimal sum of costs that we can select k cards, so their GCD is 1.First observation is that: GCD(x1, x2, ..., xk) = 1 means that for any prime p, there exist i such that xi is not dividable by p. So we only care about what prime factors a number contain. (So for example, 12 -> {2, 3}, 6 -> {2, 3}, 9 -> {3]})The second observation is: If x ≤ 109 then it has at most 9 prime factors.So after we select one number, we only care about these 9 or less primes. Then this problem equals to set covering problem (SCP), it can be done by mask DP. It can run in about O(2^9 * n^2).510E - Fox And Dinner / 512C - Fox And DinnerFirst finding is: if a + b is a prime, then one of them is an odd number, another is an even number. (that's why we set 2 ≤ xi)Then we could find: every odd number have exactly 2 even number as neighborhood, and every even number have exactly 2 odd number as neighborhood. And that means we need |#even| = |#odd| to have a solution.So it looks like bipartite graph matching, but every element matched 2 elements. And in fact it can be handled by maxflow: For each odd number, we add a node on the left side and link it from source with capacity equals to 2, and for each even number, we add a node on the right side and link it to sink with capacity equals to 2. And if sum of two numbers is a prime number, we link them with capacity equals to 1.Then we solve the max flow, it have solution if and only if maxflow = 2 * |#even|.We can construct the answer(cycles) from the matches.Note: Actually this task is still solvable if we allow ai = 1. But you need some clever way to deal with it. We think it is too hard so we removed this case. What do you think about this decision?512D - Fox And TravellingWe could find that some nodes cannot be visited. And more specific, if one node is in a cycle then it cannot be visited. So what about the structure of nodes that we can visit?Let's first find a way to get all nodes that could be visited. We can deal with this by something like biconnected decomposition, but that is not easy to implement. In fact we can use this simple method: each time we pick one node that have at most 1 neighborhood and delete it. Repeat this process until we can't do it anymore.We could find these nodes are actually belonging to these 2 kinds: 1. A tree. 2. Rooted tree. (that means, the root is attached to a cycle)The rooted tree case is simple: we can solve it by tree DP. The state will be dp[i][j] = the way to remove j nodes in the subtree rooted at i.Then how to solve the unrooted tree case? The way to deal with that is to transform it into rooted case. We have 2 solution: We select one unvisited node as the root by some rules: for example, we select one with minimal index. Then we just need to modify the DP a bit to adjust this additional condition. We could find if the tree has n nodes and we visit k nodes in the end, then there will be max(1, n-k) ways to choose the root. That means if we choose every node as the root and sum up them, we will count this case exactly max(1, n-k) times. So we just do the rooted DP for from node n times, and divide max(1, n-k) for ans[k]. The overall complicity is O(n4), and it can be optimize into O(n3) if you like.512E - Fox And PolygonTriangulation of polygon is something hard to think about. So the first key observation is that, we can transform this task into operations on rooted trees!One Triangulation of polygon can be mapping to one rooted tree. And the flip operation can be mapping to the rotation of trees. (It is the operation we used to balance our BST) You can find the mapping from above picture. The red lines indicate the edge that will be flipped and the nodes we rotated.Then we should find a standard shape of the tree, and solve this task: how to rotate any tree into this standard shape?My solution is to choose the balanced tree as standard shape. The way to do that is this: find the node that the index is the middle number, rotate it to the top(that what we did for splay tree), and do the same thing for each subtree.It is easy to see it could work in O(nlogn) steps.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/16173",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 510\\s*B"
          },
          "content_length": 6165
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #290 - Codeforces - Code 1",
          "code": "26\na\nb\nc\n...\nz",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16147",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #290 - Codeforces - Code 2",
          "code": "26\na\nb\nc\n...\nz",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16147",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #290 Editorial - Codeforces - Code 1",
          "code": "head = (1, 1)\nrepeat:\n\trepeat m-1 times: head move to right\n\trepeat 2 times: head move down\n\trepeat 2 times: head move down\n\trepeat m-1 times: head move to left\n\trepeat 2 times: head move down\n\trepeat 2 times: head move down\nuntil head is out of the board",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16173",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #290 Editorial - Codeforces - Code 2",
          "code": "head = (1, 1)\nrepeat:\n\trepeat m-1 times: head move to right\n\trepeat 2 times: head move down\n\trepeat 2 times: head move down\n\trepeat m-1 times: head move to left\n\trepeat 2 times: head move down\n\trepeat 2 times: head move down\nuntil head is out of the board",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16173",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #290 Editorial - Codeforces - Code 3",
          "code": "(4k+1) / (4k+3) line: \"#######\"\n(4k+2) line: \".......#\"\n(4k+0) line: \"#.......\"",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16173",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #290 Editorial - Codeforces - Code 4",
          "code": "(4k+1) / (4k+3) line: \"#######\"\n(4k+2) line: \".......#\"\n(4k+0) line: \"#.......\"",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16173",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #290 Editorial - Codeforces - Code 5",
          "code": "for (i64 i = 0; i < n; i++) {\n    hepsi[ l[i] ] = c[i];\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16173",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #290 Editorial - Codeforces - Code 6",
          "code": "for (i64 i = 0; i < n; i++) {\n    hepsi[ l[i] ] = c[i];\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16173",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #290 Editorial - Codeforces - Code 7",
          "code": "hepsi[ 0 ] = 0;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16173",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #290 Editorial - Codeforces - Code 8",
          "code": "hepsi[ 0 ] = 0;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16173",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #290 Editorial - Codeforces - Code 9",
          "code": "s = primes.size();\n\nfor(int mask = 0; mask < (1<<s); mask++){\n\tdp[mask] = INF;\n}\n\t\t\ndp[m[i]] = c[i];\n\t\t\nfor(int mask = 0; mask < (1<<s); mask++){\n\tfor(int j = 0; j < n; j++){\n\t\tif(dp[mask] != INF)\n\t\t\tdp[mask | m[j]] = min(dp[mask | m[j]], dp[mask] + c[j]);\n\t}\n}\n\nans = min(ans, dp[(1<<s) - 1]);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16173",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #290 Editorial - Codeforces - Code 10",
          "code": "s = primes.size();\n\nfor(int mask = 0; mask < (1<<s); mask++){\n\tdp[mask] = INF;\n}\n\t\t\ndp[m[i]] = c[i];\n\t\t\nfor(int mask = 0; mask < (1<<s); mask++){\n\tfor(int j = 0; j < n; j++){\n\t\tif(dp[mask] != INF)\n\t\t\tdp[mask | m[j]] = min(dp[mask | m[j]], dp[mask] + c[j]);\n\t}\n}\n\nans = min(ans, dp[(1<<s) - 1]);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16173",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #290 Editorial - Codeforces - Code 11",
          "code": "3 3\nBAB\nAAA\nBAB",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16173",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #290 Editorial - Codeforces - Code 12",
          "code": "3 3\nBAB\nAAA\nBAB",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16173",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #290 Editorial - Codeforces - Code 13",
          "code": "#include<Stdio.h>",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/16173",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #290 Editorial - Codeforces - Code 14",
          "code": "dp[i][sz[i]] = dp[i][sz[i] - 1]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16173",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #290 Editorial - Codeforces - Code 15",
          "code": "dpValue dfs(int cur, int from)\n{\n\tdpValue ret;\n\tret.x[0] = 1;\n\tfor(int i = 0; i < e[cur].size(); i++)\n\t{\n\t\tint t = e[cur][i];\n\t\tif(t == from) continue;\n\t\tret = combine(ret, dfs(t, cur));\n\t}\n\tfor(int i = 0; i < MAXN; i++)\n\t\tif(ret.x[i] == 0)\n\t\t{\n\t\t\tret.x[i] = ret.x[i-1];\n\t\t\tbreak;\n\t\t}\n\treturn ret;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16173",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #290 Editorial - Codeforces - Code 16",
          "code": "dpValue dfs(int cur, int from)\n{\n\tdpValue ret;\n\tret.x[0] = 1;\n\tfor(int i = 0; i < e[cur].size(); i++)\n\t{\n\t\tint t = e[cur][i];\n\t\tif(t == from) continue;\n\t\tret = combine(ret, dfs(t, cur));\n\t}\n\tfor(int i = 0; i < MAXN; i++)\n\t\tif(ret.x[i] == 0)\n\t\t{\n\t\t\tret.x[i] = ret.x[i-1];\n\t\t\tbreak;\n\t\t}\n\treturn ret;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16173",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #290 Editorial - Codeforces - Code 17",
          "code": "dpValue combine(dpValue A, dpValue B)\n{\n\tdpValue ret;\n\tfor(int i = 0; i < MAXN; i++)\n\t\tfor(int j = 0; i+j < MAXN; j++)\n\t\t{\n\t\t\tret.x[i+j] += ((A.x[i] * B.x[j]) % mod) * C(i+j, i);\n\t\t\tret.x[i+j] %= mod;\n\t\t}\n\treturn ret;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16173",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #290 Editorial - Codeforces - Code 18",
          "code": "dpValue combine(dpValue A, dpValue B)\n{\n\tdpValue ret;\n\tfor(int i = 0; i < MAXN; i++)\n\t\tfor(int j = 0; i+j < MAXN; j++)\n\t\t{\n\t\t\tret.x[i+j] += ((A.x[i] * B.x[j]) % mod) * C(i+j, i);\n\t\t\tret.x[i+j] %= mod;\n\t\t}\n\treturn ret;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16173",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #290 Editorial - Codeforces - Code 19",
          "code": "4\n2 4 5 7\n1 1 1 1000000000",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16173",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #290 Editorial - Codeforces - Code 20",
          "code": "4\n2 4 5 7\n1 1 1 1000000000",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16173",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(2, 50, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(2, 50, \"m\");\n    inf.readEoln();\n\n    string pattern = format(\"[A-Z]{%d}\", m);\n    for (int i = 0; i < n; ++i) {\n        string line = inf.readLine(pattern, format(\"line %d\", i + 1));\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(2, 50, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(2, 50, \"m\");\n    inf.readEoln();\n\n    string pattern = format(\"[A-Z]{%d}\", m);\n    for (int i = 0; i < n; ++i) {\n        string line = inf.readLine(pattern, format(\"line %d\", i + 1));\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(2, 50, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(2, 50, \"m\");\n    inf.readEoln();\n\n    string pattern = format(\"[A-Z]{%d}\", m);\n    for (int i = 0; i < n; ++i) {\n        string line = inf.readLine(pattern, format(\"line %d\", i + 1));\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n#include <string>\r\n\r\nusing namespace std;\r\n\r\nconst string YES = \"YES\";\r\nconst string NO = \"NO\";\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"%s\", (\"multiple \" + YES + \"/\" + NO + \" (case insensitive)\").c_str());\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int index = 0, yesCount = 0, noCount = 0;\r\n    string pa;\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        index++;\r\n        string ja = upperCase(ans.readToken());\r\n        pa = upperCase(ouf.readToken());\r\n\r\n        if (ja != YES && ja != NO)\r\n            quitf(_fail, \"%s or %s expected in answer, but %s found [%d%s token]\",\r\n                  YES.c_str(), NO.c_str(), compress(ja).c_str(), index, englishEnding(index).c_str());\r\n\r\n        if (pa == YES)\r\n            yesCount++;\r\n        else if (pa == NO)\r\n            noCount++;\r\n        else\r\n            quitf(_pe, \"%s or %s expected, but %s found [%d%s token]\",\r\n                  YES.c_str(), NO.c_str(), compress(pa).c_str(), index, englishEnding(index).c_str());\r\n\r\n        if (ja != pa)\r\n            quitf(_wa, \"expected %s, found %s [%d%s token]\",\r\n                  compress(ja).c_str(), compress(pa).c_str(), index, englishEnding(index).c_str());\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n    while (!ans.seekEof()) {\r\n        ans.readToken();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n    while (!ouf.seekEof()) {\r\n        ouf.readToken();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              index + extraInAnsCount, index);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              index + extraInOufCount, index);\r\n\r\n    if (index == 0)\r\n        quitf(_ok, \"Empty output\");\r\n    else if (index == 1)\r\n        quitf(_ok, \"%s\", pa.c_str());\r\n    else\r\n        quitf(_ok, \"%d token(s): yes count is %d, no count is %d\", index, yesCount, noCount);\r\n\r\n    quitf(_fail, \"Impossible case\");\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nvoid outputGrid(const vector<string>& grid) {\n    printf(\"%d %d\\n\", int(grid.size()), int(grid[0].size()));\n    for (const string& row : grid) {\n        printf(\"%s\\n\", row.c_str());\n    }\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string type = opt<string>(\"type\", \"random\");\n\n    if (type == \"random\") {\n        // Randomly populate grid with random colors\n        int num_colors = rnd.next(1, 26); // Between 1 and 26 colors\n        vector<char> colors(num_colors);\n        for (int i = 0; i < num_colors; ++i) {\n            colors[i] = 'A' + i;\n        }\n        vector<string> grid(n, string(m, 'A'));\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < m; ++j) {\n                grid[i][j] = colors[rnd.next(0, num_colors - 1)];\n            }\n        }\n        outputGrid(grid);\n    } else if (type == \"all_same_color\") {\n        char color = rnd.next('A', 'Z');\n        vector<string> grid(n, string(m, color));\n        outputGrid(grid);\n    } else if (type == \"checkerboard\") {\n        vector<string> grid(n, string(m, 'A'));\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < m; ++j) {\n                grid[i][j] = ((i + j) % 2 == 0) ? 'A' : 'B';\n            }\n        }\n        outputGrid(grid);\n    } else if (type == \"single_cycle\") {\n        vector<string> grid(n, string(m, 'B')); // Fill with 'B'\n\n        // Create a cycle of color 'A'\n        if (n >= 2 && m >= 2) {\n            grid[0][0] = grid[0][1] = grid[1][0] = grid[1][1] = 'A';\n        }\n        outputGrid(grid);\n    } else if (type == \"large_cycle\") {\n        vector<string> grid(n, string(m, 'B')); // Fill with 'B'\n\n        char color = 'A';\n\n        // Make the border cells to be 'A's, forming a cycle along the border.\n        for (int i = 0; i < n; ++i) {\n            grid[i][0] = color;\n            grid[i][m - 1] = color;\n        }\n        for (int j = 0; j < m; ++j) {\n            grid[0][j] = color;\n            grid[n - 1][j] = color;\n        }\n        outputGrid(grid);\n    } else if (type == \"diagonal\") {\n        vector<string> grid(n, string(m, 'B')); // Fill with 'B'\n        char color = 'A';\n        int diag_len = min(n, m);\n        for (int i = 0; i < diag_len; ++i) {\n            grid[i][i] = color;\n        }\n        outputGrid(grid);\n    } else if (type == \"minimal_no_cycle\") {\n        vector<string> grid(n, string(m, 'B'));\n        if (n >= 2 && m >= 2) {\n            grid[0][0] = grid[0][1] = grid[1][0] = 'A';\n            grid[1][1] = 'B';\n        }\n        outputGrid(grid);\n    } else if (type == \"multiple_cycles\") {\n        vector<string> grid(n, string(m, 'B'));\n        if (n >= 4 && m >= 4) {\n            // Top-left cycle\n            grid[0][0] = grid[0][1] = grid[1][0] = grid[1][1] = 'A';\n            // Bottom-right cycle\n            grid[n - 2][m - 2] = grid[n - 2][m - 1] = grid[n - 1][m - 2] = grid[n - 1][m - 1] = 'A';\n        }\n        outputGrid(grid);\n    } else if (type == \"no_cycles\") {\n        char color = rnd.next('A', 'Z');\n        vector<string> grid(n, string(m, color));\n\n        // Break cycles by clearing some cells\n        for (int i = 0; i < n; ++i) {\n            for (int j = (i == 0 ? 1 : 0); j < m; ++j) {\n                grid[i][j] = 'B';\n            }\n        }\n        outputGrid(grid);\n    } else {\n        // Unknown type, default to random\n        int num_colors = rnd.next(1, 26); // Between 1 and 26 colors\n        vector<char> colors(num_colors);\n        for (int i = 0; i < num_colors; ++i) {\n            colors[i] = 'A' + i;\n        }\n        vector<string> grid(n, string(m, 'A'));\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < m; ++j) {\n                grid[i][j] = colors[rnd.next(0, num_colors - 1)];\n            }\n        }\n        outputGrid(grid);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nvoid outputGrid(const vector<string>& grid) {\n    printf(\"%d %d\\n\", int(grid.size()), int(grid[0].size()));\n    for (const string& row : grid) {\n        printf(\"%s\\n\", row.c_str());\n    }\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string type = opt<string>(\"type\", \"random\");\n\n    if (type == \"random\") {\n        // Randomly populate grid with random colors\n        int num_colors = rnd.next(1, 26); // Between 1 and 26 colors\n        vector<char> colors(num_colors);\n        for (int i = 0; i < num_colors; ++i) {\n            colors[i] = 'A' + i;\n        }\n        vector<string> grid(n, string(m, 'A'));\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < m; ++j) {\n                grid[i][j] = colors[rnd.next(0, num_colors - 1)];\n            }\n        }\n        outputGrid(grid);\n    } else if (type == \"all_same_color\") {\n        char color = rnd.next('A', 'Z');\n        vector<string> grid(n, string(m, color));\n        outputGrid(grid);\n    } else if (type == \"checkerboard\") {\n        vector<string> grid(n, string(m, 'A'));\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < m; ++j) {\n                grid[i][j] = ((i + j) % 2 == 0) ? 'A' : 'B';\n            }\n        }\n        outputGrid(grid);\n    } else if (type == \"single_cycle\") {\n        vector<string> grid(n, string(m, 'B')); // Fill with 'B'\n\n        // Create a cycle of color 'A'\n        if (n >= 2 && m >= 2) {\n            grid[0][0] = grid[0][1] = grid[1][0] = grid[1][1] = 'A';\n        }\n        outputGrid(grid);\n    } else if (type == \"large_cycle\") {\n        vector<string> grid(n, string(m, 'B')); // Fill with 'B'\n\n        char color = 'A';\n\n        // Make the border cells to be 'A's, forming a cycle along the border.\n        for (int i = 0; i < n; ++i) {\n            grid[i][0] = color;\n            grid[i][m - 1] = color;\n        }\n        for (int j = 0; j < m; ++j) {\n            grid[0][j] = color;\n            grid[n - 1][j] = color;\n        }\n        outputGrid(grid);\n    } else if (type == \"diagonal\") {\n        vector<string> grid(n, string(m, 'B')); // Fill with 'B'\n        char color = 'A';\n        int diag_len = min(n, m);\n        for (int i = 0; i < diag_len; ++i) {\n            grid[i][i] = color;\n        }\n        outputGrid(grid);\n    } else if (type == \"minimal_no_cycle\") {\n        vector<string> grid(n, string(m, 'B'));\n        if (n >= 2 && m >= 2) {\n            grid[0][0] = grid[0][1] = grid[1][0] = 'A';\n            grid[1][1] = 'B';\n        }\n        outputGrid(grid);\n    } else if (type == \"multiple_cycles\") {\n        vector<string> grid(n, string(m, 'B'));\n        if (n >= 4 && m >= 4) {\n            // Top-left cycle\n            grid[0][0] = grid[0][1] = grid[1][0] = grid[1][1] = 'A';\n            // Bottom-right cycle\n            grid[n - 2][m - 2] = grid[n - 2][m - 1] = grid[n - 1][m - 2] = grid[n - 1][m - 1] = 'A';\n        }\n        outputGrid(grid);\n    } else if (type == \"no_cycles\") {\n        char color = rnd.next('A', 'Z');\n        vector<string> grid(n, string(m, color));\n\n        // Break cycles by clearing some cells\n        for (int i = 0; i < n; ++i) {\n            for (int j = (i == 0 ? 1 : 0); j < m; ++j) {\n                grid[i][j] = 'B';\n            }\n        }\n        outputGrid(grid);\n    } else {\n        // Unknown type, default to random\n        int num_colors = rnd.next(1, 26); // Between 1 and 26 colors\n        vector<char> colors(num_colors);\n        for (int i = 0; i < num_colors; ++i) {\n            colors[i] = 'A' + i;\n        }\n        vector<string> grid(n, string(m, 'A'));\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < m; ++j) {\n                grid[i][j] = colors[rnd.next(0, num_colors - 1)];\n            }\n        }\n        outputGrid(grid);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 2 -m 2 -type minimal_no_cycle\n./gen -n 2 -m 2 -type all_same_color\n./gen -n 2 -m 2 -type random\n\n./gen -n 3 -m 4 -type random\n./gen -n 3 -m 4 -type checkerboard\n./gen -n 3 -m 4 -type all_same_color\n./gen -n 3 -m 4 -type single_cycle\n./gen -n 3 -m 4 -type no_cycles\n./gen -n 3 -m 4 -type large_cycle\n./gen -n 3 -m 4 -type diagonal\n./gen -n 3 -m 4 -type minimal_no_cycle\n./gen -n 3 -m 4 -type multiple_cycles\n\n./gen -n 7 -m 6 -type multiple_cycles\n\n./gen -n 10 -m 10 -type random\n./gen -n 10 -m 10 -type checkerboard\n./gen -n 10 -m 10 -type all_same_color\n./gen -n 10 -m 10 -type single_cycle\n./gen -n 10 -m 10 -type no_cycles\n./gen -n 10 -m 10 -type large_cycle\n./gen -n 10 -m 10 -type diagonal\n./gen -n 10 -m 10 -type minimal_no_cycle\n./gen -n 10 -m 10 -type multiple_cycles\n\n./gen -n 20 -m 30 -type checkerboard\n./gen -n 30 -m 20 -type random\n\n./gen -n 50 -m 50 -type random\n./gen -n 50 -m 50 -type checkerboard\n./gen -n 50 -m 50 -type all_same_color\n./gen -n 50 -m 50 -type single_cycle\n./gen -n 50 -m 50 -type no_cycles\n./gen -n 50 -m 50 -type large_cycle\n./gen -n 50 -m 50 -type diagonal\n./gen -n 50 -m 50 -type minimal_no_cycle\n./gen -n 50 -m 50 -type multiple_cycles\n\n./gen -n 2 -m 13 -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:41:36.647506",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "510/C",
      "title": "C. Fox And Names",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains an integer n (1 ≤ n ≤ 100): number of names.Each of the following n lines contain one string namei (1 ≤ |namei| ≤ 100), the i-th name. Each name contains only lowercase Latin letters. All names are different.",
      "output_spec": "OutputIf there exists such order of letters that the given names are sorted lexicographically, output any such order as a permutation of characters 'a'–'z' (i. e. first output the first letter of the modified alphabet, then the second, and so on).Otherwise output a single word \"Impossible\" (without quotes).",
      "sample_tests": "ExamplesInputCopy3rivestshamiradlemanOutputCopybcdefghijklmnopqrsatuvwxyzInputCopy10touristpetrwjmzbmryeputonsvepifanovscottwuoooooooooooooooosubscriberrowdarktankengineerOutputCopyImpossibleInputCopy10petregorendagorionfeferivanilovetanyaromanovakostkadmitriyhmaratsnowbearbredorjaguarturnikcgyforeverOutputCopyaghjlnopefikdmbcqrstuvwxyzInputCopy7carcarecarefulcarefullybecarefuldontforgetsomethingotherwiseyouwillbehackedgoodluckOutputCopyacbdefhijklmnogpqrstuvwxyz",
      "description": "C. Fox And Names\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains an integer n (1 ≤ n ≤ 100): number of names.Each of the following n lines contain one string namei (1 ≤ |namei| ≤ 100), the i-th name. Each name contains only lowercase Latin letters. All names are different.\n\nOutputIf there exists such order of letters that the given names are sorted lexicographically, output any such order as a permutation of characters 'a'–'z' (i. e. first output the first letter of the modified alphabet, then the second, and so on).Otherwise output a single word \"Impossible\" (without quotes).\n\nInputCopy3rivestshamiradlemanOutputCopybcdefghijklmnopqrsatuvwxyzInputCopy10touristpetrwjmzbmryeputonsvepifanovscottwuoooooooooooooooosubscriberrowdarktankengineerOutputCopyImpossibleInputCopy10petregorendagorionfeferivanilovetanyaromanovakostkadmitriyhmaratsnowbearbredorjaguarturnikcgyforeverOutputCopyaghjlnopefikdmbcqrstuvwxyzInputCopy7carcarecarefulcarefullybecarefuldontforgetsomethingotherwiseyouwillbehackedgoodluckOutputCopyacbdefhijklmnogpqrstuvwxyz\n\nInputCopy3rivestshamiradleman\n\nOutputCopybcdefghijklmnopqrsatuvwxyz\n\nInputCopy10touristpetrwjmzbmryeputonsvepifanovscottwuoooooooooooooooosubscriberrowdarktankengineer\n\nOutputCopyImpossible\n\nInputCopy10petregorendagorionfeferivanilovetanyaromanovakostkadmitriyhmaratsnowbearbredorjaguarturnikcgyforever\n\nOutputCopyaghjlnopefikdmbcqrstuvwxyz\n\nInputCopy7carcarecarefulcarefullybecarefuldontforgetsomethingotherwiseyouwillbehackedgoodluck\n\nOutputCopyacbdefhijklmnogpqrstuvwxyz",
      "solutions": [
        {
          "title": "Codeforces Round #290 - Codeforces",
          "content": "Fox Ciel is back!I invite you to participate in Codeforces Round #290, which will start at the standard time on next Monday: This is my 4th round on Codeforces, my previous rounds: #190, #228, #270.Last Div1 Round (#286) is so hard, so after notice that, we decide to reduce the difficulty of this round. (For example, current Div1-E was used as Div1-D) I hope more people can enjoy all tasks in this round: this time no task requires advanced knowledge like linear space or Fourier Transform.The background story will be Fox Ciel's life: learning programming, play games, traveling, have dinner and so on.Like Round #228, top-20 contestants that are currently at Petrozavodsk training camp will be rewarded with nice Codefores T-Shirts. Contestant may be a team member, jury, coach, organizer, or whoever else involved in camp, no matter of status.As usual, thanks to Zlobober for giving great suggestions and test my round, and MikeMirzayanov for the platform (Codeforces and Polygon). Good luck and have fun!Update1: Score Distribution is ... Div2: Standard (500 — 1000 — 1500 — 2000 — 2500), Div1: a bit unusual ... (500 — 1000 — 1500 — 2250 — 2250)Update2: Editorial: http://codeforces.com/blog/entry/16173Update3: Congratulation to our winners:Div1: Petr Endagorion mmaxio jqdai0815 tourist They are all people who solved 5 tasks!Div2: SkullSkin joshkirstein gabrielinelus UnknownNooby Andrey_WK",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/16147",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1401
        },
        {
          "title": "Codeforces Round #290 Editorial - Codeforces",
          "content": "Update 1 : here are the reference solutions for this contest: Div2-A: http://ideone.com/JP1Ksj DIv2-B: http://ideone.com/udz3bN Div2-C / Div1-A: http://ideone.com/KVobNb Div2-D / Div1-B: http://ideone.com/7MQqOm Div2-E / Div1-C: http://ideone.com/z3FsU2 Div1-D: http://ideone.com/Y7j21a Div1-E: http://ideone.com/Orbacp Note that for Div2-E / Div1-C, it is for the harder version: we need to handle '1' in the cycle.510A - Fox And SnakeThere are 2 different ways to solve this kind of task:First one is to simulate the movement of the snake head, and you draw '#'s on the board. The code will look like: head = (1, 1)\nrepeat:\n\trepeat m-1 times: head move to right\n\trepeat 2 times: head move down\n\trepeat 2 times: head move down\n\trepeat m-1 times: head move to left\n\trepeat 2 times: head move down\n\trepeat 2 times: head move down\nuntil head is out of the boardAnother way is to do some observation about the result, you can find this pattern: (4k+1) / (4k+3) line: \"#######\"\n(4k+2) line: \".......#\"\n(4k+0) line: \"#.......\"510B - Fox And Two DotsThis task is essentially ask if there is a cycle in an undirected graph: treat each cell as a node, and add an edge if two cells are neighborhood and have some color.There are lots of ways to do this, for example: Run dfs / bfs, if an edge lead you to a visited node, then there must be a cycle. For each connected component, test if |#edges| = |#nodes| - 1, if not then there must be a cycle. 510C - Fox And Names / 512A - Fox And NamesLet's first think about what S < T can tell us: suppose S = abcxyz and T = abcuv. Then we know that S < T if and only if x < u by the definition.So we can transform the conditions name1 < name2, name2 < name3 ... into the order of letters.Then the question become: do we have a permutation that satisfy those conditions. It is actually the classic topological order question.One trick in this task is that, if we have something like xy < x then there is no solution. This is not covered in pretests. :)510D - Fox And Jumping / 512B - Fox And JumpingThis task equals to: what is the minimal sum of costs that we can select k cards, so their GCD is 1.First observation is that: GCD(x1, x2, ..., xk) = 1 means that for any prime p, there exist i such that xi is not dividable by p. So we only care about what prime factors a number contain. (So for example, 12 -> {2, 3}, 6 -> {2, 3}, 9 -> {3]})The second observation is: If x ≤ 109 then it has at most 9 prime factors.So after we select one number, we only care about these 9 or less primes. Then this problem equals to set covering problem (SCP), it can be done by mask DP. It can run in about O(2^9 * n^2).510E - Fox And Dinner / 512C - Fox And DinnerFirst finding is: if a + b is a prime, then one of them is an odd number, another is an even number. (that's why we set 2 ≤ xi)Then we could find: every odd number have exactly 2 even number as neighborhood, and every even number have exactly 2 odd number as neighborhood. And that means we need |#even| = |#odd| to have a solution.So it looks like bipartite graph matching, but every element matched 2 elements. And in fact it can be handled by maxflow: For each odd number, we add a node on the left side and link it from source with capacity equals to 2, and for each even number, we add a node on the right side and link it to sink with capacity equals to 2. And if sum of two numbers is a prime number, we link them with capacity equals to 1.Then we solve the max flow, it have solution if and only if maxflow = 2 * |#even|.We can construct the answer(cycles) from the matches.Note: Actually this task is still solvable if we allow ai = 1. But you need some clever way to deal with it. We think it is too hard so we removed this case. What do you think about this decision?512D - Fox And TravellingWe could find that some nodes cannot be visited. And more specific, if one node is in a cycle then it cannot be visited. So what about the structure of nodes that we can visit?Let's first find a way to get all nodes that could be visited. We can deal with this by something like biconnected decomposition, but that is not easy to implement. In fact we can use this simple method: each time we pick one node that have at most 1 neighborhood and delete it. Repeat this process until we can't do it anymore.We could find these nodes are actually belonging to these 2 kinds: 1. A tree. 2. Rooted tree. (that means, the root is attached to a cycle)The rooted tree case is simple: we can solve it by tree DP. The state will be dp[i][j] = the way to remove j nodes in the subtree rooted at i.Then how to solve the unrooted tree case? The way to deal with that is to transform it into rooted case. We have 2 solution: We select one unvisited node as the root by some rules: for example, we select one with minimal index. Then we just need to modify the DP a bit to adjust this additional condition. We could find if the tree has n nodes and we visit k nodes in the end, then there will be max(1, n-k) ways to choose the root. That means if we choose every node as the root and sum up them, we will count this case exactly max(1, n-k) times. So we just do the rooted DP for from node n times, and divide max(1, n-k) for ans[k]. The overall complicity is O(n4), and it can be optimize into O(n3) if you like.512E - Fox And PolygonTriangulation of polygon is something hard to think about. So the first key observation is that, we can transform this task into operations on rooted trees!One Triangulation of polygon can be mapping to one rooted tree. And the flip operation can be mapping to the rotation of trees. (It is the operation we used to balance our BST) You can find the mapping from above picture. The red lines indicate the edge that will be flipped and the nodes we rotated.Then we should find a standard shape of the tree, and solve this task: how to rotate any tree into this standard shape?My solution is to choose the balanced tree as standard shape. The way to do that is this: find the node that the index is the middle number, rotate it to the top(that what we did for splay tree), and do the same thing for each subtree.It is easy to see it could work in O(nlogn) steps.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/16173",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 510\\s*C"
          },
          "content_length": 6165
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #290 - Codeforces - Code 1",
          "code": "26\na\nb\nc\n...\nz",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16147",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #290 - Codeforces - Code 2",
          "code": "26\na\nb\nc\n...\nz",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16147",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #290 Editorial - Codeforces - Code 1",
          "code": "head = (1, 1)\nrepeat:\n\trepeat m-1 times: head move to right\n\trepeat 2 times: head move down\n\trepeat 2 times: head move down\n\trepeat m-1 times: head move to left\n\trepeat 2 times: head move down\n\trepeat 2 times: head move down\nuntil head is out of the board",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16173",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #290 Editorial - Codeforces - Code 2",
          "code": "head = (1, 1)\nrepeat:\n\trepeat m-1 times: head move to right\n\trepeat 2 times: head move down\n\trepeat 2 times: head move down\n\trepeat m-1 times: head move to left\n\trepeat 2 times: head move down\n\trepeat 2 times: head move down\nuntil head is out of the board",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16173",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #290 Editorial - Codeforces - Code 3",
          "code": "(4k+1) / (4k+3) line: \"#######\"\n(4k+2) line: \".......#\"\n(4k+0) line: \"#.......\"",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16173",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #290 Editorial - Codeforces - Code 4",
          "code": "(4k+1) / (4k+3) line: \"#######\"\n(4k+2) line: \".......#\"\n(4k+0) line: \"#.......\"",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16173",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #290 Editorial - Codeforces - Code 5",
          "code": "for (i64 i = 0; i < n; i++) {\n    hepsi[ l[i] ] = c[i];\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16173",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #290 Editorial - Codeforces - Code 6",
          "code": "for (i64 i = 0; i < n; i++) {\n    hepsi[ l[i] ] = c[i];\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16173",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #290 Editorial - Codeforces - Code 7",
          "code": "hepsi[ 0 ] = 0;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16173",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #290 Editorial - Codeforces - Code 8",
          "code": "hepsi[ 0 ] = 0;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16173",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #290 Editorial - Codeforces - Code 9",
          "code": "s = primes.size();\n\nfor(int mask = 0; mask < (1<<s); mask++){\n\tdp[mask] = INF;\n}\n\t\t\ndp[m[i]] = c[i];\n\t\t\nfor(int mask = 0; mask < (1<<s); mask++){\n\tfor(int j = 0; j < n; j++){\n\t\tif(dp[mask] != INF)\n\t\t\tdp[mask | m[j]] = min(dp[mask | m[j]], dp[mask] + c[j]);\n\t}\n}\n\nans = min(ans, dp[(1<<s) - 1]);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16173",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #290 Editorial - Codeforces - Code 10",
          "code": "s = primes.size();\n\nfor(int mask = 0; mask < (1<<s); mask++){\n\tdp[mask] = INF;\n}\n\t\t\ndp[m[i]] = c[i];\n\t\t\nfor(int mask = 0; mask < (1<<s); mask++){\n\tfor(int j = 0; j < n; j++){\n\t\tif(dp[mask] != INF)\n\t\t\tdp[mask | m[j]] = min(dp[mask | m[j]], dp[mask] + c[j]);\n\t}\n}\n\nans = min(ans, dp[(1<<s) - 1]);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16173",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #290 Editorial - Codeforces - Code 11",
          "code": "3 3\nBAB\nAAA\nBAB",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16173",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #290 Editorial - Codeforces - Code 12",
          "code": "3 3\nBAB\nAAA\nBAB",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16173",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #290 Editorial - Codeforces - Code 13",
          "code": "#include<Stdio.h>",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/16173",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #290 Editorial - Codeforces - Code 14",
          "code": "dp[i][sz[i]] = dp[i][sz[i] - 1]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16173",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #290 Editorial - Codeforces - Code 15",
          "code": "dpValue dfs(int cur, int from)\n{\n\tdpValue ret;\n\tret.x[0] = 1;\n\tfor(int i = 0; i < e[cur].size(); i++)\n\t{\n\t\tint t = e[cur][i];\n\t\tif(t == from) continue;\n\t\tret = combine(ret, dfs(t, cur));\n\t}\n\tfor(int i = 0; i < MAXN; i++)\n\t\tif(ret.x[i] == 0)\n\t\t{\n\t\t\tret.x[i] = ret.x[i-1];\n\t\t\tbreak;\n\t\t}\n\treturn ret;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16173",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #290 Editorial - Codeforces - Code 16",
          "code": "dpValue dfs(int cur, int from)\n{\n\tdpValue ret;\n\tret.x[0] = 1;\n\tfor(int i = 0; i < e[cur].size(); i++)\n\t{\n\t\tint t = e[cur][i];\n\t\tif(t == from) continue;\n\t\tret = combine(ret, dfs(t, cur));\n\t}\n\tfor(int i = 0; i < MAXN; i++)\n\t\tif(ret.x[i] == 0)\n\t\t{\n\t\t\tret.x[i] = ret.x[i-1];\n\t\t\tbreak;\n\t\t}\n\treturn ret;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16173",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #290 Editorial - Codeforces - Code 17",
          "code": "dpValue combine(dpValue A, dpValue B)\n{\n\tdpValue ret;\n\tfor(int i = 0; i < MAXN; i++)\n\t\tfor(int j = 0; i+j < MAXN; j++)\n\t\t{\n\t\t\tret.x[i+j] += ((A.x[i] * B.x[j]) % mod) * C(i+j, i);\n\t\t\tret.x[i+j] %= mod;\n\t\t}\n\treturn ret;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16173",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #290 Editorial - Codeforces - Code 18",
          "code": "dpValue combine(dpValue A, dpValue B)\n{\n\tdpValue ret;\n\tfor(int i = 0; i < MAXN; i++)\n\t\tfor(int j = 0; i+j < MAXN; j++)\n\t\t{\n\t\t\tret.x[i+j] += ((A.x[i] * B.x[j]) % mod) * C(i+j, i);\n\t\t\tret.x[i+j] %= mod;\n\t\t}\n\treturn ret;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16173",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #290 Editorial - Codeforces - Code 19",
          "code": "4\n2 4 5 7\n1 1 1 1000000000",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16173",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #290 Editorial - Codeforces - Code 20",
          "code": "4\n2 4 5 7\n1 1 1 1000000000",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16173",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readEoln();\n    set<string> names;\n    for (int i = 0; i < n; i++) {\n        string s = inf.readLine(\"[a-z]{1,100}\");\n        ensuref(names.count(s) == 0, \"All names must be different, but name[%d]='%s' is repeated\", i+1, s.c_str());\n        names.insert(s);\n    }\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readEoln();\n    set<string> names;\n    for (int i = 0; i < n; i++) {\n        string s = inf.readLine(\"[a-z]{1,100}\");\n        ensuref(names.count(s) == 0, \"All names must be different, but name[%d]='%s' is repeated\", i+1, s.c_str());\n        names.insert(s);\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readEoln();\n    set<string> names;\n    for (int i = 0; i < n; i++) {\n        string s = inf.readLine(\"[a-z]{1,100}\");\n        ensuref(names.count(s) == 0, \"All names must be different, but name[%d]='%s' is repeated\", i+1, s.c_str());\n        names.insert(s);\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[])\n{\n    registerTestlibCmd(argc, argv);\n\n    // Read the input values from the test input file.\n    int n = inf.readInt();\n    vector<string> names(n);\n    for (int i = 0; i < n; i++) {\n        names[i] = inf.readToken();\n    }\n\n    // Safely read the jury's output (ans).\n    if (ans.seekEof()) {\n        quitf(_fail, \"Jury's answer is missing\");\n    }\n    string juryAnswer = ans.readToken();\n\n    // Safely read the contestant's output (ouf).\n    if (ouf.seekEof()) {\n        quitf(_wa, \"Contestant's output is missing\");\n    }\n    string contAnswer = ouf.readToken();\n\n    // If the jury's answer is \"Impossible\", that means no valid ordering exists.\n    if (juryAnswer == \"Impossible\") {\n        // The only correct output for the contestant is also \"Impossible\".\n        if (contAnswer == \"Impossible\") {\n            quitf(_ok, \"Both jury and contestant say 'Impossible'\");\n        } else {\n            quitf(_wa, \"Jury says 'Impossible' (no valid ordering), but contestant gave a different answer\");\n        }\n    }\n\n    // Otherwise, the jury's answer is guaranteed to be a valid ordering of letters,\n    // so the contestant must also provide a valid ordering (or say \"Impossible\").\n    if (contAnswer == \"Impossible\") {\n        quitf(_wa, \"Jury found a valid ordering, but contestant says 'Impossible'\");\n    }\n\n    // Check that the contestant's answer is exactly 26 letters and a permutation of [a-z].\n    if ((int)contAnswer.size() != 26) {\n        quitf(_wa, \"Contestant's answer is not 26 characters long\");\n    }\n    vector<bool> used(26, false);\n    for (char c : contAnswer) {\n        if (c < 'a' || c > 'z') {\n            quitf(_wa, \"Character '%c' in the order is invalid (not in [a-z])\", c);\n        }\n        if (used[c - 'a']) {\n            quitf(_wa, \"Duplicate letter '%c' in the ordering\", c);\n        }\n        used[c - 'a'] = true;\n    }\n\n    // Create rank array: rank[c - 'a'] = position of c in the contestant's order.\n    vector<int> rank(26);\n    for (int i = 0; i < 26; i++) {\n        rank[contAnswer[i] - 'a'] = i;\n    }\n\n    // Check if 'names' are sorted under the contestant's alphabet order.\n    for (int i = 0; i + 1 < n; i++) {\n        const string &s = names[i], &t = names[i + 1];\n        // Compare s and t lexicographically according to 'rank'.\n        bool sortedCorrectly = false;\n        int len = min(s.size(), t.size());\n        int j = 0;\n        for (; j < len; j++) {\n            if (s[j] != t[j]) {\n                // Compare by rank\n                if (rank[s[j] - 'a'] < rank[t[j] - 'a']) {\n                    sortedCorrectly = true;\n                }\n                break;\n            }\n        }\n        // If all characters up to j match, the shorter name must come first or be the same name\n        if (!sortedCorrectly) {\n            if (j == len && s.size() <= t.size()) {\n                sortedCorrectly = true;\n            }\n        }\n        if (!sortedCorrectly) {\n            quitf(_wa, \"Names are not sorted; comparison failed between \\\"%s\\\" and \\\"%s\\\"\",\n                  s.c_str(), t.c_str());\n        }\n    }\n\n    // If we reach here, the contestant's ordering is valid.\n    quitf(_ok, \"Contestant's ordering is valid\");\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<string> names;\n\n    if (type == \"random\") {\n        // Generate n random names\n        while ((int)names.size() < n) {\n            int len = rnd.next(1, 100); // Length between 1 and 100\n            string s;\n            for (int j = 0; j < len; ++j) {\n                char c = 'a' + rnd.next(26); // Random letter between 'a' and 'z'\n                s += c;\n            }\n            if (find(names.begin(), names.end(), s) == names.end()) {\n                names.push_back(s);\n            }\n        }\n    } else if (type == \"cycle\") {\n        // Generate names that produce a cycle in the constraints\n        int k = opt<int>(\"k\", 3); // Number of letters in the cycle\n        if (k < 2 || k > 26) k = 3; // Limit k between 2 and 26\n        vector<char> letters;\n        for (int i = 0; i < k; ++i) {\n            letters.push_back('a' + i);\n        }\n        // Construct names to create constraints a1 < a2, a2 < a3, ..., a_k < a1\n        for (int i = 0; i < k; ++i) {\n            string name;\n            name += letters[i];\n            name += letters[(i+1)%k];\n            names.push_back(name);\n        }\n        // Pad names to reach n\n        while ((int)names.size() < n) {\n            string name;\n            int len = rnd.next(1, 100);\n            for (int i = 0; i < len; ++i) {\n                char c = letters[rnd.next(k)];\n                name += c;\n            }\n            if (find(names.begin(), names.end(), name) == names.end()) {\n                names.push_back(name);\n            }\n        }\n    } else if (type == \"acyclic\") {\n        // Generate names that produce acyclic constraints\n        vector<char> letters(26);\n        for (int i = 0; i < 26; ++i) {\n            letters[i] = 'a' + i;\n        }\n        shuffle(letters.begin(), letters.end());\n        // Generate names to enforce the letter order in letters[0..25]\n        for (int i = 0; i < 25; ++i) {\n            string name1;\n            string name2;\n            name1 += letters[i];\n            name1 += 'a'; // Additional character to ensure length >= 2\n            name2 += letters[i+1];\n            name2 += 'a';\n            if (find(names.begin(), names.end(), name1) == names.end()) {\n                names.push_back(name1);\n            }\n            if (find(names.begin(), names.end(), name2) == names.end()) {\n                names.push_back(name2);\n            }\n        }\n        // Pad names to reach n\n        while ((int)names.size() < n) {\n            int len = rnd.next(1, 100);\n            string name;\n            for (int i = 0; i < len; ++i) {\n                char c = 'a' + rnd.next(26);\n                name += c;\n            }\n            if (find(names.begin(), names.end(), name) == names.end()) {\n                names.push_back(name);\n            }\n        }\n    } else if (type == \"prefix\") {\n        // Generate names where one is prefix of another\n        string base = \"\";\n        int len = 1;\n        for (int i = 0; i < n; ++i) {\n            if (i%10 == 0 && len < 100) ++len;\n            base += 'a' + rnd.next(26);\n            string name = base.substr(0, len);\n            if (find(names.begin(), names.end(), name) == names.end()) {\n                names.push_back(name);\n            }\n        }\n    } else if (type == \"maxlen\") {\n        // Generate names with maximum length\n        while ((int)names.size() < n) {\n            string s;\n            for (int j = 0; j < 100; ++j) {\n                char c = 'a' + rnd.next(26);\n                s += c;\n            }\n            if (find(names.begin(), names.end(), s) == names.end()) {\n                names.push_back(s);\n            }\n        }\n    } else {\n        // Default to random if type is unknown\n        while ((int)names.size() < n) {\n            int len = rnd.next(1, 100);\n            string s;\n            for (int j = 0; j < len; ++j) {\n                char c = 'a' + rnd.next(26);\n                s += c;\n            }\n            if (find(names.begin(), names.end(), s) == names.end()) {\n                names.push_back(s);\n            }\n        }\n    }\n\n    // Shuffle names to ensure random order\n    shuffle(names.begin(), names.end());\n\n    // Output n\n    printf(\"%d\\n\", n);\n    for (const string& name : names) {\n        printf(\"%s\\n\", name.c_str());\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<string> names;\n\n    if (type == \"random\") {\n        // Generate n random names\n        while ((int)names.size() < n) {\n            int len = rnd.next(1, 100); // Length between 1 and 100\n            string s;\n            for (int j = 0; j < len; ++j) {\n                char c = 'a' + rnd.next(26); // Random letter between 'a' and 'z'\n                s += c;\n            }\n            if (find(names.begin(), names.end(), s) == names.end()) {\n                names.push_back(s);\n            }\n        }\n    } else if (type == \"cycle\") {\n        // Generate names that produce a cycle in the constraints\n        int k = opt<int>(\"k\", 3); // Number of letters in the cycle\n        if (k < 2 || k > 26) k = 3; // Limit k between 2 and 26\n        vector<char> letters;\n        for (int i = 0; i < k; ++i) {\n            letters.push_back('a' + i);\n        }\n        // Construct names to create constraints a1 < a2, a2 < a3, ..., a_k < a1\n        for (int i = 0; i < k; ++i) {\n            string name;\n            name += letters[i];\n            name += letters[(i+1)%k];\n            names.push_back(name);\n        }\n        // Pad names to reach n\n        while ((int)names.size() < n) {\n            string name;\n            int len = rnd.next(1, 100);\n            for (int i = 0; i < len; ++i) {\n                char c = letters[rnd.next(k)];\n                name += c;\n            }\n            if (find(names.begin(), names.end(), name) == names.end()) {\n                names.push_back(name);\n            }\n        }\n    } else if (type == \"acyclic\") {\n        // Generate names that produce acyclic constraints\n        vector<char> letters(26);\n        for (int i = 0; i < 26; ++i) {\n            letters[i] = 'a' + i;\n        }\n        shuffle(letters.begin(), letters.end());\n        // Generate names to enforce the letter order in letters[0..25]\n        for (int i = 0; i < 25; ++i) {\n            string name1;\n            string name2;\n            name1 += letters[i];\n            name1 += 'a'; // Additional character to ensure length >= 2\n            name2 += letters[i+1];\n            name2 += 'a';\n            if (find(names.begin(), names.end(), name1) == names.end()) {\n                names.push_back(name1);\n            }\n            if (find(names.begin(), names.end(), name2) == names.end()) {\n                names.push_back(name2);\n            }\n        }\n        // Pad names to reach n\n        while ((int)names.size() < n) {\n            int len = rnd.next(1, 100);\n            string name;\n            for (int i = 0; i < len; ++i) {\n                char c = 'a' + rnd.next(26);\n                name += c;\n            }\n            if (find(names.begin(), names.end(), name) == names.end()) {\n                names.push_back(name);\n            }\n        }\n    } else if (type == \"prefix\") {\n        // Generate names where one is prefix of another\n        string base = \"\";\n        int len = 1;\n        for (int i = 0; i < n; ++i) {\n            if (i%10 == 0 && len < 100) ++len;\n            base += 'a' + rnd.next(26);\n            string name = base.substr(0, len);\n            if (find(names.begin(), names.end(), name) == names.end()) {\n                names.push_back(name);\n            }\n        }\n    } else if (type == \"maxlen\") {\n        // Generate names with maximum length\n        while ((int)names.size() < n) {\n            string s;\n            for (int j = 0; j < 100; ++j) {\n                char c = 'a' + rnd.next(26);\n                s += c;\n            }\n            if (find(names.begin(), names.end(), s) == names.end()) {\n                names.push_back(s);\n            }\n        }\n    } else {\n        // Default to random if type is unknown\n        while ((int)names.size() < n) {\n            int len = rnd.next(1, 100);\n            string s;\n            for (int j = 0; j < len; ++j) {\n                char c = 'a' + rnd.next(26);\n                s += c;\n            }\n            if (find(names.begin(), names.end(), s) == names.end()) {\n                names.push_back(s);\n            }\n        }\n    }\n\n    // Shuffle names to ensure random order\n    shuffle(names.begin(), names.end());\n\n    // Output n\n    printf(\"%d\\n\", n);\n    for (const string& name : names) {\n        printf(\"%s\\n\", name.c_str());\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -type random\n./gen -n 2 -type random\n./gen -n 3 -type random\n./gen -n 10 -type random\n./gen -n 50 -type random\n./gen -n 99 -type random\n./gen -n 100 -type random\n\n./gen -n 1 -type acyclic\n./gen -n 2 -type acyclic\n./gen -n 10 -type acyclic\n./gen -n 50 -type acyclic\n./gen -n 70 -type acyclic\n./gen -n 100 -type acyclic\n\n./gen -n 1 -type cycle -k 2\n./gen -n 5 -type cycle -k 2\n./gen -n 10 -type cycle -k 3\n./gen -n 10 -type cycle -k 4\n./gen -n 10 -type cycle -k 5\n./gen -n 100 -type cycle -k 5\n./gen -n 100 -type cycle -k 26\n\n./gen -n 3 -type prefix\n./gen -n 4 -type prefix\n./gen -n 10 -type prefix\n./gen -n 20 -type prefix\n./gen -n 50 -type prefix\n\n./gen -n 1 -type maxlen\n./gen -n 10 -type maxlen\n./gen -n 50 -type maxlen\n./gen -n 100 -type maxlen\n\n./gen -n 1 -type random\n./gen -n 100 -type random\n./gen -n 100 -type random\n./gen -n 100 -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:41:38.867771",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "510/D",
      "title": "D. Лиса и прыжки",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест2 секунды",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеВ первой строке записано целое число n (1 ≤ n ≤ 300), количество карточек.Во второй строке записано n чисел li (1 ≤ li ≤ 109), длины прыжков, указанные на карточках.В третьей строке записано n чисел ci (1 ≤ ci ≤ 105), стоимости карточек.",
      "output_spec": "Выходные данныеЕсли невозможно купить некоторое количество карточек и получить возможность прыгнуть в любую ячейку, выведите -1. В противном случае, выведите минимальную стоимость покупки такого набора карточек.",
      "sample_tests": "ПримерыВходные данныеСкопировать3100 99 99001 1 1Выходные данныеСкопировать2Входные данныеСкопировать510 20 30 40 501 1 1 1 1Выходные данныеСкопировать-1Входные данныеСкопировать715015 10010 6006 4290 2730 2310 11 1 1 1 1 1 10Выходные данныеСкопировать6Входные данныеСкопировать84264 4921 6321 6984 2316 8432 6120 10264264 4921 6321 6984 2316 8432 6120 1026Выходные данныеСкопировать7237",
      "description": "D. Лиса и прыжки\n\nограничение по времени на тест2 секунды\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвыводstdout\n\nВходные данныеВ первой строке записано целое число n (1 ≤ n ≤ 300), количество карточек.Во второй строке записано n чисел li (1 ≤ li ≤ 109), длины прыжков, указанные на карточках.В третьей строке записано n чисел ci (1 ≤ ci ≤ 105), стоимости карточек.\n\nВходные данные\n\nВыходные данныеЕсли невозможно купить некоторое количество карточек и получить возможность прыгнуть в любую ячейку, выведите -1. В противном случае, выведите минимальную стоимость покупки такого набора карточек.\n\nВыходные данные\n\nВходные данныеСкопировать3100 99 99001 1 1Выходные данныеСкопировать2Входные данныеСкопировать510 20 30 40 501 1 1 1 1Выходные данныеСкопировать-1Входные данныеСкопировать715015 10010 6006 4290 2730 2310 11 1 1 1 1 1 10Выходные данныеСкопировать6Входные данныеСкопировать84264 4921 6321 6984 2316 8432 6120 10264264 4921 6321 6984 2316 8432 6120 1026Выходные данныеСкопировать7237\n\nВходные данныеСкопировать3100 99 99001 1 1\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать2\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать510 20 30 40 501 1 1 1 1\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать-1\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать715015 10010 6006 4290 2730 2310 11 1 1 1 1 1 10\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать6\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать84264 4921 6321 6984 2316 8432 6120 10264264 4921 6321 6984 2316 8432 6120 1026\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать7237\n\nВыходные данныеСкопировать\n\nСкопировать\n\nПримечаниеВ первом примере недостаточно купить одну карточку: например, если купить карточку для прыжков длины 100, то нельзя прыгнуть ни в одну ячейку, номер которой не кратен 100. Оптимальный способ — купить первую и вторую карточку, тогда можно будет добраться до любой ячейки.Во втором примере, даже если купить все карточки, то вы не сможете прыгнуть ни в одну ячейку, номер которой не кратен 10, так что ответ — -1.",
      "solutions": [
        {
          "title": "Codeforces Round #290 - Codeforces",
          "content": "Лиса Ciel возвращается!Все приглашаются поучаствовать в Codeforces Round #290, который начинается в обычное время в ближайший понедельник.Это мой четвёртый раунд на Codeforces, можете ознакомиться с моими предыдущими раундами: #190, #228, #270.Последний Div1-раунд (#286) оказался очень непростым, поэтому мы решили уменьшить сложность раунда (например, Div1-E превратилась в Div1-D). Надеюсь, это позволит большому количеству людей насладиться всеми задачами раунда: в этот раз ни одна задача не требует продвинутых знаний наподобие линейной алгебры или преобразования Фурье.Главным персонажем раунда будет Лиса Ciel и её жизнь: она учится программировать, играет, путешествует, принимает ужин, а также делает многое другое.Как и на раунде #228, топ-20 участников, присутствующих на зимних сборах в Петрозаводске, будут награждены футболочками Codeforces. Футболку может получить любой участник сборов, член жюри, тренер, организатор или любой другой человек, так или иначе присутствующий на сборах.Как обычно, спасибо Zlobober за ценные советы и помощь в подготовке моего раунда, и MikeMirzayanov за платформы Codeforces и Polygon.Удачи! Update1: Score Distribution is ... Div2: Standard (500 — 1000 — 1500 — 2000 — 2500), Div1: a bit unusual ... (500 — 1000 — 1500 — 2250 — 2250)Update2: Editorial: http://codeforces.com/blog/entry/16173Update3: Congratulation to our winners:Div1: Petr Endagorion mmaxio jqdai0815 tourist They are all people who solved 5 tasks!Div2: SkullSkin joshkirstein gabrielinelus UnknownNooby Andrey_WK",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/16147",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1530
        },
        {
          "title": "Codeforces Round #290 Editorial - Codeforces",
          "content": "Update 1 : here are the reference solutions for this contest: Div2-A: http://ideone.com/JP1Ksj DIv2-B: http://ideone.com/udz3bN Div2-C / Div1-A: http://ideone.com/KVobNb Div2-D / Div1-B: http://ideone.com/7MQqOm Div2-E / Div1-C: http://ideone.com/z3FsU2 Div1-D: http://ideone.com/Y7j21a Div1-E: http://ideone.com/Orbacp Note that for Div2-E / Div1-C, it is for the harder version: we need to handle '1' in the cycle.510A - Fox And SnakeThere are 2 different ways to solve this kind of task:First one is to simulate the movement of the snake head, and you draw '#'s on the board. The code will look like: head = (1, 1)\nrepeat:\n\trepeat m-1 times: head move to right\n\trepeat 2 times: head move down\n\trepeat 2 times: head move down\n\trepeat m-1 times: head move to left\n\trepeat 2 times: head move down\n\trepeat 2 times: head move down\nuntil head is out of the boardAnother way is to do some observation about the result, you can find this pattern: (4k+1) / (4k+3) line: \"#######\"\n(4k+2) line: \".......#\"\n(4k+0) line: \"#.......\"510B - Fox And Two DotsThis task is essentially ask if there is a cycle in an undirected graph: treat each cell as a node, and add an edge if two cells are neighborhood and have some color.There are lots of ways to do this, for example: Run dfs / bfs, if an edge lead you to a visited node, then there must be a cycle. For each connected component, test if |#edges| = |#nodes| - 1, if not then there must be a cycle. 510C - Fox And Names / 512A - Fox And NamesLet's first think about what S < T can tell us: suppose S = abcxyz and T = abcuv. Then we know that S < T if and only if x < u by the definition.So we can transform the conditions name1 < name2, name2 < name3 ... into the order of letters.Then the question become: do we have a permutation that satisfy those conditions. It is actually the classic topological order question.One trick in this task is that, if we have something like xy < x then there is no solution. This is not covered in pretests. :)510D - Fox And Jumping / 512B - Fox And JumpingThis task equals to: what is the minimal sum of costs that we can select k cards, so their GCD is 1.First observation is that: GCD(x1, x2, ..., xk) = 1 means that for any prime p, there exist i such that xi is not dividable by p. So we only care about what prime factors a number contain. (So for example, 12 -> {2, 3}, 6 -> {2, 3}, 9 -> {3]})The second observation is: If x ≤ 109 then it has at most 9 prime factors.So after we select one number, we only care about these 9 or less primes. Then this problem equals to set covering problem (SCP), it can be done by mask DP. It can run in about O(2^9 * n^2).510E - Fox And Dinner / 512C - Fox And DinnerFirst finding is: if a + b is a prime, then one of them is an odd number, another is an even number. (that's why we set 2 ≤ xi)Then we could find: every odd number have exactly 2 even number as neighborhood, and every even number have exactly 2 odd number as neighborhood. And that means we need |#even| = |#odd| to have a solution.So it looks like bipartite graph matching, but every element matched 2 elements. And in fact it can be handled by maxflow: For each odd number, we add a node on the left side and link it from source with capacity equals to 2, and for each even number, we add a node on the right side and link it to sink with capacity equals to 2. And if sum of two numbers is a prime number, we link them with capacity equals to 1.Then we solve the max flow, it have solution if and only if maxflow = 2 * |#even|.We can construct the answer(cycles) from the matches.Note: Actually this task is still solvable if we allow ai = 1. But you need some clever way to deal with it. We think it is too hard so we removed this case. What do you think about this decision?512D - Fox And TravellingWe could find that some nodes cannot be visited. And more specific, if one node is in a cycle then it cannot be visited. So what about the structure of nodes that we can visit?Let's first find a way to get all nodes that could be visited. We can deal with this by something like biconnected decomposition, but that is not easy to implement. In fact we can use this simple method: each time we pick one node that have at most 1 neighborhood and delete it. Repeat this process until we can't do it anymore.We could find these nodes are actually belonging to these 2 kinds: 1. A tree. 2. Rooted tree. (that means, the root is attached to a cycle)The rooted tree case is simple: we can solve it by tree DP. The state will be dp[i][j] = the way to remove j nodes in the subtree rooted at i.Then how to solve the unrooted tree case? The way to deal with that is to transform it into rooted case. We have 2 solution: We select one unvisited node as the root by some rules: for example, we select one with minimal index. Then we just need to modify the DP a bit to adjust this additional condition. We could find if the tree has n nodes and we visit k nodes in the end, then there will be max(1, n-k) ways to choose the root. That means if we choose every node as the root and sum up them, we will count this case exactly max(1, n-k) times. So we just do the rooted DP for from node n times, and divide max(1, n-k) for ans[k]. The overall complicity is O(n4), and it can be optimize into O(n3) if you like.512E - Fox And PolygonTriangulation of polygon is something hard to think about. So the first key observation is that, we can transform this task into operations on rooted trees!One Triangulation of polygon can be mapping to one rooted tree. And the flip operation can be mapping to the rotation of trees. (It is the operation we used to balance our BST) You can find the mapping from above picture. The red lines indicate the edge that will be flipped and the nodes we rotated.Then we should find a standard shape of the tree, and solve this task: how to rotate any tree into this standard shape?My solution is to choose the balanced tree as standard shape. The way to do that is this: find the node that the index is the middle number, rotate it to the top(that what we did for splay tree), and do the same thing for each subtree.It is easy to see it could work in O(nlogn) steps.",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/16173",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 510\\s*D"
          },
          "content_length": 6165
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #290 - Codeforces - Code 1",
          "code": "26\na\nb\nc\n...\nz",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16147",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #290 - Codeforces - Code 2",
          "code": "26\na\nb\nc\n...\nz",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16147",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #290 Editorial - Codeforces - Code 1",
          "code": "head = (1, 1)\nrepeat:\n\trepeat m-1 times: head move to right\n\trepeat 2 times: head move down\n\trepeat 2 times: head move down\n\trepeat m-1 times: head move to left\n\trepeat 2 times: head move down\n\trepeat 2 times: head move down\nuntil head is out of the board",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16173",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #290 Editorial - Codeforces - Code 2",
          "code": "head = (1, 1)\nrepeat:\n\trepeat m-1 times: head move to right\n\trepeat 2 times: head move down\n\trepeat 2 times: head move down\n\trepeat m-1 times: head move to left\n\trepeat 2 times: head move down\n\trepeat 2 times: head move down\nuntil head is out of the board",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16173",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #290 Editorial - Codeforces - Code 3",
          "code": "(4k+1) / (4k+3) line: \"#######\"\n(4k+2) line: \".......#\"\n(4k+0) line: \"#.......\"",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16173",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #290 Editorial - Codeforces - Code 4",
          "code": "(4k+1) / (4k+3) line: \"#######\"\n(4k+2) line: \".......#\"\n(4k+0) line: \"#.......\"",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16173",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #290 Editorial - Codeforces - Code 5",
          "code": "for (i64 i = 0; i < n; i++) {\n    hepsi[ l[i] ] = c[i];\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16173",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #290 Editorial - Codeforces - Code 6",
          "code": "for (i64 i = 0; i < n; i++) {\n    hepsi[ l[i] ] = c[i];\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16173",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #290 Editorial - Codeforces - Code 7",
          "code": "hepsi[ 0 ] = 0;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16173",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #290 Editorial - Codeforces - Code 8",
          "code": "hepsi[ 0 ] = 0;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16173",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #290 Editorial - Codeforces - Code 9",
          "code": "s = primes.size();\n\nfor(int mask = 0; mask < (1<<s); mask++){\n\tdp[mask] = INF;\n}\n\t\t\ndp[m[i]] = c[i];\n\t\t\nfor(int mask = 0; mask < (1<<s); mask++){\n\tfor(int j = 0; j < n; j++){\n\t\tif(dp[mask] != INF)\n\t\t\tdp[mask | m[j]] = min(dp[mask | m[j]], dp[mask] + c[j]);\n\t}\n}\n\nans = min(ans, dp[(1<<s) - 1]);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16173",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #290 Editorial - Codeforces - Code 10",
          "code": "s = primes.size();\n\nfor(int mask = 0; mask < (1<<s); mask++){\n\tdp[mask] = INF;\n}\n\t\t\ndp[m[i]] = c[i];\n\t\t\nfor(int mask = 0; mask < (1<<s); mask++){\n\tfor(int j = 0; j < n; j++){\n\t\tif(dp[mask] != INF)\n\t\t\tdp[mask | m[j]] = min(dp[mask | m[j]], dp[mask] + c[j]);\n\t}\n}\n\nans = min(ans, dp[(1<<s) - 1]);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16173",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #290 Editorial - Codeforces - Code 11",
          "code": "3 3\nBAB\nAAA\nBAB",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16173",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #290 Editorial - Codeforces - Code 12",
          "code": "3 3\nBAB\nAAA\nBAB",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16173",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #290 Editorial - Codeforces - Code 13",
          "code": "#include<Stdio.h>",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/16173",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #290 Editorial - Codeforces - Code 14",
          "code": "dp[i][sz[i]] = dp[i][sz[i] - 1]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16173",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #290 Editorial - Codeforces - Code 15",
          "code": "dpValue dfs(int cur, int from)\n{\n\tdpValue ret;\n\tret.x[0] = 1;\n\tfor(int i = 0; i < e[cur].size(); i++)\n\t{\n\t\tint t = e[cur][i];\n\t\tif(t == from) continue;\n\t\tret = combine(ret, dfs(t, cur));\n\t}\n\tfor(int i = 0; i < MAXN; i++)\n\t\tif(ret.x[i] == 0)\n\t\t{\n\t\t\tret.x[i] = ret.x[i-1];\n\t\t\tbreak;\n\t\t}\n\treturn ret;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16173",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #290 Editorial - Codeforces - Code 16",
          "code": "dpValue dfs(int cur, int from)\n{\n\tdpValue ret;\n\tret.x[0] = 1;\n\tfor(int i = 0; i < e[cur].size(); i++)\n\t{\n\t\tint t = e[cur][i];\n\t\tif(t == from) continue;\n\t\tret = combine(ret, dfs(t, cur));\n\t}\n\tfor(int i = 0; i < MAXN; i++)\n\t\tif(ret.x[i] == 0)\n\t\t{\n\t\t\tret.x[i] = ret.x[i-1];\n\t\t\tbreak;\n\t\t}\n\treturn ret;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16173",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #290 Editorial - Codeforces - Code 17",
          "code": "dpValue combine(dpValue A, dpValue B)\n{\n\tdpValue ret;\n\tfor(int i = 0; i < MAXN; i++)\n\t\tfor(int j = 0; i+j < MAXN; j++)\n\t\t{\n\t\t\tret.x[i+j] += ((A.x[i] * B.x[j]) % mod) * C(i+j, i);\n\t\t\tret.x[i+j] %= mod;\n\t\t}\n\treturn ret;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16173",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #290 Editorial - Codeforces - Code 18",
          "code": "dpValue combine(dpValue A, dpValue B)\n{\n\tdpValue ret;\n\tfor(int i = 0; i < MAXN; i++)\n\t\tfor(int j = 0; i+j < MAXN; j++)\n\t\t{\n\t\t\tret.x[i+j] += ((A.x[i] * B.x[j]) % mod) * C(i+j, i);\n\t\t\tret.x[i+j] %= mod;\n\t\t}\n\treturn ret;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16173",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #290 Editorial - Codeforces - Code 19",
          "code": "4\n2 4 5 7\n1 1 1 1000000000",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16173",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #290 Editorial - Codeforces - Code 20",
          "code": "4\n2 4 5 7\n1 1 1 1000000000",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16173",
          "author": "Qingyu"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 300, \"n\");\n    inf.readEoln();\n    vector<int> l = inf.readInts(n, 1, 1000000000, \"li\");\n    inf.readEoln();\n    vector<int> c = inf.readInts(n, 1, 100000, \"ci\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 300, \"n\");\n    inf.readEoln();\n    vector<int> l = inf.readInts(n, 1, 1000000000, \"li\");\n    inf.readEoln();\n    vector<int> c = inf.readInts(n, 1, 100000, \"ci\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 300, \"n\");\n    inf.readEoln();\n    vector<int> l = inf.readInts(n, 1, 1000000000, \"li\");\n    inf.readEoln();\n    vector<int> c = inf.readInts(n, 1, 100000, \"ci\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\");\n\n    vector<int> li;\n    vector<int> ci;\n\n    if (type == \"gcd1_all\") {\n        // Generate lengths with GCD 1\n        li.resize(n);\n        ci.resize(n);\n        if (n >= 2) {\n            // Set li[0] and li[1] such that GCD(li[0], li[1]) = 1\n            int x = rnd.next(2, 1000000000 - 1);\n            li[0] = x;\n            li[1] = x + 1;\n            for (int i = 2; i < n; ++i) {\n                li[i] = rnd.next(2, 1000000000);\n            }\n        } else if (n == 1) {\n            li[0] = 1;\n        }\n        for (int i = 0; i < n; ++i) {\n            ci[i] = rnd.next(1, 100000);\n        }\n\n    } else if (type == \"gcd1_subset\") {\n        // Generate lengths where overall GCD is not 1, but a subset has GCD 1\n        li.resize(n);\n        ci.resize(n);\n        li[0] = 2;\n        li[1] = 3;\n        int lcm_val = 6;\n        for (int i = 2; i < n; ++i) {\n            int max_mult = 1000000000 / lcm_val;\n            int mult = rnd.next(1, max_mult);\n            li[i] = lcm_val * mult;\n        }\n        ci[0] = rnd.next(1, 100);\n        ci[1] = rnd.next(1, 100);\n        for (int i = 2; i < n; ++i) {\n            ci[i] = rnd.next(1000, 100000);\n        }\n\n    } else if (type == \"no_gcd1\") {\n        // Generate lengths where no subset has GCD 1\n        li.resize(n);\n        ci.resize(n);\n        int g = rnd.next(2, 1000000000);\n        for (int i = 0; i < n; ++i) {\n            int max_mult = 1000000000 / g;\n            int mult = rnd.next(1, max_mult);\n            li[i] = g * mult;\n        }\n        for (int i = 0; i < n; ++i) {\n            ci[i] = rnd.next(1, 100000);\n        }\n\n    } else if (type == \"same_lengths\") {\n        // All lengths are the same\n        li.resize(n);\n        ci.resize(n);\n        int l = rnd.next(2, 1000000000);\n        for (int i = 0; i < n; ++i) {\n            li[i] = l;\n            ci[i] = rnd.next(1, 100000);\n        }\n\n    } else if (type == \"random\") {\n        // Random lengths and costs\n        li.resize(n);\n        ci.resize(n);\n        for (int i = 0; i < n; ++i) {\n            li[i] = rnd.next(1, 1000000000);\n            ci[i] = rnd.next(1, 100000);\n        }\n\n    } else if (type == \"max_numbers\") {\n        // Maximal lengths and costs\n        li.resize(n);\n        ci.resize(n);\n        for (int i = 0; i < n; ++i) {\n            li[i] = 1000000000;\n            ci[i] = 100000;\n        }\n\n    } else if (type == \"min_numbers\") {\n        // Minimal lengths and costs\n        li.resize(n);\n        ci.resize(n);\n        for (int i = 0; i < n; ++i) {\n            li[i] = 1;\n            ci[i] = 1;\n        }\n\n    } else if (type == \"special_case_1\") {\n        // Single card with length 1\n        n = 1;\n        li.resize(1);\n        ci.resize(1);\n        li[0] = 1;\n        ci[0] = rnd.next(1, 100000);\n\n    } else if (type == \"large_gcd\") {\n        // Generate lengths with a large GCD\n        li.resize(n);\n        ci.resize(n);\n        int g = rnd.next(100000000, 1000000000);\n        for (int i = 0; i < n; ++i) {\n            int max_mult = 1000000000 / g;\n            int mult = rnd.next(1, max_mult);\n            li[i] = g * mult;\n            ci[i] = rnd.next(1, 100000);\n        }\n\n    } else if (type == \"small_gcd\") {\n        // Generate lengths with a small GCD greater than 1\n        li.resize(n);\n        ci.resize(n);\n        int g = rnd.next(2, 1000);\n        for (int i = 0; i < n; ++i) {\n            int max_mult = 1000000000 / g;\n            int mult = rnd.next(1, max_mult);\n            li[i] = g * mult;\n            ci[i] = rnd.next(1, 100000);\n        }\n\n    } else {\n        // Default to random\n        li.resize(n);\n        ci.resize(n);\n        for (int i = 0; i < n; ++i) {\n            li[i] = rnd.next(1, 1000000000);\n            ci[i] = rnd.next(1, 100000);\n        }\n    }\n\n    // Output n\n    printf(\"%d\\n\", n);\n    // Output li's\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d\", li[i]);\n        if (i < n - 1) printf(\" \");\n    }\n    printf(\"\\n\");\n    // Output ci's\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d\", ci[i]);\n        if (i < n - 1) printf(\" \");\n    }\n    printf(\"\\n\");\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\");\n\n    vector<int> li;\n    vector<int> ci;\n\n    if (type == \"gcd1_all\") {\n        // Generate lengths with GCD 1\n        li.resize(n);\n        ci.resize(n);\n        if (n >= 2) {\n            // Set li[0] and li[1] such that GCD(li[0], li[1]) = 1\n            int x = rnd.next(2, 1000000000 - 1);\n            li[0] = x;\n            li[1] = x + 1;\n            for (int i = 2; i < n; ++i) {\n                li[i] = rnd.next(2, 1000000000);\n            }\n        } else if (n == 1) {\n            li[0] = 1;\n        }\n        for (int i = 0; i < n; ++i) {\n            ci[i] = rnd.next(1, 100000);\n        }\n\n    } else if (type == \"gcd1_subset\") {\n        // Generate lengths where overall GCD is not 1, but a subset has GCD 1\n        li.resize(n);\n        ci.resize(n);\n        li[0] = 2;\n        li[1] = 3;\n        int lcm_val = 6;\n        for (int i = 2; i < n; ++i) {\n            int max_mult = 1000000000 / lcm_val;\n            int mult = rnd.next(1, max_mult);\n            li[i] = lcm_val * mult;\n        }\n        ci[0] = rnd.next(1, 100);\n        ci[1] = rnd.next(1, 100);\n        for (int i = 2; i < n; ++i) {\n            ci[i] = rnd.next(1000, 100000);\n        }\n\n    } else if (type == \"no_gcd1\") {\n        // Generate lengths where no subset has GCD 1\n        li.resize(n);\n        ci.resize(n);\n        int g = rnd.next(2, 1000000000);\n        for (int i = 0; i < n; ++i) {\n            int max_mult = 1000000000 / g;\n            int mult = rnd.next(1, max_mult);\n            li[i] = g * mult;\n        }\n        for (int i = 0; i < n; ++i) {\n            ci[i] = rnd.next(1, 100000);\n        }\n\n    } else if (type == \"same_lengths\") {\n        // All lengths are the same\n        li.resize(n);\n        ci.resize(n);\n        int l = rnd.next(2, 1000000000);\n        for (int i = 0; i < n; ++i) {\n            li[i] = l;\n            ci[i] = rnd.next(1, 100000);\n        }\n\n    } else if (type == \"random\") {\n        // Random lengths and costs\n        li.resize(n);\n        ci.resize(n);\n        for (int i = 0; i < n; ++i) {\n            li[i] = rnd.next(1, 1000000000);\n            ci[i] = rnd.next(1, 100000);\n        }\n\n    } else if (type == \"max_numbers\") {\n        // Maximal lengths and costs\n        li.resize(n);\n        ci.resize(n);\n        for (int i = 0; i < n; ++i) {\n            li[i] = 1000000000;\n            ci[i] = 100000;\n        }\n\n    } else if (type == \"min_numbers\") {\n        // Minimal lengths and costs\n        li.resize(n);\n        ci.resize(n);\n        for (int i = 0; i < n; ++i) {\n            li[i] = 1;\n            ci[i] = 1;\n        }\n\n    } else if (type == \"special_case_1\") {\n        // Single card with length 1\n        n = 1;\n        li.resize(1);\n        ci.resize(1);\n        li[0] = 1;\n        ci[0] = rnd.next(1, 100000);\n\n    } else if (type == \"large_gcd\") {\n        // Generate lengths with a large GCD\n        li.resize(n);\n        ci.resize(n);\n        int g = rnd.next(100000000, 1000000000);\n        for (int i = 0; i < n; ++i) {\n            int max_mult = 1000000000 / g;\n            int mult = rnd.next(1, max_mult);\n            li[i] = g * mult;\n            ci[i] = rnd.next(1, 100000);\n        }\n\n    } else if (type == \"small_gcd\") {\n        // Generate lengths with a small GCD greater than 1\n        li.resize(n);\n        ci.resize(n);\n        int g = rnd.next(2, 1000);\n        for (int i = 0; i < n; ++i) {\n            int max_mult = 1000000000 / g;\n            int mult = rnd.next(1, max_mult);\n            li[i] = g * mult;\n            ci[i] = rnd.next(1, 100000);\n        }\n\n    } else {\n        // Default to random\n        li.resize(n);\n        ci.resize(n);\n        for (int i = 0; i < n; ++i) {\n            li[i] = rnd.next(1, 1000000000);\n            ci[i] = rnd.next(1, 100000);\n        }\n    }\n\n    // Output n\n    printf(\"%d\\n\", n);\n    // Output li's\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d\", li[i]);\n        if (i < n - 1) printf(\" \");\n    }\n    printf(\"\\n\");\n    // Output ci's\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d\", ci[i]);\n        if (i < n - 1) printf(\" \");\n    }\n    printf(\"\\n\");\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Special case: single card with length 1\n./gen -n 1 -type special_case_1\n\n# gcd1_all: All lengths have GCD 1\n./gen -n 2 -type gcd1_all\n./gen -n 3 -type gcd1_all\n./gen -n 10 -type gcd1_all\n./gen -n 50 -type gcd1_all\n./gen -n 100 -type gcd1_all\n./gen -n 300 -type gcd1_all\n\n# gcd1_subset: Subset of lengths has GCD 1\n./gen -n 2 -type gcd1_subset\n./gen -n 5 -type gcd1_subset\n./gen -n 50 -type gcd1_subset\n./gen -n 100 -type gcd1_subset\n./gen -n 300 -type gcd1_subset\n\n# no_gcd1: No subset has GCD 1\n./gen -n 2 -type no_gcd1\n./gen -n 5 -type no_gcd1\n./gen -n 50 -type no_gcd1\n./gen -n 100 -type no_gcd1\n./gen -n 300 -type no_gcd1\n\n# same_lengths: All lengths are the same\n./gen -n 2 -type same_lengths\n./gen -n 5 -type same_lengths\n./gen -n 50 -type same_lengths\n./gen -n 100 -type same_lengths\n./gen -n 300 -type same_lengths\n\n# random: Random lengths and costs\n./gen -n 2 -type random\n./gen -n 5 -type random\n./gen -n 50 -type random\n./gen -n 100 -type random\n./gen -n 300 -type random\n\n# max_numbers: Maximal lengths and costs\n./gen -n 2 -type max_numbers\n./gen -n 5 -type max_numbers\n./gen -n 50 -type max_numbers\n./gen -n 100 -type max_numbers\n./gen -n 300 -type max_numbers\n\n# min_numbers: Minimal lengths and costs\n./gen -n 2 -type min_numbers\n./gen -n 5 -type min_numbers\n./gen -n 50 -type min_numbers\n./gen -n 100 -type min_numbers\n./gen -n 300 -type min_numbers\n\n# large_gcd: Lengths with large GCD\n./gen -n 2 -type large_gcd\n./gen -n 5 -type large_gcd\n./gen -n 50 -type large_gcd\n./gen -n 100 -type large_gcd\n./gen -n 300 -type large_gcd\n\n# small_gcd: Lengths with small GCD greater than 1\n./gen -n 2 -type small_gcd\n./gen -n 5 -type small_gcd\n./gen -n 50 -type small_gcd\n./gen -n 100 -type small_gcd\n./gen -n 300 -type small_gcd\n\n# Additional random cases for robustness\n./gen -n 300 -type random\n./gen -n 300 -type random\n./gen -n 300 -type random\n./gen -n 300 -type random\n./gen -n 300 -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:41:40.634558",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "510/E",
      "title": "E. Fox And Dinner",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains single integer n (3 ≤ n ≤ 200): the number of foxes in this party. The second line contains n integers ai (2 ≤ ai ≤ 104).",
      "output_spec": "OutputIf it is impossible to do this, output \"Impossible\".Otherwise, in the first line output an integer m (): the number of tables.Then output m lines, each line should start with an integer k -=– the number of foxes around that table, and then k numbers — indices of fox sitting around that table in clockwise order.If there are several possible arrangements, output any of them.",
      "sample_tests": "ExamplesInputCopy43 4 8 9OutputCopy14 1 2 4 3InputCopy52 2 2 2 2OutputCopyImpossibleInputCopy122 3 4 5 6 7 8 9 10 11 12 13OutputCopy112 1 2 3 6 5 12 9 8 7 10 11 4InputCopy242 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25OutputCopy36 1 2 3 6 5 410 7 8 9 12 15 14 13 16 11 108 17 18 23 22 19 20 21 24",
      "description": "E. Fox And Dinner\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains single integer n (3 ≤ n ≤ 200): the number of foxes in this party. The second line contains n integers ai (2 ≤ ai ≤ 104).\n\nOutputIf it is impossible to do this, output \"Impossible\".Otherwise, in the first line output an integer m (): the number of tables.Then output m lines, each line should start with an integer k -=– the number of foxes around that table, and then k numbers — indices of fox sitting around that table in clockwise order.If there are several possible arrangements, output any of them.\n\nInputCopy43 4 8 9OutputCopy14 1 2 4 3InputCopy52 2 2 2 2OutputCopyImpossibleInputCopy122 3 4 5 6 7 8 9 10 11 12 13OutputCopy112 1 2 3 6 5 12 9 8 7 10 11 4InputCopy242 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25OutputCopy36 1 2 3 6 5 410 7 8 9 12 15 14 13 16 11 108 17 18 23 22 19 20 21 24\n\nInputCopy43 4 8 9\n\nOutputCopy14 1 2 4 3\n\nInputCopy52 2 2 2 2\n\nOutputCopyImpossible\n\nInputCopy122 3 4 5 6 7 8 9 10 11 12 13\n\nOutputCopy112 1 2 3 6 5 12 9 8 7 10 11 4\n\nInputCopy242 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25\n\nOutputCopy36 1 2 3 6 5 410 7 8 9 12 15 14 13 16 11 108 17 18 23 22 19 20 21 24\n\nNoteIn example 1, they can sit around one table, their ages are: 3-8-9-4, adjacent sums are: 11, 17, 13 and 7, all those integers are primes.In example 2, it is not possible: the sum of 2+2 = 4 is not a prime number.",
      "solutions": [
        {
          "title": "Codeforces Round #290 - Codeforces",
          "content": "Fox Ciel is back!I invite you to participate in Codeforces Round #290, which will start at the standard time on next Monday: This is my 4th round on Codeforces, my previous rounds: #190, #228, #270.Last Div1 Round (#286) is so hard, so after notice that, we decide to reduce the difficulty of this round. (For example, current Div1-E was used as Div1-D) I hope more people can enjoy all tasks in this round: this time no task requires advanced knowledge like linear space or Fourier Transform.The background story will be Fox Ciel's life: learning programming, play games, traveling, have dinner and so on.Like Round #228, top-20 contestants that are currently at Petrozavodsk training camp will be rewarded with nice Codefores T-Shirts. Contestant may be a team member, jury, coach, organizer, or whoever else involved in camp, no matter of status.As usual, thanks to Zlobober for giving great suggestions and test my round, and MikeMirzayanov for the platform (Codeforces and Polygon). Good luck and have fun!Update1: Score Distribution is ... Div2: Standard (500 — 1000 — 1500 — 2000 — 2500), Div1: a bit unusual ... (500 — 1000 — 1500 — 2250 — 2250)Update2: Editorial: http://codeforces.com/blog/entry/16173Update3: Congratulation to our winners:Div1: Petr Endagorion mmaxio jqdai0815 tourist They are all people who solved 5 tasks!Div2: SkullSkin joshkirstein gabrielinelus UnknownNooby Andrey_WK",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/16147",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1401
        },
        {
          "title": "Codeforces Round #290 Editorial - Codeforces",
          "content": "Update 1 : here are the reference solutions for this contest: Div2-A: http://ideone.com/JP1Ksj DIv2-B: http://ideone.com/udz3bN Div2-C / Div1-A: http://ideone.com/KVobNb Div2-D / Div1-B: http://ideone.com/7MQqOm Div2-E / Div1-C: http://ideone.com/z3FsU2 Div1-D: http://ideone.com/Y7j21a Div1-E: http://ideone.com/Orbacp Note that for Div2-E / Div1-C, it is for the harder version: we need to handle '1' in the cycle.510A - Fox And SnakeThere are 2 different ways to solve this kind of task:First one is to simulate the movement of the snake head, and you draw '#'s on the board. The code will look like: head = (1, 1)\nrepeat:\n\trepeat m-1 times: head move to right\n\trepeat 2 times: head move down\n\trepeat 2 times: head move down\n\trepeat m-1 times: head move to left\n\trepeat 2 times: head move down\n\trepeat 2 times: head move down\nuntil head is out of the boardAnother way is to do some observation about the result, you can find this pattern: (4k+1) / (4k+3) line: \"#######\"\n(4k+2) line: \".......#\"\n(4k+0) line: \"#.......\"510B - Fox And Two DotsThis task is essentially ask if there is a cycle in an undirected graph: treat each cell as a node, and add an edge if two cells are neighborhood and have some color.There are lots of ways to do this, for example: Run dfs / bfs, if an edge lead you to a visited node, then there must be a cycle. For each connected component, test if |#edges| = |#nodes| - 1, if not then there must be a cycle. 510C - Fox And Names / 512A - Fox And NamesLet's first think about what S < T can tell us: suppose S = abcxyz and T = abcuv. Then we know that S < T if and only if x < u by the definition.So we can transform the conditions name1 < name2, name2 < name3 ... into the order of letters.Then the question become: do we have a permutation that satisfy those conditions. It is actually the classic topological order question.One trick in this task is that, if we have something like xy < x then there is no solution. This is not covered in pretests. :)510D - Fox And Jumping / 512B - Fox And JumpingThis task equals to: what is the minimal sum of costs that we can select k cards, so their GCD is 1.First observation is that: GCD(x1, x2, ..., xk) = 1 means that for any prime p, there exist i such that xi is not dividable by p. So we only care about what prime factors a number contain. (So for example, 12 -> {2, 3}, 6 -> {2, 3}, 9 -> {3]})The second observation is: If x ≤ 109 then it has at most 9 prime factors.So after we select one number, we only care about these 9 or less primes. Then this problem equals to set covering problem (SCP), it can be done by mask DP. It can run in about O(2^9 * n^2).510E - Fox And Dinner / 512C - Fox And DinnerFirst finding is: if a + b is a prime, then one of them is an odd number, another is an even number. (that's why we set 2 ≤ xi)Then we could find: every odd number have exactly 2 even number as neighborhood, and every even number have exactly 2 odd number as neighborhood. And that means we need |#even| = |#odd| to have a solution.So it looks like bipartite graph matching, but every element matched 2 elements. And in fact it can be handled by maxflow: For each odd number, we add a node on the left side and link it from source with capacity equals to 2, and for each even number, we add a node on the right side and link it to sink with capacity equals to 2. And if sum of two numbers is a prime number, we link them with capacity equals to 1.Then we solve the max flow, it have solution if and only if maxflow = 2 * |#even|.We can construct the answer(cycles) from the matches.Note: Actually this task is still solvable if we allow ai = 1. But you need some clever way to deal with it. We think it is too hard so we removed this case. What do you think about this decision?512D - Fox And TravellingWe could find that some nodes cannot be visited. And more specific, if one node is in a cycle then it cannot be visited. So what about the structure of nodes that we can visit?Let's first find a way to get all nodes that could be visited. We can deal with this by something like biconnected decomposition, but that is not easy to implement. In fact we can use this simple method: each time we pick one node that have at most 1 neighborhood and delete it. Repeat this process until we can't do it anymore.We could find these nodes are actually belonging to these 2 kinds: 1. A tree. 2. Rooted tree. (that means, the root is attached to a cycle)The rooted tree case is simple: we can solve it by tree DP. The state will be dp[i][j] = the way to remove j nodes in the subtree rooted at i.Then how to solve the unrooted tree case? The way to deal with that is to transform it into rooted case. We have 2 solution: We select one unvisited node as the root by some rules: for example, we select one with minimal index. Then we just need to modify the DP a bit to adjust this additional condition. We could find if the tree has n nodes and we visit k nodes in the end, then there will be max(1, n-k) ways to choose the root. That means if we choose every node as the root and sum up them, we will count this case exactly max(1, n-k) times. So we just do the rooted DP for from node n times, and divide max(1, n-k) for ans[k]. The overall complicity is O(n4), and it can be optimize into O(n3) if you like.512E - Fox And PolygonTriangulation of polygon is something hard to think about. So the first key observation is that, we can transform this task into operations on rooted trees!One Triangulation of polygon can be mapping to one rooted tree. And the flip operation can be mapping to the rotation of trees. (It is the operation we used to balance our BST) You can find the mapping from above picture. The red lines indicate the edge that will be flipped and the nodes we rotated.Then we should find a standard shape of the tree, and solve this task: how to rotate any tree into this standard shape?My solution is to choose the balanced tree as standard shape. The way to do that is this: find the node that the index is the middle number, rotate it to the top(that what we did for splay tree), and do the same thing for each subtree.It is easy to see it could work in O(nlogn) steps.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/16173",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 510\\s*E"
          },
          "content_length": 6165
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #290 - Codeforces - Code 1",
          "code": "26\na\nb\nc\n...\nz",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16147",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #290 - Codeforces - Code 2",
          "code": "26\na\nb\nc\n...\nz",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16147",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #290 Editorial - Codeforces - Code 1",
          "code": "head = (1, 1)\nrepeat:\n\trepeat m-1 times: head move to right\n\trepeat 2 times: head move down\n\trepeat 2 times: head move down\n\trepeat m-1 times: head move to left\n\trepeat 2 times: head move down\n\trepeat 2 times: head move down\nuntil head is out of the board",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16173",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #290 Editorial - Codeforces - Code 2",
          "code": "head = (1, 1)\nrepeat:\n\trepeat m-1 times: head move to right\n\trepeat 2 times: head move down\n\trepeat 2 times: head move down\n\trepeat m-1 times: head move to left\n\trepeat 2 times: head move down\n\trepeat 2 times: head move down\nuntil head is out of the board",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16173",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #290 Editorial - Codeforces - Code 3",
          "code": "(4k+1) / (4k+3) line: \"#######\"\n(4k+2) line: \".......#\"\n(4k+0) line: \"#.......\"",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16173",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #290 Editorial - Codeforces - Code 4",
          "code": "(4k+1) / (4k+3) line: \"#######\"\n(4k+2) line: \".......#\"\n(4k+0) line: \"#.......\"",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16173",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #290 Editorial - Codeforces - Code 5",
          "code": "for (i64 i = 0; i < n; i++) {\n    hepsi[ l[i] ] = c[i];\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16173",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #290 Editorial - Codeforces - Code 6",
          "code": "for (i64 i = 0; i < n; i++) {\n    hepsi[ l[i] ] = c[i];\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16173",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #290 Editorial - Codeforces - Code 7",
          "code": "hepsi[ 0 ] = 0;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16173",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #290 Editorial - Codeforces - Code 8",
          "code": "hepsi[ 0 ] = 0;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16173",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #290 Editorial - Codeforces - Code 9",
          "code": "s = primes.size();\n\nfor(int mask = 0; mask < (1<<s); mask++){\n\tdp[mask] = INF;\n}\n\t\t\ndp[m[i]] = c[i];\n\t\t\nfor(int mask = 0; mask < (1<<s); mask++){\n\tfor(int j = 0; j < n; j++){\n\t\tif(dp[mask] != INF)\n\t\t\tdp[mask | m[j]] = min(dp[mask | m[j]], dp[mask] + c[j]);\n\t}\n}\n\nans = min(ans, dp[(1<<s) - 1]);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16173",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #290 Editorial - Codeforces - Code 10",
          "code": "s = primes.size();\n\nfor(int mask = 0; mask < (1<<s); mask++){\n\tdp[mask] = INF;\n}\n\t\t\ndp[m[i]] = c[i];\n\t\t\nfor(int mask = 0; mask < (1<<s); mask++){\n\tfor(int j = 0; j < n; j++){\n\t\tif(dp[mask] != INF)\n\t\t\tdp[mask | m[j]] = min(dp[mask | m[j]], dp[mask] + c[j]);\n\t}\n}\n\nans = min(ans, dp[(1<<s) - 1]);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16173",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #290 Editorial - Codeforces - Code 11",
          "code": "3 3\nBAB\nAAA\nBAB",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16173",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #290 Editorial - Codeforces - Code 12",
          "code": "3 3\nBAB\nAAA\nBAB",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16173",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #290 Editorial - Codeforces - Code 13",
          "code": "#include<Stdio.h>",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/16173",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #290 Editorial - Codeforces - Code 14",
          "code": "dp[i][sz[i]] = dp[i][sz[i] - 1]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16173",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #290 Editorial - Codeforces - Code 15",
          "code": "dpValue dfs(int cur, int from)\n{\n\tdpValue ret;\n\tret.x[0] = 1;\n\tfor(int i = 0; i < e[cur].size(); i++)\n\t{\n\t\tint t = e[cur][i];\n\t\tif(t == from) continue;\n\t\tret = combine(ret, dfs(t, cur));\n\t}\n\tfor(int i = 0; i < MAXN; i++)\n\t\tif(ret.x[i] == 0)\n\t\t{\n\t\t\tret.x[i] = ret.x[i-1];\n\t\t\tbreak;\n\t\t}\n\treturn ret;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16173",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #290 Editorial - Codeforces - Code 16",
          "code": "dpValue dfs(int cur, int from)\n{\n\tdpValue ret;\n\tret.x[0] = 1;\n\tfor(int i = 0; i < e[cur].size(); i++)\n\t{\n\t\tint t = e[cur][i];\n\t\tif(t == from) continue;\n\t\tret = combine(ret, dfs(t, cur));\n\t}\n\tfor(int i = 0; i < MAXN; i++)\n\t\tif(ret.x[i] == 0)\n\t\t{\n\t\t\tret.x[i] = ret.x[i-1];\n\t\t\tbreak;\n\t\t}\n\treturn ret;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16173",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #290 Editorial - Codeforces - Code 17",
          "code": "dpValue combine(dpValue A, dpValue B)\n{\n\tdpValue ret;\n\tfor(int i = 0; i < MAXN; i++)\n\t\tfor(int j = 0; i+j < MAXN; j++)\n\t\t{\n\t\t\tret.x[i+j] += ((A.x[i] * B.x[j]) % mod) * C(i+j, i);\n\t\t\tret.x[i+j] %= mod;\n\t\t}\n\treturn ret;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16173",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #290 Editorial - Codeforces - Code 18",
          "code": "dpValue combine(dpValue A, dpValue B)\n{\n\tdpValue ret;\n\tfor(int i = 0; i < MAXN; i++)\n\t\tfor(int j = 0; i+j < MAXN; j++)\n\t\t{\n\t\t\tret.x[i+j] += ((A.x[i] * B.x[j]) % mod) * C(i+j, i);\n\t\t\tret.x[i+j] %= mod;\n\t\t}\n\treturn ret;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16173",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #290 Editorial - Codeforces - Code 19",
          "code": "4\n2 4 5 7\n1 1 1 1000000000",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16173",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #290 Editorial - Codeforces - Code 20",
          "code": "4\n2 4 5 7\n1 1 1 1000000000",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16173",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(3, 200, \"n\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, 2, 10000, \"a\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(3, 200, \"n\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, 2, 10000, \"a\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(3, 200, \"n\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, 2, 10000, \"a\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nstatic const int MAX_AGE = 10000;\nstatic const int MAX_SUM = 2 * MAX_AGE; // up to 20000 for prime checks\n\n// We'll hold a sieve for primes up to MAX_SUM.\nstatic vector<bool> primeSieve;\n\nbool isPrime(int x) {\n    if (x <= 1 || x > MAX_SUM) return false;\n    return primeSieve[x];\n}\n\nstruct Distribution {\n    bool impossible;          // true if \"Impossible\"\n    vector<vector<int>> tables; // seating arrangement if not impossible\n};\n\n/*\n  After we finish reading an answer (be it \"Impossible\" or a distribution),\n  we want to allow only whitespace (spaces/newlines) before the end of file.\n  If there's another actual token, that means extra data -> WA.\n  \n  For older versions of testlib, calling readToken() in a loop can lead to \n  \"Unexpected end of file - token expected\" if nothing is left. Instead, we do:\n    - skipBlanks() to consume remaining whitespaces/newlines\n    - check if we reached EOF\n    - if not EOF, read one string token => WA\n    - if EOF, we're good\n*/\nstatic void ensureNoExtraTokens(InStream &stream, const string &label) {\n    // Skip any trailing spaces/newlines\n    stream.skipBlanks();\n    // If not EOF, there's still data -> WA\n    if (!stream.eof()) {\n        // read whatever token remains\n        string leftover = stream.readString();\n        stream.quitf(_wa, \"[%s] Extra data after finishing output: '%s'.\",\n                     label.c_str(), leftover.c_str());\n    }\n}\n\n/*\n  Reads either:\n    1) \"Impossible\" \n       => sets dist.impossible = true,\n          calls ensureNoExtraTokens() to allow only trailing whitespace, then returns.\n    2) an integer m (1 <= m <= n), \n       => reads the distribution for m tables, \n          checks adjacency prime sums, ensures each fox used exactly once, total n used,\n          then calls ensureNoExtraTokens().\n\n  If anything is invalid (format, adjacency sums, repeated indices, etc.), \n  calls stream.quitf(_wa).\n\n  On older testlib versions, this approach avoids \"Unexpected end of file - token expected\" \n  by replacing repeated readToken() loops with skipBlanks() + readString() approach.\n*/\nDistribution readDistribution(InStream &stream, int n, const vector<int> &ages, const string &label) {\n    Distribution dist;\n    dist.impossible = false;\n\n    // If there's no output at all, that's a problem\n    if (stream.eof()) {\n        stream.quitf(_wa, \"[%s] No output (empty file).\", label.c_str());\n    }\n\n    // Read the first token\n    string firstToken = stream.readToken();\n    if (firstToken == \"Impossible\") {\n        dist.impossible = true;\n        ensureNoExtraTokens(stream, label);\n        return dist;\n    }\n\n    // Otherwise, parse it as integer m\n    long long mVal;\n    {\n        istringstream iss(firstToken);\n        if (!(iss >> mVal) || !iss.eof()) {\n            stream.quitf(_wa,\n                         \"[%s] Expected 'Impossible' or an integer m, got '%s'.\",\n                         label.c_str(), firstToken.c_str());\n        }\n    }\n    if (mVal < 1 || mVal > n) {\n        stream.quitf(_wa,\n                     \"[%s] Invalid number of tables m=%lld (must be within 1..%d).\",\n                     label.c_str(), mVal, n);\n    }\n    int m = (int)mVal;\n    dist.tables.resize(m);\n\n    vector<bool> used(n, false);\n    int totalFoxCount = 0;\n\n    // Read info for m tables\n    for (int i = 0; i < m; i++) {\n        // Number of foxes at this table\n        int k = stream.readInt(3, n,\n            format(\"[%s] number of foxes at table %d\", label.c_str(), i + 1).c_str());\n        \n        dist.tables[i].resize(k);\n        for (int j = 0; j < k; j++) {\n            int idx = stream.readInt(1, n,\n                format(\"[%s] table %d, fox index %d\", label.c_str(), i+1, j+1).c_str());\n            // Each fox must appear exactly once overall\n            if (used[idx - 1]) {\n                stream.quitf(_wa,\n                    \"[%s] Fox %d is used more than once.\", label.c_str(), idx);\n            }\n            used[idx - 1] = true;\n            dist.tables[i][j] = idx;\n        }\n\n        totalFoxCount += k;\n\n        // Check adjacency sums for primality in circular arrangement\n        for (int j = 0; j < k; j++) {\n            int a = dist.tables[i][j];\n            int b = dist.tables[i][(j + 1) % k];\n            int sumAges = ages[a - 1] + ages[b - 1];\n            if (!isPrime(sumAges)) {\n                stream.quitf(_wa,\n                    \"[%s] Adjacent foxes %d(age=%d) and %d(age=%d) => sum=%d, not prime.\",\n                    label.c_str(), a, ages[a - 1], b, ages[b - 1], sumAges);\n            }\n        }\n    }\n\n    if (totalFoxCount != n) {\n        stream.quitf(_wa,\n            \"[%s] Used %d foxes total, but n=%d. (Some foxes missing or repeated)\",\n            label.c_str(), totalFoxCount, n);\n    }\n\n    // No extra tokens (besides trailing whitespace)\n    ensureNoExtraTokens(stream, label);\n\n    return dist;\n}\n\nint main(int argc, char* argv[]){\n    registerTestlibCmd(argc, argv);\n\n    // Precompute primes up to MAX_SUM (20000)\n    primeSieve.assign(MAX_SUM + 1, true);\n    primeSieve[0] = false;\n    primeSieve[1] = false;\n    for (int i = 2; i * i <= MAX_SUM; i++) {\n        if (primeSieve[i]) {\n            for (int j = i * i; j <= MAX_SUM; j += i) {\n                primeSieve[j] = false;\n            }\n        }\n    }\n\n    // Read the original problem input\n    int n = inf.readInt(3, 200, \"n\");\n    vector<int> ages(n);\n    for (int i = 0; i < n; i++) {\n        ages[i] = inf.readInt(2, 10000,\n            format(\"ages[%d]\", i + 1).c_str());\n    }\n\n    // Read the jury's solution\n    bool ansImpossible = false;\n    try {\n        Distribution juryDist = readDistribution(ans, n, ages, \"jury\");\n        ansImpossible = juryDist.impossible;\n    } catch (...) {\n        quitf(_fail, \"Jury's answer is invalid or caused an exception in the checker.\");\n    }\n\n    // Read the participant's solution\n    bool oufImpossible = false;\n    try {\n        Distribution partDist = readDistribution(ouf, n, ages, \"participant\");\n        oufImpossible = partDist.impossible;\n    } catch (...) {\n        quitf(_wa, \"Participant's answer is invalid or caused an exception in checker.\");\n    }\n\n    // Compare the results\n    if (ansImpossible) {\n        // Jury says no valid arrangement\n        if (oufImpossible) {\n            quitf(_ok, \"Both jury and participant say 'Impossible'.\");\n        } else {\n            // Jury says impossible, participant found valid\n            quitf(_fail, \"Jury says Impossible, participant found a valid arrangement.\");\n        }\n    } else {\n        // Jury has a valid arrangement\n        if (oufImpossible) {\n            quitf(_wa, \"Jury found a valid arrangement, but participant says Impossible.\");\n        } else {\n            quitf(_ok, \"Both jury and participant have valid solutions.\");\n        }\n    }\n\n    // Fallback\n    quitf(_fail, \"Unexpected logic path in checker.\");\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    \n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> ages(n);\n\n    if (type == \"all_even\") {\n        for(int i = 0; i < n; ++i) {\n            ages[i] = rnd.next(2, 5000) * 2; // Even numbers between 4 and 10000\n        }\n    } else if (type == \"all_odd\") {\n        for(int i = 0; i < n; ++i) {\n            ages[i] = rnd.next(1, 5000) * 2 + 1; // Odd numbers between 3 and 10001\n        }\n    } else if (type == \"alternating\") {\n        for(int i = 0; i < n; ++i) {\n            if (i % 2 == 0) {\n                ages[i] = rnd.next(1, 5000) * 2; // Even numbers\n            } else {\n                ages[i] = rnd.next(1, 5000) * 2 + 1; // Odd numbers\n            }\n        }\n    } else if (type == \"impossible\") {\n        for(int i = 0; i < n; ++i) {\n            ages[i] = 4; // All ages are 4 (even), sum of any two ages is 8, which is not prime\n        }\n    } else { // random\n        for(int i = 0; i < n; ++i) {\n            ages[i] = rnd.next(2, 10000); // Random ages between 2 and 10000\n        }\n    }\n\n    // Output\n    printf(\"%d\\n\", n);\n    for(int i = 0; i < n; ++i) {\n        printf(\"%d%c\", ages[i], i == n - 1 ? '\\n' : ' ');\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    \n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> ages(n);\n\n    if (type == \"all_even\") {\n        for(int i = 0; i < n; ++i) {\n            ages[i] = rnd.next(2, 5000) * 2; // Even numbers between 4 and 10000\n        }\n    } else if (type == \"all_odd\") {\n        for(int i = 0; i < n; ++i) {\n            ages[i] = rnd.next(1, 5000) * 2 + 1; // Odd numbers between 3 and 10001\n        }\n    } else if (type == \"alternating\") {\n        for(int i = 0; i < n; ++i) {\n            if (i % 2 == 0) {\n                ages[i] = rnd.next(1, 5000) * 2; // Even numbers\n            } else {\n                ages[i] = rnd.next(1, 5000) * 2 + 1; // Odd numbers\n            }\n        }\n    } else if (type == \"impossible\") {\n        for(int i = 0; i < n; ++i) {\n            ages[i] = 4; // All ages are 4 (even), sum of any two ages is 8, which is not prime\n        }\n    } else { // random\n        for(int i = 0; i < n; ++i) {\n            ages[i] = rnd.next(2, 10000); // Random ages between 2 and 10000\n        }\n    }\n\n    // Output\n    printf(\"%d\\n\", n);\n    for(int i = 0; i < n; ++i) {\n        printf(\"%d%c\", ages[i], i == n - 1 ? '\\n' : ' ');\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 3 -type random\n./gen -n 3 -type all_even\n./gen -n 3 -type all_odd\n./gen -n 3 -type alternating\n./gen -n 3 -type impossible\n\n./gen -n 5 -type random\n./gen -n 5 -type all_even\n./gen -n 5 -type all_odd\n./gen -n 5 -type alternating\n./gen -n 5 -type impossible\n\n./gen -n 10 -type random\n./gen -n 10 -type all_even\n./gen -n 10 -type all_odd\n./gen -n 10 -type alternating\n./gen -n 10 -type impossible\n\n./gen -n 50 -type random\n./gen -n 50 -type all_even\n./gen -n 50 -type all_odd\n./gen -n 50 -type alternating\n./gen -n 50 -type impossible\n\n./gen -n 100 -type random\n./gen -n 100 -type all_even\n./gen -n 100 -type all_odd\n./gen -n 100 -type alternating\n./gen -n 100 -type impossible\n\n./gen -n 200 -type random\n./gen -n 200 -type all_even\n./gen -n 200 -type all_odd\n./gen -n 200 -type alternating\n./gen -n 200 -type impossible\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:41:43.062233",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "512/A",
      "title": "A. Лиса и имена",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест2 секунды",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеВ первой строке записано целое число n (1 ≤ n ≤ 100), количество имен.В каждой из следующих n строк записано по одному слову namei (1 ≤ |namei| ≤ 100), обозначающему i-е имя. Каждое имя содержит только строчные буквы латинского алфавита. Все имена различны.",
      "output_spec": "Выходные данныеЕсли существует такой порядок букв, при котором имена в данном списке следуют в лексикографическом порядке, выведите любой такой порядок в виде перестановки символов 'a'–'z' (иными словами, выведите сначала первую букву модифицированного алфавита, затем вторую, и так далее).В противном случае выведите единственное слово «Impossible» (без кавычек).",
      "sample_tests": "ПримерыВходные данныеСкопировать3rivestshamiradlemanВыходные данныеСкопироватьbcdefghijklmnopqrsatuvwxyzВходные данныеСкопировать10touristpetrwjmzbmryeputonsvepifanovscottwuoooooooooooooooosubscriberrowdarktankengineerВыходные данныеСкопироватьImpossibleВходные данныеСкопировать10petregorendagorionfeferivanilovetanyaromanovakostkadmitriyhmaratsnowbearbredorjaguarturnikcgyforeverВыходные данныеСкопироватьaghjlnopefikdmbcqrstuvwxyzВходные данныеСкопировать7carcarecarefulcarefullybecarefuldontforgetsomethingotherwiseyouwillbehackedgoodluckВыходные данныеСкопироватьacbdefhijklmnogpqrstuvwxyz",
      "description": "A. Лиса и имена\n\nограничение по времени на тест2 секунды\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвыводstdout\n\nВходные данныеВ первой строке записано целое число n (1 ≤ n ≤ 100), количество имен.В каждой из следующих n строк записано по одному слову namei (1 ≤ |namei| ≤ 100), обозначающему i-е имя. Каждое имя содержит только строчные буквы латинского алфавита. Все имена различны.\n\nВходные данные\n\nВыходные данныеЕсли существует такой порядок букв, при котором имена в данном списке следуют в лексикографическом порядке, выведите любой такой порядок в виде перестановки символов 'a'–'z' (иными словами, выведите сначала первую букву модифицированного алфавита, затем вторую, и так далее).В противном случае выведите единственное слово «Impossible» (без кавычек).\n\nВыходные данные\n\nВходные данныеСкопировать3rivestshamiradlemanВыходные данныеСкопироватьbcdefghijklmnopqrsatuvwxyzВходные данныеСкопировать10touristpetrwjmzbmryeputonsvepifanovscottwuoooooooooooooooosubscriberrowdarktankengineerВыходные данныеСкопироватьImpossibleВходные данныеСкопировать10petregorendagorionfeferivanilovetanyaromanovakostkadmitriyhmaratsnowbearbredorjaguarturnikcgyforeverВыходные данныеСкопироватьaghjlnopefikdmbcqrstuvwxyzВходные данныеСкопировать7carcarecarefulcarefullybecarefuldontforgetsomethingotherwiseyouwillbehackedgoodluckВыходные данныеСкопироватьacbdefhijklmnogpqrstuvwxyz\n\nВходные данныеСкопировать3rivestshamiradleman\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопироватьbcdefghijklmnopqrsatuvwxyz\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать10touristpetrwjmzbmryeputonsvepifanovscottwuoooooooooooooooosubscriberrowdarktankengineer\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопироватьImpossible\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать10petregorendagorionfeferivanilovetanyaromanovakostkadmitriyhmaratsnowbearbredorjaguarturnikcgyforever\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопироватьaghjlnopefikdmbcqrstuvwxyz\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать7carcarecarefulcarefullybecarefuldontforgetsomethingotherwiseyouwillbehackedgoodluck\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопироватьacbdefhijklmnogpqrstuvwxyz\n\nВыходные данныеСкопировать\n\nСкопировать",
      "solutions": [
        {
          "title": "Codeforces Round #290 - Codeforces",
          "content": "Лиса Ciel возвращается!Все приглашаются поучаствовать в Codeforces Round #290, который начинается в обычное время в ближайший понедельник.Это мой четвёртый раунд на Codeforces, можете ознакомиться с моими предыдущими раундами: #190, #228, #270.Последний Div1-раунд (#286) оказался очень непростым, поэтому мы решили уменьшить сложность раунда (например, Div1-E превратилась в Div1-D). Надеюсь, это позволит большому количеству людей насладиться всеми задачами раунда: в этот раз ни одна задача не требует продвинутых знаний наподобие линейной алгебры или преобразования Фурье.Главным персонажем раунда будет Лиса Ciel и её жизнь: она учится программировать, играет, путешествует, принимает ужин, а также делает многое другое.Как и на раунде #228, топ-20 участников, присутствующих на зимних сборах в Петрозаводске, будут награждены футболочками Codeforces. Футболку может получить любой участник сборов, член жюри, тренер, организатор или любой другой человек, так или иначе присутствующий на сборах.Как обычно, спасибо Zlobober за ценные советы и помощь в подготовке моего раунда, и MikeMirzayanov за платформы Codeforces и Polygon.Удачи! Update1: Score Distribution is ... Div2: Standard (500 — 1000 — 1500 — 2000 — 2500), Div1: a bit unusual ... (500 — 1000 — 1500 — 2250 — 2250)Update2: Editorial: http://codeforces.com/blog/entry/16173Update3: Congratulation to our winners:Div1: Petr Endagorion mmaxio jqdai0815 tourist They are all people who solved 5 tasks!Div2: SkullSkin joshkirstein gabrielinelus UnknownNooby Andrey_WK",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/16147",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1530
        },
        {
          "title": "Codeforces Round #290 Editorial - Codeforces",
          "content": "Update 1 : here are the reference solutions for this contest: Div2-A: http://ideone.com/JP1Ksj DIv2-B: http://ideone.com/udz3bN Div2-C / Div1-A: http://ideone.com/KVobNb Div2-D / Div1-B: http://ideone.com/7MQqOm Div2-E / Div1-C: http://ideone.com/z3FsU2 Div1-D: http://ideone.com/Y7j21a Div1-E: http://ideone.com/Orbacp Note that for Div2-E / Div1-C, it is for the harder version: we need to handle '1' in the cycle.510A - Fox And SnakeThere are 2 different ways to solve this kind of task:First one is to simulate the movement of the snake head, and you draw '#'s on the board. The code will look like: head = (1, 1)\nrepeat:\n\trepeat m-1 times: head move to right\n\trepeat 2 times: head move down\n\trepeat 2 times: head move down\n\trepeat m-1 times: head move to left\n\trepeat 2 times: head move down\n\trepeat 2 times: head move down\nuntil head is out of the boardAnother way is to do some observation about the result, you can find this pattern: (4k+1) / (4k+3) line: \"#######\"\n(4k+2) line: \".......#\"\n(4k+0) line: \"#.......\"510B - Fox And Two DotsThis task is essentially ask if there is a cycle in an undirected graph: treat each cell as a node, and add an edge if two cells are neighborhood and have some color.There are lots of ways to do this, for example: Run dfs / bfs, if an edge lead you to a visited node, then there must be a cycle. For each connected component, test if |#edges| = |#nodes| - 1, if not then there must be a cycle. 510C - Fox And Names / 512A - Fox And NamesLet's first think about what S < T can tell us: suppose S = abcxyz and T = abcuv. Then we know that S < T if and only if x < u by the definition.So we can transform the conditions name1 < name2, name2 < name3 ... into the order of letters.Then the question become: do we have a permutation that satisfy those conditions. It is actually the classic topological order question.One trick in this task is that, if we have something like xy < x then there is no solution. This is not covered in pretests. :)510D - Fox And Jumping / 512B - Fox And JumpingThis task equals to: what is the minimal sum of costs that we can select k cards, so their GCD is 1.First observation is that: GCD(x1, x2, ..., xk) = 1 means that for any prime p, there exist i such that xi is not dividable by p. So we only care about what prime factors a number contain. (So for example, 12 -> {2, 3}, 6 -> {2, 3}, 9 -> {3]})The second observation is: If x ≤ 109 then it has at most 9 prime factors.So after we select one number, we only care about these 9 or less primes. Then this problem equals to set covering problem (SCP), it can be done by mask DP. It can run in about O(2^9 * n^2).510E - Fox And Dinner / 512C - Fox And DinnerFirst finding is: if a + b is a prime, then one of them is an odd number, another is an even number. (that's why we set 2 ≤ xi)Then we could find: every odd number have exactly 2 even number as neighborhood, and every even number have exactly 2 odd number as neighborhood. And that means we need |#even| = |#odd| to have a solution.So it looks like bipartite graph matching, but every element matched 2 elements. And in fact it can be handled by maxflow: For each odd number, we add a node on the left side and link it from source with capacity equals to 2, and for each even number, we add a node on the right side and link it to sink with capacity equals to 2. And if sum of two numbers is a prime number, we link them with capacity equals to 1.Then we solve the max flow, it have solution if and only if maxflow = 2 * |#even|.We can construct the answer(cycles) from the matches.Note: Actually this task is still solvable if we allow ai = 1. But you need some clever way to deal with it. We think it is too hard so we removed this case. What do you think about this decision?512D - Fox And TravellingWe could find that some nodes cannot be visited. And more specific, if one node is in a cycle then it cannot be visited. So what about the structure of nodes that we can visit?Let's first find a way to get all nodes that could be visited. We can deal with this by something like biconnected decomposition, but that is not easy to implement. In fact we can use this simple method: each time we pick one node that have at most 1 neighborhood and delete it. Repeat this process until we can't do it anymore.We could find these nodes are actually belonging to these 2 kinds: 1. A tree. 2. Rooted tree. (that means, the root is attached to a cycle)The rooted tree case is simple: we can solve it by tree DP. The state will be dp[i][j] = the way to remove j nodes in the subtree rooted at i.Then how to solve the unrooted tree case? The way to deal with that is to transform it into rooted case. We have 2 solution: We select one unvisited node as the root by some rules: for example, we select one with minimal index. Then we just need to modify the DP a bit to adjust this additional condition. We could find if the tree has n nodes and we visit k nodes in the end, then there will be max(1, n-k) ways to choose the root. That means if we choose every node as the root and sum up them, we will count this case exactly max(1, n-k) times. So we just do the rooted DP for from node n times, and divide max(1, n-k) for ans[k]. The overall complicity is O(n4), and it can be optimize into O(n3) if you like.512E - Fox And PolygonTriangulation of polygon is something hard to think about. So the first key observation is that, we can transform this task into operations on rooted trees!One Triangulation of polygon can be mapping to one rooted tree. And the flip operation can be mapping to the rotation of trees. (It is the operation we used to balance our BST) You can find the mapping from above picture. The red lines indicate the edge that will be flipped and the nodes we rotated.Then we should find a standard shape of the tree, and solve this task: how to rotate any tree into this standard shape?My solution is to choose the balanced tree as standard shape. The way to do that is this: find the node that the index is the middle number, rotate it to the top(that what we did for splay tree), and do the same thing for each subtree.It is easy to see it could work in O(nlogn) steps.",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/16173",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 512\\s*A"
          },
          "content_length": 6165
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #290 - Codeforces - Code 1",
          "code": "26\na\nb\nc\n...\nz",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16147",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #290 - Codeforces - Code 2",
          "code": "26\na\nb\nc\n...\nz",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16147",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #290 Editorial - Codeforces - Code 1",
          "code": "head = (1, 1)\nrepeat:\n\trepeat m-1 times: head move to right\n\trepeat 2 times: head move down\n\trepeat 2 times: head move down\n\trepeat m-1 times: head move to left\n\trepeat 2 times: head move down\n\trepeat 2 times: head move down\nuntil head is out of the board",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16173",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #290 Editorial - Codeforces - Code 2",
          "code": "head = (1, 1)\nrepeat:\n\trepeat m-1 times: head move to right\n\trepeat 2 times: head move down\n\trepeat 2 times: head move down\n\trepeat m-1 times: head move to left\n\trepeat 2 times: head move down\n\trepeat 2 times: head move down\nuntil head is out of the board",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16173",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #290 Editorial - Codeforces - Code 3",
          "code": "(4k+1) / (4k+3) line: \"#######\"\n(4k+2) line: \".......#\"\n(4k+0) line: \"#.......\"",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16173",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #290 Editorial - Codeforces - Code 4",
          "code": "(4k+1) / (4k+3) line: \"#######\"\n(4k+2) line: \".......#\"\n(4k+0) line: \"#.......\"",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16173",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #290 Editorial - Codeforces - Code 5",
          "code": "for (i64 i = 0; i < n; i++) {\n    hepsi[ l[i] ] = c[i];\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16173",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #290 Editorial - Codeforces - Code 6",
          "code": "for (i64 i = 0; i < n; i++) {\n    hepsi[ l[i] ] = c[i];\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16173",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #290 Editorial - Codeforces - Code 7",
          "code": "hepsi[ 0 ] = 0;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16173",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #290 Editorial - Codeforces - Code 8",
          "code": "hepsi[ 0 ] = 0;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16173",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #290 Editorial - Codeforces - Code 9",
          "code": "s = primes.size();\n\nfor(int mask = 0; mask < (1<<s); mask++){\n\tdp[mask] = INF;\n}\n\t\t\ndp[m[i]] = c[i];\n\t\t\nfor(int mask = 0; mask < (1<<s); mask++){\n\tfor(int j = 0; j < n; j++){\n\t\tif(dp[mask] != INF)\n\t\t\tdp[mask | m[j]] = min(dp[mask | m[j]], dp[mask] + c[j]);\n\t}\n}\n\nans = min(ans, dp[(1<<s) - 1]);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16173",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #290 Editorial - Codeforces - Code 10",
          "code": "s = primes.size();\n\nfor(int mask = 0; mask < (1<<s); mask++){\n\tdp[mask] = INF;\n}\n\t\t\ndp[m[i]] = c[i];\n\t\t\nfor(int mask = 0; mask < (1<<s); mask++){\n\tfor(int j = 0; j < n; j++){\n\t\tif(dp[mask] != INF)\n\t\t\tdp[mask | m[j]] = min(dp[mask | m[j]], dp[mask] + c[j]);\n\t}\n}\n\nans = min(ans, dp[(1<<s) - 1]);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16173",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #290 Editorial - Codeforces - Code 11",
          "code": "3 3\nBAB\nAAA\nBAB",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16173",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #290 Editorial - Codeforces - Code 12",
          "code": "3 3\nBAB\nAAA\nBAB",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16173",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #290 Editorial - Codeforces - Code 13",
          "code": "#include<Stdio.h>",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/16173",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #290 Editorial - Codeforces - Code 14",
          "code": "dp[i][sz[i]] = dp[i][sz[i] - 1]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16173",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #290 Editorial - Codeforces - Code 15",
          "code": "dpValue dfs(int cur, int from)\n{\n\tdpValue ret;\n\tret.x[0] = 1;\n\tfor(int i = 0; i < e[cur].size(); i++)\n\t{\n\t\tint t = e[cur][i];\n\t\tif(t == from) continue;\n\t\tret = combine(ret, dfs(t, cur));\n\t}\n\tfor(int i = 0; i < MAXN; i++)\n\t\tif(ret.x[i] == 0)\n\t\t{\n\t\t\tret.x[i] = ret.x[i-1];\n\t\t\tbreak;\n\t\t}\n\treturn ret;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16173",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #290 Editorial - Codeforces - Code 16",
          "code": "dpValue dfs(int cur, int from)\n{\n\tdpValue ret;\n\tret.x[0] = 1;\n\tfor(int i = 0; i < e[cur].size(); i++)\n\t{\n\t\tint t = e[cur][i];\n\t\tif(t == from) continue;\n\t\tret = combine(ret, dfs(t, cur));\n\t}\n\tfor(int i = 0; i < MAXN; i++)\n\t\tif(ret.x[i] == 0)\n\t\t{\n\t\t\tret.x[i] = ret.x[i-1];\n\t\t\tbreak;\n\t\t}\n\treturn ret;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16173",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #290 Editorial - Codeforces - Code 17",
          "code": "dpValue combine(dpValue A, dpValue B)\n{\n\tdpValue ret;\n\tfor(int i = 0; i < MAXN; i++)\n\t\tfor(int j = 0; i+j < MAXN; j++)\n\t\t{\n\t\t\tret.x[i+j] += ((A.x[i] * B.x[j]) % mod) * C(i+j, i);\n\t\t\tret.x[i+j] %= mod;\n\t\t}\n\treturn ret;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16173",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #290 Editorial - Codeforces - Code 18",
          "code": "dpValue combine(dpValue A, dpValue B)\n{\n\tdpValue ret;\n\tfor(int i = 0; i < MAXN; i++)\n\t\tfor(int j = 0; i+j < MAXN; j++)\n\t\t{\n\t\t\tret.x[i+j] += ((A.x[i] * B.x[j]) % mod) * C(i+j, i);\n\t\t\tret.x[i+j] %= mod;\n\t\t}\n\treturn ret;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16173",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #290 Editorial - Codeforces - Code 19",
          "code": "4\n2 4 5 7\n1 1 1 1000000000",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16173",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #290 Editorial - Codeforces - Code 20",
          "code": "4\n2 4 5 7\n1 1 1 1000000000",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16173",
          "author": "Qingyu"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readEoln();\n\n    set<string> nameSet;\n    for (int i = 0; i < n; i++) {\n        string name = inf.readToken(\"[a-z]{1,100}\", \"name\");\n        inf.readEoln();\n        ensuref(nameSet.find(name) == nameSet.end(), \"Name %s occurs more than once\", name.c_str());\n        nameSet.insert(name);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readEoln();\n\n    set<string> nameSet;\n    for (int i = 0; i < n; i++) {\n        string name = inf.readToken(\"[a-z]{1,100}\", \"name\");\n        inf.readEoln();\n        ensuref(nameSet.find(name) == nameSet.end(), \"Name %s occurs more than once\", name.c_str());\n        nameSet.insert(name);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readEoln();\n\n    set<string> nameSet;\n    for (int i = 0; i < n; i++) {\n        string name = inf.readToken(\"[a-z]{1,100}\", \"name\");\n        inf.readEoln();\n        ensuref(nameSet.find(name) == nameSet.end(), \"Name %s occurs more than once\", name.c_str());\n        nameSet.insert(name);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\n/*\n    This problem asks us to determine if there is ANY order of letters 'a'–'z'\n    such that the given list of names is sorted lexicographically under that order.\n    If such an order exists, contestants should print any valid permutation of\n    'a'–'z'. Otherwise, they should print \"Impossible\".\n\n    Since there can be multiple valid permutations, we need a custom checker\n    that verifies the contestant's output:\n\n      1) If the contestant prints \"Impossible\", check if no valid ordering exists.\n         - If indeed no ordering can make the names sorted, accept (_ok).\n         - If there is at least one valid ordering, reject (_wa).\n\n      2) If the contestant prints a 26-letter string:\n         - Check it is a permutation of 'a'–'z'.\n         - Check that the given list of names is sorted according to this custom\n           alphabet order. If not sorted, reject (_wa). If sorted, accept (_ok).\n\n    We do NOT compare against the jury's official output because the problem\n    explicitly allows multiple correct solutions if an ordering exists.\n*/\n\nstatic const int ALPHABET_SIZE = 26;\n\n// Returns:\n//   true if the list of names can be sorted by some ordering of letters\n//   false if it is impossible (i.e., there is a contradiction).\n// Also builds adjacency matrix \"adj\" (adj[u][v] = true if letter u < letter v in the order).\n// If it returns false, \"adj\" is in an undefined state.\nbool buildConstraints(const vector<string> &names, vector<vector<bool>> &adj)\n{\n    // We'll compare consecutive pairs of names to deduce ordering constraints.\n    // If we find a contradiction, return false immediately.\n    for (int i = 0; i + 1 < (int)names.size(); i++)\n    {\n        const string &a = names[i];\n        const string &b = names[i + 1];\n\n        // Find first differing character\n        int pos = 0;\n        int minLen = min((int)a.size(), (int)b.size());\n        while (pos < minLen && a[pos] == b[pos]) pos++;\n\n        if (pos == minLen)\n        {\n            // If we didn't find a difference but |a| > |b|, no order can fix that\n            // because \"a\" is a prefix of \"b\" but 'a' is longer => not sorted\n            if ((int)a.size() > (int)b.size())\n                return false;\n        }\n        else\n        {\n            // We found a differing character\n            int x = a[pos] - 'a';\n            int y = b[pos] - 'a';\n            // a[pos] < b[pos] in the custom alphabet\n            adj[x][y] = true;\n        }\n    }\n    return true;\n}\n\n// Checks if there exists ANY topological ordering of the adjacency constraints.\n// If a cycle exists, then no such ordering is possible => return false.\n// Otherwise, return true.\nbool canFindAnyValidOrdering(const vector<vector<bool>> &adj)\n{\n    // We'll do a standard Kahn's or DFS-based check for cycle in the directed graph\n    // Graph: 26 letters, edges from u to v if adj[u][v] = true\n    vector<int> indeg(ALPHABET_SIZE, 0);\n    for (int i = 0; i < ALPHABET_SIZE; i++)\n    {\n        for (int j = 0; j < ALPHABET_SIZE; j++)\n        {\n            if (adj[i][j]) indeg[j]++;\n        }\n    }\n\n    queue<int> q;\n    for (int i = 0; i < ALPHABET_SIZE; i++)\n    {\n        if (indeg[i] == 0) q.push(i);\n    }\n\n    int visitedCount = 0;\n    while (!q.empty())\n    {\n        int u = q.front();\n        q.pop();\n        visitedCount++;\n\n        for (int v = 0; v < ALPHABET_SIZE; v++)\n        {\n            if (adj[u][v])\n            {\n                indeg[v]--;\n                if (indeg[v] == 0) q.push(v);\n            }\n        }\n    }\n\n    // If visitedCount < ALPHABET_SIZE, there's a cycle\n    return (visitedCount == ALPHABET_SIZE);\n}\n\n// Check if the given 26-letter string is a permutation of 'a'..'z'.\nbool isPermutationOfAlphabet(const string &s)\n{\n    if (s.size() != 26) return false;\n    vector<bool> used(ALPHABET_SIZE, false);\n    for (char c : s)\n    {\n        if (c < 'a' || c > 'z') return false;\n        if (used[c - 'a']) return false;\n        used[c - 'a'] = true;\n    }\n    return true;\n}\n\n// Check if names[] is sorted according to the order defined by \"perm\" (which\n// is a 26-length string that is a permutation of 'a'..'z').\nbool checkSorted(const vector<string> &names, const string &perm)\n{\n    // Build array to store position of each letter\n    // pos[c - 'a'] = index of c in perm\n    vector<int> pos(ALPHABET_SIZE);\n    for (int i = 0; i < ALPHABET_SIZE; i++)\n    {\n        pos[perm[i] - 'a'] = i;\n    }\n\n    // Compare consecutive pairs\n    for (int i = 0; i + 1 < (int)names.size(); i++)\n    {\n        const string &a = names[i];\n        const string &b = names[i + 1];\n\n        // Compare lexicographically under custom order\n        int minLen = min((int)a.size(), (int)b.size());\n        int idx = 0;\n        while (idx < minLen && a[idx] == b[idx]) idx++;\n\n        if (idx == minLen)\n        {\n            // If prefix but a is longer, not sorted\n            if ((int)a.size() > (int)b.size()) return false;\n        }\n        else\n        {\n            // We found a difference at idx\n            int ca = pos[a[idx] - 'a'];\n            int cb = pos[b[idx] - 'a'];\n            if (ca > cb) return false;\n        }\n    }\n    return true;\n}\n\nint main(int argc, char* argv[])\n{\n    registerTestlibCmd(argc, argv);\n\n    // Read input\n    int n = inf.readInt(1, 100, \"n\");\n    vector<string> names(n);\n    for (int i = 0; i < n; i++)\n    {\n        // Each name is a token of 1..100 lowercase letters\n        names[i] = inf.readToken(\"[a-z]{1,100}\", (\"name#\" + to_string(i + 1)).c_str());\n    }\n\n    // Read contestant's output\n    // The answer should be either \"Impossible\" or a 26-letter permutation.\n    // We'll peek the first token to decide what to do.\n    // (We read as token to handle the single-word answer.)\n    string answer = ouf.readToken();\n\n    // Build adjacency constraints from the input names\n    vector<vector<bool>> adj(ALPHABET_SIZE, vector<bool>(ALPHABET_SIZE, false));\n    bool validConstraints = buildConstraints(names, adj);\n\n    // If building constraints found a direct contradiction, then any\n    // supposed order is impossible. If the participant doesn't say \"Impossible\"\n    // in that scenario, it's WA unless they are somehow checking incorrectly.\n    // We'll handle that logic below.\n\n    // If the participant says \"Impossible\":\n    if (answer == \"Impossible\")\n    {\n        // Check if there's ANY valid ordering. If constraints are already invalid\n        // or if there's a cycle, there's indeed no valid order => OK.\n        // Otherwise => WA (participant missed that an order actually exists).\n        if (!validConstraints)\n        {\n            // There's a direct contradiction among consecutive names\n            quitf(_ok, \"Correct: indeed no valid ordering is possible.\");\n        }\n        else\n        {\n            // We must check if there's a cycle in the partial order\n            if (!canFindAnyValidOrdering(adj))\n                quitf(_ok, \"Correct: no valid ordering (cycle in constraints).\");\n            else\n                quitf(_wa, \"Wrong: a valid ordering exists but contestant printed 'Impossible'.\");\n        }\n    }\n    else\n    {\n        // The contestant presumably provided a 26-letter permutation.\n        // First, check if it is indeed 26 letters and a permutation of a..z\n        if (!isPermutationOfAlphabet(answer))\n            quitf(_wa, \"Output is neither 'Impossible' nor a valid 26-letter permutation.\");\n\n        // If constraints were already directly invalid, then no order can fix it\n        // => WA if the participant tried to give an order.\n        if (!validConstraints)\n            quitf(_wa, \"No valid order is possible, but contestant provided a permutation.\");\n\n        // Otherwise, check that the partial order is not inherently cyclical:\n        // If it's cyclical, no permutation can satisfy it => WA.\n        if (!canFindAnyValidOrdering(adj))\n            quitf(_wa, \"No valid order is possible (cycle in constraints).\");\n\n        // Finally, check if the given permutation sorts the names\n        if (checkSorted(names, answer))\n            quitf(_ok, \"Correct permutation provided.\");\n        else\n            quitf(_wa, \"Names are not sorted under the provided permutation.\");\n    }\n\n    // Shouldn't reach here, but just in case:\n    quitf(_fail, \"Checker logic error.\");\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nvoid generate_random_possible(int n) {\n    // Generate random letter order (permutation of 'a'-'z')\n    vector<char> letters(26);\n    for (int i = 0; i < 26; i++) {\n        letters[i] = 'a' + i;\n    }\n    shuffle(letters.begin(), letters.end());\n\n    // Build letter_order mapping\n    int letter_order[26];\n    for (int i = 0; i < 26; i++) {\n        letter_order[letters[i] - 'a'] = i;\n    }\n\n    // Generate n random names\n    vector<string> names;\n    for (int i = 0; i < n; i++) {\n        int len = rnd.next(1, 100);\n        string name;\n        for (int j = 0; j < len; j++) {\n            char c = rnd.next('a', 'z');\n            name += c;\n        }\n        names.push_back(name);\n    }\n\n    // Sort names according to custom order\n    sort(names.begin(), names.end(), [&](const string& a, const string& b) {\n        int la = a.size(), lb = b.size();\n        int l = min(la, lb);\n        for (int i = 0; i < l; i++) {\n            int oa = letter_order[a[i] - 'a'];\n            int ob = letter_order[b[i] - 'a'];\n            if (oa != ob)\n                return oa < ob;\n        }\n        return la < lb;\n    });\n\n    // Output n\n    printf(\"%d\\n\", n);\n    // Output names\n    for (auto& name : names) {\n        printf(\"%s\\n\", name.c_str());\n    }\n}\n\nvoid generate_random_impossible(int n) {\n    // Generate impossible test case by constructing a cycle in the ordering\n    int k = rnd.next(3, min(26, n)); // Number of letters in the cycle\n\n    vector<char> letters(26);\n    for (int i = 0; i < 26; i++) {\n        letters[i] = 'a' + i;\n    }\n    shuffle(letters.begin(), letters.end());\n    letters.resize(k); // The letters involved in the cycle\n\n    vector<string> names;\n    // Create names to induce ordering constraints\n    for (int i = 0; i < k; i++) {\n        // Names that differ at the first character\n        string name1, name2;\n        name1 = letters[i];\n        name2 = letters[(i + 1) % k];\n        names.push_back(name1);\n        names.push_back(name2);\n    }\n    // Add additional random names to reach n\n    while ((int)names.size() < n) {\n        int len = rnd.next(1, 100);\n        string name;\n        for (int j = 0; j < len; j++) {\n            char c = rnd.next('a', 'z');\n            name += c;\n        }\n        names.push_back(name);\n    }\n\n    // Shuffle the names\n    shuffle(names.begin(), names.end());\n\n    // Output n\n    printf(\"%d\\n\", n);\n    // Output names\n    for (const string& name : names) {\n        printf(\"%s\\n\", name.c_str());\n    }\n}\n\nvoid generate_prefixes_possible(int n) {\n    // Generate names where each name is a prefix of the next name, possible case\n    string base = \"\";\n    vector<string> names;\n    for (int i = 0; i < n; i++) {\n        char c = rnd.next('a', 'z');\n        base += c;\n        names.push_back(base);\n    }\n\n    // Output n\n    printf(\"%d\\n\", n);\n    // Output names\n    for (const string& name : names) {\n        printf(\"%s\\n\", name.c_str());\n    }\n}\n\nvoid generate_prefixes_impossible(int n) {\n    // Generate names where there is a conflict in prefixes, impossible case\n    vector<string> names;\n    string base = \"\";\n    for (int i = 0; i < n - 1; i++) {\n        char c = 'a';\n        base += c;\n        names.push_back(base);\n    }\n    // Add a name that is a shorter prefix, causing impossibility\n    names.push_back(\"b\");\n\n    // Output n\n    printf(\"%d\\n\", n);\n    // Output names\n    for (const string& name : names) {\n        printf(\"%s\\n\", name.c_str());\n    }\n}\n\nvoid generate_maximal_lengths(int n) {\n    // Generate names with maximal length (100)\n    vector<string> names;\n    for (int i = 0; i < n; i++) {\n        string name;\n        for (int j = 0; j < 100; j++) {\n            char c = rnd.next('a', 'z');\n            name += c;\n        }\n        names.push_back(name);\n    }\n\n    // Output n\n    printf(\"%d\\n\", n);\n    // Output names\n    for (const string& name : names) {\n        printf(\"%s\\n\", name.c_str());\n    }\n}\n\nvoid generate_minimal_lengths(int n) {\n    // Generate names with minimal length (1)\n    vector<string> names;\n    for (int i = 0; i < n; i++) {\n        char c = rnd.next('a', 'z');\n        string name;\n        name += c;\n        names.push_back(name);\n    }\n\n    // Output n\n    printf(\"%d\\n\", n);\n    // Output names\n    for (const string& name : names) {\n        printf(\"%s\\n\", name.c_str());\n    }\n}\n\nvoid generate_same_letters(int n) {\n    // Generate names using only a few letters\n    vector<char> selected_letters;\n    int num_letters = rnd.next(1, 3);\n    for (int i = 0; i < num_letters; i++) {\n        char c = rnd.next('a', 'z');\n        selected_letters.push_back(c);\n    }\n\n    vector<string> names;\n    for (int i = 0; i < n; i++) {\n        int len = rnd.next(1, 100);\n        string name;\n        for (int j = 0; j < len; j++) {\n            char c = selected_letters[rnd.next(0, num_letters - 1)];\n            name += c;\n        }\n        names.push_back(name);\n    }\n\n    // Output n\n    printf(\"%d\\n\", n);\n    // Output names\n    for (const string& name : names) {\n        printf(\"%s\\n\", name.c_str());\n    }\n}\n\nvoid generate_cycles(int n) {\n    // Similar to random_impossible but specifically focusing on cycles\n    generate_random_impossible(n);\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random_possible\");\n\n    if (type == \"random_possible\") {\n        generate_random_possible(n);\n    } else if (type == \"random_impossible\") {\n        generate_random_impossible(n);\n    } else if (type == \"prefixes_possible\") {\n        generate_prefixes_possible(n);\n    } else if (type == \"prefixes_impossible\") {\n        generate_prefixes_impossible(n);\n    } else if (type == \"maximal_lengths\") {\n        generate_maximal_lengths(n);\n    } else if (type == \"minimal_lengths\") {\n        generate_minimal_lengths(n);\n    } else if (type == \"same_letters\") {\n        generate_same_letters(n);\n    } else if (type == \"cycles\") {\n        generate_cycles(n);\n    } else {\n        // Default\n        generate_random_possible(n);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nvoid generate_random_possible(int n) {\n    // Generate random letter order (permutation of 'a'-'z')\n    vector<char> letters(26);\n    for (int i = 0; i < 26; i++) {\n        letters[i] = 'a' + i;\n    }\n    shuffle(letters.begin(), letters.end());\n\n    // Build letter_order mapping\n    int letter_order[26];\n    for (int i = 0; i < 26; i++) {\n        letter_order[letters[i] - 'a'] = i;\n    }\n\n    // Generate n random names\n    vector<string> names;\n    for (int i = 0; i < n; i++) {\n        int len = rnd.next(1, 100);\n        string name;\n        for (int j = 0; j < len; j++) {\n            char c = rnd.next('a', 'z');\n            name += c;\n        }\n        names.push_back(name);\n    }\n\n    // Sort names according to custom order\n    sort(names.begin(), names.end(), [&](const string& a, const string& b) {\n        int la = a.size(), lb = b.size();\n        int l = min(la, lb);\n        for (int i = 0; i < l; i++) {\n            int oa = letter_order[a[i] - 'a'];\n            int ob = letter_order[b[i] - 'a'];\n            if (oa != ob)\n                return oa < ob;\n        }\n        return la < lb;\n    });\n\n    // Output n\n    printf(\"%d\\n\", n);\n    // Output names\n    for (auto& name : names) {\n        printf(\"%s\\n\", name.c_str());\n    }\n}\n\nvoid generate_random_impossible(int n) {\n    // Generate impossible test case by constructing a cycle in the ordering\n    int k = rnd.next(3, min(26, n)); // Number of letters in the cycle\n\n    vector<char> letters(26);\n    for (int i = 0; i < 26; i++) {\n        letters[i] = 'a' + i;\n    }\n    shuffle(letters.begin(), letters.end());\n    letters.resize(k); // The letters involved in the cycle\n\n    vector<string> names;\n    // Create names to induce ordering constraints\n    for (int i = 0; i < k; i++) {\n        // Names that differ at the first character\n        string name1, name2;\n        name1 = letters[i];\n        name2 = letters[(i + 1) % k];\n        names.push_back(name1);\n        names.push_back(name2);\n    }\n    // Add additional random names to reach n\n    while ((int)names.size() < n) {\n        int len = rnd.next(1, 100);\n        string name;\n        for (int j = 0; j < len; j++) {\n            char c = rnd.next('a', 'z');\n            name += c;\n        }\n        names.push_back(name);\n    }\n\n    // Shuffle the names\n    shuffle(names.begin(), names.end());\n\n    // Output n\n    printf(\"%d\\n\", n);\n    // Output names\n    for (const string& name : names) {\n        printf(\"%s\\n\", name.c_str());\n    }\n}\n\nvoid generate_prefixes_possible(int n) {\n    // Generate names where each name is a prefix of the next name, possible case\n    string base = \"\";\n    vector<string> names;\n    for (int i = 0; i < n; i++) {\n        char c = rnd.next('a', 'z');\n        base += c;\n        names.push_back(base);\n    }\n\n    // Output n\n    printf(\"%d\\n\", n);\n    // Output names\n    for (const string& name : names) {\n        printf(\"%s\\n\", name.c_str());\n    }\n}\n\nvoid generate_prefixes_impossible(int n) {\n    // Generate names where there is a conflict in prefixes, impossible case\n    vector<string> names;\n    string base = \"\";\n    for (int i = 0; i < n - 1; i++) {\n        char c = 'a';\n        base += c;\n        names.push_back(base);\n    }\n    // Add a name that is a shorter prefix, causing impossibility\n    names.push_back(\"b\");\n\n    // Output n\n    printf(\"%d\\n\", n);\n    // Output names\n    for (const string& name : names) {\n        printf(\"%s\\n\", name.c_str());\n    }\n}\n\nvoid generate_maximal_lengths(int n) {\n    // Generate names with maximal length (100)\n    vector<string> names;\n    for (int i = 0; i < n; i++) {\n        string name;\n        for (int j = 0; j < 100; j++) {\n            char c = rnd.next('a', 'z');\n            name += c;\n        }\n        names.push_back(name);\n    }\n\n    // Output n\n    printf(\"%d\\n\", n);\n    // Output names\n    for (const string& name : names) {\n        printf(\"%s\\n\", name.c_str());\n    }\n}\n\nvoid generate_minimal_lengths(int n) {\n    // Generate names with minimal length (1)\n    vector<string> names;\n    for (int i = 0; i < n; i++) {\n        char c = rnd.next('a', 'z');\n        string name;\n        name += c;\n        names.push_back(name);\n    }\n\n    // Output n\n    printf(\"%d\\n\", n);\n    // Output names\n    for (const string& name : names) {\n        printf(\"%s\\n\", name.c_str());\n    }\n}\n\nvoid generate_same_letters(int n) {\n    // Generate names using only a few letters\n    vector<char> selected_letters;\n    int num_letters = rnd.next(1, 3);\n    for (int i = 0; i < num_letters; i++) {\n        char c = rnd.next('a', 'z');\n        selected_letters.push_back(c);\n    }\n\n    vector<string> names;\n    for (int i = 0; i < n; i++) {\n        int len = rnd.next(1, 100);\n        string name;\n        for (int j = 0; j < len; j++) {\n            char c = selected_letters[rnd.next(0, num_letters - 1)];\n            name += c;\n        }\n        names.push_back(name);\n    }\n\n    // Output n\n    printf(\"%d\\n\", n);\n    // Output names\n    for (const string& name : names) {\n        printf(\"%s\\n\", name.c_str());\n    }\n}\n\nvoid generate_cycles(int n) {\n    // Similar to random_impossible but specifically focusing on cycles\n    generate_random_impossible(n);\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random_possible\");\n\n    if (type == \"random_possible\") {\n        generate_random_possible(n);\n    } else if (type == \"random_impossible\") {\n        generate_random_impossible(n);\n    } else if (type == \"prefixes_possible\") {\n        generate_prefixes_possible(n);\n    } else if (type == \"prefixes_impossible\") {\n        generate_prefixes_impossible(n);\n    } else if (type == \"maximal_lengths\") {\n        generate_maximal_lengths(n);\n    } else if (type == \"minimal_lengths\") {\n        generate_minimal_lengths(n);\n    } else if (type == \"same_letters\") {\n        generate_same_letters(n);\n    } else if (type == \"cycles\") {\n        generate_cycles(n);\n    } else {\n        // Default\n        generate_random_possible(n);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Random possible cases\n./gen -n 1 -type random_possible\n./gen -n 2 -type random_possible\n./gen -n 10 -type random_possible\n./gen -n 50 -type random_possible\n./gen -n 100 -type random_possible\n\n# Random impossible cases\n./gen -n 3 -type random_impossible\n./gen -n 10 -type random_impossible\n./gen -n 50 -type random_impossible\n./gen -n 100 -type random_impossible\n\n# Prefixes possible\n./gen -n 5 -type prefixes_possible\n./gen -n 10 -type prefixes_possible\n./gen -n 20 -type prefixes_possible\n\n# Prefixes impossible\n./gen -n 5 -type prefixes_impossible\n./gen -n 10 -type prefixes_impossible\n./gen -n 20 -type prefixes_impossible\n\n# Maximal lengths\n./gen -n 1 -type maximal_lengths\n./gen -n 10 -type maximal_lengths\n./gen -n 100 -type maximal_lengths\n\n# Minimal lengths\n./gen -n 1 -type minimal_lengths\n./gen -n 50 -type minimal_lengths\n./gen -n 100 -type minimal_lengths\n\n# Same letters\n./gen -n 5 -type same_letters\n./gen -n 25 -type same_letters\n./gen -n 100 -type same_letters\n\n# Cycles\n./gen -n 5 -type cycles\n./gen -n 10 -type cycles\n./gen -n 26 -type cycles\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:41:44.747683",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "512/B",
      "title": "B. Fox And Jumping",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains an integer n (1 ≤ n ≤ 300), number of cards.The second line contains n numbers li (1 ≤ li ≤ 109), the jump lengths of cards.The third line contains n numbers ci (1 ≤ ci ≤ 105), the costs of cards.",
      "output_spec": "OutputIf it is impossible to buy some cards and become able to jump to any cell, output -1. Otherwise output the minimal cost of buying such set of cards.",
      "sample_tests": "ExamplesInputCopy3100 99 99001 1 1OutputCopy2InputCopy510 20 30 40 501 1 1 1 1OutputCopy-1InputCopy715015 10010 6006 4290 2730 2310 11 1 1 1 1 1 10OutputCopy6InputCopy84264 4921 6321 6984 2316 8432 6120 10264264 4921 6321 6984 2316 8432 6120 1026OutputCopy7237",
      "description": "B. Fox And Jumping\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains an integer n (1 ≤ n ≤ 300), number of cards.The second line contains n numbers li (1 ≤ li ≤ 109), the jump lengths of cards.The third line contains n numbers ci (1 ≤ ci ≤ 105), the costs of cards.\n\nOutputIf it is impossible to buy some cards and become able to jump to any cell, output -1. Otherwise output the minimal cost of buying such set of cards.\n\nInputCopy3100 99 99001 1 1OutputCopy2InputCopy510 20 30 40 501 1 1 1 1OutputCopy-1InputCopy715015 10010 6006 4290 2730 2310 11 1 1 1 1 1 10OutputCopy6InputCopy84264 4921 6321 6984 2316 8432 6120 10264264 4921 6321 6984 2316 8432 6120 1026OutputCopy7237\n\nInputCopy3100 99 99001 1 1\n\nOutputCopy2\n\nInputCopy510 20 30 40 501 1 1 1 1\n\nOutputCopy-1\n\nInputCopy715015 10010 6006 4290 2730 2310 11 1 1 1 1 1 10\n\nOutputCopy6\n\nInputCopy84264 4921 6321 6984 2316 8432 6120 10264264 4921 6321 6984 2316 8432 6120 1026\n\nOutputCopy7237\n\nNoteIn first sample test, buying one card is not enough: for example, if you buy a card with length 100, you can't jump to any cell whose index is not a multiple of 100. The best way is to buy first and second card, that will make you be able to jump to any cell.In the second sample test, even if you buy all cards, you can't jump to any cell whose index is not a multiple of 10, so you should output -1.",
      "solutions": [
        {
          "title": "Codeforces Round #290 - Codeforces",
          "content": "Fox Ciel is back!I invite you to participate in Codeforces Round #290, which will start at the standard time on next Monday: This is my 4th round on Codeforces, my previous rounds: #190, #228, #270.Last Div1 Round (#286) is so hard, so after notice that, we decide to reduce the difficulty of this round. (For example, current Div1-E was used as Div1-D) I hope more people can enjoy all tasks in this round: this time no task requires advanced knowledge like linear space or Fourier Transform.The background story will be Fox Ciel's life: learning programming, play games, traveling, have dinner and so on.Like Round #228, top-20 contestants that are currently at Petrozavodsk training camp will be rewarded with nice Codefores T-Shirts. Contestant may be a team member, jury, coach, organizer, or whoever else involved in camp, no matter of status.As usual, thanks to Zlobober for giving great suggestions and test my round, and MikeMirzayanov for the platform (Codeforces and Polygon). Good luck and have fun!Update1: Score Distribution is ... Div2: Standard (500 — 1000 — 1500 — 2000 — 2500), Div1: a bit unusual ... (500 — 1000 — 1500 — 2250 — 2250)Update2: Editorial: http://codeforces.com/blog/entry/16173Update3: Congratulation to our winners:Div1: Petr Endagorion mmaxio jqdai0815 tourist They are all people who solved 5 tasks!Div2: SkullSkin joshkirstein gabrielinelus UnknownNooby Andrey_WK",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/16147",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1401
        },
        {
          "title": "Codeforces Round #290 Editorial - Codeforces",
          "content": "Update 1 : here are the reference solutions for this contest: Div2-A: http://ideone.com/JP1Ksj DIv2-B: http://ideone.com/udz3bN Div2-C / Div1-A: http://ideone.com/KVobNb Div2-D / Div1-B: http://ideone.com/7MQqOm Div2-E / Div1-C: http://ideone.com/z3FsU2 Div1-D: http://ideone.com/Y7j21a Div1-E: http://ideone.com/Orbacp Note that for Div2-E / Div1-C, it is for the harder version: we need to handle '1' in the cycle.510A - Fox And SnakeThere are 2 different ways to solve this kind of task:First one is to simulate the movement of the snake head, and you draw '#'s on the board. The code will look like: head = (1, 1)\nrepeat:\n\trepeat m-1 times: head move to right\n\trepeat 2 times: head move down\n\trepeat 2 times: head move down\n\trepeat m-1 times: head move to left\n\trepeat 2 times: head move down\n\trepeat 2 times: head move down\nuntil head is out of the boardAnother way is to do some observation about the result, you can find this pattern: (4k+1) / (4k+3) line: \"#######\"\n(4k+2) line: \".......#\"\n(4k+0) line: \"#.......\"510B - Fox And Two DotsThis task is essentially ask if there is a cycle in an undirected graph: treat each cell as a node, and add an edge if two cells are neighborhood and have some color.There are lots of ways to do this, for example: Run dfs / bfs, if an edge lead you to a visited node, then there must be a cycle. For each connected component, test if |#edges| = |#nodes| - 1, if not then there must be a cycle. 510C - Fox And Names / 512A - Fox And NamesLet's first think about what S < T can tell us: suppose S = abcxyz and T = abcuv. Then we know that S < T if and only if x < u by the definition.So we can transform the conditions name1 < name2, name2 < name3 ... into the order of letters.Then the question become: do we have a permutation that satisfy those conditions. It is actually the classic topological order question.One trick in this task is that, if we have something like xy < x then there is no solution. This is not covered in pretests. :)510D - Fox And Jumping / 512B - Fox And JumpingThis task equals to: what is the minimal sum of costs that we can select k cards, so their GCD is 1.First observation is that: GCD(x1, x2, ..., xk) = 1 means that for any prime p, there exist i such that xi is not dividable by p. So we only care about what prime factors a number contain. (So for example, 12 -> {2, 3}, 6 -> {2, 3}, 9 -> {3]})The second observation is: If x ≤ 109 then it has at most 9 prime factors.So after we select one number, we only care about these 9 or less primes. Then this problem equals to set covering problem (SCP), it can be done by mask DP. It can run in about O(2^9 * n^2).510E - Fox And Dinner / 512C - Fox And DinnerFirst finding is: if a + b is a prime, then one of them is an odd number, another is an even number. (that's why we set 2 ≤ xi)Then we could find: every odd number have exactly 2 even number as neighborhood, and every even number have exactly 2 odd number as neighborhood. And that means we need |#even| = |#odd| to have a solution.So it looks like bipartite graph matching, but every element matched 2 elements. And in fact it can be handled by maxflow: For each odd number, we add a node on the left side and link it from source with capacity equals to 2, and for each even number, we add a node on the right side and link it to sink with capacity equals to 2. And if sum of two numbers is a prime number, we link them with capacity equals to 1.Then we solve the max flow, it have solution if and only if maxflow = 2 * |#even|.We can construct the answer(cycles) from the matches.Note: Actually this task is still solvable if we allow ai = 1. But you need some clever way to deal with it. We think it is too hard so we removed this case. What do you think about this decision?512D - Fox And TravellingWe could find that some nodes cannot be visited. And more specific, if one node is in a cycle then it cannot be visited. So what about the structure of nodes that we can visit?Let's first find a way to get all nodes that could be visited. We can deal with this by something like biconnected decomposition, but that is not easy to implement. In fact we can use this simple method: each time we pick one node that have at most 1 neighborhood and delete it. Repeat this process until we can't do it anymore.We could find these nodes are actually belonging to these 2 kinds: 1. A tree. 2. Rooted tree. (that means, the root is attached to a cycle)The rooted tree case is simple: we can solve it by tree DP. The state will be dp[i][j] = the way to remove j nodes in the subtree rooted at i.Then how to solve the unrooted tree case? The way to deal with that is to transform it into rooted case. We have 2 solution: We select one unvisited node as the root by some rules: for example, we select one with minimal index. Then we just need to modify the DP a bit to adjust this additional condition. We could find if the tree has n nodes and we visit k nodes in the end, then there will be max(1, n-k) ways to choose the root. That means if we choose every node as the root and sum up them, we will count this case exactly max(1, n-k) times. So we just do the rooted DP for from node n times, and divide max(1, n-k) for ans[k]. The overall complicity is O(n4), and it can be optimize into O(n3) if you like.512E - Fox And PolygonTriangulation of polygon is something hard to think about. So the first key observation is that, we can transform this task into operations on rooted trees!One Triangulation of polygon can be mapping to one rooted tree. And the flip operation can be mapping to the rotation of trees. (It is the operation we used to balance our BST) You can find the mapping from above picture. The red lines indicate the edge that will be flipped and the nodes we rotated.Then we should find a standard shape of the tree, and solve this task: how to rotate any tree into this standard shape?My solution is to choose the balanced tree as standard shape. The way to do that is this: find the node that the index is the middle number, rotate it to the top(that what we did for splay tree), and do the same thing for each subtree.It is easy to see it could work in O(nlogn) steps.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/16173",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 512\\s*B"
          },
          "content_length": 6165
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #290 - Codeforces - Code 1",
          "code": "26\na\nb\nc\n...\nz",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16147",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #290 - Codeforces - Code 2",
          "code": "26\na\nb\nc\n...\nz",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16147",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #290 Editorial - Codeforces - Code 1",
          "code": "head = (1, 1)\nrepeat:\n\trepeat m-1 times: head move to right\n\trepeat 2 times: head move down\n\trepeat 2 times: head move down\n\trepeat m-1 times: head move to left\n\trepeat 2 times: head move down\n\trepeat 2 times: head move down\nuntil head is out of the board",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16173",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #290 Editorial - Codeforces - Code 2",
          "code": "head = (1, 1)\nrepeat:\n\trepeat m-1 times: head move to right\n\trepeat 2 times: head move down\n\trepeat 2 times: head move down\n\trepeat m-1 times: head move to left\n\trepeat 2 times: head move down\n\trepeat 2 times: head move down\nuntil head is out of the board",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16173",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #290 Editorial - Codeforces - Code 3",
          "code": "(4k+1) / (4k+3) line: \"#######\"\n(4k+2) line: \".......#\"\n(4k+0) line: \"#.......\"",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16173",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #290 Editorial - Codeforces - Code 4",
          "code": "(4k+1) / (4k+3) line: \"#######\"\n(4k+2) line: \".......#\"\n(4k+0) line: \"#.......\"",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16173",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #290 Editorial - Codeforces - Code 5",
          "code": "for (i64 i = 0; i < n; i++) {\n    hepsi[ l[i] ] = c[i];\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16173",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #290 Editorial - Codeforces - Code 6",
          "code": "for (i64 i = 0; i < n; i++) {\n    hepsi[ l[i] ] = c[i];\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16173",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #290 Editorial - Codeforces - Code 7",
          "code": "hepsi[ 0 ] = 0;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16173",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #290 Editorial - Codeforces - Code 8",
          "code": "hepsi[ 0 ] = 0;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16173",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #290 Editorial - Codeforces - Code 9",
          "code": "s = primes.size();\n\nfor(int mask = 0; mask < (1<<s); mask++){\n\tdp[mask] = INF;\n}\n\t\t\ndp[m[i]] = c[i];\n\t\t\nfor(int mask = 0; mask < (1<<s); mask++){\n\tfor(int j = 0; j < n; j++){\n\t\tif(dp[mask] != INF)\n\t\t\tdp[mask | m[j]] = min(dp[mask | m[j]], dp[mask] + c[j]);\n\t}\n}\n\nans = min(ans, dp[(1<<s) - 1]);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16173",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #290 Editorial - Codeforces - Code 10",
          "code": "s = primes.size();\n\nfor(int mask = 0; mask < (1<<s); mask++){\n\tdp[mask] = INF;\n}\n\t\t\ndp[m[i]] = c[i];\n\t\t\nfor(int mask = 0; mask < (1<<s); mask++){\n\tfor(int j = 0; j < n; j++){\n\t\tif(dp[mask] != INF)\n\t\t\tdp[mask | m[j]] = min(dp[mask | m[j]], dp[mask] + c[j]);\n\t}\n}\n\nans = min(ans, dp[(1<<s) - 1]);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16173",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #290 Editorial - Codeforces - Code 11",
          "code": "3 3\nBAB\nAAA\nBAB",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16173",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #290 Editorial - Codeforces - Code 12",
          "code": "3 3\nBAB\nAAA\nBAB",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16173",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #290 Editorial - Codeforces - Code 13",
          "code": "#include<Stdio.h>",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/16173",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #290 Editorial - Codeforces - Code 14",
          "code": "dp[i][sz[i]] = dp[i][sz[i] - 1]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16173",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #290 Editorial - Codeforces - Code 15",
          "code": "dpValue dfs(int cur, int from)\n{\n\tdpValue ret;\n\tret.x[0] = 1;\n\tfor(int i = 0; i < e[cur].size(); i++)\n\t{\n\t\tint t = e[cur][i];\n\t\tif(t == from) continue;\n\t\tret = combine(ret, dfs(t, cur));\n\t}\n\tfor(int i = 0; i < MAXN; i++)\n\t\tif(ret.x[i] == 0)\n\t\t{\n\t\t\tret.x[i] = ret.x[i-1];\n\t\t\tbreak;\n\t\t}\n\treturn ret;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16173",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #290 Editorial - Codeforces - Code 16",
          "code": "dpValue dfs(int cur, int from)\n{\n\tdpValue ret;\n\tret.x[0] = 1;\n\tfor(int i = 0; i < e[cur].size(); i++)\n\t{\n\t\tint t = e[cur][i];\n\t\tif(t == from) continue;\n\t\tret = combine(ret, dfs(t, cur));\n\t}\n\tfor(int i = 0; i < MAXN; i++)\n\t\tif(ret.x[i] == 0)\n\t\t{\n\t\t\tret.x[i] = ret.x[i-1];\n\t\t\tbreak;\n\t\t}\n\treturn ret;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16173",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #290 Editorial - Codeforces - Code 17",
          "code": "dpValue combine(dpValue A, dpValue B)\n{\n\tdpValue ret;\n\tfor(int i = 0; i < MAXN; i++)\n\t\tfor(int j = 0; i+j < MAXN; j++)\n\t\t{\n\t\t\tret.x[i+j] += ((A.x[i] * B.x[j]) % mod) * C(i+j, i);\n\t\t\tret.x[i+j] %= mod;\n\t\t}\n\treturn ret;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16173",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #290 Editorial - Codeforces - Code 18",
          "code": "dpValue combine(dpValue A, dpValue B)\n{\n\tdpValue ret;\n\tfor(int i = 0; i < MAXN; i++)\n\t\tfor(int j = 0; i+j < MAXN; j++)\n\t\t{\n\t\t\tret.x[i+j] += ((A.x[i] * B.x[j]) % mod) * C(i+j, i);\n\t\t\tret.x[i+j] %= mod;\n\t\t}\n\treturn ret;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16173",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #290 Editorial - Codeforces - Code 19",
          "code": "4\n2 4 5 7\n1 1 1 1000000000",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16173",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #290 Editorial - Codeforces - Code 20",
          "code": "4\n2 4 5 7\n1 1 1 1000000000",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16173",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 300, \"n\");\n    inf.readEoln();\n    vector<long long> li = inf.readLongs(n, 1, 1000000000LL, \"li\");\n    inf.readEoln();\n    vector<long long> ci = inf.readLongs(n, 1, 100000LL, \"ci\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 300, \"n\");\n    inf.readEoln();\n    vector<long long> li = inf.readLongs(n, 1, 1000000000LL, \"li\");\n    inf.readEoln();\n    vector<long long> ci = inf.readLongs(n, 1, 100000LL, \"ci\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 300, \"n\");\n    inf.readEoln();\n    vector<long long> li = inf.readLongs(n, 1, 1000000000LL, \"li\");\n    inf.readEoln();\n    vector<long long> ci = inf.readLongs(n, 1, 100000LL, \"ci\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> l(n);\n    vector<int> c(n);\n    int max_l = 1e9;\n    int max_c = 1e5;\n\n    if (type == \"random_possible\") {\n        for (int i = 0; i < n; i++) {\n            l[i] = rnd.next(1, max_l);\n            c[i] = rnd.next(1, max_c);\n        }\n\n        int total_gcd = l[0];\n        for (int i = 1; i < n; i++) {\n            total_gcd = __gcd(total_gcd, l[i]);\n        }\n\n        if (total_gcd != 1) {\n            // Set a random l_i to 1 to ensure GCD is 1\n            int idx = rnd.next(0, n - 1);\n            l[idx] = 1;\n        }\n    } else if (type == \"random_impossible\") {\n        // Choose a random gcd greater than 1\n        int min_gcd = 2;\n        int max_gcd = 1e6;\n        int g = rnd.next(min_gcd, max_gcd);\n\n        for (int i = 0; i < n; i++) {\n            int k = rnd.next(1, max_l / g);\n            l[i] = k * g;\n            c[i] = rnd.next(1, max_c);\n        }\n\n    } else if (type == \"single_l_equals_1\") {\n        for (int i = 0; i < n; i++) {\n            l[i] = rnd.next(2, max_l); // Start from 2 so l_i != 1\n            c[i] = rnd.next(1, max_c);\n        }\n\n        // Set one l_i to 1\n        int idx = rnd.next(0, n - 1);\n        l[idx] = 1;\n\n    } else if (type == \"max_cost\") {\n        for (int i = 0; i < n; i++) {\n            l[i] = rnd.next(1, max_l);\n            c[i] = max_c; // Set c_i to maximum\n        }\n\n        int total_gcd = l[0];\n        for (int i = 1; i < n; i++) {\n            total_gcd = __gcd(total_gcd, l[i]);\n        }\n\n        if (total_gcd != 1) {\n            // Set a random l_i to 1 to ensure GCD is 1\n            int idx = rnd.next(0, n - 1);\n            l[idx] = 1;\n        }\n    } else {\n        // Default random test case\n        for (int i = 0; i < n; i++) {\n            l[i] = rnd.next(1, max_l);\n            c[i] = rnd.next(1, max_c);\n        }\n    }\n\n    // Output n\n    printf(\"%d\\n\", n);\n\n    // Output l_i's\n    for (int i = 0; i < n; i++) {\n        printf(\"%d%c\", l[i], i == n - 1 ? '\\n' : ' ');\n    }\n\n    // Output c_i's\n    for (int i = 0; i < n; i++) {\n        printf(\"%d%c\", c[i], i == n - 1 ? '\\n' : ' ');\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> l(n);\n    vector<int> c(n);\n    int max_l = 1e9;\n    int max_c = 1e5;\n\n    if (type == \"random_possible\") {\n        for (int i = 0; i < n; i++) {\n            l[i] = rnd.next(1, max_l);\n            c[i] = rnd.next(1, max_c);\n        }\n\n        int total_gcd = l[0];\n        for (int i = 1; i < n; i++) {\n            total_gcd = __gcd(total_gcd, l[i]);\n        }\n\n        if (total_gcd != 1) {\n            // Set a random l_i to 1 to ensure GCD is 1\n            int idx = rnd.next(0, n - 1);\n            l[idx] = 1;\n        }\n    } else if (type == \"random_impossible\") {\n        // Choose a random gcd greater than 1\n        int min_gcd = 2;\n        int max_gcd = 1e6;\n        int g = rnd.next(min_gcd, max_gcd);\n\n        for (int i = 0; i < n; i++) {\n            int k = rnd.next(1, max_l / g);\n            l[i] = k * g;\n            c[i] = rnd.next(1, max_c);\n        }\n\n    } else if (type == \"single_l_equals_1\") {\n        for (int i = 0; i < n; i++) {\n            l[i] = rnd.next(2, max_l); // Start from 2 so l_i != 1\n            c[i] = rnd.next(1, max_c);\n        }\n\n        // Set one l_i to 1\n        int idx = rnd.next(0, n - 1);\n        l[idx] = 1;\n\n    } else if (type == \"max_cost\") {\n        for (int i = 0; i < n; i++) {\n            l[i] = rnd.next(1, max_l);\n            c[i] = max_c; // Set c_i to maximum\n        }\n\n        int total_gcd = l[0];\n        for (int i = 1; i < n; i++) {\n            total_gcd = __gcd(total_gcd, l[i]);\n        }\n\n        if (total_gcd != 1) {\n            // Set a random l_i to 1 to ensure GCD is 1\n            int idx = rnd.next(0, n - 1);\n            l[idx] = 1;\n        }\n    } else {\n        // Default random test case\n        for (int i = 0; i < n; i++) {\n            l[i] = rnd.next(1, max_l);\n            c[i] = rnd.next(1, max_c);\n        }\n    }\n\n    // Output n\n    printf(\"%d\\n\", n);\n\n    // Output l_i's\n    for (int i = 0; i < n; i++) {\n        printf(\"%d%c\", l[i], i == n - 1 ? '\\n' : ' ');\n    }\n\n    // Output c_i's\n    for (int i = 0; i < n; i++) {\n        printf(\"%d%c\", c[i], i == n - 1 ? '\\n' : ' ');\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -type random_possible\n./gen -n 1 -type random_impossible\n\n./gen -n 2 -type random_possible\n./gen -n 2 -type random_impossible\n./gen -n 2 -type single_l_equals_1\n./gen -n 2 -type max_cost\n\n./gen -n 5 -type random_possible\n./gen -n 5 -type random_impossible\n./gen -n 5 -type single_l_equals_1\n./gen -n 5 -type max_cost\n\n./gen -n 10 -type random_possible\n./gen -n 10 -type random_impossible\n./gen -n 10 -type single_l_equals_1\n./gen -n 10 -type max_cost\n\n./gen -n 50 -type random_possible\n./gen -n 50 -type random_impossible\n./gen -n 50 -type single_l_equals_1\n./gen -n 50 -type max_cost\n\n./gen -n 100 -type random_possible\n./gen -n 100 -type random_impossible\n./gen -n 100 -type single_l_equals_1\n./gen -n 100 -type max_cost\n\n./gen -n 200 -type random_possible\n./gen -n 200 -type random_impossible\n./gen -n 200 -type single_l_equals_1\n./gen -n 200 -type max_cost\n\n./gen -n 300 -type random_possible\n./gen -n 300 -type random_impossible\n./gen -n 300 -type single_l_equals_1\n./gen -n 300 -type max_cost\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:41:46.900189",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "512/C",
      "title": "C. Fox And Dinner",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains single integer n (3 ≤ n ≤ 200): the number of foxes in this party. The second line contains n integers ai (2 ≤ ai ≤ 104).",
      "output_spec": "OutputIf it is impossible to do this, output \"Impossible\".Otherwise, in the first line output an integer m (): the number of tables.Then output m lines, each line should start with an integer k -=– the number of foxes around that table, and then k numbers — indices of fox sitting around that table in clockwise order.If there are several possible arrangements, output any of them.",
      "sample_tests": "ExamplesInputCopy43 4 8 9OutputCopy14 1 2 4 3InputCopy52 2 2 2 2OutputCopyImpossibleInputCopy122 3 4 5 6 7 8 9 10 11 12 13OutputCopy112 1 2 3 6 5 12 9 8 7 10 11 4InputCopy242 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25OutputCopy36 1 2 3 6 5 410 7 8 9 12 15 14 13 16 11 108 17 18 23 22 19 20 21 24",
      "description": "C. Fox And Dinner\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains single integer n (3 ≤ n ≤ 200): the number of foxes in this party. The second line contains n integers ai (2 ≤ ai ≤ 104).\n\nOutputIf it is impossible to do this, output \"Impossible\".Otherwise, in the first line output an integer m (): the number of tables.Then output m lines, each line should start with an integer k -=– the number of foxes around that table, and then k numbers — indices of fox sitting around that table in clockwise order.If there are several possible arrangements, output any of them.\n\nInputCopy43 4 8 9OutputCopy14 1 2 4 3InputCopy52 2 2 2 2OutputCopyImpossibleInputCopy122 3 4 5 6 7 8 9 10 11 12 13OutputCopy112 1 2 3 6 5 12 9 8 7 10 11 4InputCopy242 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25OutputCopy36 1 2 3 6 5 410 7 8 9 12 15 14 13 16 11 108 17 18 23 22 19 20 21 24\n\nInputCopy43 4 8 9\n\nOutputCopy14 1 2 4 3\n\nInputCopy52 2 2 2 2\n\nOutputCopyImpossible\n\nInputCopy122 3 4 5 6 7 8 9 10 11 12 13\n\nOutputCopy112 1 2 3 6 5 12 9 8 7 10 11 4\n\nInputCopy242 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25\n\nOutputCopy36 1 2 3 6 5 410 7 8 9 12 15 14 13 16 11 108 17 18 23 22 19 20 21 24\n\nNoteIn example 1, they can sit around one table, their ages are: 3-8-9-4, adjacent sums are: 11, 17, 13 and 7, all those integers are primes.In example 2, it is not possible: the sum of 2+2 = 4 is not a prime number.",
      "solutions": [
        {
          "title": "Codeforces Round #290 - Codeforces",
          "content": "Fox Ciel is back!I invite you to participate in Codeforces Round #290, which will start at the standard time on next Monday: This is my 4th round on Codeforces, my previous rounds: #190, #228, #270.Last Div1 Round (#286) is so hard, so after notice that, we decide to reduce the difficulty of this round. (For example, current Div1-E was used as Div1-D) I hope more people can enjoy all tasks in this round: this time no task requires advanced knowledge like linear space or Fourier Transform.The background story will be Fox Ciel's life: learning programming, play games, traveling, have dinner and so on.Like Round #228, top-20 contestants that are currently at Petrozavodsk training camp will be rewarded with nice Codefores T-Shirts. Contestant may be a team member, jury, coach, organizer, or whoever else involved in camp, no matter of status.As usual, thanks to Zlobober for giving great suggestions and test my round, and MikeMirzayanov for the platform (Codeforces and Polygon). Good luck and have fun!Update1: Score Distribution is ... Div2: Standard (500 — 1000 — 1500 — 2000 — 2500), Div1: a bit unusual ... (500 — 1000 — 1500 — 2250 — 2250)Update2: Editorial: http://codeforces.com/blog/entry/16173Update3: Congratulation to our winners:Div1: Petr Endagorion mmaxio jqdai0815 tourist They are all people who solved 5 tasks!Div2: SkullSkin joshkirstein gabrielinelus UnknownNooby Andrey_WK",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/16147",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1401
        },
        {
          "title": "Codeforces Round #290 Editorial - Codeforces",
          "content": "Update 1 : here are the reference solutions for this contest: Div2-A: http://ideone.com/JP1Ksj DIv2-B: http://ideone.com/udz3bN Div2-C / Div1-A: http://ideone.com/KVobNb Div2-D / Div1-B: http://ideone.com/7MQqOm Div2-E / Div1-C: http://ideone.com/z3FsU2 Div1-D: http://ideone.com/Y7j21a Div1-E: http://ideone.com/Orbacp Note that for Div2-E / Div1-C, it is for the harder version: we need to handle '1' in the cycle.510A - Fox And SnakeThere are 2 different ways to solve this kind of task:First one is to simulate the movement of the snake head, and you draw '#'s on the board. The code will look like: head = (1, 1)\nrepeat:\n\trepeat m-1 times: head move to right\n\trepeat 2 times: head move down\n\trepeat 2 times: head move down\n\trepeat m-1 times: head move to left\n\trepeat 2 times: head move down\n\trepeat 2 times: head move down\nuntil head is out of the boardAnother way is to do some observation about the result, you can find this pattern: (4k+1) / (4k+3) line: \"#######\"\n(4k+2) line: \".......#\"\n(4k+0) line: \"#.......\"510B - Fox And Two DotsThis task is essentially ask if there is a cycle in an undirected graph: treat each cell as a node, and add an edge if two cells are neighborhood and have some color.There are lots of ways to do this, for example: Run dfs / bfs, if an edge lead you to a visited node, then there must be a cycle. For each connected component, test if |#edges| = |#nodes| - 1, if not then there must be a cycle. 510C - Fox And Names / 512A - Fox And NamesLet's first think about what S < T can tell us: suppose S = abcxyz and T = abcuv. Then we know that S < T if and only if x < u by the definition.So we can transform the conditions name1 < name2, name2 < name3 ... into the order of letters.Then the question become: do we have a permutation that satisfy those conditions. It is actually the classic topological order question.One trick in this task is that, if we have something like xy < x then there is no solution. This is not covered in pretests. :)510D - Fox And Jumping / 512B - Fox And JumpingThis task equals to: what is the minimal sum of costs that we can select k cards, so their GCD is 1.First observation is that: GCD(x1, x2, ..., xk) = 1 means that for any prime p, there exist i such that xi is not dividable by p. So we only care about what prime factors a number contain. (So for example, 12 -> {2, 3}, 6 -> {2, 3}, 9 -> {3]})The second observation is: If x ≤ 109 then it has at most 9 prime factors.So after we select one number, we only care about these 9 or less primes. Then this problem equals to set covering problem (SCP), it can be done by mask DP. It can run in about O(2^9 * n^2).510E - Fox And Dinner / 512C - Fox And DinnerFirst finding is: if a + b is a prime, then one of them is an odd number, another is an even number. (that's why we set 2 ≤ xi)Then we could find: every odd number have exactly 2 even number as neighborhood, and every even number have exactly 2 odd number as neighborhood. And that means we need |#even| = |#odd| to have a solution.So it looks like bipartite graph matching, but every element matched 2 elements. And in fact it can be handled by maxflow: For each odd number, we add a node on the left side and link it from source with capacity equals to 2, and for each even number, we add a node on the right side and link it to sink with capacity equals to 2. And if sum of two numbers is a prime number, we link them with capacity equals to 1.Then we solve the max flow, it have solution if and only if maxflow = 2 * |#even|.We can construct the answer(cycles) from the matches.Note: Actually this task is still solvable if we allow ai = 1. But you need some clever way to deal with it. We think it is too hard so we removed this case. What do you think about this decision?512D - Fox And TravellingWe could find that some nodes cannot be visited. And more specific, if one node is in a cycle then it cannot be visited. So what about the structure of nodes that we can visit?Let's first find a way to get all nodes that could be visited. We can deal with this by something like biconnected decomposition, but that is not easy to implement. In fact we can use this simple method: each time we pick one node that have at most 1 neighborhood and delete it. Repeat this process until we can't do it anymore.We could find these nodes are actually belonging to these 2 kinds: 1. A tree. 2. Rooted tree. (that means, the root is attached to a cycle)The rooted tree case is simple: we can solve it by tree DP. The state will be dp[i][j] = the way to remove j nodes in the subtree rooted at i.Then how to solve the unrooted tree case? The way to deal with that is to transform it into rooted case. We have 2 solution: We select one unvisited node as the root by some rules: for example, we select one with minimal index. Then we just need to modify the DP a bit to adjust this additional condition. We could find if the tree has n nodes and we visit k nodes in the end, then there will be max(1, n-k) ways to choose the root. That means if we choose every node as the root and sum up them, we will count this case exactly max(1, n-k) times. So we just do the rooted DP for from node n times, and divide max(1, n-k) for ans[k]. The overall complicity is O(n4), and it can be optimize into O(n3) if you like.512E - Fox And PolygonTriangulation of polygon is something hard to think about. So the first key observation is that, we can transform this task into operations on rooted trees!One Triangulation of polygon can be mapping to one rooted tree. And the flip operation can be mapping to the rotation of trees. (It is the operation we used to balance our BST) You can find the mapping from above picture. The red lines indicate the edge that will be flipped and the nodes we rotated.Then we should find a standard shape of the tree, and solve this task: how to rotate any tree into this standard shape?My solution is to choose the balanced tree as standard shape. The way to do that is this: find the node that the index is the middle number, rotate it to the top(that what we did for splay tree), and do the same thing for each subtree.It is easy to see it could work in O(nlogn) steps.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/16173",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 512\\s*C"
          },
          "content_length": 6165
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #290 - Codeforces - Code 1",
          "code": "26\na\nb\nc\n...\nz",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16147",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #290 - Codeforces - Code 2",
          "code": "26\na\nb\nc\n...\nz",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16147",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #290 Editorial - Codeforces - Code 1",
          "code": "head = (1, 1)\nrepeat:\n\trepeat m-1 times: head move to right\n\trepeat 2 times: head move down\n\trepeat 2 times: head move down\n\trepeat m-1 times: head move to left\n\trepeat 2 times: head move down\n\trepeat 2 times: head move down\nuntil head is out of the board",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16173",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #290 Editorial - Codeforces - Code 2",
          "code": "head = (1, 1)\nrepeat:\n\trepeat m-1 times: head move to right\n\trepeat 2 times: head move down\n\trepeat 2 times: head move down\n\trepeat m-1 times: head move to left\n\trepeat 2 times: head move down\n\trepeat 2 times: head move down\nuntil head is out of the board",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16173",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #290 Editorial - Codeforces - Code 3",
          "code": "(4k+1) / (4k+3) line: \"#######\"\n(4k+2) line: \".......#\"\n(4k+0) line: \"#.......\"",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16173",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #290 Editorial - Codeforces - Code 4",
          "code": "(4k+1) / (4k+3) line: \"#######\"\n(4k+2) line: \".......#\"\n(4k+0) line: \"#.......\"",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16173",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #290 Editorial - Codeforces - Code 5",
          "code": "for (i64 i = 0; i < n; i++) {\n    hepsi[ l[i] ] = c[i];\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16173",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #290 Editorial - Codeforces - Code 6",
          "code": "for (i64 i = 0; i < n; i++) {\n    hepsi[ l[i] ] = c[i];\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16173",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #290 Editorial - Codeforces - Code 7",
          "code": "hepsi[ 0 ] = 0;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16173",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #290 Editorial - Codeforces - Code 8",
          "code": "hepsi[ 0 ] = 0;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16173",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #290 Editorial - Codeforces - Code 9",
          "code": "s = primes.size();\n\nfor(int mask = 0; mask < (1<<s); mask++){\n\tdp[mask] = INF;\n}\n\t\t\ndp[m[i]] = c[i];\n\t\t\nfor(int mask = 0; mask < (1<<s); mask++){\n\tfor(int j = 0; j < n; j++){\n\t\tif(dp[mask] != INF)\n\t\t\tdp[mask | m[j]] = min(dp[mask | m[j]], dp[mask] + c[j]);\n\t}\n}\n\nans = min(ans, dp[(1<<s) - 1]);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16173",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #290 Editorial - Codeforces - Code 10",
          "code": "s = primes.size();\n\nfor(int mask = 0; mask < (1<<s); mask++){\n\tdp[mask] = INF;\n}\n\t\t\ndp[m[i]] = c[i];\n\t\t\nfor(int mask = 0; mask < (1<<s); mask++){\n\tfor(int j = 0; j < n; j++){\n\t\tif(dp[mask] != INF)\n\t\t\tdp[mask | m[j]] = min(dp[mask | m[j]], dp[mask] + c[j]);\n\t}\n}\n\nans = min(ans, dp[(1<<s) - 1]);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16173",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #290 Editorial - Codeforces - Code 11",
          "code": "3 3\nBAB\nAAA\nBAB",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16173",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #290 Editorial - Codeforces - Code 12",
          "code": "3 3\nBAB\nAAA\nBAB",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16173",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #290 Editorial - Codeforces - Code 13",
          "code": "#include<Stdio.h>",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/16173",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #290 Editorial - Codeforces - Code 14",
          "code": "dp[i][sz[i]] = dp[i][sz[i] - 1]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16173",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #290 Editorial - Codeforces - Code 15",
          "code": "dpValue dfs(int cur, int from)\n{\n\tdpValue ret;\n\tret.x[0] = 1;\n\tfor(int i = 0; i < e[cur].size(); i++)\n\t{\n\t\tint t = e[cur][i];\n\t\tif(t == from) continue;\n\t\tret = combine(ret, dfs(t, cur));\n\t}\n\tfor(int i = 0; i < MAXN; i++)\n\t\tif(ret.x[i] == 0)\n\t\t{\n\t\t\tret.x[i] = ret.x[i-1];\n\t\t\tbreak;\n\t\t}\n\treturn ret;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16173",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #290 Editorial - Codeforces - Code 16",
          "code": "dpValue dfs(int cur, int from)\n{\n\tdpValue ret;\n\tret.x[0] = 1;\n\tfor(int i = 0; i < e[cur].size(); i++)\n\t{\n\t\tint t = e[cur][i];\n\t\tif(t == from) continue;\n\t\tret = combine(ret, dfs(t, cur));\n\t}\n\tfor(int i = 0; i < MAXN; i++)\n\t\tif(ret.x[i] == 0)\n\t\t{\n\t\t\tret.x[i] = ret.x[i-1];\n\t\t\tbreak;\n\t\t}\n\treturn ret;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16173",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #290 Editorial - Codeforces - Code 17",
          "code": "dpValue combine(dpValue A, dpValue B)\n{\n\tdpValue ret;\n\tfor(int i = 0; i < MAXN; i++)\n\t\tfor(int j = 0; i+j < MAXN; j++)\n\t\t{\n\t\t\tret.x[i+j] += ((A.x[i] * B.x[j]) % mod) * C(i+j, i);\n\t\t\tret.x[i+j] %= mod;\n\t\t}\n\treturn ret;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16173",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #290 Editorial - Codeforces - Code 18",
          "code": "dpValue combine(dpValue A, dpValue B)\n{\n\tdpValue ret;\n\tfor(int i = 0; i < MAXN; i++)\n\t\tfor(int j = 0; i+j < MAXN; j++)\n\t\t{\n\t\t\tret.x[i+j] += ((A.x[i] * B.x[j]) % mod) * C(i+j, i);\n\t\t\tret.x[i+j] %= mod;\n\t\t}\n\treturn ret;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16173",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #290 Editorial - Codeforces - Code 19",
          "code": "4\n2 4 5 7\n1 1 1 1000000000",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16173",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #290 Editorial - Codeforces - Code 20",
          "code": "4\n2 4 5 7\n1 1 1 1000000000",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16173",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(3, 200, \"n\");\n    inf.readEoln();\n    vector<int> a = inf.readInts(n, 2, 10000, \"a_i\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(3, 200, \"n\");\n    inf.readEoln();\n    vector<int> a = inf.readInts(n, 2, 10000, \"a_i\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(3, 200, \"n\");\n    inf.readEoln();\n    vector<int> a = inf.readInts(n, 2, 10000, \"a_i\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nstatic const int MAX_SUM = 40000;\n\n// A helper function to build a sieve for prime checking up to MAX_SUM.\n// For values larger than MAX_SUM, we will do a direct primality test.\nvector<bool> sievePrime(int limit) {\n    vector<bool> isPrime(limit + 1, true);\n    isPrime[0] = false;\n    if (limit >= 1) isPrime[1] = false;\n    for (int i = 2; i * i <= limit; i++) {\n        if (isPrime[i]) {\n            for (int j = i * i; j <= limit; j += i)\n                isPrime[j] = false;\n        }\n    }\n    return isPrime;\n}\n\n// A direct check for primality if x > MAX_SUM\nbool isPrimeLong(long long x) {\n    if (x < 2) return false;\n    for (long long i = 2; i * i <= x; i++) {\n        if (x % i == 0) return false;\n    }\n    return true;\n}\n\nint main(int argc, char* argv[]) {\n    registerTestlibCmd(argc, argv);\n\n    // Read input from the test (not from participant).\n    int n = inf.readInt(3, 200, \"n\");\n    vector<int> ages(n);\n    for (int i = 0; i < n; i++) {\n        ages[i] = inf.readInt(2, 10000, \"ages[i]\");\n    }\n\n    // Precompute prime information up to MAX_SUM.\n    vector<bool> smallPrime = sievePrime(MAX_SUM);\n\n    // Read first token from jury's answer to see if it is \"Impossible\".\n    bool juryImpossible;\n    if (ans.seekEof()) {\n        // If the jury's file is empty, assume it declares \"Impossible\".\n        juryImpossible = true;\n    } else {\n        string tokenAns = ans.readToken();\n        juryImpossible = (tokenAns == \"Impossible\");\n    }\n\n    // Read contestant's output.\n    if (ouf.seekEof()) {\n        quitf(_wa, \"No output from the participant\");\n    }\n    string tokenOut = ouf.readToken();\n\n    // If participant says \"Impossible\"...\n    if (tokenOut == \"Impossible\") {\n        if (juryImpossible) {\n            quitf(_ok, \"Both jury and participant say 'Impossible'\");\n        } else {\n            quitf(_wa, \"Participant says 'Impossible' but jury has a valid arrangement\");\n        }\n    }\n\n    // If participant provides a solution but jury says \"Impossible\", that's also wrong.\n    if (juryImpossible) {\n        quitf(_wa, \"Participant found a solution while jury says 'Impossible'\");\n    }\n\n    // Now parse the participant's solution.\n    // The first token is the number of tables:\n    int m;\n    try {\n        m = stoi(tokenOut);\n    } catch (...) {\n        quitf(_wa, \"Expected an integer (number of tables), got '%s'\", tokenOut.c_str());\n    }\n    if (m < 1 || m > n) {\n        quitf(_wa, \"Number of tables m = %d is out of valid range [1..n]\", m);\n    }\n\n    vector<bool> used(n, false);\n    int totalUsed = 0;\n\n    for (int i = 1; i <= m; i++) {\n        // Read the number of foxes around this table\n        int k = ouf.readInt(3, n, (\"k for table \" + to_string(i)).c_str());\n        vector<int> table(k);\n        for (int j = 0; j < k; j++) {\n            int foxIndex = ouf.readInt(1, n, (\"fox index for table \" + to_string(i)).c_str());\n            // Convert to 0-based for internal checks\n            foxIndex--;\n            if (used[foxIndex]) {\n                quitf(_wa, \"Fox %d is used more than once\", foxIndex + 1);\n            }\n            used[foxIndex] = true;\n            table[j] = foxIndex;\n            totalUsed++;\n        }\n        // Check prime sums for adjacent pairs in a circular manner\n        for (int j = 0; j < k; j++) {\n            int nxt = (j + 1) % k;\n            long long sumAges = (long long)ages[table[j]] + (long long)ages[table[nxt]];\n            if ((sumAges <= MAX_SUM && !smallPrime[sumAges]) ||\n                (sumAges > MAX_SUM && !isPrimeLong(sumAges))) {\n                quitf(_wa, \"Sum of ages %lld (between foxes %d and %d) is not prime\",\n                      sumAges, table[j] + 1, table[nxt] + 1);\n            }\n        }\n    }\n\n    // Check that all n foxes are used exactly once\n    if (totalUsed != n) {\n        quitf(_wa, \"Not all foxes are used exactly once: totalUsed = %d, n = %d\", totalUsed, n);\n    }\n\n    quitf(_ok, \"Participant's solution is valid\");\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> ages(n);\n\n    if (type == \"even\") {\n        // All ages are even numbers ≥2\n        for(int i = 0; i < n; ++i) {\n            ages[i] = 2 * rnd.next(1, 5000); // ages from 2 to 10000\n        }\n    } else if (type == \"odd\") {\n        // All ages are odd numbers ≥3\n        for(int i = 0; i < n; ++i) {\n            ages[i] = 2 * rnd.next(1, 4999) + 1; // ages from 3 to 9999\n        }\n    } else if (type == \"alternate\") {\n        // Alternate between even and odd ages\n        for(int i = 0; i < n; ++i) {\n            if (i % 2 == 0)\n                ages[i] = 2 * rnd.next(1, 5000); // even ages\n            else\n                ages[i] = 2 * rnd.next(1, 4999) + 1; // odd ages\n        }\n    } else if (type == \"same_even\") {\n        // All ages are the same even number\n        int age = 2 * rnd.next(1, 5000);\n        for(int i = 0; i < n; ++i) {\n            ages[i] = age;\n        }\n    } else if (type == \"same_odd\") {\n        // All ages are the same odd number\n        int age = 2 * rnd.next(1, 4999) + 1;\n        for(int i = 0; i < n; ++i) {\n            ages[i] = age;\n        }\n    } else if (type == \"impossible\") {\n        // Generate a test case where it's impossible\n        // For example, all ages are 2\n        int age = 2;\n        for(int i = 0; i < n; ++i) {\n            ages[i] = age;\n        }\n    } else if (type == \"possible\") {\n        // Generate a test case where it's possible\n        // Alternate ages between 2 and 3 to get sums of 5 (prime)\n        for(int i = 0; i < n; ++i) {\n            if (i % 2 == 0)\n                ages[i] = 2;\n            else\n                ages[i] = 3;\n        }\n    } else if (type == \"max\") {\n        // All ages are maximum (10000)\n        int age = 10000;\n        for(int i = 0; i < n; ++i) {\n            ages[i] = age;\n        }\n    } else if (type == \"min\") {\n        // All ages are minimum (2)\n        int age = 2;\n        for(int i = 0; i < n; ++i) {\n            ages[i] = age;\n        }\n    } else if (type == \"reverse\") {\n        // Generate ages in decreasing order\n        int start_age = rnd.next(2, 10000);\n        for(int i = 0; i < n; ++i) {\n            ages[i] = max(2, start_age - i);\n        }\n    } else if (type == \"primes\") {\n        // Generate ages as primes\n        vector<int> primes;\n        const int MAX_AGE = 10000;\n        vector<bool> is_prime(MAX_AGE + 1, true);\n        for(int i = 2; i <= MAX_AGE; ++i) {\n            if (is_prime[i]) {\n                primes.push_back(i);\n                for(int j = i+i; j <= MAX_AGE; j += i) {\n                    is_prime[j] = false;\n                }\n            }\n        }\n        for(int i = 0; i < n; ++i) {\n            ages[i] = primes[rnd.next(0, (int)primes.size() - 1)];\n        }\n    } else {\n        // Default to random\n        for(int i = 0; i < n; ++i) {\n            ages[i] = rnd.next(2, 10000);\n        }\n    }\n\n    // Output n\n    printf(\"%d\\n\", n);\n    for(int i = 0; i < n; ++i) {\n        printf(\"%d\", ages[i]);\n        if (i != n - 1)\n            printf(\" \");\n        else\n            printf(\"\\n\");\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> ages(n);\n\n    if (type == \"even\") {\n        // All ages are even numbers ≥2\n        for(int i = 0; i < n; ++i) {\n            ages[i] = 2 * rnd.next(1, 5000); // ages from 2 to 10000\n        }\n    } else if (type == \"odd\") {\n        // All ages are odd numbers ≥3\n        for(int i = 0; i < n; ++i) {\n            ages[i] = 2 * rnd.next(1, 4999) + 1; // ages from 3 to 9999\n        }\n    } else if (type == \"alternate\") {\n        // Alternate between even and odd ages\n        for(int i = 0; i < n; ++i) {\n            if (i % 2 == 0)\n                ages[i] = 2 * rnd.next(1, 5000); // even ages\n            else\n                ages[i] = 2 * rnd.next(1, 4999) + 1; // odd ages\n        }\n    } else if (type == \"same_even\") {\n        // All ages are the same even number\n        int age = 2 * rnd.next(1, 5000);\n        for(int i = 0; i < n; ++i) {\n            ages[i] = age;\n        }\n    } else if (type == \"same_odd\") {\n        // All ages are the same odd number\n        int age = 2 * rnd.next(1, 4999) + 1;\n        for(int i = 0; i < n; ++i) {\n            ages[i] = age;\n        }\n    } else if (type == \"impossible\") {\n        // Generate a test case where it's impossible\n        // For example, all ages are 2\n        int age = 2;\n        for(int i = 0; i < n; ++i) {\n            ages[i] = age;\n        }\n    } else if (type == \"possible\") {\n        // Generate a test case where it's possible\n        // Alternate ages between 2 and 3 to get sums of 5 (prime)\n        for(int i = 0; i < n; ++i) {\n            if (i % 2 == 0)\n                ages[i] = 2;\n            else\n                ages[i] = 3;\n        }\n    } else if (type == \"max\") {\n        // All ages are maximum (10000)\n        int age = 10000;\n        for(int i = 0; i < n; ++i) {\n            ages[i] = age;\n        }\n    } else if (type == \"min\") {\n        // All ages are minimum (2)\n        int age = 2;\n        for(int i = 0; i < n; ++i) {\n            ages[i] = age;\n        }\n    } else if (type == \"reverse\") {\n        // Generate ages in decreasing order\n        int start_age = rnd.next(2, 10000);\n        for(int i = 0; i < n; ++i) {\n            ages[i] = max(2, start_age - i);\n        }\n    } else if (type == \"primes\") {\n        // Generate ages as primes\n        vector<int> primes;\n        const int MAX_AGE = 10000;\n        vector<bool> is_prime(MAX_AGE + 1, true);\n        for(int i = 2; i <= MAX_AGE; ++i) {\n            if (is_prime[i]) {\n                primes.push_back(i);\n                for(int j = i+i; j <= MAX_AGE; j += i) {\n                    is_prime[j] = false;\n                }\n            }\n        }\n        for(int i = 0; i < n; ++i) {\n            ages[i] = primes[rnd.next(0, (int)primes.size() - 1)];\n        }\n    } else {\n        // Default to random\n        for(int i = 0; i < n; ++i) {\n            ages[i] = rnd.next(2, 10000);\n        }\n    }\n\n    // Output n\n    printf(\"%d\\n\", n);\n    for(int i = 0; i < n; ++i) {\n        printf(\"%d\", ages[i]);\n        if (i != n - 1)\n            printf(\" \");\n        else\n            printf(\"\\n\");\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 3 -type min\n./gen -n 3 -type max\n./gen -n 3 -type possible\n./gen -n 3 -type impossible\n./gen -n 3 -type even\n./gen -n 3 -type odd\n./gen -n 3 -type same_odd\n./gen -n 3 -type same_even\n./gen -n 3 -type alternate\n./gen -n 3 -type primes\n\n./gen -n 20 -type random\n./gen -n 20 -type even\n./gen -n 20 -type odd\n./gen -n 20 -type same_even\n./gen -n 20 -type same_odd\n./gen -n 20 -type alternate\n./gen -n 20 -type possible\n./gen -n 20 -type impossible\n./gen -n 20 -type primes\n\n./gen -n 50 -type reverse\n./gen -n 50 -type max\n./gen -n 50 -type min\n\n./gen -n 100 -type random\n./gen -n 100 -type primes\n\n./gen -n 200 -type random\n./gen -n 200 -type possible\n\n./gen -n 199 -type impossible\n./gen -n 198 -type possible\n./gen -n 197 -type primes\n\n./gen -n 200 -type same_even\n./gen -n 200 -type same_odd\n\n./gen -n 100 -type reverse\n./gen -n 100 -type alternate\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:41:49.258114",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "512/D",
      "title": "D. Лиса и путешествие",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест3 секунды",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеВ первой строке записано два целых числа: n, m (1 ≤ n ≤ 100, ), количество достопримечательностей и количество дорог.В каждой из следующих m строк записано по два целых числа, ai и bi (1 ≤ ai, bi ≤ n, ai ≠ bi), описывающих дорогу. Каждую пару достопримечательностей соединяет не более одной дороги.",
      "output_spec": "Выходные данныеВыведите n + 1 целых чисел: количество возможных маршрутов путешествия по модулю 109 + 9 для всех k от 0 до n.",
      "sample_tests": "ПримерыВходные данныеСкопировать3 21 22 3Выходные данныеСкопировать1244Входные данныеСкопировать4 41 22 33 44 1Выходные данныеСкопировать10000Входные данныеСкопировать12 112 34 74 55 64 66 125 125 88 910 811 9Выходные данныеСкопировать163113548313803060504050400000Входные данныеСкопировать13 0Выходные данныеСкопировать113156171617160154440123552086486405189184025945920037836791113510373227020746227020746",
      "description": "D. Лиса и путешествие\n\nограничение по времени на тест3 секунды\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвыводstdout\n\nВходные данныеВ первой строке записано два целых числа: n, m (1 ≤ n ≤ 100, ), количество достопримечательностей и количество дорог.В каждой из следующих m строк записано по два целых числа, ai и bi (1 ≤ ai, bi ≤ n, ai ≠ bi), описывающих дорогу. Каждую пару достопримечательностей соединяет не более одной дороги.\n\nВходные данные\n\nВыходные данныеВыведите n + 1 целых чисел: количество возможных маршрутов путешествия по модулю 109 + 9 для всех k от 0 до n.\n\nВыходные данные\n\nВходные данныеСкопировать3 21 22 3Выходные данныеСкопировать1244Входные данныеСкопировать4 41 22 33 44 1Выходные данныеСкопировать10000Входные данныеСкопировать12 112 34 74 55 64 66 125 125 88 910 811 9Выходные данныеСкопировать163113548313803060504050400000Входные данныеСкопировать13 0Выходные данныеСкопировать113156171617160154440123552086486405189184025945920037836791113510373227020746227020746\n\nВходные данныеСкопировать3 21 22 3\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать1244\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать4 41 22 33 44 1\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать10000\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать12 112 34 74 55 64 66 125 125 88 910 811 9\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать163113548313803060504050400000\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать13 0\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать113156171617160154440123552086486405189184025945920037836791113510373227020746227020746\n\nВыходные данныеСкопировать\n\nСкопировать\n\nПримечаниеВ первом тесте из условия для k = 3 существует 4 маршрута: {1, 2, 3}, {1, 3, 2}, {3, 1, 2}, {3, 2, 1}.Во втором тесте из условия Ciel не может начать ни с одной достопримечательности в первый же день, так что для k > 0 ответ равен 0.В третьем тесте из условия Фоксленды выглядят следующим образом:",
      "solutions": [
        {
          "title": "Codeforces Round #290 - Codeforces",
          "content": "Лиса Ciel возвращается!Все приглашаются поучаствовать в Codeforces Round #290, который начинается в обычное время в ближайший понедельник.Это мой четвёртый раунд на Codeforces, можете ознакомиться с моими предыдущими раундами: #190, #228, #270.Последний Div1-раунд (#286) оказался очень непростым, поэтому мы решили уменьшить сложность раунда (например, Div1-E превратилась в Div1-D). Надеюсь, это позволит большому количеству людей насладиться всеми задачами раунда: в этот раз ни одна задача не требует продвинутых знаний наподобие линейной алгебры или преобразования Фурье.Главным персонажем раунда будет Лиса Ciel и её жизнь: она учится программировать, играет, путешествует, принимает ужин, а также делает многое другое.Как и на раунде #228, топ-20 участников, присутствующих на зимних сборах в Петрозаводске, будут награждены футболочками Codeforces. Футболку может получить любой участник сборов, член жюри, тренер, организатор или любой другой человек, так или иначе присутствующий на сборах.Как обычно, спасибо Zlobober за ценные советы и помощь в подготовке моего раунда, и MikeMirzayanov за платформы Codeforces и Polygon.Удачи! Update1: Score Distribution is ... Div2: Standard (500 — 1000 — 1500 — 2000 — 2500), Div1: a bit unusual ... (500 — 1000 — 1500 — 2250 — 2250)Update2: Editorial: http://codeforces.com/blog/entry/16173Update3: Congratulation to our winners:Div1: Petr Endagorion mmaxio jqdai0815 tourist They are all people who solved 5 tasks!Div2: SkullSkin joshkirstein gabrielinelus UnknownNooby Andrey_WK",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/16147",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1530
        },
        {
          "title": "Codeforces Round #290 Editorial - Codeforces",
          "content": "Update 1 : here are the reference solutions for this contest: Div2-A: http://ideone.com/JP1Ksj DIv2-B: http://ideone.com/udz3bN Div2-C / Div1-A: http://ideone.com/KVobNb Div2-D / Div1-B: http://ideone.com/7MQqOm Div2-E / Div1-C: http://ideone.com/z3FsU2 Div1-D: http://ideone.com/Y7j21a Div1-E: http://ideone.com/Orbacp Note that for Div2-E / Div1-C, it is for the harder version: we need to handle '1' in the cycle.510A - Fox And SnakeThere are 2 different ways to solve this kind of task:First one is to simulate the movement of the snake head, and you draw '#'s on the board. The code will look like: head = (1, 1)\nrepeat:\n\trepeat m-1 times: head move to right\n\trepeat 2 times: head move down\n\trepeat 2 times: head move down\n\trepeat m-1 times: head move to left\n\trepeat 2 times: head move down\n\trepeat 2 times: head move down\nuntil head is out of the boardAnother way is to do some observation about the result, you can find this pattern: (4k+1) / (4k+3) line: \"#######\"\n(4k+2) line: \".......#\"\n(4k+0) line: \"#.......\"510B - Fox And Two DotsThis task is essentially ask if there is a cycle in an undirected graph: treat each cell as a node, and add an edge if two cells are neighborhood and have some color.There are lots of ways to do this, for example: Run dfs / bfs, if an edge lead you to a visited node, then there must be a cycle. For each connected component, test if |#edges| = |#nodes| - 1, if not then there must be a cycle. 510C - Fox And Names / 512A - Fox And NamesLet's first think about what S < T can tell us: suppose S = abcxyz and T = abcuv. Then we know that S < T if and only if x < u by the definition.So we can transform the conditions name1 < name2, name2 < name3 ... into the order of letters.Then the question become: do we have a permutation that satisfy those conditions. It is actually the classic topological order question.One trick in this task is that, if we have something like xy < x then there is no solution. This is not covered in pretests. :)510D - Fox And Jumping / 512B - Fox And JumpingThis task equals to: what is the minimal sum of costs that we can select k cards, so their GCD is 1.First observation is that: GCD(x1, x2, ..., xk) = 1 means that for any prime p, there exist i such that xi is not dividable by p. So we only care about what prime factors a number contain. (So for example, 12 -> {2, 3}, 6 -> {2, 3}, 9 -> {3]})The second observation is: If x ≤ 109 then it has at most 9 prime factors.So after we select one number, we only care about these 9 or less primes. Then this problem equals to set covering problem (SCP), it can be done by mask DP. It can run in about O(2^9 * n^2).510E - Fox And Dinner / 512C - Fox And DinnerFirst finding is: if a + b is a prime, then one of them is an odd number, another is an even number. (that's why we set 2 ≤ xi)Then we could find: every odd number have exactly 2 even number as neighborhood, and every even number have exactly 2 odd number as neighborhood. And that means we need |#even| = |#odd| to have a solution.So it looks like bipartite graph matching, but every element matched 2 elements. And in fact it can be handled by maxflow: For each odd number, we add a node on the left side and link it from source with capacity equals to 2, and for each even number, we add a node on the right side and link it to sink with capacity equals to 2. And if sum of two numbers is a prime number, we link them with capacity equals to 1.Then we solve the max flow, it have solution if and only if maxflow = 2 * |#even|.We can construct the answer(cycles) from the matches.Note: Actually this task is still solvable if we allow ai = 1. But you need some clever way to deal with it. We think it is too hard so we removed this case. What do you think about this decision?512D - Fox And TravellingWe could find that some nodes cannot be visited. And more specific, if one node is in a cycle then it cannot be visited. So what about the structure of nodes that we can visit?Let's first find a way to get all nodes that could be visited. We can deal with this by something like biconnected decomposition, but that is not easy to implement. In fact we can use this simple method: each time we pick one node that have at most 1 neighborhood and delete it. Repeat this process until we can't do it anymore.We could find these nodes are actually belonging to these 2 kinds: 1. A tree. 2. Rooted tree. (that means, the root is attached to a cycle)The rooted tree case is simple: we can solve it by tree DP. The state will be dp[i][j] = the way to remove j nodes in the subtree rooted at i.Then how to solve the unrooted tree case? The way to deal with that is to transform it into rooted case. We have 2 solution: We select one unvisited node as the root by some rules: for example, we select one with minimal index. Then we just need to modify the DP a bit to adjust this additional condition. We could find if the tree has n nodes and we visit k nodes in the end, then there will be max(1, n-k) ways to choose the root. That means if we choose every node as the root and sum up them, we will count this case exactly max(1, n-k) times. So we just do the rooted DP for from node n times, and divide max(1, n-k) for ans[k]. The overall complicity is O(n4), and it can be optimize into O(n3) if you like.512E - Fox And PolygonTriangulation of polygon is something hard to think about. So the first key observation is that, we can transform this task into operations on rooted trees!One Triangulation of polygon can be mapping to one rooted tree. And the flip operation can be mapping to the rotation of trees. (It is the operation we used to balance our BST) You can find the mapping from above picture. The red lines indicate the edge that will be flipped and the nodes we rotated.Then we should find a standard shape of the tree, and solve this task: how to rotate any tree into this standard shape?My solution is to choose the balanced tree as standard shape. The way to do that is this: find the node that the index is the middle number, rotate it to the top(that what we did for splay tree), and do the same thing for each subtree.It is easy to see it could work in O(nlogn) steps.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/16173",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 512\\s*D"
          },
          "content_length": 6165
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #290 - Codeforces - Code 1",
          "code": "26\na\nb\nc\n...\nz",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16147",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #290 - Codeforces - Code 2",
          "code": "26\na\nb\nc\n...\nz",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16147",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #290 Editorial - Codeforces - Code 1",
          "code": "head = (1, 1)\nrepeat:\n\trepeat m-1 times: head move to right\n\trepeat 2 times: head move down\n\trepeat 2 times: head move down\n\trepeat m-1 times: head move to left\n\trepeat 2 times: head move down\n\trepeat 2 times: head move down\nuntil head is out of the board",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16173",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #290 Editorial - Codeforces - Code 2",
          "code": "head = (1, 1)\nrepeat:\n\trepeat m-1 times: head move to right\n\trepeat 2 times: head move down\n\trepeat 2 times: head move down\n\trepeat m-1 times: head move to left\n\trepeat 2 times: head move down\n\trepeat 2 times: head move down\nuntil head is out of the board",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16173",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #290 Editorial - Codeforces - Code 3",
          "code": "(4k+1) / (4k+3) line: \"#######\"\n(4k+2) line: \".......#\"\n(4k+0) line: \"#.......\"",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16173",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #290 Editorial - Codeforces - Code 4",
          "code": "(4k+1) / (4k+3) line: \"#######\"\n(4k+2) line: \".......#\"\n(4k+0) line: \"#.......\"",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16173",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #290 Editorial - Codeforces - Code 5",
          "code": "for (i64 i = 0; i < n; i++) {\n    hepsi[ l[i] ] = c[i];\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16173",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #290 Editorial - Codeforces - Code 6",
          "code": "for (i64 i = 0; i < n; i++) {\n    hepsi[ l[i] ] = c[i];\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16173",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #290 Editorial - Codeforces - Code 7",
          "code": "hepsi[ 0 ] = 0;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16173",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #290 Editorial - Codeforces - Code 8",
          "code": "hepsi[ 0 ] = 0;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16173",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #290 Editorial - Codeforces - Code 9",
          "code": "s = primes.size();\n\nfor(int mask = 0; mask < (1<<s); mask++){\n\tdp[mask] = INF;\n}\n\t\t\ndp[m[i]] = c[i];\n\t\t\nfor(int mask = 0; mask < (1<<s); mask++){\n\tfor(int j = 0; j < n; j++){\n\t\tif(dp[mask] != INF)\n\t\t\tdp[mask | m[j]] = min(dp[mask | m[j]], dp[mask] + c[j]);\n\t}\n}\n\nans = min(ans, dp[(1<<s) - 1]);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16173",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #290 Editorial - Codeforces - Code 10",
          "code": "s = primes.size();\n\nfor(int mask = 0; mask < (1<<s); mask++){\n\tdp[mask] = INF;\n}\n\t\t\ndp[m[i]] = c[i];\n\t\t\nfor(int mask = 0; mask < (1<<s); mask++){\n\tfor(int j = 0; j < n; j++){\n\t\tif(dp[mask] != INF)\n\t\t\tdp[mask | m[j]] = min(dp[mask | m[j]], dp[mask] + c[j]);\n\t}\n}\n\nans = min(ans, dp[(1<<s) - 1]);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16173",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #290 Editorial - Codeforces - Code 11",
          "code": "3 3\nBAB\nAAA\nBAB",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16173",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #290 Editorial - Codeforces - Code 12",
          "code": "3 3\nBAB\nAAA\nBAB",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16173",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #290 Editorial - Codeforces - Code 13",
          "code": "#include<Stdio.h>",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/16173",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #290 Editorial - Codeforces - Code 14",
          "code": "dp[i][sz[i]] = dp[i][sz[i] - 1]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16173",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #290 Editorial - Codeforces - Code 15",
          "code": "dpValue dfs(int cur, int from)\n{\n\tdpValue ret;\n\tret.x[0] = 1;\n\tfor(int i = 0; i < e[cur].size(); i++)\n\t{\n\t\tint t = e[cur][i];\n\t\tif(t == from) continue;\n\t\tret = combine(ret, dfs(t, cur));\n\t}\n\tfor(int i = 0; i < MAXN; i++)\n\t\tif(ret.x[i] == 0)\n\t\t{\n\t\t\tret.x[i] = ret.x[i-1];\n\t\t\tbreak;\n\t\t}\n\treturn ret;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16173",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #290 Editorial - Codeforces - Code 16",
          "code": "dpValue dfs(int cur, int from)\n{\n\tdpValue ret;\n\tret.x[0] = 1;\n\tfor(int i = 0; i < e[cur].size(); i++)\n\t{\n\t\tint t = e[cur][i];\n\t\tif(t == from) continue;\n\t\tret = combine(ret, dfs(t, cur));\n\t}\n\tfor(int i = 0; i < MAXN; i++)\n\t\tif(ret.x[i] == 0)\n\t\t{\n\t\t\tret.x[i] = ret.x[i-1];\n\t\t\tbreak;\n\t\t}\n\treturn ret;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16173",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #290 Editorial - Codeforces - Code 17",
          "code": "dpValue combine(dpValue A, dpValue B)\n{\n\tdpValue ret;\n\tfor(int i = 0; i < MAXN; i++)\n\t\tfor(int j = 0; i+j < MAXN; j++)\n\t\t{\n\t\t\tret.x[i+j] += ((A.x[i] * B.x[j]) % mod) * C(i+j, i);\n\t\t\tret.x[i+j] %= mod;\n\t\t}\n\treturn ret;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16173",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #290 Editorial - Codeforces - Code 18",
          "code": "dpValue combine(dpValue A, dpValue B)\n{\n\tdpValue ret;\n\tfor(int i = 0; i < MAXN; i++)\n\t\tfor(int j = 0; i+j < MAXN; j++)\n\t\t{\n\t\t\tret.x[i+j] += ((A.x[i] * B.x[j]) % mod) * C(i+j, i);\n\t\t\tret.x[i+j] %= mod;\n\t\t}\n\treturn ret;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16173",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #290 Editorial - Codeforces - Code 19",
          "code": "4\n2 4 5 7\n1 1 1 1000000000",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16173",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #290 Editorial - Codeforces - Code 20",
          "code": "4\n2 4 5 7\n1 1 1 1000000000",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16173",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(0, n * (n - 1) / 2, \"m\");\n    inf.readEoln();\n\n    set<pair<int, int>> edges;\n    for (int i = 0; i < m; ++i) {\n        int a = inf.readInt(1, n, \"a_i\");\n        inf.readSpace();\n        int b = inf.readInt(1, n, \"b_i\");\n        inf.readEoln();\n        ensuref(a != b, \"Edge %d is a loop edge (%d to %d)\", i + 1, a, b);\n        int u = min(a, b);\n        int v = max(a, b);\n        auto edge = make_pair(u, v);\n        ensuref(edges.count(edge) == 0, \"Edge %d (%d,%d) is a duplicate of a previous edge\", i + 1, u, v);\n        edges.insert(edge);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(0, n * (n - 1) / 2, \"m\");\n    inf.readEoln();\n\n    set<pair<int, int>> edges;\n    for (int i = 0; i < m; ++i) {\n        int a = inf.readInt(1, n, \"a_i\");\n        inf.readSpace();\n        int b = inf.readInt(1, n, \"b_i\");\n        inf.readEoln();\n        ensuref(a != b, \"Edge %d is a loop edge (%d to %d)\", i + 1, a, b);\n        int u = min(a, b);\n        int v = max(a, b);\n        auto edge = make_pair(u, v);\n        ensuref(edges.count(edge) == 0, \"Edge %d (%d,%d) is a duplicate of a previous edge\", i + 1, u, v);\n        edges.insert(edge);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(0, n * (n - 1) / 2, \"m\");\n    inf.readEoln();\n\n    set<pair<int, int>> edges;\n    for (int i = 0; i < m; ++i) {\n        int a = inf.readInt(1, n, \"a_i\");\n        inf.readSpace();\n        int b = inf.readInt(1, n, \"b_i\");\n        inf.readEoln();\n        ensuref(a != b, \"Edge %d is a loop edge (%d to %d)\", i + 1, a, b);\n        int u = min(a, b);\n        int v = max(a, b);\n        auto edge = make_pair(u, v);\n        ensuref(edges.count(edge) == 0, \"Edge %d (%d,%d) is a duplicate of a previous edge\", i + 1, u, v);\n        edges.insert(edge);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n    int m = 0;\n    vector<pair<int, int>> edges;\n\n    if (type == \"path\") {\n        /* nodes connected in a path */\n        m = n - 1;\n        for (int i = 1; i < n; i++)\n            edges.push_back({i - 1, i});\n    } else if (type == \"star\") {\n        /* one central node connected to all other nodes */\n        m = n - 1;\n        for (int i = 1; i < n; i++)\n            edges.push_back({0, i});\n    } else if (type == \"cycle\") {\n        /* nodes connected in a cycle */\n        m = n;\n        for (int i = 0; i < n; i++)\n            edges.push_back({i, (i + 1) % n});\n    } else if (type == \"complete\") {\n        /* complete graph */\n        m = n * (n - 1) / 2;\n        for (int i = 0; i < n; i++)\n            for (int j = i + 1; j < n; j++)\n                edges.push_back({i, j});\n    } else if (type == \"tree\") {\n        /* generate a random tree */\n        m = n - 1;\n        vector<int> p(n);\n        for (int i = 1; i < n; i++)\n            p[i] = rnd.next(i);\n        for (int i = 1; i < n; i++)\n            edges.push_back({i, p[i]});\n    } else if (type == \"random\") {\n        /* generate a random graph */\n        int maxEdges = n * (n - 1) / 2;\n        int m_max = opt<int>(\"m\", rnd.next(0, maxEdges));\n        m = min(m_max, maxEdges);\n        set<pair<int, int>> edgeSet;\n        while ((int)edgeSet.size() < m) {\n            int u = rnd.next(0, n - 1);\n            int v = rnd.next(0, n - 1);\n            if (u == v) continue;\n            if (u > v) swap(u, v);\n            if (edgeSet.count({u, v})) continue;\n            edgeSet.insert({u, v});\n            edges.push_back({u, v});\n        }\n    } else {\n        cerr << \"Unknown type: \" << type << endl;\n        return 1;\n    }\n\n    /* shuffle vertices */\n    vector<int> perm(n);\n    for (int i = 0; i < n; ++i)\n        perm[i] = i;\n    shuffle(perm.begin(), perm.end());\n\n    /* adjust edges according to the shuffled vertices */\n    for (auto& edge : edges) {\n        edge.first = perm[edge.first];\n        edge.second = perm[edge.second];\n    }\n\n    /* shuffle edges */\n    shuffle(edges.begin(), edges.end());\n\n    /* output n and m */\n    printf(\"%d %d\\n\", n, m);\n\n    /* output edges */\n    for (auto& edge : edges)\n        printf(\"%d %d\\n\", edge.first + 1, edge.second + 1);\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n    int m = 0;\n    vector<pair<int, int>> edges;\n\n    if (type == \"path\") {\n        /* nodes connected in a path */\n        m = n - 1;\n        for (int i = 1; i < n; i++)\n            edges.push_back({i - 1, i});\n    } else if (type == \"star\") {\n        /* one central node connected to all other nodes */\n        m = n - 1;\n        for (int i = 1; i < n; i++)\n            edges.push_back({0, i});\n    } else if (type == \"cycle\") {\n        /* nodes connected in a cycle */\n        m = n;\n        for (int i = 0; i < n; i++)\n            edges.push_back({i, (i + 1) % n});\n    } else if (type == \"complete\") {\n        /* complete graph */\n        m = n * (n - 1) / 2;\n        for (int i = 0; i < n; i++)\n            for (int j = i + 1; j < n; j++)\n                edges.push_back({i, j});\n    } else if (type == \"tree\") {\n        /* generate a random tree */\n        m = n - 1;\n        vector<int> p(n);\n        for (int i = 1; i < n; i++)\n            p[i] = rnd.next(i);\n        for (int i = 1; i < n; i++)\n            edges.push_back({i, p[i]});\n    } else if (type == \"random\") {\n        /* generate a random graph */\n        int maxEdges = n * (n - 1) / 2;\n        int m_max = opt<int>(\"m\", rnd.next(0, maxEdges));\n        m = min(m_max, maxEdges);\n        set<pair<int, int>> edgeSet;\n        while ((int)edgeSet.size() < m) {\n            int u = rnd.next(0, n - 1);\n            int v = rnd.next(0, n - 1);\n            if (u == v) continue;\n            if (u > v) swap(u, v);\n            if (edgeSet.count({u, v})) continue;\n            edgeSet.insert({u, v});\n            edges.push_back({u, v});\n        }\n    } else {\n        cerr << \"Unknown type: \" << type << endl;\n        return 1;\n    }\n\n    /* shuffle vertices */\n    vector<int> perm(n);\n    for (int i = 0; i < n; ++i)\n        perm[i] = i;\n    shuffle(perm.begin(), perm.end());\n\n    /* adjust edges according to the shuffled vertices */\n    for (auto& edge : edges) {\n        edge.first = perm[edge.first];\n        edge.second = perm[edge.second];\n    }\n\n    /* shuffle edges */\n    shuffle(edges.begin(), edges.end());\n\n    /* output n and m */\n    printf(\"%d %d\\n\", n, m);\n\n    /* output edges */\n    for (auto& edge : edges)\n        printf(\"%d %d\\n\", edge.first + 1, edge.second + 1);\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -type path\n./gen -n 1 -type star\n./gen -n 1 -type cycle\n./gen -n 1 -type complete\n./gen -n 1 -type tree\n./gen -n 1 -type random\n\n./gen -n 2 -type path\n./gen -n 2 -type star\n./gen -n 2 -type cycle\n./gen -n 2 -type complete\n./gen -n 2 -type tree\n./gen -n 2 -type random\n\n./gen -n 3 -type path\n./gen -n 3 -type star\n./gen -n 3 -type cycle\n./gen -n 3 -type complete\n./gen -n 3 -type tree\n./gen -n 3 -type random\n\n./gen -n 4 -type cycle  # Similar to the second sample input\n./gen -n 13 -type random -m 0  # Similar to the fourth sample input\n\n./gen -n 10 -type path\n./gen -n 10 -type star\n./gen -n 10 -type cycle\n./gen -n 10 -type complete\n./gen -n 10 -type tree\n./gen -n 10 -type random\n\n./gen -n 50 -type path\n./gen -n 50 -type star\n./gen -n 50 -type cycle\n./gen -n 50 -type complete\n./gen -n 50 -type tree\n./gen -n 50 -type random -m 0\n./gen -n 50 -type random -m 1225  # Max edges for n = 50\n./gen -n 50 -type random -m 50\n\n./gen -n 100 -type path\n./gen -n 100 -type star\n./gen -n 100 -type cycle\n./gen -n 100 -type complete\n./gen -n 100 -type tree\n./gen -n 100 -type random\n\n./gen -n 100 -type random -m 0  # Disconnected graph with no edges\n./gen -n 100 -type random -m 4950  # Complete graph\n\n# Test cases with varying m\n./gen -n 100 -type random -m 1000\n./gen -n 100 -type random -m 2000\n./gen -n 100 -type random -m 3000\n./gen -n 100 -type random -m 4000\n\n# Edge cases\n./gen -n 1 -type random\n./gen -n 100 -type random -m 1  # Sparse graph\n./gen -n 100 -type random -m 99  # Tree-like graph with n - 1 edges\n./gen -n 100 -type random -m 5000  # Dense graph but not complete\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:41:50.945857",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    }
  ]
}