{
  "metadata": {
    "batch_number": 32,
    "total_batches": 73,
    "problems_in_batch": 100,
    "total_problems": 7261,
    "created_at": "2025-08-28T22:04:41.177013",
    "format": "wenjiajia_v1.0"
  },
  "problems": [
    {
      "problem_id": "199/B",
      "title": "B. Special Olympics",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe input contains two lines. Each line has four space-separated integers xi, yi, ri, Ri, that describe the i-th ring; xi and yi are coordinates of the ring's center, ri and Ri are the internal and external radii of the ring correspondingly ( - 100 ≤ xi, yi ≤ 100; 1 ≤ ri < Ri ≤ 100). It is guaranteed that the centers of the rings do not coinside.",
      "output_spec": "OutputA single integer — the number of ways to cut out a circle from the canvas.",
      "sample_tests": "ExamplesInputCopy60 60 45 5580 80 8 32OutputCopy1InputCopy60 60 45 5580 60 15 25OutputCopy4InputCopy50 50 35 4590 50 35 45OutputCopy0",
      "description": "B. Special Olympics\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe input contains two lines. Each line has four space-separated integers xi, yi, ri, Ri, that describe the i-th ring; xi and yi are coordinates of the ring's center, ri and Ri are the internal and external radii of the ring correspondingly ( - 100 ≤ xi, yi ≤ 100; 1 ≤ ri < Ri ≤ 100). It is guaranteed that the centers of the rings do not coinside.\n\nOutputA single integer — the number of ways to cut out a circle from the canvas.\n\nInputCopy60 60 45 5580 80 8 32OutputCopy1InputCopy60 60 45 5580 60 15 25OutputCopy4InputCopy50 50 35 4590 50 35 45OutputCopy0\n\nInputCopy60 60 45 5580 80 8 32\n\nOutputCopy1\n\nInputCopy60 60 45 5580 60 15 25\n\nOutputCopy4\n\nInputCopy50 50 35 4590 50 35 45\n\nOutputCopy0\n\nNoteFigures for test samples are given below. The possible cuts are marked with red dotted line.",
      "solutions": [
        {
          "title": "Codeforces Round #125 - Codeforces",
          "content": "Hello everyone!There is yet another Codeforces round. Now it is the 53-th one.The round will run for both divisions by classic rules of Codeforces format.Points are standard: 500-1000-1500-2000-2500.Round was prepared by Ripatti , Alex_KPR , Gerald , Aksenov239 , RAD , Delinur .Good luck!UPD. Round is ended.Winners of div1:1. Petr2. tourist3. SergeyRogulenko4. bmerry5. UESTC_Nocturne Winners of div2:1. gflegar2. mylyanyk.ivan3. arbesfeld Petr is only who solved all 5 problems in the first division. No one solved all 5 problems in the second division.UPD. Editorial.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/4757",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 571
        },
        {
          "title": "Solutions for Codeforces Round #125 - Codeforces",
          "content": "Div2 A. You can just output \"0 0 n\". Author is Alex_KPR . Div2 B. You should check for every circle of one ring: it have intersections with another ring or not. So, there are 4 checks. There are 2 cases:1. circle is inside of ring;2. circle is outside of ring and ring is outside of circle;3. circle is outside of ring and ring is inside of circle.If at least one of these cases is performed, circle is good.You can easily do checks following way. Let us d be a distance between centers of ring and circle, r1 and R1 are inside and outside radii of ring, r be radius of circle. Then conditions for all cases will be1. d + r ≤ r1.2. r + R1 ≤ d.3. d + R1 ≤ r.You can check all conditions in integers using squares of distances. Author is Alex_KPR Div2 C. Div1 A.The first solution. Consider sequence a0 = 1, ai = ai - 1k + b:a0, a1, a2, ..., an = z.You can see that for all numbers from segment [a0, a1 - 1] you can number not less than z using exactly n steps. But for n - 1 steps you will bet number less than z. It works because transformation is monotonous. Analogically, for numbers from segments [a1, a2 - 1], [a2, a3 - 1], etc, you need exactly n - 1, n - 2, etc steps. So you just need find segment that contains number t. You can do it by generate a few first members of the sequence a. You need no more than t members. The second solution. Equation:tkx + b(kx - 1 + kx - 2... + 1) ≥ kn + b(kx - 1 + kx - 2... + 1)Using formula for geometric progression you can get:For k ≠ 1 we can multiply both sides by k - 1, (you can consider case k = 1 by yourself).t(k - 1)kx + bkx - b ≥ (k - 1)kn + bkn - b kx(t(k - 1) + b) ≥ kn(k - 1 + b) So, you can find value n - x using simply raising to a power.Authors are Gerald and RipattiDiv2 D. Div1 B. You should construct graph where vertices are areas of walls and edges are actions of ninja. Then you should run BFS with one modification: is you reach vertex later then water, you shouldn't do moves from this vertex.It is solution in O(n).Author is RipattiDiv2 E. Div1 C. If you can reach the planet in time t, you also can reach one in any time greater then t (you can just reach planet in time t and then move along with planet). There exists some t0 for that for all t > t0 you can reach planet, and for all t < t0 you cannot do in. Let us find t0 using binary search.Checking every of t inside of binary search you can do following way. You should calculate place if planet after time t and find distance between ship's place and new planet place.So, you have following \"classic\" problem: there are two points A and B and circle with center in O and radius R (points are outside of circle), you need find distance between points and you cannot moving inside of circle.There are 2 cases:1. You can move direct way2. You should skirt the circle The second case is performed iff two following conditions are performed:a. Angles OAB and OBA are acuteb. Height OH of triangle OAB less than RAll checks you can do in integers.Well, let's understand how to precess our cases:1. Obviously2. Let us C and D be tangency points (i.e. you are moving along line ACDB). Thiangles OAC and OBD are right and you can easily calculate all angles inside of them. Then you should find angle COD. After that you can find length of line ACDB. You can see that you don't need find places of points C and D.Author is RipattiDiv1 D. We will construct solution recursively. For every k it is possible construct parallelepiped k × k × (k + 1) that contains 2 cubes k × k × k. For k = 2 solution is obliviousо. How to build solutions for k > 2 is shown in following picture:Red and blue cubes are start and end of chain. Firstly you should build one floor over. Then you should build 2 layers on two opposite sides.For every n you can build parallelepiped n × n × (n + 1), and drop one layer for getting cube n × n × n.Author is RipattiDiv1 E. You can allocate all grippers as points on plane with coordinates (distance, mass). So, when you use some gripper, you are collecting grippers inside some rectangle with corner in origin. Let us collect grippers and put them into queue. For current gripper you should take all grippers from rectangle and store them into queue. Then you should take next gripper from queue and do some manipulations with them and so on. Well, now you need do it fast.Let us create segment tree (for example, there you can use Fenwick tree) for dimention \"distance\". In every vertex of that tree you should store stack of points ordered by \"mass\". More details: every vertex of segment tree is some range of coordinates, and you should store in thet vertex points only from this range. At the top of every stack should be point with minimal mass. Well, let us put all points into tree. Every position is covered by no more thenм segmetns, therefore all tree will require of memory.When you process query, you should extract points from some stacks and put them into queue. You can see that you may put some points into queue twice. To avoid this you should also put number of point into stack. So, when you are extracting point from stack you can check that it is the first extract using some array of flags.This solution works in .Author is Ripatti ; the above solution was proposed by RAD",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/4764",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 5239
        }
      ],
      "code_examples": [
        {
          "title": "Solutions for Codeforces Round #125 - Codeforces - Code 1",
          "code": "The input contains of a single integer n (0 ≤ n < 10^9) — the number that should be represented by the rules described above. It is guaranteed that n is a Fibonacci number.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4764",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    \n    // Read first ring\n    int xi1 = inf.readInt(-100, 100, \"x1\");\n    inf.readSpace();\n    int yi1 = inf.readInt(-100, 100, \"y1\");\n    inf.readSpace();\n    int ri1 = inf.readInt(1, 100, \"r1\");\n    inf.readSpace();\n    int Ri1 = inf.readInt(1, 100, \"R1\");\n    inf.readEoln();\n    \n    // Read second ring\n    int xi2 = inf.readInt(-100, 100, \"x2\");\n    inf.readSpace();\n    int yi2 = inf.readInt(-100, 100, \"y2\");\n    inf.readSpace();\n    int ri2 = inf.readInt(1, 100, \"r2\");\n    inf.readSpace();\n    int Ri2 = inf.readInt(1, 100, \"R2\");\n    inf.readEoln();\n    \n    // Check that ri < Ri for both rings\n    ensuref(ri1 < Ri1, \"Ring 1 must satisfy r1 < R1, but got r1=%d, R1=%d\", ri1, Ri1);\n    ensuref(ri2 < Ri2, \"Ring 2 must satisfy r2 < R2, but got r2=%d, R2=%d\", ri2, Ri2);\n    \n    // Check that the centers do not coincide\n    ensuref(!(xi1 == xi2 && yi1 == yi2), \"The centers of the rings coincide at (%d, %d)\", xi1, yi1);\n    \n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    \n    // Read first ring\n    int xi1 = inf.readInt(-100, 100, \"x1\");\n    inf.readSpace();\n    int yi1 = inf.readInt(-100, 100, \"y1\");\n    inf.readSpace();\n    int ri1 = inf.readInt(1, 100, \"r1\");\n    inf.readSpace();\n    int Ri1 = inf.readInt(1, 100, \"R1\");\n    inf.readEoln();\n    \n    // Read second ring\n    int xi2 = inf.readInt(-100, 100, \"x2\");\n    inf.readSpace();\n    int yi2 = inf.readInt(-100, 100, \"y2\");\n    inf.readSpace();\n    int ri2 = inf.readInt(1, 100, \"r2\");\n    inf.readSpace();\n    int Ri2 = inf.readInt(1, 100, \"R2\");\n    inf.readEoln();\n    \n    // Check that ri < Ri for both rings\n    ensuref(ri1 < Ri1, \"Ring 1 must satisfy r1 < R1, but got r1=%d, R1=%d\", ri1, Ri1);\n    ensuref(ri2 < Ri2, \"Ring 2 must satisfy r2 < R2, but got r2=%d, R2=%d\", ri2, Ri2);\n    \n    // Check that the centers do not coincide\n    ensuref(!(xi1 == xi2 && yi1 == yi2), \"The centers of the rings coincide at (%d, %d)\", xi1, yi1);\n    \n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    \n    // Read first ring\n    int xi1 = inf.readInt(-100, 100, \"x1\");\n    inf.readSpace();\n    int yi1 = inf.readInt(-100, 100, \"y1\");\n    inf.readSpace();\n    int ri1 = inf.readInt(1, 100, \"r1\");\n    inf.readSpace();\n    int Ri1 = inf.readInt(1, 100, \"R1\");\n    inf.readEoln();\n    \n    // Read second ring\n    int xi2 = inf.readInt(-100, 100, \"x2\");\n    inf.readSpace();\n    int yi2 = inf.readInt(-100, 100, \"y2\");\n    inf.readSpace();\n    int ri2 = inf.readInt(1, 100, \"r2\");\n    inf.readSpace();\n    int Ri2 = inf.readInt(1, 100, \"R2\");\n    inf.readEoln();\n    \n    // Check that ri < Ri for both rings\n    ensuref(ri1 < Ri1, \"Ring 1 must satisfy r1 < R1, but got r1=%d, R1=%d\", ri1, Ri1);\n    ensuref(ri2 < Ri2, \"Ring 2 must satisfy r2 < R2, but got r2=%d, R2=%d\", ri2, Ri2);\n    \n    // Check that the centers do not coincide\n    ensuref(!(xi1 == xi2 && yi1 == yi2), \"The centers of the rings coincide at (%d, %d)\", xi1, yi1);\n    \n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\n// Function to generate random integer in range [l, r]\nint randInt(int l, int r) {\n    return rnd.next(l, r);\n}\n\n// Function to generate random double in range [l, r)\ndouble randDouble(double l, double r) {\n    return rnd.next(l, r);\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    string pattern = opt<string>(\"pattern\", \"random\");\n    int scale = opt<int>(\"scale\", 100);\n\n    int x1, y1, r1, R1;\n    int x2, y2, r2, R2;\n\n    // Ensure that positions are within [-100, 100]\n    int pos_min = -100;\n    int pos_max = 100;\n\n    // Ensure that radii are within [1, 100]\n\n    if (pattern == \"nonoverlapping\") {\n        // Generate two rings that are far apart\n\n        // Generate random radii\n        r1 = randInt(1, 50);\n        R1 = randInt(r1+1, 100);\n\n        r2 = randInt(1, 50);\n        R2 = randInt(r2+1, 100);\n\n        // Maximum possible radius sum\n        int max_R = R1 + R2;\n\n        // Generate positions such that distance between centers > R1 + R2\n\n        // Choose x1, y1 randomly\n        x1 = randInt(pos_min + R1, pos_max - R1);\n        y1 = randInt(pos_min + R1, pos_max - R1);\n\n        // Now choose x2, y2 such that distance between centers > R1 + R2\n\n        int safe_distance = R1 + R2 + randInt(10, 20); // Ensure some margin\n\n        // Generate random angle\n        double angle = randDouble(0, 2*M_PI);\n\n        // Compute displacement\n        double dx = safe_distance * cos(angle);\n        double dy = safe_distance * sin(angle);\n\n        x2 = x1 + (int)round(dx);\n        y2 = y1 + (int)round(dy);\n\n        // Adjust if out of bounds\n        if (x2 < pos_min + R2) x2 = pos_min + R2;\n        if (x2 > pos_max - R2) x2 = pos_max - R2;\n        if (y2 < pos_min + R2) y2 = pos_min + R2;\n        if (y2 > pos_max - R2) y2 = pos_max - R2;\n\n    } else if (pattern == \"overlapping\") {\n        // Generate two rings that overlap partially\n\n        // Generate random radii\n        r1 = randInt(30, 70);\n        R1 = randInt(r1+1, 100);\n\n        r2 = randInt(30, 70);\n        R2 = randInt(r2+1, 100);\n\n        // Distance between centers less than R1 + R2 and greater than abs(R1 - R2)\n        int min_distance = abs(R1 - R2) + 5;\n        int max_distance = R1 + R2 - 5;\n\n        int distance_between_centers = randInt(min_distance, max_distance);\n\n        // Generate random angle\n        double angle = randDouble(0, 2*M_PI);\n\n        // Choose x1, y1 randomly\n        x1 = randInt(pos_min + R1, pos_max - R1);\n        y1 = randInt(pos_min + R1, pos_max - R1);\n\n        // Compute displacement\n        double dx = distance_between_centers * cos(angle);\n        double dy = distance_between_centers * sin(angle);\n\n        x2 = x1 + (int)round(dx);\n        y2 = y1 + (int)round(dy);\n\n        // Adjust x2, y2 if out of bounds\n        if (x2 < pos_min + R2) x2 = pos_min + R2;\n        if (x2 > pos_max - R2) x2 = pos_max - R2;\n        if (y2 < pos_min + R2) y2 = pos_min + R2;\n        if (y2 > pos_max - R2) y2 = pos_max - R2;\n\n    } else if (pattern == \"touching\") {\n        // Generate two rings touching externally\n\n        // Generate random radii\n        r1 = randInt(10, 50);\n        R1 = randInt(r1+1, 100);\n\n        r2 = randInt(10, 50);\n        R2 = randInt(r2+1, 100);\n\n        // Distance between centers equals R1 + R2\n        int distance_between_centers = R1 + R2;\n\n        // Generate random angle\n        double angle = randDouble(0, 2*M_PI);\n\n        // Choose x1, y1 randomly\n        x1 = randInt(pos_min + R1, pos_max - R1);\n        y1 = randInt(pos_min + R1, pos_max - R1);\n\n        // Compute displacement\n        double dx = distance_between_centers * cos(angle);\n        double dy = distance_between_centers * sin(angle);\n\n        x2 = x1 + (int)round(dx);\n        y2 = y1 + (int)round(dy);\n\n        // Adjust x2, y2 if out of bounds\n        if (x2 < pos_min + R2) x2 = pos_min + R2;\n        if (x2 > pos_max - R2) x2 = pos_max - R2;\n        if (y2 < pos_min + R2) y2 = pos_min + R2;\n        if (y2 > pos_max - R2) y2 = pos_max - R2;\n\n    } else if (pattern == \"nested\") {\n        // One ring entirely within another\n\n        // Generate radii where R2 < r1\n        r1 = randInt(50, 70); // Outer ring\n        R1 = randInt(r1+1, 100);\n\n        R2 = randInt(1, r1 - 1);\n        r2 = randInt(1, R2 - 1);\n\n        // Place x1, y1 randomly\n        x1 = randInt(pos_min + R1, pos_max - R1);\n        y1 = randInt(pos_min + R1, pos_max - R1);\n\n        // Place x2, y2 close to x1, y1 but not the same\n        int offset = randInt(1, 5); // Ensure centers are different\n        x2 = x1 + offset;\n        y2 = y1;\n\n    } else if (pattern == \"tangent_internal\") {\n        // One ring inside another, touching internally\n\n        // Generate radii where R2 = r1\n\n        r1 = randInt(50, 90);\n        R1 = randInt(r1+1, 100);\n\n        R2 = r1;\n        r2 = randInt(1, R2 - 1);\n\n        // Place centers at minimal offset\n        x1 = randInt(pos_min + R1, pos_max - R1);\n        y1 = randInt(pos_min + R1, pos_max - R1);\n\n        int offset = 1; // minimal offset to avoid coincidence\n        x2 = x1 + offset;\n        y2 = y1;\n\n    } else if (pattern == \"tangent_external\") {\n        // Two rings touching externally\n\n        // Generate random radii\n        r1 = randInt(10, 50);\n        R1 = randInt(r1+1, 100);\n\n        r2 = randInt(10, 50);\n        R2 = randInt(r2+1, 100);\n\n        // Distance between centers equals R1 + R2\n\n        int distance_between_centers = R1 + R2;\n\n        // Generate random angle\n        double angle = randDouble(0, 2*M_PI);\n\n        // Choose x1, y1 randomly\n        x1 = randInt(pos_min + R1, pos_max - R1);\n        y1 = randInt(pos_min + R1, pos_max - R1);\n\n        // Compute displacement\n        double dx = distance_between_centers * cos(angle);\n        double dy = distance_between_centers * sin(angle);\n\n        x2 = x1 + (int)round(dx);\n        y2 = y1 + (int)round(dy);\n\n        // Adjust x2, y2 if out of bounds\n        if (x2 < pos_min + R2) x2 = pos_min + R2;\n        if (x2 > pos_max - R2) x2 = pos_max - R2;\n        if (y2 < pos_min + R2) y2 = pos_min + R2;\n        if (y2 > pos_max - R2) y2 = pos_max - R2;\n\n    } else {\n        // Default case: random rings\n\n        r1 = randInt(1, 99);\n        R1 = randInt(r1 + 1, 100);\n        r2 = randInt(1, 99);\n        R2 = randInt(r2 + 1, 100);\n\n        // Random positions\n        x1 = randInt(pos_min + R1, pos_max - R1);\n        y1 = randInt(pos_min + R1, pos_max - R1);\n\n        x2 = randInt(pos_min + R2, pos_max - R2);\n        y2 = randInt(pos_min + R2, pos_max - R2);\n\n        // Ensure centers do not coincide\n        while (x1 == x2 && y1 == y2) {\n            x2 = randInt(pos_min + R2, pos_max - R2);\n            y2 = randInt(pos_min + R2, pos_max - R2);\n        }\n    }\n\n    // Ensure centers do not coincide\n    if (x1 == x2 && y1 == y2) {\n        x2 += 1;\n        if (x2 > pos_max - R2) {\n            x2 = pos_min + R2;\n        }\n    }\n\n    // Output the two rings\n    printf(\"%d %d %d %d\\n\", x1, y1, r1, R1);\n    printf(\"%d %d %d %d\\n\", x2, y2, r2, R2);\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\n// Function to generate random integer in range [l, r]\nint randInt(int l, int r) {\n    return rnd.next(l, r);\n}\n\n// Function to generate random double in range [l, r)\ndouble randDouble(double l, double r) {\n    return rnd.next(l, r);\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    string pattern = opt<string>(\"pattern\", \"random\");\n    int scale = opt<int>(\"scale\", 100);\n\n    int x1, y1, r1, R1;\n    int x2, y2, r2, R2;\n\n    // Ensure that positions are within [-100, 100]\n    int pos_min = -100;\n    int pos_max = 100;\n\n    // Ensure that radii are within [1, 100]\n\n    if (pattern == \"nonoverlapping\") {\n        // Generate two rings that are far apart\n\n        // Generate random radii\n        r1 = randInt(1, 50);\n        R1 = randInt(r1+1, 100);\n\n        r2 = randInt(1, 50);\n        R2 = randInt(r2+1, 100);\n\n        // Maximum possible radius sum\n        int max_R = R1 + R2;\n\n        // Generate positions such that distance between centers > R1 + R2\n\n        // Choose x1, y1 randomly\n        x1 = randInt(pos_min + R1, pos_max - R1);\n        y1 = randInt(pos_min + R1, pos_max - R1);\n\n        // Now choose x2, y2 such that distance between centers > R1 + R2\n\n        int safe_distance = R1 + R2 + randInt(10, 20); // Ensure some margin\n\n        // Generate random angle\n        double angle = randDouble(0, 2*M_PI);\n\n        // Compute displacement\n        double dx = safe_distance * cos(angle);\n        double dy = safe_distance * sin(angle);\n\n        x2 = x1 + (int)round(dx);\n        y2 = y1 + (int)round(dy);\n\n        // Adjust if out of bounds\n        if (x2 < pos_min + R2) x2 = pos_min + R2;\n        if (x2 > pos_max - R2) x2 = pos_max - R2;\n        if (y2 < pos_min + R2) y2 = pos_min + R2;\n        if (y2 > pos_max - R2) y2 = pos_max - R2;\n\n    } else if (pattern == \"overlapping\") {\n        // Generate two rings that overlap partially\n\n        // Generate random radii\n        r1 = randInt(30, 70);\n        R1 = randInt(r1+1, 100);\n\n        r2 = randInt(30, 70);\n        R2 = randInt(r2+1, 100);\n\n        // Distance between centers less than R1 + R2 and greater than abs(R1 - R2)\n        int min_distance = abs(R1 - R2) + 5;\n        int max_distance = R1 + R2 - 5;\n\n        int distance_between_centers = randInt(min_distance, max_distance);\n\n        // Generate random angle\n        double angle = randDouble(0, 2*M_PI);\n\n        // Choose x1, y1 randomly\n        x1 = randInt(pos_min + R1, pos_max - R1);\n        y1 = randInt(pos_min + R1, pos_max - R1);\n\n        // Compute displacement\n        double dx = distance_between_centers * cos(angle);\n        double dy = distance_between_centers * sin(angle);\n\n        x2 = x1 + (int)round(dx);\n        y2 = y1 + (int)round(dy);\n\n        // Adjust x2, y2 if out of bounds\n        if (x2 < pos_min + R2) x2 = pos_min + R2;\n        if (x2 > pos_max - R2) x2 = pos_max - R2;\n        if (y2 < pos_min + R2) y2 = pos_min + R2;\n        if (y2 > pos_max - R2) y2 = pos_max - R2;\n\n    } else if (pattern == \"touching\") {\n        // Generate two rings touching externally\n\n        // Generate random radii\n        r1 = randInt(10, 50);\n        R1 = randInt(r1+1, 100);\n\n        r2 = randInt(10, 50);\n        R2 = randInt(r2+1, 100);\n\n        // Distance between centers equals R1 + R2\n        int distance_between_centers = R1 + R2;\n\n        // Generate random angle\n        double angle = randDouble(0, 2*M_PI);\n\n        // Choose x1, y1 randomly\n        x1 = randInt(pos_min + R1, pos_max - R1);\n        y1 = randInt(pos_min + R1, pos_max - R1);\n\n        // Compute displacement\n        double dx = distance_between_centers * cos(angle);\n        double dy = distance_between_centers * sin(angle);\n\n        x2 = x1 + (int)round(dx);\n        y2 = y1 + (int)round(dy);\n\n        // Adjust x2, y2 if out of bounds\n        if (x2 < pos_min + R2) x2 = pos_min + R2;\n        if (x2 > pos_max - R2) x2 = pos_max - R2;\n        if (y2 < pos_min + R2) y2 = pos_min + R2;\n        if (y2 > pos_max - R2) y2 = pos_max - R2;\n\n    } else if (pattern == \"nested\") {\n        // One ring entirely within another\n\n        // Generate radii where R2 < r1\n        r1 = randInt(50, 70); // Outer ring\n        R1 = randInt(r1+1, 100);\n\n        R2 = randInt(1, r1 - 1);\n        r2 = randInt(1, R2 - 1);\n\n        // Place x1, y1 randomly\n        x1 = randInt(pos_min + R1, pos_max - R1);\n        y1 = randInt(pos_min + R1, pos_max - R1);\n\n        // Place x2, y2 close to x1, y1 but not the same\n        int offset = randInt(1, 5); // Ensure centers are different\n        x2 = x1 + offset;\n        y2 = y1;\n\n    } else if (pattern == \"tangent_internal\") {\n        // One ring inside another, touching internally\n\n        // Generate radii where R2 = r1\n\n        r1 = randInt(50, 90);\n        R1 = randInt(r1+1, 100);\n\n        R2 = r1;\n        r2 = randInt(1, R2 - 1);\n\n        // Place centers at minimal offset\n        x1 = randInt(pos_min + R1, pos_max - R1);\n        y1 = randInt(pos_min + R1, pos_max - R1);\n\n        int offset = 1; // minimal offset to avoid coincidence\n        x2 = x1 + offset;\n        y2 = y1;\n\n    } else if (pattern == \"tangent_external\") {\n        // Two rings touching externally\n\n        // Generate random radii\n        r1 = randInt(10, 50);\n        R1 = randInt(r1+1, 100);\n\n        r2 = randInt(10, 50);\n        R2 = randInt(r2+1, 100);\n\n        // Distance between centers equals R1 + R2\n\n        int distance_between_centers = R1 + R2;\n\n        // Generate random angle\n        double angle = randDouble(0, 2*M_PI);\n\n        // Choose x1, y1 randomly\n        x1 = randInt(pos_min + R1, pos_max - R1);\n        y1 = randInt(pos_min + R1, pos_max - R1);\n\n        // Compute displacement\n        double dx = distance_between_centers * cos(angle);\n        double dy = distance_between_centers * sin(angle);\n\n        x2 = x1 + (int)round(dx);\n        y2 = y1 + (int)round(dy);\n\n        // Adjust x2, y2 if out of bounds\n        if (x2 < pos_min + R2) x2 = pos_min + R2;\n        if (x2 > pos_max - R2) x2 = pos_max - R2;\n        if (y2 < pos_min + R2) y2 = pos_min + R2;\n        if (y2 > pos_max - R2) y2 = pos_max - R2;\n\n    } else {\n        // Default case: random rings\n\n        r1 = randInt(1, 99);\n        R1 = randInt(r1 + 1, 100);\n        r2 = randInt(1, 99);\n        R2 = randInt(r2 + 1, 100);\n\n        // Random positions\n        x1 = randInt(pos_min + R1, pos_max - R1);\n        y1 = randInt(pos_min + R1, pos_max - R1);\n\n        x2 = randInt(pos_min + R2, pos_max - R2);\n        y2 = randInt(pos_min + R2, pos_max - R2);\n\n        // Ensure centers do not coincide\n        while (x1 == x2 && y1 == y2) {\n            x2 = randInt(pos_min + R2, pos_max - R2);\n            y2 = randInt(pos_min + R2, pos_max - R2);\n        }\n    }\n\n    // Ensure centers do not coincide\n    if (x1 == x2 && y1 == y2) {\n        x2 += 1;\n        if (x2 > pos_max - R2) {\n            x2 = pos_min + R2;\n        }\n    }\n\n    // Output the two rings\n    printf(\"%d %d %d %d\\n\", x1, y1, r1, R1);\n    printf(\"%d %d %d %d\\n\", x2, y2, r2, R2);\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Non-overlapping rings\n./gen -pattern nonoverlapping\n./gen -pattern nonoverlapping\n./gen -pattern nonoverlapping\n\n# Overlapping rings\n./gen -pattern overlapping\n./gen -pattern overlapping\n./gen -pattern overlapping\n\n# Touching rings externally\n./gen -pattern touching\n./gen -pattern touching\n\n# Nested rings\n./gen -pattern nested\n./gen -pattern nested\n\n# Tangent rings internally\n./gen -pattern tangent_internal\n./gen -pattern tangent_internal\n\n# Tangent rings externally\n./gen -pattern tangent_external\n./gen -pattern tangent_external\n\n# Random rings\n./gen\n./gen\n./gen\n./gen\n\n# Rings where one is completely inside the other without touching\n./gen -pattern nested -scale 50\n./gen -pattern nested -scale 70\n\n# Rings overlapping at a point (almost tangent)\n./gen -pattern overlapping -scale 50\n\n# Large rings overlapping\n./gen -pattern overlapping -scale 100\n\n# Rings touching internally\n./gen -pattern tangent_internal -scale 80\n\n# Rings touching externally\n./gen -pattern tangent_external -scale 80\n\n# Edge case: rings with maximum radii\n./gen -pattern overlapping -scale 100\n\n# Edge case: rings with minimum radii\n./gen -pattern overlapping -scale 1\n\n# Rings placed at the limits of the coordinate plane\n./gen -pattern nonoverlapping -scale 100\n\n# Rings with same outer radius but different inner radius\n./gen -pattern overlapping\n\n# Rings with same inner radius but different outer radius\n./gen -pattern overlapping\n\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T19:47:33.513244",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "199/C",
      "title": "C. О микробах",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест2 секунды",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеВ первой строке через пробел записаны четыре целых числа k, b, n и t (1 ≤ k, b, n, t ≤ 106) — параметры размножения бактерий, время, через которое в пробирке оказалось z бактерий в первом опыте, и начальное количество бактерий во втором опыте, соответственно.",
      "output_spec": "Выходные данныеВыведите одно число — наименьшее количество секунд, через которое бактерий станет не меньше, чем z.",
      "sample_tests": "ПримерыВходные данныеСкопировать3 1 3 5Выходные данныеСкопировать2Входные данныеСкопировать1 4 4 7Выходные данныеСкопировать3Входные данныеСкопировать2 2 4 100Выходные данныеСкопировать0",
      "description": "C. О микробах\n\nограничение по времени на тест2 секунды\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвыводstdout\n\nВходные данныеВ первой строке через пробел записаны четыре целых числа k, b, n и t (1 ≤ k, b, n, t ≤ 106) — параметры размножения бактерий, время, через которое в пробирке оказалось z бактерий в первом опыте, и начальное количество бактерий во втором опыте, соответственно.\n\nВходные данные\n\nВыходные данныеВыведите одно число — наименьшее количество секунд, через которое бактерий станет не меньше, чем z.\n\nВыходные данные\n\nВходные данныеСкопировать3 1 3 5Выходные данныеСкопировать2Входные данныеСкопировать1 4 4 7Выходные данныеСкопировать3Входные данныеСкопировать2 2 4 100Выходные данныеСкопировать0\n\nВходные данныеСкопировать3 1 3 5\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать2\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать1 4 4 7\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать3\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать2 2 4 100\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать0\n\nВыходные данныеСкопировать\n\nСкопировать",
      "solutions": [
        {
          "title": "Codeforces Round #125 - Codeforces",
          "content": "Привет всем!Сегодня очередной раунд на Codeforces, вот уже 53-ый.Раунд будет проходить для обоих дивизионов по классическим правилам формата Codeforces.Разбалловка стандартная: 500-1000-1500-2000-2500.В подготовке контеста участвовали Ripatti , Alex_KPR , Gerald , Aksenov239 , RAD , Delinur .Всем удачи!UPD. Раунд окончен.Победители div1:1. Petr2. tourist3. SergeyRogulenko4. bmerry5. UESTC_Nocturne Победители div2:1. gflegar2. mylyanyk.ivan3. arbesfeld Petr — единственный в первом дивизионе, решивший все 5 задач. Во втором дивизионе 5 задач не решил никто.UPD. Разбор задач.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/4757",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 579
        },
        {
          "title": "Разбор задач Codeforces Round #125 - Codeforces",
          "content": "Div2 A. Для решения данной задачи достаточно вывести \"0 0 n\". Автор задачи — Alex_KPR . Div2 B. Для каждой окружности одного кольца нужно определить — имеет ли она пересечения с другим кольцом (касаться можно). Итого 4 проверки. Возможны 3 случая:1. окружность внутри кольца;2. окружность вне кольца и кольцо находится вне окружности;3. окружность вне кольца и кольцо находится внутри окружности.Если хотя бы одно из этих условий выполняется, то окружность хорошая.Проверку легко сделать следующим образом. Пусть d — расстояние между центрами кольца и окружности, r1 и R1 — внутренний и внешний радиусы кольца, r — радиус окружности. Тогда условия запишутся как1. d + r ≤ r1.2. r + R1 ≤ d.3. d + R1 ≤ r.Эти проверки удобно проводить в целых числах, используя квадраты расстояний. Автор задачи — Alex_KPR Div2 C. Div1 A.Первый вариант решения. Рассмотрим последовательность a0 = 1, ai = ai - 1k + b:a0, a1, a2, ..., an = z.Заметим, что для всех чисел из отрезка [a0, a1 - 1] ровно за n преобразований мы получим число не меньше z, однако за n - 1 преобразование мы получим число строго меньше z. Это верно из соображений монотонности функции преобразования. Аналогичные рассуждения можно применить и к числам из отрезков [a1, a2 - 1], [a2, a3 - 1] и так далее, только там будет n - 1, n - 2 шагов и так далее. Значит, для решения задачи, нам нужно узнать к какому из отрезков принадлежит число t. Это можно сделать просто сгенерировав несколько первых членов последовательности a. Не более чем через t шагов найдется подходящий отрезок. Второй вариант решения. Запишем уравнения в лоб:tkx + b(kx - 1 + kx - 2... + 1) ≥ kn + b(kx - 1 + kx - 2... + 1)Воспользуемся формулой для геометрической прогрессии:Далее считаем k ≠ 1, случай k = 1 удобно рассмотреть отдельно в самом начале (его разбирать не будем, он тривиален).t(k - 1)kx + bkx - b ≥ (k - 1)kn + bkn - b kx(t(k - 1) + b) ≥ kn(k - 1 + b) Итак, величину n - x можно найти простым возведением в степень \"пока не переполнится\".Авторы — Gerald и RipattiDiv2 D. Div1 B. Заведем граф, в котором вершинами являются участки стен, ребрами — возможные перемещения ниндзя и запустим на нем поиск в ширину (BFS) с одной модификацией: если мы добрались до некоторой вершины позже, чем до туда добралась вода, то оттуда не делаем ходов.Решение имеет сложность O(n).Автор — RipattiDiv2 E. Div1 C. Заметим, что если мы можем достичь планеты за некоторое время t, то мы можем достичь ее и за любое большее время (для этого достаточно достичь ее за время t, а затем просто перемещаться вместе с планетой). Понятно, что существует некоторое t0, для которого для всех t > t0 достичь планету можно, а для всех t < t0 — нельзя. Будем искать t0 при помощи бинпоиска.Проверку каждого из t внутри бинпоиска можно осуществлять следующим образом. Вычислим положение планеты через время t и найдем расстояние от корабля до этого нового положения.Задача свелась к следующей \"классической\" задаче: есть две точки A и B и круг с центром в O радиуса R (точки вне круга), нужно найти расстояние между точками, при этом в круг заходить нельзя.Возможны 2 случая:1. Можно пройти напрямую2. Следует огибать круг Второй случай выполняется тогда и только тогда, когда верны оба утверждения:a. Углы OAB и OBA острыеb. Высота OH меньше RВсе проверки можно сделать в целых числах.Теперь поймем как обработать случаи:1. Очевидно2. Пусть C и D — точки касания (т.е. мы должны двигаться по линии ACDB). Треугольники OAC и OBD — прямоугольные, там можно легко вычислить все углы, откуда легко найти угол COD. Дальше вычислить длину линии несложно. Заметим, что находить положения точек C и D совсем не обязательно.Автор — RipattiDiv1 D. Суть авторского решения в том, чтобы рекурсивно строить решения в виде параллелепипедов размера k × k × (k + 1), содержащих нужные 2 куба размера k × k × k. Для k = 2 решение очевидно. Далее решение расширятся в соответствии с картинкой:Красный и синий кубики — начало и конец цепи. Сначала мы надстраиваем один этаж сверху, а затем 2 слоя по бокам. Построения зависят от четности текущего k.Чтобы получить решение для n построим n × n × (n + 1), а потом просто отбросим один слой.Автор — RipattiDiv1 E. Расположим все захваты как точки на плоскости с координатами (расстояние, масса). Тогда, пользуясь некоторым захватом, мы можем собирать все захваты внутри некоторого прямоугольника с углом в начале координат. Будем собирать захваты и помещать их в очередь. Тогда для текущего захвата все захваты в прямоугольнике собраны — будем доставать следующий захват из очереди и делать манипуляции с ним. Осталось научиться делать запросы быстро.Заведем дерево отрезков (например, удобно использовать дерево Фенвика) по координате \"расстояние\", в каждой вершине которого будем хранить стек из точек, упорядоченных по координате \"масса\". Каждая вершина дерева отрезков есть некоторый диапазон координат, именно точки из этого диапазона будут храниться в данной вершине. На вершине каждого стека будет захват с наименьшей массой. Положим вначале все точки в это дерево отрезков. Так как каждая координата покрыта не более чем отрезками, всего это дерево будет использовать памяти.При выполнении запроса мы извлекаем из некоторых стеков точки с массой, не превышающей некоторого значения и помещаем их в очередь. Следует отметить, что одна и та же точка может находиться в разных стеках и мы можем случайно положить в очередь одну и ту же точку дважды. Чтобы избежать этого, можно вместе с точкой складывать в дерево отрезков ее номер. А при извлечении точки проверять первое это извлечение или нет в некотором массиве флагов по номеру.Итого решение имеет сложность .Автор — Ripatti ; описанное выше решение предложил RAD",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/4764",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 5659
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #125 - Codeforces - Code 1",
          "code": "UPD. Надеюсь матч Германия-Греция поможет расслабиться тем кому контест не удался...",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4757",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #125 - Codeforces - Code 2",
          "code": "UPD. Надеюсь матч Германия-Греция поможет расслабиться тем кому контест не удался...",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4757",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #125 - Codeforces - Code 3",
          "code": "UPD. А вы считаете что когда решаешь 1 задачу(Div.2) это круто?",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4757",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #125 - Codeforces - Code 4",
          "code": "public class TaskC {\n\tpublic void solve(int testNumber, InputReader in, PrintWriter out) {\n        int xp = in.nextInt();\n        int yp = in.nextInt();\n        int vp = in.nextInt();\n        int x = in.nextInt();\n        int y = in.nextInt();\n        int v = in.nextInt();\n        int r = in.nextInt();\n        double R = Math.sqrt(xp * xp + yp * yp);\n        double left = 0;\n        double right = 1e7;\n        while ((right - left) / right > 1e-10) {\n            double middle = (left + right) / 2;\n            double alpha = middle / (R / vp);\n            double nx = xp * Math.cos(alpha) - yp * Math.sin(alpha);\n            double ny = xp * Math.sin(alpha) + yp * Math.cos(alpha);\n            double a = ny - y;\n            double b = x - nx;\n            double c = -(a * x + b * y);\n            double z = Math.sqrt(a * a + b * b);\n            a /= z;\n            b /= z;\n            c /= z;\n            double need;\n            if (Math.abs(c) < r - 1e-8) {\n                double mx = a * (-c);\n                double my = b * (-c);\n                if (dist(x, y, mx, my) + dist(mx, my, nx, ny) > dist(x, y, nx, ny) + 1e-8) {\n                    need = dist(x, y, nx, ny);\n                } else {\n                    need = catet(dist(x, y, 0, 0), r) + catet(dist(nx, ny, 0, 0), r);\n                    double alp = Math.abs(Math.atan2(y, x) - Math.atan2(ny, nx));\n                    if (alp > Math.PI) alp = 2 * Math.PI - alp;\n                    alp -= Math.acos(Math.min(1.0, r / dist(x, y, 0, 0)));\n                    alp -= Math.acos(Math.min(1.0, r / dist(nx, ny, 0, 0)));\n                    need += alp * r;\n                }\n            } else {\n                need = dist(x, y, nx, ny);\n            }\n            if (need / v <= middle)\n                right = middle;\n            else\n                left = middle;\n        }\n        out.println(right);\n\t}\n\n    private double catet(double a, int b) {\n        double z = a * a - b * b;\n        if (z < 1e-12) z = 0;\n        return Math.sqrt(z);\n    }\n\n    private double dist(double x1, double y1, double x2, double y2) {\n        double dx = x1 - x2;\n        double dy = y1 - y2;\n        return Math.sqrt(dx * dx + dy * dy);\n    }\n}",
          "language": "Java",
          "source": "https://codeforces.com/blog/entry/4757",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #125 - Codeforces - Code 5",
          "code": "public class TaskC {\n\tpublic void solve(int testNumber, InputReader in, PrintWriter out) {\n        int xp = in.nextInt();\n        int yp = in.nextInt();\n        int vp = in.nextInt();\n        int x = in.nextInt();\n        int y = in.nextInt();\n        int v = in.nextInt();\n        int r = in.nextInt();\n        double R = Math.sqrt(xp * xp + yp * yp);\n        double left = 0;\n        double right = 1e7;\n        while ((right - left) / right > 1e-10) {\n            double middle = (left + right) / 2;\n            double alpha = middle / (R / vp);\n            double nx = xp * Math.cos(alpha) - yp * Math.sin(alpha);\n            double ny = xp * Math.sin(alpha) + yp * Math.cos(alpha);\n            double a = ny - y;\n            double b = x - nx;\n            double c = -(a * x + b * y);\n            double z = Math.sqrt(a * a + b * b);\n            a /= z;\n            b /= z;\n            c /= z;\n            double need;\n            if (Math.abs(c) < r - 1e-8) {\n                double mx = a * (-c);\n                double my = b * (-c);\n                if (dist(x, y, mx, my) + dist(mx, my, nx, ny) > dist(x, y, nx, ny) + 1e-8) {\n                    need = dist(x, y, nx, ny);\n                } else {\n                    need = catet(dist(x, y, 0, 0), r) + catet(dist(nx, ny, 0, 0), r);\n                    double alp = Math.abs(Math.atan2(y, x) - Math.atan2(ny, nx));\n                    if (alp > Math.PI) alp = 2 * Math.PI - alp;\n                    alp -= Math.acos(Math.min(1.0, r / dist(x, y, 0, 0)));\n                    alp -= Math.acos(Math.min(1.0, r / dist(nx, ny, 0, 0)));\n                    need += alp * r;\n                }\n            } else {\n                need = dist(x, y, nx, ny);\n            }\n            if (need / v <= middle)\n                right = middle;\n            else\n                left = middle;\n        }\n        out.println(right);\n\t}\n\n    private double catet(double a, int b) {\n        double z = a * a - b * b;\n        if (z < 1e-12) z = 0;\n        return Math.sqrt(z);\n    }\n\n    private double dist(double x1, double y1, double x2, double y2) {\n        double dx = x1 - x2;\n        double dy = y1 - y2;\n        return Math.sqrt(dx * dx + dy * dy);\n    }\n}",
          "language": "Java",
          "source": "https://codeforces.com/blog/entry/4757",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Codeforces Round #125 - Codeforces - Code 1",
          "code": "The input contains of a single integer n (0 ≤ n < 10^9) — the number that should be represented by the rules described above. It is guaranteed that n is a Fibonacci number.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4764",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int k = inf.readInt(1, 1000000, \"k\");\n    inf.readSpace();\n    int b = inf.readInt(1, 1000000, \"b\");\n    inf.readSpace();\n    int n = inf.readInt(1, 1000000, \"n\");\n    inf.readSpace();\n    int t = inf.readInt(1, 1000000, \"t\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int k = inf.readInt(1, 1000000, \"k\");\n    inf.readSpace();\n    int b = inf.readInt(1, 1000000, \"b\");\n    inf.readSpace();\n    int n = inf.readInt(1, 1000000, \"n\");\n    inf.readSpace();\n    int t = inf.readInt(1, 1000000, \"t\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int k = inf.readInt(1, 1000000, \"k\");\n    inf.readSpace();\n    int b = inf.readInt(1, 1000000, \"b\");\n    inf.readSpace();\n    int n = inf.readInt(1, 1000000, \"n\");\n    inf.readSpace();\n    int t = inf.readInt(1, 1000000, \"t\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    // Read parameters\n    int k = opt<int>(\"k\", -1);\n    int b = opt<int>(\"b\", -1);\n    int n = opt<int>(\"n\", -1);\n    string t_type = opt<string>(\"t_type\", \"random\");\n\n    // Assign default random values if not specified\n    if (k == -1)\n        k = rnd.next(1, 1000000);\n    if (b == -1)\n        b = rnd.next(0, 1000000);\n\n    // For t_type 'z' and 'z-1', control k, b, n to keep z within 1e6\n    if (t_type == \"z\" || t_type == \"z-1\") {\n        k = rnd.next(1, 10);\n        b = rnd.next(0, 10);\n        n = rnd.next(1, 100);\n    } else {\n        if (n == -1)\n            n = rnd.next(1, 1000000);\n    }\n\n    // Compute z after n steps starting from x = 1\n    const long long INF = LLONG_MAX / 2;\n    long long x = 1;\n    for (int i = 0; i < n; ++i) {\n        x = k * x + b;\n        if (x > INF) {\n            x = INF;\n            break;\n        }\n    }\n    long long z = x;\n\n    // Set t according to t_type\n    int t;\n    if (t_type == \"min\") {\n        t = 1;\n    } else if (t_type == \"z\") {\n        t = min(z, (long long)1000000);\n    } else if (t_type == \"z-1\") {\n        t = max(1LL, min(z - 1, (long long)1000000));\n    } else if (t_type == \"half\") {\n        t = max(1LL, min(z / 2, (long long)1000000));\n    } else if (t_type == \"max\") {\n        t = 1000000;\n    } else if (t_type == \"random\") {\n        t = rnd.next(1, 1000000);\n    } else {\n        t = rnd.next(1, 1000000);\n    }\n\n    // Output the test case\n    printf(\"%d %d %d %d\\n\", k, b, n, t);\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    // Read parameters\n    int k = opt<int>(\"k\", -1);\n    int b = opt<int>(\"b\", -1);\n    int n = opt<int>(\"n\", -1);\n    string t_type = opt<string>(\"t_type\", \"random\");\n\n    // Assign default random values if not specified\n    if (k == -1)\n        k = rnd.next(1, 1000000);\n    if (b == -1)\n        b = rnd.next(0, 1000000);\n\n    // For t_type 'z' and 'z-1', control k, b, n to keep z within 1e6\n    if (t_type == \"z\" || t_type == \"z-1\") {\n        k = rnd.next(1, 10);\n        b = rnd.next(0, 10);\n        n = rnd.next(1, 100);\n    } else {\n        if (n == -1)\n            n = rnd.next(1, 1000000);\n    }\n\n    // Compute z after n steps starting from x = 1\n    const long long INF = LLONG_MAX / 2;\n    long long x = 1;\n    for (int i = 0; i < n; ++i) {\n        x = k * x + b;\n        if (x > INF) {\n            x = INF;\n            break;\n        }\n    }\n    long long z = x;\n\n    // Set t according to t_type\n    int t;\n    if (t_type == \"min\") {\n        t = 1;\n    } else if (t_type == \"z\") {\n        t = min(z, (long long)1000000);\n    } else if (t_type == \"z-1\") {\n        t = max(1LL, min(z - 1, (long long)1000000));\n    } else if (t_type == \"half\") {\n        t = max(1LL, min(z / 2, (long long)1000000));\n    } else if (t_type == \"max\") {\n        t = 1000000;\n    } else if (t_type == \"random\") {\n        t = rnd.next(1, 1000000);\n    } else {\n        t = rnd.next(1, 1000000);\n    }\n\n    // Output the test case\n    printf(\"%d %d %d %d\\n\", k, b, n, t);\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -t_type z\n./gen -t_type z\n./gen -t_type z-1\n./gen -t_type z-1\n./gen -t_type min\n./gen -t_type min\n./gen -t_type half\n./gen -t_type half\n./gen -t_type max\n./gen -t_type max\n./gen -t_type random\n./gen -t_type random\n\n./gen -k 1 -b 0 -t_type random\n./gen -k 1 -b 0 -t_type min\n./gen -k 1 -b 0 -t_type z\n./gen -k 1 -b 0 -t_type z-1\n\n./gen -k 1 -b 1 -t_type random\n./gen -k 1 -b 1 -t_type z\n./gen -k 1 -b 1 -t_type z-1\n\n./gen -k 1000000 -b 1000000 -t_type random\n./gen -k 1000000 -b 1000000 -t_type min\n./gen -k 1000000 -b 1000000 -t_type max\n\n./gen -b 0 -t_type random\n./gen -b 0 -t_type z\n./gen -b 0 -t_type z-1\n./gen -b 0 -t_type min\n\n./gen -n 1 -t_type random\n./gen -n 1 -t_type z\n./gen -n 1 -t_type z-1\n./gen -n 1000000 -t_type random\n./gen -n 1000000 -t_type min\n\n./gen -n 1000000 -k 1000000 -b 0 -t_type random\n./gen -n 1000000 -k 1000000 -b 0 -t_type max\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T19:47:35.089544",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "199/D",
      "title": "D. Jumping on Walls",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains two integers n and k (1 ≤ n, k ≤ 105) — the height of the canyon and the height of ninja's jump, correspondingly.The second line contains the description of the left wall — a string with the length of n characters. The i-th character represents the state of the i-th wall area: character \"X\" represents a dangerous area and character \"-\" represents a safe area.The third line describes the right wall in the same format.It is guaranteed that the first area of the left wall is not dangerous.",
      "output_spec": "OutputPrint \"YES\" (without the quotes) if the ninja can get out from the canyon, otherwise, print \"NO\" (without the quotes).",
      "sample_tests": "ExamplesInputCopy7 3---X--X-X--XX-OutputCopyYESInputCopy6 2--X-X-X--XX-OutputCopyNO",
      "description": "D. Jumping on Walls\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains two integers n and k (1 ≤ n, k ≤ 105) — the height of the canyon and the height of ninja's jump, correspondingly.The second line contains the description of the left wall — a string with the length of n characters. The i-th character represents the state of the i-th wall area: character \"X\" represents a dangerous area and character \"-\" represents a safe area.The third line describes the right wall in the same format.It is guaranteed that the first area of the left wall is not dangerous.\n\nOutputPrint \"YES\" (without the quotes) if the ninja can get out from the canyon, otherwise, print \"NO\" (without the quotes).\n\nInputCopy7 3---X--X-X--XX-OutputCopyYESInputCopy6 2--X-X-X--XX-OutputCopyNO\n\nInputCopy7 3---X--X-X--XX-\n\nOutputCopyYES\n\nInputCopy6 2--X-X-X--XX-\n\nOutputCopyNO\n\nNoteIn the first sample the ninja should first jump to the right wall, then go one meter down along the right wall, then jump to the left wall. The next jump can get the ninja from the canyon. In the second sample there's no way the ninja can get out of the canyon.",
      "solutions": [
        {
          "title": "Codeforces Round #125 - Codeforces",
          "content": "Hello everyone!There is yet another Codeforces round. Now it is the 53-th one.The round will run for both divisions by classic rules of Codeforces format.Points are standard: 500-1000-1500-2000-2500.Round was prepared by Ripatti , Alex_KPR , Gerald , Aksenov239 , RAD , Delinur .Good luck!UPD. Round is ended.Winners of div1:1. Petr2. tourist3. SergeyRogulenko4. bmerry5. UESTC_Nocturne Winners of div2:1. gflegar2. mylyanyk.ivan3. arbesfeld Petr is only who solved all 5 problems in the first division. No one solved all 5 problems in the second division.UPD. Editorial.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/4757",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 571
        },
        {
          "title": "Solutions for Codeforces Round #125 - Codeforces",
          "content": "Div2 A. You can just output \"0 0 n\". Author is Alex_KPR . Div2 B. You should check for every circle of one ring: it have intersections with another ring or not. So, there are 4 checks. There are 2 cases:1. circle is inside of ring;2. circle is outside of ring and ring is outside of circle;3. circle is outside of ring and ring is inside of circle.If at least one of these cases is performed, circle is good.You can easily do checks following way. Let us d be a distance between centers of ring and circle, r1 and R1 are inside and outside radii of ring, r be radius of circle. Then conditions for all cases will be1. d + r ≤ r1.2. r + R1 ≤ d.3. d + R1 ≤ r.You can check all conditions in integers using squares of distances. Author is Alex_KPR Div2 C. Div1 A.The first solution. Consider sequence a0 = 1, ai = ai - 1k + b:a0, a1, a2, ..., an = z.You can see that for all numbers from segment [a0, a1 - 1] you can number not less than z using exactly n steps. But for n - 1 steps you will bet number less than z. It works because transformation is monotonous. Analogically, for numbers from segments [a1, a2 - 1], [a2, a3 - 1], etc, you need exactly n - 1, n - 2, etc steps. So you just need find segment that contains number t. You can do it by generate a few first members of the sequence a. You need no more than t members. The second solution. Equation:tkx + b(kx - 1 + kx - 2... + 1) ≥ kn + b(kx - 1 + kx - 2... + 1)Using formula for geometric progression you can get:For k ≠ 1 we can multiply both sides by k - 1, (you can consider case k = 1 by yourself).t(k - 1)kx + bkx - b ≥ (k - 1)kn + bkn - b kx(t(k - 1) + b) ≥ kn(k - 1 + b) So, you can find value n - x using simply raising to a power.Authors are Gerald and RipattiDiv2 D. Div1 B. You should construct graph where vertices are areas of walls and edges are actions of ninja. Then you should run BFS with one modification: is you reach vertex later then water, you shouldn't do moves from this vertex.It is solution in O(n).Author is RipattiDiv2 E. Div1 C. If you can reach the planet in time t, you also can reach one in any time greater then t (you can just reach planet in time t and then move along with planet). There exists some t0 for that for all t > t0 you can reach planet, and for all t < t0 you cannot do in. Let us find t0 using binary search.Checking every of t inside of binary search you can do following way. You should calculate place if planet after time t and find distance between ship's place and new planet place.So, you have following \"classic\" problem: there are two points A and B and circle with center in O and radius R (points are outside of circle), you need find distance between points and you cannot moving inside of circle.There are 2 cases:1. You can move direct way2. You should skirt the circle The second case is performed iff two following conditions are performed:a. Angles OAB and OBA are acuteb. Height OH of triangle OAB less than RAll checks you can do in integers.Well, let's understand how to precess our cases:1. Obviously2. Let us C and D be tangency points (i.e. you are moving along line ACDB). Thiangles OAC and OBD are right and you can easily calculate all angles inside of them. Then you should find angle COD. After that you can find length of line ACDB. You can see that you don't need find places of points C and D.Author is RipattiDiv1 D. We will construct solution recursively. For every k it is possible construct parallelepiped k × k × (k + 1) that contains 2 cubes k × k × k. For k = 2 solution is obliviousо. How to build solutions for k > 2 is shown in following picture:Red and blue cubes are start and end of chain. Firstly you should build one floor over. Then you should build 2 layers on two opposite sides.For every n you can build parallelepiped n × n × (n + 1), and drop one layer for getting cube n × n × n.Author is RipattiDiv1 E. You can allocate all grippers as points on plane with coordinates (distance, mass). So, when you use some gripper, you are collecting grippers inside some rectangle with corner in origin. Let us collect grippers and put them into queue. For current gripper you should take all grippers from rectangle and store them into queue. Then you should take next gripper from queue and do some manipulations with them and so on. Well, now you need do it fast.Let us create segment tree (for example, there you can use Fenwick tree) for dimention \"distance\". In every vertex of that tree you should store stack of points ordered by \"mass\". More details: every vertex of segment tree is some range of coordinates, and you should store in thet vertex points only from this range. At the top of every stack should be point with minimal mass. Well, let us put all points into tree. Every position is covered by no more thenм segmetns, therefore all tree will require of memory.When you process query, you should extract points from some stacks and put them into queue. You can see that you may put some points into queue twice. To avoid this you should also put number of point into stack. So, when you are extracting point from stack you can check that it is the first extract using some array of flags.This solution works in .Author is Ripatti ; the above solution was proposed by RAD",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/4764",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 5239
        }
      ],
      "code_examples": [
        {
          "title": "Solutions for Codeforces Round #125 - Codeforces - Code 1",
          "code": "The input contains of a single integer n (0 ≤ n < 10^9) — the number that should be represented by the rules described above. It is guaranteed that n is a Fibonacci number.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4764",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    const int MAX_N = 100000;\n    const int MIN_N = 1;\n    const int MAX_K = 100000;\n    const int MIN_K = 1;\n\n    int n = inf.readInt(MIN_N, MAX_N, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(MIN_K, MAX_K, \"k\");\n    inf.readEoln();\n\n    string left_wall = inf.readLine();\n    ensuref(int(left_wall.size()) == n, \"The length of left wall description must be n=%d, but was %d\", n, int(left_wall.size()));\n\n    for (int i = 0; i < n; ++i) {\n        char c = left_wall[i];\n        ensuref(c == 'X' || c == '-', \"Left wall contains invalid character '%c' at position %d\", c, i+1);\n    }\n\n    string right_wall = inf.readLine();\n    ensuref(int(right_wall.size()) == n, \"The length of right wall description must be n=%d, but was %d\", n, int(right_wall.size()));\n\n    for (int i = 0; i < n; ++i) {\n        char c = right_wall[i];\n        ensuref(c == 'X' || c == '-', \"Right wall contains invalid character '%c' at position %d\", c, i+1);\n    }\n\n    ensuref(left_wall[0] == '-', \"First area of left wall must not be dangerous\");\n\n    inf.readEof();\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    const int MAX_N = 100000;\n    const int MIN_N = 1;\n    const int MAX_K = 100000;\n    const int MIN_K = 1;\n\n    int n = inf.readInt(MIN_N, MAX_N, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(MIN_K, MAX_K, \"k\");\n    inf.readEoln();\n\n    string left_wall = inf.readLine();\n    ensuref(int(left_wall.size()) == n, \"The length of left wall description must be n=%d, but was %d\", n, int(left_wall.size()));\n\n    for (int i = 0; i < n; ++i) {\n        char c = left_wall[i];\n        ensuref(c == 'X' || c == '-', \"Left wall contains invalid character '%c' at position %d\", c, i+1);\n    }\n\n    string right_wall = inf.readLine();\n    ensuref(int(right_wall.size()) == n, \"The length of right wall description must be n=%d, but was %d\", n, int(right_wall.size()));\n\n    for (int i = 0; i < n; ++i) {\n        char c = right_wall[i];\n        ensuref(c == 'X' || c == '-', \"Right wall contains invalid character '%c' at position %d\", c, i+1);\n    }\n\n    ensuref(left_wall[0] == '-', \"First area of left wall must not be dangerous\");\n\n    inf.readEof();\n\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    const int MAX_N = 100000;\n    const int MIN_N = 1;\n    const int MAX_K = 100000;\n    const int MIN_K = 1;\n\n    int n = inf.readInt(MIN_N, MAX_N, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(MIN_K, MAX_K, \"k\");\n    inf.readEoln();\n\n    string left_wall = inf.readLine();\n    ensuref(int(left_wall.size()) == n, \"The length of left wall description must be n=%d, but was %d\", n, int(left_wall.size()));\n\n    for (int i = 0; i < n; ++i) {\n        char c = left_wall[i];\n        ensuref(c == 'X' || c == '-', \"Left wall contains invalid character '%c' at position %d\", c, i+1);\n    }\n\n    string right_wall = inf.readLine();\n    ensuref(int(right_wall.size()) == n, \"The length of right wall description must be n=%d, but was %d\", n, int(right_wall.size()));\n\n    for (int i = 0; i < n; ++i) {\n        char c = right_wall[i];\n        ensuref(c == 'X' || c == '-', \"Right wall contains invalid character '%c' at position %d\", c, i+1);\n    }\n\n    ensuref(left_wall[0] == '-', \"First area of left wall must not be dangerous\");\n\n    inf.readEof();\n\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n#include <string>\r\n\r\nusing namespace std;\r\n\r\nconst string YES = \"YES\";\r\nconst string NO = \"NO\";\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"%s\", (\"multiple \" + YES + \"/\" + NO + \" (case insensitive)\").c_str());\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int index = 0, yesCount = 0, noCount = 0;\r\n    string pa;\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        index++;\r\n        string ja = upperCase(ans.readToken());\r\n        pa = upperCase(ouf.readToken());\r\n\r\n        if (ja != YES && ja != NO)\r\n            quitf(_fail, \"%s or %s expected in answer, but %s found [%d%s token]\",\r\n                  YES.c_str(), NO.c_str(), compress(ja).c_str(), index, englishEnding(index).c_str());\r\n\r\n        if (pa == YES)\r\n            yesCount++;\r\n        else if (pa == NO)\r\n            noCount++;\r\n        else\r\n            quitf(_pe, \"%s or %s expected, but %s found [%d%s token]\",\r\n                  YES.c_str(), NO.c_str(), compress(pa).c_str(), index, englishEnding(index).c_str());\r\n\r\n        if (ja != pa)\r\n            quitf(_wa, \"expected %s, found %s [%d%s token]\",\r\n                  compress(ja).c_str(), compress(pa).c_str(), index, englishEnding(index).c_str());\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n    while (!ans.seekEof()) {\r\n        ans.readToken();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n    while (!ouf.seekEof()) {\r\n        ouf.readToken();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              index + extraInAnsCount, index);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              index + extraInOufCount, index);\r\n\r\n    if (index == 0)\r\n        quitf(_ok, \"Empty output\");\r\n    else if (index == 1)\r\n        quitf(_ok, \"%s\", pa.c_str());\r\n    else\r\n        quitf(_ok, \"%d token(s): yes count is %d, no count is %d\", index, yesCount, noCount);\r\n\r\n    quitf(_fail, \"Impossible case\");\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    // Read parameters.\n    // n: height of the canyon\n    // k: jump height\n    // type: pattern of wall generation (\"all-safe\", \"only-first-safe\", \"random\", \"top-blocked\", etc.)\n    // density: probability of safe cell when \"random\" (0.0 <= density <= 1.0)\n    int n = opt<int>(\"n\", 10);\n    int k = opt<int>(\"k\", 1);\n    string type = opt<string>(\"type\", \"random\");\n    double density = opt<double>(\"density\", 0.5);\n\n    // Make sure n, k satisfy the constraints 1 <= n, k <= 100000\n    // (We assume the user won't break the constraints via command line.)\n    \n    // We'll generate two walls (each of length n), guaranteeing:\n    //   - The first area of the left wall (index 0) must be safe (\"-\").\n\n    // Initialize walls with safe cells.\n    // We'll fill them differently depending on \"type\".\n    string leftWall(n, '-');\n    string rightWall(n, '-');\n    \n    // A small helper to set a character to 'X' with probability p, '-' otherwise.\n    auto randomCell = [&](double p){\n        // if random double [0,1) < p => 'X' else '-'\n        double r = rnd.next();\n        return (r < p) ? 'X' : '-';\n    };\n\n    // We guarantee the first position on the left wall is safe.\n    leftWall[0] = '-';\n\n    if (type == \"all-safe\") {\n        // everything remains '-'\n        // leftWall, rightWall are already filled with '-'\n    }\n    else if (type == \"only-first-safe\") {\n        // only the first area of the left wall is safe, all others 'X'\n        for (int i = 1; i < n; i++) {\n            leftWall[i] = 'X';\n        }\n        for (int i = 0; i < n; i++) {\n            rightWall[i] = 'X';\n        }\n    }\n    else if (type == \"top-blocked\") {\n        // everything safe except top few (say 5) positions on both walls are 'X'\n        // handle cases when n < 5\n        int blockCount = min(n, 5);\n        for (int i = 1; i < n - blockCount; i++) {\n            leftWall[i] = '-';\n            rightWall[i] = '-';\n        }\n        for (int i = max(1, n - blockCount); i < n; i++) {\n            leftWall[i] = 'X';\n            rightWall[i] = 'X';\n        }\n    }\n    else if (type == \"periodic\") {\n        // a repeating pattern of safe/danger\n        // for example, repeat \"-X-\" across each wall\n        // ensuring the first cell of leftWall is still '-'\n        // We'll start from index=1 for leftWall to keep first cell safe\n        for (int i = 1; i < n; i++) {\n            // the pattern is length 3 => \"-X-\"\n            if ((i % 3) == 1) {\n                leftWall[i] = 'X';\n            } else {\n                leftWall[i] = '-';\n            }\n        }\n        for (int i = 0; i < n; i++) {\n            // let's do another pattern for right wall, for variety, e.g. \"-XX-\"\n            // length 4 pattern, but we only do 'X' if remainder is 1 or 2\n            if ((i % 4) == 1 || (i % 4) == 2) {\n                rightWall[i] = 'X';\n            } else {\n                rightWall[i] = '-';\n            }\n        }\n        // ensure leftWall[0] is safe, as required\n        leftWall[0] = '-';\n    }\n    else {\n        // type == \"random\" or anything else => random distribution\n        // but leftWall[0] is forced safe\n        // We'll interpret \"density\" = probability of \"X\".\n        // We'll fill from i=1 for the leftWall so we don't overwrite index 0\n        for (int i = 1; i < n; i++) {\n            leftWall[i] = randomCell(density);\n        }\n        for (int i = 0; i < n; i++) {\n            rightWall[i] = randomCell(density);\n        }\n    }\n\n    // Now output the test in the required format:\n    //  1) n k\n    //  2) left wall\n    //  3) right wall\n\n    cout << n << \" \" << k << \"\\n\";\n    cout << leftWall << \"\\n\";\n    cout << rightWall << \"\\n\";\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    // Read parameters.\n    // n: height of the canyon\n    // k: jump height\n    // type: pattern of wall generation (\"all-safe\", \"only-first-safe\", \"random\", \"top-blocked\", etc.)\n    // density: probability of safe cell when \"random\" (0.0 <= density <= 1.0)\n    int n = opt<int>(\"n\", 10);\n    int k = opt<int>(\"k\", 1);\n    string type = opt<string>(\"type\", \"random\");\n    double density = opt<double>(\"density\", 0.5);\n\n    // Make sure n, k satisfy the constraints 1 <= n, k <= 100000\n    // (We assume the user won't break the constraints via command line.)\n    \n    // We'll generate two walls (each of length n), guaranteeing:\n    //   - The first area of the left wall (index 0) must be safe (\"-\").\n\n    // Initialize walls with safe cells.\n    // We'll fill them differently depending on \"type\".\n    string leftWall(n, '-');\n    string rightWall(n, '-');\n    \n    // A small helper to set a character to 'X' with probability p, '-' otherwise.\n    auto randomCell = [&](double p){\n        // if random double [0,1) < p => 'X' else '-'\n        double r = rnd.next();\n        return (r < p) ? 'X' : '-';\n    };\n\n    // We guarantee the first position on the left wall is safe.\n    leftWall[0] = '-';\n\n    if (type == \"all-safe\") {\n        // everything remains '-'\n        // leftWall, rightWall are already filled with '-'\n    }\n    else if (type == \"only-first-safe\") {\n        // only the first area of the left wall is safe, all others 'X'\n        for (int i = 1; i < n; i++) {\n            leftWall[i] = 'X';\n        }\n        for (int i = 0; i < n; i++) {\n            rightWall[i] = 'X';\n        }\n    }\n    else if (type == \"top-blocked\") {\n        // everything safe except top few (say 5) positions on both walls are 'X'\n        // handle cases when n < 5\n        int blockCount = min(n, 5);\n        for (int i = 1; i < n - blockCount; i++) {\n            leftWall[i] = '-';\n            rightWall[i] = '-';\n        }\n        for (int i = max(1, n - blockCount); i < n; i++) {\n            leftWall[i] = 'X';\n            rightWall[i] = 'X';\n        }\n    }\n    else if (type == \"periodic\") {\n        // a repeating pattern of safe/danger\n        // for example, repeat \"-X-\" across each wall\n        // ensuring the first cell of leftWall is still '-'\n        // We'll start from index=1 for leftWall to keep first cell safe\n        for (int i = 1; i < n; i++) {\n            // the pattern is length 3 => \"-X-\"\n            if ((i % 3) == 1) {\n                leftWall[i] = 'X';\n            } else {\n                leftWall[i] = '-';\n            }\n        }\n        for (int i = 0; i < n; i++) {\n            // let's do another pattern for right wall, for variety, e.g. \"-XX-\"\n            // length 4 pattern, but we only do 'X' if remainder is 1 or 2\n            if ((i % 4) == 1 || (i % 4) == 2) {\n                rightWall[i] = 'X';\n            } else {\n                rightWall[i] = '-';\n            }\n        }\n        // ensure leftWall[0] is safe, as required\n        leftWall[0] = '-';\n    }\n    else {\n        // type == \"random\" or anything else => random distribution\n        // but leftWall[0] is forced safe\n        // We'll interpret \"density\" = probability of \"X\".\n        // We'll fill from i=1 for the leftWall so we don't overwrite index 0\n        for (int i = 1; i < n; i++) {\n            leftWall[i] = randomCell(density);\n        }\n        for (int i = 0; i < n; i++) {\n            rightWall[i] = randomCell(density);\n        }\n    }\n\n    // Now output the test in the required format:\n    //  1) n k\n    //  2) left wall\n    //  3) right wall\n\n    cout << n << \" \" << k << \"\\n\";\n    cout << leftWall << \"\\n\";\n    cout << rightWall << \"\\n\";\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Below are a set of sample commands (20+) to generate various test cases.\n# 1) Very small cases\n./gen -n 1 -k 1 -type all-safe\n./gen -n 1 -k 1 -type only-first-safe\n./gen -n 2 -k 1 -type top-blocked\n./gen -n 3 -k 2 -type random -density 0.0   # No dangerous areas\n\n# 2) More small/medium variety\n./gen -n 5 -k 1 -type random -density 0.3\n./gen -n 6 -k 2 -type random -density 0.7\n./gen -n 10 -k 1 -type only-first-safe\n./gen -n 10 -k 3 -type periodic\n\n# 3) Medium-larger n\n./gen -n 20 -k 1 -type top-blocked\n./gen -n 20 -k 5 -type random -density 0.5\n./gen -n 50 -k 10 -type periodic\n./gen -n 50 -k 1 -type all-safe\n\n# 4) Larger n\n./gen -n 100 -k 1 -type random -density 0.1\n./gen -n 100 -k 10 -type random -density 0.8\n./gen -n 200 -k 50 -type periodic\n./gen -n 300 -k 299 -type top-blocked\n\n# 5) Even larger n\n./gen -n 99999 -k 1 -type only-first-safe\n./gen -n 100000 -k 1 -type all-safe\n./gen -n 100000 -k 50000 -type top-blocked\n./gen -n 100000 -k 99999 -type random -density 0.5\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T19:47:37.335502",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "199/E",
      "title": "E. Доставка канцерогена",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест2 seconds",
      "memory_limit": "ограничение по памяти на тест256 megabytes",
      "input_spec": "Входные данныеВ первой строке записаны через пробел целые числа xp, yp и vp ( - 104 ≤ xp, yp ≤ 104, 1 ≤ vp < 104) — начальное положение Персефоны и скорость ее вращения вокруг Диатар.Во второй строке записаны через пробел целые числа x, y, v и r ( - 104 ≤ x, y ≤ 104, 1 < v ≤ 104, 1 ≤ r ≤ 104) — начальное положение корабля Йцукена, максимальная скорость его движения и минимальное безопасное расстояние до звезды Диатар.Гарантируется, что r2 < x2 + y2, r2 < xp2 + yp2 и vp < v.",
      "output_spec": "Выходные данныеВыведите одно вещественное число — наименьшее возможное время доставки. Ответ будет считаться правильным, если его относительная или абсолютная погрешность не будет превышать 10 - 6.",
      "sample_tests": "ПримерыВходные данныеСкопировать10 0 1-10 0 2 8Выходные данныеСкопировать9.584544103Входные данныеСкопировать50 60 1050 60 20 40Выходные данныеСкопировать0.000000000",
      "description": "E. Доставка канцерогена\n\nограничение по времени на тест2 seconds\n\nограничение по времени на тест\n\nограничение по памяти на тест256 megabytes\n\nограничение по памяти на тест\n\nвыводstdout\n\nВходные данныеВ первой строке записаны через пробел целые числа xp, yp и vp ( - 104 ≤ xp, yp ≤ 104, 1 ≤ vp < 104) — начальное положение Персефоны и скорость ее вращения вокруг Диатар.Во второй строке записаны через пробел целые числа x, y, v и r ( - 104 ≤ x, y ≤ 104, 1 < v ≤ 104, 1 ≤ r ≤ 104) — начальное положение корабля Йцукена, максимальная скорость его движения и минимальное безопасное расстояние до звезды Диатар.Гарантируется, что r2 < x2 + y2, r2 < xp2 + yp2 и vp < v.\n\nВходные данные\n\nВыходные данныеВыведите одно вещественное число — наименьшее возможное время доставки. Ответ будет считаться правильным, если его относительная или абсолютная погрешность не будет превышать 10 - 6.\n\nВыходные данные\n\nВходные данныеСкопировать10 0 1-10 0 2 8Выходные данныеСкопировать9.584544103Входные данныеСкопировать50 60 1050 60 20 40Выходные данныеСкопировать0.000000000\n\nВходные данныеСкопировать10 0 1-10 0 2 8\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать9.584544103\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать50 60 1050 60 20 40\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать0.000000000\n\nВыходные данныеСкопировать\n\nСкопировать",
      "solutions": [
        {
          "title": "Codeforces Round #125 - Codeforces",
          "content": "Привет всем!Сегодня очередной раунд на Codeforces, вот уже 53-ый.Раунд будет проходить для обоих дивизионов по классическим правилам формата Codeforces.Разбалловка стандартная: 500-1000-1500-2000-2500.В подготовке контеста участвовали Ripatti , Alex_KPR , Gerald , Aksenov239 , RAD , Delinur .Всем удачи!UPD. Раунд окончен.Победители div1:1. Petr2. tourist3. SergeyRogulenko4. bmerry5. UESTC_Nocturne Победители div2:1. gflegar2. mylyanyk.ivan3. arbesfeld Petr — единственный в первом дивизионе, решивший все 5 задач. Во втором дивизионе 5 задач не решил никто.UPD. Разбор задач.",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/4757",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 579
        },
        {
          "title": "Разбор задач Codeforces Round #125 - Codeforces",
          "content": "Div2 A. Для решения данной задачи достаточно вывести \"0 0 n\". Автор задачи — Alex_KPR . Div2 B. Для каждой окружности одного кольца нужно определить — имеет ли она пересечения с другим кольцом (касаться можно). Итого 4 проверки. Возможны 3 случая:1. окружность внутри кольца;2. окружность вне кольца и кольцо находится вне окружности;3. окружность вне кольца и кольцо находится внутри окружности.Если хотя бы одно из этих условий выполняется, то окружность хорошая.Проверку легко сделать следующим образом. Пусть d — расстояние между центрами кольца и окружности, r1 и R1 — внутренний и внешний радиусы кольца, r — радиус окружности. Тогда условия запишутся как1. d + r ≤ r1.2. r + R1 ≤ d.3. d + R1 ≤ r.Эти проверки удобно проводить в целых числах, используя квадраты расстояний. Автор задачи — Alex_KPR Div2 C. Div1 A.Первый вариант решения. Рассмотрим последовательность a0 = 1, ai = ai - 1k + b:a0, a1, a2, ..., an = z.Заметим, что для всех чисел из отрезка [a0, a1 - 1] ровно за n преобразований мы получим число не меньше z, однако за n - 1 преобразование мы получим число строго меньше z. Это верно из соображений монотонности функции преобразования. Аналогичные рассуждения можно применить и к числам из отрезков [a1, a2 - 1], [a2, a3 - 1] и так далее, только там будет n - 1, n - 2 шагов и так далее. Значит, для решения задачи, нам нужно узнать к какому из отрезков принадлежит число t. Это можно сделать просто сгенерировав несколько первых членов последовательности a. Не более чем через t шагов найдется подходящий отрезок. Второй вариант решения. Запишем уравнения в лоб:tkx + b(kx - 1 + kx - 2... + 1) ≥ kn + b(kx - 1 + kx - 2... + 1)Воспользуемся формулой для геометрической прогрессии:Далее считаем k ≠ 1, случай k = 1 удобно рассмотреть отдельно в самом начале (его разбирать не будем, он тривиален).t(k - 1)kx + bkx - b ≥ (k - 1)kn + bkn - b kx(t(k - 1) + b) ≥ kn(k - 1 + b) Итак, величину n - x можно найти простым возведением в степень \"пока не переполнится\".Авторы — Gerald и RipattiDiv2 D. Div1 B. Заведем граф, в котором вершинами являются участки стен, ребрами — возможные перемещения ниндзя и запустим на нем поиск в ширину (BFS) с одной модификацией: если мы добрались до некоторой вершины позже, чем до туда добралась вода, то оттуда не делаем ходов.Решение имеет сложность O(n).Автор — RipattiDiv2 E. Div1 C. Заметим, что если мы можем достичь планеты за некоторое время t, то мы можем достичь ее и за любое большее время (для этого достаточно достичь ее за время t, а затем просто перемещаться вместе с планетой). Понятно, что существует некоторое t0, для которого для всех t > t0 достичь планету можно, а для всех t < t0 — нельзя. Будем искать t0 при помощи бинпоиска.Проверку каждого из t внутри бинпоиска можно осуществлять следующим образом. Вычислим положение планеты через время t и найдем расстояние от корабля до этого нового положения.Задача свелась к следующей \"классической\" задаче: есть две точки A и B и круг с центром в O радиуса R (точки вне круга), нужно найти расстояние между точками, при этом в круг заходить нельзя.Возможны 2 случая:1. Можно пройти напрямую2. Следует огибать круг Второй случай выполняется тогда и только тогда, когда верны оба утверждения:a. Углы OAB и OBA острыеb. Высота OH меньше RВсе проверки можно сделать в целых числах.Теперь поймем как обработать случаи:1. Очевидно2. Пусть C и D — точки касания (т.е. мы должны двигаться по линии ACDB). Треугольники OAC и OBD — прямоугольные, там можно легко вычислить все углы, откуда легко найти угол COD. Дальше вычислить длину линии несложно. Заметим, что находить положения точек C и D совсем не обязательно.Автор — RipattiDiv1 D. Суть авторского решения в том, чтобы рекурсивно строить решения в виде параллелепипедов размера k × k × (k + 1), содержащих нужные 2 куба размера k × k × k. Для k = 2 решение очевидно. Далее решение расширятся в соответствии с картинкой:Красный и синий кубики — начало и конец цепи. Сначала мы надстраиваем один этаж сверху, а затем 2 слоя по бокам. Построения зависят от четности текущего k.Чтобы получить решение для n построим n × n × (n + 1), а потом просто отбросим один слой.Автор — RipattiDiv1 E. Расположим все захваты как точки на плоскости с координатами (расстояние, масса). Тогда, пользуясь некоторым захватом, мы можем собирать все захваты внутри некоторого прямоугольника с углом в начале координат. Будем собирать захваты и помещать их в очередь. Тогда для текущего захвата все захваты в прямоугольнике собраны — будем доставать следующий захват из очереди и делать манипуляции с ним. Осталось научиться делать запросы быстро.Заведем дерево отрезков (например, удобно использовать дерево Фенвика) по координате \"расстояние\", в каждой вершине которого будем хранить стек из точек, упорядоченных по координате \"масса\". Каждая вершина дерева отрезков есть некоторый диапазон координат, именно точки из этого диапазона будут храниться в данной вершине. На вершине каждого стека будет захват с наименьшей массой. Положим вначале все точки в это дерево отрезков. Так как каждая координата покрыта не более чем отрезками, всего это дерево будет использовать памяти.При выполнении запроса мы извлекаем из некоторых стеков точки с массой, не превышающей некоторого значения и помещаем их в очередь. Следует отметить, что одна и та же точка может находиться в разных стеках и мы можем случайно положить в очередь одну и ту же точку дважды. Чтобы избежать этого, можно вместе с точкой складывать в дерево отрезков ее номер. А при извлечении точки проверять первое это извлечение или нет в некотором массиве флагов по номеру.Итого решение имеет сложность .Автор — Ripatti ; описанное выше решение предложил RAD",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/4764",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 5659
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #125 - Codeforces - Code 1",
          "code": "UPD. Надеюсь матч Германия-Греция поможет расслабиться тем кому контест не удался...",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4757",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #125 - Codeforces - Code 2",
          "code": "UPD. Надеюсь матч Германия-Греция поможет расслабиться тем кому контест не удался...",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4757",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #125 - Codeforces - Code 3",
          "code": "UPD. А вы считаете что когда решаешь 1 задачу(Div.2) это круто?",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4757",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #125 - Codeforces - Code 4",
          "code": "public class TaskC {\n\tpublic void solve(int testNumber, InputReader in, PrintWriter out) {\n        int xp = in.nextInt();\n        int yp = in.nextInt();\n        int vp = in.nextInt();\n        int x = in.nextInt();\n        int y = in.nextInt();\n        int v = in.nextInt();\n        int r = in.nextInt();\n        double R = Math.sqrt(xp * xp + yp * yp);\n        double left = 0;\n        double right = 1e7;\n        while ((right - left) / right > 1e-10) {\n            double middle = (left + right) / 2;\n            double alpha = middle / (R / vp);\n            double nx = xp * Math.cos(alpha) - yp * Math.sin(alpha);\n            double ny = xp * Math.sin(alpha) + yp * Math.cos(alpha);\n            double a = ny - y;\n            double b = x - nx;\n            double c = -(a * x + b * y);\n            double z = Math.sqrt(a * a + b * b);\n            a /= z;\n            b /= z;\n            c /= z;\n            double need;\n            if (Math.abs(c) < r - 1e-8) {\n                double mx = a * (-c);\n                double my = b * (-c);\n                if (dist(x, y, mx, my) + dist(mx, my, nx, ny) > dist(x, y, nx, ny) + 1e-8) {\n                    need = dist(x, y, nx, ny);\n                } else {\n                    need = catet(dist(x, y, 0, 0), r) + catet(dist(nx, ny, 0, 0), r);\n                    double alp = Math.abs(Math.atan2(y, x) - Math.atan2(ny, nx));\n                    if (alp > Math.PI) alp = 2 * Math.PI - alp;\n                    alp -= Math.acos(Math.min(1.0, r / dist(x, y, 0, 0)));\n                    alp -= Math.acos(Math.min(1.0, r / dist(nx, ny, 0, 0)));\n                    need += alp * r;\n                }\n            } else {\n                need = dist(x, y, nx, ny);\n            }\n            if (need / v <= middle)\n                right = middle;\n            else\n                left = middle;\n        }\n        out.println(right);\n\t}\n\n    private double catet(double a, int b) {\n        double z = a * a - b * b;\n        if (z < 1e-12) z = 0;\n        return Math.sqrt(z);\n    }\n\n    private double dist(double x1, double y1, double x2, double y2) {\n        double dx = x1 - x2;\n        double dy = y1 - y2;\n        return Math.sqrt(dx * dx + dy * dy);\n    }\n}",
          "language": "Java",
          "source": "https://codeforces.com/blog/entry/4757",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #125 - Codeforces - Code 5",
          "code": "public class TaskC {\n\tpublic void solve(int testNumber, InputReader in, PrintWriter out) {\n        int xp = in.nextInt();\n        int yp = in.nextInt();\n        int vp = in.nextInt();\n        int x = in.nextInt();\n        int y = in.nextInt();\n        int v = in.nextInt();\n        int r = in.nextInt();\n        double R = Math.sqrt(xp * xp + yp * yp);\n        double left = 0;\n        double right = 1e7;\n        while ((right - left) / right > 1e-10) {\n            double middle = (left + right) / 2;\n            double alpha = middle / (R / vp);\n            double nx = xp * Math.cos(alpha) - yp * Math.sin(alpha);\n            double ny = xp * Math.sin(alpha) + yp * Math.cos(alpha);\n            double a = ny - y;\n            double b = x - nx;\n            double c = -(a * x + b * y);\n            double z = Math.sqrt(a * a + b * b);\n            a /= z;\n            b /= z;\n            c /= z;\n            double need;\n            if (Math.abs(c) < r - 1e-8) {\n                double mx = a * (-c);\n                double my = b * (-c);\n                if (dist(x, y, mx, my) + dist(mx, my, nx, ny) > dist(x, y, nx, ny) + 1e-8) {\n                    need = dist(x, y, nx, ny);\n                } else {\n                    need = catet(dist(x, y, 0, 0), r) + catet(dist(nx, ny, 0, 0), r);\n                    double alp = Math.abs(Math.atan2(y, x) - Math.atan2(ny, nx));\n                    if (alp > Math.PI) alp = 2 * Math.PI - alp;\n                    alp -= Math.acos(Math.min(1.0, r / dist(x, y, 0, 0)));\n                    alp -= Math.acos(Math.min(1.0, r / dist(nx, ny, 0, 0)));\n                    need += alp * r;\n                }\n            } else {\n                need = dist(x, y, nx, ny);\n            }\n            if (need / v <= middle)\n                right = middle;\n            else\n                left = middle;\n        }\n        out.println(right);\n\t}\n\n    private double catet(double a, int b) {\n        double z = a * a - b * b;\n        if (z < 1e-12) z = 0;\n        return Math.sqrt(z);\n    }\n\n    private double dist(double x1, double y1, double x2, double y2) {\n        double dx = x1 - x2;\n        double dy = y1 - y2;\n        return Math.sqrt(dx * dx + dy * dy);\n    }\n}",
          "language": "Java",
          "source": "https://codeforces.com/blog/entry/4757",
          "author": "Qingyu"
        },
        {
          "title": "Разбор задач Codeforces Round #125 - Codeforces - Code 1",
          "code": "The input contains of a single integer n (0 ≤ n < 10^9) — the number that should be represented by the rules described above. It is guaranteed that n is a Fibonacci number.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4764",
          "author": "Qingyu"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    // First line: xp, yp, vp\n    int xp = inf.readInt(-10000, 10000, \"xp\");\n    inf.readSpace();\n    int yp = inf.readInt(-10000, 10000, \"yp\");\n    inf.readSpace();\n    int vp = inf.readInt(1, 9999, \"vp\");\n    inf.readEoln();\n\n    // Second line: x, y, v, r\n    int x = inf.readInt(-10000, 10000, \"x\");\n    inf.readSpace();\n    int y = inf.readInt(-10000, 10000, \"y\");\n    inf.readSpace();\n    int v = inf.readInt(2, 10000, \"v\");\n    inf.readSpace();\n    int r = inf.readInt(1, 10000, \"r\");\n    inf.readEoln();\n\n    // Now check the additional constraints\n\n    // It is guaranteed that r^2 < x^2 + y^2\n    long long rsq = 1LL * r * r;\n    long long xsq = 1LL * x * x + 1LL * y * y;\n    ensuref(rsq < xsq, \"r^2 < x^2 + y^2 failed: %lld >= %lld\", rsq, xsq);\n\n    // Similarly, r^2 < xp^2 + yp^2\n    long long xpsq = 1LL * xp * xp + 1LL * yp * yp;\n    ensuref(rsq < xpsq, \"r^2 < xp^2 + yp^2 failed: %lld >= %lld\", rsq, xpsq);\n\n    // vp < v\n    ensuref(vp < v, \"vp < v failed: %d >= %d\", vp, v);\n\n    // Read EOF\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    // First line: xp, yp, vp\n    int xp = inf.readInt(-10000, 10000, \"xp\");\n    inf.readSpace();\n    int yp = inf.readInt(-10000, 10000, \"yp\");\n    inf.readSpace();\n    int vp = inf.readInt(1, 9999, \"vp\");\n    inf.readEoln();\n\n    // Second line: x, y, v, r\n    int x = inf.readInt(-10000, 10000, \"x\");\n    inf.readSpace();\n    int y = inf.readInt(-10000, 10000, \"y\");\n    inf.readSpace();\n    int v = inf.readInt(2, 10000, \"v\");\n    inf.readSpace();\n    int r = inf.readInt(1, 10000, \"r\");\n    inf.readEoln();\n\n    // Now check the additional constraints\n\n    // It is guaranteed that r^2 < x^2 + y^2\n    long long rsq = 1LL * r * r;\n    long long xsq = 1LL * x * x + 1LL * y * y;\n    ensuref(rsq < xsq, \"r^2 < x^2 + y^2 failed: %lld >= %lld\", rsq, xsq);\n\n    // Similarly, r^2 < xp^2 + yp^2\n    long long xpsq = 1LL * xp * xp + 1LL * yp * yp;\n    ensuref(rsq < xpsq, \"r^2 < xp^2 + yp^2 failed: %lld >= %lld\", rsq, xpsq);\n\n    // vp < v\n    ensuref(vp < v, \"vp < v failed: %d >= %d\", vp, v);\n\n    // Read EOF\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    // First line: xp, yp, vp\n    int xp = inf.readInt(-10000, 10000, \"xp\");\n    inf.readSpace();\n    int yp = inf.readInt(-10000, 10000, \"yp\");\n    inf.readSpace();\n    int vp = inf.readInt(1, 9999, \"vp\");\n    inf.readEoln();\n\n    // Second line: x, y, v, r\n    int x = inf.readInt(-10000, 10000, \"x\");\n    inf.readSpace();\n    int y = inf.readInt(-10000, 10000, \"y\");\n    inf.readSpace();\n    int v = inf.readInt(2, 10000, \"v\");\n    inf.readSpace();\n    int r = inf.readInt(1, 10000, \"r\");\n    inf.readEoln();\n\n    // Now check the additional constraints\n\n    // It is guaranteed that r^2 < x^2 + y^2\n    long long rsq = 1LL * r * r;\n    long long xsq = 1LL * x * x + 1LL * y * y;\n    ensuref(rsq < xsq, \"r^2 < x^2 + y^2 failed: %lld >= %lld\", rsq, xsq);\n\n    // Similarly, r^2 < xp^2 + yp^2\n    long long xpsq = 1LL * xp * xp + 1LL * yp * yp;\n    ensuref(rsq < xpsq, \"r^2 < xp^2 + yp^2 failed: %lld >= %lld\", rsq, xpsq);\n\n    // vp < v\n    ensuref(vp < v, \"vp < v failed: %d >= %d\", vp, v);\n\n    // Read EOF\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nconst double EPS = 1E-6;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare two sequences of doubles, max absolute or relative  error = %.7f\", EPS);\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    double j = 0, p = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        n++;\r\n        j = ans.readDouble();\r\n        p = ouf.readDouble();\r\n        if (!doubleCompare(j, p, EPS)) {\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%.7f', found: '%.7f', error = '%.7f'\",\r\n                  n, englishEnding(n).c_str(), j, p, doubleDelta(j, p));\r\n        }\r\n    }\r\n\r\n    if (n == 1)\r\n        quitf(_ok, \"found '%.7f', expected '%.7f', error '%.7f'\", p, j, doubleDelta(j, p));\r\n\r\n    quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\n/*\n  This generator produces exactly one test case each time it runs. \n\n  It reads a parameter \"type\" to decide which kind of test to produce:\n   1) \"random\"        - a fully random valid test\n   2) \"co_located\"    - Qwerty's ship initially at the same point as Persephone\n   3) \"extreme_speeds\" - large speeds (vp close to v, but v > vp)\n   4) \"large_coords\"   - coordinates near the limits ±10000\n   5) \"near_r\"         - planet and ship just outside distance r from the star\n   6) \"planet_close\"   - r is large, and xp^2+yp^2 just a bit larger than r^2\n*/\n\nstatic const int COORD_MIN = -10000;\nstatic const int COORD_MAX =  10000;\nstatic const int SPEED_MIN = 1;\nstatic const int SPEED_MAX = 10000;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    // Read scenario type, default \"random\"\n    string type = opt<string>(\"type\", \"random\");\n\n    // We'll generate (xp, yp, vp) on the first line,\n    // and (x, y, v, r) on the second line.\n    // All must satisfy:\n    //   -10000 <= xp, yp <= 10000\n    //   1 <= vp < 10000\n    //   -10000 <= x, y <= 10000\n    //   1 < v <= 10000\n    //   1 <= r <= 10000\n    //   r^2 < x^2 + y^2\n    //   r^2 < xp^2 + yp^2\n    //   vp < v\n\n    // We'll define helper lambdas:\n\n    // Generate a random integer within [low, high].\n    auto rndInt = [&](int low, int high) {\n        return rnd.next(low, high);\n    };\n\n    // We want to produce one test with the constraints.\n\n    // A small function to ensure (xx, yy) != (0, 0) and (xx^2 + yy^2) > rr^2.\n    // We'll pick random (xx, yy) until valid.\n    auto genXY = [&](int r) {\n        // Keep picking until valid\n        while (true) {\n            int xx = rndInt(COORD_MIN, COORD_MAX);\n            int yy = rndInt(COORD_MIN, COORD_MAX);\n            long long dist2 = 1LL * xx * xx + 1LL * yy * yy;\n            long long rr2   = 1LL * r * r;\n            // Need dist2 > rr2, not both 0\n            if (dist2 > rr2) {\n                return make_pair(xx, yy);\n            }\n        }\n    };\n\n    // We'll prepare variables for output.\n    int xp, yp, vp;\n    int x, y, v, r;\n\n    if (type == \"random\") {\n        // 1) pick r\n        r = rndInt(1, SPEED_MAX - 1); // up to 9999\n        // 2) generate xp, yp so that xp^2+yp^2 > r^2\n        auto p1 = genXY(r);\n        xp = p1.first;\n        yp = p1.second;\n        // 3) generate x, y so that x^2+y^2 > r^2\n        auto p2 = genXY(r);\n        x = p2.first;\n        y = p2.second;\n        // 4) pick vp in [1..9999]\n        vp = rndInt(SPEED_MIN, SPEED_MAX - 1); \n        // 5) pick v in [vp+1..10000] to ensure v>vp\n        v  = rndInt(vp + 1, SPEED_MAX);\n\n    } else if (type == \"co_located\") {\n        // Qwerty's ship is at the same place as Persephone\n        // We choose a fixed example that satisfies constraints\n        // xp=100, yp=0 => xp^2=10000\n        // choose r=90 => r^2=8100 => < 10000 => valid\n        // so x=100, y=0 => dist^2=10000 => also > 8100 => valid\n        // vp=2, v=3 => satisfies vp<v\n        xp = 100; \n        yp = 0;\n        vp = 2; \n        x  = 100; \n        y  = 0; \n        v  = 3; \n        r  = 90;\n\n    } else if (type == \"extreme_speeds\") {\n        // Large speeds, with vp just a bit less than v.\n        // xp=100, yp=0 => xp^2=10000\n        // choose r=1 => r^2=1 => 1<10000 => valid\n        // x=-100, y=0 => 10000>1 => valid\n        // vp=9999, v=10000 => vp<v\n        xp = 100;\n        yp = 0;\n        r  = 1;\n        x  = -100;\n        y  = 0;\n        vp = 9999;\n        v  = 10000;\n\n    } else if (type == \"large_coords\") {\n        // Coordinates near ±10000\n        // We'll fix xp=10000, yp=0 => xp^2=10000^2=100000000\n        // pick r=100 => r^2=10000 => < 100000000 => valid\n        // x=-10000, y=0 => x^2=100000000 => also >10000 => valid\n        // let vp=9999, v=10000 => still valid\n        xp = 10000; \n        yp = 0;\n        r  = 100;\n        x  = -10000;\n        y  = 0;\n        vp = 9999;\n        v  = 10000;\n\n    } else if (type == \"near_r\") {\n        // Have the planet and ship just outside distance r from star.\n        // For example, pick r=200, xp=201, yp=0 => 201^2=40401>40000 => valid\n        // x=-202,y=0 => 202^2=40804>40000 => valid\n        // vp=10, v=15 => valid\n        r  = 200;\n        xp = 201; \n        yp = 0; \n        x  = -202; \n        y  = 0; \n        vp = 10; \n        v  = 15;\n\n    } else if (type == \"planet_close\") {\n        // The planet's orbit radius is just barely above r.\n        // e.g. r=9 => r^2=81\n        // xp=10, yp=0 => 10^2=100 => just above 81\n        // x=-20, y=0 => 400>81 => good\n        // vp=5, v=6 => vp<v\n        r  = 9;\n        xp = 10; \n        yp = 0; \n        x  = -20;\n        y  = 0;\n        vp = 5;\n        v  = 6;\n\n    } else {\n        // Fallback to \"random\" if unknown type\n        r = rndInt(1, SPEED_MAX - 1);\n        auto p1 = genXY(r);\n        xp = p1.first;\n        yp = p1.second;\n        auto p2 = genXY(r);\n        x = p2.first;\n        y = p2.second;\n        vp = rndInt(SPEED_MIN, SPEED_MAX - 1);\n        v  = rndInt(vp + 1, SPEED_MAX);\n    }\n\n    // Now print the test case:\n    // First line: xp, yp, vp\n    // Second line: x, y, v, r\n    cout << xp << \" \" << yp << \" \" << vp << \"\\n\";\n    cout << x  << \" \" << y  << \" \" << v  << \" \" << r << \"\\n\";\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\n/*\n  This generator produces exactly one test case each time it runs. \n\n  It reads a parameter \"type\" to decide which kind of test to produce:\n   1) \"random\"        - a fully random valid test\n   2) \"co_located\"    - Qwerty's ship initially at the same point as Persephone\n   3) \"extreme_speeds\" - large speeds (vp close to v, but v > vp)\n   4) \"large_coords\"   - coordinates near the limits ±10000\n   5) \"near_r\"         - planet and ship just outside distance r from the star\n   6) \"planet_close\"   - r is large, and xp^2+yp^2 just a bit larger than r^2\n*/\n\nstatic const int COORD_MIN = -10000;\nstatic const int COORD_MAX =  10000;\nstatic const int SPEED_MIN = 1;\nstatic const int SPEED_MAX = 10000;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    // Read scenario type, default \"random\"\n    string type = opt<string>(\"type\", \"random\");\n\n    // We'll generate (xp, yp, vp) on the first line,\n    // and (x, y, v, r) on the second line.\n    // All must satisfy:\n    //   -10000 <= xp, yp <= 10000\n    //   1 <= vp < 10000\n    //   -10000 <= x, y <= 10000\n    //   1 < v <= 10000\n    //   1 <= r <= 10000\n    //   r^2 < x^2 + y^2\n    //   r^2 < xp^2 + yp^2\n    //   vp < v\n\n    // We'll define helper lambdas:\n\n    // Generate a random integer within [low, high].\n    auto rndInt = [&](int low, int high) {\n        return rnd.next(low, high);\n    };\n\n    // We want to produce one test with the constraints.\n\n    // A small function to ensure (xx, yy) != (0, 0) and (xx^2 + yy^2) > rr^2.\n    // We'll pick random (xx, yy) until valid.\n    auto genXY = [&](int r) {\n        // Keep picking until valid\n        while (true) {\n            int xx = rndInt(COORD_MIN, COORD_MAX);\n            int yy = rndInt(COORD_MIN, COORD_MAX);\n            long long dist2 = 1LL * xx * xx + 1LL * yy * yy;\n            long long rr2   = 1LL * r * r;\n            // Need dist2 > rr2, not both 0\n            if (dist2 > rr2) {\n                return make_pair(xx, yy);\n            }\n        }\n    };\n\n    // We'll prepare variables for output.\n    int xp, yp, vp;\n    int x, y, v, r;\n\n    if (type == \"random\") {\n        // 1) pick r\n        r = rndInt(1, SPEED_MAX - 1); // up to 9999\n        // 2) generate xp, yp so that xp^2+yp^2 > r^2\n        auto p1 = genXY(r);\n        xp = p1.first;\n        yp = p1.second;\n        // 3) generate x, y so that x^2+y^2 > r^2\n        auto p2 = genXY(r);\n        x = p2.first;\n        y = p2.second;\n        // 4) pick vp in [1..9999]\n        vp = rndInt(SPEED_MIN, SPEED_MAX - 1); \n        // 5) pick v in [vp+1..10000] to ensure v>vp\n        v  = rndInt(vp + 1, SPEED_MAX);\n\n    } else if (type == \"co_located\") {\n        // Qwerty's ship is at the same place as Persephone\n        // We choose a fixed example that satisfies constraints\n        // xp=100, yp=0 => xp^2=10000\n        // choose r=90 => r^2=8100 => < 10000 => valid\n        // so x=100, y=0 => dist^2=10000 => also > 8100 => valid\n        // vp=2, v=3 => satisfies vp<v\n        xp = 100; \n        yp = 0;\n        vp = 2; \n        x  = 100; \n        y  = 0; \n        v  = 3; \n        r  = 90;\n\n    } else if (type == \"extreme_speeds\") {\n        // Large speeds, with vp just a bit less than v.\n        // xp=100, yp=0 => xp^2=10000\n        // choose r=1 => r^2=1 => 1<10000 => valid\n        // x=-100, y=0 => 10000>1 => valid\n        // vp=9999, v=10000 => vp<v\n        xp = 100;\n        yp = 0;\n        r  = 1;\n        x  = -100;\n        y  = 0;\n        vp = 9999;\n        v  = 10000;\n\n    } else if (type == \"large_coords\") {\n        // Coordinates near ±10000\n        // We'll fix xp=10000, yp=0 => xp^2=10000^2=100000000\n        // pick r=100 => r^2=10000 => < 100000000 => valid\n        // x=-10000, y=0 => x^2=100000000 => also >10000 => valid\n        // let vp=9999, v=10000 => still valid\n        xp = 10000; \n        yp = 0;\n        r  = 100;\n        x  = -10000;\n        y  = 0;\n        vp = 9999;\n        v  = 10000;\n\n    } else if (type == \"near_r\") {\n        // Have the planet and ship just outside distance r from star.\n        // For example, pick r=200, xp=201, yp=0 => 201^2=40401>40000 => valid\n        // x=-202,y=0 => 202^2=40804>40000 => valid\n        // vp=10, v=15 => valid\n        r  = 200;\n        xp = 201; \n        yp = 0; \n        x  = -202; \n        y  = 0; \n        vp = 10; \n        v  = 15;\n\n    } else if (type == \"planet_close\") {\n        // The planet's orbit radius is just barely above r.\n        // e.g. r=9 => r^2=81\n        // xp=10, yp=0 => 10^2=100 => just above 81\n        // x=-20, y=0 => 400>81 => good\n        // vp=5, v=6 => vp<v\n        r  = 9;\n        xp = 10; \n        yp = 0; \n        x  = -20;\n        y  = 0;\n        vp = 5;\n        v  = 6;\n\n    } else {\n        // Fallback to \"random\" if unknown type\n        r = rndInt(1, SPEED_MAX - 1);\n        auto p1 = genXY(r);\n        xp = p1.first;\n        yp = p1.second;\n        auto p2 = genXY(r);\n        x = p2.first;\n        y = p2.second;\n        vp = rndInt(SPEED_MIN, SPEED_MAX - 1);\n        v  = rndInt(vp + 1, SPEED_MAX);\n    }\n\n    // Now print the test case:\n    // First line: xp, yp, vp\n    // Second line: x, y, v, r\n    cout << xp << \" \" << yp << \" \" << vp << \"\\n\";\n    cout << x  << \" \" << y  << \" \" << v  << \" \" << r << \"\\n\";\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Below are 20 distinct commands to produce a variety of test cases.\n# Each command prints exactly one test case to standard output.\n\n./gen -type co_located\n./gen -type co_located\n./gen -type extreme_speeds\n./gen -type extreme_speeds\n./gen -type large_coords\n./gen -type large_coords\n./gen -type near_r\n./gen -type near_r\n./gen -type planet_close\n./gen -type planet_close\n\n./gen -type random\n./gen -type random\n./gen -type random\n./gen -type random\n./gen -type random\n./gen -type random\n./gen -type random\n./gen -type random\n./gen -type random\n./gen -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T19:47:39.759651",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "2/A",
      "title": "A. Winner",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test64 megabytes",
      "input_spec": "InputThe first line contains an integer number n (1  ≤  n  ≤  1000), n is the number of rounds played. Then follow n lines, containing the information about the rounds in \"name score\" format in chronological order, where name is a string of lower-case Latin letters with the length from 1 to 32, and score is an integer number between -1000 and 1000, inclusive.",
      "output_spec": "OutputPrint the name of the winner.",
      "sample_tests": "ExamplesInputCopy3mike 3andrew 5mike 2OutputCopyandrewInputCopy3andrew 3andrew 2mike 5OutputCopyandrew",
      "description": "time limit per test1 second\n\ntime limit per test\n\nmemory limit per test64 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains an integer number n (1  ≤  n  ≤  1000), n is the number of rounds played. Then follow n lines, containing the information about the rounds in \"name score\" format in chronological order, where name is a string of lower-case Latin letters with the length from 1 to 32, and score is an integer number between -1000 and 1000, inclusive.\n\nOutputPrint the name of the winner.\n\nInputCopy3mike 3andrew 5mike 2OutputCopyandrewInputCopy3andrew 3andrew 2mike 5OutputCopyandrew\n\nInputCopy3mike 3andrew 5mike 2\n\nOutputCopyandrew\n\nInputCopy3andrew 3andrew 2mike 5\n\nOutputCopyandrew",
      "solutions": [
        {
          "title": "Codeforces Beta Round #2 - Codeforces",
          "content": "Thank you all for participating in Codeforces Beta Round # 2. I hope you enjoyed it. You may discuss the problems and system in comments. Please express your opinion, especially if you notice any inappropriate behavior. And as always, I will read with interest the suggestions for improvement. Congratulations to the three leaders: RAVEman, GarnetCrow and ivan.popelyshev! See you at Codeforces Beta Round # 3. P.S. And by the way, the round tutorial is waiting for a volunteer. It is desirable that it will be one of the leaders of today's competition. The tutorial should be in Russian and in English. It will be published on the homepage and later will be available via special link from the contest page.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/97",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.6,
            "reason": "宽松匹配: 包含题目编号 2 和字母"
          },
          "content_length": 708
        },
        {
          "title": "Codeforces Beta Round #2 - Another Tutorial - Codeforces",
          "content": "Lets start from the end.Problem С. Commentator problemLet R be the distance from point А to a circle with center О and radius r. From this point the circle is observed at the angle . So, the three stadiums are observed at the same angle if R1 / r1 = R2 / r2 = R3 / r3. Take two different points A, B. The set of points C that AC / BC = const is either a line (perpendicular bisector of AB) or a circle with center somewhere on the line AB. This circle is easy to find. It contains two points that lie on AB and satisfy AC / BC condition. Let X1 be the set of points from which stadiums 1 and 2 are observed at the same angle. Let X2 be the set of points from which stadiums 2 and 3 are observed at the same angle. The answer belongs to both X1 and X2 . The centers of the three stadiums don't lie on one line, so the number of points in the intersection of  X1 and X2 will be finite.Check them all. The answer is the point that lies closer to any of the stadiums. The stadiums don't intersect, so that point will not lie inside any of them.How to get a big circle for X1 : put the centers of the stadiums in the points far away, for example in (0, 0) and (1000, 0). The ratio of the radii should be the closer possible to 1, for example . The center and the radius of the new circle will have the order 106 . The answer should be known with 10 - 5 precision. Roofly speaking, we need 11 digits, double precision will be enough.Problem B. The least round wayLet us solve the problem in the case of positive matrix.Let the number in the end be N = 2k· 5m·(other primes). The number of zeroes at the end of N is equal to min(k, m). At the aid of dynamic programming find minimal value of k (let it be k1) and minimal value of m (let it be m1), and paths that lead to these values. In case of k1 < m1 choose the path corresponding to k1, else  m1. So min(k, m) is the upper bound for the answer. Let us prove that it is the lower bound too. If there exists a path leading to a number with number of zeroes less than min(k, m) then in the factorization of that number the power of two is k < k1 or the power of five is m < m1. We come to a contradiction.So we need to calculate the power of 2 and 5 in the factorization of each value in the matrix and use dynamic programming on each of the two matrices. In the case of matrix containing zeroes, calculate separately the best path not containing zeroes and any path containing zeroes:Replace all 0 by 10 and use the method described above. For paths containing zeroes the result will contain at least one zero at the end. If the method returned a number without zeroes at the end, the corresponding path is the answer, else any path containing zeroes is the answer.The complexity of the algorithm depends on the complexity of the dynamics, it is O(N· M).Problem A. Winner Simple problem, just code it. At the first pass calculate the sum of points for each player at game end. Let M be the maximum of these sums. At the second pass check every round. If current player X has not less than M points and his final score is equal to M then he is the winner. The following test illustrates that player could receive more than M points, then lose some and, finally, win. Input: Masha 12 Masha -5 Sasha 10 Masha 3 Output: Masha",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/107",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 2\\s*A"
          },
          "content_length": 3266
        },
        {
          "title": "Codeforces Beta Round #2 - Tutorial - Codeforces",
          "content": "Problem A. Winner To solve the problem we just need accurately follow all rules described in the problem statement. Let's describe in more details required sequence of actions. First of all, we need to find the maximum score m at the end of the game. This can be done by emulating. After all rounds played just iterate over players and choose one with the maximum score. Second, we need to figure out the set of players who have maximum score at the end of the game. We can do this in the same way as calculating maximum score. Just iterate over players after all rounds played and store all players with score equal to m. And the last, we need to find a winner. To do this we will emulate the game one more time looking for player from the winner list with score not less m after some round. This task demonstrates that sometimes it is easier to code everything stated in the problem statement, than thinking and optimizing. Problem B. The least round way First of all, let's consider a case when there is at least one zero number in the square. In this case we can easily create a way with only one trailing zero in resulting multiplication - just output way over this zero number. The only case when this is not optimal way is when a way exists with no trailing zeroes at all. So, we can replace all 0's with 10's and solve the problem in general case. If there is an answer with no trailing zeroes - we will choose this one, otherwise we will output way over zero number. So, we can consider that all numbers in the square are positive. Let's understand what the number of zeroes in the resulting multiplication is. If we go along a way and count number of 2's and 5's in numbers factorization then the number of trailing zeros will be min(number of 2's, number of 5's). This allows us to solve the problem independently for 2's and 5's. The final answer will be just a minimum over these two solutions. Now, the last thing left is to solve the problem for 2's and 5's. New problem interpretation is the following: there is a square with numbers inside. We are to find a way with the minimal sum of the number over the way. This is classical dynamic programming problem. Let's consider that A[r,c] is the number in cell (r,c) and D[r,c] is the answer for this cell. Then D[r,c] = min(D[r-1,c],D[r,c-1]) + A[r][c] Problem C. Commentator problem. Let's take two stadiums and find out a set of points from which the stadiums are observed at the same angle. Not very hard mathematical calculation shows that this is a line if stadiums have the same radius and this is a circle if they have different radiuses. Let's define S(i,j) as a set of points from which the stadiums i and j are observed at the same angle. Given that centers of stadiums are not on the same line, the intersection of S(1,2) with S(1,3) contains no more than two points. If we know these no more that 2 points we can double-check that they satisfy the criteria and chose the point with the maximum angle of observation.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/109",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.6,
            "reason": "宽松匹配: 包含题目编号 2 和字母"
          },
          "content_length": 2991
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Beta Round #2 - Another Tutorial - Codeforces - Code 1",
          "code": "Test: #31, time: 3421 ms., memory: 172 KB, exit code: 0, checker exit code: 1, verdict: WRONG_ANSWER\n...\nChecker Log\nwrong answer Jury has better answer: ja=1 vs pa=2974",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/107",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Beta Round #2 - Another Tutorial - Codeforces - Code 2",
          "code": "Test: #31, time: 3421 ms., memory: 172 KB, exit code: 0, checker exit code: 1, verdict: WRONG_ANSWER\n...\nChecker Log\nwrong answer Jury has better answer: ja=1 vs pa=2974",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/107",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Beta Round #2 - Another Tutorial - Codeforces - Code 3",
          "code": "4\na 10\nb 2\nb 3\na -10",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/107",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Beta Round #2 - Another Tutorial - Codeforces - Code 4",
          "code": "int n;\nmap<string, int> score_board;\nmap<int, vector<string>> rev_board;\n\n\n\nvoid solve() {\n\n\tcin >> n;\n\n\tfor(int i=0; i<n; ++i) {\n\t\n\t\tstring name;\n\t\tint score;\n\n\t\tcin >> name >> score;\n\n\t\tscore_board[name] += score;\n\t\trev_board[score_board[name]].push_back(name);\n\n\t}\n\n\t\n\tauto it=rev_board.end();\n\t--it;\n\n\tcout << it->second[0];\n\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/107",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Beta Round #2 - Another Tutorial - Codeforces - Code 5",
          "code": "int n;\nmap<string, int> score_board;\nmap<int, vector<string>> rev_board;\n\n\n\nvoid solve() {\n\n\tcin >> n;\n\n\tfor(int i=0; i<n; ++i) {\n\t\n\t\tstring name;\n\t\tint score;\n\n\t\tcin >> name >> score;\n\n\t\tscore_board[name] += score;\n\t\trev_board[score_board[name]].push_back(name);\n\n\t}\n\n\t\n\tauto it=rev_board.end();\n\t--it;\n\n\tcout << it->second[0];\n\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/107",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 1000, \"n\");\n    inf.readEoln();\n\n    map<string, long long> totals;\n    for (int i = 0; i < n; ++i) {\n        string name = inf.readToken(\"[a-z]{1,32}\", \"name\");\n        inf.readSpace();\n        int score = inf.readInt(-1000, 1000, \"score\");\n        inf.readEoln();\n        totals[name] += score;\n    }\n\n    inf.readEof();\n\n    int positive_count = 0;\n    for (auto& p : totals) {\n        if (p.second > 0) {\n            ++positive_count;\n        }\n    }\n    ensuref(positive_count >= 1, \"At the end of the game at least one player has a positive number of points\");\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 1000, \"n\");\n    inf.readEoln();\n\n    map<string, long long> totals;\n    for (int i = 0; i < n; ++i) {\n        string name = inf.readToken(\"[a-z]{1,32}\", \"name\");\n        inf.readSpace();\n        int score = inf.readInt(-1000, 1000, \"score\");\n        inf.readEoln();\n        totals[name] += score;\n    }\n\n    inf.readEof();\n\n    int positive_count = 0;\n    for (auto& p : totals) {\n        if (p.second > 0) {\n            ++positive_count;\n        }\n    }\n    ensuref(positive_count >= 1, \"At the end of the game at least one player has a positive number of points\");\n\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 1000, \"n\");\n    inf.readEoln();\n\n    map<string, long long> totals;\n    for (int i = 0; i < n; ++i) {\n        string name = inf.readToken(\"[a-z]{1,32}\", \"name\");\n        inf.readSpace();\n        int score = inf.readInt(-1000, 1000, \"score\");\n        inf.readEoln();\n        totals[name] += score;\n    }\n\n    inf.readEof();\n\n    int positive_count = 0;\n    for (auto& p : totals) {\n        if (p.second > 0) {\n            ++positive_count;\n        }\n    }\n    ensuref(positive_count >= 1, \"At the end of the game at least one player has a positive number of points\");\n\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare sequences of tokens\");\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string j, p;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n\r\n        ans.readWordTo(j);\r\n        ouf.readWordTo(p);\r\n\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s words differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  compress(j).c_str(), compress(p).c_str());\r\n    }\r\n\r\n    if (ans.seekEof() && ouf.seekEof()) {\r\n        if (n == 1)\r\n            quitf(_ok, \"\\\"%s\\\"\", compress(j).c_str());\r\n        else\r\n            quitf(_ok, \"%d tokens\", n);\r\n    } else {\r\n        if (ans.seekEof())\r\n            quitf(_wa, \"Participant output contains extra tokens\");\r\n        else\r\n            quitf(_wa, \"Unexpected EOF in the participants output\");\r\n    }\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nstring random_name(int min_len = 1, int max_len = 32) {\n    int len = rnd.next(min_len, max_len);\n    string s;\n    for (int i = 0; i < len; ++i) {\n        s += (char)('a' + rnd.next(26));\n    }\n    return s;\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<pair<string, int>> rounds;\n\n    if (type == \"random\") {\n        int M = min(n, 100);\n        set<string> name_set;\n        while (name_set.size() < M) {\n            string name = random_name();\n            name_set.insert(name);\n        }\n        vector<string> names(name_set.begin(), name_set.end());\n        map<string, int> cumulative_scores;\n        for (string name : names) cumulative_scores[name] = 0;\n\n        for (int i = 0; i < n; ++i) {\n            string name = names[rnd.next(0, M - 1)];\n            int score = rnd.next(-1000, 1000);\n            rounds.push_back(make_pair(name, score));\n            cumulative_scores[name] += score;\n        }\n\n        bool has_positive = false;\n        for (auto& kv : cumulative_scores) {\n            if (kv.second > 0) {\n                has_positive = true;\n                break;\n            }\n        }\n\n        if (!has_positive) {\n            // Adjust last occurrence of the player with maximum cumulative score\n            int max_score = INT_MIN;\n            string max_player;\n            for (auto& kv : cumulative_scores) {\n                if (kv.second > max_score) {\n                    max_score = kv.second;\n                    max_player = kv.first;\n                }\n            }\n            int delta = 1 - max_score;\n            for (int i = n - 1; i >= 0; --i) {\n                if (rounds[i].first == max_player) {\n                    rounds[i].second += delta;\n                    cumulative_scores[max_player] += delta;\n                    break;\n                }\n            }\n        }\n\n    } else if (type == \"tie\") {\n        int M = 3; // Number of players in tie\n        int m = 100;\n        set<string> name_set;\n        while (name_set.size() < M) {\n            string name = random_name();\n            name_set.insert(name);\n        }\n        vector<string> names(name_set.begin(), name_set.end());\n\n        map<string, int> cumulative_scores;\n        for (string name : names) cumulative_scores[name] = 0;\n\n        // Round 1: names[0] reaches m\n        rounds.push_back(make_pair(names[0], m));\n        cumulative_scores[names[0]] += m;\n        // Round 2: names[1] reaches m\n        rounds.push_back(make_pair(names[1], m));\n        cumulative_scores[names[1]] += m;\n        // Round 3: names[2] reaches m\n        rounds.push_back(make_pair(names[2], m));\n        cumulative_scores[names[2]] += m;\n\n        int current_round = 3;\n\n        while (current_round < n) {\n            string name = names[rnd.next(0, M - 1)];\n            int score = rnd.next(-1000, 1000);\n            rounds.push_back(make_pair(name, score));\n            cumulative_scores[name] += score;\n            current_round++;\n        }\n\n        // Adjust cumulative scores to ensure tie at m\n        for (int i = 0; i < M; ++i) {\n            string name = names[i];\n            if (cumulative_scores[name] != m) {\n                int delta = m - cumulative_scores[name];\n                // Find last occurrence of name in rounds\n                for (int j = rounds.size() - 1; j >= 0; --j) {\n                    if (rounds[j].first == name) {\n                        rounds[j].second += delta;\n                        cumulative_scores[name] += delta;\n                        break;\n                    }\n                }\n            }\n        }\n\n    } else if (type == \"earlywin\") {\n        vector<string> names;\n        names.push_back(random_name()); // Player A\n        names.push_back(random_name()); // Player B\n\n        map<string, int> cumulative_scores;\n        cumulative_scores[names[0]] = 0;\n        cumulative_scores[names[1]] = 0;\n\n        // Round 1: A +10\n        rounds.push_back(make_pair(names[0], 10));\n        cumulative_scores[names[0]] += 10;\n\n        // Round 2: B +5\n        rounds.push_back(make_pair(names[1], 5));\n        cumulative_scores[names[1]] += 5;\n\n        // Round 3: B +6\n        rounds.push_back(make_pair(names[1], 6));\n        cumulative_scores[names[1]] += 6;\n\n        int current_round = 3;\n\n        while (current_round < n) {\n            int idx = rnd.next(0, 1);\n            string name = names[idx];\n            int score = rnd.next(-1000, 1000);\n            cumulative_scores[name] += score;\n            rounds.push_back(make_pair(name, score));\n            current_round++;\n        }\n\n        if (cumulative_scores[names[1]] <= cumulative_scores[names[0]]) {\n            int delta = cumulative_scores[names[0]] - cumulative_scores[names[1]] + 1;\n            for (int i = rounds.size() - 1; i >= 0; --i) {\n                if (rounds[i].first == names[1]) {\n                    rounds[i].second += delta;\n                    cumulative_scores[names[1]] += delta;\n                    break;\n                }\n            }\n        }\n\n    } else {\n        // Default to random if unknown type\n        // Same as \"random\" type\n    }\n\n    // Output the rounds\n    printf(\"%d\\n\", n);\n    for (auto& pr : rounds) {\n        printf(\"%s %d\\n\", pr.first.c_str(), pr.second);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nstring random_name(int min_len = 1, int max_len = 32) {\n    int len = rnd.next(min_len, max_len);\n    string s;\n    for (int i = 0; i < len; ++i) {\n        s += (char)('a' + rnd.next(26));\n    }\n    return s;\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<pair<string, int>> rounds;\n\n    if (type == \"random\") {\n        int M = min(n, 100);\n        set<string> name_set;\n        while (name_set.size() < M) {\n            string name = random_name();\n            name_set.insert(name);\n        }\n        vector<string> names(name_set.begin(), name_set.end());\n        map<string, int> cumulative_scores;\n        for (string name : names) cumulative_scores[name] = 0;\n\n        for (int i = 0; i < n; ++i) {\n            string name = names[rnd.next(0, M - 1)];\n            int score = rnd.next(-1000, 1000);\n            rounds.push_back(make_pair(name, score));\n            cumulative_scores[name] += score;\n        }\n\n        bool has_positive = false;\n        for (auto& kv : cumulative_scores) {\n            if (kv.second > 0) {\n                has_positive = true;\n                break;\n            }\n        }\n\n        if (!has_positive) {\n            // Adjust last occurrence of the player with maximum cumulative score\n            int max_score = INT_MIN;\n            string max_player;\n            for (auto& kv : cumulative_scores) {\n                if (kv.second > max_score) {\n                    max_score = kv.second;\n                    max_player = kv.first;\n                }\n            }\n            int delta = 1 - max_score;\n            for (int i = n - 1; i >= 0; --i) {\n                if (rounds[i].first == max_player) {\n                    rounds[i].second += delta;\n                    cumulative_scores[max_player] += delta;\n                    break;\n                }\n            }\n        }\n\n    } else if (type == \"tie\") {\n        int M = 3; // Number of players in tie\n        int m = 100;\n        set<string> name_set;\n        while (name_set.size() < M) {\n            string name = random_name();\n            name_set.insert(name);\n        }\n        vector<string> names(name_set.begin(), name_set.end());\n\n        map<string, int> cumulative_scores;\n        for (string name : names) cumulative_scores[name] = 0;\n\n        // Round 1: names[0] reaches m\n        rounds.push_back(make_pair(names[0], m));\n        cumulative_scores[names[0]] += m;\n        // Round 2: names[1] reaches m\n        rounds.push_back(make_pair(names[1], m));\n        cumulative_scores[names[1]] += m;\n        // Round 3: names[2] reaches m\n        rounds.push_back(make_pair(names[2], m));\n        cumulative_scores[names[2]] += m;\n\n        int current_round = 3;\n\n        while (current_round < n) {\n            string name = names[rnd.next(0, M - 1)];\n            int score = rnd.next(-1000, 1000);\n            rounds.push_back(make_pair(name, score));\n            cumulative_scores[name] += score;\n            current_round++;\n        }\n\n        // Adjust cumulative scores to ensure tie at m\n        for (int i = 0; i < M; ++i) {\n            string name = names[i];\n            if (cumulative_scores[name] != m) {\n                int delta = m - cumulative_scores[name];\n                // Find last occurrence of name in rounds\n                for (int j = rounds.size() - 1; j >= 0; --j) {\n                    if (rounds[j].first == name) {\n                        rounds[j].second += delta;\n                        cumulative_scores[name] += delta;\n                        break;\n                    }\n                }\n            }\n        }\n\n    } else if (type == \"earlywin\") {\n        vector<string> names;\n        names.push_back(random_name()); // Player A\n        names.push_back(random_name()); // Player B\n\n        map<string, int> cumulative_scores;\n        cumulative_scores[names[0]] = 0;\n        cumulative_scores[names[1]] = 0;\n\n        // Round 1: A +10\n        rounds.push_back(make_pair(names[0], 10));\n        cumulative_scores[names[0]] += 10;\n\n        // Round 2: B +5\n        rounds.push_back(make_pair(names[1], 5));\n        cumulative_scores[names[1]] += 5;\n\n        // Round 3: B +6\n        rounds.push_back(make_pair(names[1], 6));\n        cumulative_scores[names[1]] += 6;\n\n        int current_round = 3;\n\n        while (current_round < n) {\n            int idx = rnd.next(0, 1);\n            string name = names[idx];\n            int score = rnd.next(-1000, 1000);\n            cumulative_scores[name] += score;\n            rounds.push_back(make_pair(name, score));\n            current_round++;\n        }\n\n        if (cumulative_scores[names[1]] <= cumulative_scores[names[0]]) {\n            int delta = cumulative_scores[names[0]] - cumulative_scores[names[1]] + 1;\n            for (int i = rounds.size() - 1; i >= 0; --i) {\n                if (rounds[i].first == names[1]) {\n                    rounds[i].second += delta;\n                    cumulative_scores[names[1]] += delta;\n                    break;\n                }\n            }\n        }\n\n    } else {\n        // Default to random if unknown type\n        // Same as \"random\" type\n    }\n\n    // Output the rounds\n    printf(\"%d\\n\", n);\n    for (auto& pr : rounds) {\n        printf(\"%s %d\\n\", pr.first.c_str(), pr.second);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -type random\n./gen -n 2 -type random\n./gen -n 5 -type random\n./gen -n 10 -type random\n./gen -n 100 -type random\n./gen -n 500 -type random\n./gen -n 999 -type random\n./gen -n 1000 -type random\n\n./gen -n 3 -type tie\n./gen -n 10 -type tie\n./gen -n 100 -type tie\n./gen -n 500 -type tie\n./gen -n 1000 -type tie\n\n./gen -n 3 -type earlywin\n./gen -n 10 -type earlywin\n./gen -n 100 -type earlywin\n./gen -n 500 -type earlywin\n./gen -n 1000 -type earlywin\n\n./gen -n 1 -type random\n./gen -n 1000 -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T19:47:41.329979",
        "total_tutorials": 3,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "2/B",
      "title": "B. The least round way",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test64 megabytes",
      "input_spec": "InputThe first line contains an integer number n (2 ≤ n ≤ 1000), n is the size of the matrix. Then follow n lines containing the matrix elements (non-negative integer numbers not exceeding 109).",
      "output_spec": "OutputIn the first line print the least number of trailing zeros. In the second line print the correspondent way itself.",
      "sample_tests": "ExamplesInputCopy31 2 34 5 67 8 9OutputCopy0DDRR",
      "description": "B. The least round way\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test64 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains an integer number n (2 ≤ n ≤ 1000), n is the size of the matrix. Then follow n lines containing the matrix elements (non-negative integer numbers not exceeding 109).\n\nOutputIn the first line print the least number of trailing zeros. In the second line print the correspondent way itself.\n\nInputCopy31 2 34 5 67 8 9OutputCopy0DDRR\n\nInputCopy31 2 34 5 67 8 9\n\nOutputCopy0DDRR",
      "solutions": [
        {
          "title": "Codeforces Beta Round #2 - Codeforces",
          "content": "Thank you all for participating in Codeforces Beta Round # 2. I hope you enjoyed it. You may discuss the problems and system in comments. Please express your opinion, especially if you notice any inappropriate behavior. And as always, I will read with interest the suggestions for improvement. Congratulations to the three leaders: RAVEman, GarnetCrow and ivan.popelyshev! See you at Codeforces Beta Round # 3. P.S. And by the way, the round tutorial is waiting for a volunteer. It is desirable that it will be one of the leaders of today's competition. The tutorial should be in Russian and in English. It will be published on the homepage and later will be available via special link from the contest page.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/97",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.6,
            "reason": "宽松匹配: 包含题目编号 2 和字母"
          },
          "content_length": 708
        },
        {
          "title": "Codeforces Beta Round #2 - Another Tutorial - Codeforces",
          "content": "Lets start from the end.Problem С. Commentator problemLet R be the distance from point А to a circle with center О and radius r. From this point the circle is observed at the angle . So, the three stadiums are observed at the same angle if R1 / r1 = R2 / r2 = R3 / r3. Take two different points A, B. The set of points C that AC / BC = const is either a line (perpendicular bisector of AB) or a circle with center somewhere on the line AB. This circle is easy to find. It contains two points that lie on AB and satisfy AC / BC condition. Let X1 be the set of points from which stadiums 1 and 2 are observed at the same angle. Let X2 be the set of points from which stadiums 2 and 3 are observed at the same angle. The answer belongs to both X1 and X2 . The centers of the three stadiums don't lie on one line, so the number of points in the intersection of  X1 and X2 will be finite.Check them all. The answer is the point that lies closer to any of the stadiums. The stadiums don't intersect, so that point will not lie inside any of them.How to get a big circle for X1 : put the centers of the stadiums in the points far away, for example in (0, 0) and (1000, 0). The ratio of the radii should be the closer possible to 1, for example . The center and the radius of the new circle will have the order 106 . The answer should be known with 10 - 5 precision. Roofly speaking, we need 11 digits, double precision will be enough.Problem B. The least round wayLet us solve the problem in the case of positive matrix.Let the number in the end be N = 2k· 5m·(other primes). The number of zeroes at the end of N is equal to min(k, m). At the aid of dynamic programming find minimal value of k (let it be k1) and minimal value of m (let it be m1), and paths that lead to these values. In case of k1 < m1 choose the path corresponding to k1, else  m1. So min(k, m) is the upper bound for the answer. Let us prove that it is the lower bound too. If there exists a path leading to a number with number of zeroes less than min(k, m) then in the factorization of that number the power of two is k < k1 or the power of five is m < m1. We come to a contradiction.So we need to calculate the power of 2 and 5 in the factorization of each value in the matrix and use dynamic programming on each of the two matrices. In the case of matrix containing zeroes, calculate separately the best path not containing zeroes and any path containing zeroes:Replace all 0 by 10 and use the method described above. For paths containing zeroes the result will contain at least one zero at the end. If the method returned a number without zeroes at the end, the corresponding path is the answer, else any path containing zeroes is the answer.The complexity of the algorithm depends on the complexity of the dynamics, it is O(N· M).Problem A. Winner Simple problem, just code it. At the first pass calculate the sum of points for each player at game end. Let M be the maximum of these sums. At the second pass check every round. If current player X has not less than M points and his final score is equal to M then he is the winner. The following test illustrates that player could receive more than M points, then lose some and, finally, win. Input: Masha 12 Masha -5 Sasha 10 Masha 3 Output: Masha",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/107",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 2\\s*B"
          },
          "content_length": 3266
        },
        {
          "title": "Codeforces Beta Round #2 - Tutorial - Codeforces",
          "content": "Problem A. Winner To solve the problem we just need accurately follow all rules described in the problem statement. Let's describe in more details required sequence of actions. First of all, we need to find the maximum score m at the end of the game. This can be done by emulating. After all rounds played just iterate over players and choose one with the maximum score. Second, we need to figure out the set of players who have maximum score at the end of the game. We can do this in the same way as calculating maximum score. Just iterate over players after all rounds played and store all players with score equal to m. And the last, we need to find a winner. To do this we will emulate the game one more time looking for player from the winner list with score not less m after some round. This task demonstrates that sometimes it is easier to code everything stated in the problem statement, than thinking and optimizing. Problem B. The least round way First of all, let's consider a case when there is at least one zero number in the square. In this case we can easily create a way with only one trailing zero in resulting multiplication - just output way over this zero number. The only case when this is not optimal way is when a way exists with no trailing zeroes at all. So, we can replace all 0's with 10's and solve the problem in general case. If there is an answer with no trailing zeroes - we will choose this one, otherwise we will output way over zero number. So, we can consider that all numbers in the square are positive. Let's understand what the number of zeroes in the resulting multiplication is. If we go along a way and count number of 2's and 5's in numbers factorization then the number of trailing zeros will be min(number of 2's, number of 5's). This allows us to solve the problem independently for 2's and 5's. The final answer will be just a minimum over these two solutions. Now, the last thing left is to solve the problem for 2's and 5's. New problem interpretation is the following: there is a square with numbers inside. We are to find a way with the minimal sum of the number over the way. This is classical dynamic programming problem. Let's consider that A[r,c] is the number in cell (r,c) and D[r,c] is the answer for this cell. Then D[r,c] = min(D[r-1,c],D[r,c-1]) + A[r][c] Problem C. Commentator problem. Let's take two stadiums and find out a set of points from which the stadiums are observed at the same angle. Not very hard mathematical calculation shows that this is a line if stadiums have the same radius and this is a circle if they have different radiuses. Let's define S(i,j) as a set of points from which the stadiums i and j are observed at the same angle. Given that centers of stadiums are not on the same line, the intersection of S(1,2) with S(1,3) contains no more than two points. If we know these no more that 2 points we can double-check that they satisfy the criteria and chose the point with the maximum angle of observation.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/109",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.6,
            "reason": "宽松匹配: 包含题目编号 2 和字母"
          },
          "content_length": 2991
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Beta Round #2 - Another Tutorial - Codeforces - Code 1",
          "code": "Test: #31, time: 3421 ms., memory: 172 KB, exit code: 0, checker exit code: 1, verdict: WRONG_ANSWER\n...\nChecker Log\nwrong answer Jury has better answer: ja=1 vs pa=2974",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/107",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Beta Round #2 - Another Tutorial - Codeforces - Code 2",
          "code": "Test: #31, time: 3421 ms., memory: 172 KB, exit code: 0, checker exit code: 1, verdict: WRONG_ANSWER\n...\nChecker Log\nwrong answer Jury has better answer: ja=1 vs pa=2974",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/107",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Beta Round #2 - Another Tutorial - Codeforces - Code 3",
          "code": "4\na 10\nb 2\nb 3\na -10",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/107",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Beta Round #2 - Another Tutorial - Codeforces - Code 4",
          "code": "int n;\nmap<string, int> score_board;\nmap<int, vector<string>> rev_board;\n\n\n\nvoid solve() {\n\n\tcin >> n;\n\n\tfor(int i=0; i<n; ++i) {\n\t\n\t\tstring name;\n\t\tint score;\n\n\t\tcin >> name >> score;\n\n\t\tscore_board[name] += score;\n\t\trev_board[score_board[name]].push_back(name);\n\n\t}\n\n\t\n\tauto it=rev_board.end();\n\t--it;\n\n\tcout << it->second[0];\n\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/107",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Beta Round #2 - Another Tutorial - Codeforces - Code 5",
          "code": "int n;\nmap<string, int> score_board;\nmap<int, vector<string>> rev_board;\n\n\n\nvoid solve() {\n\n\tcin >> n;\n\n\tfor(int i=0; i<n; ++i) {\n\t\n\t\tstring name;\n\t\tint score;\n\n\t\tcin >> name >> score;\n\n\t\tscore_board[name] += score;\n\t\trev_board[score_board[name]].push_back(name);\n\n\t}\n\n\t\n\tauto it=rev_board.end();\n\t--it;\n\n\tcout << it->second[0];\n\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/107",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(2, 1000, \"n\");\n    inf.readEoln();\n\n    for (int i = 0; i < n; ++i) {\n        vector<int> row = inf.readInts(n, 0, 1000000000);\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(2, 1000, \"n\");\n    inf.readEoln();\n\n    for (int i = 0; i < n; ++i) {\n        vector<int> row = inf.readInts(n, 0, 1000000000);\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(2, 1000, \"n\");\n    inf.readEoln();\n\n    for (int i = 0; i < n; ++i) {\n        vector<int> row = inf.readInts(n, 0, 1000000000);\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\n// A small function to count how many times an integer x is divisible by p\nint countFactors(long long x, int p) {\n    int cnt = 0;\n    while (x > 0 && x % p == 0) {\n        x /= p;\n        cnt++;\n    }\n    return cnt;\n}\n\n// This function reads the contestant (or jury) output from 'stream', checks correctness,\n// and returns the number of trailing zeros counted on the path. If the output is invalid, it reports WA or FAIL.\nlong long readAndCheck(InStream &stream, const vector<vector<int>> &matrix) {\n    int n = matrix.size();\n    \n    // Read the reported minimal number of trailing zeros.\n    long long claimedZeros = stream.readLong(0, 2'000'000'000LL, \"claimedZeros\");\n\n    // Read the path (string of D and R).\n    string path = stream.readToken(\"^[DR]*$\", \"path\");  // ensures only D or R\n    // The path length must be exactly (n - 1) + (n - 1) = 2*(n - 1)\n    if ((int)path.size() != 2 * (n - 1)) {\n        stream.quitf(_wa,\n            \"Path length is %d, but should be 2*(n-1) = %d if n=%d\",\n            path.size(), 2*(n - 1), n\n        );\n    }\n\n    // Traverse the path on the matrix, starting from (0,0)\n    int r = 0, c = 0;\n    // We'll sum up the counts of 2s and 5s along the path\n    long long totalTwos = 0, totalFives = 0;\n\n    // A function to add factors of matrix[r][c]\n    auto addCellFactors = [&](int rr, int cc) {\n        // factor out 2s and 5s from matrix[rr][cc]\n        // value can be up to 1e9, so long long is safe for multiplication factor checks\n        long long val = matrix[rr][cc];\n        totalTwos += countFactors(val, 2);\n        totalFives += countFactors(val, 5);\n    };\n\n    // Add factors at the starting cell\n    addCellFactors(r, c);\n\n    // Follow the path\n    for (char ch : path) {\n        if (ch == 'D') {\n            r++;\n        } else {\n            // ch == 'R'\n            c++;\n        }\n        // Check bounds\n        if (r < 0 || r >= n || c < 0 || c >= n) {\n            stream.quitf(_wa,\n                \"Path goes out of matrix bounds at step '%c' (r=%d, c=%d), matrix size=%d\",\n                ch, r, c, n\n            );\n        }\n        addCellFactors(r, c);\n    }\n    \n    // Must end in bottom-right cell\n    if (r != n - 1 || c != n - 1) {\n        stream.quitf(_wa, \"Path ends in (%d, %d) instead of bottom-right cell (%d, %d)\",\n            r, c, n - 1, n - 1);\n    }\n    \n    long long actualZeros = min(totalTwos, totalFives);\n    // Check if claimedZeros matches actualZeros\n    if (actualZeros != claimedZeros) {\n        stream.quitf(_wa,\n            \"Claimed trailing zeros = %lld but computed = %lld\",\n            claimedZeros, actualZeros\n        );\n    }\n    \n    return actualZeros;\n}\n\nint main(int argc, char* argv[]) {\n    registerTestlibCmd(argc, argv);\n\n    // Read input\n    int n = inf.readInt(2, 1000);\n    vector<vector<int>> matrix(n, vector<int>(n));\n    for(int i = 0; i < n; i++){\n        for(int j = 0; j < n; j++){\n            matrix[i][j] = inf.readInt(0, 1000000000);\n        }\n    }\n\n    // First, read jury's answer.\n    long long jVal = readAndCheck(ans, matrix);\n\n    // Then, read participant's answer.\n    long long pVal = readAndCheck(ouf, matrix);\n\n    // Compare\n    if (pVal > jVal) {\n        // participant has more trailing zeros => worse result => WA\n        quitf(_wa, \"participant's trailing zeros=%lld, jury's trailing zeros=%lld\", pVal, jVal);\n    } else if (pVal < jVal) {\n        // participant has fewer trailing zeros => better result => fail (problem in official answer)\n        quitf(_fail, \"participant's answer is better: participant's trailing zeros=%lld, jury's trailing zeros=%lld\", pVal, jVal);\n    } else {\n        // they match\n        quitf(_ok, \"OK, trailing zeros=%lld\", pVal);\n    }\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<vector<int>> matrix(n, vector<int>(n));\n\n    if (type == \"random\") {\n        // Random numbers between 0 and 1e9\n        for(int i = 0; i < n; ++i)\n            for(int j = 0; j < n; ++j)\n                matrix[i][j] = rnd.next(0, 1000000000);\n    } else if (type == \"ones\") {\n        // All elements are 1\n        for(int i = 0; i < n; ++i)\n            for(int j = 0; j < n; ++j)\n                matrix[i][j] = 1;\n    } else if (type == \"zeros\") {\n        // All elements are 0\n        for(int i = 0; i < n; ++i)\n            for(int j = 0; j < n; ++j)\n                matrix[i][j] = 0;\n    } else if (type == \"ones_and_zeros\") {\n        // Elements are 0 or 1\n        for(int i = 0; i < n; ++i)\n            for(int j = 0; j < n; ++j)\n                matrix[i][j] = rnd.next(0, 1);\n    } else if (type == \"max_2s\") {\n        // Powers of 2 up to 2^29\n        int max_exp = 29;\n        for(int i = 0; i < n; ++i)\n            for(int j = 0; j < n; ++j)\n                matrix[i][j] = 1 << rnd.next(0, max_exp);\n    } else if (type == \"max_5s\") {\n        // Powers of 5 up to 5^12\n        int max_exp = 12;\n        vector<int> powers_of_5(max_exp + 1);\n        powers_of_5[0] = 1;\n        for(int e = 1; e <= max_exp; ++e)\n            powers_of_5[e] = powers_of_5[e-1] * 5;\n        for(int i = 0; i < n; ++i)\n            for(int j = 0; j < n; ++j)\n                matrix[i][j] = powers_of_5[rnd.next(0, max_exp)];\n    } else if (type == \"max_2s_and_5s\") {\n        // Products of powers of 2 and 5 up to 1e9\n        int max_e2 = 29;\n        int max_e5 = 12;\n        vector<long long> powers_of_2(max_e2 + 1);\n        vector<long long> powers_of_5(max_e5 + 1);\n        powers_of_2[0] = 1;\n        for(int e = 1; e <= max_e2; ++e)\n            powers_of_2[e] = powers_of_2[e-1] * 2;\n        powers_of_5[0] = 1;\n        for(int e = 1; e <= max_e5; ++e)\n            powers_of_5[e] = powers_of_5[e-1] * 5;\n        for(int i = 0; i < n; ++i)\n            for(int j = 0; j < n; ++j){\n                int e2 = rnd.next(0, max_e2);\n                int e5 = rnd.next(0, max_e5);\n                long long val = powers_of_2[e2] * powers_of_5[e5];\n                while(val > 1000000000){\n                    if(e2 > 0) e2--;\n                    else if (e5 > 0) e5--;\n                    else break;\n                    val = powers_of_2[e2] * powers_of_5[e5];\n                }\n                matrix[i][j] = (int)val;\n            }\n    } else if (type == \"path_of_zeros\") {\n        // Zeros along the main diagonal, large numbers elsewhere\n        long long max_val = 1000000000;\n        for(int i = 0; i < n; ++i){\n            for(int j = 0; j < n; ++j){\n                if(i == j){\n                    matrix[i][j] = 0;\n                }else{\n                    matrix[i][j] = (int)max_val;\n                }\n            }\n        }\n    } else if (type == \"forced_zero_path\") {\n        // Zeros along a random path from (0,0) to (n-1,n-1)\n        long long max_val = 1000000000;\n        for(int i = 0; i < n; ++i){\n            for(int j = 0; j < n; ++j){\n                matrix[i][j] = (int)max_val;\n            }\n        }\n        int x = 0, y = 0;\n        while(x < n-1 && y < n-1){\n            matrix[x][y] = 0;\n            if(rnd.next(0,1)) x++;\n            else y++;\n        }\n        while(x < n){\n            matrix[x][y] = 0;\n            x++;\n        }\n        while(y < n){\n            matrix[x-1][y] = 0;\n            y++;\n        }\n    } else if (type == \"large_numbers\") {\n        // Large numbers near 1e9\n        for(int i = 0; i < n; ++i)\n            for(int j = 0; j < n; ++j)\n                matrix[i][j] = 1000000000 - rnd.next(0, 10);\n    } else {\n        // Default to random\n        for(int i = 0; i < n; ++i)\n            for(int j = 0; j < n; ++j)\n                matrix[i][j] = rnd.next(0, 1000000000);\n    }\n\n    // Output the matrix\n    printf(\"%d\\n\", n);\n    for(int i = 0; i < n; ++i){\n        for(int j = 0; j < n; ++j){\n            if(j > 0) printf(\" \");\n            printf(\"%d\", matrix[i][j]);\n        }\n        printf(\"\\n\");\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<vector<int>> matrix(n, vector<int>(n));\n\n    if (type == \"random\") {\n        // Random numbers between 0 and 1e9\n        for(int i = 0; i < n; ++i)\n            for(int j = 0; j < n; ++j)\n                matrix[i][j] = rnd.next(0, 1000000000);\n    } else if (type == \"ones\") {\n        // All elements are 1\n        for(int i = 0; i < n; ++i)\n            for(int j = 0; j < n; ++j)\n                matrix[i][j] = 1;\n    } else if (type == \"zeros\") {\n        // All elements are 0\n        for(int i = 0; i < n; ++i)\n            for(int j = 0; j < n; ++j)\n                matrix[i][j] = 0;\n    } else if (type == \"ones_and_zeros\") {\n        // Elements are 0 or 1\n        for(int i = 0; i < n; ++i)\n            for(int j = 0; j < n; ++j)\n                matrix[i][j] = rnd.next(0, 1);\n    } else if (type == \"max_2s\") {\n        // Powers of 2 up to 2^29\n        int max_exp = 29;\n        for(int i = 0; i < n; ++i)\n            for(int j = 0; j < n; ++j)\n                matrix[i][j] = 1 << rnd.next(0, max_exp);\n    } else if (type == \"max_5s\") {\n        // Powers of 5 up to 5^12\n        int max_exp = 12;\n        vector<int> powers_of_5(max_exp + 1);\n        powers_of_5[0] = 1;\n        for(int e = 1; e <= max_exp; ++e)\n            powers_of_5[e] = powers_of_5[e-1] * 5;\n        for(int i = 0; i < n; ++i)\n            for(int j = 0; j < n; ++j)\n                matrix[i][j] = powers_of_5[rnd.next(0, max_exp)];\n    } else if (type == \"max_2s_and_5s\") {\n        // Products of powers of 2 and 5 up to 1e9\n        int max_e2 = 29;\n        int max_e5 = 12;\n        vector<long long> powers_of_2(max_e2 + 1);\n        vector<long long> powers_of_5(max_e5 + 1);\n        powers_of_2[0] = 1;\n        for(int e = 1; e <= max_e2; ++e)\n            powers_of_2[e] = powers_of_2[e-1] * 2;\n        powers_of_5[0] = 1;\n        for(int e = 1; e <= max_e5; ++e)\n            powers_of_5[e] = powers_of_5[e-1] * 5;\n        for(int i = 0; i < n; ++i)\n            for(int j = 0; j < n; ++j){\n                int e2 = rnd.next(0, max_e2);\n                int e5 = rnd.next(0, max_e5);\n                long long val = powers_of_2[e2] * powers_of_5[e5];\n                while(val > 1000000000){\n                    if(e2 > 0) e2--;\n                    else if (e5 > 0) e5--;\n                    else break;\n                    val = powers_of_2[e2] * powers_of_5[e5];\n                }\n                matrix[i][j] = (int)val;\n            }\n    } else if (type == \"path_of_zeros\") {\n        // Zeros along the main diagonal, large numbers elsewhere\n        long long max_val = 1000000000;\n        for(int i = 0; i < n; ++i){\n            for(int j = 0; j < n; ++j){\n                if(i == j){\n                    matrix[i][j] = 0;\n                }else{\n                    matrix[i][j] = (int)max_val;\n                }\n            }\n        }\n    } else if (type == \"forced_zero_path\") {\n        // Zeros along a random path from (0,0) to (n-1,n-1)\n        long long max_val = 1000000000;\n        for(int i = 0; i < n; ++i){\n            for(int j = 0; j < n; ++j){\n                matrix[i][j] = (int)max_val;\n            }\n        }\n        int x = 0, y = 0;\n        while(x < n-1 && y < n-1){\n            matrix[x][y] = 0;\n            if(rnd.next(0,1)) x++;\n            else y++;\n        }\n        while(x < n){\n            matrix[x][y] = 0;\n            x++;\n        }\n        while(y < n){\n            matrix[x-1][y] = 0;\n            y++;\n        }\n    } else if (type == \"large_numbers\") {\n        // Large numbers near 1e9\n        for(int i = 0; i < n; ++i)\n            for(int j = 0; j < n; ++j)\n                matrix[i][j] = 1000000000 - rnd.next(0, 10);\n    } else {\n        // Default to random\n        for(int i = 0; i < n; ++i)\n            for(int j = 0; j < n; ++j)\n                matrix[i][j] = rnd.next(0, 1000000000);\n    }\n\n    // Output the matrix\n    printf(\"%d\\n\", n);\n    for(int i = 0; i < n; ++i){\n        for(int j = 0; j < n; ++j){\n            if(j > 0) printf(\" \");\n            printf(\"%d\", matrix[i][j]);\n        }\n        printf(\"\\n\");\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 2 -type ones\n./gen -n 2 -type zeros\n./gen -n 2 -type ones_and_zeros\n./gen -n 2 -type random\n\n./gen -n 5 -type ones\n./gen -n 5 -type zeros\n./gen -n 5 -type max_2s\n./gen -n 5 -type max_5s\n./gen -n 5 -type max_2s_and_5s\n\n./gen -n 10 -type random\n./gen -n 10 -type ones_and_zeros\n./gen -n 10 -type path_of_zeros\n./gen -n 10 -type forced_zero_path\n\n./gen -n 50 -type random\n./gen -n 50 -type max_2s\n./gen -n 50 -type max_5s\n./gen -n 50 -type max_2s_and_5s\n./gen -n 50 -type path_of_zeros\n./gen -n 50 -type forced_zero_path\n\n./gen -n 100 -type random\n./gen -n 100 -type ones\n./gen -n 100 -type zeros\n./gen -n 100 -type ones_and_zeros\n\n./gen -n 200 -type max_2s\n./gen -n 200 -type max_5s\n./gen -n 200 -type max_2s_and_5s\n\n./gen -n 500 -type random\n./gen -n 500 -type large_numbers\n\n./gen -n 1000 -type random\n./gen -n 1000 -type max_2s\n./gen -n 1000 -type max_5s\n./gen -n 1000 -type max_2s_and_5s\n./gen -n 1000 -type path_of_zeros\n./gen -n 1000 -type forced_zero_path\n./gen -n 1000 -type large_numbers\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T19:47:43.403457",
        "total_tutorials": 3,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "2/C",
      "title": "C. Commentator problem",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test64 megabytes",
      "input_spec": "InputThe input data consists of three lines, each of them describes the position of one stadium. The lines have the format x,  y,  r, where (x, y) are the coordinates of the stadium's center ( -  103 ≤ x,  y ≤ 103), and r (1 ≤ r  ≤ 103) is its radius. All the numbers in the input data are integer, stadiums do not have common points, and their centers are not on the same line.",
      "output_spec": "OutputPrint the coordinates of the required point with five digits after the decimal point. If there is no answer meeting the conditions, the program shouldn't print anything. The output data should be left blank.",
      "sample_tests": "ExamplesInputCopy0 0 1060 0 1030 30 10OutputCopy30.00000 0.00000",
      "description": "C. Commentator problem\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test64 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe input data consists of three lines, each of them describes the position of one stadium. The lines have the format x,  y,  r, where (x, y) are the coordinates of the stadium's center ( -  103 ≤ x,  y ≤ 103), and r (1 ≤ r  ≤ 103) is its radius. All the numbers in the input data are integer, stadiums do not have common points, and their centers are not on the same line.\n\nOutputPrint the coordinates of the required point with five digits after the decimal point. If there is no answer meeting the conditions, the program shouldn't print anything. The output data should be left blank.\n\nInputCopy0 0 1060 0 1030 30 10OutputCopy30.00000 0.00000\n\nInputCopy0 0 1060 0 1030 30 10\n\nOutputCopy30.00000 0.00000",
      "solutions": [
        {
          "title": "Codeforces Beta Round #2 - Codeforces",
          "content": "Thank you all for participating in Codeforces Beta Round # 2. I hope you enjoyed it. You may discuss the problems and system in comments. Please express your opinion, especially if you notice any inappropriate behavior. And as always, I will read with interest the suggestions for improvement. Congratulations to the three leaders: RAVEman, GarnetCrow and ivan.popelyshev! See you at Codeforces Beta Round # 3. P.S. And by the way, the round tutorial is waiting for a volunteer. It is desirable that it will be one of the leaders of today's competition. The tutorial should be in Russian and in English. It will be published on the homepage and later will be available via special link from the contest page.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/97",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.6,
            "reason": "宽松匹配: 包含题目编号 2 和字母"
          },
          "content_length": 708
        },
        {
          "title": "Codeforces Beta Round #2 - Another Tutorial - Codeforces",
          "content": "Lets start from the end.Problem С. Commentator problemLet R be the distance from point А to a circle with center О and radius r. From this point the circle is observed at the angle . So, the three stadiums are observed at the same angle if R1 / r1 = R2 / r2 = R3 / r3. Take two different points A, B. The set of points C that AC / BC = const is either a line (perpendicular bisector of AB) or a circle with center somewhere on the line AB. This circle is easy to find. It contains two points that lie on AB and satisfy AC / BC condition. Let X1 be the set of points from which stadiums 1 and 2 are observed at the same angle. Let X2 be the set of points from which stadiums 2 and 3 are observed at the same angle. The answer belongs to both X1 and X2 . The centers of the three stadiums don't lie on one line, so the number of points in the intersection of  X1 and X2 will be finite.Check them all. The answer is the point that lies closer to any of the stadiums. The stadiums don't intersect, so that point will not lie inside any of them.How to get a big circle for X1 : put the centers of the stadiums in the points far away, for example in (0, 0) and (1000, 0). The ratio of the radii should be the closer possible to 1, for example . The center and the radius of the new circle will have the order 106 . The answer should be known with 10 - 5 precision. Roofly speaking, we need 11 digits, double precision will be enough.Problem B. The least round wayLet us solve the problem in the case of positive matrix.Let the number in the end be N = 2k· 5m·(other primes). The number of zeroes at the end of N is equal to min(k, m). At the aid of dynamic programming find minimal value of k (let it be k1) and minimal value of m (let it be m1), and paths that lead to these values. In case of k1 < m1 choose the path corresponding to k1, else  m1. So min(k, m) is the upper bound for the answer. Let us prove that it is the lower bound too. If there exists a path leading to a number with number of zeroes less than min(k, m) then in the factorization of that number the power of two is k < k1 or the power of five is m < m1. We come to a contradiction.So we need to calculate the power of 2 and 5 in the factorization of each value in the matrix and use dynamic programming on each of the two matrices. In the case of matrix containing zeroes, calculate separately the best path not containing zeroes and any path containing zeroes:Replace all 0 by 10 and use the method described above. For paths containing zeroes the result will contain at least one zero at the end. If the method returned a number without zeroes at the end, the corresponding path is the answer, else any path containing zeroes is the answer.The complexity of the algorithm depends on the complexity of the dynamics, it is O(N· M).Problem A. Winner Simple problem, just code it. At the first pass calculate the sum of points for each player at game end. Let M be the maximum of these sums. At the second pass check every round. If current player X has not less than M points and his final score is equal to M then he is the winner. The following test illustrates that player could receive more than M points, then lose some and, finally, win. Input: Masha 12 Masha -5 Sasha 10 Masha 3 Output: Masha",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/107",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.6,
            "reason": "宽松匹配: 包含题目编号 2 和字母"
          },
          "content_length": 3266
        },
        {
          "title": "Codeforces Beta Round #2 - Tutorial - Codeforces",
          "content": "Problem A. Winner To solve the problem we just need accurately follow all rules described in the problem statement. Let's describe in more details required sequence of actions. First of all, we need to find the maximum score m at the end of the game. This can be done by emulating. After all rounds played just iterate over players and choose one with the maximum score. Second, we need to figure out the set of players who have maximum score at the end of the game. We can do this in the same way as calculating maximum score. Just iterate over players after all rounds played and store all players with score equal to m. And the last, we need to find a winner. To do this we will emulate the game one more time looking for player from the winner list with score not less m after some round. This task demonstrates that sometimes it is easier to code everything stated in the problem statement, than thinking and optimizing. Problem B. The least round way First of all, let's consider a case when there is at least one zero number in the square. In this case we can easily create a way with only one trailing zero in resulting multiplication - just output way over this zero number. The only case when this is not optimal way is when a way exists with no trailing zeroes at all. So, we can replace all 0's with 10's and solve the problem in general case. If there is an answer with no trailing zeroes - we will choose this one, otherwise we will output way over zero number. So, we can consider that all numbers in the square are positive. Let's understand what the number of zeroes in the resulting multiplication is. If we go along a way and count number of 2's and 5's in numbers factorization then the number of trailing zeros will be min(number of 2's, number of 5's). This allows us to solve the problem independently for 2's and 5's. The final answer will be just a minimum over these two solutions. Now, the last thing left is to solve the problem for 2's and 5's. New problem interpretation is the following: there is a square with numbers inside. We are to find a way with the minimal sum of the number over the way. This is classical dynamic programming problem. Let's consider that A[r,c] is the number in cell (r,c) and D[r,c] is the answer for this cell. Then D[r,c] = min(D[r-1,c],D[r,c-1]) + A[r][c] Problem C. Commentator problem. Let's take two stadiums and find out a set of points from which the stadiums are observed at the same angle. Not very hard mathematical calculation shows that this is a line if stadiums have the same radius and this is a circle if they have different radiuses. Let's define S(i,j) as a set of points from which the stadiums i and j are observed at the same angle. Given that centers of stadiums are not on the same line, the intersection of S(1,2) with S(1,3) contains no more than two points. If we know these no more that 2 points we can double-check that they satisfy the criteria and chose the point with the maximum angle of observation.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/109",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.6,
            "reason": "宽松匹配: 包含题目编号 2 和字母"
          },
          "content_length": 2991
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Beta Round #2 - Another Tutorial - Codeforces - Code 1",
          "code": "Test: #31, time: 3421 ms., memory: 172 KB, exit code: 0, checker exit code: 1, verdict: WRONG_ANSWER\n...\nChecker Log\nwrong answer Jury has better answer: ja=1 vs pa=2974",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/107",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Beta Round #2 - Another Tutorial - Codeforces - Code 2",
          "code": "Test: #31, time: 3421 ms., memory: 172 KB, exit code: 0, checker exit code: 1, verdict: WRONG_ANSWER\n...\nChecker Log\nwrong answer Jury has better answer: ja=1 vs pa=2974",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/107",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Beta Round #2 - Another Tutorial - Codeforces - Code 3",
          "code": "4\na 10\nb 2\nb 3\na -10",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/107",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Beta Round #2 - Another Tutorial - Codeforces - Code 4",
          "code": "int n;\nmap<string, int> score_board;\nmap<int, vector<string>> rev_board;\n\n\n\nvoid solve() {\n\n\tcin >> n;\n\n\tfor(int i=0; i<n; ++i) {\n\t\n\t\tstring name;\n\t\tint score;\n\n\t\tcin >> name >> score;\n\n\t\tscore_board[name] += score;\n\t\trev_board[score_board[name]].push_back(name);\n\n\t}\n\n\t\n\tauto it=rev_board.end();\n\t--it;\n\n\tcout << it->second[0];\n\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/107",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Beta Round #2 - Another Tutorial - Codeforces - Code 5",
          "code": "int n;\nmap<string, int> score_board;\nmap<int, vector<string>> rev_board;\n\n\n\nvoid solve() {\n\n\tcin >> n;\n\n\tfor(int i=0; i<n; ++i) {\n\t\n\t\tstring name;\n\t\tint score;\n\n\t\tcin >> name >> score;\n\n\t\tscore_board[name] += score;\n\t\trev_board[score_board[name]].push_back(name);\n\n\t}\n\n\t\n\tauto it=rev_board.end();\n\t--it;\n\n\tcout << it->second[0];\n\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/107",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    const int MIN_XY = -1000;\n    const int MAX_XY = 1000;\n    const int MIN_R = 1;\n    const int MAX_R = 1000;\n\n    struct Stadium {\n        int x, y, r;\n    };\n\n    vector<Stadium> stadiums;\n\n    for (int i = 0; i < 3; ++i) {\n\n        int x = inf.readInt(MIN_XY, MAX_XY, \"x\");\n        inf.readSpace();\n        int y = inf.readInt(MIN_XY, MAX_XY, \"y\");\n        inf.readSpace();\n        int r = inf.readInt(MIN_R, MAX_R, \"r\");\n        inf.readEoln();\n\n        stadiums.push_back({x, y, r});\n    }\n\n    // Check that stadiums do not have common points\n    for (int i = 0; i < 3; ++i) {\n        for (int j = i+1; j < 3; ++j) {\n            int dx = stadiums[i].x - stadiums[j].x;\n            int dy = stadiums[i].y - stadiums[j].y;\n            long long dist_squared = 1LL*dx*dx + 1LL*dy*dy;\n            int sum_radii = stadiums[i].r + stadiums[j].r;\n            long long sum_radii_squared = 1LL*sum_radii*sum_radii;\n            ensuref(dist_squared > sum_radii_squared, \"Stadiums %d and %d have common points\", i+1, j+1);\n        }\n    }\n\n    // Ensure that their centers are not on the same line\n    int x1 = stadiums[0].x, y1 = stadiums[0].y;\n    int x2 = stadiums[1].x, y2 = stadiums[1].y;\n    int x3 = stadiums[2].x, y3 = stadiums[2].y;\n\n    int area2 = x1*(y2 - y3) + x2*(y3 - y1) + x3*(y1 - y2);\n    ensuref(area2 != 0, \"Stadium centers are colinear\");\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    const int MIN_XY = -1000;\n    const int MAX_XY = 1000;\n    const int MIN_R = 1;\n    const int MAX_R = 1000;\n\n    struct Stadium {\n        int x, y, r;\n    };\n\n    vector<Stadium> stadiums;\n\n    for (int i = 0; i < 3; ++i) {\n\n        int x = inf.readInt(MIN_XY, MAX_XY, \"x\");\n        inf.readSpace();\n        int y = inf.readInt(MIN_XY, MAX_XY, \"y\");\n        inf.readSpace();\n        int r = inf.readInt(MIN_R, MAX_R, \"r\");\n        inf.readEoln();\n\n        stadiums.push_back({x, y, r});\n    }\n\n    // Check that stadiums do not have common points\n    for (int i = 0; i < 3; ++i) {\n        for (int j = i+1; j < 3; ++j) {\n            int dx = stadiums[i].x - stadiums[j].x;\n            int dy = stadiums[i].y - stadiums[j].y;\n            long long dist_squared = 1LL*dx*dx + 1LL*dy*dy;\n            int sum_radii = stadiums[i].r + stadiums[j].r;\n            long long sum_radii_squared = 1LL*sum_radii*sum_radii;\n            ensuref(dist_squared > sum_radii_squared, \"Stadiums %d and %d have common points\", i+1, j+1);\n        }\n    }\n\n    // Ensure that their centers are not on the same line\n    int x1 = stadiums[0].x, y1 = stadiums[0].y;\n    int x2 = stadiums[1].x, y2 = stadiums[1].y;\n    int x3 = stadiums[2].x, y3 = stadiums[2].y;\n\n    int area2 = x1*(y2 - y3) + x2*(y3 - y1) + x3*(y1 - y2);\n    ensuref(area2 != 0, \"Stadium centers are colinear\");\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    const int MIN_XY = -1000;\n    const int MAX_XY = 1000;\n    const int MIN_R = 1;\n    const int MAX_R = 1000;\n\n    struct Stadium {\n        int x, y, r;\n    };\n\n    vector<Stadium> stadiums;\n\n    for (int i = 0; i < 3; ++i) {\n\n        int x = inf.readInt(MIN_XY, MAX_XY, \"x\");\n        inf.readSpace();\n        int y = inf.readInt(MIN_XY, MAX_XY, \"y\");\n        inf.readSpace();\n        int r = inf.readInt(MIN_R, MAX_R, \"r\");\n        inf.readEoln();\n\n        stadiums.push_back({x, y, r});\n    }\n\n    // Check that stadiums do not have common points\n    for (int i = 0; i < 3; ++i) {\n        for (int j = i+1; j < 3; ++j) {\n            int dx = stadiums[i].x - stadiums[j].x;\n            int dy = stadiums[i].y - stadiums[j].y;\n            long long dist_squared = 1LL*dx*dx + 1LL*dy*dy;\n            int sum_radii = stadiums[i].r + stadiums[j].r;\n            long long sum_radii_squared = 1LL*sum_radii*sum_radii;\n            ensuref(dist_squared > sum_radii_squared, \"Stadiums %d and %d have common points\", i+1, j+1);\n        }\n    }\n\n    // Ensure that their centers are not on the same line\n    int x1 = stadiums[0].x, y1 = stadiums[0].y;\n    int x2 = stadiums[1].x, y2 = stadiums[1].y;\n    int x3 = stadiums[2].x, y3 = stadiums[2].y;\n\n    int area2 = x1*(y2 - y3) + x2*(y3 - y1) + x3*(y1 - y2);\n    ensuref(area2 != 0, \"Stadium centers are colinear\");\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nconst double EPS = 1E-6;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare two sequences of doubles, max absolute or relative  error = %.7f\", EPS);\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    double j = 0, p = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        n++;\r\n        j = ans.readDouble();\r\n        p = ouf.readDouble();\r\n        if (!doubleCompare(j, p, EPS)) {\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%.7f', found: '%.7f', error = '%.7f'\",\r\n                  n, englishEnding(n).c_str(), j, p, doubleDelta(j, p));\r\n        }\r\n    }\r\n\r\n    if (n == 1)\r\n        quitf(_ok, \"found '%.7f', expected '%.7f', error '%.7f'\", p, j, doubleDelta(j, p));\r\n\r\n    quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nbool areColinear(int x1, int y1, int x2, int y2, int x3, int y3) {\n    long long area2 = (long long)(x1)*(y2 - y3) + (long long)(x2)*(y3 - y1) + (long long)(x3)*(y1 - y2);\n    return area2 == 0LL;\n}\n\nlong long dist2(int x1, int y1, int x2, int y2) {\n    return (long long)(x1 - x2)*(x1 - x2) + (long long)(y1 - y2)*(y1 - y2);\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int max_coord = opt<int>(\"max_coord\", 1000);\n    int max_radius = opt<int>(\"max_radius\", 1000);\n    string type = opt<string>(\"type\", \"random\");\n\n    int r1 = opt<int>(\"r1\", -1);\n    int r2 = opt<int>(\"r2\", -1);\n    int r3 = opt<int>(\"r3\", -1);\n\n    int x1, y1, x2, y2, x3, y3;\n\n    if (type == \"random\") {\n        int attempts = 0;\n        while (true) {\n            attempts++;\n            if (attempts > 10000) {\n                cerr << \"Failed to generate valid test case after 10000 attempts.\" << endl;\n                exit(1);\n            }\n\n            x1 = rnd.next(-max_coord, max_coord);\n            y1 = rnd.next(-max_coord, max_coord);\n            x2 = rnd.next(-max_coord, max_coord);\n            y2 = rnd.next(-max_coord, max_coord);\n            x3 = rnd.next(-max_coord, max_coord);\n            y3 = rnd.next(-max_coord, max_coord);\n\n            if (r1 == -1) r1 = rnd.next(1, max_radius);\n            if (r2 == -1) r2 = rnd.next(1, max_radius);\n            if (r3 == -1) r3 = rnd.next(1, max_radius);\n\n            if (areColinear(x1, y1, x2, y2, x3, y3)) continue;\n\n            long long d12 = dist2(x1, y1, x2, y2);\n            long long min_dist12 = ((long long)(r1 + r2)) * ((long long)(r1 + r2));\n            if (d12 < min_dist12) continue;\n\n            long long d13 = dist2(x1, y1, x3, y3);\n            long long min_dist13 = ((long long)(r1 + r3)) * ((long long)(r1 + r3));\n            if (d13 < min_dist13) continue;\n\n            long long d23 = dist2(x2, y2, x3, y3);\n            long long min_dist23 = ((long long)(r2 + r3)) * ((long long)(r2 + r3));\n            if (d23 < min_dist23) continue;\n\n            break;\n        }\n\n    } else if (type == \"symmetric\") {\n        int d = rnd.next(1, max_coord / 2);\n        x1 = 0;\n        y1 = 0;\n        x2 = d;\n        y2 = 0;\n        x3 = d/2;\n        double h = d * sqrt(3) / 2.0;\n        y3 = (int)h;\n        if (areColinear(x1, y1, x2, y2, x3, y3)) {\n            y3++;  // Adjust to make sure not colinear\n        }\n        if (r1 == -1) r1 = rnd.next(1, max_radius);\n        if (r2 == -1) r2 = rnd.next(1, max_radius);\n        if (r3 == -1) r3 = rnd.next(1, max_radius);\n    } else if (type == \"no_answer\") {\n        // Place stadiums very far apart\n        x1 = -max_coord;\n        y1 = -max_coord;\n        x2 = max_coord;\n        y2 = -max_coord;\n        x3 = 0;\n        y3 = max_coord;\n        if (r1 == -1) r1 = rnd.next(1, max_radius);\n        if (r2 == -1) r2 = rnd.next(1, max_radius);\n        if (r3 == -1) r3 = rnd.next(1, max_radius);\n\n    } else if (type == \"overlapping\") {\n        // Place stadiums close to each other, but not overlapping\n        x1 = 0;\n        y1 = 0;\n        if (r1 == -1) r1 = max_radius;\n        x2 = x1 + r1 + 1;\n        y2 = y1;\n        if (r2 == -1) r2 = 1;\n        x3 = x1;\n        y3 = y1 + r1 + r2 + 1;\n        if (r3 == -1) r3 = 1;\n        if (areColinear(x1, y1, x2, y2, x3, y3)) {\n            y3 += 1; // Adjust\n        }\n    } else if (type == \"touching\") {\n        // Place stadiums so that they are just touching, but not overlapping\n        x1 = 0;\n        y1 = 0;\n        if (r1 == -1) r1 = rnd.next(1, max_radius);\n        x2 = x1 + 2*r1;\n        y2 = y1;\n        if (r2 == -1) r2 = r1;\n        x3 = x1 + r1;\n        y3 = y1 + (int)(r1 * sqrt(3));\n        if (r3 == -1) r3 = r1;\n        if (areColinear(x1, y1, x2, y2, x3, y3)) {\n            y3 += 1; // Adjust\n        }\n    } else {\n        cerr << \"Unknown type: \" << type << endl;\n        exit(1);\n    }\n\n    // Output the stadiums\n    printf(\"%d %d %d\\n\", x1, y1, r1);\n    printf(\"%d %d %d\\n\", x2, y2, r2);\n    printf(\"%d %d %d\\n\", x3, y3, r3);\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nbool areColinear(int x1, int y1, int x2, int y2, int x3, int y3) {\n    long long area2 = (long long)(x1)*(y2 - y3) + (long long)(x2)*(y3 - y1) + (long long)(x3)*(y1 - y2);\n    return area2 == 0LL;\n}\n\nlong long dist2(int x1, int y1, int x2, int y2) {\n    return (long long)(x1 - x2)*(x1 - x2) + (long long)(y1 - y2)*(y1 - y2);\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int max_coord = opt<int>(\"max_coord\", 1000);\n    int max_radius = opt<int>(\"max_radius\", 1000);\n    string type = opt<string>(\"type\", \"random\");\n\n    int r1 = opt<int>(\"r1\", -1);\n    int r2 = opt<int>(\"r2\", -1);\n    int r3 = opt<int>(\"r3\", -1);\n\n    int x1, y1, x2, y2, x3, y3;\n\n    if (type == \"random\") {\n        int attempts = 0;\n        while (true) {\n            attempts++;\n            if (attempts > 10000) {\n                cerr << \"Failed to generate valid test case after 10000 attempts.\" << endl;\n                exit(1);\n            }\n\n            x1 = rnd.next(-max_coord, max_coord);\n            y1 = rnd.next(-max_coord, max_coord);\n            x2 = rnd.next(-max_coord, max_coord);\n            y2 = rnd.next(-max_coord, max_coord);\n            x3 = rnd.next(-max_coord, max_coord);\n            y3 = rnd.next(-max_coord, max_coord);\n\n            if (r1 == -1) r1 = rnd.next(1, max_radius);\n            if (r2 == -1) r2 = rnd.next(1, max_radius);\n            if (r3 == -1) r3 = rnd.next(1, max_radius);\n\n            if (areColinear(x1, y1, x2, y2, x3, y3)) continue;\n\n            long long d12 = dist2(x1, y1, x2, y2);\n            long long min_dist12 = ((long long)(r1 + r2)) * ((long long)(r1 + r2));\n            if (d12 < min_dist12) continue;\n\n            long long d13 = dist2(x1, y1, x3, y3);\n            long long min_dist13 = ((long long)(r1 + r3)) * ((long long)(r1 + r3));\n            if (d13 < min_dist13) continue;\n\n            long long d23 = dist2(x2, y2, x3, y3);\n            long long min_dist23 = ((long long)(r2 + r3)) * ((long long)(r2 + r3));\n            if (d23 < min_dist23) continue;\n\n            break;\n        }\n\n    } else if (type == \"symmetric\") {\n        int d = rnd.next(1, max_coord / 2);\n        x1 = 0;\n        y1 = 0;\n        x2 = d;\n        y2 = 0;\n        x3 = d/2;\n        double h = d * sqrt(3) / 2.0;\n        y3 = (int)h;\n        if (areColinear(x1, y1, x2, y2, x3, y3)) {\n            y3++;  // Adjust to make sure not colinear\n        }\n        if (r1 == -1) r1 = rnd.next(1, max_radius);\n        if (r2 == -1) r2 = rnd.next(1, max_radius);\n        if (r3 == -1) r3 = rnd.next(1, max_radius);\n    } else if (type == \"no_answer\") {\n        // Place stadiums very far apart\n        x1 = -max_coord;\n        y1 = -max_coord;\n        x2 = max_coord;\n        y2 = -max_coord;\n        x3 = 0;\n        y3 = max_coord;\n        if (r1 == -1) r1 = rnd.next(1, max_radius);\n        if (r2 == -1) r2 = rnd.next(1, max_radius);\n        if (r3 == -1) r3 = rnd.next(1, max_radius);\n\n    } else if (type == \"overlapping\") {\n        // Place stadiums close to each other, but not overlapping\n        x1 = 0;\n        y1 = 0;\n        if (r1 == -1) r1 = max_radius;\n        x2 = x1 + r1 + 1;\n        y2 = y1;\n        if (r2 == -1) r2 = 1;\n        x3 = x1;\n        y3 = y1 + r1 + r2 + 1;\n        if (r3 == -1) r3 = 1;\n        if (areColinear(x1, y1, x2, y2, x3, y3)) {\n            y3 += 1; // Adjust\n        }\n    } else if (type == \"touching\") {\n        // Place stadiums so that they are just touching, but not overlapping\n        x1 = 0;\n        y1 = 0;\n        if (r1 == -1) r1 = rnd.next(1, max_radius);\n        x2 = x1 + 2*r1;\n        y2 = y1;\n        if (r2 == -1) r2 = r1;\n        x3 = x1 + r1;\n        y3 = y1 + (int)(r1 * sqrt(3));\n        if (r3 == -1) r3 = r1;\n        if (areColinear(x1, y1, x2, y2, x3, y3)) {\n            y3 += 1; // Adjust\n        }\n    } else {\n        cerr << \"Unknown type: \" << type << endl;\n        exit(1);\n    }\n\n    // Output the stadiums\n    printf(\"%d %d %d\\n\", x1, y1, r1);\n    printf(\"%d %d %d\\n\", x2, y2, r2);\n    printf(\"%d %d %d\\n\", x3, y3, r3);\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -max_coord=10 -max_radius=5 -type=random\n./gen -max_coord=50 -max_radius=20 -type=random\n./gen -max_coord=100 -max_radius=30 -type=random\n./gen -max_coord=500 -max_radius=100 -type=random\n./gen -max_coord=1000 -max_radius=500 -type=random\n\n./gen -max_coord=10 -max_radius=5 -type=symmetric\n./gen -max_coord=50 -max_radius=20 -type=symmetric\n./gen -max_coord=100 -max_radius=30 -type=symmetric\n./gen -max_coord=500 -max_radius=100 -type=symmetric\n./gen -max_coord=1000 -max_radius=500 -type=symmetric\n\n./gen -max_coord=1000 -max_radius=500 -type=no_answer\n./gen -max_coord=1000 -max_radius=1000 -type=no_answer\n\n./gen -max_coord=100 -max_radius=50 -type=overlapping\n./gen -max_coord=1000 -max_radius=500 -type=overlapping\n\n./gen -max_coord=1000 -max_radius=1 -type=random\n./gen -max_coord=1000 -max_radius=1000 -type=random\n\n# Special cases with specific radii\n./gen -max_coord=1000 -max_radius=1000 -r1=1000 -r2=1 -r3=1 -type=random\n./gen -max_coord=1000 -max_radius=1000 -r1=1 -r2=1000 -r3=1 -type=random\n./gen -max_coord=1000 -max_radius=1000 -r1=1 -r2=1 -r3=1000 -type=random\n\n# Touching stadiums\n./gen -max_radius=10 -type=touching\n./gen -max_radius=50 -type=touching\n./gen -max_radius=100 -type=touching\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T19:47:45.544356",
        "total_tutorials": 3,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "20/A",
      "title": "A. BerOS file system",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test64 megabytes",
      "input_spec": "InputThe first line of the input contains only lowercase Latin letters and character '/' — the path to some directory. All paths start with at least one character '/'. The length of the given line is no more than 100 characters, it is not empty.",
      "output_spec": "OutputThe path in normalized form.",
      "sample_tests": "ExamplesInputCopy//usr///local//nginx/sbinOutputCopy/usr/local/nginx/sbin",
      "description": "A. BerOS file system\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test64 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line of the input contains only lowercase Latin letters and character '/' — the path to some directory. All paths start with at least one character '/'. The length of the given line is no more than 100 characters, it is not empty.\n\nOutputThe path in normalized form.\n\nInputCopy//usr///local//nginx/sbinOutputCopy/usr/local/nginx/sbin\n\nInputCopy//usr///local//nginx/sbin\n\nOutputCopy/usr/local/nginx/sbin",
      "solutions": [],
      "code_examples": [],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    string s = inf.readLine();\n    ensuref(s.length() >= 1 && s.length() <= 100, \"The length of path must be between 1 and 100, but it is %d\", (int)s.length());\n    ensuref(s[0] == '/', \"The path must start with '/'\");\n\n    for (int i = 0; i < (int)s.length(); i++) {\n        char c = s[i];\n        ensuref(c == '/' || (c >= 'a' && c <= 'z'), \"Invalid character '%c' in path\", c);\n    }\n    inf.readEof();\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    string s = inf.readLine();\n    ensuref(s.length() >= 1 && s.length() <= 100, \"The length of path must be between 1 and 100, but it is %d\", (int)s.length());\n    ensuref(s[0] == '/', \"The path must start with '/'\");\n\n    for (int i = 0; i < (int)s.length(); i++) {\n        char c = s[i];\n        ensuref(c == '/' || (c >= 'a' && c <= 'z'), \"Invalid character '%c' in path\", c);\n    }\n    inf.readEof();\n\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    string s = inf.readLine();\n    ensuref(s.length() >= 1 && s.length() <= 100, \"The length of path must be between 1 and 100, but it is %d\", (int)s.length());\n    ensuref(s[0] == '/', \"The path must start with '/'\");\n\n    for (int i = 0; i < (int)s.length(); i++) {\n        char c = s[i];\n        ensuref(c == '/' || (c >= 'a' && c <= 'z'), \"Invalid character '%c' in path\", c);\n    }\n    inf.readEof();\n\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare sequences of tokens\");\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string j, p;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n\r\n        ans.readWordTo(j);\r\n        ouf.readWordTo(p);\r\n\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s words differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  compress(j).c_str(), compress(p).c_str());\r\n    }\r\n\r\n    if (ans.seekEof() && ouf.seekEof()) {\r\n        if (n == 1)\r\n            quitf(_ok, \"\\\"%s\\\"\", compress(j).c_str());\r\n        else\r\n            quitf(_ok, \"%d tokens\", n);\r\n    } else {\r\n        if (ans.seekEof())\r\n            quitf(_wa, \"Participant output contains extra tokens\");\r\n        else\r\n            quitf(_wa, \"Unexpected EOF in the participants output\");\r\n    }\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");  // Maximum length of the path (up to 100)\n    string type = opt<string>(\"type\", \"random\");\n\n    // Ensure 'n' is between 1 and 100\n    n = max(1, min(n, 100));\n\n    string path;\n\n    if (type == \"slashes_only\") {\n        // Path consisting of only '/' characters\n        int length = rnd.next(1, n);\n        path = string(length, '/');\n    } else if (type == \"root_only\") {\n        // Path is just \"/\"\n        path = \"/\";\n    } else if (type == \"ends_with_slash\") {\n        // Path ending with multiple slashes\n        path = \"/\";\n        int length = 1;\n        while (length < n) {\n            // Add a component\n            int component_length = rnd.next(1, min(n - length, 10));\n            for (int i = 0; i < component_length && length < n; ++i) {\n                path += (char)rnd.next('a', 'z');\n                length++;\n            }\n\n            if (length >= n) break;\n\n            // Add multiple '/'\n            int num_slashes = rnd.next(1, min(n - length, 5));\n            path += string(num_slashes, '/');\n            length += num_slashes;\n        }\n        // Add extra slashes at the end if possible\n        if (length < n) {\n            int extra_slashes = min(n - length, 5);\n            path += string(extra_slashes, '/');\n            length += extra_slashes;\n        }\n    } else if (type == \"no_slashes\") {\n        // Path starting with '/' but containing no subsequent '/'\n        path = \"/\";\n        int remaining = n - 1;\n        for (int i = 0; i < remaining; ++i) {\n            path += (char)rnd.next('a', 'z');\n        }\n    } else if (type == \"single_component\") {\n        // Path with a single component\n        path = \"/\";\n        int remaining = n - 1;\n        for (int i = 0; i < remaining; ++i) {\n            path += (char)rnd.next('a', 'z');\n        }\n    } else if (type == \"max_components\") {\n        // Path with maximum number of components\n        path = \"/\";\n        int length = 1;\n        while (length < n) {\n            // Add '/' characters\n            int num_slashes = rnd.next(1, min(2, n - length));\n            path += string(num_slashes, '/');\n            length += num_slashes;\n\n            if (length >= n) break;\n\n            // Add a single character component\n            path += (char)rnd.next('a', 'z');\n            length++;\n        }\n    } else if (type == \"long\") {\n        // Long path with multiple components\n        path = \"/\";\n        int length = 1;\n        while (length < n) {\n            // Add a component\n            int component_length = rnd.next(1, min(10, n - length));\n            for (int i = 0; i < component_length && length < n; ++i) {\n                path += (char)rnd.next('a', 'z');\n                length++;\n            }\n            if (length >= n) break;\n\n            // Add '/'\n            path += '/';\n            length++;\n        }\n    } else {\n        // Random path\n        path = \"/\";\n        int length = 1;\n        while (length < n) {\n            int choice = rnd.next(0, 2);\n            if (choice == 0) {\n                // Add a lowercase letter\n                path += (char)rnd.next('a', 'z');\n                length++;\n            } else {\n                // Add one or more '/'\n                int num_slashes = rnd.next(1, min(5, n - length));\n                path += string(num_slashes, '/');\n                length += num_slashes;\n            }\n        }\n    }\n\n    // Ensure the path starts with at least one '/'\n    if (path.empty() || path[0] != '/') {\n        path = \"/\" + path;\n    }\n\n    // Truncate the path to length 'n' if necessary\n    if ((int)path.length() > n) {\n        path = path.substr(0, n);\n    }\n\n    // Output the path\n    printf(\"%s\\n\", path.c_str());\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");  // Maximum length of the path (up to 100)\n    string type = opt<string>(\"type\", \"random\");\n\n    // Ensure 'n' is between 1 and 100\n    n = max(1, min(n, 100));\n\n    string path;\n\n    if (type == \"slashes_only\") {\n        // Path consisting of only '/' characters\n        int length = rnd.next(1, n);\n        path = string(length, '/');\n    } else if (type == \"root_only\") {\n        // Path is just \"/\"\n        path = \"/\";\n    } else if (type == \"ends_with_slash\") {\n        // Path ending with multiple slashes\n        path = \"/\";\n        int length = 1;\n        while (length < n) {\n            // Add a component\n            int component_length = rnd.next(1, min(n - length, 10));\n            for (int i = 0; i < component_length && length < n; ++i) {\n                path += (char)rnd.next('a', 'z');\n                length++;\n            }\n\n            if (length >= n) break;\n\n            // Add multiple '/'\n            int num_slashes = rnd.next(1, min(n - length, 5));\n            path += string(num_slashes, '/');\n            length += num_slashes;\n        }\n        // Add extra slashes at the end if possible\n        if (length < n) {\n            int extra_slashes = min(n - length, 5);\n            path += string(extra_slashes, '/');\n            length += extra_slashes;\n        }\n    } else if (type == \"no_slashes\") {\n        // Path starting with '/' but containing no subsequent '/'\n        path = \"/\";\n        int remaining = n - 1;\n        for (int i = 0; i < remaining; ++i) {\n            path += (char)rnd.next('a', 'z');\n        }\n    } else if (type == \"single_component\") {\n        // Path with a single component\n        path = \"/\";\n        int remaining = n - 1;\n        for (int i = 0; i < remaining; ++i) {\n            path += (char)rnd.next('a', 'z');\n        }\n    } else if (type == \"max_components\") {\n        // Path with maximum number of components\n        path = \"/\";\n        int length = 1;\n        while (length < n) {\n            // Add '/' characters\n            int num_slashes = rnd.next(1, min(2, n - length));\n            path += string(num_slashes, '/');\n            length += num_slashes;\n\n            if (length >= n) break;\n\n            // Add a single character component\n            path += (char)rnd.next('a', 'z');\n            length++;\n        }\n    } else if (type == \"long\") {\n        // Long path with multiple components\n        path = \"/\";\n        int length = 1;\n        while (length < n) {\n            // Add a component\n            int component_length = rnd.next(1, min(10, n - length));\n            for (int i = 0; i < component_length && length < n; ++i) {\n                path += (char)rnd.next('a', 'z');\n                length++;\n            }\n            if (length >= n) break;\n\n            // Add '/'\n            path += '/';\n            length++;\n        }\n    } else {\n        // Random path\n        path = \"/\";\n        int length = 1;\n        while (length < n) {\n            int choice = rnd.next(0, 2);\n            if (choice == 0) {\n                // Add a lowercase letter\n                path += (char)rnd.next('a', 'z');\n                length++;\n            } else {\n                // Add one or more '/'\n                int num_slashes = rnd.next(1, min(5, n - length));\n                path += string(num_slashes, '/');\n                length += num_slashes;\n            }\n        }\n    }\n\n    // Ensure the path starts with at least one '/'\n    if (path.empty() || path[0] != '/') {\n        path = \"/\" + path;\n    }\n\n    // Truncate the path to length 'n' if necessary\n    if ((int)path.length() > n) {\n        path = path.substr(0, n);\n    }\n\n    // Output the path\n    printf(\"%s\\n\", path.c_str());\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -type root_only\n./gen -n 1 -type slashes_only\n./gen -n 1 -type no_slashes\n./gen -n 1 -type single_component\n./gen -n 1 -type max_components\n./gen -n 1 -type long\n./gen -n 1 -type random\n\n./gen -n 10 -type root_only\n./gen -n 10 -type slashes_only\n./gen -n 10 -type no_slashes\n./gen -n 10 -type ends_with_slash\n./gen -n 10 -type single_component\n./gen -n 10 -type max_components\n./gen -n 10 -type long\n./gen -n 10 -type random\n\n./gen -n 50 -type slashes_only\n./gen -n 50 -type ends_with_slash\n./gen -n 50 -type no_slashes\n./gen -n 50 -type single_component\n./gen -n 50 -type max_components\n./gen -n 50 -type long\n./gen -n 50 -type random\n\n./gen -n 100 -type root_only\n./gen -n 100 -type slashes_only\n./gen -n 100 -type ends_with_slash\n./gen -n 100 -type no_slashes\n./gen -n 100 -type single_component\n./gen -n 100 -type max_components\n./gen -n 100 -type long\n./gen -n 100 -type random\n\n./gen -n 100 -type random\n./gen -n 100 -type ends_with_slash\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T19:47:47.872479",
        "total_tutorials": 0,
        "has_ai_judgment": false,
        "has_code_files": true
      }
    },
    {
      "problem_id": "20/B",
      "title": "B. Equation",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains three integer numbers A, B and C ( - 105 ≤ A, B, C ≤ 105). Any coefficient may be equal to 0.",
      "output_spec": "OutputIn case of infinite root count print the only integer -1. In case of no roots print the only integer 0. In other cases print the number of root on the first line and the roots on the following lines in the ascending order. Print roots with at least 5 digits after the decimal point.",
      "sample_tests": "ExamplesInputCopy1 -5 6OutputCopy22.00000000003.0000000000",
      "description": "B. Equation\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains three integer numbers A, B and C ( - 105 ≤ A, B, C ≤ 105). Any coefficient may be equal to 0.\n\nOutputIn case of infinite root count print the only integer -1. In case of no roots print the only integer 0. In other cases print the number of root on the first line and the roots on the following lines in the ascending order. Print roots with at least 5 digits after the decimal point.\n\nInputCopy1 -5 6OutputCopy22.00000000003.0000000000\n\nInputCopy1 -5 6\n\nOutputCopy22.00000000003.0000000000",
      "solutions": [],
      "code_examples": [],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int A = inf.readInt(-100000, 100000, \"A\");\n    inf.readSpace();\n    int B = inf.readInt(-100000, 100000, \"B\");\n    inf.readSpace();\n    int C = inf.readInt(-100000, 100000, \"C\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int A = inf.readInt(-100000, 100000, \"A\");\n    inf.readSpace();\n    int B = inf.readInt(-100000, 100000, \"B\");\n    inf.readSpace();\n    int C = inf.readInt(-100000, 100000, \"C\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int A = inf.readInt(-100000, 100000, \"A\");\n    inf.readSpace();\n    int B = inf.readInt(-100000, 100000, \"B\");\n    inf.readSpace();\n    int C = inf.readInt(-100000, 100000, \"C\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nconst double EPS = 1E-6;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare two sequences of doubles, max absolute or relative  error = %.7f\", EPS);\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    double j = 0, p = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        n++;\r\n        j = ans.readDouble();\r\n        p = ouf.readDouble();\r\n        if (!doubleCompare(j, p, EPS)) {\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%.7f', found: '%.7f', error = '%.7f'\",\r\n                  n, englishEnding(n).c_str(), j, p, doubleDelta(j, p));\r\n        }\r\n    }\r\n\r\n    if (n == 1)\r\n        quitf(_ok, \"found '%.7f', expected '%.7f', error '%.7f'\", p, j, doubleDelta(j, p));\r\n\r\n    quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    string type = opt<string>(\"type\", \"random\");\n    int max_coeff = opt<int>(\"max_coeff\", 100000);\n\n    int A = opt<int>(\"A\", INT_MAX);\n    int B = opt<int>(\"B\", INT_MAX);\n    int C = opt<int>(\"C\", INT_MAX);\n\n    if (A != INT_MAX && B != INT_MAX && C != INT_MAX) {\n        // Use specified A, B, and C\n    } else {\n        // Generate according to the specified type\n        if (type == \"quadratic_two_roots\") {\n            // Generate A ≠ 0\n            do {\n                A = rnd.next(-max_coeff, max_coeff);\n            } while (A == 0);\n            // Generate B and C such that discriminant > 0\n            long long discriminant;\n            do {\n                B = rnd.next(-max_coeff, max_coeff);\n                C = rnd.next(-max_coeff, max_coeff);\n                discriminant = (long long)B * B - 4LL * A * C;\n            } while (discriminant <= 0);\n        } else if (type == \"quadratic_one_root\") {\n            // Generate A ≠ 0\n            do {\n                A = rnd.next(-max_coeff, max_coeff);\n            } while (A == 0);\n            // Let B^2 = 4AC\n            int k = rnd.next(-max_coeff / (abs(A) > 0 ? abs(A) : 1), max_coeff / (abs(A) > 0 ? abs(A) : 1));\n            B = 2 * A * k;\n            C = A * k * k;\n        } else if (type == \"quadratic_no_real_root\") {\n            // Generate A ≠ 0\n            do {\n                A = rnd.next(-max_coeff, max_coeff);\n            } while (A == 0);\n            // Generate B and C such that discriminant < 0\n            long long discriminant;\n            do {\n                B = rnd.next(-max_coeff, max_coeff);\n                C = rnd.next(-max_coeff, max_coeff);\n                discriminant = (long long)B * B - 4LL * A * C;\n            } while (discriminant >= 0);\n        } else if (type == \"linear\") {\n            A = 0;\n            do {\n                B = rnd.next(-max_coeff, max_coeff);\n            } while (B == 0);\n            C = rnd.next(-max_coeff, max_coeff);\n        } else if (type == \"linear_no_root\") {\n            A = 0;\n            B = 0;\n            do {\n                C = rnd.next(-max_coeff, max_coeff);\n            } while (C == 0);\n        } else if (type == \"infinite_roots\") {\n            A = 0;\n            B = 0;\n            C = 0;\n        } else if (type == \"edge_case\") {\n            // Generate discriminant very close to zero\n            do {\n                A = rnd.next(-max_coeff, max_coeff);\n                if (A == 0) continue;\n                B = rnd.next(-max_coeff, max_coeff);\n                long long D = (long long)B * B;\n                C = (B * B - rnd.next(1, 2)) / (4LL * A);\n                if (abs(D - 4LL * A * C) <= 1) break;\n            } while (true);\n        } else {\n            // Generate random coefficients within constraints\n            A = rnd.next(-max_coeff, max_coeff);\n            B = rnd.next(-max_coeff, max_coeff);\n            C = rnd.next(-max_coeff, max_coeff);\n        }\n    }\n\n    // Ensure coefficients are within the constraints\n    A = max(-max_coeff, min(max_coeff, A));\n    B = max(-max_coeff, min(max_coeff, B));\n    C = max(-max_coeff, min(max_coeff, C));\n\n    printf(\"%d %d %d\\n\", A, B, C);\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    string type = opt<string>(\"type\", \"random\");\n    int max_coeff = opt<int>(\"max_coeff\", 100000);\n\n    int A = opt<int>(\"A\", INT_MAX);\n    int B = opt<int>(\"B\", INT_MAX);\n    int C = opt<int>(\"C\", INT_MAX);\n\n    if (A != INT_MAX && B != INT_MAX && C != INT_MAX) {\n        // Use specified A, B, and C\n    } else {\n        // Generate according to the specified type\n        if (type == \"quadratic_two_roots\") {\n            // Generate A ≠ 0\n            do {\n                A = rnd.next(-max_coeff, max_coeff);\n            } while (A == 0);\n            // Generate B and C such that discriminant > 0\n            long long discriminant;\n            do {\n                B = rnd.next(-max_coeff, max_coeff);\n                C = rnd.next(-max_coeff, max_coeff);\n                discriminant = (long long)B * B - 4LL * A * C;\n            } while (discriminant <= 0);\n        } else if (type == \"quadratic_one_root\") {\n            // Generate A ≠ 0\n            do {\n                A = rnd.next(-max_coeff, max_coeff);\n            } while (A == 0);\n            // Let B^2 = 4AC\n            int k = rnd.next(-max_coeff / (abs(A) > 0 ? abs(A) : 1), max_coeff / (abs(A) > 0 ? abs(A) : 1));\n            B = 2 * A * k;\n            C = A * k * k;\n        } else if (type == \"quadratic_no_real_root\") {\n            // Generate A ≠ 0\n            do {\n                A = rnd.next(-max_coeff, max_coeff);\n            } while (A == 0);\n            // Generate B and C such that discriminant < 0\n            long long discriminant;\n            do {\n                B = rnd.next(-max_coeff, max_coeff);\n                C = rnd.next(-max_coeff, max_coeff);\n                discriminant = (long long)B * B - 4LL * A * C;\n            } while (discriminant >= 0);\n        } else if (type == \"linear\") {\n            A = 0;\n            do {\n                B = rnd.next(-max_coeff, max_coeff);\n            } while (B == 0);\n            C = rnd.next(-max_coeff, max_coeff);\n        } else if (type == \"linear_no_root\") {\n            A = 0;\n            B = 0;\n            do {\n                C = rnd.next(-max_coeff, max_coeff);\n            } while (C == 0);\n        } else if (type == \"infinite_roots\") {\n            A = 0;\n            B = 0;\n            C = 0;\n        } else if (type == \"edge_case\") {\n            // Generate discriminant very close to zero\n            do {\n                A = rnd.next(-max_coeff, max_coeff);\n                if (A == 0) continue;\n                B = rnd.next(-max_coeff, max_coeff);\n                long long D = (long long)B * B;\n                C = (B * B - rnd.next(1, 2)) / (4LL * A);\n                if (abs(D - 4LL * A * C) <= 1) break;\n            } while (true);\n        } else {\n            // Generate random coefficients within constraints\n            A = rnd.next(-max_coeff, max_coeff);\n            B = rnd.next(-max_coeff, max_coeff);\n            C = rnd.next(-max_coeff, max_coeff);\n        }\n    }\n\n    // Ensure coefficients are within the constraints\n    A = max(-max_coeff, min(max_coeff, A));\n    B = max(-max_coeff, min(max_coeff, B));\n    C = max(-max_coeff, min(max_coeff, C));\n\n    printf(\"%d %d %d\\n\", A, B, C);\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Infinite roots (A=0, B=0, C=0)\n./gen -type infinite_roots\n\n# No solution (A=0, B=0, C≠0)\n./gen -type linear_no_root\n\n# Linear equations (A=0, B≠0)\n./gen -type linear\n./gen -type linear\n\n# Quadratic equations with two real roots (discriminant > 0)\n./gen -type quadratic_two_roots\n./gen -type quadratic_two_roots\n./gen -type quadratic_two_roots\n\n# Quadratic equations with one real root (discriminant = 0)\n./gen -type quadratic_one_root\n./gen -type quadratic_one_root\n\n# Quadratic equations with no real roots (discriminant < 0)\n./gen -type quadratic_no_real_root\n./gen -type quadratic_no_real_root\n\n# Edge cases where discriminant is very close to zero\n./gen -type edge_case\n./gen -type edge_case\n\n# Specific test cases with predefined coefficients\n./gen -A 1 -B -2 -C 1       # x^2 - 2x + 1 = 0 (one real root at x=1)\n./gen -A 1 -B 0 -C -1       # x^2 - 1 = 0 (roots at x = -1 and x = 1)\n./gen -A 1 -B 0 -C 0        # x^2 = 0 (one real root at x=0)\n./gen -A 0 -B 1 -C 0        # x = 0 (one real root)\n./gen -A 0 -B 1 -C 1        # x + 1 = 0 (one real root at x = -1)\n./gen -A 0 -B 0 -C 1        # No solution (0x = -1)\n./gen -A 0 -B 0 -C 0        # Infinite roots (0 = 0)\n./gen -A 1 -B -100000 -C 1  # Large B coefficient\n./gen -A -100000 -B 1 -C 1  # Large negative A coefficient\n./gen -A 1 -B 1 -C 100000   # Discriminant < 0 (no real roots)\n./gen -A 100000 -B 100000 -C 1  # Large coefficients\n./gen -A 1 -B 100000 -C 100000  # Large B and C coefficients\n./gen -A 100000 -B 1 -C -100000 # Large A and C coefficients\n./gen -A 1 -B -1 -C 0       # x^2 - x = 0 (roots at x = 0 and x = 1)\n\n# Generate small coefficients with specific types\n./gen -type quadratic_one_root -max_coeff 1\n./gen -type quadratic_no_real_root -max_coeff 1\n./gen -type quadratic_two_roots -max_coeff 1\n\n# Additional random test cases to increase coverage\n./gen -type quadratic_two_roots\n./gen -type quadratic_no_real_root\n./gen -type linear\n./gen -type edge_case\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T19:47:49.725040",
        "total_tutorials": 0,
        "has_ai_judgment": false,
        "has_code_files": true
      }
    },
    {
      "problem_id": "20/C",
      "title": "C. Dijkstra?",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test64 megabytes",
      "input_spec": "InputThe first line contains two integers n and m (2 ≤ n ≤ 105, 0 ≤ m ≤ 105), where n is the number of vertices and m is the number of edges. Following m lines contain one edge each in form ai, bi and wi (1 ≤ ai, bi ≤ n, 1 ≤ wi ≤ 106), where ai, bi are edge endpoints and wi is the length of the edge.It is possible that the graph has loops and multiple edges between pair of vertices.",
      "output_spec": "OutputWrite the only integer -1 in case of no path. Write the shortest path in opposite case. If there are many solutions, print any of them.",
      "sample_tests": "ExamplesInputCopy5 61 2 22 5 52 3 41 4 14 3 33 5 1OutputCopy1 4 3 5 InputCopy5 61 2 22 5 52 3 41 4 14 3 33 5 1OutputCopy1 4 3 5",
      "description": "C. Dijkstra?\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test64 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains two integers n and m (2 ≤ n ≤ 105, 0 ≤ m ≤ 105), where n is the number of vertices and m is the number of edges. Following m lines contain one edge each in form ai, bi and wi (1 ≤ ai, bi ≤ n, 1 ≤ wi ≤ 106), where ai, bi are edge endpoints and wi is the length of the edge.It is possible that the graph has loops and multiple edges between pair of vertices.\n\nOutputWrite the only integer -1 in case of no path. Write the shortest path in opposite case. If there are many solutions, print any of them.\n\nInputCopy5 61 2 22 5 52 3 41 4 14 3 33 5 1OutputCopy1 4 3 5 InputCopy5 61 2 22 5 52 3 41 4 14 3 33 5 1OutputCopy1 4 3 5\n\nInputCopy5 61 2 22 5 52 3 41 4 14 3 33 5 1\n\nOutputCopy1 4 3 5\n\nInputCopy5 61 2 22 5 52 3 41 4 14 3 33 5 1\n\nOutputCopy1 4 3 5",
      "solutions": [],
      "code_examples": [],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(2, 100000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(0, 100000, \"m\");\n    inf.readEoln();\n    for (int i = 0; i < m; ++i) {\n        int a = inf.readInt(1, n, \"a_i\");\n        inf.readSpace();\n        int b = inf.readInt(1, n, \"b_i\");\n        inf.readSpace();\n        int w = inf.readInt(1, 1000000, \"w_i\");\n        inf.readEoln();\n    }\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(2, 100000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(0, 100000, \"m\");\n    inf.readEoln();\n    for (int i = 0; i < m; ++i) {\n        int a = inf.readInt(1, n, \"a_i\");\n        inf.readSpace();\n        int b = inf.readInt(1, n, \"b_i\");\n        inf.readSpace();\n        int w = inf.readInt(1, 1000000, \"w_i\");\n        inf.readEoln();\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(2, 100000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(0, 100000, \"m\");\n    inf.readEoln();\n    for (int i = 0; i < m; ++i) {\n        int a = inf.readInt(1, n, \"a_i\");\n        inf.readSpace();\n        int b = inf.readInt(1, n, \"b_i\");\n        inf.readSpace();\n        int w = inf.readInt(1, 1000000, \"w_i\");\n        inf.readEoln();\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint n, m;\nmap<pair<int, int>, int> edgeWeights;\n\nlong long readAndCheckAnswer(InStream& stream, map<pair<int,int>, int>& edgeWeights, int n) {\n    if (stream.seekEof())\n        stream.quitf(_wa, \"Empty output\");\n\n    string firstToken = stream.readToken();\n    if (firstToken == \"-1\") {\n        if (!stream.seekEof())\n            stream.quitf(_wa, \"Extra output after -1\");\n        return -1;\n    } else {\n        int v = atoi(firstToken.c_str());\n        if (v < 1 || v > n)\n            stream.quitf(_wa, \"Vertex %d is out of bounds\", v);\n        vector<int> path;\n        path.push_back(v);\n        while (!stream.seekEof()) {\n            v = stream.readInt(1, n, \"vertex in path\");\n            path.push_back(v);\n        }\n        if (path.front() != 1)\n            stream.quitf(_wa, \"Path does not start at vertex 1\");\n        if (path.back() != n)\n            stream.quitf(_wa, \"Path does not end at vertex n\");\n        long long totalLength = 0;\n        for (size_t i = 1; i < path.size(); ++i) {\n            int u = path[i - 1];\n            int v = path[i];\n            auto it = edgeWeights.find({u, v});\n            if (it == edgeWeights.end()) {\n                stream.quitf(_wa, \"Edge between %d and %d does not exist\", u, v);\n            }\n            totalLength += it->second;\n        }\n        return totalLength;\n    }\n}\n\nint main(int argc, char* argv[]) {\n    registerTestlibCmd(argc, argv);\n\n    n = inf.readInt(2, 100000, \"n\");\n    m = inf.readInt(0, 100000, \"m\");\n    for (int i = 0; i < m; ++i) {\n        int a = inf.readInt(1, n, \"ai\");\n        int b = inf.readInt(1, n, \"bi\");\n        int w = inf.readInt(1, 1000000, \"wi\");\n        // Keep the minimum weight for each pair\n        auto it = edgeWeights.find({a, b});\n        if (it == edgeWeights.end() || it->second > w) {\n            edgeWeights[{a, b}] = w;\n            edgeWeights[{b, a}] = w;\n        }\n    }\n\n    long long juryResult = readAndCheckAnswer(ans, edgeWeights, n);\n    long long participantResult = readAndCheckAnswer(ouf, edgeWeights, n);\n\n    if (juryResult == -1) {\n        if (participantResult == -1) {\n            quitf(_ok, \"Both outputs are -1\");\n        } else {\n            quitf(_wa, \"Jury has no path, but participant found a path of length %lld\", participantResult);\n        }\n    } else {\n        if (participantResult == -1) {\n            quitf(_wa, \"Participant outputs -1, but a path exists\");\n        } else {\n            if (participantResult > juryResult) {\n                quitf(_wa, \"Participant's path length %lld is longer than shortest possible path length %lld\", participantResult, juryResult);\n            } else if (participantResult == juryResult) {\n                quitf(_ok, \"Correct path of length %lld\", participantResult);\n            } else {\n                quitf(_fail, \"Participant found a path of length %lld shorter than jury's path of length %lld\", participantResult, juryResult);\n            }\n        }\n    }\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char *argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\", -1);\n    string type = opt<string>(\"type\", \"random\");\n    string wtype = opt<string>(\"wtype\", \"random\");\n\n    auto getWeight = [&]() {\n        if (wtype == \"random\") {\n            return rnd.next(1, 1000000);\n        } else if (wtype == \"max\") {\n            return 1000000;\n        } else if (wtype == \"min\") {\n            return 1;\n        } else {\n            ensuref(false, \"Unknown wtype: %s\", wtype.c_str());\n            return -1; // unreachable\n        }\n    };\n\n    if (type == \"random\") {\n        ensuref(m != -1, \"Type 'random' requires parameter 'm'\");\n        long long maxEdges = (long long)n * n;\n        ensuref(0 <= m && m <= min(100000LL, maxEdges), \"Invalid 'm' value\");\n\n        printf(\"%d %d\\n\", n, m);\n        for (int i = 0; i < m; i++) {\n            int a = rnd.next(1, n);\n            int b = rnd.next(1, n);\n            int w = getWeight();\n            printf(\"%d %d %d\\n\", a, b, w);\n        }\n    } else if (type == \"chain\") {\n        m = n - 1;\n        ensuref(m <= 100000, \"Too many edges for 'chain' type\");\n        printf(\"%d %d\\n\", n, m);\n        for (int i = 1; i < n; ++i) {\n            int w = getWeight();\n            printf(\"%d %d %d\\n\", i, i+1, w);\n        }\n    } else if (type == \"star\") {\n        m = n - 1;\n        ensuref(m <= 100000, \"Too many edges for 'star' type\");\n        printf(\"%d %d\\n\", n, m);\n        for (int i = 2; i <= n; ++i) {\n            int w = getWeight();\n            printf(\"%d %d %d\\n\", 1, i, w);\n        }\n    } else if (type == \"disconnected\") {\n        int k = n / 2;\n        vector<pair<int, int>> edges;\n        for (int i = 1; i < k; ++i) {\n            int w = getWeight();\n            edges.emplace_back(i, i+1);\n        }\n        for (int i = k+1; i < n; ++i) {\n            int w = getWeight();\n            edges.emplace_back(i, i+1);\n        }\n        m = edges.size();\n        ensuref(m <= 100000, \"Too many edges for 'disconnected' type\");\n        printf(\"%d %d\\n\", n, m);\n        for (auto edge : edges) {\n            int w = getWeight();\n            printf(\"%d %d %d\\n\", edge.first, edge.second, w);\n        }\n    } else if (type == \"loops\") {\n        ensuref(m != -1, \"Type 'loops' requires parameter 'm'\");\n        ensuref(m <= 100000, \"Too many edges for 'loops' type\");\n        printf(\"%d %d\\n\", n, m);\n        int loops = m / 2;\n        int others = m - loops;\n        for (int i = 0; i < loops; ++i) {\n            int a = rnd.next(1, n);\n            int w = getWeight();\n            printf(\"%d %d %d\\n\", a, a, w);\n        }\n        for (int i = 0; i < others; ++i) {\n            int a = rnd.next(1, n);\n            int b = rnd.next(1, n);\n            if (a == b) b = (b % n) + 1; // Ensure a != b\n            int w = getWeight();\n            printf(\"%d %d %d\\n\", a, b, w);\n        }\n    } else if (type == \"multi_edges\") {\n        ensuref(m != -1, \"Type 'multi_edges' requires parameter 'm'\");\n        ensuref(m <= 100000, \"Too many edges for 'multi_edges' type\");\n        printf(\"%d %d\\n\", n, m);\n        // First create a connected graph\n        for (int i = 1; i < n; ++i) {\n            int w = getWeight();\n            printf(\"%d %d %d\\n\", i, i + 1, w);\n        }\n        // Add extra edges to create multiple edges between nodes\n        for (int i = n - 1; i < m; ++i) {\n            int a = rnd.next(1, n);\n            int b = rnd.next(1, n);\n            int w = getWeight();\n            printf(\"%d %d %d\\n\", a, b, w);\n        }\n    } else {\n        ensuref(false, \"Unknown type: %s\", type.c_str());\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char *argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\", -1);\n    string type = opt<string>(\"type\", \"random\");\n    string wtype = opt<string>(\"wtype\", \"random\");\n\n    auto getWeight = [&]() {\n        if (wtype == \"random\") {\n            return rnd.next(1, 1000000);\n        } else if (wtype == \"max\") {\n            return 1000000;\n        } else if (wtype == \"min\") {\n            return 1;\n        } else {\n            ensuref(false, \"Unknown wtype: %s\", wtype.c_str());\n            return -1; // unreachable\n        }\n    };\n\n    if (type == \"random\") {\n        ensuref(m != -1, \"Type 'random' requires parameter 'm'\");\n        long long maxEdges = (long long)n * n;\n        ensuref(0 <= m && m <= min(100000LL, maxEdges), \"Invalid 'm' value\");\n\n        printf(\"%d %d\\n\", n, m);\n        for (int i = 0; i < m; i++) {\n            int a = rnd.next(1, n);\n            int b = rnd.next(1, n);\n            int w = getWeight();\n            printf(\"%d %d %d\\n\", a, b, w);\n        }\n    } else if (type == \"chain\") {\n        m = n - 1;\n        ensuref(m <= 100000, \"Too many edges for 'chain' type\");\n        printf(\"%d %d\\n\", n, m);\n        for (int i = 1; i < n; ++i) {\n            int w = getWeight();\n            printf(\"%d %d %d\\n\", i, i+1, w);\n        }\n    } else if (type == \"star\") {\n        m = n - 1;\n        ensuref(m <= 100000, \"Too many edges for 'star' type\");\n        printf(\"%d %d\\n\", n, m);\n        for (int i = 2; i <= n; ++i) {\n            int w = getWeight();\n            printf(\"%d %d %d\\n\", 1, i, w);\n        }\n    } else if (type == \"disconnected\") {\n        int k = n / 2;\n        vector<pair<int, int>> edges;\n        for (int i = 1; i < k; ++i) {\n            int w = getWeight();\n            edges.emplace_back(i, i+1);\n        }\n        for (int i = k+1; i < n; ++i) {\n            int w = getWeight();\n            edges.emplace_back(i, i+1);\n        }\n        m = edges.size();\n        ensuref(m <= 100000, \"Too many edges for 'disconnected' type\");\n        printf(\"%d %d\\n\", n, m);\n        for (auto edge : edges) {\n            int w = getWeight();\n            printf(\"%d %d %d\\n\", edge.first, edge.second, w);\n        }\n    } else if (type == \"loops\") {\n        ensuref(m != -1, \"Type 'loops' requires parameter 'm'\");\n        ensuref(m <= 100000, \"Too many edges for 'loops' type\");\n        printf(\"%d %d\\n\", n, m);\n        int loops = m / 2;\n        int others = m - loops;\n        for (int i = 0; i < loops; ++i) {\n            int a = rnd.next(1, n);\n            int w = getWeight();\n            printf(\"%d %d %d\\n\", a, a, w);\n        }\n        for (int i = 0; i < others; ++i) {\n            int a = rnd.next(1, n);\n            int b = rnd.next(1, n);\n            if (a == b) b = (b % n) + 1; // Ensure a != b\n            int w = getWeight();\n            printf(\"%d %d %d\\n\", a, b, w);\n        }\n    } else if (type == \"multi_edges\") {\n        ensuref(m != -1, \"Type 'multi_edges' requires parameter 'm'\");\n        ensuref(m <= 100000, \"Too many edges for 'multi_edges' type\");\n        printf(\"%d %d\\n\", n, m);\n        // First create a connected graph\n        for (int i = 1; i < n; ++i) {\n            int w = getWeight();\n            printf(\"%d %d %d\\n\", i, i + 1, w);\n        }\n        // Add extra edges to create multiple edges between nodes\n        for (int i = n - 1; i < m; ++i) {\n            int a = rnd.next(1, n);\n            int b = rnd.next(1, n);\n            int w = getWeight();\n            printf(\"%d %d %d\\n\", a, b, w);\n        }\n    } else {\n        ensuref(false, \"Unknown type: %s\", type.c_str());\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 2 -type chain\n./gen -n 2 -type random -m 1 -wtype min\n./gen -n 10 -type chain -wtype min\n\n./gen -n 10 -type random -m 15\n./gen -n 10 -type random -m 20 -wtype max\n\n./gen -n 100 -type random -m 200\n\n./gen -n 1000 -type random -m 5000\n\n./gen -n 10000 -type random -m 100000\n\n./gen -n 100000 -type random -m 100000\n\n./gen -n 50000 -type chain\n\n./gen -n 100000 -type star\n\n./gen -n 100000 -type chain -wtype max\n\n./gen -n 100000 -type disconnected\n\n./gen -n 100000 -type loops -m 100000 -wtype min\n\n./gen -n 100000 -type multi_edges -m 100000\n\n./gen -n 100000 -type multi_edges -m 100000 -wtype max\n\n./gen -n 2 -type disconnected -m 0\n\n./gen -n 5000 -type disconnected -m 0\n\n./gen -n 100000 -type disconnected -m 0\n\n./gen -n 100000 -type random -m 0\n\n./gen -n 100000 -type random -m 100000\n\n./gen -n 100000 -type random -m 100000 -wtype min\n\n./gen -n 100000 -type random -m 100000 -wtype max\n\n./gen -n 100000 -type star -wtype min\n\n./gen -n 100000 -type random -m 50000\n\n./gen -n 99999 -type chain\n\n./gen -n 99999 -type star\n\n./gen -n 99999 -type disconnected -m 0\n\n./gen -n 2 -type chain\n\n./gen -n 100000 -type loops -m 100000\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T19:47:51.504641",
        "total_tutorials": 0,
        "has_ai_judgment": false,
        "has_code_files": true
      }
    },
    {
      "problem_id": "200/A",
      "title": "A. Cinema",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1.5 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first input line contains three integers n, m, k (1 ≤ n, m ≤ 2000, 1 ≤ k ≤ min(n·m, 105) — the number of rows in the room, the number of seats in each row and the number of people in the line, correspondingly. Each of the next k lines contains two integers xi, yi (1 ≤ xi ≤ n, 1 ≤ yi ≤ m) — the coordinates of the seat each person has chosen. Numbers on the same line are separated by a space. The pairs of coordinates are located in the order, in which people stand in the line, starting from the head (the first person in the line who stands in front of the box office) to the tail (the last person in the line).",
      "output_spec": "OutputPrint k lines, each containing a pair of integers. Print on the i-th line xi, yi — the coordinates of the seat, for which the person who stands i-th in the line will buy the ticket.",
      "sample_tests": "ExamplesInputCopy3 4 61 11 11 11 21 31 3OutputCopy1 11 22 11 31 42 3InputCopy4 3 122 22 22 22 22 22 22 22 22 22 22 22 2OutputCopy2 21 22 12 33 21 11 33 13 34 24 14 3",
      "description": "time limit per test1.5 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first input line contains three integers n, m, k (1 ≤ n, m ≤ 2000, 1 ≤ k ≤ min(n·m, 105) — the number of rows in the room, the number of seats in each row and the number of people in the line, correspondingly. Each of the next k lines contains two integers xi, yi (1 ≤ xi ≤ n, 1 ≤ yi ≤ m) — the coordinates of the seat each person has chosen. Numbers on the same line are separated by a space. The pairs of coordinates are located in the order, in which people stand in the line, starting from the head (the first person in the line who stands in front of the box office) to the tail (the last person in the line).\n\nOutputPrint k lines, each containing a pair of integers. Print on the i-th line xi, yi — the coordinates of the seat, for which the person who stands i-th in the line will buy the ticket.\n\nInputCopy3 4 61 11 11 11 21 31 3OutputCopy1 11 22 11 31 42 3InputCopy4 3 122 22 22 22 22 22 22 22 22 22 22 22 2OutputCopy2 21 22 12 33 21 11 33 13 34 24 14 3\n\nInputCopy3 4 61 11 11 11 21 31 3\n\nOutputCopy1 11 22 11 31 42 3\n\nInputCopy4 3 122 22 22 22 22 22 22 22 22 22 22 22 2\n\nOutputCopy2 21 22 12 33 21 11 33 13 34 24 14 3",
      "solutions": [
        {
          "title": "Codeforces Round #126 (Div. 2) - Codeforces",
          "content": "Good afternoon, friends)We introduce you Codeforces Round #126 (Div. 2). Please note, Codeforces Round #126 (Div. 2) will be only today and only today you will have unique opportunity to raise your rating in this competition (certainly, you will be able to solve problems virtually after round, but this doesn't change your rating). Also round will be unrated for participants from first division.This round was prepared by students of Saratov State University: Nicolay Kuznetsov (NALP), Pavel Kholkin (HolkinPV), Igor Kudryashov (Igor_Kudryashov) and Gerald Agapov (Gerald). Also we thank creator of Codeforces Michael Mirzayanov (MikeMirzayanov) for amazing system, member of staff of Codeforces Mary Belova (Delinur) for great translation and Alexander Kuprin (Alex_KPR) for help in preparation of this round.Note, today it is decided to use dynamic scoring system (Learn more about dynamic problem scoring).Also problems will be placed in random order, it means they aren't sorted in increasing order of difficulty.More right ideas and fine solutions to you.UPD. Competition is over. Thanks for all who participated. We hope you enjoyed the participation, and round not passed in vain. Editorial will be posted soon. Congratulations to the winners: Andreos jma127 iensen Spider-man MrPapaya",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/4765",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1294
        },
        {
          "title": "Editorial of Codeforces Round #126 (Div. 2) - Codeforces",
          "content": "200A — CinemaIn this problem were given the field, which size is n × m, and k queries. Each query is the cell of the field. You had to find closest free cell for given one (there was used manhattan metric). Than found cell was marked as used. The time complexity of the solution is supposed to be . Firstly, we show the main idea, than we show why solution has time complexity .First of all, if n > m, than rotate matrix by 90 degrees (than we explain purpose of this transformation). We will have two matrices, size of each is n × m. In this matrices we will maintain for each cell the nearest free one to the left and to the right. Suppose we have query — cell (x, y). Iterate d — how much rows we will go above or below. Suppose we fix d, than look at the row x - d, for example (also we should do same things for row x + d). Lets find in this row nearest free cells to the left and to the right of (x - d, y) by using our matrices and try to update answer. When d will be greater than current found answer we will stop, because answer won't update in this case. After we find the answer, we have to change value in some cells of our matrices. It can be done by using structure DSU for each row.Lets show why this solution has time complexity . Suppose all queries are equal, for example each query is (x, y). Than if field is big enough, all points will be placed in form of square, which is rotated by 45 degrees and have center in point (x, y). Also the side of the square will have length . Than diagonal will have length too. It means that we see rows in each query and we do O(1) operations in each row. If the square doesn't fit into the field, than field is too thin verticaly or horizontaly. So we will have figure looks like rectangle, and one side of this rectangle will be less than . In this case rotate field so, than least side of rectangle means rows. Than we will see not greater than rows in each query and will perform not greater than O(1) operations in each row.This problem is supposed to be the hardest problem of the contest.200B — DrinksThis problem was the easiest problem of the contest. There you had to find average of the given numbers. The most participants solved this problem.200C — Football ChampionshipIn this problem was given description of the group stage of some football competition and scoring system. There were given results of all matches, excepting one, and you had to find result of the last match, satisfied some given criterias. Also Berland's team must be first or the second team of the group after than match.Lets note, that in each finished match were not greater than 18 goals. It means that we can brute-force all results of the last match, when score is not greater than 200 goals, and find the best one. One of the easiest way is to fill table to the end (it means to change points value and balls value), than to sort teams according to the given rules and to check that Berland is the first or the second team of the group.200D — Programming LanguageIn this task were given the list of template functions. Each function have its name and the list of types of arguments (also it can be used universal type). Also there were given set of variables and thier types, and some queries. Each query is function, which has name and list of arguments. For each query you had to find, how many functions from the given list fit to the function from query. There fit means that functions have the same name, same number of arguments and types of all arguments also equal.For solving this problem it is needed to implement comparing of functions. Constrains gave the possibility to brute-force function from the given list and check if the names and arguments of functions are equal.200E — Tractor CollegeIn this problem were given four integer numbers c3, c4, c5, s. You had to find 0 ≤ k3 ≤ k4 ≤ k5 such, that c3·k3 + c4·k4 + c5·k5 = s and |c3·k3–c4·k4| + |c4·k4–c5·k5| is minimal.Firstly, brute-force k4 so, that s–c4·k4 ≥ 0. Than look at 4 cases, according to the sign of the value in each modulus.Lets see the case, when c3·k3–c4·k4 ≥ 0 and c4·k4–c5·k5 ≥ 0. Than we have to minimize c3·k3–c5·k5. Also 0 ≤ k3 ≤ k4 ≤ k5 and c3·k3 + c5·k5 = s–c4·k4. Lets see diofant equation c3·k3 + c5... k5 = s–c4·k4. It can be that this equation doesn't have solution. Lets see the case, when equation has solution. As c3, c5 ≥ 0, than for minimization c3·k3–c5·k5 we have to minimize k3 and maximize k5. All solutions of diofant equation c3·k3 + c5·k5 = s–c4·k4 can be described by using one argument k. Than we have to find such segment, that for all k from it, k3 will fit above constrains, such segment, that for all k from it, k5 will fit above constrains, find intersection of this segments and, if intersection isn't empty, choose such k, that k5 is maximal.Similar you have to manage remain 3 cases and choose optimal values k3 and k5 for fixed k4. Also you can note, that in all cases minimized function is linear and in segment it has minimal value in one of its ends. So we can only find such segments, that for all k from that segments k3, k5 will fit above constrains, and calculate answer in the ends of this segments. If for all fixed k4 diofant equation doesn't have solution, or intersections of the described segments are empty, than answer is IMPOSSIBLE, else we should find the best. So the time complexity is O(s·log(s)) — brute-force of k4 and solving diofant equation for fixed k4.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/4769",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 200\\s*A"
          },
          "content_length": 5442
        },
        {
          "title": "Editorial of Codeforces Round #126 (Div. 2) - Codeforces",
          "content": "200A — CinemaIn this problem were given the field, which size is n × m, and k queries. Each query is the cell of the field. You had to find closest free cell for given one (there was used manhattan metric). Than found cell was marked as used. The time complexity of the solution is supposed to be . Firstly, we show the main idea, than we show why solution has time complexity .First of all, if n > m, than rotate matrix by 90 degrees (than we explain purpose of this transformation). We will have two matrices, size of each is n × m. In this matrices we will maintain for each cell the nearest free one to the left and to the right. Suppose we have query — cell (x, y). Iterate d — how much rows we will go above or below. Suppose we fix d, than look at the row x - d, for example (also we should do same things for row x + d). Lets find in this row nearest free cells to the left and to the right of (x - d, y) by using our matrices and try to update answer. When d will be greater than current found answer we will stop, because answer won't update in this case. After we find the answer, we have to change value in some cells of our matrices. It can be done by using structure DSU for each row.Lets show why this solution has time complexity . Suppose all queries are equal, for example each query is (x, y). Than if field is big enough, all points will be placed in form of square, which is rotated by 45 degrees and have center in point (x, y). Also the side of the square will have length . Than diagonal will have length too. It means that we see rows in each query and we do O(1) operations in each row. If the square doesn't fit into the field, than field is too thin verticaly or horizontaly. So we will have figure looks like rectangle, and one side of this rectangle will be less than . In this case rotate field so, than least side of rectangle means rows. Than we will see not greater than rows in each query and will perform not greater than O(1) operations in each row.This problem is supposed to be the hardest problem of the contest.200B — DrinksThis problem was the easiest problem of the contest. There you had to find average of the given numbers. The most participants solved this problem.200C — Football ChampionshipIn this problem was given description of the group stage of some football competition and scoring system. There were given results of all matches, excepting one, and you had to find result of the last match, satisfied some given criterias. Also Berland's team must be first or the second team of the group after than match.Lets note, that in each finished match were not greater than 18 goals. It means that we can brute-force all results of the last match, when score is not greater than 200 goals, and find the best one. One of the easiest way is to fill table to the end (it means to change points value and balls value), than to sort teams according to the given rules and to check that Berland is the first or the second team of the group.200D — Programming LanguageIn this task were given the list of template functions. Each function have its name and the list of types of arguments (also it can be used universal type). Also there were given set of variables and thier types, and some queries. Each query is function, which has name and list of arguments. For each query you had to find, how many functions from the given list fit to the function from query. There fit means that functions have the same name, same number of arguments and types of all arguments also equal.For solving this problem it is needed to implement comparing of functions. Constrains gave the possibility to brute-force function from the given list and check if the names and arguments of functions are equal.200E — Tractor CollegeIn this problem were given four integer numbers c3, c4, c5, s. You had to find 0 ≤ k3 ≤ k4 ≤ k5 such, that c3·k3 + c4·k4 + c5·k5 = s and |c3·k3–c4·k4| + |c4·k4–c5·k5| is minimal.Firstly, brute-force k4 so, that s–c4·k4 ≥ 0. Than look at 4 cases, according to the sign of the value in each modulus.Lets see the case, when c3·k3–c4·k4 ≥ 0 and c4·k4–c5·k5 ≥ 0. Than we have to minimize c3·k3–c5·k5. Also 0 ≤ k3 ≤ k4 ≤ k5 and c3·k3 + c5·k5 = s–c4·k4. Lets see diofant equation c3·k3 + c5... k5 = s–c4·k4. It can be that this equation doesn't have solution. Lets see the case, when equation has solution. As c3, c5 ≥ 0, than for minimization c3·k3–c5·k5 we have to minimize k3 and maximize k5. All solutions of diofant equation c3·k3 + c5·k5 = s–c4·k4 can be described by using one argument k. Than we have to find such segment, that for all k from it, k3 will fit above constrains, such segment, that for all k from it, k5 will fit above constrains, find intersection of this segments and, if intersection isn't empty, choose such k, that k5 is maximal.Similar you have to manage remain 3 cases and choose optimal values k3 and k5 for fixed k4. Also you can note, that in all cases minimized function is linear and in segment it has minimal value in one of its ends. So we can only find such segments, that for all k from that segments k3, k5 will fit above constrains, and calculate answer in the ends of this segments. If for all fixed k4 diofant equation doesn't have solution, or intersections of the described segments are empty, than answer is IMPOSSIBLE, else we should find the best. So the time complexity is O(s·log(s)) — brute-force of k4 and solving diofant equation for fixed k4.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/4769",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 200\\s*A"
          },
          "content_length": 5442
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #126 (Div. 2) - Codeforces - Code 1",
          "code": "The names of teams team1 and team2 are non-empty strings, consisting of uppercase English letters, with length of no more than 20 characters; goals1, goals2 are integers from 0 to 9.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4765",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #126 (Div. 2) - Codeforces - Code 2",
          "code": "The names of teams team1 and team2 are non-empty strings, consisting of uppercase English letters, with length of no more than 20 characters; goals1, goals2 are integers from 0 to 9.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4765",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #126 (Div. 2) - Codeforces - Code 3",
          "code": "X > Y, that is, Berland is going to win this game;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4765",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #126 (Div. 2) - Codeforces - Code 4",
          "code": "X > Y, that is, Berland is going to win this game;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4765",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 2000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 2000, \"m\");\n    inf.readSpace();\n    int max_k = min(n * m, 100000);\n    int k = inf.readInt(1, max_k, \"k\");\n    inf.readEoln();\n\n    for (int i = 0; i < k; i++) {\n        int xi = inf.readInt(1, n, \"xi\");\n        inf.readSpace();\n        int yi = inf.readInt(1, m, \"yi\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 2000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 2000, \"m\");\n    inf.readSpace();\n    int max_k = min(n * m, 100000);\n    int k = inf.readInt(1, max_k, \"k\");\n    inf.readEoln();\n\n    for (int i = 0; i < k; i++) {\n        int xi = inf.readInt(1, n, \"xi\");\n        inf.readSpace();\n        int yi = inf.readInt(1, m, \"yi\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 2000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 2000, \"m\");\n    inf.readSpace();\n    int max_k = min(n * m, 100000);\n    int k = inf.readInt(1, max_k, \"k\");\n    inf.readEoln();\n\n    for (int i = 0; i < k; i++) {\n        int xi = inf.readInt(1, n, \"xi\");\n        inf.readSpace();\n        int yi = inf.readInt(1, m, \"yi\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    // Read parameters\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string type = opt<string>(\"type\", \"random\");\n    int k;\n\n    // Adjust k according to type\n    if (type == \"max_people\") {\n        k = min(100000, n * m);\n    } else {\n        k = opt<int>(\"k\", min(100000, n*m));\n        k = min(k, n*m);\n        k = min(k, 100000);\n        k = max(k, 1);\n    }\n\n    // Now generate test case\n    printf(\"%d %d %d\\n\", n, m, k);\n\n    vector<pair<int, int> > choices;\n\n    if (type == \"random\") {\n        for(int i = 0; i < k; ++i) {\n            int xi = rnd.next(1, n);\n            int yi = rnd.next(1, m);\n            choices.emplace_back(xi, yi);\n        }\n    } else if (type == \"same_seat\" || type == \"max_dups\") {\n        int xi = n / 2 + 1;\n        int yi = m / 2 + 1;\n        for(int i = 0; i < k; ++i) {\n            choices.emplace_back(xi, yi);\n        }\n    } else if (type == \"fill_row\") {\n        int xi = n / 2 + 1;\n        for(int i = 0; i < k; ++i) {\n            int yi = (i % m) + 1;\n            choices.emplace_back(xi, yi);\n        }\n    } else if (type == \"fill_column\") {\n        int yi = m / 2 + 1;\n        for(int i = 0; i < k; ++i) {\n            int xi = (i % n) + 1;\n            choices.emplace_back(xi, yi);\n        }\n    } else if (type == \"max_people\") {\n        // Generate seat choices to fill the theater\n        for(int i = 0; i < k; ++i) {\n            int xi = (i / m) + 1;\n            int yi = (i % m) + 1;\n            choices.emplace_back(xi, yi);\n        }\n    } else if (type == \"minimize_motion\") {\n        int xi = n / 2 + 1;\n        int yi = m / 2 + 1;\n        // First person wants (xi, yi)\n        choices.emplace_back(xi, yi);\n        // Next people will have choices designed to cause tie-breakers\n        for(int i = 1; i < k; ++i) {\n            int dx = ((i - 1) / m) % n - n / 2;\n            int dy = ((i - 1) % m) - m / 2;\n            int x = xi + dx;\n            int y = yi + dy;\n            x = max(1, min(n, x));\n            y = max(1, min(m, y));\n            choices.emplace_back(x, y);\n        }\n    } else {\n        // Default to random\n        for(int i = 0; i < k; ++i) {\n            int xi = rnd.next(1, n);\n            int yi = rnd.next(1, m);\n            choices.emplace_back(xi, yi);\n        }\n    }\n\n    // Now output the seat choices\n    for(auto p : choices) {\n        printf(\"%d %d\\n\", p.first, p.second);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    // Read parameters\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string type = opt<string>(\"type\", \"random\");\n    int k;\n\n    // Adjust k according to type\n    if (type == \"max_people\") {\n        k = min(100000, n * m);\n    } else {\n        k = opt<int>(\"k\", min(100000, n*m));\n        k = min(k, n*m);\n        k = min(k, 100000);\n        k = max(k, 1);\n    }\n\n    // Now generate test case\n    printf(\"%d %d %d\\n\", n, m, k);\n\n    vector<pair<int, int> > choices;\n\n    if (type == \"random\") {\n        for(int i = 0; i < k; ++i) {\n            int xi = rnd.next(1, n);\n            int yi = rnd.next(1, m);\n            choices.emplace_back(xi, yi);\n        }\n    } else if (type == \"same_seat\" || type == \"max_dups\") {\n        int xi = n / 2 + 1;\n        int yi = m / 2 + 1;\n        for(int i = 0; i < k; ++i) {\n            choices.emplace_back(xi, yi);\n        }\n    } else if (type == \"fill_row\") {\n        int xi = n / 2 + 1;\n        for(int i = 0; i < k; ++i) {\n            int yi = (i % m) + 1;\n            choices.emplace_back(xi, yi);\n        }\n    } else if (type == \"fill_column\") {\n        int yi = m / 2 + 1;\n        for(int i = 0; i < k; ++i) {\n            int xi = (i % n) + 1;\n            choices.emplace_back(xi, yi);\n        }\n    } else if (type == \"max_people\") {\n        // Generate seat choices to fill the theater\n        for(int i = 0; i < k; ++i) {\n            int xi = (i / m) + 1;\n            int yi = (i % m) + 1;\n            choices.emplace_back(xi, yi);\n        }\n    } else if (type == \"minimize_motion\") {\n        int xi = n / 2 + 1;\n        int yi = m / 2 + 1;\n        // First person wants (xi, yi)\n        choices.emplace_back(xi, yi);\n        // Next people will have choices designed to cause tie-breakers\n        for(int i = 1; i < k; ++i) {\n            int dx = ((i - 1) / m) % n - n / 2;\n            int dy = ((i - 1) % m) - m / 2;\n            int x = xi + dx;\n            int y = yi + dy;\n            x = max(1, min(n, x));\n            y = max(1, min(m, y));\n            choices.emplace_back(x, y);\n        }\n    } else {\n        // Default to random\n        for(int i = 0; i < k; ++i) {\n            int xi = rnd.next(1, n);\n            int yi = rnd.next(1, m);\n            choices.emplace_back(xi, yi);\n        }\n    }\n\n    // Now output the seat choices\n    for(auto p : choices) {\n        printf(\"%d %d\\n\", p.first, p.second);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 10 -m 10 -k 20 -type random\n./gen -n 10 -m 10 -k 20 -type same_seat\n./gen -n 10 -m 10 -k 20 -type fill_row\n./gen -n 10 -m 10 -k 20 -type fill_column\n./gen -n 10 -m 10 -type max_people\n./gen -n 10 -m 10 -k 20 -type max_dups\n./gen -n 10 -m 10 -k 20 -type minimize_motion\n\n./gen -n 100 -m 100 -k 2000 -type random\n\n./gen -n 2000 -m 2000 -k 100000 -type random\n./gen -n 2000 -m 2000 -k 100000 -type same_seat\n./gen -n 2000 -m 2000 -k 100000 -type fill_row\n./gen -n 2000 -m 2000 -k 100000 -type fill_column\n./gen -n 2000 -m 2000 -type max_people\n./gen -n 2000 -m 2000 -k 100000 -type max_dups\n./gen -n 2000 -m 2000 -k 100000 -type minimize_motion\n\n./gen -n 1 -m 1000 -k 1000 -type fill_row\n./gen -n 1000 -m 1 -k 1000 -type fill_column\n./gen -n 2000 -m 1 -k 100000 -type fill_column\n./gen -n 1 -m 2000 -k 100000 -type fill_row\n\n./gen -n 2 -m 2 -k 100000 -type random\n./gen -n 2000 -m 2000 -k 1 -type random\n\n./gen -n 2000 -m 2000 -k 1000 -type minimize_motion\n./gen -n 2000 -m 2000 -k 1000 -type same_seat\n\n./gen -n 2000 -m 2000 -k 1 -type same_seat\n\n./gen -n 2000 -m 2000 -k 100000 -type minimize_motion\n\n./gen -n 2000 -m 2000 -k 100000 -type max_dups\n\n./gen -n 1999 -m 1999 -k 100000 -type random\n\n./gen -n 1 -m 1 -k 1 -type same_seat\n\n./gen -n 10 -m 10 -k 100 -type minimize_motion\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T19:47:53.471541",
        "total_tutorials": 3,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "200/B",
      "title": "B. Drinks",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first input line contains a single integer n (1 ≤ n ≤ 100) — the number of orange-containing drinks in Vasya's fridge. The second line contains n integers pi (0 ≤ pi ≤ 100) — the volume fraction of orange juice in the i-th drink, in percent. The numbers are separated by a space.",
      "output_spec": "OutputPrint the volume fraction in percent of orange juice in Vasya's cocktail. The answer will be considered correct if the absolute or relative error does not exceed 10  - 4.",
      "sample_tests": "ExamplesInputCopy350 50 100OutputCopy66.666666666667InputCopy40 25 50 75OutputCopy37.500000000000",
      "description": "time limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first input line contains a single integer n (1 ≤ n ≤ 100) — the number of orange-containing drinks in Vasya's fridge. The second line contains n integers pi (0 ≤ pi ≤ 100) — the volume fraction of orange juice in the i-th drink, in percent. The numbers are separated by a space.\n\nOutputPrint the volume fraction in percent of orange juice in Vasya's cocktail. The answer will be considered correct if the absolute or relative error does not exceed 10  - 4.\n\nInputCopy350 50 100OutputCopy66.666666666667InputCopy40 25 50 75OutputCopy37.500000000000\n\nInputCopy350 50 100\n\nOutputCopy66.666666666667\n\nInputCopy40 25 50 75\n\nOutputCopy37.500000000000\n\nNoteNote to the first sample: let's assume that Vasya takes x milliliters of each drink from the fridge. Then the volume of pure juice in the cocktail will equal  milliliters. The total cocktail's volume equals 3·x milliliters, so the volume fraction of the juice in the cocktail equals , that is, 66.(6) percent.",
      "solutions": [
        {
          "title": "Codeforces Round #126 (Div. 2) - Codeforces",
          "content": "Good afternoon, friends)We introduce you Codeforces Round #126 (Div. 2). Please note, Codeforces Round #126 (Div. 2) will be only today and only today you will have unique opportunity to raise your rating in this competition (certainly, you will be able to solve problems virtually after round, but this doesn't change your rating). Also round will be unrated for participants from first division.This round was prepared by students of Saratov State University: Nicolay Kuznetsov (NALP), Pavel Kholkin (HolkinPV), Igor Kudryashov (Igor_Kudryashov) and Gerald Agapov (Gerald). Also we thank creator of Codeforces Michael Mirzayanov (MikeMirzayanov) for amazing system, member of staff of Codeforces Mary Belova (Delinur) for great translation and Alexander Kuprin (Alex_KPR) for help in preparation of this round.Note, today it is decided to use dynamic scoring system (Learn more about dynamic problem scoring).Also problems will be placed in random order, it means they aren't sorted in increasing order of difficulty.More right ideas and fine solutions to you.UPD. Competition is over. Thanks for all who participated. We hope you enjoyed the participation, and round not passed in vain. Editorial will be posted soon. Congratulations to the winners: Andreos jma127 iensen Spider-man MrPapaya",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/4765",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1294
        },
        {
          "title": "Editorial of Codeforces Round #126 (Div. 2) - Codeforces",
          "content": "200A — CinemaIn this problem were given the field, which size is n × m, and k queries. Each query is the cell of the field. You had to find closest free cell for given one (there was used manhattan metric). Than found cell was marked as used. The time complexity of the solution is supposed to be . Firstly, we show the main idea, than we show why solution has time complexity .First of all, if n > m, than rotate matrix by 90 degrees (than we explain purpose of this transformation). We will have two matrices, size of each is n × m. In this matrices we will maintain for each cell the nearest free one to the left and to the right. Suppose we have query — cell (x, y). Iterate d — how much rows we will go above or below. Suppose we fix d, than look at the row x - d, for example (also we should do same things for row x + d). Lets find in this row nearest free cells to the left and to the right of (x - d, y) by using our matrices and try to update answer. When d will be greater than current found answer we will stop, because answer won't update in this case. After we find the answer, we have to change value in some cells of our matrices. It can be done by using structure DSU for each row.Lets show why this solution has time complexity . Suppose all queries are equal, for example each query is (x, y). Than if field is big enough, all points will be placed in form of square, which is rotated by 45 degrees and have center in point (x, y). Also the side of the square will have length . Than diagonal will have length too. It means that we see rows in each query and we do O(1) operations in each row. If the square doesn't fit into the field, than field is too thin verticaly or horizontaly. So we will have figure looks like rectangle, and one side of this rectangle will be less than . In this case rotate field so, than least side of rectangle means rows. Than we will see not greater than rows in each query and will perform not greater than O(1) operations in each row.This problem is supposed to be the hardest problem of the contest.200B — DrinksThis problem was the easiest problem of the contest. There you had to find average of the given numbers. The most participants solved this problem.200C — Football ChampionshipIn this problem was given description of the group stage of some football competition and scoring system. There were given results of all matches, excepting one, and you had to find result of the last match, satisfied some given criterias. Also Berland's team must be first or the second team of the group after than match.Lets note, that in each finished match were not greater than 18 goals. It means that we can brute-force all results of the last match, when score is not greater than 200 goals, and find the best one. One of the easiest way is to fill table to the end (it means to change points value and balls value), than to sort teams according to the given rules and to check that Berland is the first or the second team of the group.200D — Programming LanguageIn this task were given the list of template functions. Each function have its name and the list of types of arguments (also it can be used universal type). Also there were given set of variables and thier types, and some queries. Each query is function, which has name and list of arguments. For each query you had to find, how many functions from the given list fit to the function from query. There fit means that functions have the same name, same number of arguments and types of all arguments also equal.For solving this problem it is needed to implement comparing of functions. Constrains gave the possibility to brute-force function from the given list and check if the names and arguments of functions are equal.200E — Tractor CollegeIn this problem were given four integer numbers c3, c4, c5, s. You had to find 0 ≤ k3 ≤ k4 ≤ k5 such, that c3·k3 + c4·k4 + c5·k5 = s and |c3·k3–c4·k4| + |c4·k4–c5·k5| is minimal.Firstly, brute-force k4 so, that s–c4·k4 ≥ 0. Than look at 4 cases, according to the sign of the value in each modulus.Lets see the case, when c3·k3–c4·k4 ≥ 0 and c4·k4–c5·k5 ≥ 0. Than we have to minimize c3·k3–c5·k5. Also 0 ≤ k3 ≤ k4 ≤ k5 and c3·k3 + c5·k5 = s–c4·k4. Lets see diofant equation c3·k3 + c5... k5 = s–c4·k4. It can be that this equation doesn't have solution. Lets see the case, when equation has solution. As c3, c5 ≥ 0, than for minimization c3·k3–c5·k5 we have to minimize k3 and maximize k5. All solutions of diofant equation c3·k3 + c5·k5 = s–c4·k4 can be described by using one argument k. Than we have to find such segment, that for all k from it, k3 will fit above constrains, such segment, that for all k from it, k5 will fit above constrains, find intersection of this segments and, if intersection isn't empty, choose such k, that k5 is maximal.Similar you have to manage remain 3 cases and choose optimal values k3 and k5 for fixed k4. Also you can note, that in all cases minimized function is linear and in segment it has minimal value in one of its ends. So we can only find such segments, that for all k from that segments k3, k5 will fit above constrains, and calculate answer in the ends of this segments. If for all fixed k4 diofant equation doesn't have solution, or intersections of the described segments are empty, than answer is IMPOSSIBLE, else we should find the best. So the time complexity is O(s·log(s)) — brute-force of k4 and solving diofant equation for fixed k4.",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/4769",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 200\\s*B"
          },
          "content_length": 5442
        },
        {
          "title": "Editorial of Codeforces Round #126 (Div. 2) - Codeforces",
          "content": "200A — CinemaIn this problem were given the field, which size is n × m, and k queries. Each query is the cell of the field. You had to find closest free cell for given one (there was used manhattan metric). Than found cell was marked as used. The time complexity of the solution is supposed to be . Firstly, we show the main idea, than we show why solution has time complexity .First of all, if n > m, than rotate matrix by 90 degrees (than we explain purpose of this transformation). We will have two matrices, size of each is n × m. In this matrices we will maintain for each cell the nearest free one to the left and to the right. Suppose we have query — cell (x, y). Iterate d — how much rows we will go above or below. Suppose we fix d, than look at the row x - d, for example (also we should do same things for row x + d). Lets find in this row nearest free cells to the left and to the right of (x - d, y) by using our matrices and try to update answer. When d will be greater than current found answer we will stop, because answer won't update in this case. After we find the answer, we have to change value in some cells of our matrices. It can be done by using structure DSU for each row.Lets show why this solution has time complexity . Suppose all queries are equal, for example each query is (x, y). Than if field is big enough, all points will be placed in form of square, which is rotated by 45 degrees and have center in point (x, y). Also the side of the square will have length . Than diagonal will have length too. It means that we see rows in each query and we do O(1) operations in each row. If the square doesn't fit into the field, than field is too thin verticaly or horizontaly. So we will have figure looks like rectangle, and one side of this rectangle will be less than . In this case rotate field so, than least side of rectangle means rows. Than we will see not greater than rows in each query and will perform not greater than O(1) operations in each row.This problem is supposed to be the hardest problem of the contest.200B — DrinksThis problem was the easiest problem of the contest. There you had to find average of the given numbers. The most participants solved this problem.200C — Football ChampionshipIn this problem was given description of the group stage of some football competition and scoring system. There were given results of all matches, excepting one, and you had to find result of the last match, satisfied some given criterias. Also Berland's team must be first or the second team of the group after than match.Lets note, that in each finished match were not greater than 18 goals. It means that we can brute-force all results of the last match, when score is not greater than 200 goals, and find the best one. One of the easiest way is to fill table to the end (it means to change points value and balls value), than to sort teams according to the given rules and to check that Berland is the first or the second team of the group.200D — Programming LanguageIn this task were given the list of template functions. Each function have its name and the list of types of arguments (also it can be used universal type). Also there were given set of variables and thier types, and some queries. Each query is function, which has name and list of arguments. For each query you had to find, how many functions from the given list fit to the function from query. There fit means that functions have the same name, same number of arguments and types of all arguments also equal.For solving this problem it is needed to implement comparing of functions. Constrains gave the possibility to brute-force function from the given list and check if the names and arguments of functions are equal.200E — Tractor CollegeIn this problem were given four integer numbers c3, c4, c5, s. You had to find 0 ≤ k3 ≤ k4 ≤ k5 such, that c3·k3 + c4·k4 + c5·k5 = s and |c3·k3–c4·k4| + |c4·k4–c5·k5| is minimal.Firstly, brute-force k4 so, that s–c4·k4 ≥ 0. Than look at 4 cases, according to the sign of the value in each modulus.Lets see the case, when c3·k3–c4·k4 ≥ 0 and c4·k4–c5·k5 ≥ 0. Than we have to minimize c3·k3–c5·k5. Also 0 ≤ k3 ≤ k4 ≤ k5 and c3·k3 + c5·k5 = s–c4·k4. Lets see diofant equation c3·k3 + c5... k5 = s–c4·k4. It can be that this equation doesn't have solution. Lets see the case, when equation has solution. As c3, c5 ≥ 0, than for minimization c3·k3–c5·k5 we have to minimize k3 and maximize k5. All solutions of diofant equation c3·k3 + c5·k5 = s–c4·k4 can be described by using one argument k. Than we have to find such segment, that for all k from it, k3 will fit above constrains, such segment, that for all k from it, k5 will fit above constrains, find intersection of this segments and, if intersection isn't empty, choose such k, that k5 is maximal.Similar you have to manage remain 3 cases and choose optimal values k3 and k5 for fixed k4. Also you can note, that in all cases minimized function is linear and in segment it has minimal value in one of its ends. So we can only find such segments, that for all k from that segments k3, k5 will fit above constrains, and calculate answer in the ends of this segments. If for all fixed k4 diofant equation doesn't have solution, or intersections of the described segments are empty, than answer is IMPOSSIBLE, else we should find the best. So the time complexity is O(s·log(s)) — brute-force of k4 and solving diofant equation for fixed k4.",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/4769",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 200\\s*B"
          },
          "content_length": 5442
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #126 (Div. 2) - Codeforces - Code 1",
          "code": "The names of teams team1 and team2 are non-empty strings, consisting of uppercase English letters, with length of no more than 20 characters; goals1, goals2 are integers from 0 to 9.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4765",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #126 (Div. 2) - Codeforces - Code 2",
          "code": "The names of teams team1 and team2 are non-empty strings, consisting of uppercase English letters, with length of no more than 20 characters; goals1, goals2 are integers from 0 to 9.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4765",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #126 (Div. 2) - Codeforces - Code 3",
          "code": "X > Y, that is, Berland is going to win this game;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4765",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #126 (Div. 2) - Codeforces - Code 4",
          "code": "X > Y, that is, Berland is going to win this game;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4765",
          "author": "Qingyu"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readEoln();\n\n    vector<int> pi = inf.readInts(n, 0, 100, \"pi\");\n    inf.readEoln();\n    \n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readEoln();\n\n    vector<int> pi = inf.readInts(n, 0, 100, \"pi\");\n    inf.readEoln();\n    \n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readEoln();\n\n    vector<int> pi = inf.readInts(n, 0, 100, \"pi\");\n    inf.readEoln();\n    \n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nconst double EPS = 1E-4;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare two sequences of doubles, max absolute or relative error = %.5f\", EPS);\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    double j = 0, p = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        n++;\r\n        j = ans.readDouble();\r\n        p = ouf.readDouble();\r\n        if (!doubleCompare(j, p, EPS)) {\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%.5f', found: '%.5f', error = '%.5f'\",\r\n                  n, englishEnding(n).c_str(), j, p, doubleDelta(j, p));\r\n        }\r\n    }\r\n\r\n    if (n == 1)\r\n        quitf(_ok, \"found '%.5f', expected '%.5f', error '%.5f'\", p, j, doubleDelta(j, p));\r\n\r\n    quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> pi(n);\n\n    if (type == \"all_zero\") {\n        fill(pi.begin(), pi.end(), 0);\n    } else if (type == \"all_hundred\") {\n        fill(pi.begin(), pi.end(), 100);\n    } else if (type == \"alternating\") {\n        for (int i = 0; i < n; ++i) {\n            pi[i] = (i % 2 == 0) ? 0 : 100;\n        }\n    } else if (type == \"increasing\") {\n        for (int i = 0; i < n; ++i) {\n            if (n == 1)\n                pi[i] = 0;\n            else\n                pi[i] = (i * 100) / (n - 1);\n        }\n    } else if (type == \"decreasing\") {\n        for (int i = 0; i < n; ++i) {\n            if (n == 1)\n                pi[i] = 100;\n            else\n                pi[i] = 100 - (i * 100) / (n - 1);\n        }\n    } else if (type == \"only_one_non_zero\") {\n        fill(pi.begin(), pi.end(), 0);\n        int pos = rnd.next(0, n - 1);\n        pi[pos] = rnd.next(1, 100);\n    } else if (type == \"only_one_non_hundred\") {\n        fill(pi.begin(), pi.end(), 100);\n        int pos = rnd.next(0, n - 1);\n        pi[pos] = rnd.next(0, 99);\n    } else if (type == \"random\") {\n        for (int i = 0; i < n; ++i) {\n            pi[i] = rnd.next(0, 100);\n        }\n    } else {\n        // default case, random\n        for (int i = 0; i < n; ++i) {\n            pi[i] = rnd.next(0, 100);\n        }\n    }\n\n    printf(\"%d\\n\", n);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d\", pi[i]);\n        if (i + 1 < n)\n            printf(\" \");\n    }\n    printf(\"\\n\");\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> pi(n);\n\n    if (type == \"all_zero\") {\n        fill(pi.begin(), pi.end(), 0);\n    } else if (type == \"all_hundred\") {\n        fill(pi.begin(), pi.end(), 100);\n    } else if (type == \"alternating\") {\n        for (int i = 0; i < n; ++i) {\n            pi[i] = (i % 2 == 0) ? 0 : 100;\n        }\n    } else if (type == \"increasing\") {\n        for (int i = 0; i < n; ++i) {\n            if (n == 1)\n                pi[i] = 0;\n            else\n                pi[i] = (i * 100) / (n - 1);\n        }\n    } else if (type == \"decreasing\") {\n        for (int i = 0; i < n; ++i) {\n            if (n == 1)\n                pi[i] = 100;\n            else\n                pi[i] = 100 - (i * 100) / (n - 1);\n        }\n    } else if (type == \"only_one_non_zero\") {\n        fill(pi.begin(), pi.end(), 0);\n        int pos = rnd.next(0, n - 1);\n        pi[pos] = rnd.next(1, 100);\n    } else if (type == \"only_one_non_hundred\") {\n        fill(pi.begin(), pi.end(), 100);\n        int pos = rnd.next(0, n - 1);\n        pi[pos] = rnd.next(0, 99);\n    } else if (type == \"random\") {\n        for (int i = 0; i < n; ++i) {\n            pi[i] = rnd.next(0, 100);\n        }\n    } else {\n        // default case, random\n        for (int i = 0; i < n; ++i) {\n            pi[i] = rnd.next(0, 100);\n        }\n    }\n\n    printf(\"%d\\n\", n);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d\", pi[i]);\n        if (i + 1 < n)\n            printf(\" \");\n    }\n    printf(\"\\n\");\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Minimum n\n./gen -n 1 -type all_zero\n./gen -n 1 -type all_hundred\n./gen -n 1 -type random\n./gen -n 1 -type increasing\n./gen -n 1 -type decreasing\n./gen -n 1 -type only_one_non_zero\n./gen -n 1 -type only_one_non_hundred\n./gen -n 1 -type alternating\n\n# Small n\n./gen -n 2 -type all_zero\n./gen -n 2 -type all_hundred\n./gen -n 2 -type alternating\n\n./gen -n 5 -type increasing\n./gen -n 5 -type decreasing\n./gen -n 5 -type random\n\n# Medium n\n./gen -n 50 -type random\n./gen -n 50 -type alternating\n./gen -n 50 -type only_one_non_zero\n./gen -n 50 -type only_one_non_hundred\n\n# Max n\n./gen -n 100 -type all_zero\n./gen -n 100 -type all_hundred\n./gen -n 100 -type random\n./gen -n 100 -type increasing\n./gen -n 100 -type decreasing\n./gen -n 100 -type alternating\n\n# Additional test cases\n./gen -n 99 -type random\n./gen -n 100 -type only_one_non_zero\n./gen -n 100 -type only_one_non_hundred\n\n# Random n\n./gen -n 17 -type random\n./gen -n 33 -type random\n./gen -n 70 -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T19:47:55.009161",
        "total_tutorials": 3,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "200/C",
      "title": "C. Football Championship",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe input has five lines.Each line describes a game as \"team1 team2 goals1:goals2\" (without the quotes), what means that team team1 played a game with team team2, besides, team1 scored goals1 goals and team2 scored goals2 goals. The names of teams team1 and team2 are non-empty strings, consisting of uppercase English letters, with length of no more than 20 characters; goals1, goals2 are integers from 0 to 9. The Berland team is called \"BERLAND\". It is guaranteed that the Berland team and one more team played exactly 2 games and the the other teams played exactly 3 games.",
      "output_spec": "OutputPrint the required score in the last game as X:Y, where X is the number of goals Berland scored and Y is the number of goals the opponent scored. If the Berland team does not get the first or the second place in the group, whatever this game's score is, then print on a single line \"IMPOSSIBLE\" (without the quotes).Note, that the result score can be very huge, 10:0 for example.",
      "sample_tests": "ExamplesInputCopyAERLAND DERLAND 2:1DERLAND CERLAND 0:3CERLAND AERLAND 0:1AERLAND BERLAND 2:0DERLAND BERLAND 4:0OutputCopy6:0InputCopyAERLAND DERLAND 2:2DERLAND CERLAND 2:3CERLAND AERLAND 1:3AERLAND BERLAND 2:1DERLAND BERLAND 4:1OutputCopyIMPOSSIBLE",
      "description": "C. Football Championship\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe input has five lines.Each line describes a game as \"team1 team2 goals1:goals2\" (without the quotes), what means that team team1 played a game with team team2, besides, team1 scored goals1 goals and team2 scored goals2 goals. The names of teams team1 and team2 are non-empty strings, consisting of uppercase English letters, with length of no more than 20 characters; goals1, goals2 are integers from 0 to 9. The Berland team is called \"BERLAND\". It is guaranteed that the Berland team and one more team played exactly 2 games and the the other teams played exactly 3 games.\n\nOutputPrint the required score in the last game as X:Y, where X is the number of goals Berland scored and Y is the number of goals the opponent scored. If the Berland team does not get the first or the second place in the group, whatever this game's score is, then print on a single line \"IMPOSSIBLE\" (without the quotes).Note, that the result score can be very huge, 10:0 for example.\n\nInputCopyAERLAND DERLAND 2:1DERLAND CERLAND 0:3CERLAND AERLAND 0:1AERLAND BERLAND 2:0DERLAND BERLAND 4:0OutputCopy6:0InputCopyAERLAND DERLAND 2:2DERLAND CERLAND 2:3CERLAND AERLAND 1:3AERLAND BERLAND 2:1DERLAND BERLAND 4:1OutputCopyIMPOSSIBLE\n\nInputCopyAERLAND DERLAND 2:1DERLAND CERLAND 0:3CERLAND AERLAND 0:1AERLAND BERLAND 2:0DERLAND BERLAND 4:0\n\nOutputCopy6:0\n\nInputCopyAERLAND DERLAND 2:2DERLAND CERLAND 2:3CERLAND AERLAND 1:3AERLAND BERLAND 2:1DERLAND BERLAND 4:1\n\nOutputCopyIMPOSSIBLE\n\nNoteIn the first sample \"BERLAND\" plays the last game with team \"CERLAND\". If Berland wins with score 6:0, the results' table looks like that in the end:   AERLAND (points: 9, the difference between scored and missed goals: 4, scored goals: 5)  BERLAND (points: 3, the difference between scored and missed goals: 0, scored goals: 6)  DERLAND (points: 3, the difference between scored and missed goals: 0, scored goals: 5)  CERLAND (points: 3, the difference between scored and missed goals: -4, scored goals: 3) In the second sample teams \"AERLAND\" and \"DERLAND\" have already won 7 and 4 points, respectively. The Berland team wins only 3 points, which is not enough to advance to the next championship stage.",
      "solutions": [
        {
          "title": "Codeforces Round #126 (Div. 2) - Codeforces",
          "content": "Good afternoon, friends)We introduce you Codeforces Round #126 (Div. 2). Please note, Codeforces Round #126 (Div. 2) will be only today and only today you will have unique opportunity to raise your rating in this competition (certainly, you will be able to solve problems virtually after round, but this doesn't change your rating). Also round will be unrated for participants from first division.This round was prepared by students of Saratov State University: Nicolay Kuznetsov (NALP), Pavel Kholkin (HolkinPV), Igor Kudryashov (Igor_Kudryashov) and Gerald Agapov (Gerald). Also we thank creator of Codeforces Michael Mirzayanov (MikeMirzayanov) for amazing system, member of staff of Codeforces Mary Belova (Delinur) for great translation and Alexander Kuprin (Alex_KPR) for help in preparation of this round.Note, today it is decided to use dynamic scoring system (Learn more about dynamic problem scoring).Also problems will be placed in random order, it means they aren't sorted in increasing order of difficulty.More right ideas and fine solutions to you.UPD. Competition is over. Thanks for all who participated. We hope you enjoyed the participation, and round not passed in vain. Editorial will be posted soon. Congratulations to the winners: Andreos jma127 iensen Spider-man MrPapaya",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/4765",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1294
        },
        {
          "title": "Editorial of Codeforces Round #126 (Div. 2) - Codeforces",
          "content": "200A — CinemaIn this problem were given the field, which size is n × m, and k queries. Each query is the cell of the field. You had to find closest free cell for given one (there was used manhattan metric). Than found cell was marked as used. The time complexity of the solution is supposed to be . Firstly, we show the main idea, than we show why solution has time complexity .First of all, if n > m, than rotate matrix by 90 degrees (than we explain purpose of this transformation). We will have two matrices, size of each is n × m. In this matrices we will maintain for each cell the nearest free one to the left and to the right. Suppose we have query — cell (x, y). Iterate d — how much rows we will go above or below. Suppose we fix d, than look at the row x - d, for example (also we should do same things for row x + d). Lets find in this row nearest free cells to the left and to the right of (x - d, y) by using our matrices and try to update answer. When d will be greater than current found answer we will stop, because answer won't update in this case. After we find the answer, we have to change value in some cells of our matrices. It can be done by using structure DSU for each row.Lets show why this solution has time complexity . Suppose all queries are equal, for example each query is (x, y). Than if field is big enough, all points will be placed in form of square, which is rotated by 45 degrees and have center in point (x, y). Also the side of the square will have length . Than diagonal will have length too. It means that we see rows in each query and we do O(1) operations in each row. If the square doesn't fit into the field, than field is too thin verticaly or horizontaly. So we will have figure looks like rectangle, and one side of this rectangle will be less than . In this case rotate field so, than least side of rectangle means rows. Than we will see not greater than rows in each query and will perform not greater than O(1) operations in each row.This problem is supposed to be the hardest problem of the contest.200B — DrinksThis problem was the easiest problem of the contest. There you had to find average of the given numbers. The most participants solved this problem.200C — Football ChampionshipIn this problem was given description of the group stage of some football competition and scoring system. There were given results of all matches, excepting one, and you had to find result of the last match, satisfied some given criterias. Also Berland's team must be first or the second team of the group after than match.Lets note, that in each finished match were not greater than 18 goals. It means that we can brute-force all results of the last match, when score is not greater than 200 goals, and find the best one. One of the easiest way is to fill table to the end (it means to change points value and balls value), than to sort teams according to the given rules and to check that Berland is the first or the second team of the group.200D — Programming LanguageIn this task were given the list of template functions. Each function have its name and the list of types of arguments (also it can be used universal type). Also there were given set of variables and thier types, and some queries. Each query is function, which has name and list of arguments. For each query you had to find, how many functions from the given list fit to the function from query. There fit means that functions have the same name, same number of arguments and types of all arguments also equal.For solving this problem it is needed to implement comparing of functions. Constrains gave the possibility to brute-force function from the given list and check if the names and arguments of functions are equal.200E — Tractor CollegeIn this problem were given four integer numbers c3, c4, c5, s. You had to find 0 ≤ k3 ≤ k4 ≤ k5 such, that c3·k3 + c4·k4 + c5·k5 = s and |c3·k3–c4·k4| + |c4·k4–c5·k5| is minimal.Firstly, brute-force k4 so, that s–c4·k4 ≥ 0. Than look at 4 cases, according to the sign of the value in each modulus.Lets see the case, when c3·k3–c4·k4 ≥ 0 and c4·k4–c5·k5 ≥ 0. Than we have to minimize c3·k3–c5·k5. Also 0 ≤ k3 ≤ k4 ≤ k5 and c3·k3 + c5·k5 = s–c4·k4. Lets see diofant equation c3·k3 + c5... k5 = s–c4·k4. It can be that this equation doesn't have solution. Lets see the case, when equation has solution. As c3, c5 ≥ 0, than for minimization c3·k3–c5·k5 we have to minimize k3 and maximize k5. All solutions of diofant equation c3·k3 + c5·k5 = s–c4·k4 can be described by using one argument k. Than we have to find such segment, that for all k from it, k3 will fit above constrains, such segment, that for all k from it, k5 will fit above constrains, find intersection of this segments and, if intersection isn't empty, choose such k, that k5 is maximal.Similar you have to manage remain 3 cases and choose optimal values k3 and k5 for fixed k4. Also you can note, that in all cases minimized function is linear and in segment it has minimal value in one of its ends. So we can only find such segments, that for all k from that segments k3, k5 will fit above constrains, and calculate answer in the ends of this segments. If for all fixed k4 diofant equation doesn't have solution, or intersections of the described segments are empty, than answer is IMPOSSIBLE, else we should find the best. So the time complexity is O(s·log(s)) — brute-force of k4 and solving diofant equation for fixed k4.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/4769",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 200\\s*C"
          },
          "content_length": 5442
        },
        {
          "title": "Editorial of Codeforces Round #126 (Div. 2) - Codeforces",
          "content": "200A — CinemaIn this problem were given the field, which size is n × m, and k queries. Each query is the cell of the field. You had to find closest free cell for given one (there was used manhattan metric). Than found cell was marked as used. The time complexity of the solution is supposed to be . Firstly, we show the main idea, than we show why solution has time complexity .First of all, if n > m, than rotate matrix by 90 degrees (than we explain purpose of this transformation). We will have two matrices, size of each is n × m. In this matrices we will maintain for each cell the nearest free one to the left and to the right. Suppose we have query — cell (x, y). Iterate d — how much rows we will go above or below. Suppose we fix d, than look at the row x - d, for example (also we should do same things for row x + d). Lets find in this row nearest free cells to the left and to the right of (x - d, y) by using our matrices and try to update answer. When d will be greater than current found answer we will stop, because answer won't update in this case. After we find the answer, we have to change value in some cells of our matrices. It can be done by using structure DSU for each row.Lets show why this solution has time complexity . Suppose all queries are equal, for example each query is (x, y). Than if field is big enough, all points will be placed in form of square, which is rotated by 45 degrees and have center in point (x, y). Also the side of the square will have length . Than diagonal will have length too. It means that we see rows in each query and we do O(1) operations in each row. If the square doesn't fit into the field, than field is too thin verticaly or horizontaly. So we will have figure looks like rectangle, and one side of this rectangle will be less than . In this case rotate field so, than least side of rectangle means rows. Than we will see not greater than rows in each query and will perform not greater than O(1) operations in each row.This problem is supposed to be the hardest problem of the contest.200B — DrinksThis problem was the easiest problem of the contest. There you had to find average of the given numbers. The most participants solved this problem.200C — Football ChampionshipIn this problem was given description of the group stage of some football competition and scoring system. There were given results of all matches, excepting one, and you had to find result of the last match, satisfied some given criterias. Also Berland's team must be first or the second team of the group after than match.Lets note, that in each finished match were not greater than 18 goals. It means that we can brute-force all results of the last match, when score is not greater than 200 goals, and find the best one. One of the easiest way is to fill table to the end (it means to change points value and balls value), than to sort teams according to the given rules and to check that Berland is the first or the second team of the group.200D — Programming LanguageIn this task were given the list of template functions. Each function have its name and the list of types of arguments (also it can be used universal type). Also there were given set of variables and thier types, and some queries. Each query is function, which has name and list of arguments. For each query you had to find, how many functions from the given list fit to the function from query. There fit means that functions have the same name, same number of arguments and types of all arguments also equal.For solving this problem it is needed to implement comparing of functions. Constrains gave the possibility to brute-force function from the given list and check if the names and arguments of functions are equal.200E — Tractor CollegeIn this problem were given four integer numbers c3, c4, c5, s. You had to find 0 ≤ k3 ≤ k4 ≤ k5 such, that c3·k3 + c4·k4 + c5·k5 = s and |c3·k3–c4·k4| + |c4·k4–c5·k5| is minimal.Firstly, brute-force k4 so, that s–c4·k4 ≥ 0. Than look at 4 cases, according to the sign of the value in each modulus.Lets see the case, when c3·k3–c4·k4 ≥ 0 and c4·k4–c5·k5 ≥ 0. Than we have to minimize c3·k3–c5·k5. Also 0 ≤ k3 ≤ k4 ≤ k5 and c3·k3 + c5·k5 = s–c4·k4. Lets see diofant equation c3·k3 + c5... k5 = s–c4·k4. It can be that this equation doesn't have solution. Lets see the case, when equation has solution. As c3, c5 ≥ 0, than for minimization c3·k3–c5·k5 we have to minimize k3 and maximize k5. All solutions of diofant equation c3·k3 + c5·k5 = s–c4·k4 can be described by using one argument k. Than we have to find such segment, that for all k from it, k3 will fit above constrains, such segment, that for all k from it, k5 will fit above constrains, find intersection of this segments and, if intersection isn't empty, choose such k, that k5 is maximal.Similar you have to manage remain 3 cases and choose optimal values k3 and k5 for fixed k4. Also you can note, that in all cases minimized function is linear and in segment it has minimal value in one of its ends. So we can only find such segments, that for all k from that segments k3, k5 will fit above constrains, and calculate answer in the ends of this segments. If for all fixed k4 diofant equation doesn't have solution, or intersections of the described segments are empty, than answer is IMPOSSIBLE, else we should find the best. So the time complexity is O(s·log(s)) — brute-force of k4 and solving diofant equation for fixed k4.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/4769",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 200\\s*C"
          },
          "content_length": 5442
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #126 (Div. 2) - Codeforces - Code 1",
          "code": "The names of teams team1 and team2 are non-empty strings, consisting of uppercase English letters, with length of no more than 20 characters; goals1, goals2 are integers from 0 to 9.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4765",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #126 (Div. 2) - Codeforces - Code 2",
          "code": "The names of teams team1 and team2 are non-empty strings, consisting of uppercase English letters, with length of no more than 20 characters; goals1, goals2 are integers from 0 to 9.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4765",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #126 (Div. 2) - Codeforces - Code 3",
          "code": "X > Y, that is, Berland is going to win this game;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4765",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #126 (Div. 2) - Codeforces - Code 4",
          "code": "X > Y, that is, Berland is going to win this game;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4765",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    set<pair<string, string>> matches;\n    map<string, int> gamesPlayed;\n    set<string> teams;\n\n    for (int i = 0; i < 5; ++i) {\n        string team1 = inf.readToken(\"[A-Z]{1,20}\", \"team1\");\n        inf.readSpace();\n        string team2 = inf.readToken(\"[A-Z]{1,20}\", \"team2\");\n\n        ensuref(team1 != team2, \"team1 and team2 must be different\");\n\n        inf.readSpace();\n\n        // Read goals1\n        char c1 = inf.readChar();\n        ensuref(isdigit(c1), \"goals1 must be a digit between 0 and 9\");\n        int goals1 = c1 - '0';\n\n        // Read ':'\n        char colon = inf.readChar();\n        ensuref(colon == ':', \"Expected ':' between goals1 and goals2\");\n\n        // Read goals2\n        char c2 = inf.readChar();\n        ensuref(isdigit(c2), \"goals2 must be a digit between 0 and 9\");\n        int goals2 = c2 - '0';\n\n        inf.readEoln();\n\n        // Check for duplicate matches\n        string t_min = min(team1, team2);\n        string t_max = max(team1, team2);\n        pair<string, string> match = make_pair(t_min, t_max);\n        ensuref(matches.count(match) == 0, \"Duplicate match between %s and %s\", t_min.c_str(), t_max.c_str());\n        matches.insert(match);\n\n        gamesPlayed[team1]++;\n        gamesPlayed[team2]++;\n        teams.insert(team1);\n        teams.insert(team2);\n    }\n\n    inf.readEof();\n\n    ensuref(teams.size() == 4, \"Number of teams must be 4\");\n    ensuref(teams.count(\"BERLAND\") == 1, \"BERLAND must be one of the teams\");\n    ensuref(gamesPlayed[\"BERLAND\"] == 2, \"BERLAND must have played exactly 2 games (played %d games)\", gamesPlayed[\"BERLAND\"]);\n\n    int teamsWith2Games = 0;\n    for (auto& p : gamesPlayed) {\n        if (p.second == 2) {\n            teamsWith2Games++;\n        } else if (p.second == 3) {\n            // Ok\n        } else {\n            ensuref(false, \"Team %s has invalid number of games played %d\", p.first.c_str(), p.second);\n        }\n    }\n    ensuref(teamsWith2Games == 2, \"Exactly two teams must have played 2 games\");\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    set<pair<string, string>> matches;\n    map<string, int> gamesPlayed;\n    set<string> teams;\n\n    for (int i = 0; i < 5; ++i) {\n        string team1 = inf.readToken(\"[A-Z]{1,20}\", \"team1\");\n        inf.readSpace();\n        string team2 = inf.readToken(\"[A-Z]{1,20}\", \"team2\");\n\n        ensuref(team1 != team2, \"team1 and team2 must be different\");\n\n        inf.readSpace();\n\n        // Read goals1\n        char c1 = inf.readChar();\n        ensuref(isdigit(c1), \"goals1 must be a digit between 0 and 9\");\n        int goals1 = c1 - '0';\n\n        // Read ':'\n        char colon = inf.readChar();\n        ensuref(colon == ':', \"Expected ':' between goals1 and goals2\");\n\n        // Read goals2\n        char c2 = inf.readChar();\n        ensuref(isdigit(c2), \"goals2 must be a digit between 0 and 9\");\n        int goals2 = c2 - '0';\n\n        inf.readEoln();\n\n        // Check for duplicate matches\n        string t_min = min(team1, team2);\n        string t_max = max(team1, team2);\n        pair<string, string> match = make_pair(t_min, t_max);\n        ensuref(matches.count(match) == 0, \"Duplicate match between %s and %s\", t_min.c_str(), t_max.c_str());\n        matches.insert(match);\n\n        gamesPlayed[team1]++;\n        gamesPlayed[team2]++;\n        teams.insert(team1);\n        teams.insert(team2);\n    }\n\n    inf.readEof();\n\n    ensuref(teams.size() == 4, \"Number of teams must be 4\");\n    ensuref(teams.count(\"BERLAND\") == 1, \"BERLAND must be one of the teams\");\n    ensuref(gamesPlayed[\"BERLAND\"] == 2, \"BERLAND must have played exactly 2 games (played %d games)\", gamesPlayed[\"BERLAND\"]);\n\n    int teamsWith2Games = 0;\n    for (auto& p : gamesPlayed) {\n        if (p.second == 2) {\n            teamsWith2Games++;\n        } else if (p.second == 3) {\n            // Ok\n        } else {\n            ensuref(false, \"Team %s has invalid number of games played %d\", p.first.c_str(), p.second);\n        }\n    }\n    ensuref(teamsWith2Games == 2, \"Exactly two teams must have played 2 games\");\n\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    set<pair<string, string>> matches;\n    map<string, int> gamesPlayed;\n    set<string> teams;\n\n    for (int i = 0; i < 5; ++i) {\n        string team1 = inf.readToken(\"[A-Z]{1,20}\", \"team1\");\n        inf.readSpace();\n        string team2 = inf.readToken(\"[A-Z]{1,20}\", \"team2\");\n\n        ensuref(team1 != team2, \"team1 and team2 must be different\");\n\n        inf.readSpace();\n\n        // Read goals1\n        char c1 = inf.readChar();\n        ensuref(isdigit(c1), \"goals1 must be a digit between 0 and 9\");\n        int goals1 = c1 - '0';\n\n        // Read ':'\n        char colon = inf.readChar();\n        ensuref(colon == ':', \"Expected ':' between goals1 and goals2\");\n\n        // Read goals2\n        char c2 = inf.readChar();\n        ensuref(isdigit(c2), \"goals2 must be a digit between 0 and 9\");\n        int goals2 = c2 - '0';\n\n        inf.readEoln();\n\n        // Check for duplicate matches\n        string t_min = min(team1, team2);\n        string t_max = max(team1, team2);\n        pair<string, string> match = make_pair(t_min, t_max);\n        ensuref(matches.count(match) == 0, \"Duplicate match between %s and %s\", t_min.c_str(), t_max.c_str());\n        matches.insert(match);\n\n        gamesPlayed[team1]++;\n        gamesPlayed[team2]++;\n        teams.insert(team1);\n        teams.insert(team2);\n    }\n\n    inf.readEof();\n\n    ensuref(teams.size() == 4, \"Number of teams must be 4\");\n    ensuref(teams.count(\"BERLAND\") == 1, \"BERLAND must be one of the teams\");\n    ensuref(gamesPlayed[\"BERLAND\"] == 2, \"BERLAND must have played exactly 2 games (played %d games)\", gamesPlayed[\"BERLAND\"]);\n\n    int teamsWith2Games = 0;\n    for (auto& p : gamesPlayed) {\n        if (p.second == 2) {\n            teamsWith2Games++;\n        } else if (p.second == 3) {\n            // Ok\n        } else {\n            ensuref(false, \"Team %s has invalid number of games played %d\", p.first.c_str(), p.second);\n        }\n    }\n    ensuref(teamsWith2Games == 2, \"Exactly two teams must have played 2 games\");\n\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare sequences of tokens\");\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string j, p;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n\r\n        ans.readWordTo(j);\r\n        ouf.readWordTo(p);\r\n\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s words differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  compress(j).c_str(), compress(p).c_str());\r\n    }\r\n\r\n    if (ans.seekEof() && ouf.seekEof()) {\r\n        if (n == 1)\r\n            quitf(_ok, \"\\\"%s\\\"\", compress(j).c_str());\r\n        else\r\n            quitf(_ok, \"%d tokens\", n);\r\n    } else {\r\n        if (ans.seekEof())\r\n            quitf(_wa, \"Participant output contains extra tokens\");\r\n        else\r\n            quitf(_wa, \"Unexpected EOF in the participants output\");\r\n    }\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\n/*\n  Generator for the \"Berland Football Championship\" problem.\n\n  -------------------------------------------------------------\n  HOW IT WORKS\n\n  We have exactly 4 teams in a single group: \"BERLAND\" plus 3 others.\n  The group plays 6 matches total (each pair of teams plays exactly once).\n  However, the input only gives us 5 matches (the last match is missing).\n  By the problem statement, \"BERLAND\" and exactly one other team\n  have only 2 matches in these 5 lines, so their match is the missing one.\n\n  In other words:\n    There are 4 teams: [BERLAND, T1, T2, T3].\n    Every pair among those 4 teams should play exactly once.\n    That gives 6 total pairs:\n       (BERLAND, T1)\n       (BERLAND, T2)\n       (BERLAND, T3)\n       (T1, T2)\n       (T2, T3)\n       (T3, T1)\n\n    Only 5 of these pairs appear in the input. The missing pair is\n    (BERLAND, Tmissing), for some Tmissing in {T1, T2, T3}.\n\n  Each of the 5 lines is in the format:\n      TEAM1 TEAM2 x:y\n  where TEAM1 and TEAM2 are uppercase strings, length ≤ 20,\n  and x,y are integers in [0..9].\n\n  This generator allows different \"test case\" types via the parameter -tc.\n  Some test types produce fixed partial results (corner / special cases),\n  while others produce random partial results. Each run outputs exactly\n  one test (5 lines).\n\n  -------------------------------------------------------------\n  HOW TO USE\n\n    Compile and run:\n      ./gen -tc=1\n    or\n      ./gen -tc=7\n    etc.\n\n    You can produce many tests by running\n      ./gen -tc=<value>\n    for different <value>.\n\n  -------------------------------------------------------------\n  ARGUMENTS\n\n    -tc : integer, selects which test scenario (1..N). Default = 1.\n\n  -------------------------------------------------------------\n*/\n\nstatic const vector<string> possibleTeams = {\n    \"AERLAND\", \"CERLAND\", \"DERLAND\"\n    // You could add more if you wish, but three is enough for our group of 4.\n};\n\nstruct Match {\n    string A, B;\n    int x, y; // goals in [0..9]\n};\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    // Parse parameters\n    int tc = opt<int>(\"tc\", 1);\n\n    // Our three non-BERLAND teams\n    // We'll stick to these for consistency:\n    string T1 = \"AERLAND\";\n    string T2 = \"CERLAND\";\n    string T3 = \"DERLAND\";\n\n    // We'll pick which team is missing the match vs. BERLAND.\n    // For variety in certain test cases, we can fix it or shuffle it.\n    // We'll store them in a small array for convenience.\n    vector<string> others = {T1, T2, T3};\n\n    // We'll define a function that, given which team is missing,\n    // returns the 5 matches that DO appear, with some (possibly random) results.\n    auto produceMatches = [&](string missingTeam, int scenario) {\n        /*\n          The 6 possible pairs are:\n            (BERLAND, T1)\n            (BERLAND, T2)\n            (BERLAND, T3)\n            (T1, T2)\n            (T2, T3)\n            (T3, T1)\n\n          If missingTeam = T1, we skip (BERLAND, T1).\n          Then the 5 matches are:\n            (BERLAND, T2)\n            (BERLAND, T3)\n            (T1, T2)\n            (T1, T3)\n            (T2, T3)\n\n          We'll produce results for each match in [0..9].\n          Depending on scenario, we can do fixed or random results.\n        */\n\n        vector<Match> matches;\n\n        auto addMatch = [&](string A, string B, int x, int y) {\n            Match m;\n            m.A = A;\n            m.B = B;\n            m.x = x;\n            m.y = y;\n            matches.push_back(m);\n        };\n\n        // We'll store the 5 needed pairs in a small buffer\n        vector<pair<string,string>> pairs;\n        // Collect the 5 pairs that DO appear\n        set<pair<string,string>> allPairs = {\n            {\"BERLAND\", T1},\n            {\"BERLAND\", T2},\n            {\"BERLAND\", T3},\n            {T1, T2},\n            {T2, T3},\n            {T3, T1}\n        };\n\n        // We want to skip the pair (BERLAND, missingTeam).\n        // Because in the problem statement format, it's always \"team1 team2 ...\" but\n        // we don't forbid reversing them. However, let's keep it consistent:\n        // We'll remove the pair in whichever order it might appear.\n        // We can remove both (BERLAND, missingTeam) and (missingTeam, BERLAND) just in case.\n        set<pair<string,string>> toRemove;\n        toRemove.insert({\"BERLAND\", missingTeam});\n        toRemove.insert({missingTeam, \"BERLAND\"});\n        for (auto rm : toRemove) {\n            if (allPairs.find(rm) != allPairs.end()) {\n                allPairs.erase(rm);\n            }\n        }\n\n        // Now allPairs should have exactly 5 pairs.\n        vector<pair<string,string>> finalPairs(allPairs.begin(), allPairs.end());\n\n        // SCENARIOS:\n        // We'll define a handful of special, then random for the leftover\n\n        // A helper to get random [0..9]\n        auto randScore = [&]() {\n            return rnd.next(10); // [0..9]\n        };\n\n        // We'll fill the scoreboard.\n        switch (scenario) {\n            case 1:\n            {\n                // Case 1: Berland always loses heavily, making it likely IMPOSSIBLE.\n                // We'll specifically set big losses if \"BERLAND\" is in the match.\n                for (auto &p : finalPairs) {\n                    int x, y;\n                    if (p.first == \"BERLAND\") {\n                        // Berland concedes more\n                        x = rnd.next(2);   // 0..1\n                        y = 9;            // huge\n                    } else if (p.second == \"BERLAND\") {\n                        // Berland concedes more\n                        x = 9;\n                        y = rnd.next(2);  // 0..1\n                    } else {\n                        // For other pairs, set random small\n                        x = randScore();\n                        y = randScore();\n                    }\n                    addMatch(p.first, p.second, x, y);\n                }\n                break;\n            }\n            case 2:\n            {\n                // Case 2: Many draws or narrow margins; possibly small random.\n                for (auto &p : finalPairs) {\n                    int x, y;\n                    // 50% chance for exact draw, else a 1-goal difference\n                    if (rnd.next(2) == 0) {\n                        // draw\n                        x = rnd.next(5);\n                        y = x;\n                    } else {\n                        // one-goal difference\n                        x = rnd.next(5);\n                        y = x + (rnd.next(2) ? 1 : -1);\n                        if (y < 0) y = 0; \n                        if (y > 9) y = 9; \n                    }\n                    addMatch(p.first, p.second, x, y);\n                }\n                break;\n            }\n            case 3:\n            {\n                // Case 3: Berland is \"almost out,\" has 2 large defeats,\n                // but the other matches vary.\n                // This might force a big victory in the final.\n                for (auto &p : finalPairs) {\n                    if (p.first == \"BERLAND\" || p.second == \"BERLAND\") {\n                        // Let Berland lose 2:9 or 1:9\n                        int x = rnd.next(2); // 0..1\n                        int y = 9;\n                        // If reversed, so be it\n                        addMatch(p.first, p.second, x, y);\n                    } else {\n                        // random\n                        addMatch(p.first, p.second, randScore(), randScore());\n                    }\n                }\n                break;\n            }\n            case 4:\n            {\n                // Case 4: Berland is doing fairly well, close to top. \n                // We'll let Berland have 1 big win, 1 big loss, to create tie/edge cases.\n                // Others random.\n                for (auto &p : finalPairs) {\n                    if (p.first == \"BERLAND\" || p.second == \"BERLAND\") {\n                        if (rnd.next(2) == 0) {\n                            // Big win for Berland\n                            addMatch(p.first, p.second, 9, 0);\n                        } else {\n                            // Big loss for Berland\n                            addMatch(p.first, p.second, 0, 9);\n                        }\n                    } else {\n                        addMatch(p.first, p.second, randScore(), randScore());\n                    }\n                }\n                break;\n            }\n            case 5:\n            {\n                // Case 5: All small random. Could be mild or consistent.\n                for (auto &p : finalPairs) {\n                    int x = rnd.next(3); // [0..2]\n                    int y = rnd.next(3); // [0..2]\n                    addMatch(p.first, p.second, x, y);\n                }\n                break;\n            }\n            case 6:\n            {\n                // Case 6: Driven example to create multi-way tie.\n                // We'll craft the partial results so that everyone\n                // except the missing match lumps into some very balanced scenario.\n                // All draws with 1:1\n                for (auto &p : finalPairs) {\n                    addMatch(p.first, p.second, 1, 1);\n                }\n                break;\n            }\n\n            default:\n            {\n                // Otherwise: \"random\" scenario for variety\n                for (auto &p : finalPairs) {\n                    addMatch(p.first, p.second, randScore(), randScore());\n                }\n                break;\n            }\n        }\n\n        return matches;\n    };\n\n    // We'll pick which team is missing in a round-robin way or random, based on (tc mod 3).\n    // This is just a simple scheme to ensure variety across testcases.\n    // If you want to fix it for certain testcases, you can do that in a bigger switch.\n    int pickMissingIndex = (tc - 1) % 3; \n    string missingTeam = others[pickMissingIndex];\n\n    // We'll also pick a scenario from 1..7 or so (some are special, some random).\n    // E.g. scenario = (tc - 1) % 7 + 1\n    int scenario = (tc - 1) % 7 + 1;\n\n    // Now produce our 5 lines:\n    vector<Match> matches = produceMatches(missingTeam, scenario);\n\n    // Finally, print them.\n    // Format: \"TEAM1 TEAM2 x:y\"\n    // x,y in [0..9].\n    // These are guaranteed by our logic above.\n\n    for (auto &m : matches) {\n        printf(\"%s %s %d:%d\\n\", m.A.c_str(), m.B.c_str(), m.x, m.y);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\n/*\n  Generator for the \"Berland Football Championship\" problem.\n\n  -------------------------------------------------------------\n  HOW IT WORKS\n\n  We have exactly 4 teams in a single group: \"BERLAND\" plus 3 others.\n  The group plays 6 matches total (each pair of teams plays exactly once).\n  However, the input only gives us 5 matches (the last match is missing).\n  By the problem statement, \"BERLAND\" and exactly one other team\n  have only 2 matches in these 5 lines, so their match is the missing one.\n\n  In other words:\n    There are 4 teams: [BERLAND, T1, T2, T3].\n    Every pair among those 4 teams should play exactly once.\n    That gives 6 total pairs:\n       (BERLAND, T1)\n       (BERLAND, T2)\n       (BERLAND, T3)\n       (T1, T2)\n       (T2, T3)\n       (T3, T1)\n\n    Only 5 of these pairs appear in the input. The missing pair is\n    (BERLAND, Tmissing), for some Tmissing in {T1, T2, T3}.\n\n  Each of the 5 lines is in the format:\n      TEAM1 TEAM2 x:y\n  where TEAM1 and TEAM2 are uppercase strings, length ≤ 20,\n  and x,y are integers in [0..9].\n\n  This generator allows different \"test case\" types via the parameter -tc.\n  Some test types produce fixed partial results (corner / special cases),\n  while others produce random partial results. Each run outputs exactly\n  one test (5 lines).\n\n  -------------------------------------------------------------\n  HOW TO USE\n\n    Compile and run:\n      ./gen -tc=1\n    or\n      ./gen -tc=7\n    etc.\n\n    You can produce many tests by running\n      ./gen -tc=<value>\n    for different <value>.\n\n  -------------------------------------------------------------\n  ARGUMENTS\n\n    -tc : integer, selects which test scenario (1..N). Default = 1.\n\n  -------------------------------------------------------------\n*/\n\nstatic const vector<string> possibleTeams = {\n    \"AERLAND\", \"CERLAND\", \"DERLAND\"\n    // You could add more if you wish, but three is enough for our group of 4.\n};\n\nstruct Match {\n    string A, B;\n    int x, y; // goals in [0..9]\n};\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    // Parse parameters\n    int tc = opt<int>(\"tc\", 1);\n\n    // Our three non-BERLAND teams\n    // We'll stick to these for consistency:\n    string T1 = \"AERLAND\";\n    string T2 = \"CERLAND\";\n    string T3 = \"DERLAND\";\n\n    // We'll pick which team is missing the match vs. BERLAND.\n    // For variety in certain test cases, we can fix it or shuffle it.\n    // We'll store them in a small array for convenience.\n    vector<string> others = {T1, T2, T3};\n\n    // We'll define a function that, given which team is missing,\n    // returns the 5 matches that DO appear, with some (possibly random) results.\n    auto produceMatches = [&](string missingTeam, int scenario) {\n        /*\n          The 6 possible pairs are:\n            (BERLAND, T1)\n            (BERLAND, T2)\n            (BERLAND, T3)\n            (T1, T2)\n            (T2, T3)\n            (T3, T1)\n\n          If missingTeam = T1, we skip (BERLAND, T1).\n          Then the 5 matches are:\n            (BERLAND, T2)\n            (BERLAND, T3)\n            (T1, T2)\n            (T1, T3)\n            (T2, T3)\n\n          We'll produce results for each match in [0..9].\n          Depending on scenario, we can do fixed or random results.\n        */\n\n        vector<Match> matches;\n\n        auto addMatch = [&](string A, string B, int x, int y) {\n            Match m;\n            m.A = A;\n            m.B = B;\n            m.x = x;\n            m.y = y;\n            matches.push_back(m);\n        };\n\n        // We'll store the 5 needed pairs in a small buffer\n        vector<pair<string,string>> pairs;\n        // Collect the 5 pairs that DO appear\n        set<pair<string,string>> allPairs = {\n            {\"BERLAND\", T1},\n            {\"BERLAND\", T2},\n            {\"BERLAND\", T3},\n            {T1, T2},\n            {T2, T3},\n            {T3, T1}\n        };\n\n        // We want to skip the pair (BERLAND, missingTeam).\n        // Because in the problem statement format, it's always \"team1 team2 ...\" but\n        // we don't forbid reversing them. However, let's keep it consistent:\n        // We'll remove the pair in whichever order it might appear.\n        // We can remove both (BERLAND, missingTeam) and (missingTeam, BERLAND) just in case.\n        set<pair<string,string>> toRemove;\n        toRemove.insert({\"BERLAND\", missingTeam});\n        toRemove.insert({missingTeam, \"BERLAND\"});\n        for (auto rm : toRemove) {\n            if (allPairs.find(rm) != allPairs.end()) {\n                allPairs.erase(rm);\n            }\n        }\n\n        // Now allPairs should have exactly 5 pairs.\n        vector<pair<string,string>> finalPairs(allPairs.begin(), allPairs.end());\n\n        // SCENARIOS:\n        // We'll define a handful of special, then random for the leftover\n\n        // A helper to get random [0..9]\n        auto randScore = [&]() {\n            return rnd.next(10); // [0..9]\n        };\n\n        // We'll fill the scoreboard.\n        switch (scenario) {\n            case 1:\n            {\n                // Case 1: Berland always loses heavily, making it likely IMPOSSIBLE.\n                // We'll specifically set big losses if \"BERLAND\" is in the match.\n                for (auto &p : finalPairs) {\n                    int x, y;\n                    if (p.first == \"BERLAND\") {\n                        // Berland concedes more\n                        x = rnd.next(2);   // 0..1\n                        y = 9;            // huge\n                    } else if (p.second == \"BERLAND\") {\n                        // Berland concedes more\n                        x = 9;\n                        y = rnd.next(2);  // 0..1\n                    } else {\n                        // For other pairs, set random small\n                        x = randScore();\n                        y = randScore();\n                    }\n                    addMatch(p.first, p.second, x, y);\n                }\n                break;\n            }\n            case 2:\n            {\n                // Case 2: Many draws or narrow margins; possibly small random.\n                for (auto &p : finalPairs) {\n                    int x, y;\n                    // 50% chance for exact draw, else a 1-goal difference\n                    if (rnd.next(2) == 0) {\n                        // draw\n                        x = rnd.next(5);\n                        y = x;\n                    } else {\n                        // one-goal difference\n                        x = rnd.next(5);\n                        y = x + (rnd.next(2) ? 1 : -1);\n                        if (y < 0) y = 0; \n                        if (y > 9) y = 9; \n                    }\n                    addMatch(p.first, p.second, x, y);\n                }\n                break;\n            }\n            case 3:\n            {\n                // Case 3: Berland is \"almost out,\" has 2 large defeats,\n                // but the other matches vary.\n                // This might force a big victory in the final.\n                for (auto &p : finalPairs) {\n                    if (p.first == \"BERLAND\" || p.second == \"BERLAND\") {\n                        // Let Berland lose 2:9 or 1:9\n                        int x = rnd.next(2); // 0..1\n                        int y = 9;\n                        // If reversed, so be it\n                        addMatch(p.first, p.second, x, y);\n                    } else {\n                        // random\n                        addMatch(p.first, p.second, randScore(), randScore());\n                    }\n                }\n                break;\n            }\n            case 4:\n            {\n                // Case 4: Berland is doing fairly well, close to top. \n                // We'll let Berland have 1 big win, 1 big loss, to create tie/edge cases.\n                // Others random.\n                for (auto &p : finalPairs) {\n                    if (p.first == \"BERLAND\" || p.second == \"BERLAND\") {\n                        if (rnd.next(2) == 0) {\n                            // Big win for Berland\n                            addMatch(p.first, p.second, 9, 0);\n                        } else {\n                            // Big loss for Berland\n                            addMatch(p.first, p.second, 0, 9);\n                        }\n                    } else {\n                        addMatch(p.first, p.second, randScore(), randScore());\n                    }\n                }\n                break;\n            }\n            case 5:\n            {\n                // Case 5: All small random. Could be mild or consistent.\n                for (auto &p : finalPairs) {\n                    int x = rnd.next(3); // [0..2]\n                    int y = rnd.next(3); // [0..2]\n                    addMatch(p.first, p.second, x, y);\n                }\n                break;\n            }\n            case 6:\n            {\n                // Case 6: Driven example to create multi-way tie.\n                // We'll craft the partial results so that everyone\n                // except the missing match lumps into some very balanced scenario.\n                // All draws with 1:1\n                for (auto &p : finalPairs) {\n                    addMatch(p.first, p.second, 1, 1);\n                }\n                break;\n            }\n\n            default:\n            {\n                // Otherwise: \"random\" scenario for variety\n                for (auto &p : finalPairs) {\n                    addMatch(p.first, p.second, randScore(), randScore());\n                }\n                break;\n            }\n        }\n\n        return matches;\n    };\n\n    // We'll pick which team is missing in a round-robin way or random, based on (tc mod 3).\n    // This is just a simple scheme to ensure variety across testcases.\n    // If you want to fix it for certain testcases, you can do that in a bigger switch.\n    int pickMissingIndex = (tc - 1) % 3; \n    string missingTeam = others[pickMissingIndex];\n\n    // We'll also pick a scenario from 1..7 or so (some are special, some random).\n    // E.g. scenario = (tc - 1) % 7 + 1\n    int scenario = (tc - 1) % 7 + 1;\n\n    // Now produce our 5 lines:\n    vector<Match> matches = produceMatches(missingTeam, scenario);\n\n    // Finally, print them.\n    // Format: \"TEAM1 TEAM2 x:y\"\n    // x,y in [0..9].\n    // These are guaranteed by our logic above.\n\n    for (auto &m : matches) {\n        printf(\"%s %s %d:%d\\n\", m.A.c_str(), m.B.c_str(), m.x, m.y);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Below are 20 example commands to run this generator.\n# Each command will produce exactly one test case (5 lines of output).\n# The parameter -tc selects a scenario from 1..20.\n\n./gen -tc=1\n./gen -tc=2\n./gen -tc=3\n./gen -tc=4\n./gen -tc=5\n./gen -tc=6\n./gen -tc=7\n./gen -tc=8\n./gen -tc=9\n./gen -tc=10\n./gen -tc=11\n./gen -tc=12\n./gen -tc=13\n./gen -tc=14\n./gen -tc=15\n./gen -tc=16\n./gen -tc=17\n./gen -tc=18\n./gen -tc=19\n./gen -tc=20\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T19:47:56.913138",
        "total_tutorials": 3,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "200/D",
      "title": "D. Programming Language",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains a single integer n (1 ≤ n ≤ 1000) — the number of template procedures. The next n lines contain the description of the procedures specified in the following format:\"void procedureName (type_1, type_2, ..., type_t)\" (1 ≤ t ≤ 5), where void is the keyword, procedureName is the procedure name, type_i is the type of the next parameter. Types of language parameters can be \"int\", \"string\", \"double\", and the keyword \"T\", which denotes the generic type.The next line contains a single integer m (1 ≤ m ≤ 1000) — the number of used variables. Next m lines specify the description of the variables in the following format:\"type variableName\", where type is the type of variable that can take values \"int\", \"string\", \"double\", variableName — the name of the variable.The next line contains a single integer k (1 ≤ k ≤ 1000) — the number of procedure calls. Next k lines specify the procedure calls in the following format:\"procedureName (var_1, var_2, ..., var_t)\" (1 ≤ t ≤ 5), where procedureName is the name of the procedure, var_i is the name of a variable.The lines describing the variables, template procedures and their calls may contain spaces at the beginning of the line and at the end of the line, before and after the brackets and commas. Spaces may be before and after keyword void. The length of each input line does not exceed 100 characters. The names of variables and procedures are non-empty strings of lowercase English letters and numbers with lengths of not more than 10 characters. Note that this is the only condition at the names. Only the specified variables are used in procedure calls. The names of the variables are distinct. No two procedures are the same. Two procedures are the same, if they have identical names and identical ordered sets of types of their parameters.",
      "output_spec": "OutputOn each of k lines print a single number, where the i-th number stands for the number of suitable template procedures for the i-th call.",
      "sample_tests": "ExamplesInputCopy4void f(int,T)void  f(T, T) void foo123   ( int,  double,  string,string  )   void  p(T,double)3int a string    sdouble x123 5f(a,  a)  f(s,a   )foo   (a,s,s) f  (  s  ,x123)proc(a)OutputCopy21010InputCopy6void f(string,double,int)void f(int)   void f  ( T  )void procedure(int,double)void f  (T, double,int)   void f(string, T,T)4 int a int xstring  tdouble  val  5f(t, a, a)f(t,val,a)f(val,a, val) solve300(val, val)f  (x)OutputCopy13002",
      "description": "D. Programming Language\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains a single integer n (1 ≤ n ≤ 1000) — the number of template procedures. The next n lines contain the description of the procedures specified in the following format:\"void procedureName (type_1, type_2, ..., type_t)\" (1 ≤ t ≤ 5), where void is the keyword, procedureName is the procedure name, type_i is the type of the next parameter. Types of language parameters can be \"int\", \"string\", \"double\", and the keyword \"T\", which denotes the generic type.The next line contains a single integer m (1 ≤ m ≤ 1000) — the number of used variables. Next m lines specify the description of the variables in the following format:\"type variableName\", where type is the type of variable that can take values \"int\", \"string\", \"double\", variableName — the name of the variable.The next line contains a single integer k (1 ≤ k ≤ 1000) — the number of procedure calls. Next k lines specify the procedure calls in the following format:\"procedureName (var_1, var_2, ..., var_t)\" (1 ≤ t ≤ 5), where procedureName is the name of the procedure, var_i is the name of a variable.The lines describing the variables, template procedures and their calls may contain spaces at the beginning of the line and at the end of the line, before and after the brackets and commas. Spaces may be before and after keyword void. The length of each input line does not exceed 100 characters. The names of variables and procedures are non-empty strings of lowercase English letters and numbers with lengths of not more than 10 characters. Note that this is the only condition at the names. Only the specified variables are used in procedure calls. The names of the variables are distinct. No two procedures are the same. Two procedures are the same, if they have identical names and identical ordered sets of types of their parameters.\n\nOutputOn each of k lines print a single number, where the i-th number stands for the number of suitable template procedures for the i-th call.\n\nInputCopy4void f(int,T)void  f(T, T) void foo123   ( int,  double,  string,string  )   void  p(T,double)3int a string    sdouble x123 5f(a,  a)  f(s,a   )foo   (a,s,s) f  (  s  ,x123)proc(a)OutputCopy21010InputCopy6void f(string,double,int)void f(int)   void f  ( T  )void procedure(int,double)void f  (T, double,int)   void f(string, T,T)4 int a int xstring  tdouble  val  5f(t, a, a)f(t,val,a)f(val,a, val) solve300(val, val)f  (x)OutputCopy13002\n\nInputCopy4void f(int,T)void  f(T, T) void foo123   ( int,  double,  string,string  )   void  p(T,double)3int a string    sdouble x123 5f(a,  a)  f(s,a   )foo   (a,s,s) f  (  s  ,x123)proc(a)\n\nOutputCopy21010\n\nInputCopy6void f(string,double,int)void f(int)   void f  ( T  )void procedure(int,double)void f  (T, double,int)   void f(string, T,T)4 int a int xstring  tdouble  val  5f(t, a, a)f(t,val,a)f(val,a, val) solve300(val, val)f  (x)\n\nOutputCopy13002",
      "solutions": [
        {
          "title": "Codeforces Round #126 (Div. 2) - Codeforces",
          "content": "Good afternoon, friends)We introduce you Codeforces Round #126 (Div. 2). Please note, Codeforces Round #126 (Div. 2) will be only today and only today you will have unique opportunity to raise your rating in this competition (certainly, you will be able to solve problems virtually after round, but this doesn't change your rating). Also round will be unrated for participants from first division.This round was prepared by students of Saratov State University: Nicolay Kuznetsov (NALP), Pavel Kholkin (HolkinPV), Igor Kudryashov (Igor_Kudryashov) and Gerald Agapov (Gerald). Also we thank creator of Codeforces Michael Mirzayanov (MikeMirzayanov) for amazing system, member of staff of Codeforces Mary Belova (Delinur) for great translation and Alexander Kuprin (Alex_KPR) for help in preparation of this round.Note, today it is decided to use dynamic scoring system (Learn more about dynamic problem scoring).Also problems will be placed in random order, it means they aren't sorted in increasing order of difficulty.More right ideas and fine solutions to you.UPD. Competition is over. Thanks for all who participated. We hope you enjoyed the participation, and round not passed in vain. Editorial will be posted soon. Congratulations to the winners: Andreos jma127 iensen Spider-man MrPapaya",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/4765",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1294
        },
        {
          "title": "Editorial of Codeforces Round #126 (Div. 2) - Codeforces",
          "content": "200A — CinemaIn this problem were given the field, which size is n × m, and k queries. Each query is the cell of the field. You had to find closest free cell for given one (there was used manhattan metric). Than found cell was marked as used. The time complexity of the solution is supposed to be . Firstly, we show the main idea, than we show why solution has time complexity .First of all, if n > m, than rotate matrix by 90 degrees (than we explain purpose of this transformation). We will have two matrices, size of each is n × m. In this matrices we will maintain for each cell the nearest free one to the left and to the right. Suppose we have query — cell (x, y). Iterate d — how much rows we will go above or below. Suppose we fix d, than look at the row x - d, for example (also we should do same things for row x + d). Lets find in this row nearest free cells to the left and to the right of (x - d, y) by using our matrices and try to update answer. When d will be greater than current found answer we will stop, because answer won't update in this case. After we find the answer, we have to change value in some cells of our matrices. It can be done by using structure DSU for each row.Lets show why this solution has time complexity . Suppose all queries are equal, for example each query is (x, y). Than if field is big enough, all points will be placed in form of square, which is rotated by 45 degrees and have center in point (x, y). Also the side of the square will have length . Than diagonal will have length too. It means that we see rows in each query and we do O(1) operations in each row. If the square doesn't fit into the field, than field is too thin verticaly or horizontaly. So we will have figure looks like rectangle, and one side of this rectangle will be less than . In this case rotate field so, than least side of rectangle means rows. Than we will see not greater than rows in each query and will perform not greater than O(1) operations in each row.This problem is supposed to be the hardest problem of the contest.200B — DrinksThis problem was the easiest problem of the contest. There you had to find average of the given numbers. The most participants solved this problem.200C — Football ChampionshipIn this problem was given description of the group stage of some football competition and scoring system. There were given results of all matches, excepting one, and you had to find result of the last match, satisfied some given criterias. Also Berland's team must be first or the second team of the group after than match.Lets note, that in each finished match were not greater than 18 goals. It means that we can brute-force all results of the last match, when score is not greater than 200 goals, and find the best one. One of the easiest way is to fill table to the end (it means to change points value and balls value), than to sort teams according to the given rules and to check that Berland is the first or the second team of the group.200D — Programming LanguageIn this task were given the list of template functions. Each function have its name and the list of types of arguments (also it can be used universal type). Also there were given set of variables and thier types, and some queries. Each query is function, which has name and list of arguments. For each query you had to find, how many functions from the given list fit to the function from query. There fit means that functions have the same name, same number of arguments and types of all arguments also equal.For solving this problem it is needed to implement comparing of functions. Constrains gave the possibility to brute-force function from the given list and check if the names and arguments of functions are equal.200E — Tractor CollegeIn this problem were given four integer numbers c3, c4, c5, s. You had to find 0 ≤ k3 ≤ k4 ≤ k5 such, that c3·k3 + c4·k4 + c5·k5 = s and |c3·k3–c4·k4| + |c4·k4–c5·k5| is minimal.Firstly, brute-force k4 so, that s–c4·k4 ≥ 0. Than look at 4 cases, according to the sign of the value in each modulus.Lets see the case, when c3·k3–c4·k4 ≥ 0 and c4·k4–c5·k5 ≥ 0. Than we have to minimize c3·k3–c5·k5. Also 0 ≤ k3 ≤ k4 ≤ k5 and c3·k3 + c5·k5 = s–c4·k4. Lets see diofant equation c3·k3 + c5... k5 = s–c4·k4. It can be that this equation doesn't have solution. Lets see the case, when equation has solution. As c3, c5 ≥ 0, than for minimization c3·k3–c5·k5 we have to minimize k3 and maximize k5. All solutions of diofant equation c3·k3 + c5·k5 = s–c4·k4 can be described by using one argument k. Than we have to find such segment, that for all k from it, k3 will fit above constrains, such segment, that for all k from it, k5 will fit above constrains, find intersection of this segments and, if intersection isn't empty, choose such k, that k5 is maximal.Similar you have to manage remain 3 cases and choose optimal values k3 and k5 for fixed k4. Also you can note, that in all cases minimized function is linear and in segment it has minimal value in one of its ends. So we can only find such segments, that for all k from that segments k3, k5 will fit above constrains, and calculate answer in the ends of this segments. If for all fixed k4 diofant equation doesn't have solution, or intersections of the described segments are empty, than answer is IMPOSSIBLE, else we should find the best. So the time complexity is O(s·log(s)) — brute-force of k4 and solving diofant equation for fixed k4.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/4769",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 200\\s*D"
          },
          "content_length": 5442
        },
        {
          "title": "Editorial of Codeforces Round #126 (Div. 2) - Codeforces",
          "content": "200A — CinemaIn this problem were given the field, which size is n × m, and k queries. Each query is the cell of the field. You had to find closest free cell for given one (there was used manhattan metric). Than found cell was marked as used. The time complexity of the solution is supposed to be . Firstly, we show the main idea, than we show why solution has time complexity .First of all, if n > m, than rotate matrix by 90 degrees (than we explain purpose of this transformation). We will have two matrices, size of each is n × m. In this matrices we will maintain for each cell the nearest free one to the left and to the right. Suppose we have query — cell (x, y). Iterate d — how much rows we will go above or below. Suppose we fix d, than look at the row x - d, for example (also we should do same things for row x + d). Lets find in this row nearest free cells to the left and to the right of (x - d, y) by using our matrices and try to update answer. When d will be greater than current found answer we will stop, because answer won't update in this case. After we find the answer, we have to change value in some cells of our matrices. It can be done by using structure DSU for each row.Lets show why this solution has time complexity . Suppose all queries are equal, for example each query is (x, y). Than if field is big enough, all points will be placed in form of square, which is rotated by 45 degrees and have center in point (x, y). Also the side of the square will have length . Than diagonal will have length too. It means that we see rows in each query and we do O(1) operations in each row. If the square doesn't fit into the field, than field is too thin verticaly or horizontaly. So we will have figure looks like rectangle, and one side of this rectangle will be less than . In this case rotate field so, than least side of rectangle means rows. Than we will see not greater than rows in each query and will perform not greater than O(1) operations in each row.This problem is supposed to be the hardest problem of the contest.200B — DrinksThis problem was the easiest problem of the contest. There you had to find average of the given numbers. The most participants solved this problem.200C — Football ChampionshipIn this problem was given description of the group stage of some football competition and scoring system. There were given results of all matches, excepting one, and you had to find result of the last match, satisfied some given criterias. Also Berland's team must be first or the second team of the group after than match.Lets note, that in each finished match were not greater than 18 goals. It means that we can brute-force all results of the last match, when score is not greater than 200 goals, and find the best one. One of the easiest way is to fill table to the end (it means to change points value and balls value), than to sort teams according to the given rules and to check that Berland is the first or the second team of the group.200D — Programming LanguageIn this task were given the list of template functions. Each function have its name and the list of types of arguments (also it can be used universal type). Also there were given set of variables and thier types, and some queries. Each query is function, which has name and list of arguments. For each query you had to find, how many functions from the given list fit to the function from query. There fit means that functions have the same name, same number of arguments and types of all arguments also equal.For solving this problem it is needed to implement comparing of functions. Constrains gave the possibility to brute-force function from the given list and check if the names and arguments of functions are equal.200E — Tractor CollegeIn this problem were given four integer numbers c3, c4, c5, s. You had to find 0 ≤ k3 ≤ k4 ≤ k5 such, that c3·k3 + c4·k4 + c5·k5 = s and |c3·k3–c4·k4| + |c4·k4–c5·k5| is minimal.Firstly, brute-force k4 so, that s–c4·k4 ≥ 0. Than look at 4 cases, according to the sign of the value in each modulus.Lets see the case, when c3·k3–c4·k4 ≥ 0 and c4·k4–c5·k5 ≥ 0. Than we have to minimize c3·k3–c5·k5. Also 0 ≤ k3 ≤ k4 ≤ k5 and c3·k3 + c5·k5 = s–c4·k4. Lets see diofant equation c3·k3 + c5... k5 = s–c4·k4. It can be that this equation doesn't have solution. Lets see the case, when equation has solution. As c3, c5 ≥ 0, than for minimization c3·k3–c5·k5 we have to minimize k3 and maximize k5. All solutions of diofant equation c3·k3 + c5·k5 = s–c4·k4 can be described by using one argument k. Than we have to find such segment, that for all k from it, k3 will fit above constrains, such segment, that for all k from it, k5 will fit above constrains, find intersection of this segments and, if intersection isn't empty, choose such k, that k5 is maximal.Similar you have to manage remain 3 cases and choose optimal values k3 and k5 for fixed k4. Also you can note, that in all cases minimized function is linear and in segment it has minimal value in one of its ends. So we can only find such segments, that for all k from that segments k3, k5 will fit above constrains, and calculate answer in the ends of this segments. If for all fixed k4 diofant equation doesn't have solution, or intersections of the described segments are empty, than answer is IMPOSSIBLE, else we should find the best. So the time complexity is O(s·log(s)) — brute-force of k4 and solving diofant equation for fixed k4.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/4769",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 200\\s*D"
          },
          "content_length": 5442
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #126 (Div. 2) - Codeforces - Code 1",
          "code": "The names of teams team1 and team2 are non-empty strings, consisting of uppercase English letters, with length of no more than 20 characters; goals1, goals2 are integers from 0 to 9.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4765",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #126 (Div. 2) - Codeforces - Code 2",
          "code": "The names of teams team1 and team2 are non-empty strings, consisting of uppercase English letters, with length of no more than 20 characters; goals1, goals2 are integers from 0 to 9.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4765",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #126 (Div. 2) - Codeforces - Code 3",
          "code": "X > Y, that is, Berland is going to win this game;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4765",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #126 (Div. 2) - Codeforces - Code 4",
          "code": "X > Y, that is, Berland is going to win this game;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4765",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<string> tokenize(const string &s) {\n    vector<string> tokens;\n    size_t pos = 0;\n    while (pos < s.length()) {\n        while (pos < s.length() && s[pos] == ' ') pos++;\n        if (pos >= s.length()) break;\n        if (s[pos] == '(' || s[pos] == ')' || s[pos] == ',') {\n            tokens.push_back(string(1, s[pos]));\n            pos++;\n        } else if (isalnum(s[pos]) || isupper(s[pos]) || islower(s[pos])) {\n            size_t start = pos;\n            while (pos < s.length() && (isalnum(s[pos]) || isupper(s[pos]) || islower(s[pos]))) pos++;\n            tokens.push_back(s.substr(start, pos - start));\n        } else {\n            ensuref(false, \"Invalid character '%c' in line\", s[pos]);\n        }\n    }\n    return tokens;\n}\n\nbool isValidName(const string &name) {\n    if (name.empty() || name.length() > 10) return false;\n    for (char c : name) {\n        if (!islower(c) && !isdigit(c)) return false;\n    }\n    return true;\n}\n\nbool isValidType(const string &type, bool allowT) {\n    static set<string> validTypes = {\"int\", \"string\", \"double\"};\n    if (validTypes.count(type)) return true;\n    if (allowT && type == \"T\") return true;\n    return false;\n}\n\nvoid parseProcedureLine(const string &s, set<pair<string, vector<string>>> &procedures) {\n    ensuref(s.length() <= 100, \"Procedure line length exceeds 100 characters\");\n    vector<string> tokens = tokenize(s);\n    size_t idx = 0;\n    ensuref(idx < tokens.size() && tokens[idx] == \"void\", \"Expected 'void'\");\n    idx++;\n    ensuref(idx < tokens.size(), \"Procedure name missing\");\n    string procName = tokens[idx++];\n    ensuref(isValidName(procName), \"Invalid procedure name '%s'\", procName.c_str());\n    ensuref(idx < tokens.size() && tokens[idx] == \"(\", \"Expected '(' after procedure name\");\n    idx++;\n    vector<string> paramTypes;\n    while (idx < tokens.size() && tokens[idx] != \")\") {\n        ensuref(idx < tokens.size(), \"Unexpected end of input in procedure parameters\");\n        string type = tokens[idx++];\n        ensuref(isValidType(type, true), \"Invalid type '%s' in procedure parameters\", type.c_str());\n        paramTypes.push_back(type);\n        if (idx < tokens.size() && tokens[idx] == \",\") {\n            idx++;\n        } else if (idx < tokens.size() && tokens[idx] != \")\") {\n            ensuref(false, \"Expected ',' or ')' in procedure parameters\");\n        }\n    }\n    ensuref(idx < tokens.size() && tokens[idx] == \")\", \"Expected ')' at the end of procedure parameters\");\n    idx++;\n    ensuref(idx == tokens.size(), \"Extra tokens after procedure declaration\");\n    ensuref(1 <= paramTypes.size() && paramTypes.size() <= 5, \"Procedure must have 1 to 5 parameters\");\n    auto key = make_pair(procName, paramTypes);\n    ensuref(procedures.count(key) == 0, \"Duplicate procedure detected\");\n    procedures.insert(key);\n}\n\nvoid parseVariableLine(const string &s, map<string, string> &variables) {\n    ensuref(s.length() <= 100, \"Variable line length exceeds 100 characters\");\n    vector<string> tokens = tokenize(s);\n    size_t idx = 0;\n    ensuref(idx < tokens.size(), \"Missing type in variable declaration\");\n    string type = tokens[idx++];\n    ensuref(isValidType(type, false), \"Invalid variable type '%s'\", type.c_str());\n    ensuref(idx < tokens.size(), \"Missing variable name\");\n    string varName = tokens[idx++];\n    ensuref(isValidName(varName), \"Invalid variable name '%s'\", varName.c_str());\n    ensuref(variables.count(varName) == 0, \"Duplicate variable name '%s'\", varName.c_str());\n    ensuref(idx == tokens.size(), \"Extra tokens after variable declaration\");\n    variables[varName] = type;\n}\n\nvoid parseCallLine(const string &s, const map<string, string> &variables) {\n    ensuref(s.length() <= 100, \"Call line length exceeds 100 characters\");\n    vector<string> tokens = tokenize(s);\n    size_t idx = 0;\n    ensuref(idx < tokens.size(), \"Missing procedure name in call\");\n    string procName = tokens[idx++];\n    ensuref(isValidName(procName), \"Invalid procedure name '%s'\", procName.c_str());\n    ensuref(idx < tokens.size() && tokens[idx] == \"(\", \"Expected '(' after procedure name in call\");\n    idx++;\n    while (idx < tokens.size() && tokens[idx] != \")\") {\n        ensuref(idx < tokens.size(), \"Unexpected end of input in call parameters\");\n        string varName = tokens[idx++];\n        ensuref(variables.count(varName), \"Variable '%s' not declared\", varName.c_str());\n        if (idx < tokens.size() && tokens[idx] == \",\") {\n            idx++;\n        } else if (idx < tokens.size() && tokens[idx] != \")\") {\n            ensuref(false, \"Expected ',' or ')' in call parameters\");\n        }\n    }\n    ensuref(idx < tokens.size() && tokens[idx] == \")\", \"Expected ')' at the end of call parameters\");\n    idx++;\n    ensuref(idx == tokens.size(), \"Extra tokens after procedure call\");\n}\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 1000, \"n\");\n    inf.readEoln();\n\n    set<pair<string, vector<string>>> procedures;\n    for (int i = 0; i < n; i++) {\n        string s = inf.readLine();\n        ensuref(s.length() <= 100, \"Procedure line length exceeds 100 characters\");\n        parseProcedureLine(s, procedures);\n    }\n\n    int m = inf.readInt(1, 1000, \"m\");\n    inf.readEoln();\n\n    map<string, string> variables;\n    for (int i = 0; i < m; i++) {\n        string s = inf.readLine();\n        ensuref(s.length() <= 100, \"Variable line length exceeds 100 characters\");\n        parseVariableLine(s, variables);\n    }\n\n    int k = inf.readInt(1, 1000, \"k\");\n    inf.readEoln();\n\n    for (int i = 0; i < k; i++) {\n        string s = inf.readLine();\n        ensuref(s.length() <= 100, \"Call line length exceeds 100 characters\");\n        parseCallLine(s, variables);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<string> tokenize(const string &s) {\n    vector<string> tokens;\n    size_t pos = 0;\n    while (pos < s.length()) {\n        while (pos < s.length() && s[pos] == ' ') pos++;\n        if (pos >= s.length()) break;\n        if (s[pos] == '(' || s[pos] == ')' || s[pos] == ',') {\n            tokens.push_back(string(1, s[pos]));\n            pos++;\n        } else if (isalnum(s[pos]) || isupper(s[pos]) || islower(s[pos])) {\n            size_t start = pos;\n            while (pos < s.length() && (isalnum(s[pos]) || isupper(s[pos]) || islower(s[pos]))) pos++;\n            tokens.push_back(s.substr(start, pos - start));\n        } else {\n            ensuref(false, \"Invalid character '%c' in line\", s[pos]);\n        }\n    }\n    return tokens;\n}\n\nbool isValidName(const string &name) {\n    if (name.empty() || name.length() > 10) return false;\n    for (char c : name) {\n        if (!islower(c) && !isdigit(c)) return false;\n    }\n    return true;\n}\n\nbool isValidType(const string &type, bool allowT) {\n    static set<string> validTypes = {\"int\", \"string\", \"double\"};\n    if (validTypes.count(type)) return true;\n    if (allowT && type == \"T\") return true;\n    return false;\n}\n\nvoid parseProcedureLine(const string &s, set<pair<string, vector<string>>> &procedures) {\n    ensuref(s.length() <= 100, \"Procedure line length exceeds 100 characters\");\n    vector<string> tokens = tokenize(s);\n    size_t idx = 0;\n    ensuref(idx < tokens.size() && tokens[idx] == \"void\", \"Expected 'void'\");\n    idx++;\n    ensuref(idx < tokens.size(), \"Procedure name missing\");\n    string procName = tokens[idx++];\n    ensuref(isValidName(procName), \"Invalid procedure name '%s'\", procName.c_str());\n    ensuref(idx < tokens.size() && tokens[idx] == \"(\", \"Expected '(' after procedure name\");\n    idx++;\n    vector<string> paramTypes;\n    while (idx < tokens.size() && tokens[idx] != \")\") {\n        ensuref(idx < tokens.size(), \"Unexpected end of input in procedure parameters\");\n        string type = tokens[idx++];\n        ensuref(isValidType(type, true), \"Invalid type '%s' in procedure parameters\", type.c_str());\n        paramTypes.push_back(type);\n        if (idx < tokens.size() && tokens[idx] == \",\") {\n            idx++;\n        } else if (idx < tokens.size() && tokens[idx] != \")\") {\n            ensuref(false, \"Expected ',' or ')' in procedure parameters\");\n        }\n    }\n    ensuref(idx < tokens.size() && tokens[idx] == \")\", \"Expected ')' at the end of procedure parameters\");\n    idx++;\n    ensuref(idx == tokens.size(), \"Extra tokens after procedure declaration\");\n    ensuref(1 <= paramTypes.size() && paramTypes.size() <= 5, \"Procedure must have 1 to 5 parameters\");\n    auto key = make_pair(procName, paramTypes);\n    ensuref(procedures.count(key) == 0, \"Duplicate procedure detected\");\n    procedures.insert(key);\n}\n\nvoid parseVariableLine(const string &s, map<string, string> &variables) {\n    ensuref(s.length() <= 100, \"Variable line length exceeds 100 characters\");\n    vector<string> tokens = tokenize(s);\n    size_t idx = 0;\n    ensuref(idx < tokens.size(), \"Missing type in variable declaration\");\n    string type = tokens[idx++];\n    ensuref(isValidType(type, false), \"Invalid variable type '%s'\", type.c_str());\n    ensuref(idx < tokens.size(), \"Missing variable name\");\n    string varName = tokens[idx++];\n    ensuref(isValidName(varName), \"Invalid variable name '%s'\", varName.c_str());\n    ensuref(variables.count(varName) == 0, \"Duplicate variable name '%s'\", varName.c_str());\n    ensuref(idx == tokens.size(), \"Extra tokens after variable declaration\");\n    variables[varName] = type;\n}\n\nvoid parseCallLine(const string &s, const map<string, string> &variables) {\n    ensuref(s.length() <= 100, \"Call line length exceeds 100 characters\");\n    vector<string> tokens = tokenize(s);\n    size_t idx = 0;\n    ensuref(idx < tokens.size(), \"Missing procedure name in call\");\n    string procName = tokens[idx++];\n    ensuref(isValidName(procName), \"Invalid procedure name '%s'\", procName.c_str());\n    ensuref(idx < tokens.size() && tokens[idx] == \"(\", \"Expected '(' after procedure name in call\");\n    idx++;\n    while (idx < tokens.size() && tokens[idx] != \")\") {\n        ensuref(idx < tokens.size(), \"Unexpected end of input in call parameters\");\n        string varName = tokens[idx++];\n        ensuref(variables.count(varName), \"Variable '%s' not declared\", varName.c_str());\n        if (idx < tokens.size() && tokens[idx] == \",\") {\n            idx++;\n        } else if (idx < tokens.size() && tokens[idx] != \")\") {\n            ensuref(false, \"Expected ',' or ')' in call parameters\");\n        }\n    }\n    ensuref(idx < tokens.size() && tokens[idx] == \")\", \"Expected ')' at the end of call parameters\");\n    idx++;\n    ensuref(idx == tokens.size(), \"Extra tokens after procedure call\");\n}\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 1000, \"n\");\n    inf.readEoln();\n\n    set<pair<string, vector<string>>> procedures;\n    for (int i = 0; i < n; i++) {\n        string s = inf.readLine();\n        ensuref(s.length() <= 100, \"Procedure line length exceeds 100 characters\");\n        parseProcedureLine(s, procedures);\n    }\n\n    int m = inf.readInt(1, 1000, \"m\");\n    inf.readEoln();\n\n    map<string, string> variables;\n    for (int i = 0; i < m; i++) {\n        string s = inf.readLine();\n        ensuref(s.length() <= 100, \"Variable line length exceeds 100 characters\");\n        parseVariableLine(s, variables);\n    }\n\n    int k = inf.readInt(1, 1000, \"k\");\n    inf.readEoln();\n\n    for (int i = 0; i < k; i++) {\n        string s = inf.readLine();\n        ensuref(s.length() <= 100, \"Call line length exceeds 100 characters\");\n        parseCallLine(s, variables);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<string> tokenize(const string &s) {\n    vector<string> tokens;\n    size_t pos = 0;\n    while (pos < s.length()) {\n        while (pos < s.length() && s[pos] == ' ') pos++;\n        if (pos >= s.length()) break;\n        if (s[pos] == '(' || s[pos] == ')' || s[pos] == ',') {\n            tokens.push_back(string(1, s[pos]));\n            pos++;\n        } else if (isalnum(s[pos]) || isupper(s[pos]) || islower(s[pos])) {\n            size_t start = pos;\n            while (pos < s.length() && (isalnum(s[pos]) || isupper(s[pos]) || islower(s[pos]))) pos++;\n            tokens.push_back(s.substr(start, pos - start));\n        } else {\n            ensuref(false, \"Invalid character '%c' in line\", s[pos]);\n        }\n    }\n    return tokens;\n}\n\nbool isValidName(const string &name) {\n    if (name.empty() || name.length() > 10) return false;\n    for (char c : name) {\n        if (!islower(c) && !isdigit(c)) return false;\n    }\n    return true;\n}\n\nbool isValidType(const string &type, bool allowT) {\n    static set<string> validTypes = {\"int\", \"string\", \"double\"};\n    if (validTypes.count(type)) return true;\n    if (allowT && type == \"T\") return true;\n    return false;\n}\n\nvoid parseProcedureLine(const string &s, set<pair<string, vector<string>>> &procedures) {\n    ensuref(s.length() <= 100, \"Procedure line length exceeds 100 characters\");\n    vector<string> tokens = tokenize(s);\n    size_t idx = 0;\n    ensuref(idx < tokens.size() && tokens[idx] == \"void\", \"Expected 'void'\");\n    idx++;\n    ensuref(idx < tokens.size(), \"Procedure name missing\");\n    string procName = tokens[idx++];\n    ensuref(isValidName(procName), \"Invalid procedure name '%s'\", procName.c_str());\n    ensuref(idx < tokens.size() && tokens[idx] == \"(\", \"Expected '(' after procedure name\");\n    idx++;\n    vector<string> paramTypes;\n    while (idx < tokens.size() && tokens[idx] != \")\") {\n        ensuref(idx < tokens.size(), \"Unexpected end of input in procedure parameters\");\n        string type = tokens[idx++];\n        ensuref(isValidType(type, true), \"Invalid type '%s' in procedure parameters\", type.c_str());\n        paramTypes.push_back(type);\n        if (idx < tokens.size() && tokens[idx] == \",\") {\n            idx++;\n        } else if (idx < tokens.size() && tokens[idx] != \")\") {\n            ensuref(false, \"Expected ',' or ')' in procedure parameters\");\n        }\n    }\n    ensuref(idx < tokens.size() && tokens[idx] == \")\", \"Expected ')' at the end of procedure parameters\");\n    idx++;\n    ensuref(idx == tokens.size(), \"Extra tokens after procedure declaration\");\n    ensuref(1 <= paramTypes.size() && paramTypes.size() <= 5, \"Procedure must have 1 to 5 parameters\");\n    auto key = make_pair(procName, paramTypes);\n    ensuref(procedures.count(key) == 0, \"Duplicate procedure detected\");\n    procedures.insert(key);\n}\n\nvoid parseVariableLine(const string &s, map<string, string> &variables) {\n    ensuref(s.length() <= 100, \"Variable line length exceeds 100 characters\");\n    vector<string> tokens = tokenize(s);\n    size_t idx = 0;\n    ensuref(idx < tokens.size(), \"Missing type in variable declaration\");\n    string type = tokens[idx++];\n    ensuref(isValidType(type, false), \"Invalid variable type '%s'\", type.c_str());\n    ensuref(idx < tokens.size(), \"Missing variable name\");\n    string varName = tokens[idx++];\n    ensuref(isValidName(varName), \"Invalid variable name '%s'\", varName.c_str());\n    ensuref(variables.count(varName) == 0, \"Duplicate variable name '%s'\", varName.c_str());\n    ensuref(idx == tokens.size(), \"Extra tokens after variable declaration\");\n    variables[varName] = type;\n}\n\nvoid parseCallLine(const string &s, const map<string, string> &variables) {\n    ensuref(s.length() <= 100, \"Call line length exceeds 100 characters\");\n    vector<string> tokens = tokenize(s);\n    size_t idx = 0;\n    ensuref(idx < tokens.size(), \"Missing procedure name in call\");\n    string procName = tokens[idx++];\n    ensuref(isValidName(procName), \"Invalid procedure name '%s'\", procName.c_str());\n    ensuref(idx < tokens.size() && tokens[idx] == \"(\", \"Expected '(' after procedure name in call\");\n    idx++;\n    while (idx < tokens.size() && tokens[idx] != \")\") {\n        ensuref(idx < tokens.size(), \"Unexpected end of input in call parameters\");\n        string varName = tokens[idx++];\n        ensuref(variables.count(varName), \"Variable '%s' not declared\", varName.c_str());\n        if (idx < tokens.size() && tokens[idx] == \",\") {\n            idx++;\n        } else if (idx < tokens.size() && tokens[idx] != \")\") {\n            ensuref(false, \"Expected ',' or ')' in call parameters\");\n        }\n    }\n    ensuref(idx < tokens.size() && tokens[idx] == \")\", \"Expected ')' at the end of call parameters\");\n    idx++;\n    ensuref(idx == tokens.size(), \"Extra tokens after procedure call\");\n}\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 1000, \"n\");\n    inf.readEoln();\n\n    set<pair<string, vector<string>>> procedures;\n    for (int i = 0; i < n; i++) {\n        string s = inf.readLine();\n        ensuref(s.length() <= 100, \"Procedure line length exceeds 100 characters\");\n        parseProcedureLine(s, procedures);\n    }\n\n    int m = inf.readInt(1, 1000, \"m\");\n    inf.readEoln();\n\n    map<string, string> variables;\n    for (int i = 0; i < m; i++) {\n        string s = inf.readLine();\n        ensuref(s.length() <= 100, \"Variable line length exceeds 100 characters\");\n        parseVariableLine(s, variables);\n    }\n\n    int k = inf.readInt(1, 1000, \"k\");\n    inf.readEoln();\n\n    for (int i = 0; i < k; i++) {\n        string s = inf.readLine();\n        ensuref(s.length() <= 100, \"Call line length exceeds 100 characters\");\n        parseCallLine(s, variables);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nstruct Variable {\n    string name;\n    string type; // \"int\", \"string\", \"double\"\n};\n\nstruct Procedure {\n    string name;\n    vector<string> param_types; // \"int\", \"string\", \"double\", \"T\"\n};\n\n// Function to generate a unique name\nstring genUniqueName(set<string>& used_names) {\n    string name;\n    do {\n        int len = rnd.next(1, 10); // Length between 1 and 10\n        name = \"\";\n        for (int i = 0; i < len; ++i) {\n            int r = rnd.next(36);\n            if (r < 26) name += (char)('a' + r);\n            else name += (char)('0' + (r - 26));\n        }\n    } while (used_names.count(name));\n    used_names.insert(name);\n    return name;\n}\n\n// Function to generate variable types\nstring genVarType() {\n    int r = rnd.next(3);\n    if (r == 0) return \"int\";\n    else if (r == 1) return \"string\";\n    else return \"double\";\n}\n\n// Function to generate parameter types\nstring genParamType() {\n    int r = rnd.next(4);\n    if (r == 0) return \"int\";\n    else if (r == 1) return \"string\";\n    else if (r == 2) return \"double\";\n    else return \"T\";\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    int n = opt<int>(\"n\", 10);\n    int m = opt<int>(\"m\", 10);\n    int k = opt<int>(\"k\", 10);\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<Variable> variables;\n    vector<Procedure> procedures;\n    vector<pair<string, vector<string>>> procedure_calls; // (proc_name, list of variable names)\n\n    set<string> variable_names;\n    set<string> procedure_names;\n    set<string> procedure_signatures;\n\n    // Generate variables\n    for (int i = 0; i < m; ++i) {\n        string name = genUniqueName(variable_names);\n        string type = genVarType();\n        variables.push_back({name, type});\n    }\n\n    // Generate procedures\n    for (int i = 0; i < n; ++i) {\n        string proc_name;\n        if (type == \"random\") {\n            // For random test type, we can allow multiple procedures to have same name\n            int r = rnd.next(3);\n            if (r == 0 && !procedures.empty()) {\n                // Reuse an existing procedure name\n                int idx = rnd.next(procedures.size());\n                proc_name = procedures[idx].name;\n            } else {\n                // Generate a new procedure name\n                proc_name = genUniqueName(procedure_names);\n                procedure_names.insert(proc_name);\n            }\n        } else {\n            // For other test types\n            proc_name = genUniqueName(procedure_names);\n            procedure_names.insert(proc_name);\n        }\n        int t = rnd.next(1, 5); // Number of parameters between 1 and 5\n        vector<string> param_types;\n        for (int j = 0; j < t; ++j) {\n            param_types.push_back(genParamType());\n        }\n        // Ensure the procedure is unique\n        stringstream ss;\n        ss << proc_name << \":\";\n        for (int j = 0; j < t; ++j) {\n            ss << param_types[j];\n            if (j != t - 1) ss << \",\";\n        }\n        string signature = ss.str();\n        if (procedure_signatures.count(signature)) {\n            // Duplicate procedure, try again\n            --i;\n            continue;\n        }\n        procedure_signatures.insert(signature);\n        procedures.push_back({proc_name, param_types});\n    }\n\n    // Generate procedure calls\n    for (int i = 0; i < k; ++i) {\n        int r = rnd.next(100);\n        if (r < 70 && !procedures.empty()) {\n            // With 70% probability, generate a call that matches existing procedure(s)\n            // Pick a procedure at random\n            int proc_idx = rnd.next(procedures.size());\n            string proc_name = procedures[proc_idx].name;\n            vector<string> param_types = procedures[proc_idx].param_types;\n            vector<string> var_names;\n            for (int j = 0; j < param_types.size(); ++j) {\n                string param_type = param_types[j];\n                vector<string> candidates;\n                // Find variables that match the parameter type\n                for (const Variable& var : variables) {\n                    if (param_type == \"T\" || var.type == param_type) {\n                        candidates.push_back(var.name);\n                    }\n                }\n                if (candidates.empty()) {\n                    // No matching variable, pick any variable\n                    int var_idx = rnd.next(variables.size());\n                    var_names.push_back(variables[var_idx].name);\n                } else {\n                    int var_idx = rnd.next(candidates.size());\n                    var_names.push_back(candidates[var_idx]);\n                }\n            }\n            procedure_calls.push_back({proc_name, var_names});\n        } else {\n            // With 30% probability, generate a call that may or may not match any procedure\n            // Generate a procedure name\n            string proc_name;\n            if (rnd.next(2) == 0 && !procedures.empty()) {\n                // Reuse an existing procedure name\n                int proc_idx = rnd.next(procedures.size());\n                proc_name = procedures[proc_idx].name;\n            } else {\n                // Generate a new procedure name\n                proc_name = genUniqueName(procedure_names);\n                procedure_names.insert(proc_name);\n            }\n            // Random number of parameters between 1 and 5\n            int t = rnd.next(1, 5);\n            vector<string> var_names;\n            for (int j = 0; j < t; ++j) {\n                int var_idx = rnd.next(variables.size());\n                var_names.push_back(variables[var_idx].name);\n            }\n            procedure_calls.push_back({proc_name, var_names});\n        }\n    }\n\n    // Output n and procedures\n    printf(\"%d\\n\", n);\n    for (const Procedure& proc : procedures) {\n        printf(\"void %s(\", proc.name.c_str());\n        for (int i = 0; i < proc.param_types.size(); ++i) {\n            printf(\"%s\", proc.param_types[i].c_str());\n            if (i != proc.param_types.size() - 1) printf(\", \");\n        }\n        printf(\")\\n\");\n    }\n\n    // Output m and variables\n    printf(\"%d\\n\", m);\n    for (const Variable& var : variables) {\n        printf(\"%s %s\\n\", var.type.c_str(), var.name.c_str());\n    }\n\n    // Output k and procedure calls\n    printf(\"%d\\n\", k);\n    for (const auto& call : procedure_calls) {\n        printf(\"%s(\", call.first.c_str());\n        for (int i = 0; i < call.second.size(); ++i) {\n            printf(\"%s\", call.second[i].c_str());\n            if (i != call.second.size() - 1) printf(\", \");\n        }\n        printf(\")\\n\");\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nstruct Variable {\n    string name;\n    string type; // \"int\", \"string\", \"double\"\n};\n\nstruct Procedure {\n    string name;\n    vector<string> param_types; // \"int\", \"string\", \"double\", \"T\"\n};\n\n// Function to generate a unique name\nstring genUniqueName(set<string>& used_names) {\n    string name;\n    do {\n        int len = rnd.next(1, 10); // Length between 1 and 10\n        name = \"\";\n        for (int i = 0; i < len; ++i) {\n            int r = rnd.next(36);\n            if (r < 26) name += (char)('a' + r);\n            else name += (char)('0' + (r - 26));\n        }\n    } while (used_names.count(name));\n    used_names.insert(name);\n    return name;\n}\n\n// Function to generate variable types\nstring genVarType() {\n    int r = rnd.next(3);\n    if (r == 0) return \"int\";\n    else if (r == 1) return \"string\";\n    else return \"double\";\n}\n\n// Function to generate parameter types\nstring genParamType() {\n    int r = rnd.next(4);\n    if (r == 0) return \"int\";\n    else if (r == 1) return \"string\";\n    else if (r == 2) return \"double\";\n    else return \"T\";\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    int n = opt<int>(\"n\", 10);\n    int m = opt<int>(\"m\", 10);\n    int k = opt<int>(\"k\", 10);\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<Variable> variables;\n    vector<Procedure> procedures;\n    vector<pair<string, vector<string>>> procedure_calls; // (proc_name, list of variable names)\n\n    set<string> variable_names;\n    set<string> procedure_names;\n    set<string> procedure_signatures;\n\n    // Generate variables\n    for (int i = 0; i < m; ++i) {\n        string name = genUniqueName(variable_names);\n        string type = genVarType();\n        variables.push_back({name, type});\n    }\n\n    // Generate procedures\n    for (int i = 0; i < n; ++i) {\n        string proc_name;\n        if (type == \"random\") {\n            // For random test type, we can allow multiple procedures to have same name\n            int r = rnd.next(3);\n            if (r == 0 && !procedures.empty()) {\n                // Reuse an existing procedure name\n                int idx = rnd.next(procedures.size());\n                proc_name = procedures[idx].name;\n            } else {\n                // Generate a new procedure name\n                proc_name = genUniqueName(procedure_names);\n                procedure_names.insert(proc_name);\n            }\n        } else {\n            // For other test types\n            proc_name = genUniqueName(procedure_names);\n            procedure_names.insert(proc_name);\n        }\n        int t = rnd.next(1, 5); // Number of parameters between 1 and 5\n        vector<string> param_types;\n        for (int j = 0; j < t; ++j) {\n            param_types.push_back(genParamType());\n        }\n        // Ensure the procedure is unique\n        stringstream ss;\n        ss << proc_name << \":\";\n        for (int j = 0; j < t; ++j) {\n            ss << param_types[j];\n            if (j != t - 1) ss << \",\";\n        }\n        string signature = ss.str();\n        if (procedure_signatures.count(signature)) {\n            // Duplicate procedure, try again\n            --i;\n            continue;\n        }\n        procedure_signatures.insert(signature);\n        procedures.push_back({proc_name, param_types});\n    }\n\n    // Generate procedure calls\n    for (int i = 0; i < k; ++i) {\n        int r = rnd.next(100);\n        if (r < 70 && !procedures.empty()) {\n            // With 70% probability, generate a call that matches existing procedure(s)\n            // Pick a procedure at random\n            int proc_idx = rnd.next(procedures.size());\n            string proc_name = procedures[proc_idx].name;\n            vector<string> param_types = procedures[proc_idx].param_types;\n            vector<string> var_names;\n            for (int j = 0; j < param_types.size(); ++j) {\n                string param_type = param_types[j];\n                vector<string> candidates;\n                // Find variables that match the parameter type\n                for (const Variable& var : variables) {\n                    if (param_type == \"T\" || var.type == param_type) {\n                        candidates.push_back(var.name);\n                    }\n                }\n                if (candidates.empty()) {\n                    // No matching variable, pick any variable\n                    int var_idx = rnd.next(variables.size());\n                    var_names.push_back(variables[var_idx].name);\n                } else {\n                    int var_idx = rnd.next(candidates.size());\n                    var_names.push_back(candidates[var_idx]);\n                }\n            }\n            procedure_calls.push_back({proc_name, var_names});\n        } else {\n            // With 30% probability, generate a call that may or may not match any procedure\n            // Generate a procedure name\n            string proc_name;\n            if (rnd.next(2) == 0 && !procedures.empty()) {\n                // Reuse an existing procedure name\n                int proc_idx = rnd.next(procedures.size());\n                proc_name = procedures[proc_idx].name;\n            } else {\n                // Generate a new procedure name\n                proc_name = genUniqueName(procedure_names);\n                procedure_names.insert(proc_name);\n            }\n            // Random number of parameters between 1 and 5\n            int t = rnd.next(1, 5);\n            vector<string> var_names;\n            for (int j = 0; j < t; ++j) {\n                int var_idx = rnd.next(variables.size());\n                var_names.push_back(variables[var_idx].name);\n            }\n            procedure_calls.push_back({proc_name, var_names});\n        }\n    }\n\n    // Output n and procedures\n    printf(\"%d\\n\", n);\n    for (const Procedure& proc : procedures) {\n        printf(\"void %s(\", proc.name.c_str());\n        for (int i = 0; i < proc.param_types.size(); ++i) {\n            printf(\"%s\", proc.param_types[i].c_str());\n            if (i != proc.param_types.size() - 1) printf(\", \");\n        }\n        printf(\")\\n\");\n    }\n\n    // Output m and variables\n    printf(\"%d\\n\", m);\n    for (const Variable& var : variables) {\n        printf(\"%s %s\\n\", var.type.c_str(), var.name.c_str());\n    }\n\n    // Output k and procedure calls\n    printf(\"%d\\n\", k);\n    for (const auto& call : procedure_calls) {\n        printf(\"%s(\", call.first.c_str());\n        for (int i = 0; i < call.second.size(); ++i) {\n            printf(\"%s\", call.second[i].c_str());\n            if (i != call.second.size() - 1) printf(\", \");\n        }\n        printf(\")\\n\");\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Minimal Input Test Case\n./gen -n 1 -m 1 -k 1 -type random\n# Small Random Test Cases\n./gen -n 5 -m 5 -k 5 -type random\n./gen -n 10 -m 10 -k 10 -type random\n./gen -n 20 -m 20 -k 20 -type random\n# Medium Random Test Cases\n./gen -n 100 -m 100 -k 100 -type random\n./gen -n 200 -m 200 -k 200 -type random\n# Large Random Test Cases\n./gen -n 500 -m 500 -k 500 -type random\n./gen -n 1000 -m 1000 -k 1000 -type random\n# Random Test Cases with Maximum Sizes\n./gen -n 1000 -m 1000 -k 1000 -type max_random\n# Test Cases with Random Spaces\n./gen -n 100 -m 100 -k 100 -type spaces\n# Edge Case Test Cases\n./gen -n 1 -m 1000 -k 1000 -type edge_cases\n./gen -n 1000 -m 1 -k 1000 -type edge_cases\n./gen -n 1000 -m 1000 -k 1 -type edge_cases\n# Test Cases with Procedures Having Maximum Parameters\n./gen -n 100 -m 1000 -k 100 -type max_parameters\n# Test Cases with Long Variable and Procedure Names\n./gen -n 100 -m 100 -k 100 -type long_names\n# Test Cases with Heavy Use of Generic Type T\n./gen -n 100 -m 100 -k 100 -type heavy_generic\n# Test Cases to Produce Calls Matching Multiple Procedures\n./gen -n 200 -m 200 -k 100 -type multiple_matches\n# Test Cases to Produce Calls Matching No Procedures\n./gen -n 200 -m 200 -k 100 -type no_matches\n# Test Cases with Only Int Type Variables and Procedures\n./gen -n 1000 -m 1000 -k 1000 -type int_only\n# Test Cases with Variables of Same Type but Different Names\n./gen -n 500 -m 1000 -k 1000 -type same_type_vars\n# Additional Random Test Cases\n./gen -n 300 -m 300 -k 300 -type random\n./gen -n 400 -m 400 -k 400 -type random\n./gen -n 600 -m 600 -k 600 -type random\n./gen -n 800 -m 800 -k 800 -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T19:47:58.529420",
        "total_tutorials": 3,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "200/E",
      "title": "E. Тракторный институт",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест4 секунды",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеВ первой строке заданы два целых числа n, s (3 ≤ n ≤ 300, 1 ≤ s ≤ 3·105) — количество студентов и размер бюджета стипендии соответственно. Во второй строке задано n целых чисел, где i-ое число означает оценку за экзамен i-го студента. Гарантируется, что каждую оценку получил хотя бы один студент.",
      "output_spec": "Выходные данныеВ единственной строке выведите три целых числа k3, k4 и k5 — искомые величины, обозначающие оптимальное распределение размеров стипендии. Если оптимальных ответов несколько, выведите любой из них. Если ответа не существует, выведите -1.",
      "sample_tests": "ПримерыВходные данныеСкопировать5 113 4 3 5 5Выходные данныеСкопировать1 3 3Входные данныеСкопировать6 155 3 3 4 4 5Выходные данныеСкопировать-1",
      "description": "E. Тракторный институт\n\nограничение по времени на тест4 секунды\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвыводstdout\n\nВходные данныеВ первой строке заданы два целых числа n, s (3 ≤ n ≤ 300, 1 ≤ s ≤ 3·105) — количество студентов и размер бюджета стипендии соответственно. Во второй строке задано n целых чисел, где i-ое число означает оценку за экзамен i-го студента. Гарантируется, что каждую оценку получил хотя бы один студент.\n\nВходные данные\n\nВыходные данныеВ единственной строке выведите три целых числа k3, k4 и k5 — искомые величины, обозначающие оптимальное распределение размеров стипендии. Если оптимальных ответов несколько, выведите любой из них. Если ответа не существует, выведите -1.\n\nВыходные данные\n\nВходные данныеСкопировать5 113 4 3 5 5Выходные данныеСкопировать1 3 3Входные данныеСкопировать6 155 3 3 4 4 5Выходные данныеСкопировать-1\n\nВходные данныеСкопировать5 113 4 3 5 5\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать1 3 3\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать6 155 3 3 4 4 5\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать-1\n\nВыходные данныеСкопировать\n\nСкопировать",
      "solutions": [
        {
          "title": "Codeforces Round #126 (Div. 2) - Codeforces",
          "content": "Добрый день, друзья)Предлагаем вашему вниманию уникальный Codeforces Round #126 (Div. 2). Обратите внимание, что Codeforces Round #126 (Div. 2) проводится только сегодня, и только сегодня у вас будет единственная возможность поднять рейтинг в этом соревновании (конечно, порешать задачи с этого раунда вы сможете после его окончания как виртуальный участник, но это не повлияет на рейтинг). Также для участников из первого дивизиона данный раунд будет нерейтинговым.В подготовке раунда принимали участие студенты Саратовского Государственного университета Николай Кузнецов (NALP), Павел Холкин (HolkinPV), Игорь Кудряшов (Igor_Kudryashov) и Геральд Агапов (Gerald). Выражаем также благодарность создателю Codeforces Михаилу Мирзаянову (MikeMirzayanov) за прекрасную систему, сотруднику штаба Codeforces Марии Беловой (Delinur) за отличный перевод условий, а также Александру Куприну (Alex_KPR) за помощь при организации данного раунда.Обращаем ваше внимание, что сегодня было решено использовать динамическую систему начисления очков (подробнее о динамической стоимости). При этом задачи будут расположены в произвольном порядке, т.е. не по возрастанию сложности.Желаем всем побольше правильных идей и изящных решений.UPD. Соревнование окончено. Всем спасибо за участие, надеемся, что вы получили удовольствие от участия, а раунд не прошел без пользы. Разбор задач будет опубликован через некоторое время. Поздравляем победителей: Andreos jma127 iensen Spider-man MrPapaya",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/4765",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 1472
        },
        {
          "title": "Разбор Codeforces Round #126 (Div. 2) - Codeforces",
          "content": "200A — КиноВ этой задаче было дано поле размером n × m и k запросов. Каждый запрос –-- это клетка поля. Нужно было для каждого запроса находить ближайшую к заданной не занятую клетку (при этом ближайшая клетка находится по манхэттенской метрике). После этого найденная клетка помечалась как занятая. В задаче предполагалось решение за время . Сначала поясним идею решения, затем покажем, как достигается такая временная оценка. Идея решения состоит в следующем. Прежде всего, если n > m, то повернем матрицу на 90 градусов (далее будет пояснено зачем). Будем хранить две матрицы n × m, в которых для каждой клетки будем хранить ближайшую свободную клетку слева и справа. Пусть теперь приходит запрос клетка (x, y). Будем перебирать величину d на сколько строчек мы отступим вниз и вверх. Когда мы зафиксировали d, то рассмотрим строку, например, x–d (аналогичные действия нужно будет проделать для строки x + d). В данной строке найдем при помощи наших матриц ближайшие свободные клетки слева и справа от клетки (x–d, y) и попробуем улучшить ответ. В тот момент, когда величина d станет больше, чем текущая найденная величина ответа, остановимся, т.к. в этом случае ответ уже не улучшится. После того, как мы найдем ответ на запрос – ближайшую клетку, нужно пересчитать значения в массивах. Это можно делать, используя, например, для каждой строки структуру DSU.Покажем теперь, почему данное решение работает за время . Предположим, у нас все запросы одинаковы, т.е. одна и та же точка (x, y). Тогда если поле достаточно большое, то все точки будут располагаться в виде квадрата, повернутого на 45 градусов, с центром в точке (x, y). При этом сторона квадрата будет иметь величину порядка . Тогда и диагональ, которую мы рассмотрим в результате решения, описанного выше, имеет величину порядка . Т.е. в каждом запросе мы рассматриваем строчек и в каждой строке мы совершаем O(1) действий. Если поле такое, что квадрат не помещается в него, т.е. слишком узкое либо по вертикали, либо по горизонтали, то получится нечто, похожее на прямоугольник, у которого одна из сторон будет меньше . Тогда повернем поле таким образом, чтобы меньшая сторона этого прямоугольника соответствовала строкам. В результате мы будем проходить при каждом запросе также не более строк и в каждой строке совершать не более O(1) действий. Данная задача предполагалась как самая сложная задача контеста.200B — НапиткиДанная задача являлась самой простой задачей контеста. В ней необходимо было найти среднее арифметическое заданных чисел. С задачей справилось подавляющее большинство участников соревнования.200C — Чемпионат по футболуВ задаче было задано описание группового этапа некоторого футбольного соревнования, и правила подсчета очков и выявление победителей. Были даны результаты всех матчей, кроме одного и требовалось найти наиболее подходящий исход матча, удовлетворяющий некоторым критериям, при котором команда Берляндии занимала бы первое или второе место в своей группе.Для решения задачи достаточно было заметить, что поскольку в каждом из уже сыгранных матчей было забито не более 18 голов, то можно перебрать исход последнего матча, при котором забито не более 200 голов и найти наиболее подходящий. Проще всего было при фиксированном исходе заполнить таблицу до конца (т.е. изменить значения очков и забитых мячей для команд, играющих последний матч), а затем отсортировать команды в соответствии с заданными правилами и проверить, что команда Берляндии попала в первые две лучшие команды группы.200D — Язык программированияВ данной задаче был дан набор шаблонных функций своими названиями и списками параметров (при этом мог использоваться обобщенный тип), список переменных и их типов и некоторое количество запросов. Каждый запрос описывает функцию, заданную также своим именем и списком параметров. Про каждую такую функцию нужно было сказать, скольким шаблонным функциям из набора она <<подходит>>. <<Подходит>> в данном случае означает, что у нее и функции из набора совпадают имена, количество параметров и сами параметры.Для решения задачи нужно было просто реализовать то, что было описано в условии. Ограничения позволяли отвечать на каждый запрос за время, пропорциональное количеству шаблонных функций в наборе, поэтому нужно было перебрать функцию из набора и проверить совпадение имен и списков аргументов.200E — Тракторный институтВ данной задаче по сути было дано четыре числа c3, c4, c5, s. Нужно было найти такие числа 0 ≤ k3 ≤ k4 ≤ k5, что c3·k3 + c4·k4 + c5·k5 = s и при этом |c3·k3–c4·k4| + |c4·k4–c5·k5| минимально. Для начала переберем k4 так, чтобы s–c4·k4 ≥ 0. Затем рассмотрим 4 случая, в зависимости от того, каковы по знаку значения под модулями.Рассмотрим случай c3·k3–c4·k4 ≥ 0 и c4·k4–c5·k5 ≥ 0. Тогда нужно минимизировать c3·k3–c5·k5. При этом 0 ≤ k3 ≤ k4 ≤ k5 и c3·k3 + c5·k5 = s–c4·k4. Рассмотрим диофантово уравнение c3·k3 + c5·k5 = s–c4·k4. При этом оно может не иметь решений. Рассмотрим случай, когда решения есть. Поскольку c3, c5 ≥ 0, то для минимизации c3·k3–c5·k5 нужно минимизировать k3 и максимизировать k5. Все решения диофантового уравнения c3·k3 + c5·k5 = s–c4·k4 можно выразить через один параметр k. Тогда необходимо найти отрезок значений k, при которых k3 будет подходящим, отрезок, при котором k5 будет подходящим, пересечь данные отрезки и, если пересечение не пусто, выбрать то значение k, при котором k5 максимально.Аналогично рассуждая, нужно разобрать остальные 3 случая и выбрать оптимальные значения k3 и k5 для фиксированного k4. Можно было также заметить, что в каждом из случаев искомая функция линейно зависит от аргумента, а, значит, она принимает минимальное значение на отрезке в одном из его концов. Поэтому можно не рассматривать случаи, а находить отрезки k, при которых k3, k5 принимают допустимые значения, и считать целевую функцию в концах этих отрезков. Если при этом для всех фиксированных k4 не существует решений диофантовых уравнений, или пересечения выше указанных отрезков пустые, то ответ IMPOSSIBLE, иначе нужно выбрать лучшее. Таким образом решение получается за O(s·log(s)) --– перебор k4, и решение диофантова уравнения при каждом k4.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/4769",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 200\\s*E"
          },
          "content_length": 6113
        },
        {
          "title": "Разбор Codeforces Round #126 (Div. 2) - Codeforces",
          "content": "200A — КиноВ этой задаче было дано поле размером n × m и k запросов. Каждый запрос –-- это клетка поля. Нужно было для каждого запроса находить ближайшую к заданной не занятую клетку (при этом ближайшая клетка находится по манхэттенской метрике). После этого найденная клетка помечалась как занятая. В задаче предполагалось решение за время . Сначала поясним идею решения, затем покажем, как достигается такая временная оценка. Идея решения состоит в следующем. Прежде всего, если n > m, то повернем матрицу на 90 градусов (далее будет пояснено зачем). Будем хранить две матрицы n × m, в которых для каждой клетки будем хранить ближайшую свободную клетку слева и справа. Пусть теперь приходит запрос клетка (x, y). Будем перебирать величину d на сколько строчек мы отступим вниз и вверх. Когда мы зафиксировали d, то рассмотрим строку, например, x–d (аналогичные действия нужно будет проделать для строки x + d). В данной строке найдем при помощи наших матриц ближайшие свободные клетки слева и справа от клетки (x–d, y) и попробуем улучшить ответ. В тот момент, когда величина d станет больше, чем текущая найденная величина ответа, остановимся, т.к. в этом случае ответ уже не улучшится. После того, как мы найдем ответ на запрос – ближайшую клетку, нужно пересчитать значения в массивах. Это можно делать, используя, например, для каждой строки структуру DSU.Покажем теперь, почему данное решение работает за время . Предположим, у нас все запросы одинаковы, т.е. одна и та же точка (x, y). Тогда если поле достаточно большое, то все точки будут располагаться в виде квадрата, повернутого на 45 градусов, с центром в точке (x, y). При этом сторона квадрата будет иметь величину порядка . Тогда и диагональ, которую мы рассмотрим в результате решения, описанного выше, имеет величину порядка . Т.е. в каждом запросе мы рассматриваем строчек и в каждой строке мы совершаем O(1) действий. Если поле такое, что квадрат не помещается в него, т.е. слишком узкое либо по вертикали, либо по горизонтали, то получится нечто, похожее на прямоугольник, у которого одна из сторон будет меньше . Тогда повернем поле таким образом, чтобы меньшая сторона этого прямоугольника соответствовала строкам. В результате мы будем проходить при каждом запросе также не более строк и в каждой строке совершать не более O(1) действий. Данная задача предполагалась как самая сложная задача контеста.200B — НапиткиДанная задача являлась самой простой задачей контеста. В ней необходимо было найти среднее арифметическое заданных чисел. С задачей справилось подавляющее большинство участников соревнования.200C — Чемпионат по футболуВ задаче было задано описание группового этапа некоторого футбольного соревнования, и правила подсчета очков и выявление победителей. Были даны результаты всех матчей, кроме одного и требовалось найти наиболее подходящий исход матча, удовлетворяющий некоторым критериям, при котором команда Берляндии занимала бы первое или второе место в своей группе.Для решения задачи достаточно было заметить, что поскольку в каждом из уже сыгранных матчей было забито не более 18 голов, то можно перебрать исход последнего матча, при котором забито не более 200 голов и найти наиболее подходящий. Проще всего было при фиксированном исходе заполнить таблицу до конца (т.е. изменить значения очков и забитых мячей для команд, играющих последний матч), а затем отсортировать команды в соответствии с заданными правилами и проверить, что команда Берляндии попала в первые две лучшие команды группы.200D — Язык программированияВ данной задаче был дан набор шаблонных функций своими названиями и списками параметров (при этом мог использоваться обобщенный тип), список переменных и их типов и некоторое количество запросов. Каждый запрос описывает функцию, заданную также своим именем и списком параметров. Про каждую такую функцию нужно было сказать, скольким шаблонным функциям из набора она <<подходит>>. <<Подходит>> в данном случае означает, что у нее и функции из набора совпадают имена, количество параметров и сами параметры.Для решения задачи нужно было просто реализовать то, что было описано в условии. Ограничения позволяли отвечать на каждый запрос за время, пропорциональное количеству шаблонных функций в наборе, поэтому нужно было перебрать функцию из набора и проверить совпадение имен и списков аргументов.200E — Тракторный институтВ данной задаче по сути было дано четыре числа c3, c4, c5, s. Нужно было найти такие числа 0 ≤ k3 ≤ k4 ≤ k5, что c3·k3 + c4·k4 + c5·k5 = s и при этом |c3·k3–c4·k4| + |c4·k4–c5·k5| минимально. Для начала переберем k4 так, чтобы s–c4·k4 ≥ 0. Затем рассмотрим 4 случая, в зависимости от того, каковы по знаку значения под модулями.Рассмотрим случай c3·k3–c4·k4 ≥ 0 и c4·k4–c5·k5 ≥ 0. Тогда нужно минимизировать c3·k3–c5·k5. При этом 0 ≤ k3 ≤ k4 ≤ k5 и c3·k3 + c5·k5 = s–c4·k4. Рассмотрим диофантово уравнение c3·k3 + c5·k5 = s–c4·k4. При этом оно может не иметь решений. Рассмотрим случай, когда решения есть. Поскольку c3, c5 ≥ 0, то для минимизации c3·k3–c5·k5 нужно минимизировать k3 и максимизировать k5. Все решения диофантового уравнения c3·k3 + c5·k5 = s–c4·k4 можно выразить через один параметр k. Тогда необходимо найти отрезок значений k, при которых k3 будет подходящим, отрезок, при котором k5 будет подходящим, пересечь данные отрезки и, если пересечение не пусто, выбрать то значение k, при котором k5 максимально.Аналогично рассуждая, нужно разобрать остальные 3 случая и выбрать оптимальные значения k3 и k5 для фиксированного k4. Можно было также заметить, что в каждом из случаев искомая функция линейно зависит от аргумента, а, значит, она принимает минимальное значение на отрезке в одном из его концов. Поэтому можно не рассматривать случаи, а находить отрезки k, при которых k3, k5 принимают допустимые значения, и считать целевую функцию в концах этих отрезков. Если при этом для всех фиксированных k4 не существует решений диофантовых уравнений, или пересечения выше указанных отрезков пустые, то ответ IMPOSSIBLE, иначе нужно выбрать лучшее. Таким образом решение получается за O(s·log(s)) --– перебор k4, и решение диофантова уравнения при каждом k4.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/4769",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 200\\s*E"
          },
          "content_length": 6113
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #126 (Div. 2) - Codeforces - Code 1",
          "code": "while (tokens == null) {\n\n        tokens = new StringTokenizer(input.readLine(), \"\\t\\n\\r\\n(), \");\n\n    }\n\n    if (!tokens.hasMoreTokens()) {\n\n        tokens = null;\n\n        return null;\n\n    }\n\n    return tokens.nextToken();\n\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4765",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #126 (Div. 2) - Codeforces - Code 2",
          "code": "The names of teams team1 and team2 are non-empty strings, consisting of uppercase English letters, with length of no more than 20 characters; goals1, goals2 are integers from 0 to 9.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4765",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #126 (Div. 2) - Codeforces - Code 3",
          "code": "The names of teams team1 and team2 are non-empty strings, consisting of uppercase English letters, with length of no more than 20 characters; goals1, goals2 are integers from 0 to 9.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4765",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #126 (Div. 2) - Codeforces - Code 4",
          "code": "OOOBBSSCAQFNGLB BERLAND 7:2\nOOOBBSSCAQFNGLB MFRZATRH 1:3\nZNRFARJZAVB BERLAND 0:0\nZNRFARJZAVB MFRZATRH 5:3\nZNRFARJZAVB OOOBBSSCAQFNGLB 0:5",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4765",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #126 (Div. 2) - Codeforces - Code 5",
          "code": "OOOBBSSCAQFNGLB BERLAND 7:2\nOOOBBSSCAQFNGLB MFRZATRH 1:3\nZNRFARJZAVB BERLAND 0:0\nZNRFARJZAVB MFRZATRH 5:3\nZNRFARJZAVB OOOBBSSCAQFNGLB 0:5",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4765",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #126 (Div. 2) - Codeforces - Code 6",
          "code": "X > Y, то есть Берляндия собирается выигрывать в этом матче;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4765",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #126 (Div. 2) - Codeforces - Code 7",
          "code": "X > Y, that is, Berland is going to win this game;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4765",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #126 (Div. 2) - Codeforces - Code 8",
          "code": "X > Y, that is, Berland is going to win this game;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4765",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #126 (Div. 2) - Codeforces - Code 1",
          "code": "Разбор как раз вовремя.\nP.S Уже все задачи сам дорешал :)\nUPD. Извиняюсь, не заметил его, думал что он только появился.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4769",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #126 (Div. 2) - Codeforces - Code 2",
          "code": "Разбор как раз вовремя.\nP.S Уже все задачи сам дорешал :)\nUPD. Извиняюсь, не заметил его, думал что он только появился.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4769",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #126 (Div. 2) - Codeforces - Code 1",
          "code": "Разбор как раз вовремя.\nP.S Уже все задачи сам дорешал :)\nUPD. Извиняюсь, не заметил его, думал что он только появился.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4769",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #126 (Div. 2) - Codeforces - Code 2",
          "code": "Разбор как раз вовремя.\nP.S Уже все задачи сам дорешал :)\nUPD. Извиняюсь, не заметил его, думал что он только появился.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4769",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(3, 300, \"n\");\n    inf.readSpace();\n    int s = inf.readInt(1, 300000, \"s\");\n    inf.readEoln();\n\n    vector<int> marks = inf.readInts(n, 3, 5, \"marks\");\n    inf.readEoln();\n\n    int c[6] = {0};\n    for (int i = 0; i < n; ++i) {\n        int m = marks[i];\n        c[m]++;\n    }\n    ensuref(c[3] > 0, \"At least one student must have mark 3\");\n    ensuref(c[4] > 0, \"At least one student must have mark 4\");\n    ensuref(c[5] > 0, \"At least one student must have mark 5\");\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(3, 300, \"n\");\n    inf.readSpace();\n    int s = inf.readInt(1, 300000, \"s\");\n    inf.readEoln();\n\n    vector<int> marks = inf.readInts(n, 3, 5, \"marks\");\n    inf.readEoln();\n\n    int c[6] = {0};\n    for (int i = 0; i < n; ++i) {\n        int m = marks[i];\n        c[m]++;\n    }\n    ensuref(c[3] > 0, \"At least one student must have mark 3\");\n    ensuref(c[4] > 0, \"At least one student must have mark 4\");\n    ensuref(c[5] > 0, \"At least one student must have mark 5\");\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(3, 300, \"n\");\n    inf.readSpace();\n    int s = inf.readInt(1, 300000, \"s\");\n    inf.readEoln();\n\n    vector<int> marks = inf.readInts(n, 3, 5, \"marks\");\n    inf.readEoln();\n\n    int c[6] = {0};\n    for (int i = 0; i < n; ++i) {\n        int m = marks[i];\n        c[m]++;\n    }\n    ensuref(c[3] > 0, \"At least one student must have mark 3\");\n    ensuref(c[4] > 0, \"At least one student must have mark 4\");\n    ensuref(c[5] > 0, \"At least one student must have mark 5\");\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\n/*\n * Reads a single line from stream if available. If no line is available (EOF), returns an empty string.\n */\nstring safeReadLine(InStream& stream) {\n    if (!stream.seekEof()) {\n        return stream.readLine();\n    }\n    return \"\";\n}\n\n/*\n * Parses one line of text into either:\n *   - no solution (blank/whitespace or single token \"-1\"),\n *   - a triple (k3, k4, k5) satisfying 0 ≤ k3 ≤ k4 ≤ k5.\n * Returns (noSol, k3, k4, k5).\n */\ntuple<bool,long long,long long,long long> parseLine(const string &line, bool isJury) {\n    // If line is empty or only whitespace => no solution\n    if (line.find_first_not_of(\" \\t\\r\\n\") == string::npos) {\n        return {true, 0, 0, 0};\n    }\n\n    // Tokenize\n    vector<string> tokens;\n    {\n        istringstream iss(line);\n        for (string t; iss >> t; ) {\n            tokens.push_back(t);\n        }\n    }\n\n    // If no tokens => no solution\n    if (tokens.empty()) {\n        return {true, 0, 0, 0};\n    }\n    // If exactly one token == \"-1\" => no solution\n    if (tokens.size() == 1 && tokens[0] == \"-1\") {\n        return {true, 0, 0, 0};\n    }\n    // Otherwise must be exactly 3 tokens\n    if (tokens.size() != 3) {\n        if (isJury) {\n            quitf(_fail, \"Jury output must be '-1' or exactly three integers; found %d token(s).\",\n                  (int)tokens.size());\n        } else {\n            quitf(_wa, \"Output must be '-1' or exactly three integers; found %d token(s).\",\n                  (int)tokens.size());\n        }\n    }\n\n    // Parse the three tokens as integers\n    long long k3, k4, k5;\n    try {\n        k3 = stoll(tokens[0]);\n        k4 = stoll(tokens[1]);\n        k5 = stoll(tokens[2]);\n    } catch (...) {\n        if (isJury) {\n            quitf(_fail, \"Jury's tokens cannot be parsed as integers\");\n        } else {\n            quitf(_wa, \"Participant's tokens cannot be parsed as integers\");\n        }\n    }\n\n    // Check 0 ≤ k3 ≤ k4 ≤ k5\n    if (k3 < 0 || k4 < k3 || k5 < k4) {\n        if (isJury) {\n            quitf(_fail, \"Jury's triple must satisfy 0 ≤ k3 ≤ k4 ≤ k5\");\n        } else {\n            quitf(_wa, \"Participant's triple must satisfy 0 ≤ k3 ≤ k4 ≤ k5\");\n        }\n    }\n\n    return {false, k3, k4, k5};\n}\n\nint main(int argc, char* argv[]) {\n    registerTestlibCmd(argc, argv);\n\n    // 1) Read problem input\n    int n = inf.readInt();\n    long long s = inf.readLong();\n    vector<int> marks(n);\n    for (int i = 0; i < n; i++) {\n        marks[i] = inf.readInt();\n    }\n\n    // Count how many got each mark\n    long long c3 = 0, c4 = 0, c5 = 0;\n    for (int m : marks) {\n        if (m == 3) c3++;\n        else if (m == 4) c4++;\n        else if (m == 5) c5++;\n    }\n\n    // 2) Read exactly one line from jury (official) output\n    string juryLine = safeReadLine(ans);\n    auto [juryNoSol, juryK3, juryK4, juryK5] = parseLine(juryLine, /*isJury*/true);\n\n    // If jury gave a triple, verify the sum\n    if (!juryNoSol) {\n        long long sumJ = c3 * juryK3 + c4 * juryK4 + c5 * juryK5;\n        if (sumJ != s) {\n            quitf(_fail, \"Jury's c3*k3 + c4*k4 + c5*k5 != s\");\n        }\n    }\n\n    // 3) Read exactly one line from participant output\n    string partLine = safeReadLine(ouf);\n    auto [partNoSol, partK3, partK4, partK5] = parseLine(partLine, /*isJury*/false);\n\n    // If participant gave a triple, verify the sum\n    if (!partNoSol) {\n        long long sumP = c3 * partK3 + c4 * partK4 + c5 * partK5;\n        if (sumP != s) {\n            quitf(_wa, \"Participant's c3*k3 + c4*k4 + c5*k5 != s\");\n        }\n    }\n\n    // 4) Compare solutions\n    if (juryNoSol) {\n        if (partNoSol) {\n            quitf(_ok, \"Both say no solution\");\n        } else {\n            quitf(_wa, \"Jury says no solution; participant found one\");\n        }\n    } else {\n        if (partNoSol) {\n            quitf(_wa, \"Jury has a valid solution; participant says no solution\");\n        } else {\n            quitf(_ok, \"Participant's solution is valid\");\n        }\n    }\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char *argv[])\n{\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int s = opt<int>(\"s\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> marks(n);\n\n    if (n < 3)\n    {\n        fprintf(stderr, \"n must be at least 3\\n\");\n        return 1;\n    }\n\n    // Ensure at least one student with each mark\n    marks[0] = 3;\n    marks[1] = 4;\n    marks[2] = 5;\n\n    if (type == \"equal_counts\")\n    {\n        // Distribute remaining marks equally\n        int count = (n - 3) / 3;\n        for (int i = 3; i < n; ++i)\n        {\n            marks[i] = 3 + (i - 3) % 3;\n        }\n    }\n    else if (type == \"c3_max\")\n    {\n        // Maximize c3\n        for (int i = 3; i < n; ++i)\n        {\n            marks[i] = 3;\n        }\n    }\n    else if (type == \"c4_max\")\n    {\n        // Maximize c4\n        for (int i = 3; i < n; ++i)\n        {\n            marks[i] = 4;\n        }\n    }\n    else if (type == \"c5_max\")\n    {\n        // Maximize c5\n        for (int i = 3; i < n; ++i)\n        {\n            marks[i] = 5;\n        }\n    }\n    else if (type == \"random\")\n    {\n        for (int i = 3; i < n; ++i)\n        {\n            marks[i] = rnd.next(3, 5);\n        }\n    }\n    else if (type == \"impossible\")\n    {\n        // Generate impossible case\n        // Assign random marks ensuring each mark appears at least once\n        for (int i = 3; i < n; ++i)\n        {\n            marks[i] = rnd.next(3, 5);\n        }\n\n        // Calculate counts\n        int c3 = count(marks.begin(), marks.end(), 3);\n        int c4 = count(marks.begin(), marks.end(), 4);\n        int c5 = count(marks.begin(), marks.end(), 5);\n\n        int min_possible_s = 0; // Since k3,k4,k5 can be zero\n        int max_possible_s = s + 1; // Set s to be impossible\n\n        // Adjust s to be impossible\n        s = rnd.next(1, n * 1000) + n * 1000;\n    }\n    else\n    {\n        // Default to random\n        for (int i = 3; i < n; ++i)\n        {\n            marks[i] = rnd.next(3, 5);\n        }\n    }\n\n    // Shuffle the marks\n    shuffle(marks.begin(), marks.end());\n\n    // Output n and s\n    printf(\"%d %d\\n\", n, s);\n\n    // Output marks\n    for (int i = 0; i < n; ++i)\n    {\n        printf(\"%d\", marks[i]);\n        if (i + 1 < n)\n            printf(\" \");\n    }\n    printf(\"\\n\");\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char *argv[])\n{\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int s = opt<int>(\"s\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> marks(n);\n\n    if (n < 3)\n    {\n        fprintf(stderr, \"n must be at least 3\\n\");\n        return 1;\n    }\n\n    // Ensure at least one student with each mark\n    marks[0] = 3;\n    marks[1] = 4;\n    marks[2] = 5;\n\n    if (type == \"equal_counts\")\n    {\n        // Distribute remaining marks equally\n        int count = (n - 3) / 3;\n        for (int i = 3; i < n; ++i)\n        {\n            marks[i] = 3 + (i - 3) % 3;\n        }\n    }\n    else if (type == \"c3_max\")\n    {\n        // Maximize c3\n        for (int i = 3; i < n; ++i)\n        {\n            marks[i] = 3;\n        }\n    }\n    else if (type == \"c4_max\")\n    {\n        // Maximize c4\n        for (int i = 3; i < n; ++i)\n        {\n            marks[i] = 4;\n        }\n    }\n    else if (type == \"c5_max\")\n    {\n        // Maximize c5\n        for (int i = 3; i < n; ++i)\n        {\n            marks[i] = 5;\n        }\n    }\n    else if (type == \"random\")\n    {\n        for (int i = 3; i < n; ++i)\n        {\n            marks[i] = rnd.next(3, 5);\n        }\n    }\n    else if (type == \"impossible\")\n    {\n        // Generate impossible case\n        // Assign random marks ensuring each mark appears at least once\n        for (int i = 3; i < n; ++i)\n        {\n            marks[i] = rnd.next(3, 5);\n        }\n\n        // Calculate counts\n        int c3 = count(marks.begin(), marks.end(), 3);\n        int c4 = count(marks.begin(), marks.end(), 4);\n        int c5 = count(marks.begin(), marks.end(), 5);\n\n        int min_possible_s = 0; // Since k3,k4,k5 can be zero\n        int max_possible_s = s + 1; // Set s to be impossible\n\n        // Adjust s to be impossible\n        s = rnd.next(1, n * 1000) + n * 1000;\n    }\n    else\n    {\n        // Default to random\n        for (int i = 3; i < n; ++i)\n        {\n            marks[i] = rnd.next(3, 5);\n        }\n    }\n\n    // Shuffle the marks\n    shuffle(marks.begin(), marks.end());\n\n    // Output n and s\n    printf(\"%d %d\\n\", n, s);\n\n    // Output marks\n    for (int i = 0; i < n; ++i)\n    {\n        printf(\"%d\", marks[i]);\n        if (i + 1 < n)\n            printf(\" \");\n    }\n    printf(\"\\n\");\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Small n, small s, random marks\n./gen -n 3 -s 10 -type random\n\n# Small n, small s, equal counts\n./gen -n 9 -s 15 -type equal_counts\n\n# Medium n, medium s, c3_max\n./gen -n 100 -s 5000 -type c3_max\n\n# Medium n, medium s, c5_max\n./gen -n 100 -s 5000 -type c5_max\n\n# Large n, large s, random\n./gen -n 300 -s 300000 -type random\n\n# Small n, minimal s\n./gen -n 3 -s 0 -type random\n\n# Medium n, impossible s\n./gen -n 100 -s 123456 -type impossible\n\n# Medium n, c4_max\n./gen -n 100 -s 10000 -type c4_max\n\n# Large n, impossible s\n./gen -n 300 -s 1 -type impossible\n\n# Small n, c3_max\n./gen -n 10 -s 100 -type c3_max\n\n# Small n, c5_max\n./gen -n 10 -s 100 -type c5_max\n\n# Medium n, random marks, s near upper limit\n./gen -n 150 -s 299999 -type random\n\n# Medium n, random marks, s near lower limit\n./gen -n 150 -s 1 -type random\n\n# n = 100, s = random between 10000 and 110000, type random\n./gen -n 100 -s 105000 -type random\n\n# n = 200, s = random, type equal_counts\n./gen -n 200 -s 150000 -type equal_counts\n\n# Other cases\n./gen -n 250 -s 123456 -type random\n./gen -n 250 -s 654321 -type random\n\n# Maximum n and s\n./gen -n 300 -s 300000 -type equal_counts\n\n# n = 3, s = 0, minimal sizes\n./gen -n 3 -s 0 -type random\n\n# Force c3=1 c4=1 c5=n-2\n./gen -n 100 -s 2000 -type c5_max\n\n# Force c5=1 c4=1 c3=n-2\n./gen -n 100 -s 2000 -type c3_max\n\n# n=100, s=0, impossible case\n./gen -n 100 -s 0 -type impossible\n\n# n=100, s= big, impossible case\n./gen -n 100 -s 999999 -type impossible\n\n# Random test cases\n./gen -n 200 -s 100000 -type random\n./gen -n 200 -s 1000 -type random\n./gen -n 200 -s 200000 -type random\n\n# Medium n, random marks, s middle value\n./gen -n 150 -s 150000 -type random\n\n# Small n, impossible s\n./gen -n 10 -s 50000 -type impossible\n\n# Maximize c4\n./gen -n 50 -s 7000 -type c4_max\n\n# Equal counts, random s\n./gen -n 99 -s 123321 -type equal_counts\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T19:48:00.764466",
        "total_tutorials": 3,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "201/A",
      "title": "A. Четкая симметрия",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест2 секунды",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеВ единственной строке записано целое число x (1 ≤ x ≤ 100) — требуемая острота матрицы.",
      "output_spec": "Выходные данныеВыведите единственное число — искомое значение n.",
      "sample_tests": "ПримерыВходные данныеСкопировать4Выходные данныеСкопировать3Входные данныеСкопировать9Выходные данныеСкопировать5",
      "description": "A. Четкая симметрия\n\nограничение по времени на тест2 секунды\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвыводstdout\n\nВходные данныеВ единственной строке записано целое число x (1 ≤ x ≤ 100) — требуемая острота матрицы.\n\nВходные данные\n\nВыходные данныеВыведите единственное число — искомое значение n.\n\nВыходные данные\n\nВходные данныеСкопировать4Выходные данныеСкопировать3Входные данныеСкопировать9Выходные данныеСкопировать5\n\nВходные данныеСкопировать4\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать3\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать9\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать5\n\nВыходные данныеСкопировать\n\nСкопировать\n\nПримечаниеСоответствующие примерам матрицы приведены на рисунке:",
      "solutions": [
        {
          "title": "Codeforces Round #127 - Codeforces",
          "content": "Всем привет!Как многие из вас уже знают, сегодня в обоих дивизионах состоится Codeforces Round #127, пропускать который очень не рекомендуется ;)Оригинальные задачи для вас придумывали и готовили tourist и Romka. Мы старались сделать упор на идейную составляющую задач, поэтому надеемся, что вам придётся думать дольше, чем набирать код. Отдельное спасибо за помощь в подготовке контеста координатору Codeforces Gerald. Также благодарим Delinur за перевод условий и Alex_KPR за вычитку условий.Надеемся, что этот раунд будет для вас не просто очередным раундом на Codeforces, а принесёт вам новый опыт и новые знания. Авторам все задачи кажутся одинаково простыми, но мы всё-таки постарались расположить их в порядке убывания простоты :)Разбалловка в первом дивизионе: 1000-1000-1500-2000-2500. Разбалловка во втором дивизионе: 500-1000-2000-2000-2500.Успехов!UPD: Соревнование закончено, всем спасибо за участие. Надеемся, вам понравилось :)В первом дивизионе безоговорочную победу одержал rng_58, решив все пять задач за полтора часа! Решить все задачи за два часа больше не удалось никому.Победители в первом дивизионе (полные результаты): rng_58 peter50216 liympanda White_Bear havaliza Во втором дивизионе каждая задача была кем-то решена, но решить все задачи не удалось никому. Борьба оказалась очень упорной, а разрывы -- очень маленькими.Победители во втором дивизионе (полные результаты): Leewings snow_lotus 72VanVector_SevNTU Поздравляем победителей!UPD2: Опубликован разбор задач.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/4796",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 1493
        },
        {
          "title": "Codeforces Round #127 — разбор - Codeforces",
          "content": "Задача A(div 2) — ЛНПППредполагалось, что эту задачу можно решить, не читая её условия, а только глядя на примеры :)Найдём в заданной строке символ, который идёт в алфавите позже всех, обозначим его через z. Если этот символ встречается в строке p раз, то ответ — это строка a, состоящая из символа z, повторённого p раз.Почему это так? Из определения лексикографического сравнения и из того, что символ z — максимальный в строке, несложно понять, что если какая-то другая подпоследовательность b заданной строки лексикографически больше a, то строка b обязана иметь большую длину, чем a, и при этом a должна являться префиксом (началом) b. Однако строка b должна также быть палиндромом, поэтому последний её символ — обязательно z. В таком случае в строке b должно быть больше вхождений символа z, чем в исходной строке s, что невозможно, так как b --- подпоследовательность s.Кроме того, ограничение на длину строки было совсем небольшим, поэтому задачу можно было решить перебором всех подпоследовательностей строки. Для каждой из них нужно проверить, является ли она палиндромом, и из всех являющихся выбрать лексикографически наибольшую. Сложность такого решения составляет O(2n·n), где n — длина строки (в отличие от решения выше, сложность которого O(n)).Задача В(div 2) — Инновационно новая простая задачаОграничения в задаче были настолько малы, что проходило решение со сложностью O(m·kn). В описании каждой задачи достаточно перебрать все возможные подпоследовательности слов, являющиеся перестановками описания Лёшиной задачи, для каждой из них вычислить количество инверсий, и выбрать перестановку с минимальным количеством инверсий. Это можно сделать либо с помощью рекурсии, либо, например, с помощью необходимого количества вложенных циклов (от 1 до 4).Вот пример псевдокода для случая n = 4: w - массив слов задачи Лёши\ns - описание очередной задачи из архива\nbest = 100\nfor a = 1 to k do\n for b = 1 to k do\n for c = 1 to k do\n for d = 1 to k do\n if s[a] == w[1] and s[b] == w[2] and s[c] == w[3] and s[d] == w[4] then\n inversions = 0\n if a > b then inversions = inversions + 1\n if a > c then inversions = inversions + 1\n if a > d then inversions = inversions + 1\n if b > c then inversions = inversions + 1\n if b > d then inversions = inversions + 1\n if c > d then inversions = inversions + 1\n if inversions < best then\n best = inversionsВ конце нужно выбрать задачу с минимальным значением best и вывести ответ в соответствующем формате.Задача A(div 1)/C(div 2) — Чёткая симметрияИнтересно, что первоначально у авторов была идея не включать случай x = 3 в претесты. Представьте, сколько было бы в этом контесте сделано успешных взломов — при том, что из первых 43 решений по этой задаче ни одно претесты не прошло :)Заметим, что ответ n — всегда нечётное число. Действительно, если n чётно, то две центральные строки матрицы A обязаны содержать только нули — в противном случае найдутся две соседние клетки, содержащие единицы. Аналогичное требование относится и к двум центральным столбцам матрицы A. Заменив две центральные строки на одну и два центральных столбца на один, при этом оставив в них нули, получим матрицу с такой же остротой, но со стороной на единицу меньше.Заметим, что острота матрицы со стороной n не может превысить . Несложно убедиться, что на квадратное поле со стороной n можно выложить \"доминошек\" 1 на 2 так, чтобы \"доминошки\" не пересекались (иными словами, все клетки, кроме одной, можно разбить на пары так, что клетки в каждой паре имеют общую сторону). Тогда в соответствующей матрице под клетками, покрытыми одной \"доминошкой\", может располагаться не более одной единицы. Значит, общее количество единиц не превышает .Заметим, что матрица со стороной n и остротой при нечётном n существует. Раскрасим все клетки матрицы в шахматном порядке и в чёрные клетки поставим единицы, а в белые — нули. Несложно убедиться, что такая матрица является и чёткой, и симметричной, и при этом имеет остроту ровно .Интуитивно кажется, что раз существует матрица с остротой , то существует матрица и с любой меньшей остротой. Это верно всегда, кроме одного-единственного случая — не существует матрицы со стороной 3 и остротой 3, хотя и существует матрица со стороной 3 и остротой 5.Покажем, что утверждение выше верно при нечётных n ≥ 5. Построим матрицу с остротой , как показано выше, и будем постепенно превращать единицы в нули, уменьшая остроту. Клетки с единицами в матрице бывают трёх типов.Первый тип — центральная клетка. Она ровно одна, при этом можно превратить число в ней в ноль, и матрица не перестанет удовлетворять условию задачи.Второй тип — клетки в центральной строке и в центральном столбце (кроме центральной клетки). Такие клетки из условия симметричности разбиваются на пары — если мы заменяем значение в одной из них на ноль, мы обязаны также заменить на ноль значение в парной ей клетке.Третий тип — все остальные клетки. Из условия симметричности они разбиваются на четвёрки — если мы заменяем значение в некоторой клетке третьего типа на ноль, мы должны заменить на ноль значения во всех клетках той же четвёрки.Теперь для получения требуемой остроты x будем действовать жадно. Будем заменять единицы на нули в клетках третьего типа, делая это в четырёх клетках сразу, до тех пор, пока текущая острота превышает x как минимум на 4 и ещё есть клетки третьего типа с единицами. После этого начнём убирать клетки второго типа по парам, пока текущая острота превышает x хотя бы на 2. К этому моменту острота матрицы равна либо x, либо x + 1. Если она равна x + 1, поставим ноль в центральной клетке и получим матрицу с остротой x. Несложно проверить, что мы сможем получить матрицу любой остроты, действуя по этому жадному алгоритму.Почему такие же рассуждения не работают при n = 3? Потому что в матрице с остротой 5, полученной из шахматной раскраски, отсутствуют клетки второго типа. При n ≥ 5 в такой матрице присутствуют клетки всех типов, что и является залогом успеха. Ответы для x ≤ 5 лучше найти вручную, но аккуратно — например, многие участники решили, что при x = 2 ответ 5, а не 3.Задача В(div 1)/D(div 2) — Угадай автомобиль!Нам нужно найти такие x и y, при которых величина принимает минимальное возможное значение. Эту величину можно преобразовать к виду , и заметить, что поскольку левая часть не зависит от y, а правая от x, то можно минимизировать каждую из частей по отдельности. Рассмотрим, как минимизировать часть , вторая минимизируется аналогично. Поскольку выражение в скобках не зависит от j, эту часть можно переписать в виде , где . Теперь достаточно просто перебрать все возможные значения x, и вычислить для каждого из них искомую величину, после чего выбрать x, для которого это значение минимально. Точно так же находится оптимальное значение y.Итоговая сложность решения — O(n·m + n2 + m2).В силу выпуклости целевой функции возможны и другие подходы к решению задачи, например, градиентый спуск либо аналитический метод (вычисление производных).Главный действующий герой задачи — Ra16bit.Задача С(div 1)/E(div 2) — Хрупкие мостыЭту задачу можно решить несколькими способами, в разборе представлен один из них.Для любого решения полезно заметить следующий факт. Допустим, искомый путь начинается на платформе i и заканчивается на платформе j (i ≤ j, если это не так, можно поменять начало и конец пути местами). Тогда все мосты, находящиеся между платформами i и j, будут пройдены в этом пути нечётное число раз, а все остальные мосты — чётное число раз.Давайте найдём максимальную длину пути с концами на платформах i и j. Для этого для всех платформ найдём вспомогательные величины: lefti — максимальная длина пути, начинающегося и заканчивающегося на платформе i и при этом проходящего только по мостам левее платформы i; rightj — аналогично для мостов правее платформы j. Также для каждого моста определим oddi — наибольшее нечётное число, не превосходящее ai, и для каждой платформы определим sumOddi — сумму oddj по всем мостам левее платформы i.Тогда максимальная длина пути с концами на платформах i и j (i ≤ j) равна lefti + rightj + (sumOddj - sumOddi) или, что то же самое, (rightj + sumOddj) + (lefti - sumOddi).Теперь мы можем найти пару (i, j), для которых эта величина наибольшая, за линейное время. Переберём j. Из формулы очевидно, что нужно найти такое i ≤ j, что (lefti - sumOddi) максимально. Если перебирать j от 1 к n, то можно хранить текущее максимальное значение этой величины для всех i ≤ j и пересчитывать его при переходе к следующему j, сравнив (leftj - sumOddj) с текущим максимумом и, возможно, этот максимум обновив. Таким образом, для каждого j нужно проверять не все значения i ≤ j, а только одно.Осталось показать, как быстро искать все lefti (все rightj ищутся аналогично). Понятно, что left1 = 0, далее будем считать lefti, используя lefti - 1. Заметим, что если ai - 1 = 1, то lefti = 0, так как после перехода по мосту на платформу (i - 1) этот мост рухнет и вернуться на платформу i уже будет невозможно. Если же ai - 1 > 1, то lefti = lefti - 1 + eveni - 1, где eveni - 1 — наибольшее чётное число, не превосходящее ai - 1. Действительно, можно перейти по мосту на платформу (i - 1), проделать путь, соответствующий lefti - 1, а потом ходить по мосту между платформами (i - 1) и i, пока лимит на количество переходов не станет меньше 2 (при этом закончить нужно на платформе i).Таким образом, общая сложность этого решения — O(n).Задача D(div 1) — Инновационно новая задачаПервое решение, которое приходит на ум — рекуррентное соотношение f[i][j] =  (минимальное возможное количество инверсий, если среди первых j слов встречается перестановка слов, входящих в маску i). В таком решении параметр j изменяется от 0 до 500000, i — от 0 до 215 - 1, а пересчёт значений происходит за O(1) (либо используем очередное слово, либо нет). Это слишком много.Воспользуемся стандартным приёмом: перенесём значение соотношения в параметр, а один из параметров сделаем значением. Это можно сделать не для любого рекуррентного, но для этого как раз можно :)Понятно, что при фиксированном подмножестве слов и количестве инверсий оптимально выбрать самые ранние вхождения этих слов, которые дают такое количество инверсий. Пусть f[i][j] =  (минимальное число z такое, что среди первых z слов найдётся перестановка слов из маски i, содержащая в точности j инверсий). База — f[0][0] = 0, f[0][j] = ∞ для j > 0. Пересчёт значений происходит следующим образом: перебираем слово q из маски i, которое было последним. Зная это слово, и количество инверсий j, легко вычислить количество инверсий j', которое было без этого слова — это j минус количество слов в маске, больших q (по номеру в описании Лёшиной задачи). Пусть p = f[i^(1«q)][j']. Тогда в качестве очередного возможного значения для f[i][j] нужно рассмотреть индекс p2, равный позиции следующего вхождения слова q после позиции p. Для быстрого поиска таких значений необходимо заранее для каждой задачи из архива посчитать массив next[500010][15] такой, что next[i][j] = (минимальный индекс k > i такой, что k-е слово в описании текущей задачи равно j-му слову в описании задачи Лёши). Такой массив несложно посчитать за один проход справа налево.Суммарное количество операций можно вычислить по формуле m·(k·n + 2n·Cn2·n), где m — количество задач в архиве, k — количество слов в описании одной задачи, n — количество слов в описании задачи Лёши. При заданных ограничениях эта величина составляла около 200 миллионов, и авторские решения (включая решение на Java) работали не более двух секунд. TL был выставлен довольно-таки лояльно, 5 секунд.Главные действующие герои задач D(div 1) и B(div 2) — Chmel_Tolstiy и ivan.metelsky.Задача E(div 1) — Насквозь бюрократическая организацияДавайте представим, что у нас в распоряжении есть функция maxN(m, k), которая по заданным m и k возвращает максимальное значение n такое, что задачу для n людей и m пустых строчек в бланке можно решить за k запросов. Тогда можно применить бинарный поиск по ответу — количеству запросов k.Допустим, мы сделали какие-то k запросов. Сопоставим каждому из n человек строку из k бит, где i-ый бит равен единице, если этот человек был указан в i-ом запросе, и равен нулю в противном случае. Заметим, что мы сможем определить точную дату приёма для каждого человека в том и только в том случае, если всем n людям соответствуют попарно различные k-битовые строки. На самом деле, если двум людям соответствуют одинаковые строки, то они могли бы поменяться датами между собой и ответы на запросы не изменились бы. Если же всем людям соответствуют разные строки, для каждой даты можно определить, кто именно записан на эту дату, рассмотрев множество запросов, в ответах на которые эта дата фигурирует, и найдя человека, который указан ровно в том же множестве запросов.Ограничение в m пустых строчек в бланке означает, что в каждой из k позиций в строках суммарное число единиц по всем n числам не должно превышать m. Таким образом, функция maxN(m, k) должна возвращать максимальную мощность множества различных k-битовых строк, для которых выполняется это ограничение. Давайте ослабим это ограничение: будем искать множество, в котором в сумме по всем разрядам количество единиц не превышает k·m. Как мы докажем после, ответ от этого не изменится.С таким ослабленным ограничением задача решается простым жадным алгоритмом. Логично, что сначала лучше брать те строки, в которых меньше единиц. Будем перебирать количество единиц i в строке от 0 до k, а также хранить переменную t, обозначающую количество единиц, которое ещё можно поставить (изначально она равна k·m). Тогда на i-ом шаге максимально можно взять чисел с i единицами. Добавим p к ответу, а от t отнимем p·i. Отметим, что значения Cki нужно считать аккуратно — они могут оказаться слишком большими, и нужно не допустить переполнения.Можно показать, что сложность такого решения на один тест составляет не более O(log2n).Осталось доказать необходимое утверждение. Идея доказательства ниже принадлежит rng_58 (авторское было заметно сложнее).Решим задачу жадным алгоритмом с ограничением в k·m на общее число единиц. Полученное множество может не удовлетворять ограничению в m единиц на каждый разряд — тогда в некоторых разрядах количество единиц больше m, а в некоторых меньше m. Возьмём некоторый разряд X, в котором более m единиц, и некоторый разряд Y, в котором менее m единиц. Найдём строки, в которых стоит 1 в X и 0 в Y (допустим, таких строк x) и строки, в которых стоит 0 в X и 1 в Y (допустим, таких строк y). Понятно, что x > y. В каждой из x строк мы можем попробовать поставить 0 в X и 1 в Y — тогда полученная строка может либо остаться уникальной, либо совпасть с какой-то из y строк (но ровно одной). А поскольку x > y, точно найдётся одна из x строк такая, что в ней можно поменять местами цифры в разрядах X и Y и все строки останутся различными. Сделаем это. Теперь в разряде X стало на одну единицу меньше, а в разряде Y — на одну единицу больше. Это значит, что суммарное число лишних единиц в разрядах уменьшилось (т.к. в Y единиц не стало больше m). Таким образом, повторяя эту операцию необходимое число раз, мы сможем добиться того, чтобы в каждом разряде было не более m единиц.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/4808",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 15108
        },
        {
          "title": "Codeforces Round #127 — разбор - Codeforces",
          "content": "Задача A(div 2) — ЛНПППредполагалось, что эту задачу можно решить, не читая её условия, а только глядя на примеры :)Найдём в заданной строке символ, который идёт в алфавите позже всех, обозначим его через z. Если этот символ встречается в строке p раз, то ответ — это строка a, состоящая из символа z, повторённого p раз.Почему это так? Из определения лексикографического сравнения и из того, что символ z — максимальный в строке, несложно понять, что если какая-то другая подпоследовательность b заданной строки лексикографически больше a, то строка b обязана иметь большую длину, чем a, и при этом a должна являться префиксом (началом) b. Однако строка b должна также быть палиндромом, поэтому последний её символ — обязательно z. В таком случае в строке b должно быть больше вхождений символа z, чем в исходной строке s, что невозможно, так как b --- подпоследовательность s.Кроме того, ограничение на длину строки было совсем небольшим, поэтому задачу можно было решить перебором всех подпоследовательностей строки. Для каждой из них нужно проверить, является ли она палиндромом, и из всех являющихся выбрать лексикографически наибольшую. Сложность такого решения составляет O(2n·n), где n — длина строки (в отличие от решения выше, сложность которого O(n)).Задача В(div 2) — Инновационно новая простая задачаОграничения в задаче были настолько малы, что проходило решение со сложностью O(m·kn). В описании каждой задачи достаточно перебрать все возможные подпоследовательности слов, являющиеся перестановками описания Лёшиной задачи, для каждой из них вычислить количество инверсий, и выбрать перестановку с минимальным количеством инверсий. Это можно сделать либо с помощью рекурсии, либо, например, с помощью необходимого количества вложенных циклов (от 1 до 4).Вот пример псевдокода для случая n = 4: w - массив слов задачи Лёши\ns - описание очередной задачи из архива\nbest = 100\nfor a = 1 to k do\n for b = 1 to k do\n for c = 1 to k do\n for d = 1 to k do\n if s[a] == w[1] and s[b] == w[2] and s[c] == w[3] and s[d] == w[4] then\n inversions = 0\n if a > b then inversions = inversions + 1\n if a > c then inversions = inversions + 1\n if a > d then inversions = inversions + 1\n if b > c then inversions = inversions + 1\n if b > d then inversions = inversions + 1\n if c > d then inversions = inversions + 1\n if inversions < best then\n best = inversionsВ конце нужно выбрать задачу с минимальным значением best и вывести ответ в соответствующем формате.Задача A(div 1)/C(div 2) — Чёткая симметрияИнтересно, что первоначально у авторов была идея не включать случай x = 3 в претесты. Представьте, сколько было бы в этом контесте сделано успешных взломов — при том, что из первых 43 решений по этой задаче ни одно претесты не прошло :)Заметим, что ответ n — всегда нечётное число. Действительно, если n чётно, то две центральные строки матрицы A обязаны содержать только нули — в противном случае найдутся две соседние клетки, содержащие единицы. Аналогичное требование относится и к двум центральным столбцам матрицы A. Заменив две центральные строки на одну и два центральных столбца на один, при этом оставив в них нули, получим матрицу с такой же остротой, но со стороной на единицу меньше.Заметим, что острота матрицы со стороной n не может превысить . Несложно убедиться, что на квадратное поле со стороной n можно выложить \"доминошек\" 1 на 2 так, чтобы \"доминошки\" не пересекались (иными словами, все клетки, кроме одной, можно разбить на пары так, что клетки в каждой паре имеют общую сторону). Тогда в соответствующей матрице под клетками, покрытыми одной \"доминошкой\", может располагаться не более одной единицы. Значит, общее количество единиц не превышает .Заметим, что матрица со стороной n и остротой при нечётном n существует. Раскрасим все клетки матрицы в шахматном порядке и в чёрные клетки поставим единицы, а в белые — нули. Несложно убедиться, что такая матрица является и чёткой, и симметричной, и при этом имеет остроту ровно .Интуитивно кажется, что раз существует матрица с остротой , то существует матрица и с любой меньшей остротой. Это верно всегда, кроме одного-единственного случая — не существует матрицы со стороной 3 и остротой 3, хотя и существует матрица со стороной 3 и остротой 5.Покажем, что утверждение выше верно при нечётных n ≥ 5. Построим матрицу с остротой , как показано выше, и будем постепенно превращать единицы в нули, уменьшая остроту. Клетки с единицами в матрице бывают трёх типов.Первый тип — центральная клетка. Она ровно одна, при этом можно превратить число в ней в ноль, и матрица не перестанет удовлетворять условию задачи.Второй тип — клетки в центральной строке и в центральном столбце (кроме центральной клетки). Такие клетки из условия симметричности разбиваются на пары — если мы заменяем значение в одной из них на ноль, мы обязаны также заменить на ноль значение в парной ей клетке.Третий тип — все остальные клетки. Из условия симметричности они разбиваются на четвёрки — если мы заменяем значение в некоторой клетке третьего типа на ноль, мы должны заменить на ноль значения во всех клетках той же четвёрки.Теперь для получения требуемой остроты x будем действовать жадно. Будем заменять единицы на нули в клетках третьего типа, делая это в четырёх клетках сразу, до тех пор, пока текущая острота превышает x как минимум на 4 и ещё есть клетки третьего типа с единицами. После этого начнём убирать клетки второго типа по парам, пока текущая острота превышает x хотя бы на 2. К этому моменту острота матрицы равна либо x, либо x + 1. Если она равна x + 1, поставим ноль в центральной клетке и получим матрицу с остротой x. Несложно проверить, что мы сможем получить матрицу любой остроты, действуя по этому жадному алгоритму.Почему такие же рассуждения не работают при n = 3? Потому что в матрице с остротой 5, полученной из шахматной раскраски, отсутствуют клетки второго типа. При n ≥ 5 в такой матрице присутствуют клетки всех типов, что и является залогом успеха. Ответы для x ≤ 5 лучше найти вручную, но аккуратно — например, многие участники решили, что при x = 2 ответ 5, а не 3.Задача В(div 1)/D(div 2) — Угадай автомобиль!Нам нужно найти такие x и y, при которых величина принимает минимальное возможное значение. Эту величину можно преобразовать к виду , и заметить, что поскольку левая часть не зависит от y, а правая от x, то можно минимизировать каждую из частей по отдельности. Рассмотрим, как минимизировать часть , вторая минимизируется аналогично. Поскольку выражение в скобках не зависит от j, эту часть можно переписать в виде , где . Теперь достаточно просто перебрать все возможные значения x, и вычислить для каждого из них искомую величину, после чего выбрать x, для которого это значение минимально. Точно так же находится оптимальное значение y.Итоговая сложность решения — O(n·m + n2 + m2).В силу выпуклости целевой функции возможны и другие подходы к решению задачи, например, градиентый спуск либо аналитический метод (вычисление производных).Главный действующий герой задачи — Ra16bit.Задача С(div 1)/E(div 2) — Хрупкие мостыЭту задачу можно решить несколькими способами, в разборе представлен один из них.Для любого решения полезно заметить следующий факт. Допустим, искомый путь начинается на платформе i и заканчивается на платформе j (i ≤ j, если это не так, можно поменять начало и конец пути местами). Тогда все мосты, находящиеся между платформами i и j, будут пройдены в этом пути нечётное число раз, а все остальные мосты — чётное число раз.Давайте найдём максимальную длину пути с концами на платформах i и j. Для этого для всех платформ найдём вспомогательные величины: lefti — максимальная длина пути, начинающегося и заканчивающегося на платформе i и при этом проходящего только по мостам левее платформы i; rightj — аналогично для мостов правее платформы j. Также для каждого моста определим oddi — наибольшее нечётное число, не превосходящее ai, и для каждой платформы определим sumOddi — сумму oddj по всем мостам левее платформы i.Тогда максимальная длина пути с концами на платформах i и j (i ≤ j) равна lefti + rightj + (sumOddj - sumOddi) или, что то же самое, (rightj + sumOddj) + (lefti - sumOddi).Теперь мы можем найти пару (i, j), для которых эта величина наибольшая, за линейное время. Переберём j. Из формулы очевидно, что нужно найти такое i ≤ j, что (lefti - sumOddi) максимально. Если перебирать j от 1 к n, то можно хранить текущее максимальное значение этой величины для всех i ≤ j и пересчитывать его при переходе к следующему j, сравнив (leftj - sumOddj) с текущим максимумом и, возможно, этот максимум обновив. Таким образом, для каждого j нужно проверять не все значения i ≤ j, а только одно.Осталось показать, как быстро искать все lefti (все rightj ищутся аналогично). Понятно, что left1 = 0, далее будем считать lefti, используя lefti - 1. Заметим, что если ai - 1 = 1, то lefti = 0, так как после перехода по мосту на платформу (i - 1) этот мост рухнет и вернуться на платформу i уже будет невозможно. Если же ai - 1 > 1, то lefti = lefti - 1 + eveni - 1, где eveni - 1 — наибольшее чётное число, не превосходящее ai - 1. Действительно, можно перейти по мосту на платформу (i - 1), проделать путь, соответствующий lefti - 1, а потом ходить по мосту между платформами (i - 1) и i, пока лимит на количество переходов не станет меньше 2 (при этом закончить нужно на платформе i).Таким образом, общая сложность этого решения — O(n).Задача D(div 1) — Инновационно новая задачаПервое решение, которое приходит на ум — рекуррентное соотношение f[i][j] =  (минимальное возможное количество инверсий, если среди первых j слов встречается перестановка слов, входящих в маску i). В таком решении параметр j изменяется от 0 до 500000, i — от 0 до 215 - 1, а пересчёт значений происходит за O(1) (либо используем очередное слово, либо нет). Это слишком много.Воспользуемся стандартным приёмом: перенесём значение соотношения в параметр, а один из параметров сделаем значением. Это можно сделать не для любого рекуррентного, но для этого как раз можно :)Понятно, что при фиксированном подмножестве слов и количестве инверсий оптимально выбрать самые ранние вхождения этих слов, которые дают такое количество инверсий. Пусть f[i][j] =  (минимальное число z такое, что среди первых z слов найдётся перестановка слов из маски i, содержащая в точности j инверсий). База — f[0][0] = 0, f[0][j] = ∞ для j > 0. Пересчёт значений происходит следующим образом: перебираем слово q из маски i, которое было последним. Зная это слово, и количество инверсий j, легко вычислить количество инверсий j', которое было без этого слова — это j минус количество слов в маске, больших q (по номеру в описании Лёшиной задачи). Пусть p = f[i^(1«q)][j']. Тогда в качестве очередного возможного значения для f[i][j] нужно рассмотреть индекс p2, равный позиции следующего вхождения слова q после позиции p. Для быстрого поиска таких значений необходимо заранее для каждой задачи из архива посчитать массив next[500010][15] такой, что next[i][j] = (минимальный индекс k > i такой, что k-е слово в описании текущей задачи равно j-му слову в описании задачи Лёши). Такой массив несложно посчитать за один проход справа налево.Суммарное количество операций можно вычислить по формуле m·(k·n + 2n·Cn2·n), где m — количество задач в архиве, k — количество слов в описании одной задачи, n — количество слов в описании задачи Лёши. При заданных ограничениях эта величина составляла около 200 миллионов, и авторские решения (включая решение на Java) работали не более двух секунд. TL был выставлен довольно-таки лояльно, 5 секунд.Главные действующие герои задач D(div 1) и B(div 2) — Chmel_Tolstiy и ivan.metelsky.Задача E(div 1) — Насквозь бюрократическая организацияДавайте представим, что у нас в распоряжении есть функция maxN(m, k), которая по заданным m и k возвращает максимальное значение n такое, что задачу для n людей и m пустых строчек в бланке можно решить за k запросов. Тогда можно применить бинарный поиск по ответу — количеству запросов k.Допустим, мы сделали какие-то k запросов. Сопоставим каждому из n человек строку из k бит, где i-ый бит равен единице, если этот человек был указан в i-ом запросе, и равен нулю в противном случае. Заметим, что мы сможем определить точную дату приёма для каждого человека в том и только в том случае, если всем n людям соответствуют попарно различные k-битовые строки. На самом деле, если двум людям соответствуют одинаковые строки, то они могли бы поменяться датами между собой и ответы на запросы не изменились бы. Если же всем людям соответствуют разные строки, для каждой даты можно определить, кто именно записан на эту дату, рассмотрев множество запросов, в ответах на которые эта дата фигурирует, и найдя человека, который указан ровно в том же множестве запросов.Ограничение в m пустых строчек в бланке означает, что в каждой из k позиций в строках суммарное число единиц по всем n числам не должно превышать m. Таким образом, функция maxN(m, k) должна возвращать максимальную мощность множества различных k-битовых строк, для которых выполняется это ограничение. Давайте ослабим это ограничение: будем искать множество, в котором в сумме по всем разрядам количество единиц не превышает k·m. Как мы докажем после, ответ от этого не изменится.С таким ослабленным ограничением задача решается простым жадным алгоритмом. Логично, что сначала лучше брать те строки, в которых меньше единиц. Будем перебирать количество единиц i в строке от 0 до k, а также хранить переменную t, обозначающую количество единиц, которое ещё можно поставить (изначально она равна k·m). Тогда на i-ом шаге максимально можно взять чисел с i единицами. Добавим p к ответу, а от t отнимем p·i. Отметим, что значения Cki нужно считать аккуратно — они могут оказаться слишком большими, и нужно не допустить переполнения.Можно показать, что сложность такого решения на один тест составляет не более O(log2n).Осталось доказать необходимое утверждение. Идея доказательства ниже принадлежит rng_58 (авторское было заметно сложнее).Решим задачу жадным алгоритмом с ограничением в k·m на общее число единиц. Полученное множество может не удовлетворять ограничению в m единиц на каждый разряд — тогда в некоторых разрядах количество единиц больше m, а в некоторых меньше m. Возьмём некоторый разряд X, в котором более m единиц, и некоторый разряд Y, в котором менее m единиц. Найдём строки, в которых стоит 1 в X и 0 в Y (допустим, таких строк x) и строки, в которых стоит 0 в X и 1 в Y (допустим, таких строк y). Понятно, что x > y. В каждой из x строк мы можем попробовать поставить 0 в X и 1 в Y — тогда полученная строка может либо остаться уникальной, либо совпасть с какой-то из y строк (но ровно одной). А поскольку x > y, точно найдётся одна из x строк такая, что в ней можно поменять местами цифры в разрядах X и Y и все строки останутся различными. Сделаем это. Теперь в разряде X стало на одну единицу меньше, а в разряде Y — на одну единицу больше. Это значит, что суммарное число лишних единиц в разрядах уменьшилось (т.к. в Y единиц не стало больше m). Таким образом, повторяя эту операцию необходимое число раз, мы сможем добиться того, чтобы в каждом разряде было не более m единиц.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/4808",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 15108
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #127 - Codeforces - Code 1",
          "code": ">популярная\n>-37",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4796",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #127 - Codeforces - Code 2",
          "code": ">популярная\n>-37",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4796",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #127 - Codeforces - Code 3",
          "code": "1 0 0\n0 1 0\n1 0 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4796",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #127 - Codeforces - Code 4",
          "code": "1 0 0\n0 1 0\n1 0 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4796",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #127 - Codeforces - Code 5",
          "code": "10001\n00000\n10001\n00000\n10001",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4796",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #127 - Codeforces - Code 6",
          "code": "10001\n00000\n10001\n00000\n10001",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4796",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #127 - Codeforces - Code 7",
          "code": "0 0 1 0 0\n0 0 0 0 0\n0 0 1 0 0\n0 0 0 0 0\n0 0 1 0 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4796",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #127 - Codeforces - Code 8",
          "code": "0 0 1 0 0\n0 0 0 0 0\n0 0 1 0 0\n0 0 0 0 0\n0 0 1 0 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4796",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #127 - Codeforces - Code 9",
          "code": "0 1 0\n0 0 0\n0 1 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4796",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #127 - Codeforces - Code 10",
          "code": "0 1 0\n0 0 0\n0 1 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4796",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #127 - Codeforces - Code 11",
          "code": "0 1 0\n0 0 0\n0 1 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4796",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #127 - Codeforces - Code 12",
          "code": "0 1 0\n0 0 0\n0 1 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4796",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #127 - Codeforces - Code 13",
          "code": "int n;\ncin >> n;\nif (n == 3)\n{\n  cout << 5;\n  return 0;\n}\nfor (int i = 1;; i += 2)\n  if ((i*i+1)/2>=n)\n  {\n    cout << i;\n    return 0;\n  }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4796",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #127 - Codeforces - Code 14",
          "code": "int n;\ncin >> n;\nif (n == 3)\n{\n  cout << 5;\n  return 0;\n}\nfor (int i = 1;; i += 2)\n  if ((i*i+1)/2>=n)\n  {\n    cout << i;\n    return 0;\n  }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4796",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #127 — разбор - Codeforces - Code 1",
          "code": "w - массив слов задачи Лёши\ns - описание очередной задачи из архива\nbest = 100\nfor a = 1 to k do\n    for b = 1 to k do\n        for c = 1 to k do\n            for d = 1 to k do\n                if s[a] == w[1] and s[b] == w[2] and s[c] == w[3] and s[d] == w[4] then\n                    inversions = 0\n                    if a > b then inversions = inversions + 1\n                    if a > c then inversions = inversions + 1\n                    if a > d then inversions = inversions + 1\n                    if b > c then inversions = inversions + 1\n                    if b > d then inversions = inversions + 1\n                    if c > d then inversions = inversions + 1\n                    if inversions < best then\n                        best = inversions",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4808",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #127 — разбор - Codeforces - Code 2",
          "code": "w - массив слов задачи Лёши\ns - описание очередной задачи из архива\nbest = 100\nfor a = 1 to k do\n    for b = 1 to k do\n        for c = 1 to k do\n            for d = 1 to k do\n                if s[a] == w[1] and s[b] == w[2] and s[c] == w[3] and s[d] == w[4] then\n                    inversions = 0\n                    if a > b then inversions = inversions + 1\n                    if a > c then inversions = inversions + 1\n                    if a > d then inversions = inversions + 1\n                    if b > c then inversions = inversions + 1\n                    if b > d then inversions = inversions + 1\n                    if c > d then inversions = inversions + 1\n                    if inversions < best then\n                        best = inversions",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4808",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #127 — разбор - Codeforces - Code 3",
          "code": "10 b c a b a d d d a a",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4808",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #127 — разбор - Codeforces - Code 4",
          "code": "REP(mask,(1<<15)) REP(i,15) for(j=i;j<15;j++) if(mask&(1<<j)) cost[mask][i]++;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4808",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #127 — разбор - Codeforces - Code 5",
          "code": "long sortAndCountInv(int []a, int l, int r) {\n   if (r - l <= 1) return 0;\n   int m = (l + r)  / 2;\n   long L = sortAndCountInv(a, l, m);\n   long R = sortAndCountInv(a, m + 1, r);\n   long M = 0; \n   int []t = a.clone();\n   int at = 0;\n   for (int i = 0, j = m + 1; i <= m && j <=r; ) {\n       if (t[i] > t[j])  { // если этот элемент больше элемента справа, то значит ( так как левая часть уже отсортирована) и все остальные элементы слева больше, значит, к числу инверсий добавим (m - i) \n        M += m -i; \n        a[at++] = t[j++];\n      } \n      else  a[at++] = t[i++];             \n   }\n   while (i <= m) a[at++] = t[i++];\n   while(j <= r) a[at++]=t[j++];\n   return L + M + R;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4808",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #127 — разбор - Codeforces - Code 6",
          "code": "long sortAndCountInv(int []a, int l, int r) {\n   if (r - l <= 1) return 0;\n   int m = (l + r)  / 2;\n   long L = sortAndCountInv(a, l, m);\n   long R = sortAndCountInv(a, m + 1, r);\n   long M = 0; \n   int []t = a.clone();\n   int at = 0;\n   for (int i = 0, j = m + 1; i <= m && j <=r; ) {\n       if (t[i] > t[j])  { // если этот элемент больше элемента справа, то значит ( так как левая часть уже отсортирована) и все остальные элементы слева больше, значит, к числу инверсий добавим (m - i) \n        M += m -i; \n        a[at++] = t[j++];\n      } \n      else  a[at++] = t[i++];             \n   }\n   while (i <= m) a[at++] = t[i++];\n   while(j <= r) a[at++]=t[j++];\n   return L + M + R;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4808",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #127 — разбор - Codeforces - Code 1",
          "code": "w - массив слов задачи Лёши\ns - описание очередной задачи из архива\nbest = 100\nfor a = 1 to k do\n    for b = 1 to k do\n        for c = 1 to k do\n            for d = 1 to k do\n                if s[a] == w[1] and s[b] == w[2] and s[c] == w[3] and s[d] == w[4] then\n                    inversions = 0\n                    if a > b then inversions = inversions + 1\n                    if a > c then inversions = inversions + 1\n                    if a > d then inversions = inversions + 1\n                    if b > c then inversions = inversions + 1\n                    if b > d then inversions = inversions + 1\n                    if c > d then inversions = inversions + 1\n                    if inversions < best then\n                        best = inversions",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4808",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #127 — разбор - Codeforces - Code 2",
          "code": "w - массив слов задачи Лёши\ns - описание очередной задачи из архива\nbest = 100\nfor a = 1 to k do\n    for b = 1 to k do\n        for c = 1 to k do\n            for d = 1 to k do\n                if s[a] == w[1] and s[b] == w[2] and s[c] == w[3] and s[d] == w[4] then\n                    inversions = 0\n                    if a > b then inversions = inversions + 1\n                    if a > c then inversions = inversions + 1\n                    if a > d then inversions = inversions + 1\n                    if b > c then inversions = inversions + 1\n                    if b > d then inversions = inversions + 1\n                    if c > d then inversions = inversions + 1\n                    if inversions < best then\n                        best = inversions",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4808",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #127 — разбор - Codeforces - Code 3",
          "code": "10 b c a b a d d d a a",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4808",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #127 — разбор - Codeforces - Code 4",
          "code": "REP(mask,(1<<15)) REP(i,15) for(j=i;j<15;j++) if(mask&(1<<j)) cost[mask][i]++;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4808",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #127 — разбор - Codeforces - Code 5",
          "code": "long sortAndCountInv(int []a, int l, int r) {\n   if (r - l <= 1) return 0;\n   int m = (l + r)  / 2;\n   long L = sortAndCountInv(a, l, m);\n   long R = sortAndCountInv(a, m + 1, r);\n   long M = 0; \n   int []t = a.clone();\n   int at = 0;\n   for (int i = 0, j = m + 1; i <= m && j <=r; ) {\n       if (t[i] > t[j])  { // если этот элемент больше элемента справа, то значит ( так как левая часть уже отсортирована) и все остальные элементы слева больше, значит, к числу инверсий добавим (m - i) \n        M += m -i; \n        a[at++] = t[j++];\n      } \n      else  a[at++] = t[i++];             \n   }\n   while (i <= m) a[at++] = t[i++];\n   while(j <= r) a[at++]=t[j++];\n   return L + M + R;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4808",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #127 — разбор - Codeforces - Code 6",
          "code": "long sortAndCountInv(int []a, int l, int r) {\n   if (r - l <= 1) return 0;\n   int m = (l + r)  / 2;\n   long L = sortAndCountInv(a, l, m);\n   long R = sortAndCountInv(a, m + 1, r);\n   long M = 0; \n   int []t = a.clone();\n   int at = 0;\n   for (int i = 0, j = m + 1; i <= m && j <=r; ) {\n       if (t[i] > t[j])  { // если этот элемент больше элемента справа, то значит ( так как левая часть уже отсортирована) и все остальные элементы слева больше, значит, к числу инверсий добавим (m - i) \n        M += m -i; \n        a[at++] = t[j++];\n      } \n      else  a[at++] = t[i++];             \n   }\n   while (i <= m) a[at++] = t[i++];\n   while(j <= r) a[at++]=t[j++];\n   return L + M + R;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4808",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int x = inf.readInt(1, 100, \"x\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int x = inf.readInt(1, 100, \"x\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int x = inf.readInt(1, 100, \"x\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    // We only need to generate a single integer x in the range [1..100].\n    // This generator allows specifying a concrete x, or a \"type\" to choose x in different ways.\n    // No random seed is set.\n\n    int x = opt<int>(\"x\", -1);               // If an x is given, we'll use that directly.\n    string type = opt<string>(\"type\", \"random\"); // Otherwise, decide how to generate x based on \"type\".\n\n    if (x == -1) {  // If x was not provided, generate it.\n        if (type == \"random\") {\n            // Any random x in [1..100].\n            x = rnd.next(1, 100);\n        } else if (type == \"small\") {\n            // Random x in [1..10].\n            x = rnd.next(1, 10);\n        } else if (type == \"large\") {\n            // Random x in [90..100].\n            x = rnd.next(90, 100);\n        } else if (type == \"corner\") {\n            // Pick from a set of \"corner\" (special) values.\n            vector<int> corners = {1, 2, 3, 4, 9, 16, 25, 49, 50, 64, 81, 99, 100};\n            x = corners[rnd.next((int)corners.size())];\n        } else {\n            // Fallback to random if no recognized type is given.\n            x = rnd.next(1, 100);\n        }\n    }\n\n    // Output the chosen x.\n    cout << x << endl;\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    // We only need to generate a single integer x in the range [1..100].\n    // This generator allows specifying a concrete x, or a \"type\" to choose x in different ways.\n    // No random seed is set.\n\n    int x = opt<int>(\"x\", -1);               // If an x is given, we'll use that directly.\n    string type = opt<string>(\"type\", \"random\"); // Otherwise, decide how to generate x based on \"type\".\n\n    if (x == -1) {  // If x was not provided, generate it.\n        if (type == \"random\") {\n            // Any random x in [1..100].\n            x = rnd.next(1, 100);\n        } else if (type == \"small\") {\n            // Random x in [1..10].\n            x = rnd.next(1, 10);\n        } else if (type == \"large\") {\n            // Random x in [90..100].\n            x = rnd.next(90, 100);\n        } else if (type == \"corner\") {\n            // Pick from a set of \"corner\" (special) values.\n            vector<int> corners = {1, 2, 3, 4, 9, 16, 25, 49, 50, 64, 81, 99, 100};\n            x = corners[rnd.next((int)corners.size())];\n        } else {\n            // Fallback to random if no recognized type is given.\n            x = rnd.next(1, 100);\n        }\n    }\n\n    // Output the chosen x.\n    cout << x << endl;\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -x 1\n./gen -x 2\n./gen -x 3\n./gen -x 4\n./gen -x 9\n./gen -x 16\n./gen -x 25\n./gen -x 50\n./gen -x 81\n./gen -x 99\n./gen -x 100\n\n./gen -type corner\n./gen -type corner\n./gen -type corner\n\n./gen -type small\n./gen -type small\n\n./gen -type large\n./gen -type large\n\n./gen -type random\n./gen -type random\n\n./gen\n./gen\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T19:48:02.476600",
        "total_tutorials": 3,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "201/B",
      "title": "B. Guess That Car!",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains two integers n and m (1 ≤ n, m ≤ 1000) — the sizes of the parking lot. Each of the next n lines contains m integers: the j-th number in the i-th line describes the \"rarity\" cij (0 ≤ cij ≤ 100000) of the car that is located in the square with coordinates (i, j).",
      "output_spec": "OutputIn the first line print the minimum total time Yura needs to guess all offered cars. In the second line print two numbers li and lj (0 ≤ li ≤ n, 0 ≤ lj ≤ m) — the numbers of dividing lines that form a junction that Yura should choose to stand on at the beginning of the game show. If there are multiple optimal starting points, print the point with smaller li. If there are still multiple such points, print the point with smaller lj.Please do not use the %lld specifier to read or write 64-bit integers in С++. It is preferred to use the cin, cout streams or the %I64d specifier.",
      "sample_tests": "ExamplesInputCopy2 33 4 53 9 1OutputCopy3921 1InputCopy3 41 0 0 00 0 3 00 0 5 5OutputCopy2402 3",
      "description": "B. Guess That Car!\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains two integers n and m (1 ≤ n, m ≤ 1000) — the sizes of the parking lot. Each of the next n lines contains m integers: the j-th number in the i-th line describes the \"rarity\" cij (0 ≤ cij ≤ 100000) of the car that is located in the square with coordinates (i, j).\n\nOutputIn the first line print the minimum total time Yura needs to guess all offered cars. In the second line print two numbers li and lj (0 ≤ li ≤ n, 0 ≤ lj ≤ m) — the numbers of dividing lines that form a junction that Yura should choose to stand on at the beginning of the game show. If there are multiple optimal starting points, print the point with smaller li. If there are still multiple such points, print the point with smaller lj.Please do not use the %lld specifier to read or write 64-bit integers in С++. It is preferred to use the cin, cout streams or the %I64d specifier.\n\nInputCopy2 33 4 53 9 1OutputCopy3921 1InputCopy3 41 0 0 00 0 3 00 0 5 5OutputCopy2402 3\n\nInputCopy2 33 4 53 9 1\n\nOutputCopy3921 1\n\nInputCopy3 41 0 0 00 0 3 00 0 5 5\n\nOutputCopy2402 3\n\nNoteIn the first test case the total time of guessing all cars is equal to 3·8 + 3·8 + 4·8 + 9·8 + 5·40 + 1·40 = 392.The coordinate system of the field:",
      "solutions": [
        {
          "title": "Codeforces Round #127 - Codeforces",
          "content": "Hello everyone!As many of you already know, today is the day for Codeforces Round #127 missing which is really undesirable ;)Original problems for you were created by tourist and Romka. We tried to emphasize the ideological component of the problems, thus we hope that you'll spend more time thinking than coding. Special thanks for helping in setting the contest go to Codeforces coordinator Gerald. We also thank Delinur for translating the problem statements and Alex_KPR for reviewing them.We hope that this round won't be just a regular Codeforces round for you, but will bring you new experience and new knowledge. For the authors all problems are equally easy, yet we tried to arrange them in decreasing order of simplicity :)Problems' point values in Division 1 are 1000-1000-1500-2000-2500. Problems' point values in Division 2 are 500-1000-2000-2000-2500.Wish you success!UPD: The contest is over, thanks all for participating. We hope you enjoyed it :)In Division 1 rng_58 was a clear winner, solving all 5 problems in an hour and a half! No one else managed to solve all problems in two hours.The winners in Division 1 are (full results): rng_58 peter50216 liympanda White_Bear havaliza In Division 2 every problem was solved by somebody, but nobody managed to solve all problems. The battle was very tough and the gaps were very small.The winners in Division 2 are (full results): Leewings snow_lotus 72VanVector_SevNTU Congratulations to the winners!UPD2: The editorial is available now.",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/4796",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1501
        },
        {
          "title": "Codeforces Round #127 — editorial - Codeforces",
          "content": "Problem A(div 2) — LLPSIt's assumed that this problem can be solved just looking at the samples and without reading the statement itself :)Let's find the letter in the given string which comes last in the alphabet, denote this letter by z. If this letter occurs p times in the given string, then the answer is string a consisting of letter z repeated p times.Why is it so? Using the definition of lexicographical comparison and the fact that z is the largest letter in the string it's easy to understand that if some other subsequence b of the given string is lexicographically larger than a, then string b should be longer than a and, moreover, a should be a prefix of b (that is, b should start with a). But string b must be a palindrome, therefore its last letter must be z. In this case string b must contain more occurrences of letter z than the original string s does, which is impossible as b is a subsequence of s.Besides that, the constraint on the length of the string was very low, so the problem could be solved using brute force. For every subsequence of the given string it's necessary to check whether it's a palindrome, and from all palindromic subsequences of s the lexicographically largest should be chosen as the answer. The complexity of such a solution is O(2n·n), where n is the length of the string (unlike the solution above with complexity O(n)).Problem В(div 2) — Brand New Easy ProblemThe constraints in this problem were so low that a solution with complexity O(m·kn) was just fine. In each problem's description it's enough to loop over all possible subsequences of words which are permutations of words in Lesha's problem, for each of them calculate the number of inversions and choose a permutation with the smallest number of inversions. This can result in a short solution using recursion or, for example, you can use several nested loops (from 1 to 4).Here is an example of pseudocode for n = 4: w - array of words of Lesha''s problem\ns - the description of the current problem\nbest = 100\nfor a = 1 to k do\n for b = 1 to k do\n for c = 1 to k do\n for d = 1 to k do\n if s[a] == w[1] and s[b] == w[2] and s[c] == w[3] and s[d] == w[4] then\n inversions = 0\n if a > b then inversions = inversions + 1\n if a > c then inversions = inversions + 1\n if a > d then inversions = inversions + 1\n if b > c then inversions = inversions + 1\n if b > d then inversions = inversions + 1\n if c > d then inversions = inversions + 1\n if inversions < best then\n best = inversionsAt the end you should choose the problem with the smallest value of best and print the answer in the corresponding form.Problem A(div 1)/C(div 2) — Clear SymmetryIt's interesting that originally the authors had an idea not to include the x = 3 case into pretests. Imagine the number of successful hacking attempts in this contest -- considering the fact that none of the first 43 solutions to this problem passed pretests :)Note that the sought n is always an odd number. Indeed, if n is even, then two central rows of matrix A must contain zeroes, otherwise there will exist two neighbouring cells containing ones. Similar restriction applies to two central columns of matrix A. Replacing two central rows with just one and two central columns with just one and leaving zeroes in them, we'll obtain a smaller matrix with the same sharpness.Note that the sharpness of a matrix with side n can't exceed . It's easy to see that it's possible to lay out \"domino pieces\" 1 by 2 without intersections on a field with side n (in other words, all cells except one can be divided into pairs so that each pair contains neighbouring cells). Then there can be at most one one in the cells under each \"domino piece\" in the corresponding matrix. Therefore, the total number of ones doesn't exceed .Note that a matrix with side n and sharpness exists for an odd n. Paint all cells of the matrix in chess order and put ones into black cells and zeroes into white cells. It's easy to see that such a matrix is both clear and symmetrical and has sharpenss exactly .Intuitively it seems that if there exists a matrix with sharpness there should also exist a matrix with every smaller sharpness. That's correct except only one case -- there doesn't exist a matrix with side 3 and sharpness 3, though there exists a matrix with side 3 and sharpness 5.Let's show that the claim above is correct for odd n ≥ 5. We'll build a matrix with sharpness as shown above and gradually turn ones into zeroes reducing the sharpness. Cells containing ones in the matrix can be divided into three types.The first type is the central cell. The number in it can be turned into zero and the matrix won't stop satisfying the required conditions.The second type is the cells in the central row and the central column (except central cell). Such cells are divided into pairs by the condition of symmetry -- if we turn the number in one of them into zero, we should turn the number in its pair cell into zero as well.The third type is all the other cells. Such cells are divided into groups of four by the condition of symmetry -- if we turn the number in one of them into zero, we should turn the number in all cells from this group into zero as well.Now for obtaining the required sharpness of x we'll act greedily. Let's turn ones into zeroes in third type cells by four until the current shapness exceeds x by less than 4 or there are no third type cells with ones remaining. After that let's turn ones into zeroes in second type cells by pairs while the current sharpness exceeds x by at least 2. At this moment the sharpness of our matrix is either x or x + 1. If it's equal to x + 1, let's put a zero into the central cell and obtain a matrix with sharpness x. It's easy to check that we'll be able to obtain a matrix with any sharpness acting this way.Why is this reasoning incorrect for n = 3? Because second type cells are absent in the matrix with sharpness 5 obtained from chess coloring. For n ≥ 5 this matrix contains cells of all types, which is important for the algorithm above. It's better to find the answers for x ≤ 5 by hand but carefully -- for example, a lot of contestants decided that the answer for x = 2 is 5 instead of 3.Problem В(div 1)/D(div 2) — Guess That Car!We need to find such x and y that the value of is minimum possible. This expression can be rewritten as . Note that the first part doesn't depend on y and the second part doesn't depend on x, so we can minimize these parts separately. Here is how to minimize , the second part is minimized similarly. As the expression in the brackets doesn't depend on j, this part can be rewritten as , where . Now it's enough to calculate the required value for all possible values of x and choose x for which this value is the smallest. The optimal value of y can be found similarly.The overall complexity of this solution is O(n·m + n2 + m2).As the objective function is convex, other approaches to this problem are possible, for example, ternary search, gradient descent or analytical approach (calculation of derivatives).The main hero of this problem is Ra16bit.Problem С(div 1)/E(div 2) — Fragile BridgesThere are a few different ways to solve this problem, the editorial contains one of them.For any solution the following fact is useful. Suppose the sought path starts on platform i and ends on platform j (i ≤ j, if that's not the case, we can reverse the path). Then all bridges between platforms i and j will be passed through an odd number of times, and all other bridges will be passed through an even number of times.Let's find the maximum length of a path with its ends on platforms i and j. To do that, let's find the following auxiliary values for each platform: lefti -- the maximum length of a path starting and ending on platform i and passing only through bridges to the left of platform i; rightj -- similarly for bridges to the right of platform j. Also for each bridge define oddi as the largest odd number not larger than ai, and for each platform define sumOddi as the sum of oddj for all bridges to the left of platform i.Then the maximum length of a path with its ends on platforms i and j is equal to lefti + rightj + (sumOddj - sumOddi), or, which is the same, (rightj + sumOddj) + (lefti - sumOddi).Now we can find the pair (i, j) for which this value is the largest in linear time. Let's loop over j. From the formula it's obvious that we should find such i ≤ j that (lefti - sumOddi) is the largest. If we loop over j from 1 to n, we can maintain the largest value of this expression for all i ≤ j and recalculate it when moving to the next j, comparing (leftj - sumOddj) with the current maximum and possibly updating this maximum. This way for each j we have to check only one value of i and not all i ≤ j.The last thing to show is how to find all lefti quickly (all rightj can be found similarly). Clearly left1 = 0, then we'll calculate lefti using lefti - 1. Note that when ai - 1 = 1, we have lefti = 0 as after passing the bridge to platform (i - 1) this bridge will collapse and it will be impossible to return to platform i. If ai - 1 > 1, then lefti = lefti - 1 + eveni - 1, where eveni - 1 is the largest even number not larger than ai - 1. Indeed, we can move to platform (i - 1), then move along the path corresponding to lefti - 1, and then move along the bridge between platforms (i - 1) and i until the limit on the number of transitions is less than 2 (finishing on platform i).The overall complexity of this solution is O(n).Problem D(div 1) — Brand New ProblemThe first solution coming to mind is dynamic programming f[i][j] =  (the smallest possible number of inversions to the moment if among the first j words of the archive problem we've found a permutation of words included in bitmask i). In this solution parameter j varies from 0 to 500000, parameter i varies from 0 to 215 - 1 and calculation of each value is possible in O(1) (we are either using the current word in the subsequence or not). That's too much.Let's make use of a standard technique: make the value of DP a new parameter and make one of the existing parameters the value of DP. Not for every DP this is possible, but at least it's possible for this one :)It's clear that with a fixed subset of words and a fixed number of inversions it's optimal to choose the first occurrences of these words giving this number of inversions. Let f[i][j] =  (the smallest number z such that among first z words of the archive problem there exists a permutation of words from bitmask i containing exactly j inversions). The basis of this DP is f[0][0] = 0, f[0][j] = ∞ for j > 0. Recalculation of values happens in the following way: loop over a word q from the bitmask i which was the last in the permutation. With the knowledge of this word and the number of inversions j it's easy to find how many inversions j' there were without this word — that's j minus the number of words in the mask which appeared later in Lesha's problem than word q. Let p = f[i^(1«q)][j']. Then we should consider p2 equal to the position of the next occurrence of word q after position p as a possible value for f[i][j]. To find p2 quickly we should fill an array next[500010][15] so that next[i][j] =  (the smallest position k > i such that the k-th word in the archive problem equals the j-th word in Lesha's problem) for each archive problem in advance. This array can be easily filled passing from right to left once.The total number of operations can be calculated as m·(k·n + 2n·Cn2·n), where m is the number of problems in the archive, k is the number of words in one archive problem description and n is the number of words in Lesha's problem description. Under the given constraints that is about 200 million operations, and the author's solutions (including a Java solution) worked for less than 2 seconds. The time limit was set with a margin -- 5 seconds.The main heroes of problems D(div 1) and B(div 2) are Chmel_Tolstiy and ivan.metelsky.Problem E(div 1) — Thoroughly Bureaucratic OrganizationLet's imagine that we have a magic function maxN(m, k) that returns, given m and k, the largest value of n such that it's possible to solve the problem for n people and m empty lines in the form using k requests. Then we'll be able to use binary search on the answer -- the number of requests k.Suppose we've made k requests. Let's match a string of length k to each person, where the i-th character is equal to 1 if this person is mentioned in the i-th request and 0 otherwise. Note that we'll be able to determine the exact appointment date for each person if and only if all n strings of length k are pairwise distinct. Indeed, if two persons' strings are the same, their appointment dates could be exchanged and the responses to the requests wouldn't have changed. If all strings are distinct, for each date we may find the person appointed for this date looking at the set of requests with responses containing this date and finding the person mentioned in the same set of requests.The constraint on m empty lines in the form means that each of k positions in the strings should contain no more than m ones in all n strings overall. Thus function maxN(m, k) should return the maximum size of a set of distinct k-bit strings meeting this condition. Let's make this restriction weaker: we'll search for a set such that the total number of ones in all n strings doesn't exceed k·m. As we'll prove later, the answer won't change.With this weaker restriction the problem can be solved using a simple greedy strategy. It's obvious that strings with smaller number of ones are better. Let's loop over the number of ones i in the string from 0 to k and also maintain a variable t containing the remaining number of ones (initially it's equal to k·m). Then at the i-th step we can take at most strings containing i ones. Let's add p to the answer and subtract p·i from t. Note that the values of Cki should be calculated with care -- they can turn out to be too large, so it's important not to allow overflows.It can be shown that the overall complexity of this algorithm is at most O(log2 n).The remaining thing is to prove the claim above. The idea of the proof below belongs to rng_58 (the author's proof is notably harder).Let's solve the problem with a greedy algorithm with the k·m constraint on the total number of ones. The resulting set of strings may not satisfy the restriction of m ones for each position. If it doesn't, some of the positions contain more than m ones and some contain less than m ones. Let's pick any position X containing more than m ones and any position Y containing less than m ones. Find all strings containing 1 at X and 0 at Y (suppose there are x such strings) and all strings containing 0 at X and 1 at Y (suppose there are y such strings). It's clear that x > y. In each of x strings we can try to put 0 at X and 1 at Y -- then the string we obtain will either remain unique in this set or coincide with one of those y strings (but only one). As x > y, for at least one of x strings the change above leaves this string unique. Let's take this string and put 0 at X and 1 at Y. Now position X contains one 1 less, and position Y contains one 1 more. It means that the total number of \"extra\" ones in the positions has been decreased (as Y still contains no more than m ones). Doing this operation for a needed number of times, we'll achieve our goal.",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/4808",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 15409
        },
        {
          "title": "Codeforces Round #127 — editorial - Codeforces",
          "content": "Problem A(div 2) — LLPSIt's assumed that this problem can be solved just looking at the samples and without reading the statement itself :)Let's find the letter in the given string which comes last in the alphabet, denote this letter by z. If this letter occurs p times in the given string, then the answer is string a consisting of letter z repeated p times.Why is it so? Using the definition of lexicographical comparison and the fact that z is the largest letter in the string it's easy to understand that if some other subsequence b of the given string is lexicographically larger than a, then string b should be longer than a and, moreover, a should be a prefix of b (that is, b should start with a). But string b must be a palindrome, therefore its last letter must be z. In this case string b must contain more occurrences of letter z than the original string s does, which is impossible as b is a subsequence of s.Besides that, the constraint on the length of the string was very low, so the problem could be solved using brute force. For every subsequence of the given string it's necessary to check whether it's a palindrome, and from all palindromic subsequences of s the lexicographically largest should be chosen as the answer. The complexity of such a solution is O(2n·n), where n is the length of the string (unlike the solution above with complexity O(n)).Problem В(div 2) — Brand New Easy ProblemThe constraints in this problem were so low that a solution with complexity O(m·kn) was just fine. In each problem's description it's enough to loop over all possible subsequences of words which are permutations of words in Lesha's problem, for each of them calculate the number of inversions and choose a permutation with the smallest number of inversions. This can result in a short solution using recursion or, for example, you can use several nested loops (from 1 to 4).Here is an example of pseudocode for n = 4: w - array of words of Lesha''s problem\ns - the description of the current problem\nbest = 100\nfor a = 1 to k do\n for b = 1 to k do\n for c = 1 to k do\n for d = 1 to k do\n if s[a] == w[1] and s[b] == w[2] and s[c] == w[3] and s[d] == w[4] then\n inversions = 0\n if a > b then inversions = inversions + 1\n if a > c then inversions = inversions + 1\n if a > d then inversions = inversions + 1\n if b > c then inversions = inversions + 1\n if b > d then inversions = inversions + 1\n if c > d then inversions = inversions + 1\n if inversions < best then\n best = inversionsAt the end you should choose the problem with the smallest value of best and print the answer in the corresponding form.Problem A(div 1)/C(div 2) — Clear SymmetryIt's interesting that originally the authors had an idea not to include the x = 3 case into pretests. Imagine the number of successful hacking attempts in this contest -- considering the fact that none of the first 43 solutions to this problem passed pretests :)Note that the sought n is always an odd number. Indeed, if n is even, then two central rows of matrix A must contain zeroes, otherwise there will exist two neighbouring cells containing ones. Similar restriction applies to two central columns of matrix A. Replacing two central rows with just one and two central columns with just one and leaving zeroes in them, we'll obtain a smaller matrix with the same sharpness.Note that the sharpness of a matrix with side n can't exceed . It's easy to see that it's possible to lay out \"domino pieces\" 1 by 2 without intersections on a field with side n (in other words, all cells except one can be divided into pairs so that each pair contains neighbouring cells). Then there can be at most one one in the cells under each \"domino piece\" in the corresponding matrix. Therefore, the total number of ones doesn't exceed .Note that a matrix with side n and sharpness exists for an odd n. Paint all cells of the matrix in chess order and put ones into black cells and zeroes into white cells. It's easy to see that such a matrix is both clear and symmetrical and has sharpenss exactly .Intuitively it seems that if there exists a matrix with sharpness there should also exist a matrix with every smaller sharpness. That's correct except only one case -- there doesn't exist a matrix with side 3 and sharpness 3, though there exists a matrix with side 3 and sharpness 5.Let's show that the claim above is correct for odd n ≥ 5. We'll build a matrix with sharpness as shown above and gradually turn ones into zeroes reducing the sharpness. Cells containing ones in the matrix can be divided into three types.The first type is the central cell. The number in it can be turned into zero and the matrix won't stop satisfying the required conditions.The second type is the cells in the central row and the central column (except central cell). Such cells are divided into pairs by the condition of symmetry -- if we turn the number in one of them into zero, we should turn the number in its pair cell into zero as well.The third type is all the other cells. Such cells are divided into groups of four by the condition of symmetry -- if we turn the number in one of them into zero, we should turn the number in all cells from this group into zero as well.Now for obtaining the required sharpness of x we'll act greedily. Let's turn ones into zeroes in third type cells by four until the current shapness exceeds x by less than 4 or there are no third type cells with ones remaining. After that let's turn ones into zeroes in second type cells by pairs while the current sharpness exceeds x by at least 2. At this moment the sharpness of our matrix is either x or x + 1. If it's equal to x + 1, let's put a zero into the central cell and obtain a matrix with sharpness x. It's easy to check that we'll be able to obtain a matrix with any sharpness acting this way.Why is this reasoning incorrect for n = 3? Because second type cells are absent in the matrix with sharpness 5 obtained from chess coloring. For n ≥ 5 this matrix contains cells of all types, which is important for the algorithm above. It's better to find the answers for x ≤ 5 by hand but carefully -- for example, a lot of contestants decided that the answer for x = 2 is 5 instead of 3.Problem В(div 1)/D(div 2) — Guess That Car!We need to find such x and y that the value of is minimum possible. This expression can be rewritten as . Note that the first part doesn't depend on y and the second part doesn't depend on x, so we can minimize these parts separately. Here is how to minimize , the second part is minimized similarly. As the expression in the brackets doesn't depend on j, this part can be rewritten as , where . Now it's enough to calculate the required value for all possible values of x and choose x for which this value is the smallest. The optimal value of y can be found similarly.The overall complexity of this solution is O(n·m + n2 + m2).As the objective function is convex, other approaches to this problem are possible, for example, ternary search, gradient descent or analytical approach (calculation of derivatives).The main hero of this problem is Ra16bit.Problem С(div 1)/E(div 2) — Fragile BridgesThere are a few different ways to solve this problem, the editorial contains one of them.For any solution the following fact is useful. Suppose the sought path starts on platform i and ends on platform j (i ≤ j, if that's not the case, we can reverse the path). Then all bridges between platforms i and j will be passed through an odd number of times, and all other bridges will be passed through an even number of times.Let's find the maximum length of a path with its ends on platforms i and j. To do that, let's find the following auxiliary values for each platform: lefti -- the maximum length of a path starting and ending on platform i and passing only through bridges to the left of platform i; rightj -- similarly for bridges to the right of platform j. Also for each bridge define oddi as the largest odd number not larger than ai, and for each platform define sumOddi as the sum of oddj for all bridges to the left of platform i.Then the maximum length of a path with its ends on platforms i and j is equal to lefti + rightj + (sumOddj - sumOddi), or, which is the same, (rightj + sumOddj) + (lefti - sumOddi).Now we can find the pair (i, j) for which this value is the largest in linear time. Let's loop over j. From the formula it's obvious that we should find such i ≤ j that (lefti - sumOddi) is the largest. If we loop over j from 1 to n, we can maintain the largest value of this expression for all i ≤ j and recalculate it when moving to the next j, comparing (leftj - sumOddj) with the current maximum and possibly updating this maximum. This way for each j we have to check only one value of i and not all i ≤ j.The last thing to show is how to find all lefti quickly (all rightj can be found similarly). Clearly left1 = 0, then we'll calculate lefti using lefti - 1. Note that when ai - 1 = 1, we have lefti = 0 as after passing the bridge to platform (i - 1) this bridge will collapse and it will be impossible to return to platform i. If ai - 1 > 1, then lefti = lefti - 1 + eveni - 1, where eveni - 1 is the largest even number not larger than ai - 1. Indeed, we can move to platform (i - 1), then move along the path corresponding to lefti - 1, and then move along the bridge between platforms (i - 1) and i until the limit on the number of transitions is less than 2 (finishing on platform i).The overall complexity of this solution is O(n).Problem D(div 1) — Brand New ProblemThe first solution coming to mind is dynamic programming f[i][j] =  (the smallest possible number of inversions to the moment if among the first j words of the archive problem we've found a permutation of words included in bitmask i). In this solution parameter j varies from 0 to 500000, parameter i varies from 0 to 215 - 1 and calculation of each value is possible in O(1) (we are either using the current word in the subsequence or not). That's too much.Let's make use of a standard technique: make the value of DP a new parameter and make one of the existing parameters the value of DP. Not for every DP this is possible, but at least it's possible for this one :)It's clear that with a fixed subset of words and a fixed number of inversions it's optimal to choose the first occurrences of these words giving this number of inversions. Let f[i][j] =  (the smallest number z such that among first z words of the archive problem there exists a permutation of words from bitmask i containing exactly j inversions). The basis of this DP is f[0][0] = 0, f[0][j] = ∞ for j > 0. Recalculation of values happens in the following way: loop over a word q from the bitmask i which was the last in the permutation. With the knowledge of this word and the number of inversions j it's easy to find how many inversions j' there were without this word — that's j minus the number of words in the mask which appeared later in Lesha's problem than word q. Let p = f[i^(1«q)][j']. Then we should consider p2 equal to the position of the next occurrence of word q after position p as a possible value for f[i][j]. To find p2 quickly we should fill an array next[500010][15] so that next[i][j] =  (the smallest position k > i such that the k-th word in the archive problem equals the j-th word in Lesha's problem) for each archive problem in advance. This array can be easily filled passing from right to left once.The total number of operations can be calculated as m·(k·n + 2n·Cn2·n), where m is the number of problems in the archive, k is the number of words in one archive problem description and n is the number of words in Lesha's problem description. Under the given constraints that is about 200 million operations, and the author's solutions (including a Java solution) worked for less than 2 seconds. The time limit was set with a margin -- 5 seconds.The main heroes of problems D(div 1) and B(div 2) are Chmel_Tolstiy and ivan.metelsky.Problem E(div 1) — Thoroughly Bureaucratic OrganizationLet's imagine that we have a magic function maxN(m, k) that returns, given m and k, the largest value of n such that it's possible to solve the problem for n people and m empty lines in the form using k requests. Then we'll be able to use binary search on the answer -- the number of requests k.Suppose we've made k requests. Let's match a string of length k to each person, where the i-th character is equal to 1 if this person is mentioned in the i-th request and 0 otherwise. Note that we'll be able to determine the exact appointment date for each person if and only if all n strings of length k are pairwise distinct. Indeed, if two persons' strings are the same, their appointment dates could be exchanged and the responses to the requests wouldn't have changed. If all strings are distinct, for each date we may find the person appointed for this date looking at the set of requests with responses containing this date and finding the person mentioned in the same set of requests.The constraint on m empty lines in the form means that each of k positions in the strings should contain no more than m ones in all n strings overall. Thus function maxN(m, k) should return the maximum size of a set of distinct k-bit strings meeting this condition. Let's make this restriction weaker: we'll search for a set such that the total number of ones in all n strings doesn't exceed k·m. As we'll prove later, the answer won't change.With this weaker restriction the problem can be solved using a simple greedy strategy. It's obvious that strings with smaller number of ones are better. Let's loop over the number of ones i in the string from 0 to k and also maintain a variable t containing the remaining number of ones (initially it's equal to k·m). Then at the i-th step we can take at most strings containing i ones. Let's add p to the answer and subtract p·i from t. Note that the values of Cki should be calculated with care -- they can turn out to be too large, so it's important not to allow overflows.It can be shown that the overall complexity of this algorithm is at most O(log2 n).The remaining thing is to prove the claim above. The idea of the proof below belongs to rng_58 (the author's proof is notably harder).Let's solve the problem with a greedy algorithm with the k·m constraint on the total number of ones. The resulting set of strings may not satisfy the restriction of m ones for each position. If it doesn't, some of the positions contain more than m ones and some contain less than m ones. Let's pick any position X containing more than m ones and any position Y containing less than m ones. Find all strings containing 1 at X and 0 at Y (suppose there are x such strings) and all strings containing 0 at X and 1 at Y (suppose there are y such strings). It's clear that x > y. In each of x strings we can try to put 0 at X and 1 at Y -- then the string we obtain will either remain unique in this set or coincide with one of those y strings (but only one). As x > y, for at least one of x strings the change above leaves this string unique. Let's take this string and put 0 at X and 1 at Y. Now position X contains one 1 less, and position Y contains one 1 more. It means that the total number of \"extra\" ones in the positions has been decreased (as Y still contains no more than m ones). Doing this operation for a needed number of times, we'll achieve our goal.",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/4808",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 15409
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #127 - Codeforces - Code 1",
          "code": "1 0 0\n0 1 0\n1 0 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4796",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #127 - Codeforces - Code 2",
          "code": "1 0 0\n0 1 0\n1 0 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4796",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #127 - Codeforces - Code 3",
          "code": "0 0 1 0 0\n0 0 0 0 0\n0 0 1 0 0\n0 0 0 0 0\n0 0 1 0 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4796",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #127 - Codeforces - Code 4",
          "code": "0 0 1 0 0\n0 0 0 0 0\n0 0 1 0 0\n0 0 0 0 0\n0 0 1 0 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4796",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #127 - Codeforces - Code 5",
          "code": "0 1 0\n0 0 0\n0 1 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4796",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #127 - Codeforces - Code 6",
          "code": "0 1 0\n0 0 0\n0 1 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4796",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #127 - Codeforces - Code 7",
          "code": "0 1 0\n0 0 0\n0 1 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4796",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #127 - Codeforces - Code 8",
          "code": "0 1 0\n0 0 0\n0 1 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4796",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #127 — editorial - Codeforces - Code 1",
          "code": "w - array of words of Lesha''s problem\ns - the description of the current problem\nbest = 100\nfor a = 1 to k do\n    for b = 1 to k do\n        for c = 1 to k do\n            for d = 1 to k do\n                if s[a] == w[1] and s[b] == w[2] and s[c] == w[3] and s[d] == w[4] then\n                    inversions = 0\n                    if a > b then inversions = inversions + 1\n                    if a > c then inversions = inversions + 1\n                    if a > d then inversions = inversions + 1\n                    if b > c then inversions = inversions + 1\n                    if b > d then inversions = inversions + 1\n                    if c > d then inversions = inversions + 1\n                    if inversions < best then\n                        best = inversions",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4808",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #127 — editorial - Codeforces - Code 2",
          "code": "w - array of words of Lesha''s problem\ns - the description of the current problem\nbest = 100\nfor a = 1 to k do\n    for b = 1 to k do\n        for c = 1 to k do\n            for d = 1 to k do\n                if s[a] == w[1] and s[b] == w[2] and s[c] == w[3] and s[d] == w[4] then\n                    inversions = 0\n                    if a > b then inversions = inversions + 1\n                    if a > c then inversions = inversions + 1\n                    if a > d then inversions = inversions + 1\n                    if b > c then inversions = inversions + 1\n                    if b > d then inversions = inversions + 1\n                    if c > d then inversions = inversions + 1\n                    if inversions < best then\n                        best = inversions",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4808",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #127 — editorial - Codeforces - Code 3",
          "code": "REP(mask,(1<<15)) REP(i,15) for(j=i;j<15;j++) if(mask&(1<<j)) cost[mask][i]++;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4808",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #127 — editorial - Codeforces - Code 1",
          "code": "w - array of words of Lesha''s problem\ns - the description of the current problem\nbest = 100\nfor a = 1 to k do\n    for b = 1 to k do\n        for c = 1 to k do\n            for d = 1 to k do\n                if s[a] == w[1] and s[b] == w[2] and s[c] == w[3] and s[d] == w[4] then\n                    inversions = 0\n                    if a > b then inversions = inversions + 1\n                    if a > c then inversions = inversions + 1\n                    if a > d then inversions = inversions + 1\n                    if b > c then inversions = inversions + 1\n                    if b > d then inversions = inversions + 1\n                    if c > d then inversions = inversions + 1\n                    if inversions < best then\n                        best = inversions",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4808",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #127 — editorial - Codeforces - Code 2",
          "code": "w - array of words of Lesha''s problem\ns - the description of the current problem\nbest = 100\nfor a = 1 to k do\n    for b = 1 to k do\n        for c = 1 to k do\n            for d = 1 to k do\n                if s[a] == w[1] and s[b] == w[2] and s[c] == w[3] and s[d] == w[4] then\n                    inversions = 0\n                    if a > b then inversions = inversions + 1\n                    if a > c then inversions = inversions + 1\n                    if a > d then inversions = inversions + 1\n                    if b > c then inversions = inversions + 1\n                    if b > d then inversions = inversions + 1\n                    if c > d then inversions = inversions + 1\n                    if inversions < best then\n                        best = inversions",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4808",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #127 — editorial - Codeforces - Code 3",
          "code": "REP(mask,(1<<15)) REP(i,15) for(j=i;j<15;j++) if(mask&(1<<j)) cost[mask][i]++;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4808",
          "author": "Qingyu"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 1000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 1000, \"m\");\n    inf.readEoln();\n\n    for (int i = 0; i < n; i++) {\n        vector<int> c = inf.readInts(m, 0, 100000);\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 1000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 1000, \"m\");\n    inf.readEoln();\n\n    for (int i = 0; i < n; i++) {\n        vector<int> c = inf.readInts(m, 0, 100000);\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 1000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 1000, \"m\");\n    inf.readEoln();\n\n    for (int i = 0; i < n; i++) {\n        vector<int> c = inf.readInts(m, 0, 100000);\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string type = opt<string>(\"type\", \"random\");\n    int max_c = opt<int>(\"max_c\", 100000);\n\n    printf(\"%d %d\\n\", n, m);\n\n    if (type == \"random\") {\n        /* Random c_ij values between 0 and max_c */\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < m; ++j) {\n                int c = rnd.next(0, max_c);\n                printf(\"%d%c\", c, j == m - 1 ? '\\n' : ' ');\n            }\n        }\n    } else if (type == \"zeros\") {\n        /* All c_ij = 0 */\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < m; ++j) {\n                printf(\"0%c\", j == m - 1 ? '\\n' : ' ');\n            }\n        }\n    } else if (type == \"ones\") {\n        /* All c_ij = 1 */\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < m; ++j) {\n                printf(\"1%c\", j == m - 1 ? '\\n' : ' ');\n            }\n        }\n    } else if (type == \"max\") {\n        /* All c_ij = max_c */\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < m; ++j) {\n                printf(\"%d%c\", max_c, j == m - 1 ? '\\n' : ' ');\n            }\n        }\n    } else if (type == \"corners\") {\n        /* c_ij = max_c at corners, 0 elsewhere */\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < m; ++j) {\n                int c = 0;\n                if ((i == 0 || i == n - 1) && (j == 0 || j == m - 1)) {\n                    c = max_c;\n                }\n                printf(\"%d%c\", c, j == m - 1 ? '\\n' : ' ');\n            }\n        }\n    } else if (type == \"gradient\") {\n        /* c_ij increases toward the south-east corner */\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < m; ++j) {\n                int c = (i + j) * max_c / (n + m - 2);\n                printf(\"%d%c\", c, j == m - 1 ? '\\n' : ' ');\n            }\n        }\n    } else if (type == \"center_peak\") {\n        /* c_ij maximal in center, decreasing toward edges */\n        double center_i = (n - 1) / 2.0;\n        double center_j = (m - 1) / 2.0;\n        double max_dist = sqrt(center_i * center_i + center_j * center_j);\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < m; ++j) {\n                double dist = sqrt((i - center_i) * (i - center_i) + (j - center_j) * (j - center_j));\n                int c = max_c - (int)(dist / max_dist * max_c);\n                printf(\"%d%c\", c, j == m - 1 ? '\\n' : ' ');\n            }\n        }\n    } else if (type == \"line_increase\") {\n        /* c_ij increases with i and j */\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < m; ++j) {\n                int c = ((i + 1) * (j + 1)) % (max_c + 1);\n                printf(\"%d%c\", c, j == m - 1 ? '\\n' : ' ');\n            }\n        }\n    } else if (type == \"sparse\") {\n        /* Random positions have c = max_c, rest are zeros */\n        int num_non_zero = rnd.next(1, n * m / 10); // Up to 10% non-zero\n        set<pair<int, int>> positions;\n        while ((int)positions.size() < num_non_zero) {\n            int i = rnd.next(0, n - 1);\n            int j = rnd.next(0, m - 1);\n            positions.insert(make_pair(i, j));\n        }\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < m; ++j) {\n                int c = positions.count(make_pair(i, j)) ? max_c : 0;\n                printf(\"%d%c\", c, j == m - 1 ? '\\n' : ' ');\n            }\n        }\n    } else {\n        fprintf(stderr, \"Unknown type: %s\\n\", type.c_str());\n        exit(1);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string type = opt<string>(\"type\", \"random\");\n    int max_c = opt<int>(\"max_c\", 100000);\n\n    printf(\"%d %d\\n\", n, m);\n\n    if (type == \"random\") {\n        /* Random c_ij values between 0 and max_c */\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < m; ++j) {\n                int c = rnd.next(0, max_c);\n                printf(\"%d%c\", c, j == m - 1 ? '\\n' : ' ');\n            }\n        }\n    } else if (type == \"zeros\") {\n        /* All c_ij = 0 */\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < m; ++j) {\n                printf(\"0%c\", j == m - 1 ? '\\n' : ' ');\n            }\n        }\n    } else if (type == \"ones\") {\n        /* All c_ij = 1 */\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < m; ++j) {\n                printf(\"1%c\", j == m - 1 ? '\\n' : ' ');\n            }\n        }\n    } else if (type == \"max\") {\n        /* All c_ij = max_c */\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < m; ++j) {\n                printf(\"%d%c\", max_c, j == m - 1 ? '\\n' : ' ');\n            }\n        }\n    } else if (type == \"corners\") {\n        /* c_ij = max_c at corners, 0 elsewhere */\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < m; ++j) {\n                int c = 0;\n                if ((i == 0 || i == n - 1) && (j == 0 || j == m - 1)) {\n                    c = max_c;\n                }\n                printf(\"%d%c\", c, j == m - 1 ? '\\n' : ' ');\n            }\n        }\n    } else if (type == \"gradient\") {\n        /* c_ij increases toward the south-east corner */\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < m; ++j) {\n                int c = (i + j) * max_c / (n + m - 2);\n                printf(\"%d%c\", c, j == m - 1 ? '\\n' : ' ');\n            }\n        }\n    } else if (type == \"center_peak\") {\n        /* c_ij maximal in center, decreasing toward edges */\n        double center_i = (n - 1) / 2.0;\n        double center_j = (m - 1) / 2.0;\n        double max_dist = sqrt(center_i * center_i + center_j * center_j);\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < m; ++j) {\n                double dist = sqrt((i - center_i) * (i - center_i) + (j - center_j) * (j - center_j));\n                int c = max_c - (int)(dist / max_dist * max_c);\n                printf(\"%d%c\", c, j == m - 1 ? '\\n' : ' ');\n            }\n        }\n    } else if (type == \"line_increase\") {\n        /* c_ij increases with i and j */\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < m; ++j) {\n                int c = ((i + 1) * (j + 1)) % (max_c + 1);\n                printf(\"%d%c\", c, j == m - 1 ? '\\n' : ' ');\n            }\n        }\n    } else if (type == \"sparse\") {\n        /* Random positions have c = max_c, rest are zeros */\n        int num_non_zero = rnd.next(1, n * m / 10); // Up to 10% non-zero\n        set<pair<int, int>> positions;\n        while ((int)positions.size() < num_non_zero) {\n            int i = rnd.next(0, n - 1);\n            int j = rnd.next(0, m - 1);\n            positions.insert(make_pair(i, j));\n        }\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < m; ++j) {\n                int c = positions.count(make_pair(i, j)) ? max_c : 0;\n                printf(\"%d%c\", c, j == m - 1 ? '\\n' : ' ');\n            }\n        }\n    } else {\n        fprintf(stderr, \"Unknown type: %s\\n\", type.c_str());\n        exit(1);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -m 1 -type zeros\n./gen -n 1 -m 1 -type ones\n./gen -n 1 -m 1 -type max\n./gen -n 1 -m 1 -type random\n\n./gen -n 2 -m 2 -type random\n./gen -n 2 -m 3 -type ones\n./gen -n 3 -m 2 -type max\n\n./gen -n 5 -m 5 -type random\n./gen -n 10 -m 10 -type random\n./gen -n 10 -m 10 -type gradient\n\n./gen -n 100 -m 100 -type random\n./gen -n 100 -m 100 -type zeros\n./gen -n 100 -m 100 -type ones\n\n./gen -n 1000 -m 1000 -type random\n./gen -n 1000 -m 1000 -type zeros\n./gen -n 1000 -m 1000 -type ones\n\n./gen -n 1000 -m 1000 -type max\n./gen -n 1000 -m 1000 -type corners\n./gen -n 1000 -m 1000 -type gradient\n\n./gen -n 1000 -m 1000 -type center_peak\n./gen -n 500 -m 500 -type center_peak\n./gen -n 500 -m 1000 -type line_increase\n./gen -n 1000 -m 500 -type line_increase\n\n./gen -n 1000 -m 1000 -type sparse\n./gen -n 1 -m 1000 -type zeros\n./gen -n 1 -m 1000 -type ones\n./gen -n 1000 -m 1 -type zeros\n./gen -n 1000 -m 1 -type ones\n\n./gen -n 1 -m 1000 -type random\n./gen -n 1000 -m 1 -type random\n./gen -n 1000 -m 1000 -type random -max_c 100000\n./gen -n 1000 -m 1000 -type random -max_c 1\n./gen -n 1000 -m 1000 -type random -max_c 0\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T19:48:04.177193",
        "total_tutorials": 3,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "201/C",
      "title": "C. Хрупкие мосты",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест2 секунды",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеВ первой строке содержится целое число n (2 ≤ n ≤ 105) — количество платформ на бонусном уровне. Вторая строка содержит (n - 1) целых чисел ai (1 ≤ ai ≤ 109, 1 ≤ i < n) — количество переходов от одного конца до другого, которое может выдержать мост между платформами i и i + 1.",
      "output_spec": "Выходные данныеВыведите единственное число — максимальное количество очков, которое можно набрать на бонусном уровне.Пожалуйста, не используйте спецификатор %lld для чтения или записи 64-битных чисел на С++. Рекомендуется использовать потоки cin, cout или спецификатор %I64d.",
      "sample_tests": "ПримерыВходные данныеСкопировать52 1 2 1Выходные данныеСкопировать5",
      "description": "C. Хрупкие мосты\n\nограничение по времени на тест2 секунды\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвыводstdout\n\nВходные данныеВ первой строке содержится целое число n (2 ≤ n ≤ 105) — количество платформ на бонусном уровне. Вторая строка содержит (n - 1) целых чисел ai (1 ≤ ai ≤ 109, 1 ≤ i < n) — количество переходов от одного конца до другого, которое может выдержать мост между платформами i и i + 1.\n\nВходные данные\n\nВыходные данныеВыведите единственное число — максимальное количество очков, которое можно набрать на бонусном уровне.Пожалуйста, не используйте спецификатор %lld для чтения или записи 64-битных чисел на С++. Рекомендуется использовать потоки cin, cout или спецификатор %I64d.\n\nВыходные данные\n\nВходные данныеСкопировать52 1 2 1Выходные данныеСкопировать5\n\nВходные данныеСкопировать52 1 2 1\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать5\n\nВыходные данныеСкопировать\n\nСкопировать\n\nПримечаниеОдин из вариантов получить 5 очков в примере — начав с платформы 3, последовательно переходить на платформы 4, 3, 2, 1 и 2. После этого единственным нерухнувшим мостом останется мост между платформами 4 и 5, однако этот мост слишком далек от платформы 2, на которой расположен герой.",
      "solutions": [
        {
          "title": "Codeforces Round #127 - Codeforces",
          "content": "Всем привет!Как многие из вас уже знают, сегодня в обоих дивизионах состоится Codeforces Round #127, пропускать который очень не рекомендуется ;)Оригинальные задачи для вас придумывали и готовили tourist и Romka. Мы старались сделать упор на идейную составляющую задач, поэтому надеемся, что вам придётся думать дольше, чем набирать код. Отдельное спасибо за помощь в подготовке контеста координатору Codeforces Gerald. Также благодарим Delinur за перевод условий и Alex_KPR за вычитку условий.Надеемся, что этот раунд будет для вас не просто очередным раундом на Codeforces, а принесёт вам новый опыт и новые знания. Авторам все задачи кажутся одинаково простыми, но мы всё-таки постарались расположить их в порядке убывания простоты :)Разбалловка в первом дивизионе: 1000-1000-1500-2000-2500. Разбалловка во втором дивизионе: 500-1000-2000-2000-2500.Успехов!UPD: Соревнование закончено, всем спасибо за участие. Надеемся, вам понравилось :)В первом дивизионе безоговорочную победу одержал rng_58, решив все пять задач за полтора часа! Решить все задачи за два часа больше не удалось никому.Победители в первом дивизионе (полные результаты): rng_58 peter50216 liympanda White_Bear havaliza Во втором дивизионе каждая задача была кем-то решена, но решить все задачи не удалось никому. Борьба оказалась очень упорной, а разрывы -- очень маленькими.Победители во втором дивизионе (полные результаты): Leewings snow_lotus 72VanVector_SevNTU Поздравляем победителей!UPD2: Опубликован разбор задач.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/4796",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 1493
        },
        {
          "title": "Codeforces Round #127 — разбор - Codeforces",
          "content": "Задача A(div 2) — ЛНПППредполагалось, что эту задачу можно решить, не читая её условия, а только глядя на примеры :)Найдём в заданной строке символ, который идёт в алфавите позже всех, обозначим его через z. Если этот символ встречается в строке p раз, то ответ — это строка a, состоящая из символа z, повторённого p раз.Почему это так? Из определения лексикографического сравнения и из того, что символ z — максимальный в строке, несложно понять, что если какая-то другая подпоследовательность b заданной строки лексикографически больше a, то строка b обязана иметь большую длину, чем a, и при этом a должна являться префиксом (началом) b. Однако строка b должна также быть палиндромом, поэтому последний её символ — обязательно z. В таком случае в строке b должно быть больше вхождений символа z, чем в исходной строке s, что невозможно, так как b --- подпоследовательность s.Кроме того, ограничение на длину строки было совсем небольшим, поэтому задачу можно было решить перебором всех подпоследовательностей строки. Для каждой из них нужно проверить, является ли она палиндромом, и из всех являющихся выбрать лексикографически наибольшую. Сложность такого решения составляет O(2n·n), где n — длина строки (в отличие от решения выше, сложность которого O(n)).Задача В(div 2) — Инновационно новая простая задачаОграничения в задаче были настолько малы, что проходило решение со сложностью O(m·kn). В описании каждой задачи достаточно перебрать все возможные подпоследовательности слов, являющиеся перестановками описания Лёшиной задачи, для каждой из них вычислить количество инверсий, и выбрать перестановку с минимальным количеством инверсий. Это можно сделать либо с помощью рекурсии, либо, например, с помощью необходимого количества вложенных циклов (от 1 до 4).Вот пример псевдокода для случая n = 4: w - массив слов задачи Лёши\ns - описание очередной задачи из архива\nbest = 100\nfor a = 1 to k do\n for b = 1 to k do\n for c = 1 to k do\n for d = 1 to k do\n if s[a] == w[1] and s[b] == w[2] and s[c] == w[3] and s[d] == w[4] then\n inversions = 0\n if a > b then inversions = inversions + 1\n if a > c then inversions = inversions + 1\n if a > d then inversions = inversions + 1\n if b > c then inversions = inversions + 1\n if b > d then inversions = inversions + 1\n if c > d then inversions = inversions + 1\n if inversions < best then\n best = inversionsВ конце нужно выбрать задачу с минимальным значением best и вывести ответ в соответствующем формате.Задача A(div 1)/C(div 2) — Чёткая симметрияИнтересно, что первоначально у авторов была идея не включать случай x = 3 в претесты. Представьте, сколько было бы в этом контесте сделано успешных взломов — при том, что из первых 43 решений по этой задаче ни одно претесты не прошло :)Заметим, что ответ n — всегда нечётное число. Действительно, если n чётно, то две центральные строки матрицы A обязаны содержать только нули — в противном случае найдутся две соседние клетки, содержащие единицы. Аналогичное требование относится и к двум центральным столбцам матрицы A. Заменив две центральные строки на одну и два центральных столбца на один, при этом оставив в них нули, получим матрицу с такой же остротой, но со стороной на единицу меньше.Заметим, что острота матрицы со стороной n не может превысить . Несложно убедиться, что на квадратное поле со стороной n можно выложить \"доминошек\" 1 на 2 так, чтобы \"доминошки\" не пересекались (иными словами, все клетки, кроме одной, можно разбить на пары так, что клетки в каждой паре имеют общую сторону). Тогда в соответствующей матрице под клетками, покрытыми одной \"доминошкой\", может располагаться не более одной единицы. Значит, общее количество единиц не превышает .Заметим, что матрица со стороной n и остротой при нечётном n существует. Раскрасим все клетки матрицы в шахматном порядке и в чёрные клетки поставим единицы, а в белые — нули. Несложно убедиться, что такая матрица является и чёткой, и симметричной, и при этом имеет остроту ровно .Интуитивно кажется, что раз существует матрица с остротой , то существует матрица и с любой меньшей остротой. Это верно всегда, кроме одного-единственного случая — не существует матрицы со стороной 3 и остротой 3, хотя и существует матрица со стороной 3 и остротой 5.Покажем, что утверждение выше верно при нечётных n ≥ 5. Построим матрицу с остротой , как показано выше, и будем постепенно превращать единицы в нули, уменьшая остроту. Клетки с единицами в матрице бывают трёх типов.Первый тип — центральная клетка. Она ровно одна, при этом можно превратить число в ней в ноль, и матрица не перестанет удовлетворять условию задачи.Второй тип — клетки в центральной строке и в центральном столбце (кроме центральной клетки). Такие клетки из условия симметричности разбиваются на пары — если мы заменяем значение в одной из них на ноль, мы обязаны также заменить на ноль значение в парной ей клетке.Третий тип — все остальные клетки. Из условия симметричности они разбиваются на четвёрки — если мы заменяем значение в некоторой клетке третьего типа на ноль, мы должны заменить на ноль значения во всех клетках той же четвёрки.Теперь для получения требуемой остроты x будем действовать жадно. Будем заменять единицы на нули в клетках третьего типа, делая это в четырёх клетках сразу, до тех пор, пока текущая острота превышает x как минимум на 4 и ещё есть клетки третьего типа с единицами. После этого начнём убирать клетки второго типа по парам, пока текущая острота превышает x хотя бы на 2. К этому моменту острота матрицы равна либо x, либо x + 1. Если она равна x + 1, поставим ноль в центральной клетке и получим матрицу с остротой x. Несложно проверить, что мы сможем получить матрицу любой остроты, действуя по этому жадному алгоритму.Почему такие же рассуждения не работают при n = 3? Потому что в матрице с остротой 5, полученной из шахматной раскраски, отсутствуют клетки второго типа. При n ≥ 5 в такой матрице присутствуют клетки всех типов, что и является залогом успеха. Ответы для x ≤ 5 лучше найти вручную, но аккуратно — например, многие участники решили, что при x = 2 ответ 5, а не 3.Задача В(div 1)/D(div 2) — Угадай автомобиль!Нам нужно найти такие x и y, при которых величина принимает минимальное возможное значение. Эту величину можно преобразовать к виду , и заметить, что поскольку левая часть не зависит от y, а правая от x, то можно минимизировать каждую из частей по отдельности. Рассмотрим, как минимизировать часть , вторая минимизируется аналогично. Поскольку выражение в скобках не зависит от j, эту часть можно переписать в виде , где . Теперь достаточно просто перебрать все возможные значения x, и вычислить для каждого из них искомую величину, после чего выбрать x, для которого это значение минимально. Точно так же находится оптимальное значение y.Итоговая сложность решения — O(n·m + n2 + m2).В силу выпуклости целевой функции возможны и другие подходы к решению задачи, например, градиентый спуск либо аналитический метод (вычисление производных).Главный действующий герой задачи — Ra16bit.Задача С(div 1)/E(div 2) — Хрупкие мостыЭту задачу можно решить несколькими способами, в разборе представлен один из них.Для любого решения полезно заметить следующий факт. Допустим, искомый путь начинается на платформе i и заканчивается на платформе j (i ≤ j, если это не так, можно поменять начало и конец пути местами). Тогда все мосты, находящиеся между платформами i и j, будут пройдены в этом пути нечётное число раз, а все остальные мосты — чётное число раз.Давайте найдём максимальную длину пути с концами на платформах i и j. Для этого для всех платформ найдём вспомогательные величины: lefti — максимальная длина пути, начинающегося и заканчивающегося на платформе i и при этом проходящего только по мостам левее платформы i; rightj — аналогично для мостов правее платформы j. Также для каждого моста определим oddi — наибольшее нечётное число, не превосходящее ai, и для каждой платформы определим sumOddi — сумму oddj по всем мостам левее платформы i.Тогда максимальная длина пути с концами на платформах i и j (i ≤ j) равна lefti + rightj + (sumOddj - sumOddi) или, что то же самое, (rightj + sumOddj) + (lefti - sumOddi).Теперь мы можем найти пару (i, j), для которых эта величина наибольшая, за линейное время. Переберём j. Из формулы очевидно, что нужно найти такое i ≤ j, что (lefti - sumOddi) максимально. Если перебирать j от 1 к n, то можно хранить текущее максимальное значение этой величины для всех i ≤ j и пересчитывать его при переходе к следующему j, сравнив (leftj - sumOddj) с текущим максимумом и, возможно, этот максимум обновив. Таким образом, для каждого j нужно проверять не все значения i ≤ j, а только одно.Осталось показать, как быстро искать все lefti (все rightj ищутся аналогично). Понятно, что left1 = 0, далее будем считать lefti, используя lefti - 1. Заметим, что если ai - 1 = 1, то lefti = 0, так как после перехода по мосту на платформу (i - 1) этот мост рухнет и вернуться на платформу i уже будет невозможно. Если же ai - 1 > 1, то lefti = lefti - 1 + eveni - 1, где eveni - 1 — наибольшее чётное число, не превосходящее ai - 1. Действительно, можно перейти по мосту на платформу (i - 1), проделать путь, соответствующий lefti - 1, а потом ходить по мосту между платформами (i - 1) и i, пока лимит на количество переходов не станет меньше 2 (при этом закончить нужно на платформе i).Таким образом, общая сложность этого решения — O(n).Задача D(div 1) — Инновационно новая задачаПервое решение, которое приходит на ум — рекуррентное соотношение f[i][j] =  (минимальное возможное количество инверсий, если среди первых j слов встречается перестановка слов, входящих в маску i). В таком решении параметр j изменяется от 0 до 500000, i — от 0 до 215 - 1, а пересчёт значений происходит за O(1) (либо используем очередное слово, либо нет). Это слишком много.Воспользуемся стандартным приёмом: перенесём значение соотношения в параметр, а один из параметров сделаем значением. Это можно сделать не для любого рекуррентного, но для этого как раз можно :)Понятно, что при фиксированном подмножестве слов и количестве инверсий оптимально выбрать самые ранние вхождения этих слов, которые дают такое количество инверсий. Пусть f[i][j] =  (минимальное число z такое, что среди первых z слов найдётся перестановка слов из маски i, содержащая в точности j инверсий). База — f[0][0] = 0, f[0][j] = ∞ для j > 0. Пересчёт значений происходит следующим образом: перебираем слово q из маски i, которое было последним. Зная это слово, и количество инверсий j, легко вычислить количество инверсий j', которое было без этого слова — это j минус количество слов в маске, больших q (по номеру в описании Лёшиной задачи). Пусть p = f[i^(1«q)][j']. Тогда в качестве очередного возможного значения для f[i][j] нужно рассмотреть индекс p2, равный позиции следующего вхождения слова q после позиции p. Для быстрого поиска таких значений необходимо заранее для каждой задачи из архива посчитать массив next[500010][15] такой, что next[i][j] = (минимальный индекс k > i такой, что k-е слово в описании текущей задачи равно j-му слову в описании задачи Лёши). Такой массив несложно посчитать за один проход справа налево.Суммарное количество операций можно вычислить по формуле m·(k·n + 2n·Cn2·n), где m — количество задач в архиве, k — количество слов в описании одной задачи, n — количество слов в описании задачи Лёши. При заданных ограничениях эта величина составляла около 200 миллионов, и авторские решения (включая решение на Java) работали не более двух секунд. TL был выставлен довольно-таки лояльно, 5 секунд.Главные действующие герои задач D(div 1) и B(div 2) — Chmel_Tolstiy и ivan.metelsky.Задача E(div 1) — Насквозь бюрократическая организацияДавайте представим, что у нас в распоряжении есть функция maxN(m, k), которая по заданным m и k возвращает максимальное значение n такое, что задачу для n людей и m пустых строчек в бланке можно решить за k запросов. Тогда можно применить бинарный поиск по ответу — количеству запросов k.Допустим, мы сделали какие-то k запросов. Сопоставим каждому из n человек строку из k бит, где i-ый бит равен единице, если этот человек был указан в i-ом запросе, и равен нулю в противном случае. Заметим, что мы сможем определить точную дату приёма для каждого человека в том и только в том случае, если всем n людям соответствуют попарно различные k-битовые строки. На самом деле, если двум людям соответствуют одинаковые строки, то они могли бы поменяться датами между собой и ответы на запросы не изменились бы. Если же всем людям соответствуют разные строки, для каждой даты можно определить, кто именно записан на эту дату, рассмотрев множество запросов, в ответах на которые эта дата фигурирует, и найдя человека, который указан ровно в том же множестве запросов.Ограничение в m пустых строчек в бланке означает, что в каждой из k позиций в строках суммарное число единиц по всем n числам не должно превышать m. Таким образом, функция maxN(m, k) должна возвращать максимальную мощность множества различных k-битовых строк, для которых выполняется это ограничение. Давайте ослабим это ограничение: будем искать множество, в котором в сумме по всем разрядам количество единиц не превышает k·m. Как мы докажем после, ответ от этого не изменится.С таким ослабленным ограничением задача решается простым жадным алгоритмом. Логично, что сначала лучше брать те строки, в которых меньше единиц. Будем перебирать количество единиц i в строке от 0 до k, а также хранить переменную t, обозначающую количество единиц, которое ещё можно поставить (изначально она равна k·m). Тогда на i-ом шаге максимально можно взять чисел с i единицами. Добавим p к ответу, а от t отнимем p·i. Отметим, что значения Cki нужно считать аккуратно — они могут оказаться слишком большими, и нужно не допустить переполнения.Можно показать, что сложность такого решения на один тест составляет не более O(log2n).Осталось доказать необходимое утверждение. Идея доказательства ниже принадлежит rng_58 (авторское было заметно сложнее).Решим задачу жадным алгоритмом с ограничением в k·m на общее число единиц. Полученное множество может не удовлетворять ограничению в m единиц на каждый разряд — тогда в некоторых разрядах количество единиц больше m, а в некоторых меньше m. Возьмём некоторый разряд X, в котором более m единиц, и некоторый разряд Y, в котором менее m единиц. Найдём строки, в которых стоит 1 в X и 0 в Y (допустим, таких строк x) и строки, в которых стоит 0 в X и 1 в Y (допустим, таких строк y). Понятно, что x > y. В каждой из x строк мы можем попробовать поставить 0 в X и 1 в Y — тогда полученная строка может либо остаться уникальной, либо совпасть с какой-то из y строк (но ровно одной). А поскольку x > y, точно найдётся одна из x строк такая, что в ней можно поменять местами цифры в разрядах X и Y и все строки останутся различными. Сделаем это. Теперь в разряде X стало на одну единицу меньше, а в разряде Y — на одну единицу больше. Это значит, что суммарное число лишних единиц в разрядах уменьшилось (т.к. в Y единиц не стало больше m). Таким образом, повторяя эту операцию необходимое число раз, мы сможем добиться того, чтобы в каждом разряде было не более m единиц.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/4808",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 15108
        },
        {
          "title": "Codeforces Round #127 — разбор - Codeforces",
          "content": "Задача A(div 2) — ЛНПППредполагалось, что эту задачу можно решить, не читая её условия, а только глядя на примеры :)Найдём в заданной строке символ, который идёт в алфавите позже всех, обозначим его через z. Если этот символ встречается в строке p раз, то ответ — это строка a, состоящая из символа z, повторённого p раз.Почему это так? Из определения лексикографического сравнения и из того, что символ z — максимальный в строке, несложно понять, что если какая-то другая подпоследовательность b заданной строки лексикографически больше a, то строка b обязана иметь большую длину, чем a, и при этом a должна являться префиксом (началом) b. Однако строка b должна также быть палиндромом, поэтому последний её символ — обязательно z. В таком случае в строке b должно быть больше вхождений символа z, чем в исходной строке s, что невозможно, так как b --- подпоследовательность s.Кроме того, ограничение на длину строки было совсем небольшим, поэтому задачу можно было решить перебором всех подпоследовательностей строки. Для каждой из них нужно проверить, является ли она палиндромом, и из всех являющихся выбрать лексикографически наибольшую. Сложность такого решения составляет O(2n·n), где n — длина строки (в отличие от решения выше, сложность которого O(n)).Задача В(div 2) — Инновационно новая простая задачаОграничения в задаче были настолько малы, что проходило решение со сложностью O(m·kn). В описании каждой задачи достаточно перебрать все возможные подпоследовательности слов, являющиеся перестановками описания Лёшиной задачи, для каждой из них вычислить количество инверсий, и выбрать перестановку с минимальным количеством инверсий. Это можно сделать либо с помощью рекурсии, либо, например, с помощью необходимого количества вложенных циклов (от 1 до 4).Вот пример псевдокода для случая n = 4: w - массив слов задачи Лёши\ns - описание очередной задачи из архива\nbest = 100\nfor a = 1 to k do\n for b = 1 to k do\n for c = 1 to k do\n for d = 1 to k do\n if s[a] == w[1] and s[b] == w[2] and s[c] == w[3] and s[d] == w[4] then\n inversions = 0\n if a > b then inversions = inversions + 1\n if a > c then inversions = inversions + 1\n if a > d then inversions = inversions + 1\n if b > c then inversions = inversions + 1\n if b > d then inversions = inversions + 1\n if c > d then inversions = inversions + 1\n if inversions < best then\n best = inversionsВ конце нужно выбрать задачу с минимальным значением best и вывести ответ в соответствующем формате.Задача A(div 1)/C(div 2) — Чёткая симметрияИнтересно, что первоначально у авторов была идея не включать случай x = 3 в претесты. Представьте, сколько было бы в этом контесте сделано успешных взломов — при том, что из первых 43 решений по этой задаче ни одно претесты не прошло :)Заметим, что ответ n — всегда нечётное число. Действительно, если n чётно, то две центральные строки матрицы A обязаны содержать только нули — в противном случае найдутся две соседние клетки, содержащие единицы. Аналогичное требование относится и к двум центральным столбцам матрицы A. Заменив две центральные строки на одну и два центральных столбца на один, при этом оставив в них нули, получим матрицу с такой же остротой, но со стороной на единицу меньше.Заметим, что острота матрицы со стороной n не может превысить . Несложно убедиться, что на квадратное поле со стороной n можно выложить \"доминошек\" 1 на 2 так, чтобы \"доминошки\" не пересекались (иными словами, все клетки, кроме одной, можно разбить на пары так, что клетки в каждой паре имеют общую сторону). Тогда в соответствующей матрице под клетками, покрытыми одной \"доминошкой\", может располагаться не более одной единицы. Значит, общее количество единиц не превышает .Заметим, что матрица со стороной n и остротой при нечётном n существует. Раскрасим все клетки матрицы в шахматном порядке и в чёрные клетки поставим единицы, а в белые — нули. Несложно убедиться, что такая матрица является и чёткой, и симметричной, и при этом имеет остроту ровно .Интуитивно кажется, что раз существует матрица с остротой , то существует матрица и с любой меньшей остротой. Это верно всегда, кроме одного-единственного случая — не существует матрицы со стороной 3 и остротой 3, хотя и существует матрица со стороной 3 и остротой 5.Покажем, что утверждение выше верно при нечётных n ≥ 5. Построим матрицу с остротой , как показано выше, и будем постепенно превращать единицы в нули, уменьшая остроту. Клетки с единицами в матрице бывают трёх типов.Первый тип — центральная клетка. Она ровно одна, при этом можно превратить число в ней в ноль, и матрица не перестанет удовлетворять условию задачи.Второй тип — клетки в центральной строке и в центральном столбце (кроме центральной клетки). Такие клетки из условия симметричности разбиваются на пары — если мы заменяем значение в одной из них на ноль, мы обязаны также заменить на ноль значение в парной ей клетке.Третий тип — все остальные клетки. Из условия симметричности они разбиваются на четвёрки — если мы заменяем значение в некоторой клетке третьего типа на ноль, мы должны заменить на ноль значения во всех клетках той же четвёрки.Теперь для получения требуемой остроты x будем действовать жадно. Будем заменять единицы на нули в клетках третьего типа, делая это в четырёх клетках сразу, до тех пор, пока текущая острота превышает x как минимум на 4 и ещё есть клетки третьего типа с единицами. После этого начнём убирать клетки второго типа по парам, пока текущая острота превышает x хотя бы на 2. К этому моменту острота матрицы равна либо x, либо x + 1. Если она равна x + 1, поставим ноль в центральной клетке и получим матрицу с остротой x. Несложно проверить, что мы сможем получить матрицу любой остроты, действуя по этому жадному алгоритму.Почему такие же рассуждения не работают при n = 3? Потому что в матрице с остротой 5, полученной из шахматной раскраски, отсутствуют клетки второго типа. При n ≥ 5 в такой матрице присутствуют клетки всех типов, что и является залогом успеха. Ответы для x ≤ 5 лучше найти вручную, но аккуратно — например, многие участники решили, что при x = 2 ответ 5, а не 3.Задача В(div 1)/D(div 2) — Угадай автомобиль!Нам нужно найти такие x и y, при которых величина принимает минимальное возможное значение. Эту величину можно преобразовать к виду , и заметить, что поскольку левая часть не зависит от y, а правая от x, то можно минимизировать каждую из частей по отдельности. Рассмотрим, как минимизировать часть , вторая минимизируется аналогично. Поскольку выражение в скобках не зависит от j, эту часть можно переписать в виде , где . Теперь достаточно просто перебрать все возможные значения x, и вычислить для каждого из них искомую величину, после чего выбрать x, для которого это значение минимально. Точно так же находится оптимальное значение y.Итоговая сложность решения — O(n·m + n2 + m2).В силу выпуклости целевой функции возможны и другие подходы к решению задачи, например, градиентый спуск либо аналитический метод (вычисление производных).Главный действующий герой задачи — Ra16bit.Задача С(div 1)/E(div 2) — Хрупкие мостыЭту задачу можно решить несколькими способами, в разборе представлен один из них.Для любого решения полезно заметить следующий факт. Допустим, искомый путь начинается на платформе i и заканчивается на платформе j (i ≤ j, если это не так, можно поменять начало и конец пути местами). Тогда все мосты, находящиеся между платформами i и j, будут пройдены в этом пути нечётное число раз, а все остальные мосты — чётное число раз.Давайте найдём максимальную длину пути с концами на платформах i и j. Для этого для всех платформ найдём вспомогательные величины: lefti — максимальная длина пути, начинающегося и заканчивающегося на платформе i и при этом проходящего только по мостам левее платформы i; rightj — аналогично для мостов правее платформы j. Также для каждого моста определим oddi — наибольшее нечётное число, не превосходящее ai, и для каждой платформы определим sumOddi — сумму oddj по всем мостам левее платформы i.Тогда максимальная длина пути с концами на платформах i и j (i ≤ j) равна lefti + rightj + (sumOddj - sumOddi) или, что то же самое, (rightj + sumOddj) + (lefti - sumOddi).Теперь мы можем найти пару (i, j), для которых эта величина наибольшая, за линейное время. Переберём j. Из формулы очевидно, что нужно найти такое i ≤ j, что (lefti - sumOddi) максимально. Если перебирать j от 1 к n, то можно хранить текущее максимальное значение этой величины для всех i ≤ j и пересчитывать его при переходе к следующему j, сравнив (leftj - sumOddj) с текущим максимумом и, возможно, этот максимум обновив. Таким образом, для каждого j нужно проверять не все значения i ≤ j, а только одно.Осталось показать, как быстро искать все lefti (все rightj ищутся аналогично). Понятно, что left1 = 0, далее будем считать lefti, используя lefti - 1. Заметим, что если ai - 1 = 1, то lefti = 0, так как после перехода по мосту на платформу (i - 1) этот мост рухнет и вернуться на платформу i уже будет невозможно. Если же ai - 1 > 1, то lefti = lefti - 1 + eveni - 1, где eveni - 1 — наибольшее чётное число, не превосходящее ai - 1. Действительно, можно перейти по мосту на платформу (i - 1), проделать путь, соответствующий lefti - 1, а потом ходить по мосту между платформами (i - 1) и i, пока лимит на количество переходов не станет меньше 2 (при этом закончить нужно на платформе i).Таким образом, общая сложность этого решения — O(n).Задача D(div 1) — Инновационно новая задачаПервое решение, которое приходит на ум — рекуррентное соотношение f[i][j] =  (минимальное возможное количество инверсий, если среди первых j слов встречается перестановка слов, входящих в маску i). В таком решении параметр j изменяется от 0 до 500000, i — от 0 до 215 - 1, а пересчёт значений происходит за O(1) (либо используем очередное слово, либо нет). Это слишком много.Воспользуемся стандартным приёмом: перенесём значение соотношения в параметр, а один из параметров сделаем значением. Это можно сделать не для любого рекуррентного, но для этого как раз можно :)Понятно, что при фиксированном подмножестве слов и количестве инверсий оптимально выбрать самые ранние вхождения этих слов, которые дают такое количество инверсий. Пусть f[i][j] =  (минимальное число z такое, что среди первых z слов найдётся перестановка слов из маски i, содержащая в точности j инверсий). База — f[0][0] = 0, f[0][j] = ∞ для j > 0. Пересчёт значений происходит следующим образом: перебираем слово q из маски i, которое было последним. Зная это слово, и количество инверсий j, легко вычислить количество инверсий j', которое было без этого слова — это j минус количество слов в маске, больших q (по номеру в описании Лёшиной задачи). Пусть p = f[i^(1«q)][j']. Тогда в качестве очередного возможного значения для f[i][j] нужно рассмотреть индекс p2, равный позиции следующего вхождения слова q после позиции p. Для быстрого поиска таких значений необходимо заранее для каждой задачи из архива посчитать массив next[500010][15] такой, что next[i][j] = (минимальный индекс k > i такой, что k-е слово в описании текущей задачи равно j-му слову в описании задачи Лёши). Такой массив несложно посчитать за один проход справа налево.Суммарное количество операций можно вычислить по формуле m·(k·n + 2n·Cn2·n), где m — количество задач в архиве, k — количество слов в описании одной задачи, n — количество слов в описании задачи Лёши. При заданных ограничениях эта величина составляла около 200 миллионов, и авторские решения (включая решение на Java) работали не более двух секунд. TL был выставлен довольно-таки лояльно, 5 секунд.Главные действующие герои задач D(div 1) и B(div 2) — Chmel_Tolstiy и ivan.metelsky.Задача E(div 1) — Насквозь бюрократическая организацияДавайте представим, что у нас в распоряжении есть функция maxN(m, k), которая по заданным m и k возвращает максимальное значение n такое, что задачу для n людей и m пустых строчек в бланке можно решить за k запросов. Тогда можно применить бинарный поиск по ответу — количеству запросов k.Допустим, мы сделали какие-то k запросов. Сопоставим каждому из n человек строку из k бит, где i-ый бит равен единице, если этот человек был указан в i-ом запросе, и равен нулю в противном случае. Заметим, что мы сможем определить точную дату приёма для каждого человека в том и только в том случае, если всем n людям соответствуют попарно различные k-битовые строки. На самом деле, если двум людям соответствуют одинаковые строки, то они могли бы поменяться датами между собой и ответы на запросы не изменились бы. Если же всем людям соответствуют разные строки, для каждой даты можно определить, кто именно записан на эту дату, рассмотрев множество запросов, в ответах на которые эта дата фигурирует, и найдя человека, который указан ровно в том же множестве запросов.Ограничение в m пустых строчек в бланке означает, что в каждой из k позиций в строках суммарное число единиц по всем n числам не должно превышать m. Таким образом, функция maxN(m, k) должна возвращать максимальную мощность множества различных k-битовых строк, для которых выполняется это ограничение. Давайте ослабим это ограничение: будем искать множество, в котором в сумме по всем разрядам количество единиц не превышает k·m. Как мы докажем после, ответ от этого не изменится.С таким ослабленным ограничением задача решается простым жадным алгоритмом. Логично, что сначала лучше брать те строки, в которых меньше единиц. Будем перебирать количество единиц i в строке от 0 до k, а также хранить переменную t, обозначающую количество единиц, которое ещё можно поставить (изначально она равна k·m). Тогда на i-ом шаге максимально можно взять чисел с i единицами. Добавим p к ответу, а от t отнимем p·i. Отметим, что значения Cki нужно считать аккуратно — они могут оказаться слишком большими, и нужно не допустить переполнения.Можно показать, что сложность такого решения на один тест составляет не более O(log2n).Осталось доказать необходимое утверждение. Идея доказательства ниже принадлежит rng_58 (авторское было заметно сложнее).Решим задачу жадным алгоритмом с ограничением в k·m на общее число единиц. Полученное множество может не удовлетворять ограничению в m единиц на каждый разряд — тогда в некоторых разрядах количество единиц больше m, а в некоторых меньше m. Возьмём некоторый разряд X, в котором более m единиц, и некоторый разряд Y, в котором менее m единиц. Найдём строки, в которых стоит 1 в X и 0 в Y (допустим, таких строк x) и строки, в которых стоит 0 в X и 1 в Y (допустим, таких строк y). Понятно, что x > y. В каждой из x строк мы можем попробовать поставить 0 в X и 1 в Y — тогда полученная строка может либо остаться уникальной, либо совпасть с какой-то из y строк (но ровно одной). А поскольку x > y, точно найдётся одна из x строк такая, что в ней можно поменять местами цифры в разрядах X и Y и все строки останутся различными. Сделаем это. Теперь в разряде X стало на одну единицу меньше, а в разряде Y — на одну единицу больше. Это значит, что суммарное число лишних единиц в разрядах уменьшилось (т.к. в Y единиц не стало больше m). Таким образом, повторяя эту операцию необходимое число раз, мы сможем добиться того, чтобы в каждом разряде было не более m единиц.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/4808",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 15108
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #127 - Codeforces - Code 1",
          "code": ">популярная\n>-37",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4796",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #127 - Codeforces - Code 2",
          "code": ">популярная\n>-37",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4796",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #127 - Codeforces - Code 3",
          "code": "1 0 0\n0 1 0\n1 0 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4796",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #127 - Codeforces - Code 4",
          "code": "1 0 0\n0 1 0\n1 0 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4796",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #127 - Codeforces - Code 5",
          "code": "10001\n00000\n10001\n00000\n10001",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4796",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #127 - Codeforces - Code 6",
          "code": "10001\n00000\n10001\n00000\n10001",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4796",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #127 - Codeforces - Code 7",
          "code": "0 0 1 0 0\n0 0 0 0 0\n0 0 1 0 0\n0 0 0 0 0\n0 0 1 0 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4796",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #127 - Codeforces - Code 8",
          "code": "0 0 1 0 0\n0 0 0 0 0\n0 0 1 0 0\n0 0 0 0 0\n0 0 1 0 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4796",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #127 - Codeforces - Code 9",
          "code": "0 1 0\n0 0 0\n0 1 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4796",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #127 - Codeforces - Code 10",
          "code": "0 1 0\n0 0 0\n0 1 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4796",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #127 - Codeforces - Code 11",
          "code": "0 1 0\n0 0 0\n0 1 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4796",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #127 - Codeforces - Code 12",
          "code": "0 1 0\n0 0 0\n0 1 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4796",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #127 - Codeforces - Code 13",
          "code": "int n;\ncin >> n;\nif (n == 3)\n{\n  cout << 5;\n  return 0;\n}\nfor (int i = 1;; i += 2)\n  if ((i*i+1)/2>=n)\n  {\n    cout << i;\n    return 0;\n  }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4796",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #127 - Codeforces - Code 14",
          "code": "int n;\ncin >> n;\nif (n == 3)\n{\n  cout << 5;\n  return 0;\n}\nfor (int i = 1;; i += 2)\n  if ((i*i+1)/2>=n)\n  {\n    cout << i;\n    return 0;\n  }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4796",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #127 — разбор - Codeforces - Code 1",
          "code": "w - массив слов задачи Лёши\ns - описание очередной задачи из архива\nbest = 100\nfor a = 1 to k do\n    for b = 1 to k do\n        for c = 1 to k do\n            for d = 1 to k do\n                if s[a] == w[1] and s[b] == w[2] and s[c] == w[3] and s[d] == w[4] then\n                    inversions = 0\n                    if a > b then inversions = inversions + 1\n                    if a > c then inversions = inversions + 1\n                    if a > d then inversions = inversions + 1\n                    if b > c then inversions = inversions + 1\n                    if b > d then inversions = inversions + 1\n                    if c > d then inversions = inversions + 1\n                    if inversions < best then\n                        best = inversions",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4808",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #127 — разбор - Codeforces - Code 2",
          "code": "w - массив слов задачи Лёши\ns - описание очередной задачи из архива\nbest = 100\nfor a = 1 to k do\n    for b = 1 to k do\n        for c = 1 to k do\n            for d = 1 to k do\n                if s[a] == w[1] and s[b] == w[2] and s[c] == w[3] and s[d] == w[4] then\n                    inversions = 0\n                    if a > b then inversions = inversions + 1\n                    if a > c then inversions = inversions + 1\n                    if a > d then inversions = inversions + 1\n                    if b > c then inversions = inversions + 1\n                    if b > d then inversions = inversions + 1\n                    if c > d then inversions = inversions + 1\n                    if inversions < best then\n                        best = inversions",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4808",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #127 — разбор - Codeforces - Code 3",
          "code": "10 b c a b a d d d a a",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4808",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #127 — разбор - Codeforces - Code 4",
          "code": "REP(mask,(1<<15)) REP(i,15) for(j=i;j<15;j++) if(mask&(1<<j)) cost[mask][i]++;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4808",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #127 — разбор - Codeforces - Code 5",
          "code": "long sortAndCountInv(int []a, int l, int r) {\n   if (r - l <= 1) return 0;\n   int m = (l + r)  / 2;\n   long L = sortAndCountInv(a, l, m);\n   long R = sortAndCountInv(a, m + 1, r);\n   long M = 0; \n   int []t = a.clone();\n   int at = 0;\n   for (int i = 0, j = m + 1; i <= m && j <=r; ) {\n       if (t[i] > t[j])  { // если этот элемент больше элемента справа, то значит ( так как левая часть уже отсортирована) и все остальные элементы слева больше, значит, к числу инверсий добавим (m - i) \n        M += m -i; \n        a[at++] = t[j++];\n      } \n      else  a[at++] = t[i++];             \n   }\n   while (i <= m) a[at++] = t[i++];\n   while(j <= r) a[at++]=t[j++];\n   return L + M + R;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4808",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #127 — разбор - Codeforces - Code 6",
          "code": "long sortAndCountInv(int []a, int l, int r) {\n   if (r - l <= 1) return 0;\n   int m = (l + r)  / 2;\n   long L = sortAndCountInv(a, l, m);\n   long R = sortAndCountInv(a, m + 1, r);\n   long M = 0; \n   int []t = a.clone();\n   int at = 0;\n   for (int i = 0, j = m + 1; i <= m && j <=r; ) {\n       if (t[i] > t[j])  { // если этот элемент больше элемента справа, то значит ( так как левая часть уже отсортирована) и все остальные элементы слева больше, значит, к числу инверсий добавим (m - i) \n        M += m -i; \n        a[at++] = t[j++];\n      } \n      else  a[at++] = t[i++];             \n   }\n   while (i <= m) a[at++] = t[i++];\n   while(j <= r) a[at++]=t[j++];\n   return L + M + R;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4808",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #127 — разбор - Codeforces - Code 1",
          "code": "w - массив слов задачи Лёши\ns - описание очередной задачи из архива\nbest = 100\nfor a = 1 to k do\n    for b = 1 to k do\n        for c = 1 to k do\n            for d = 1 to k do\n                if s[a] == w[1] and s[b] == w[2] and s[c] == w[3] and s[d] == w[4] then\n                    inversions = 0\n                    if a > b then inversions = inversions + 1\n                    if a > c then inversions = inversions + 1\n                    if a > d then inversions = inversions + 1\n                    if b > c then inversions = inversions + 1\n                    if b > d then inversions = inversions + 1\n                    if c > d then inversions = inversions + 1\n                    if inversions < best then\n                        best = inversions",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4808",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #127 — разбор - Codeforces - Code 2",
          "code": "w - массив слов задачи Лёши\ns - описание очередной задачи из архива\nbest = 100\nfor a = 1 to k do\n    for b = 1 to k do\n        for c = 1 to k do\n            for d = 1 to k do\n                if s[a] == w[1] and s[b] == w[2] and s[c] == w[3] and s[d] == w[4] then\n                    inversions = 0\n                    if a > b then inversions = inversions + 1\n                    if a > c then inversions = inversions + 1\n                    if a > d then inversions = inversions + 1\n                    if b > c then inversions = inversions + 1\n                    if b > d then inversions = inversions + 1\n                    if c > d then inversions = inversions + 1\n                    if inversions < best then\n                        best = inversions",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4808",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #127 — разбор - Codeforces - Code 3",
          "code": "10 b c a b a d d d a a",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4808",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #127 — разбор - Codeforces - Code 4",
          "code": "REP(mask,(1<<15)) REP(i,15) for(j=i;j<15;j++) if(mask&(1<<j)) cost[mask][i]++;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4808",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #127 — разбор - Codeforces - Code 5",
          "code": "long sortAndCountInv(int []a, int l, int r) {\n   if (r - l <= 1) return 0;\n   int m = (l + r)  / 2;\n   long L = sortAndCountInv(a, l, m);\n   long R = sortAndCountInv(a, m + 1, r);\n   long M = 0; \n   int []t = a.clone();\n   int at = 0;\n   for (int i = 0, j = m + 1; i <= m && j <=r; ) {\n       if (t[i] > t[j])  { // если этот элемент больше элемента справа, то значит ( так как левая часть уже отсортирована) и все остальные элементы слева больше, значит, к числу инверсий добавим (m - i) \n        M += m -i; \n        a[at++] = t[j++];\n      } \n      else  a[at++] = t[i++];             \n   }\n   while (i <= m) a[at++] = t[i++];\n   while(j <= r) a[at++]=t[j++];\n   return L + M + R;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4808",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #127 — разбор - Codeforces - Code 6",
          "code": "long sortAndCountInv(int []a, int l, int r) {\n   if (r - l <= 1) return 0;\n   int m = (l + r)  / 2;\n   long L = sortAndCountInv(a, l, m);\n   long R = sortAndCountInv(a, m + 1, r);\n   long M = 0; \n   int []t = a.clone();\n   int at = 0;\n   for (int i = 0, j = m + 1; i <= m && j <=r; ) {\n       if (t[i] > t[j])  { // если этот элемент больше элемента справа, то значит ( так как левая часть уже отсортирована) и все остальные элементы слева больше, значит, к числу инверсий добавим (m - i) \n        M += m -i; \n        a[at++] = t[j++];\n      } \n      else  a[at++] = t[i++];             \n   }\n   while (i <= m) a[at++] = t[i++];\n   while(j <= r) a[at++]=t[j++];\n   return L + M + R;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4808",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(2, 100000, \"n\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n - 1, 1, 1000000000, \"a\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(2, 100000, \"n\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n - 1, 1, 1000000000, \"a\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(2, 100000, \"n\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n - 1, 1, 1000000000, \"a\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> capacities(n - 1);\n\n    if (type == \"random\") {\n        // Random capacities between 1 and 1e9\n        for(int i = 0; i < n - 1; ++i) {\n            capacities[i] = rnd.next(1, 1000000000);\n        }\n    } else if (type == \"max\") {\n        // All capacities are maximum\n        for(int i = 0; i < n - 1; ++i) {\n            capacities[i] = 1000000000;\n        }\n    } else if (type == \"min\") {\n        // All capacities are minimum\n        for(int i = 0; i < n - 1; ++i) {\n            capacities[i] = 1;\n        }\n    } else if (type == \"alternating\") {\n        // Capacities alternate between 1 and 1e9\n        for(int i = 0; i < n - 1; ++i) {\n            capacities[i] = (i % 2 == 0) ? 1 : 1000000000;\n        }\n    } else if (type == \"increasing\") {\n        // Capacities increase from 1 to 1e9\n        long long delta = 1000000000LL / (n - 1);\n        for(int i = 0; i < n - 1; ++i) {\n            capacities[i] = 1 + delta * i;\n        }\n    } else if (type == \"decreasing\") {\n        // Capacities decrease from 1e9 to 1\n        long long delta = 1000000000LL / (n - 1);\n        for(int i = 0; i < n - 1; ++i) {\n            capacities[i] = 1000000000LL - delta * i;\n        }\n    } else if (type == \"one_max_rest_min\") {\n        // One bridge has max capacity, rest have min\n        int pos = rnd.next(0, n - 2);\n        for(int i = 0; i < n - 1; ++i) {\n            capacities[i] = (i == pos) ? 1000000000 : 1;\n        }\n    } else if (type == \"one_min_rest_max\") {\n        // One bridge has min capacity, rest have max\n        int pos = rnd.next(0, n - 2);\n        for(int i = 0; i < n - 1; ++i) {\n            capacities[i] = (i == pos) ? 1 : 1000000000;\n        }\n    } else if (type == \"spike\") {\n        // Capacities increase then decrease\n        int mid = (n - 2) / 2;\n        for(int i = 0; i <= mid; ++i) {\n            capacities[i] = 1 + ((1000000000LL - 1) * i / mid);\n        }\n        for(int i = mid + 1; i < n - 1; ++i) {\n            capacities[i] = capacities[n - 2 - i];\n        }\n    } else if (type == \"const_k\") {\n        // All capacities are k\n        int k = opt<int>(\"k\");\n        ensure(1 <= k && k <= 1000000000);\n        for(int i = 0; i < n - 1; ++i) {\n            capacities[i] = k;\n        }\n    } else {\n        // Unknown type, exit with error\n        fprintf(stderr, \"Unknown type: %s\\n\", type.c_str());\n        exit(1);\n    }\n\n    // Output\n    printf(\"%d\\n\", n);\n    for(int i = 0; i < n - 1; ++i) {\n        printf(\"%d\", capacities[i]);\n        if(i < n - 2) {\n            printf(\" \");\n        } else {\n            printf(\"\\n\");\n        }\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> capacities(n - 1);\n\n    if (type == \"random\") {\n        // Random capacities between 1 and 1e9\n        for(int i = 0; i < n - 1; ++i) {\n            capacities[i] = rnd.next(1, 1000000000);\n        }\n    } else if (type == \"max\") {\n        // All capacities are maximum\n        for(int i = 0; i < n - 1; ++i) {\n            capacities[i] = 1000000000;\n        }\n    } else if (type == \"min\") {\n        // All capacities are minimum\n        for(int i = 0; i < n - 1; ++i) {\n            capacities[i] = 1;\n        }\n    } else if (type == \"alternating\") {\n        // Capacities alternate between 1 and 1e9\n        for(int i = 0; i < n - 1; ++i) {\n            capacities[i] = (i % 2 == 0) ? 1 : 1000000000;\n        }\n    } else if (type == \"increasing\") {\n        // Capacities increase from 1 to 1e9\n        long long delta = 1000000000LL / (n - 1);\n        for(int i = 0; i < n - 1; ++i) {\n            capacities[i] = 1 + delta * i;\n        }\n    } else if (type == \"decreasing\") {\n        // Capacities decrease from 1e9 to 1\n        long long delta = 1000000000LL / (n - 1);\n        for(int i = 0; i < n - 1; ++i) {\n            capacities[i] = 1000000000LL - delta * i;\n        }\n    } else if (type == \"one_max_rest_min\") {\n        // One bridge has max capacity, rest have min\n        int pos = rnd.next(0, n - 2);\n        for(int i = 0; i < n - 1; ++i) {\n            capacities[i] = (i == pos) ? 1000000000 : 1;\n        }\n    } else if (type == \"one_min_rest_max\") {\n        // One bridge has min capacity, rest have max\n        int pos = rnd.next(0, n - 2);\n        for(int i = 0; i < n - 1; ++i) {\n            capacities[i] = (i == pos) ? 1 : 1000000000;\n        }\n    } else if (type == \"spike\") {\n        // Capacities increase then decrease\n        int mid = (n - 2) / 2;\n        for(int i = 0; i <= mid; ++i) {\n            capacities[i] = 1 + ((1000000000LL - 1) * i / mid);\n        }\n        for(int i = mid + 1; i < n - 1; ++i) {\n            capacities[i] = capacities[n - 2 - i];\n        }\n    } else if (type == \"const_k\") {\n        // All capacities are k\n        int k = opt<int>(\"k\");\n        ensure(1 <= k && k <= 1000000000);\n        for(int i = 0; i < n - 1; ++i) {\n            capacities[i] = k;\n        }\n    } else {\n        // Unknown type, exit with error\n        fprintf(stderr, \"Unknown type: %s\\n\", type.c_str());\n        exit(1);\n    }\n\n    // Output\n    printf(\"%d\\n\", n);\n    for(int i = 0; i < n - 1; ++i) {\n        printf(\"%d\", capacities[i]);\n        if(i < n - 2) {\n            printf(\" \");\n        } else {\n            printf(\"\\n\");\n        }\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 2 -type min\n./gen -n 2 -type max\n\n./gen -n 10 -type random\n./gen -n 10 -type max\n./gen -n 10 -type min\n./gen -n 10 -type alternating\n./gen -n 10 -type increasing\n./gen -n 10 -type decreasing\n./gen -n 10 -type one_max_rest_min\n./gen -n 10 -type one_min_rest_max\n\n./gen -n 100 -type random\n./gen -n 100 -type max\n./gen -n 100 -type min\n./gen -n 100 -type alternating\n\n./gen -n 1000 -type random\n./gen -n 1000 -type max\n./gen -n 1000 -type min\n./gen -n 1000 -type spike\n\n./gen -n 10000 -type random\n./gen -n 10000 -type decreasing\n./gen -n 10000 -type one_min_rest_max\n\n./gen -n 100000 -type random\n./gen -n 100000 -type min\n./gen -n 100000 -type const_k -k 42\n./gen -n 100000 -type const_k -k 999999999\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T19:48:05.964105",
        "total_tutorials": 3,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "201/D",
      "title": "D. Brand New Problem",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test5 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains a single integer n (1 ≤ n ≤ 15) — the number of words in Lesha's problem. The second line contains n space-separated words — the short description of the problem.The third line contains a single integer m (1 ≤ m ≤ 10) — the number of problems in the Torcoder.com archive. Next m lines contain the descriptions of the problems as \"k s1 s2 ... sk\", where k (1 ≤ k ≤ 500000) is the number of words in the problem and si is a word of the problem description.All words from all problem descriptions contain no more than 10 lowercase English letters. It is guaranteed that the total length of words in all problem descriptions does not exceed 500015.",
      "output_spec": "OutputIf Lesha's problem is brand new, print string \"Brand new problem!\" (without quotes). Otherwise, on the first line print the index of the archive problem which resembles Lesha's problem most. If there are multiple such problems, print the one with the smallest index. On the second line print a string consisting of characters [:, character | repeated p times, and characters :], where p is the \"similarity\" between this problem and Lesha's one. The archive problems are numbered starting from one in the order in which they are given in the input.",
      "sample_tests": "ExamplesInputCopy4find the next palindrome110 find the previous palindrome or print better luck next timeOutputCopy1[:||||||:]InputCopy3add two numbers31 add2 two two3 numbers numbers numbersOutputCopyBrand new problem!InputCopy4these papers are formulas36 what are these formulas and papers5 papers are driving me crazy4 crazy into the nightOutputCopy1[:||||:]InputCopy3add two decimals54 please two decimals add5 decimals want to be added4 two add decimals add4 add one two three7 one plus two plus three equals sixOutputCopy3[:|||:]",
      "description": "D. Brand New Problem\n\ntime limit per test5 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains a single integer n (1 ≤ n ≤ 15) — the number of words in Lesha's problem. The second line contains n space-separated words — the short description of the problem.The third line contains a single integer m (1 ≤ m ≤ 10) — the number of problems in the Torcoder.com archive. Next m lines contain the descriptions of the problems as \"k s1 s2 ... sk\", where k (1 ≤ k ≤ 500000) is the number of words in the problem and si is a word of the problem description.All words from all problem descriptions contain no more than 10 lowercase English letters. It is guaranteed that the total length of words in all problem descriptions does not exceed 500015.\n\nOutputIf Lesha's problem is brand new, print string \"Brand new problem!\" (without quotes). Otherwise, on the first line print the index of the archive problem which resembles Lesha's problem most. If there are multiple such problems, print the one with the smallest index. On the second line print a string consisting of characters [:, character | repeated p times, and characters :], where p is the \"similarity\" between this problem and Lesha's one. The archive problems are numbered starting from one in the order in which they are given in the input.\n\nInputCopy4find the next palindrome110 find the previous palindrome or print better luck next timeOutputCopy1[:||||||:]InputCopy3add two numbers31 add2 two two3 numbers numbers numbersOutputCopyBrand new problem!InputCopy4these papers are formulas36 what are these formulas and papers5 papers are driving me crazy4 crazy into the nightOutputCopy1[:||||:]InputCopy3add two decimals54 please two decimals add5 decimals want to be added4 two add decimals add4 add one two three7 one plus two plus three equals sixOutputCopy3[:|||:]\n\nInputCopy4find the next palindrome110 find the previous palindrome or print better luck next time\n\nOutputCopy1[:||||||:]\n\nInputCopy3add two numbers31 add2 two two3 numbers numbers numbers\n\nOutputCopyBrand new problem!\n\nInputCopy4these papers are formulas36 what are these formulas and papers5 papers are driving me crazy4 crazy into the night\n\nOutputCopy1[:||||:]\n\nInputCopy3add two decimals54 please two decimals add5 decimals want to be added4 two add decimals add4 add one two three7 one plus two plus three equals six\n\nOutputCopy3[:|||:]\n\nNoteLet us remind you that the number of inversions is the number of pairs of words that follow in the permutation not in their original order. Thus, for example, if the original problem is \"add two numbers\", then permutation \"numbers add two\" contains two inversions — pairs of words \"numbers\" and \"add\", \"numbers\" and \"two\". Sequence b1,  b2,  ...,  bk is a subsequence of sequence a1, a2,  ...,  an if there exists such a set of indices 1 ≤ i1 <  i2 < ...   < ik ≤ n that aij  =  bj (in other words, if sequence b can be obtained from a by deleting some of its elements).In the first test case the first problem contains the \"find the palindrome next\" permutation as a subsequence, in which the number of inversions equals 1 (words \"palindrome\" and \"next\").In the second test case there is no problem that contains a permutation of words from Lesha's problem as a subsequence.",
      "solutions": [
        {
          "title": "Codeforces Round #127 - Codeforces",
          "content": "Hello everyone!As many of you already know, today is the day for Codeforces Round #127 missing which is really undesirable ;)Original problems for you were created by tourist and Romka. We tried to emphasize the ideological component of the problems, thus we hope that you'll spend more time thinking than coding. Special thanks for helping in setting the contest go to Codeforces coordinator Gerald. We also thank Delinur for translating the problem statements and Alex_KPR for reviewing them.We hope that this round won't be just a regular Codeforces round for you, but will bring you new experience and new knowledge. For the authors all problems are equally easy, yet we tried to arrange them in decreasing order of simplicity :)Problems' point values in Division 1 are 1000-1000-1500-2000-2500. Problems' point values in Division 2 are 500-1000-2000-2000-2500.Wish you success!UPD: The contest is over, thanks all for participating. We hope you enjoyed it :)In Division 1 rng_58 was a clear winner, solving all 5 problems in an hour and a half! No one else managed to solve all problems in two hours.The winners in Division 1 are (full results): rng_58 peter50216 liympanda White_Bear havaliza In Division 2 every problem was solved by somebody, but nobody managed to solve all problems. The battle was very tough and the gaps were very small.The winners in Division 2 are (full results): Leewings snow_lotus 72VanVector_SevNTU Congratulations to the winners!UPD2: The editorial is available now.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/4796",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1501
        },
        {
          "title": "Codeforces Round #127 — editorial - Codeforces",
          "content": "Problem A(div 2) — LLPSIt's assumed that this problem can be solved just looking at the samples and without reading the statement itself :)Let's find the letter in the given string which comes last in the alphabet, denote this letter by z. If this letter occurs p times in the given string, then the answer is string a consisting of letter z repeated p times.Why is it so? Using the definition of lexicographical comparison and the fact that z is the largest letter in the string it's easy to understand that if some other subsequence b of the given string is lexicographically larger than a, then string b should be longer than a and, moreover, a should be a prefix of b (that is, b should start with a). But string b must be a palindrome, therefore its last letter must be z. In this case string b must contain more occurrences of letter z than the original string s does, which is impossible as b is a subsequence of s.Besides that, the constraint on the length of the string was very low, so the problem could be solved using brute force. For every subsequence of the given string it's necessary to check whether it's a palindrome, and from all palindromic subsequences of s the lexicographically largest should be chosen as the answer. The complexity of such a solution is O(2n·n), where n is the length of the string (unlike the solution above with complexity O(n)).Problem В(div 2) — Brand New Easy ProblemThe constraints in this problem were so low that a solution with complexity O(m·kn) was just fine. In each problem's description it's enough to loop over all possible subsequences of words which are permutations of words in Lesha's problem, for each of them calculate the number of inversions and choose a permutation with the smallest number of inversions. This can result in a short solution using recursion or, for example, you can use several nested loops (from 1 to 4).Here is an example of pseudocode for n = 4: w - array of words of Lesha''s problem\ns - the description of the current problem\nbest = 100\nfor a = 1 to k do\n for b = 1 to k do\n for c = 1 to k do\n for d = 1 to k do\n if s[a] == w[1] and s[b] == w[2] and s[c] == w[3] and s[d] == w[4] then\n inversions = 0\n if a > b then inversions = inversions + 1\n if a > c then inversions = inversions + 1\n if a > d then inversions = inversions + 1\n if b > c then inversions = inversions + 1\n if b > d then inversions = inversions + 1\n if c > d then inversions = inversions + 1\n if inversions < best then\n best = inversionsAt the end you should choose the problem with the smallest value of best and print the answer in the corresponding form.Problem A(div 1)/C(div 2) — Clear SymmetryIt's interesting that originally the authors had an idea not to include the x = 3 case into pretests. Imagine the number of successful hacking attempts in this contest -- considering the fact that none of the first 43 solutions to this problem passed pretests :)Note that the sought n is always an odd number. Indeed, if n is even, then two central rows of matrix A must contain zeroes, otherwise there will exist two neighbouring cells containing ones. Similar restriction applies to two central columns of matrix A. Replacing two central rows with just one and two central columns with just one and leaving zeroes in them, we'll obtain a smaller matrix with the same sharpness.Note that the sharpness of a matrix with side n can't exceed . It's easy to see that it's possible to lay out \"domino pieces\" 1 by 2 without intersections on a field with side n (in other words, all cells except one can be divided into pairs so that each pair contains neighbouring cells). Then there can be at most one one in the cells under each \"domino piece\" in the corresponding matrix. Therefore, the total number of ones doesn't exceed .Note that a matrix with side n and sharpness exists for an odd n. Paint all cells of the matrix in chess order and put ones into black cells and zeroes into white cells. It's easy to see that such a matrix is both clear and symmetrical and has sharpenss exactly .Intuitively it seems that if there exists a matrix with sharpness there should also exist a matrix with every smaller sharpness. That's correct except only one case -- there doesn't exist a matrix with side 3 and sharpness 3, though there exists a matrix with side 3 and sharpness 5.Let's show that the claim above is correct for odd n ≥ 5. We'll build a matrix with sharpness as shown above and gradually turn ones into zeroes reducing the sharpness. Cells containing ones in the matrix can be divided into three types.The first type is the central cell. The number in it can be turned into zero and the matrix won't stop satisfying the required conditions.The second type is the cells in the central row and the central column (except central cell). Such cells are divided into pairs by the condition of symmetry -- if we turn the number in one of them into zero, we should turn the number in its pair cell into zero as well.The third type is all the other cells. Such cells are divided into groups of four by the condition of symmetry -- if we turn the number in one of them into zero, we should turn the number in all cells from this group into zero as well.Now for obtaining the required sharpness of x we'll act greedily. Let's turn ones into zeroes in third type cells by four until the current shapness exceeds x by less than 4 or there are no third type cells with ones remaining. After that let's turn ones into zeroes in second type cells by pairs while the current sharpness exceeds x by at least 2. At this moment the sharpness of our matrix is either x or x + 1. If it's equal to x + 1, let's put a zero into the central cell and obtain a matrix with sharpness x. It's easy to check that we'll be able to obtain a matrix with any sharpness acting this way.Why is this reasoning incorrect for n = 3? Because second type cells are absent in the matrix with sharpness 5 obtained from chess coloring. For n ≥ 5 this matrix contains cells of all types, which is important for the algorithm above. It's better to find the answers for x ≤ 5 by hand but carefully -- for example, a lot of contestants decided that the answer for x = 2 is 5 instead of 3.Problem В(div 1)/D(div 2) — Guess That Car!We need to find such x and y that the value of is minimum possible. This expression can be rewritten as . Note that the first part doesn't depend on y and the second part doesn't depend on x, so we can minimize these parts separately. Here is how to minimize , the second part is minimized similarly. As the expression in the brackets doesn't depend on j, this part can be rewritten as , where . Now it's enough to calculate the required value for all possible values of x and choose x for which this value is the smallest. The optimal value of y can be found similarly.The overall complexity of this solution is O(n·m + n2 + m2).As the objective function is convex, other approaches to this problem are possible, for example, ternary search, gradient descent or analytical approach (calculation of derivatives).The main hero of this problem is Ra16bit.Problem С(div 1)/E(div 2) — Fragile BridgesThere are a few different ways to solve this problem, the editorial contains one of them.For any solution the following fact is useful. Suppose the sought path starts on platform i and ends on platform j (i ≤ j, if that's not the case, we can reverse the path). Then all bridges between platforms i and j will be passed through an odd number of times, and all other bridges will be passed through an even number of times.Let's find the maximum length of a path with its ends on platforms i and j. To do that, let's find the following auxiliary values for each platform: lefti -- the maximum length of a path starting and ending on platform i and passing only through bridges to the left of platform i; rightj -- similarly for bridges to the right of platform j. Also for each bridge define oddi as the largest odd number not larger than ai, and for each platform define sumOddi as the sum of oddj for all bridges to the left of platform i.Then the maximum length of a path with its ends on platforms i and j is equal to lefti + rightj + (sumOddj - sumOddi), or, which is the same, (rightj + sumOddj) + (lefti - sumOddi).Now we can find the pair (i, j) for which this value is the largest in linear time. Let's loop over j. From the formula it's obvious that we should find such i ≤ j that (lefti - sumOddi) is the largest. If we loop over j from 1 to n, we can maintain the largest value of this expression for all i ≤ j and recalculate it when moving to the next j, comparing (leftj - sumOddj) with the current maximum and possibly updating this maximum. This way for each j we have to check only one value of i and not all i ≤ j.The last thing to show is how to find all lefti quickly (all rightj can be found similarly). Clearly left1 = 0, then we'll calculate lefti using lefti - 1. Note that when ai - 1 = 1, we have lefti = 0 as after passing the bridge to platform (i - 1) this bridge will collapse and it will be impossible to return to platform i. If ai - 1 > 1, then lefti = lefti - 1 + eveni - 1, where eveni - 1 is the largest even number not larger than ai - 1. Indeed, we can move to platform (i - 1), then move along the path corresponding to lefti - 1, and then move along the bridge between platforms (i - 1) and i until the limit on the number of transitions is less than 2 (finishing on platform i).The overall complexity of this solution is O(n).Problem D(div 1) — Brand New ProblemThe first solution coming to mind is dynamic programming f[i][j] =  (the smallest possible number of inversions to the moment if among the first j words of the archive problem we've found a permutation of words included in bitmask i). In this solution parameter j varies from 0 to 500000, parameter i varies from 0 to 215 - 1 and calculation of each value is possible in O(1) (we are either using the current word in the subsequence or not). That's too much.Let's make use of a standard technique: make the value of DP a new parameter and make one of the existing parameters the value of DP. Not for every DP this is possible, but at least it's possible for this one :)It's clear that with a fixed subset of words and a fixed number of inversions it's optimal to choose the first occurrences of these words giving this number of inversions. Let f[i][j] =  (the smallest number z such that among first z words of the archive problem there exists a permutation of words from bitmask i containing exactly j inversions). The basis of this DP is f[0][0] = 0, f[0][j] = ∞ for j > 0. Recalculation of values happens in the following way: loop over a word q from the bitmask i which was the last in the permutation. With the knowledge of this word and the number of inversions j it's easy to find how many inversions j' there were without this word — that's j minus the number of words in the mask which appeared later in Lesha's problem than word q. Let p = f[i^(1«q)][j']. Then we should consider p2 equal to the position of the next occurrence of word q after position p as a possible value for f[i][j]. To find p2 quickly we should fill an array next[500010][15] so that next[i][j] =  (the smallest position k > i such that the k-th word in the archive problem equals the j-th word in Lesha's problem) for each archive problem in advance. This array can be easily filled passing from right to left once.The total number of operations can be calculated as m·(k·n + 2n·Cn2·n), where m is the number of problems in the archive, k is the number of words in one archive problem description and n is the number of words in Lesha's problem description. Under the given constraints that is about 200 million operations, and the author's solutions (including a Java solution) worked for less than 2 seconds. The time limit was set with a margin -- 5 seconds.The main heroes of problems D(div 1) and B(div 2) are Chmel_Tolstiy and ivan.metelsky.Problem E(div 1) — Thoroughly Bureaucratic OrganizationLet's imagine that we have a magic function maxN(m, k) that returns, given m and k, the largest value of n such that it's possible to solve the problem for n people and m empty lines in the form using k requests. Then we'll be able to use binary search on the answer -- the number of requests k.Suppose we've made k requests. Let's match a string of length k to each person, where the i-th character is equal to 1 if this person is mentioned in the i-th request and 0 otherwise. Note that we'll be able to determine the exact appointment date for each person if and only if all n strings of length k are pairwise distinct. Indeed, if two persons' strings are the same, their appointment dates could be exchanged and the responses to the requests wouldn't have changed. If all strings are distinct, for each date we may find the person appointed for this date looking at the set of requests with responses containing this date and finding the person mentioned in the same set of requests.The constraint on m empty lines in the form means that each of k positions in the strings should contain no more than m ones in all n strings overall. Thus function maxN(m, k) should return the maximum size of a set of distinct k-bit strings meeting this condition. Let's make this restriction weaker: we'll search for a set such that the total number of ones in all n strings doesn't exceed k·m. As we'll prove later, the answer won't change.With this weaker restriction the problem can be solved using a simple greedy strategy. It's obvious that strings with smaller number of ones are better. Let's loop over the number of ones i in the string from 0 to k and also maintain a variable t containing the remaining number of ones (initially it's equal to k·m). Then at the i-th step we can take at most strings containing i ones. Let's add p to the answer and subtract p·i from t. Note that the values of Cki should be calculated with care -- they can turn out to be too large, so it's important not to allow overflows.It can be shown that the overall complexity of this algorithm is at most O(log2 n).The remaining thing is to prove the claim above. The idea of the proof below belongs to rng_58 (the author's proof is notably harder).Let's solve the problem with a greedy algorithm with the k·m constraint on the total number of ones. The resulting set of strings may not satisfy the restriction of m ones for each position. If it doesn't, some of the positions contain more than m ones and some contain less than m ones. Let's pick any position X containing more than m ones and any position Y containing less than m ones. Find all strings containing 1 at X and 0 at Y (suppose there are x such strings) and all strings containing 0 at X and 1 at Y (suppose there are y such strings). It's clear that x > y. In each of x strings we can try to put 0 at X and 1 at Y -- then the string we obtain will either remain unique in this set or coincide with one of those y strings (but only one). As x > y, for at least one of x strings the change above leaves this string unique. Let's take this string and put 0 at X and 1 at Y. Now position X contains one 1 less, and position Y contains one 1 more. It means that the total number of \"extra\" ones in the positions has been decreased (as Y still contains no more than m ones). Doing this operation for a needed number of times, we'll achieve our goal.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/4808",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 15409
        },
        {
          "title": "Codeforces Round #127 — editorial - Codeforces",
          "content": "Problem A(div 2) — LLPSIt's assumed that this problem can be solved just looking at the samples and without reading the statement itself :)Let's find the letter in the given string which comes last in the alphabet, denote this letter by z. If this letter occurs p times in the given string, then the answer is string a consisting of letter z repeated p times.Why is it so? Using the definition of lexicographical comparison and the fact that z is the largest letter in the string it's easy to understand that if some other subsequence b of the given string is lexicographically larger than a, then string b should be longer than a and, moreover, a should be a prefix of b (that is, b should start with a). But string b must be a palindrome, therefore its last letter must be z. In this case string b must contain more occurrences of letter z than the original string s does, which is impossible as b is a subsequence of s.Besides that, the constraint on the length of the string was very low, so the problem could be solved using brute force. For every subsequence of the given string it's necessary to check whether it's a palindrome, and from all palindromic subsequences of s the lexicographically largest should be chosen as the answer. The complexity of such a solution is O(2n·n), where n is the length of the string (unlike the solution above with complexity O(n)).Problem В(div 2) — Brand New Easy ProblemThe constraints in this problem were so low that a solution with complexity O(m·kn) was just fine. In each problem's description it's enough to loop over all possible subsequences of words which are permutations of words in Lesha's problem, for each of them calculate the number of inversions and choose a permutation with the smallest number of inversions. This can result in a short solution using recursion or, for example, you can use several nested loops (from 1 to 4).Here is an example of pseudocode for n = 4: w - array of words of Lesha''s problem\ns - the description of the current problem\nbest = 100\nfor a = 1 to k do\n for b = 1 to k do\n for c = 1 to k do\n for d = 1 to k do\n if s[a] == w[1] and s[b] == w[2] and s[c] == w[3] and s[d] == w[4] then\n inversions = 0\n if a > b then inversions = inversions + 1\n if a > c then inversions = inversions + 1\n if a > d then inversions = inversions + 1\n if b > c then inversions = inversions + 1\n if b > d then inversions = inversions + 1\n if c > d then inversions = inversions + 1\n if inversions < best then\n best = inversionsAt the end you should choose the problem with the smallest value of best and print the answer in the corresponding form.Problem A(div 1)/C(div 2) — Clear SymmetryIt's interesting that originally the authors had an idea not to include the x = 3 case into pretests. Imagine the number of successful hacking attempts in this contest -- considering the fact that none of the first 43 solutions to this problem passed pretests :)Note that the sought n is always an odd number. Indeed, if n is even, then two central rows of matrix A must contain zeroes, otherwise there will exist two neighbouring cells containing ones. Similar restriction applies to two central columns of matrix A. Replacing two central rows with just one and two central columns with just one and leaving zeroes in them, we'll obtain a smaller matrix with the same sharpness.Note that the sharpness of a matrix with side n can't exceed . It's easy to see that it's possible to lay out \"domino pieces\" 1 by 2 without intersections on a field with side n (in other words, all cells except one can be divided into pairs so that each pair contains neighbouring cells). Then there can be at most one one in the cells under each \"domino piece\" in the corresponding matrix. Therefore, the total number of ones doesn't exceed .Note that a matrix with side n and sharpness exists for an odd n. Paint all cells of the matrix in chess order and put ones into black cells and zeroes into white cells. It's easy to see that such a matrix is both clear and symmetrical and has sharpenss exactly .Intuitively it seems that if there exists a matrix with sharpness there should also exist a matrix with every smaller sharpness. That's correct except only one case -- there doesn't exist a matrix with side 3 and sharpness 3, though there exists a matrix with side 3 and sharpness 5.Let's show that the claim above is correct for odd n ≥ 5. We'll build a matrix with sharpness as shown above and gradually turn ones into zeroes reducing the sharpness. Cells containing ones in the matrix can be divided into three types.The first type is the central cell. The number in it can be turned into zero and the matrix won't stop satisfying the required conditions.The second type is the cells in the central row and the central column (except central cell). Such cells are divided into pairs by the condition of symmetry -- if we turn the number in one of them into zero, we should turn the number in its pair cell into zero as well.The third type is all the other cells. Such cells are divided into groups of four by the condition of symmetry -- if we turn the number in one of them into zero, we should turn the number in all cells from this group into zero as well.Now for obtaining the required sharpness of x we'll act greedily. Let's turn ones into zeroes in third type cells by four until the current shapness exceeds x by less than 4 or there are no third type cells with ones remaining. After that let's turn ones into zeroes in second type cells by pairs while the current sharpness exceeds x by at least 2. At this moment the sharpness of our matrix is either x or x + 1. If it's equal to x + 1, let's put a zero into the central cell and obtain a matrix with sharpness x. It's easy to check that we'll be able to obtain a matrix with any sharpness acting this way.Why is this reasoning incorrect for n = 3? Because second type cells are absent in the matrix with sharpness 5 obtained from chess coloring. For n ≥ 5 this matrix contains cells of all types, which is important for the algorithm above. It's better to find the answers for x ≤ 5 by hand but carefully -- for example, a lot of contestants decided that the answer for x = 2 is 5 instead of 3.Problem В(div 1)/D(div 2) — Guess That Car!We need to find such x and y that the value of is minimum possible. This expression can be rewritten as . Note that the first part doesn't depend on y and the second part doesn't depend on x, so we can minimize these parts separately. Here is how to minimize , the second part is minimized similarly. As the expression in the brackets doesn't depend on j, this part can be rewritten as , where . Now it's enough to calculate the required value for all possible values of x and choose x for which this value is the smallest. The optimal value of y can be found similarly.The overall complexity of this solution is O(n·m + n2 + m2).As the objective function is convex, other approaches to this problem are possible, for example, ternary search, gradient descent or analytical approach (calculation of derivatives).The main hero of this problem is Ra16bit.Problem С(div 1)/E(div 2) — Fragile BridgesThere are a few different ways to solve this problem, the editorial contains one of them.For any solution the following fact is useful. Suppose the sought path starts on platform i and ends on platform j (i ≤ j, if that's not the case, we can reverse the path). Then all bridges between platforms i and j will be passed through an odd number of times, and all other bridges will be passed through an even number of times.Let's find the maximum length of a path with its ends on platforms i and j. To do that, let's find the following auxiliary values for each platform: lefti -- the maximum length of a path starting and ending on platform i and passing only through bridges to the left of platform i; rightj -- similarly for bridges to the right of platform j. Also for each bridge define oddi as the largest odd number not larger than ai, and for each platform define sumOddi as the sum of oddj for all bridges to the left of platform i.Then the maximum length of a path with its ends on platforms i and j is equal to lefti + rightj + (sumOddj - sumOddi), or, which is the same, (rightj + sumOddj) + (lefti - sumOddi).Now we can find the pair (i, j) for which this value is the largest in linear time. Let's loop over j. From the formula it's obvious that we should find such i ≤ j that (lefti - sumOddi) is the largest. If we loop over j from 1 to n, we can maintain the largest value of this expression for all i ≤ j and recalculate it when moving to the next j, comparing (leftj - sumOddj) with the current maximum and possibly updating this maximum. This way for each j we have to check only one value of i and not all i ≤ j.The last thing to show is how to find all lefti quickly (all rightj can be found similarly). Clearly left1 = 0, then we'll calculate lefti using lefti - 1. Note that when ai - 1 = 1, we have lefti = 0 as after passing the bridge to platform (i - 1) this bridge will collapse and it will be impossible to return to platform i. If ai - 1 > 1, then lefti = lefti - 1 + eveni - 1, where eveni - 1 is the largest even number not larger than ai - 1. Indeed, we can move to platform (i - 1), then move along the path corresponding to lefti - 1, and then move along the bridge between platforms (i - 1) and i until the limit on the number of transitions is less than 2 (finishing on platform i).The overall complexity of this solution is O(n).Problem D(div 1) — Brand New ProblemThe first solution coming to mind is dynamic programming f[i][j] =  (the smallest possible number of inversions to the moment if among the first j words of the archive problem we've found a permutation of words included in bitmask i). In this solution parameter j varies from 0 to 500000, parameter i varies from 0 to 215 - 1 and calculation of each value is possible in O(1) (we are either using the current word in the subsequence or not). That's too much.Let's make use of a standard technique: make the value of DP a new parameter and make one of the existing parameters the value of DP. Not for every DP this is possible, but at least it's possible for this one :)It's clear that with a fixed subset of words and a fixed number of inversions it's optimal to choose the first occurrences of these words giving this number of inversions. Let f[i][j] =  (the smallest number z such that among first z words of the archive problem there exists a permutation of words from bitmask i containing exactly j inversions). The basis of this DP is f[0][0] = 0, f[0][j] = ∞ for j > 0. Recalculation of values happens in the following way: loop over a word q from the bitmask i which was the last in the permutation. With the knowledge of this word and the number of inversions j it's easy to find how many inversions j' there were without this word — that's j minus the number of words in the mask which appeared later in Lesha's problem than word q. Let p = f[i^(1«q)][j']. Then we should consider p2 equal to the position of the next occurrence of word q after position p as a possible value for f[i][j]. To find p2 quickly we should fill an array next[500010][15] so that next[i][j] =  (the smallest position k > i such that the k-th word in the archive problem equals the j-th word in Lesha's problem) for each archive problem in advance. This array can be easily filled passing from right to left once.The total number of operations can be calculated as m·(k·n + 2n·Cn2·n), where m is the number of problems in the archive, k is the number of words in one archive problem description and n is the number of words in Lesha's problem description. Under the given constraints that is about 200 million operations, and the author's solutions (including a Java solution) worked for less than 2 seconds. The time limit was set with a margin -- 5 seconds.The main heroes of problems D(div 1) and B(div 2) are Chmel_Tolstiy and ivan.metelsky.Problem E(div 1) — Thoroughly Bureaucratic OrganizationLet's imagine that we have a magic function maxN(m, k) that returns, given m and k, the largest value of n such that it's possible to solve the problem for n people and m empty lines in the form using k requests. Then we'll be able to use binary search on the answer -- the number of requests k.Suppose we've made k requests. Let's match a string of length k to each person, where the i-th character is equal to 1 if this person is mentioned in the i-th request and 0 otherwise. Note that we'll be able to determine the exact appointment date for each person if and only if all n strings of length k are pairwise distinct. Indeed, if two persons' strings are the same, their appointment dates could be exchanged and the responses to the requests wouldn't have changed. If all strings are distinct, for each date we may find the person appointed for this date looking at the set of requests with responses containing this date and finding the person mentioned in the same set of requests.The constraint on m empty lines in the form means that each of k positions in the strings should contain no more than m ones in all n strings overall. Thus function maxN(m, k) should return the maximum size of a set of distinct k-bit strings meeting this condition. Let's make this restriction weaker: we'll search for a set such that the total number of ones in all n strings doesn't exceed k·m. As we'll prove later, the answer won't change.With this weaker restriction the problem can be solved using a simple greedy strategy. It's obvious that strings with smaller number of ones are better. Let's loop over the number of ones i in the string from 0 to k and also maintain a variable t containing the remaining number of ones (initially it's equal to k·m). Then at the i-th step we can take at most strings containing i ones. Let's add p to the answer and subtract p·i from t. Note that the values of Cki should be calculated with care -- they can turn out to be too large, so it's important not to allow overflows.It can be shown that the overall complexity of this algorithm is at most O(log2 n).The remaining thing is to prove the claim above. The idea of the proof below belongs to rng_58 (the author's proof is notably harder).Let's solve the problem with a greedy algorithm with the k·m constraint on the total number of ones. The resulting set of strings may not satisfy the restriction of m ones for each position. If it doesn't, some of the positions contain more than m ones and some contain less than m ones. Let's pick any position X containing more than m ones and any position Y containing less than m ones. Find all strings containing 1 at X and 0 at Y (suppose there are x such strings) and all strings containing 0 at X and 1 at Y (suppose there are y such strings). It's clear that x > y. In each of x strings we can try to put 0 at X and 1 at Y -- then the string we obtain will either remain unique in this set or coincide with one of those y strings (but only one). As x > y, for at least one of x strings the change above leaves this string unique. Let's take this string and put 0 at X and 1 at Y. Now position X contains one 1 less, and position Y contains one 1 more. It means that the total number of \"extra\" ones in the positions has been decreased (as Y still contains no more than m ones). Doing this operation for a needed number of times, we'll achieve our goal.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/4808",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 15409
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #127 - Codeforces - Code 1",
          "code": "1 0 0\n0 1 0\n1 0 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4796",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #127 - Codeforces - Code 2",
          "code": "1 0 0\n0 1 0\n1 0 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4796",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #127 - Codeforces - Code 3",
          "code": "0 0 1 0 0\n0 0 0 0 0\n0 0 1 0 0\n0 0 0 0 0\n0 0 1 0 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4796",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #127 - Codeforces - Code 4",
          "code": "0 0 1 0 0\n0 0 0 0 0\n0 0 1 0 0\n0 0 0 0 0\n0 0 1 0 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4796",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #127 - Codeforces - Code 5",
          "code": "0 1 0\n0 0 0\n0 1 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4796",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #127 - Codeforces - Code 6",
          "code": "0 1 0\n0 0 0\n0 1 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4796",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #127 - Codeforces - Code 7",
          "code": "0 1 0\n0 0 0\n0 1 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4796",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #127 - Codeforces - Code 8",
          "code": "0 1 0\n0 0 0\n0 1 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4796",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #127 — editorial - Codeforces - Code 1",
          "code": "w - array of words of Lesha''s problem\ns - the description of the current problem\nbest = 100\nfor a = 1 to k do\n    for b = 1 to k do\n        for c = 1 to k do\n            for d = 1 to k do\n                if s[a] == w[1] and s[b] == w[2] and s[c] == w[3] and s[d] == w[4] then\n                    inversions = 0\n                    if a > b then inversions = inversions + 1\n                    if a > c then inversions = inversions + 1\n                    if a > d then inversions = inversions + 1\n                    if b > c then inversions = inversions + 1\n                    if b > d then inversions = inversions + 1\n                    if c > d then inversions = inversions + 1\n                    if inversions < best then\n                        best = inversions",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4808",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #127 — editorial - Codeforces - Code 2",
          "code": "w - array of words of Lesha''s problem\ns - the description of the current problem\nbest = 100\nfor a = 1 to k do\n    for b = 1 to k do\n        for c = 1 to k do\n            for d = 1 to k do\n                if s[a] == w[1] and s[b] == w[2] and s[c] == w[3] and s[d] == w[4] then\n                    inversions = 0\n                    if a > b then inversions = inversions + 1\n                    if a > c then inversions = inversions + 1\n                    if a > d then inversions = inversions + 1\n                    if b > c then inversions = inversions + 1\n                    if b > d then inversions = inversions + 1\n                    if c > d then inversions = inversions + 1\n                    if inversions < best then\n                        best = inversions",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4808",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #127 — editorial - Codeforces - Code 3",
          "code": "REP(mask,(1<<15)) REP(i,15) for(j=i;j<15;j++) if(mask&(1<<j)) cost[mask][i]++;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4808",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #127 — editorial - Codeforces - Code 1",
          "code": "w - array of words of Lesha''s problem\ns - the description of the current problem\nbest = 100\nfor a = 1 to k do\n    for b = 1 to k do\n        for c = 1 to k do\n            for d = 1 to k do\n                if s[a] == w[1] and s[b] == w[2] and s[c] == w[3] and s[d] == w[4] then\n                    inversions = 0\n                    if a > b then inversions = inversions + 1\n                    if a > c then inversions = inversions + 1\n                    if a > d then inversions = inversions + 1\n                    if b > c then inversions = inversions + 1\n                    if b > d then inversions = inversions + 1\n                    if c > d then inversions = inversions + 1\n                    if inversions < best then\n                        best = inversions",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4808",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #127 — editorial - Codeforces - Code 2",
          "code": "w - array of words of Lesha''s problem\ns - the description of the current problem\nbest = 100\nfor a = 1 to k do\n    for b = 1 to k do\n        for c = 1 to k do\n            for d = 1 to k do\n                if s[a] == w[1] and s[b] == w[2] and s[c] == w[3] and s[d] == w[4] then\n                    inversions = 0\n                    if a > b then inversions = inversions + 1\n                    if a > c then inversions = inversions + 1\n                    if a > d then inversions = inversions + 1\n                    if b > c then inversions = inversions + 1\n                    if b > d then inversions = inversions + 1\n                    if c > d then inversions = inversions + 1\n                    if inversions < best then\n                        best = inversions",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4808",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #127 — editorial - Codeforces - Code 3",
          "code": "REP(mask,(1<<15)) REP(i,15) for(j=i;j<15;j++) if(mask&(1<<j)) cost[mask][i]++;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4808",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 15, \"n\");\n    inf.readEoln();\n\n    set<string> lesha_words;\n    long long total_length = 0;\n\n    for (int i = 0; i < n; i++) {\n        if (i > 0) inf.readSpace();\n\n        string s = inf.readToken(\"[a-z]{1,10}\", \"Lesha_word\");\n\n        ensuref(lesha_words.find(s) == lesha_words.end(), \"Duplicate word '%s' in Lesha's problem\", s.c_str());\n\n        lesha_words.insert(s);\n\n        total_length += s.length();\n    }\n    inf.readEoln();\n\n    int m = inf.readInt(1, 10, \"m\");\n    inf.readEoln();\n\n    for (int i = 0; i < m; i++) {\n        int k = inf.readInt(1, 500000, \"k\");\n        inf.readSpace();\n\n        for (int j = 0; j < k; j++) {\n            if (j > 0) inf.readSpace();\n\n            string s = inf.readToken(\"[a-z]{1,10}\", \"word\");\n\n            total_length += s.length();\n        }\n        inf.readEoln();\n    }\n\n    ensuref(total_length <= 500015, \"Total length of words exceeds limit: %lld > 500015\", total_length);\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 15, \"n\");\n    inf.readEoln();\n\n    set<string> lesha_words;\n    long long total_length = 0;\n\n    for (int i = 0; i < n; i++) {\n        if (i > 0) inf.readSpace();\n\n        string s = inf.readToken(\"[a-z]{1,10}\", \"Lesha_word\");\n\n        ensuref(lesha_words.find(s) == lesha_words.end(), \"Duplicate word '%s' in Lesha's problem\", s.c_str());\n\n        lesha_words.insert(s);\n\n        total_length += s.length();\n    }\n    inf.readEoln();\n\n    int m = inf.readInt(1, 10, \"m\");\n    inf.readEoln();\n\n    for (int i = 0; i < m; i++) {\n        int k = inf.readInt(1, 500000, \"k\");\n        inf.readSpace();\n\n        for (int j = 0; j < k; j++) {\n            if (j > 0) inf.readSpace();\n\n            string s = inf.readToken(\"[a-z]{1,10}\", \"word\");\n\n            total_length += s.length();\n        }\n        inf.readEoln();\n    }\n\n    ensuref(total_length <= 500015, \"Total length of words exceeds limit: %lld > 500015\", total_length);\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 15, \"n\");\n    inf.readEoln();\n\n    set<string> lesha_words;\n    long long total_length = 0;\n\n    for (int i = 0; i < n; i++) {\n        if (i > 0) inf.readSpace();\n\n        string s = inf.readToken(\"[a-z]{1,10}\", \"Lesha_word\");\n\n        ensuref(lesha_words.find(s) == lesha_words.end(), \"Duplicate word '%s' in Lesha's problem\", s.c_str());\n\n        lesha_words.insert(s);\n\n        total_length += s.length();\n    }\n    inf.readEoln();\n\n    int m = inf.readInt(1, 10, \"m\");\n    inf.readEoln();\n\n    for (int i = 0; i < m; i++) {\n        int k = inf.readInt(1, 500000, \"k\");\n        inf.readSpace();\n\n        for (int j = 0; j < k; j++) {\n            if (j > 0) inf.readSpace();\n\n            string s = inf.readToken(\"[a-z]{1,10}\", \"word\");\n\n            total_length += s.length();\n        }\n        inf.readEoln();\n    }\n\n    ensuref(total_length <= 500015, \"Total length of words exceeds limit: %lld > 500015\", total_length);\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare sequences of tokens\");\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string j, p;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n\r\n        ans.readWordTo(j);\r\n        ouf.readWordTo(p);\r\n\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s words differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  compress(j).c_str(), compress(p).c_str());\r\n    }\r\n\r\n    if (ans.seekEof() && ouf.seekEof()) {\r\n        if (n == 1)\r\n            quitf(_ok, \"\\\"%s\\\"\", compress(j).c_str());\r\n        else\r\n            quitf(_ok, \"%d tokens\", n);\r\n    } else {\r\n        if (ans.seekEof())\r\n            quitf(_wa, \"Participant output contains extra tokens\");\r\n        else\r\n            quitf(_wa, \"Unexpected EOF in the participants output\");\r\n    }\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nvoid generateUniqueWords(int count, set<string> &used_words, vector<string> &words) {\n    for (int i = 0; i < count; ++i) {\n        string word;\n        do {\n            int len = rnd.next(1, 10);\n            word = \"\";\n            for (int j = 0; j < len; ++j) {\n                word += (char) ('a' + rnd.next(26));\n            }\n        } while (used_words.count(word) > 0);\n        words.push_back(word);\n        used_words.insert(word);\n    }\n}\n\nvoid generateArchiveProblem(int k, set<string> &used_words, vector<string> &arch_words, bool allow_repeats = true) {\n    for (int i = 0; i < k; ++i) {\n        string word;\n        int attempts = 0;\n        do {\n            int len = rnd.next(1, 10);\n            word = \"\";\n            for (int l = 0; l < len; ++l) {\n                word += (char) ('a' + rnd.next(26));\n            }\n            attempts++;\n        } while (!allow_repeats && used_words.count(word) > 0 && attempts < 1000);\n        arch_words.push_back(word);\n        if (!allow_repeats) used_words.insert(word);\n    }\n}\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\", 1);\n    string type = opt<string>(\"type\", \"brand_new\");\n\n    vector<string> lesha_words;\n    vector<vector<string>> archive_problems(m);\n\n    set<string> used_words;\n\n    if (type == \"brand_new\") {\n        generateUniqueWords(n, used_words, lesha_words);\n\n        int total_length = 500015;\n        int lesha_total_length = 0;\n        for (string& word : lesha_words) {\n            lesha_total_length += word.length();\n        }\n        total_length -= lesha_total_length;\n\n        for (int i = 0; i < m; ++i) {\n            vector<string>& arch_words = archive_problems[i];\n            int max_k = total_length / (m - i);\n            int k = rnd.next(1, min(1000, max_k)); // Limit k to prevent too much data\n            total_length -= k;\n            generateArchiveProblem(k, used_words, arch_words, false);\n        }\n    } else if (type == \"full_match\") {\n        generateUniqueWords(n, used_words, lesha_words);\n        vector<string>& arch_words = archive_problems[0];\n        arch_words = lesha_words;\n\n        for (int i = 1; i < m; ++i) {\n            vector<string>& arch_words = archive_problems[i];\n            int k = rnd.next(1, 10);\n            generateArchiveProblem(k, used_words, arch_words, false);\n        }\n    } else if (type == \"reverse_order\") {\n        generateUniqueWords(n, used_words, lesha_words);\n        vector<string>& arch_words = archive_problems[0];\n        arch_words = lesha_words;\n        reverse(arch_words.begin(), arch_words.end());\n\n        for (int i = 1; i < m; ++i) {\n            vector<string>& arch_words = archive_problems[i];\n            int k = rnd.next(1, 10);\n            generateArchiveProblem(k, used_words, arch_words, false);\n        }\n    } else if (type == \"min_inversions\") {\n        generateUniqueWords(n, used_words, lesha_words);\n        vector<string>& arch_words = archive_problems[0];\n\n        vector<string> perm = lesha_words;\n        shuffle(perm.begin(), perm.end());\n        arch_words.insert(arch_words.end(), perm.begin(), perm.end());\n        vector<string> perm2 = lesha_words;\n        shuffle(perm2.begin(), perm2.end());\n        arch_words.insert(arch_words.end(), perm2.begin(), perm2.end());\n    } else if (type == \"large_archive\") {\n        generateUniqueWords(n, used_words, lesha_words);\n\n        int total_length = 500015;\n        int lesha_total_length = 0;\n        for (string& word : lesha_words) {\n            lesha_total_length += word.length();\n        }\n        total_length -= lesha_total_length;\n\n        vector<string>& arch_words = archive_problems[0];\n        int k = min(500000, total_length / 2); // Word length average is at least 1\n        for (int i = 0; i < k; ++i) {\n            string word = \"\";\n            word += (char)('a' + rnd.next(26));\n            arch_words.push_back(word);\n        }\n    } else if (type == \"tie_breaking\") {\n        generateUniqueWords(n, used_words, lesha_words);\n        int similarities = n * (n - 1) / 2;\n\n        for (int idx = 0; idx < m; ++idx) {\n            vector<string>& arch_words = archive_problems[idx];\n            vector<string> perm = lesha_words;\n            shuffle(perm.begin(), perm.end());\n            arch_words.insert(arch_words.end(), perm.begin(), perm.end());\n        }\n    } else if (type == \"max_total_length\") {\n        generateUniqueWords(n, used_words, lesha_words);\n\n        int total_length = 500015;\n        int lesha_total_length = 0;\n        for (string& word : lesha_words) {\n            lesha_total_length += word.length();\n        }\n        total_length -= lesha_total_length;\n\n        int avg_length = 5;\n        int total_words = total_length / avg_length;\n        int words_per_problem = total_words / m;\n\n        for (int i = 0; i < m; ++i) {\n            vector<string>& arch_words = archive_problems[i];\n            int k = words_per_problem;\n            if (i == m - 1) {\n                k = total_words - words_per_problem * (m - 1);\n            }\n            for (int j = 0; j < k; ++j) {\n                string word;\n                int len = avg_length;\n                word = \"\";\n                for (int l = 0; l < len; ++l) {\n                    word += (char) ('a' + rnd.next(26));\n                }\n                arch_words.push_back(word);\n            }\n        }\n    } else if (type == \"repeated_words\") {\n        generateUniqueWords(n, used_words, lesha_words);\n        vector<string>& arch_words = archive_problems[0];\n\n        for (int i = 0; i < 2*n; ++i) {\n            int idx = rnd.next(0, n - 1);\n            arch_words.push_back(lesha_words[idx]);\n        }\n    } else {\n        // Default to brand_new\n        generateUniqueWords(n, used_words, lesha_words);\n\n        int total_length = 500015;\n        int lesha_total_length = 0;\n        for (string& word : lesha_words) {\n            lesha_total_length += word.length();\n        }\n        total_length -= lesha_total_length;\n\n        for (int i = 0; i < m; ++i) {\n            vector<string>& arch_words = archive_problems[i];\n            int max_k = total_length / (m - i);\n            int k = rnd.next(1, min(1000, max_k));\n            total_length -= k;\n            generateArchiveProblem(k, used_words, arch_words, false);\n        }\n    }\n\n    // Output\n    printf(\"%d\\n\", n);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%s\", lesha_words[i].c_str());\n        if (i + 1 < n) {\n            printf(\" \");\n        }\n    }\n    printf(\"\\n\");\n\n    printf(\"%d\\n\", m);\n    for (int i = 0; i < m; ++i) {\n        vector<string>& arch_words = archive_problems[i];\n        printf(\"%d\", (int)arch_words.size());\n        for (int j = 0; j < arch_words.size(); ++j) {\n            printf(\" %s\", arch_words[j].c_str());\n        }\n        printf(\"\\n\");\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nvoid generateUniqueWords(int count, set<string> &used_words, vector<string> &words) {\n    for (int i = 0; i < count; ++i) {\n        string word;\n        do {\n            int len = rnd.next(1, 10);\n            word = \"\";\n            for (int j = 0; j < len; ++j) {\n                word += (char) ('a' + rnd.next(26));\n            }\n        } while (used_words.count(word) > 0);\n        words.push_back(word);\n        used_words.insert(word);\n    }\n}\n\nvoid generateArchiveProblem(int k, set<string> &used_words, vector<string> &arch_words, bool allow_repeats = true) {\n    for (int i = 0; i < k; ++i) {\n        string word;\n        int attempts = 0;\n        do {\n            int len = rnd.next(1, 10);\n            word = \"\";\n            for (int l = 0; l < len; ++l) {\n                word += (char) ('a' + rnd.next(26));\n            }\n            attempts++;\n        } while (!allow_repeats && used_words.count(word) > 0 && attempts < 1000);\n        arch_words.push_back(word);\n        if (!allow_repeats) used_words.insert(word);\n    }\n}\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\", 1);\n    string type = opt<string>(\"type\", \"brand_new\");\n\n    vector<string> lesha_words;\n    vector<vector<string>> archive_problems(m);\n\n    set<string> used_words;\n\n    if (type == \"brand_new\") {\n        generateUniqueWords(n, used_words, lesha_words);\n\n        int total_length = 500015;\n        int lesha_total_length = 0;\n        for (string& word : lesha_words) {\n            lesha_total_length += word.length();\n        }\n        total_length -= lesha_total_length;\n\n        for (int i = 0; i < m; ++i) {\n            vector<string>& arch_words = archive_problems[i];\n            int max_k = total_length / (m - i);\n            int k = rnd.next(1, min(1000, max_k)); // Limit k to prevent too much data\n            total_length -= k;\n            generateArchiveProblem(k, used_words, arch_words, false);\n        }\n    } else if (type == \"full_match\") {\n        generateUniqueWords(n, used_words, lesha_words);\n        vector<string>& arch_words = archive_problems[0];\n        arch_words = lesha_words;\n\n        for (int i = 1; i < m; ++i) {\n            vector<string>& arch_words = archive_problems[i];\n            int k = rnd.next(1, 10);\n            generateArchiveProblem(k, used_words, arch_words, false);\n        }\n    } else if (type == \"reverse_order\") {\n        generateUniqueWords(n, used_words, lesha_words);\n        vector<string>& arch_words = archive_problems[0];\n        arch_words = lesha_words;\n        reverse(arch_words.begin(), arch_words.end());\n\n        for (int i = 1; i < m; ++i) {\n            vector<string>& arch_words = archive_problems[i];\n            int k = rnd.next(1, 10);\n            generateArchiveProblem(k, used_words, arch_words, false);\n        }\n    } else if (type == \"min_inversions\") {\n        generateUniqueWords(n, used_words, lesha_words);\n        vector<string>& arch_words = archive_problems[0];\n\n        vector<string> perm = lesha_words;\n        shuffle(perm.begin(), perm.end());\n        arch_words.insert(arch_words.end(), perm.begin(), perm.end());\n        vector<string> perm2 = lesha_words;\n        shuffle(perm2.begin(), perm2.end());\n        arch_words.insert(arch_words.end(), perm2.begin(), perm2.end());\n    } else if (type == \"large_archive\") {\n        generateUniqueWords(n, used_words, lesha_words);\n\n        int total_length = 500015;\n        int lesha_total_length = 0;\n        for (string& word : lesha_words) {\n            lesha_total_length += word.length();\n        }\n        total_length -= lesha_total_length;\n\n        vector<string>& arch_words = archive_problems[0];\n        int k = min(500000, total_length / 2); // Word length average is at least 1\n        for (int i = 0; i < k; ++i) {\n            string word = \"\";\n            word += (char)('a' + rnd.next(26));\n            arch_words.push_back(word);\n        }\n    } else if (type == \"tie_breaking\") {\n        generateUniqueWords(n, used_words, lesha_words);\n        int similarities = n * (n - 1) / 2;\n\n        for (int idx = 0; idx < m; ++idx) {\n            vector<string>& arch_words = archive_problems[idx];\n            vector<string> perm = lesha_words;\n            shuffle(perm.begin(), perm.end());\n            arch_words.insert(arch_words.end(), perm.begin(), perm.end());\n        }\n    } else if (type == \"max_total_length\") {\n        generateUniqueWords(n, used_words, lesha_words);\n\n        int total_length = 500015;\n        int lesha_total_length = 0;\n        for (string& word : lesha_words) {\n            lesha_total_length += word.length();\n        }\n        total_length -= lesha_total_length;\n\n        int avg_length = 5;\n        int total_words = total_length / avg_length;\n        int words_per_problem = total_words / m;\n\n        for (int i = 0; i < m; ++i) {\n            vector<string>& arch_words = archive_problems[i];\n            int k = words_per_problem;\n            if (i == m - 1) {\n                k = total_words - words_per_problem * (m - 1);\n            }\n            for (int j = 0; j < k; ++j) {\n                string word;\n                int len = avg_length;\n                word = \"\";\n                for (int l = 0; l < len; ++l) {\n                    word += (char) ('a' + rnd.next(26));\n                }\n                arch_words.push_back(word);\n            }\n        }\n    } else if (type == \"repeated_words\") {\n        generateUniqueWords(n, used_words, lesha_words);\n        vector<string>& arch_words = archive_problems[0];\n\n        for (int i = 0; i < 2*n; ++i) {\n            int idx = rnd.next(0, n - 1);\n            arch_words.push_back(lesha_words[idx]);\n        }\n    } else {\n        // Default to brand_new\n        generateUniqueWords(n, used_words, lesha_words);\n\n        int total_length = 500015;\n        int lesha_total_length = 0;\n        for (string& word : lesha_words) {\n            lesha_total_length += word.length();\n        }\n        total_length -= lesha_total_length;\n\n        for (int i = 0; i < m; ++i) {\n            vector<string>& arch_words = archive_problems[i];\n            int max_k = total_length / (m - i);\n            int k = rnd.next(1, min(1000, max_k));\n            total_length -= k;\n            generateArchiveProblem(k, used_words, arch_words, false);\n        }\n    }\n\n    // Output\n    printf(\"%d\\n\", n);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%s\", lesha_words[i].c_str());\n        if (i + 1 < n) {\n            printf(\" \");\n        }\n    }\n    printf(\"\\n\");\n\n    printf(\"%d\\n\", m);\n    for (int i = 0; i < m; ++i) {\n        vector<string>& arch_words = archive_problems[i];\n        printf(\"%d\", (int)arch_words.size());\n        for (int j = 0; j < arch_words.size(); ++j) {\n            printf(\" %s\", arch_words[j].c_str());\n        }\n        printf(\"\\n\");\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -m 1 -type brand_new\n./gen -n 5 -m 1 -type brand_new\n./gen -n 10 -m 2 -type brand_new\n./gen -n 15 -m 10 -type brand_new\n\n./gen -n 5 -m 1 -type full_match\n./gen -n 10 -m 1 -type full_match\n./gen -n 15 -m 10 -type full_match\n\n./gen -n 5 -m 1 -type reverse_order\n./gen -n 10 -m 2 -type reverse_order\n./gen -n 15 -m 5 -type reverse_order\n\n./gen -n 5 -m 1 -type min_inversions\n./gen -n 10 -m 1 -type min_inversions\n./gen -n 15 -m 2 -type min_inversions\n\n./gen -n 5 -m 1 -type large_archive\n./gen -n 10 -m 1 -type large_archive\n./gen -n 15 -m 1 -type large_archive\n\n./gen -n 15 -m 10 -type max_total_length\n\n./gen -n 15 -m 10 -type repeated_words\n\n./gen -n 15 -m 5 -type tie_breaking\n\n./gen -n 5 -m 3 -type tie_breaking\n\n./gen -n 10 -m 5 -type tie_breaking\n\n./gen -n 15 -m 10 -type tie_breaking\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T19:48:08.197035",
        "total_tutorials": 3,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "201/E",
      "title": "E. Thoroughly Bureaucratic Organization",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains a single integer t (1 ≤ t ≤ 1000) — the number of test cases. Each of the following t lines contains two integers n and m (1 ≤ n, m ≤ 109) — the number of people who have got an appointment at TBO and the number of empty lines in the request form, correspondingly.",
      "output_spec": "OutputPrint t lines, each containing an answer for the corresponding test case (in the order they are given in the input) — the minimum number of requests to submit to TBO.",
      "sample_tests": "ExamplesInputCopy54 14 27 31 142 7OutputCopy323011",
      "description": "E. Thoroughly Bureaucratic Organization\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains a single integer t (1 ≤ t ≤ 1000) — the number of test cases. Each of the following t lines contains two integers n and m (1 ≤ n, m ≤ 109) — the number of people who have got an appointment at TBO and the number of empty lines in the request form, correspondingly.\n\nOutputPrint t lines, each containing an answer for the corresponding test case (in the order they are given in the input) — the minimum number of requests to submit to TBO.\n\nInputCopy54 14 27 31 142 7OutputCopy323011\n\nInputCopy54 14 27 31 142 7\n\nOutputCopy323011\n\nNoteIn the first sample, you need to submit three requests to TBO with three different names. When you learn the appointment dates of three people out of four, you can find out the fourth person's date by elimination, so you do not need a fourth request.In the second sample you need only two requests. Let's number the persons from 1 to 4 and mention persons 1 and 2 in the first request and persons 1 and 3 in the second request. It is easy to see that after that we can clearly determine each person's appointment date regardless of the answers obtained from TBO.In the fourth sample only one person signed up for an appointment. He doesn't need to submit any requests — his appointment date is tomorrow.",
      "solutions": [
        {
          "title": "Codeforces Round #127 - Codeforces",
          "content": "Hello everyone!As many of you already know, today is the day for Codeforces Round #127 missing which is really undesirable ;)Original problems for you were created by tourist and Romka. We tried to emphasize the ideological component of the problems, thus we hope that you'll spend more time thinking than coding. Special thanks for helping in setting the contest go to Codeforces coordinator Gerald. We also thank Delinur for translating the problem statements and Alex_KPR for reviewing them.We hope that this round won't be just a regular Codeforces round for you, but will bring you new experience and new knowledge. For the authors all problems are equally easy, yet we tried to arrange them in decreasing order of simplicity :)Problems' point values in Division 1 are 1000-1000-1500-2000-2500. Problems' point values in Division 2 are 500-1000-2000-2000-2500.Wish you success!UPD: The contest is over, thanks all for participating. We hope you enjoyed it :)In Division 1 rng_58 was a clear winner, solving all 5 problems in an hour and a half! No one else managed to solve all problems in two hours.The winners in Division 1 are (full results): rng_58 peter50216 liympanda White_Bear havaliza In Division 2 every problem was solved by somebody, but nobody managed to solve all problems. The battle was very tough and the gaps were very small.The winners in Division 2 are (full results): Leewings snow_lotus 72VanVector_SevNTU Congratulations to the winners!UPD2: The editorial is available now.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/4796",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1501
        },
        {
          "title": "Codeforces Round #127 — editorial - Codeforces",
          "content": "Problem A(div 2) — LLPSIt's assumed that this problem can be solved just looking at the samples and without reading the statement itself :)Let's find the letter in the given string which comes last in the alphabet, denote this letter by z. If this letter occurs p times in the given string, then the answer is string a consisting of letter z repeated p times.Why is it so? Using the definition of lexicographical comparison and the fact that z is the largest letter in the string it's easy to understand that if some other subsequence b of the given string is lexicographically larger than a, then string b should be longer than a and, moreover, a should be a prefix of b (that is, b should start with a). But string b must be a palindrome, therefore its last letter must be z. In this case string b must contain more occurrences of letter z than the original string s does, which is impossible as b is a subsequence of s.Besides that, the constraint on the length of the string was very low, so the problem could be solved using brute force. For every subsequence of the given string it's necessary to check whether it's a palindrome, and from all palindromic subsequences of s the lexicographically largest should be chosen as the answer. The complexity of such a solution is O(2n·n), where n is the length of the string (unlike the solution above with complexity O(n)).Problem В(div 2) — Brand New Easy ProblemThe constraints in this problem were so low that a solution with complexity O(m·kn) was just fine. In each problem's description it's enough to loop over all possible subsequences of words which are permutations of words in Lesha's problem, for each of them calculate the number of inversions and choose a permutation with the smallest number of inversions. This can result in a short solution using recursion or, for example, you can use several nested loops (from 1 to 4).Here is an example of pseudocode for n = 4: w - array of words of Lesha''s problem\ns - the description of the current problem\nbest = 100\nfor a = 1 to k do\n for b = 1 to k do\n for c = 1 to k do\n for d = 1 to k do\n if s[a] == w[1] and s[b] == w[2] and s[c] == w[3] and s[d] == w[4] then\n inversions = 0\n if a > b then inversions = inversions + 1\n if a > c then inversions = inversions + 1\n if a > d then inversions = inversions + 1\n if b > c then inversions = inversions + 1\n if b > d then inversions = inversions + 1\n if c > d then inversions = inversions + 1\n if inversions < best then\n best = inversionsAt the end you should choose the problem with the smallest value of best and print the answer in the corresponding form.Problem A(div 1)/C(div 2) — Clear SymmetryIt's interesting that originally the authors had an idea not to include the x = 3 case into pretests. Imagine the number of successful hacking attempts in this contest -- considering the fact that none of the first 43 solutions to this problem passed pretests :)Note that the sought n is always an odd number. Indeed, if n is even, then two central rows of matrix A must contain zeroes, otherwise there will exist two neighbouring cells containing ones. Similar restriction applies to two central columns of matrix A. Replacing two central rows with just one and two central columns with just one and leaving zeroes in them, we'll obtain a smaller matrix with the same sharpness.Note that the sharpness of a matrix with side n can't exceed . It's easy to see that it's possible to lay out \"domino pieces\" 1 by 2 without intersections on a field with side n (in other words, all cells except one can be divided into pairs so that each pair contains neighbouring cells). Then there can be at most one one in the cells under each \"domino piece\" in the corresponding matrix. Therefore, the total number of ones doesn't exceed .Note that a matrix with side n and sharpness exists for an odd n. Paint all cells of the matrix in chess order and put ones into black cells and zeroes into white cells. It's easy to see that such a matrix is both clear and symmetrical and has sharpenss exactly .Intuitively it seems that if there exists a matrix with sharpness there should also exist a matrix with every smaller sharpness. That's correct except only one case -- there doesn't exist a matrix with side 3 and sharpness 3, though there exists a matrix with side 3 and sharpness 5.Let's show that the claim above is correct for odd n ≥ 5. We'll build a matrix with sharpness as shown above and gradually turn ones into zeroes reducing the sharpness. Cells containing ones in the matrix can be divided into three types.The first type is the central cell. The number in it can be turned into zero and the matrix won't stop satisfying the required conditions.The second type is the cells in the central row and the central column (except central cell). Such cells are divided into pairs by the condition of symmetry -- if we turn the number in one of them into zero, we should turn the number in its pair cell into zero as well.The third type is all the other cells. Such cells are divided into groups of four by the condition of symmetry -- if we turn the number in one of them into zero, we should turn the number in all cells from this group into zero as well.Now for obtaining the required sharpness of x we'll act greedily. Let's turn ones into zeroes in third type cells by four until the current shapness exceeds x by less than 4 or there are no third type cells with ones remaining. After that let's turn ones into zeroes in second type cells by pairs while the current sharpness exceeds x by at least 2. At this moment the sharpness of our matrix is either x or x + 1. If it's equal to x + 1, let's put a zero into the central cell and obtain a matrix with sharpness x. It's easy to check that we'll be able to obtain a matrix with any sharpness acting this way.Why is this reasoning incorrect for n = 3? Because second type cells are absent in the matrix with sharpness 5 obtained from chess coloring. For n ≥ 5 this matrix contains cells of all types, which is important for the algorithm above. It's better to find the answers for x ≤ 5 by hand but carefully -- for example, a lot of contestants decided that the answer for x = 2 is 5 instead of 3.Problem В(div 1)/D(div 2) — Guess That Car!We need to find such x and y that the value of is minimum possible. This expression can be rewritten as . Note that the first part doesn't depend on y and the second part doesn't depend on x, so we can minimize these parts separately. Here is how to minimize , the second part is minimized similarly. As the expression in the brackets doesn't depend on j, this part can be rewritten as , where . Now it's enough to calculate the required value for all possible values of x and choose x for which this value is the smallest. The optimal value of y can be found similarly.The overall complexity of this solution is O(n·m + n2 + m2).As the objective function is convex, other approaches to this problem are possible, for example, ternary search, gradient descent or analytical approach (calculation of derivatives).The main hero of this problem is Ra16bit.Problem С(div 1)/E(div 2) — Fragile BridgesThere are a few different ways to solve this problem, the editorial contains one of them.For any solution the following fact is useful. Suppose the sought path starts on platform i and ends on platform j (i ≤ j, if that's not the case, we can reverse the path). Then all bridges between platforms i and j will be passed through an odd number of times, and all other bridges will be passed through an even number of times.Let's find the maximum length of a path with its ends on platforms i and j. To do that, let's find the following auxiliary values for each platform: lefti -- the maximum length of a path starting and ending on platform i and passing only through bridges to the left of platform i; rightj -- similarly for bridges to the right of platform j. Also for each bridge define oddi as the largest odd number not larger than ai, and for each platform define sumOddi as the sum of oddj for all bridges to the left of platform i.Then the maximum length of a path with its ends on platforms i and j is equal to lefti + rightj + (sumOddj - sumOddi), or, which is the same, (rightj + sumOddj) + (lefti - sumOddi).Now we can find the pair (i, j) for which this value is the largest in linear time. Let's loop over j. From the formula it's obvious that we should find such i ≤ j that (lefti - sumOddi) is the largest. If we loop over j from 1 to n, we can maintain the largest value of this expression for all i ≤ j and recalculate it when moving to the next j, comparing (leftj - sumOddj) with the current maximum and possibly updating this maximum. This way for each j we have to check only one value of i and not all i ≤ j.The last thing to show is how to find all lefti quickly (all rightj can be found similarly). Clearly left1 = 0, then we'll calculate lefti using lefti - 1. Note that when ai - 1 = 1, we have lefti = 0 as after passing the bridge to platform (i - 1) this bridge will collapse and it will be impossible to return to platform i. If ai - 1 > 1, then lefti = lefti - 1 + eveni - 1, where eveni - 1 is the largest even number not larger than ai - 1. Indeed, we can move to platform (i - 1), then move along the path corresponding to lefti - 1, and then move along the bridge between platforms (i - 1) and i until the limit on the number of transitions is less than 2 (finishing on platform i).The overall complexity of this solution is O(n).Problem D(div 1) — Brand New ProblemThe first solution coming to mind is dynamic programming f[i][j] =  (the smallest possible number of inversions to the moment if among the first j words of the archive problem we've found a permutation of words included in bitmask i). In this solution parameter j varies from 0 to 500000, parameter i varies from 0 to 215 - 1 and calculation of each value is possible in O(1) (we are either using the current word in the subsequence or not). That's too much.Let's make use of a standard technique: make the value of DP a new parameter and make one of the existing parameters the value of DP. Not for every DP this is possible, but at least it's possible for this one :)It's clear that with a fixed subset of words and a fixed number of inversions it's optimal to choose the first occurrences of these words giving this number of inversions. Let f[i][j] =  (the smallest number z such that among first z words of the archive problem there exists a permutation of words from bitmask i containing exactly j inversions). The basis of this DP is f[0][0] = 0, f[0][j] = ∞ for j > 0. Recalculation of values happens in the following way: loop over a word q from the bitmask i which was the last in the permutation. With the knowledge of this word and the number of inversions j it's easy to find how many inversions j' there were without this word — that's j minus the number of words in the mask which appeared later in Lesha's problem than word q. Let p = f[i^(1«q)][j']. Then we should consider p2 equal to the position of the next occurrence of word q after position p as a possible value for f[i][j]. To find p2 quickly we should fill an array next[500010][15] so that next[i][j] =  (the smallest position k > i such that the k-th word in the archive problem equals the j-th word in Lesha's problem) for each archive problem in advance. This array can be easily filled passing from right to left once.The total number of operations can be calculated as m·(k·n + 2n·Cn2·n), where m is the number of problems in the archive, k is the number of words in one archive problem description and n is the number of words in Lesha's problem description. Under the given constraints that is about 200 million operations, and the author's solutions (including a Java solution) worked for less than 2 seconds. The time limit was set with a margin -- 5 seconds.The main heroes of problems D(div 1) and B(div 2) are Chmel_Tolstiy and ivan.metelsky.Problem E(div 1) — Thoroughly Bureaucratic OrganizationLet's imagine that we have a magic function maxN(m, k) that returns, given m and k, the largest value of n such that it's possible to solve the problem for n people and m empty lines in the form using k requests. Then we'll be able to use binary search on the answer -- the number of requests k.Suppose we've made k requests. Let's match a string of length k to each person, where the i-th character is equal to 1 if this person is mentioned in the i-th request and 0 otherwise. Note that we'll be able to determine the exact appointment date for each person if and only if all n strings of length k are pairwise distinct. Indeed, if two persons' strings are the same, their appointment dates could be exchanged and the responses to the requests wouldn't have changed. If all strings are distinct, for each date we may find the person appointed for this date looking at the set of requests with responses containing this date and finding the person mentioned in the same set of requests.The constraint on m empty lines in the form means that each of k positions in the strings should contain no more than m ones in all n strings overall. Thus function maxN(m, k) should return the maximum size of a set of distinct k-bit strings meeting this condition. Let's make this restriction weaker: we'll search for a set such that the total number of ones in all n strings doesn't exceed k·m. As we'll prove later, the answer won't change.With this weaker restriction the problem can be solved using a simple greedy strategy. It's obvious that strings with smaller number of ones are better. Let's loop over the number of ones i in the string from 0 to k and also maintain a variable t containing the remaining number of ones (initially it's equal to k·m). Then at the i-th step we can take at most strings containing i ones. Let's add p to the answer and subtract p·i from t. Note that the values of Cki should be calculated with care -- they can turn out to be too large, so it's important not to allow overflows.It can be shown that the overall complexity of this algorithm is at most O(log2 n).The remaining thing is to prove the claim above. The idea of the proof below belongs to rng_58 (the author's proof is notably harder).Let's solve the problem with a greedy algorithm with the k·m constraint on the total number of ones. The resulting set of strings may not satisfy the restriction of m ones for each position. If it doesn't, some of the positions contain more than m ones and some contain less than m ones. Let's pick any position X containing more than m ones and any position Y containing less than m ones. Find all strings containing 1 at X and 0 at Y (suppose there are x such strings) and all strings containing 0 at X and 1 at Y (suppose there are y such strings). It's clear that x > y. In each of x strings we can try to put 0 at X and 1 at Y -- then the string we obtain will either remain unique in this set or coincide with one of those y strings (but only one). As x > y, for at least one of x strings the change above leaves this string unique. Let's take this string and put 0 at X and 1 at Y. Now position X contains one 1 less, and position Y contains one 1 more. It means that the total number of \"extra\" ones in the positions has been decreased (as Y still contains no more than m ones). Doing this operation for a needed number of times, we'll achieve our goal.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/4808",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 15409
        },
        {
          "title": "Codeforces Round #127 — editorial - Codeforces",
          "content": "Problem A(div 2) — LLPSIt's assumed that this problem can be solved just looking at the samples and without reading the statement itself :)Let's find the letter in the given string which comes last in the alphabet, denote this letter by z. If this letter occurs p times in the given string, then the answer is string a consisting of letter z repeated p times.Why is it so? Using the definition of lexicographical comparison and the fact that z is the largest letter in the string it's easy to understand that if some other subsequence b of the given string is lexicographically larger than a, then string b should be longer than a and, moreover, a should be a prefix of b (that is, b should start with a). But string b must be a palindrome, therefore its last letter must be z. In this case string b must contain more occurrences of letter z than the original string s does, which is impossible as b is a subsequence of s.Besides that, the constraint on the length of the string was very low, so the problem could be solved using brute force. For every subsequence of the given string it's necessary to check whether it's a palindrome, and from all palindromic subsequences of s the lexicographically largest should be chosen as the answer. The complexity of such a solution is O(2n·n), where n is the length of the string (unlike the solution above with complexity O(n)).Problem В(div 2) — Brand New Easy ProblemThe constraints in this problem were so low that a solution with complexity O(m·kn) was just fine. In each problem's description it's enough to loop over all possible subsequences of words which are permutations of words in Lesha's problem, for each of them calculate the number of inversions and choose a permutation with the smallest number of inversions. This can result in a short solution using recursion or, for example, you can use several nested loops (from 1 to 4).Here is an example of pseudocode for n = 4: w - array of words of Lesha''s problem\ns - the description of the current problem\nbest = 100\nfor a = 1 to k do\n for b = 1 to k do\n for c = 1 to k do\n for d = 1 to k do\n if s[a] == w[1] and s[b] == w[2] and s[c] == w[3] and s[d] == w[4] then\n inversions = 0\n if a > b then inversions = inversions + 1\n if a > c then inversions = inversions + 1\n if a > d then inversions = inversions + 1\n if b > c then inversions = inversions + 1\n if b > d then inversions = inversions + 1\n if c > d then inversions = inversions + 1\n if inversions < best then\n best = inversionsAt the end you should choose the problem with the smallest value of best and print the answer in the corresponding form.Problem A(div 1)/C(div 2) — Clear SymmetryIt's interesting that originally the authors had an idea not to include the x = 3 case into pretests. Imagine the number of successful hacking attempts in this contest -- considering the fact that none of the first 43 solutions to this problem passed pretests :)Note that the sought n is always an odd number. Indeed, if n is even, then two central rows of matrix A must contain zeroes, otherwise there will exist two neighbouring cells containing ones. Similar restriction applies to two central columns of matrix A. Replacing two central rows with just one and two central columns with just one and leaving zeroes in them, we'll obtain a smaller matrix with the same sharpness.Note that the sharpness of a matrix with side n can't exceed . It's easy to see that it's possible to lay out \"domino pieces\" 1 by 2 without intersections on a field with side n (in other words, all cells except one can be divided into pairs so that each pair contains neighbouring cells). Then there can be at most one one in the cells under each \"domino piece\" in the corresponding matrix. Therefore, the total number of ones doesn't exceed .Note that a matrix with side n and sharpness exists for an odd n. Paint all cells of the matrix in chess order and put ones into black cells and zeroes into white cells. It's easy to see that such a matrix is both clear and symmetrical and has sharpenss exactly .Intuitively it seems that if there exists a matrix with sharpness there should also exist a matrix with every smaller sharpness. That's correct except only one case -- there doesn't exist a matrix with side 3 and sharpness 3, though there exists a matrix with side 3 and sharpness 5.Let's show that the claim above is correct for odd n ≥ 5. We'll build a matrix with sharpness as shown above and gradually turn ones into zeroes reducing the sharpness. Cells containing ones in the matrix can be divided into three types.The first type is the central cell. The number in it can be turned into zero and the matrix won't stop satisfying the required conditions.The second type is the cells in the central row and the central column (except central cell). Such cells are divided into pairs by the condition of symmetry -- if we turn the number in one of them into zero, we should turn the number in its pair cell into zero as well.The third type is all the other cells. Such cells are divided into groups of four by the condition of symmetry -- if we turn the number in one of them into zero, we should turn the number in all cells from this group into zero as well.Now for obtaining the required sharpness of x we'll act greedily. Let's turn ones into zeroes in third type cells by four until the current shapness exceeds x by less than 4 or there are no third type cells with ones remaining. After that let's turn ones into zeroes in second type cells by pairs while the current sharpness exceeds x by at least 2. At this moment the sharpness of our matrix is either x or x + 1. If it's equal to x + 1, let's put a zero into the central cell and obtain a matrix with sharpness x. It's easy to check that we'll be able to obtain a matrix with any sharpness acting this way.Why is this reasoning incorrect for n = 3? Because second type cells are absent in the matrix with sharpness 5 obtained from chess coloring. For n ≥ 5 this matrix contains cells of all types, which is important for the algorithm above. It's better to find the answers for x ≤ 5 by hand but carefully -- for example, a lot of contestants decided that the answer for x = 2 is 5 instead of 3.Problem В(div 1)/D(div 2) — Guess That Car!We need to find such x and y that the value of is minimum possible. This expression can be rewritten as . Note that the first part doesn't depend on y and the second part doesn't depend on x, so we can minimize these parts separately. Here is how to minimize , the second part is minimized similarly. As the expression in the brackets doesn't depend on j, this part can be rewritten as , where . Now it's enough to calculate the required value for all possible values of x and choose x for which this value is the smallest. The optimal value of y can be found similarly.The overall complexity of this solution is O(n·m + n2 + m2).As the objective function is convex, other approaches to this problem are possible, for example, ternary search, gradient descent or analytical approach (calculation of derivatives).The main hero of this problem is Ra16bit.Problem С(div 1)/E(div 2) — Fragile BridgesThere are a few different ways to solve this problem, the editorial contains one of them.For any solution the following fact is useful. Suppose the sought path starts on platform i and ends on platform j (i ≤ j, if that's not the case, we can reverse the path). Then all bridges between platforms i and j will be passed through an odd number of times, and all other bridges will be passed through an even number of times.Let's find the maximum length of a path with its ends on platforms i and j. To do that, let's find the following auxiliary values for each platform: lefti -- the maximum length of a path starting and ending on platform i and passing only through bridges to the left of platform i; rightj -- similarly for bridges to the right of platform j. Also for each bridge define oddi as the largest odd number not larger than ai, and for each platform define sumOddi as the sum of oddj for all bridges to the left of platform i.Then the maximum length of a path with its ends on platforms i and j is equal to lefti + rightj + (sumOddj - sumOddi), or, which is the same, (rightj + sumOddj) + (lefti - sumOddi).Now we can find the pair (i, j) for which this value is the largest in linear time. Let's loop over j. From the formula it's obvious that we should find such i ≤ j that (lefti - sumOddi) is the largest. If we loop over j from 1 to n, we can maintain the largest value of this expression for all i ≤ j and recalculate it when moving to the next j, comparing (leftj - sumOddj) with the current maximum and possibly updating this maximum. This way for each j we have to check only one value of i and not all i ≤ j.The last thing to show is how to find all lefti quickly (all rightj can be found similarly). Clearly left1 = 0, then we'll calculate lefti using lefti - 1. Note that when ai - 1 = 1, we have lefti = 0 as after passing the bridge to platform (i - 1) this bridge will collapse and it will be impossible to return to platform i. If ai - 1 > 1, then lefti = lefti - 1 + eveni - 1, where eveni - 1 is the largest even number not larger than ai - 1. Indeed, we can move to platform (i - 1), then move along the path corresponding to lefti - 1, and then move along the bridge between platforms (i - 1) and i until the limit on the number of transitions is less than 2 (finishing on platform i).The overall complexity of this solution is O(n).Problem D(div 1) — Brand New ProblemThe first solution coming to mind is dynamic programming f[i][j] =  (the smallest possible number of inversions to the moment if among the first j words of the archive problem we've found a permutation of words included in bitmask i). In this solution parameter j varies from 0 to 500000, parameter i varies from 0 to 215 - 1 and calculation of each value is possible in O(1) (we are either using the current word in the subsequence or not). That's too much.Let's make use of a standard technique: make the value of DP a new parameter and make one of the existing parameters the value of DP. Not for every DP this is possible, but at least it's possible for this one :)It's clear that with a fixed subset of words and a fixed number of inversions it's optimal to choose the first occurrences of these words giving this number of inversions. Let f[i][j] =  (the smallest number z such that among first z words of the archive problem there exists a permutation of words from bitmask i containing exactly j inversions). The basis of this DP is f[0][0] = 0, f[0][j] = ∞ for j > 0. Recalculation of values happens in the following way: loop over a word q from the bitmask i which was the last in the permutation. With the knowledge of this word and the number of inversions j it's easy to find how many inversions j' there were without this word — that's j minus the number of words in the mask which appeared later in Lesha's problem than word q. Let p = f[i^(1«q)][j']. Then we should consider p2 equal to the position of the next occurrence of word q after position p as a possible value for f[i][j]. To find p2 quickly we should fill an array next[500010][15] so that next[i][j] =  (the smallest position k > i such that the k-th word in the archive problem equals the j-th word in Lesha's problem) for each archive problem in advance. This array can be easily filled passing from right to left once.The total number of operations can be calculated as m·(k·n + 2n·Cn2·n), where m is the number of problems in the archive, k is the number of words in one archive problem description and n is the number of words in Lesha's problem description. Under the given constraints that is about 200 million operations, and the author's solutions (including a Java solution) worked for less than 2 seconds. The time limit was set with a margin -- 5 seconds.The main heroes of problems D(div 1) and B(div 2) are Chmel_Tolstiy and ivan.metelsky.Problem E(div 1) — Thoroughly Bureaucratic OrganizationLet's imagine that we have a magic function maxN(m, k) that returns, given m and k, the largest value of n such that it's possible to solve the problem for n people and m empty lines in the form using k requests. Then we'll be able to use binary search on the answer -- the number of requests k.Suppose we've made k requests. Let's match a string of length k to each person, where the i-th character is equal to 1 if this person is mentioned in the i-th request and 0 otherwise. Note that we'll be able to determine the exact appointment date for each person if and only if all n strings of length k are pairwise distinct. Indeed, if two persons' strings are the same, their appointment dates could be exchanged and the responses to the requests wouldn't have changed. If all strings are distinct, for each date we may find the person appointed for this date looking at the set of requests with responses containing this date and finding the person mentioned in the same set of requests.The constraint on m empty lines in the form means that each of k positions in the strings should contain no more than m ones in all n strings overall. Thus function maxN(m, k) should return the maximum size of a set of distinct k-bit strings meeting this condition. Let's make this restriction weaker: we'll search for a set such that the total number of ones in all n strings doesn't exceed k·m. As we'll prove later, the answer won't change.With this weaker restriction the problem can be solved using a simple greedy strategy. It's obvious that strings with smaller number of ones are better. Let's loop over the number of ones i in the string from 0 to k and also maintain a variable t containing the remaining number of ones (initially it's equal to k·m). Then at the i-th step we can take at most strings containing i ones. Let's add p to the answer and subtract p·i from t. Note that the values of Cki should be calculated with care -- they can turn out to be too large, so it's important not to allow overflows.It can be shown that the overall complexity of this algorithm is at most O(log2 n).The remaining thing is to prove the claim above. The idea of the proof below belongs to rng_58 (the author's proof is notably harder).Let's solve the problem with a greedy algorithm with the k·m constraint on the total number of ones. The resulting set of strings may not satisfy the restriction of m ones for each position. If it doesn't, some of the positions contain more than m ones and some contain less than m ones. Let's pick any position X containing more than m ones and any position Y containing less than m ones. Find all strings containing 1 at X and 0 at Y (suppose there are x such strings) and all strings containing 0 at X and 1 at Y (suppose there are y such strings). It's clear that x > y. In each of x strings we can try to put 0 at X and 1 at Y -- then the string we obtain will either remain unique in this set or coincide with one of those y strings (but only one). As x > y, for at least one of x strings the change above leaves this string unique. Let's take this string and put 0 at X and 1 at Y. Now position X contains one 1 less, and position Y contains one 1 more. It means that the total number of \"extra\" ones in the positions has been decreased (as Y still contains no more than m ones). Doing this operation for a needed number of times, we'll achieve our goal.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/4808",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 15409
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #127 - Codeforces - Code 1",
          "code": "1 0 0\n0 1 0\n1 0 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4796",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #127 - Codeforces - Code 2",
          "code": "1 0 0\n0 1 0\n1 0 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4796",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #127 - Codeforces - Code 3",
          "code": "0 0 1 0 0\n0 0 0 0 0\n0 0 1 0 0\n0 0 0 0 0\n0 0 1 0 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4796",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #127 - Codeforces - Code 4",
          "code": "0 0 1 0 0\n0 0 0 0 0\n0 0 1 0 0\n0 0 0 0 0\n0 0 1 0 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4796",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #127 - Codeforces - Code 5",
          "code": "0 1 0\n0 0 0\n0 1 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4796",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #127 - Codeforces - Code 6",
          "code": "0 1 0\n0 0 0\n0 1 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4796",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #127 - Codeforces - Code 7",
          "code": "0 1 0\n0 0 0\n0 1 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4796",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #127 - Codeforces - Code 8",
          "code": "0 1 0\n0 0 0\n0 1 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4796",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #127 — editorial - Codeforces - Code 1",
          "code": "w - array of words of Lesha''s problem\ns - the description of the current problem\nbest = 100\nfor a = 1 to k do\n    for b = 1 to k do\n        for c = 1 to k do\n            for d = 1 to k do\n                if s[a] == w[1] and s[b] == w[2] and s[c] == w[3] and s[d] == w[4] then\n                    inversions = 0\n                    if a > b then inversions = inversions + 1\n                    if a > c then inversions = inversions + 1\n                    if a > d then inversions = inversions + 1\n                    if b > c then inversions = inversions + 1\n                    if b > d then inversions = inversions + 1\n                    if c > d then inversions = inversions + 1\n                    if inversions < best then\n                        best = inversions",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4808",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #127 — editorial - Codeforces - Code 2",
          "code": "w - array of words of Lesha''s problem\ns - the description of the current problem\nbest = 100\nfor a = 1 to k do\n    for b = 1 to k do\n        for c = 1 to k do\n            for d = 1 to k do\n                if s[a] == w[1] and s[b] == w[2] and s[c] == w[3] and s[d] == w[4] then\n                    inversions = 0\n                    if a > b then inversions = inversions + 1\n                    if a > c then inversions = inversions + 1\n                    if a > d then inversions = inversions + 1\n                    if b > c then inversions = inversions + 1\n                    if b > d then inversions = inversions + 1\n                    if c > d then inversions = inversions + 1\n                    if inversions < best then\n                        best = inversions",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4808",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #127 — editorial - Codeforces - Code 3",
          "code": "REP(mask,(1<<15)) REP(i,15) for(j=i;j<15;j++) if(mask&(1<<j)) cost[mask][i]++;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4808",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #127 — editorial - Codeforces - Code 1",
          "code": "w - array of words of Lesha''s problem\ns - the description of the current problem\nbest = 100\nfor a = 1 to k do\n    for b = 1 to k do\n        for c = 1 to k do\n            for d = 1 to k do\n                if s[a] == w[1] and s[b] == w[2] and s[c] == w[3] and s[d] == w[4] then\n                    inversions = 0\n                    if a > b then inversions = inversions + 1\n                    if a > c then inversions = inversions + 1\n                    if a > d then inversions = inversions + 1\n                    if b > c then inversions = inversions + 1\n                    if b > d then inversions = inversions + 1\n                    if c > d then inversions = inversions + 1\n                    if inversions < best then\n                        best = inversions",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4808",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #127 — editorial - Codeforces - Code 2",
          "code": "w - array of words of Lesha''s problem\ns - the description of the current problem\nbest = 100\nfor a = 1 to k do\n    for b = 1 to k do\n        for c = 1 to k do\n            for d = 1 to k do\n                if s[a] == w[1] and s[b] == w[2] and s[c] == w[3] and s[d] == w[4] then\n                    inversions = 0\n                    if a > b then inversions = inversions + 1\n                    if a > c then inversions = inversions + 1\n                    if a > d then inversions = inversions + 1\n                    if b > c then inversions = inversions + 1\n                    if b > d then inversions = inversions + 1\n                    if c > d then inversions = inversions + 1\n                    if inversions < best then\n                        best = inversions",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4808",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #127 — editorial - Codeforces - Code 3",
          "code": "REP(mask,(1<<15)) REP(i,15) for(j=i;j<15;j++) if(mask&(1<<j)) cost[mask][i]++;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4808",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int t = inf.readInt(1, 1000, \"t\");\n    inf.readEoln();\n    for (int test = 0; test < t; ++test) {\n        int n = inf.readInt(1, 1000000000, \"n\");\n        inf.readSpace();\n        int m = inf.readInt(1, 1000000000, \"m\");\n        inf.readEoln();\n    }\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int t = inf.readInt(1, 1000, \"t\");\n    inf.readEoln();\n    for (int test = 0; test < t; ++test) {\n        int n = inf.readInt(1, 1000000000, \"n\");\n        inf.readSpace();\n        int m = inf.readInt(1, 1000000000, \"m\");\n        inf.readEoln();\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int t = inf.readInt(1, 1000, \"t\");\n    inf.readEoln();\n    for (int test = 0; test < t; ++test) {\n        int n = inf.readInt(1, 1000000000, \"n\");\n        inf.readSpace();\n        int m = inf.readInt(1, 1000000000, \"m\");\n        inf.readEoln();\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int t = opt<int>(\"t\", 1);\n    string type = opt<string>(\"type\", \"random\");\n    long long n_param = opt<long long>(\"n\", -1);\n    long long m_param = opt<long long>(\"m\", -1);\n\n    printf(\"%d\\n\", t);\n\n    for (int i = 0; i < t; ++i) {\n        long long n, m;\n\n        if (n_param != -1) n = n_param;\n        if (m_param != -1) m = m_param;\n\n        if (type == \"max\") {\n            if (n_param == -1) n = 1000000000;\n            if (m_param == -1) m = 1000000000;\n        } else if (type == \"min\") {\n            if (n_param == -1) n = 1;\n            if (m_param == -1) m = 1;\n        } else if (type == \"n_equals_m\") {\n            long long x = rnd.next(1LL, 1000000000LL);\n            if (n_param == -1) n = x;\n            if (m_param == -1) m = x;\n        } else if (type == \"m_equals_1\") {\n            if (n_param == -1) n = rnd.next(1LL, 1000000000LL);\n            if (m_param == -1) m = 1;\n        } else if (type == \"n_equals_1\") {\n            if (n_param == -1) n = 1;\n            if (m_param == -1) m = rnd.next(1LL, 1000000000LL);\n        } else if (type == \"n_large_m_small\") {\n            if (n_param == -1) n = 1000000000;\n            if (m_param == -1) m = 1;\n        } else if (type == \"n_small_m_large\") {\n            if (n_param == -1) n = 1;\n            if (m_param == -1) m = 1000000000;\n        } else if (type == \"random\") {\n            if (n_param == -1) n = rnd.next(1LL, 1000000000LL);\n            if (m_param == -1) m = rnd.next(1LL, 1000000000LL);\n        } else if (type == \"special1\") {\n            if (n_param == -1) n = 999999937; // Large prime near 1e9\n            if (m_param == -1) m = 1;\n        } else if (type == \"special2\") {\n            if (n_param == -1) n = 1000000000;\n            if (m_param == -1) m = 999999937;\n        } else {\n            // Default random\n            if (n_param == -1) n = rnd.next(1LL, 1000000000LL);\n            if (m_param == -1) m = rnd.next(1LL, 1000000000LL);\n        }\n\n        // Ensure n and m are within bounds\n        n = max(1LL, min(n, 1000000000LL));\n        m = max(1LL, min(m, 1000000000LL));\n\n        printf(\"%lld %lld\\n\", n, m);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int t = opt<int>(\"t\", 1);\n    string type = opt<string>(\"type\", \"random\");\n    long long n_param = opt<long long>(\"n\", -1);\n    long long m_param = opt<long long>(\"m\", -1);\n\n    printf(\"%d\\n\", t);\n\n    for (int i = 0; i < t; ++i) {\n        long long n, m;\n\n        if (n_param != -1) n = n_param;\n        if (m_param != -1) m = m_param;\n\n        if (type == \"max\") {\n            if (n_param == -1) n = 1000000000;\n            if (m_param == -1) m = 1000000000;\n        } else if (type == \"min\") {\n            if (n_param == -1) n = 1;\n            if (m_param == -1) m = 1;\n        } else if (type == \"n_equals_m\") {\n            long long x = rnd.next(1LL, 1000000000LL);\n            if (n_param == -1) n = x;\n            if (m_param == -1) m = x;\n        } else if (type == \"m_equals_1\") {\n            if (n_param == -1) n = rnd.next(1LL, 1000000000LL);\n            if (m_param == -1) m = 1;\n        } else if (type == \"n_equals_1\") {\n            if (n_param == -1) n = 1;\n            if (m_param == -1) m = rnd.next(1LL, 1000000000LL);\n        } else if (type == \"n_large_m_small\") {\n            if (n_param == -1) n = 1000000000;\n            if (m_param == -1) m = 1;\n        } else if (type == \"n_small_m_large\") {\n            if (n_param == -1) n = 1;\n            if (m_param == -1) m = 1000000000;\n        } else if (type == \"random\") {\n            if (n_param == -1) n = rnd.next(1LL, 1000000000LL);\n            if (m_param == -1) m = rnd.next(1LL, 1000000000LL);\n        } else if (type == \"special1\") {\n            if (n_param == -1) n = 999999937; // Large prime near 1e9\n            if (m_param == -1) m = 1;\n        } else if (type == \"special2\") {\n            if (n_param == -1) n = 1000000000;\n            if (m_param == -1) m = 999999937;\n        } else {\n            // Default random\n            if (n_param == -1) n = rnd.next(1LL, 1000000000LL);\n            if (m_param == -1) m = rnd.next(1LL, 1000000000LL);\n        }\n\n        // Ensure n and m are within bounds\n        n = max(1LL, min(n, 1000000000LL));\n        m = max(1LL, min(m, 1000000000LL));\n\n        printf(\"%lld %lld\\n\", n, m);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -t 1 -type min\n./gen -t 1 -type max\n./gen -t 1 -type n_equals_m\n./gen -t 1 -type n_equals_1\n./gen -t 1 -type m_equals_1\n./gen -t 1 -type n_large_m_small\n./gen -t 1 -type n_small_m_large\n./gen -t 1 -type random\n\n./gen -t 1000 -type random\n\n./gen -t 10 -type n_equals_m\n\n./gen -t 5 -type special1\n./gen -t 5 -type special2\n\n./gen -t 1 -n 1 -m 1\n./gen -t 1 -n 1000000000 -m 1000000000\n\n./gen -t 1 -n 1\n./gen -t 1 -m 1\n\n./gen -t 1 -n 500000000 -m 500000000\n\n./gen -t 1000 -type n_equals_m\n\n./gen -t 1 -n 1000000000 -m 1\n./gen -t 1 -n 1 -m 1000000000\n\n./gen -t 1 -n 999999937 -m 1\n\n./gen -t 1 -n 1000000000 -m 999999937\n\n./gen -t 1 -n 2 -m 1000000000\n\n./gen -t 1 -type random\n./gen -t 1 -type random\n./gen -t 1 -type random\n\n./gen -t 1 -type random -n 123456789 -m 987654321\n./gen -t 1 -type random -n 1000000000 -m 999999999\n./gen -t 1 -type random -n 1 -m 2\n./gen -t 1 -type random -n 2 -m 1\n\n./gen -t 1000 -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T19:48:10.104019",
        "total_tutorials": 3,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "202/A",
      "title": "A. ЛНПП",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест2 секунды",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеВ единственной строке записана непустая строка s, состоящая только из строчных букв латинского алфавита и имеющая длину не более 10.",
      "output_spec": "Выходные данныеВыведите лексикографически наибольшую подпоследовательность строки s, являющуюся палиндромом.",
      "sample_tests": "ПримерыВходные данныеСкопироватьradarВыходные данныеСкопироватьrrВходные данныеСкопироватьbowwowwowВыходные данныеСкопироватьwwwwwВходные данныеСкопироватьcodeforcesВыходные данныеСкопироватьsВходные данныеСкопироватьmississippВыходные данныеСкопироватьssss",
      "description": "ограничение по времени на тест2 секунды\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвыводstdout\n\nВходные данныеВ единственной строке записана непустая строка s, состоящая только из строчных букв латинского алфавита и имеющая длину не более 10.\n\nВходные данные\n\nВыходные данныеВыведите лексикографически наибольшую подпоследовательность строки s, являющуюся палиндромом.\n\nВыходные данные\n\nВходные данныеСкопироватьradarВыходные данныеСкопироватьrrВходные данныеСкопироватьbowwowwowВыходные данныеСкопироватьwwwwwВходные данныеСкопироватьcodeforcesВыходные данныеСкопироватьsВходные данныеСкопироватьmississippВыходные данныеСкопироватьssss\n\nВходные данныеСкопироватьradar\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопироватьrr\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопироватьbowwowwow\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопироватьwwwww\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопироватьcodeforces\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопироватьs\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопироватьmississipp\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопироватьssss\n\nВыходные данныеСкопировать\n\nСкопировать\n\nПримечаниеИз всех различных подпоследовательностей строки «radar» палиндромами являются «a», «d», «r», «aa», «rr», «ada», «rar», «rdr», «raar» и «radar». Лексикографически наибольшей из них является «rr».",
      "solutions": [
        {
          "title": "Codeforces Round #127 - Codeforces",
          "content": "Всем привет!Как многие из вас уже знают, сегодня в обоих дивизионах состоится Codeforces Round #127, пропускать который очень не рекомендуется ;)Оригинальные задачи для вас придумывали и готовили tourist и Romka. Мы старались сделать упор на идейную составляющую задач, поэтому надеемся, что вам придётся думать дольше, чем набирать код. Отдельное спасибо за помощь в подготовке контеста координатору Codeforces Gerald. Также благодарим Delinur за перевод условий и Alex_KPR за вычитку условий.Надеемся, что этот раунд будет для вас не просто очередным раундом на Codeforces, а принесёт вам новый опыт и новые знания. Авторам все задачи кажутся одинаково простыми, но мы всё-таки постарались расположить их в порядке убывания простоты :)Разбалловка в первом дивизионе: 1000-1000-1500-2000-2500. Разбалловка во втором дивизионе: 500-1000-2000-2000-2500.Успехов!UPD: Соревнование закончено, всем спасибо за участие. Надеемся, вам понравилось :)В первом дивизионе безоговорочную победу одержал rng_58, решив все пять задач за полтора часа! Решить все задачи за два часа больше не удалось никому.Победители в первом дивизионе (полные результаты): rng_58 peter50216 liympanda White_Bear havaliza Во втором дивизионе каждая задача была кем-то решена, но решить все задачи не удалось никому. Борьба оказалась очень упорной, а разрывы -- очень маленькими.Победители во втором дивизионе (полные результаты): Leewings snow_lotus 72VanVector_SevNTU Поздравляем победителей!UPD2: Опубликован разбор задач.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/4796",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 1493
        },
        {
          "title": "Codeforces Round #127 — разбор - Codeforces",
          "content": "Задача A(div 2) — ЛНПППредполагалось, что эту задачу можно решить, не читая её условия, а только глядя на примеры :)Найдём в заданной строке символ, который идёт в алфавите позже всех, обозначим его через z. Если этот символ встречается в строке p раз, то ответ — это строка a, состоящая из символа z, повторённого p раз.Почему это так? Из определения лексикографического сравнения и из того, что символ z — максимальный в строке, несложно понять, что если какая-то другая подпоследовательность b заданной строки лексикографически больше a, то строка b обязана иметь большую длину, чем a, и при этом a должна являться префиксом (началом) b. Однако строка b должна также быть палиндромом, поэтому последний её символ — обязательно z. В таком случае в строке b должно быть больше вхождений символа z, чем в исходной строке s, что невозможно, так как b --- подпоследовательность s.Кроме того, ограничение на длину строки было совсем небольшим, поэтому задачу можно было решить перебором всех подпоследовательностей строки. Для каждой из них нужно проверить, является ли она палиндромом, и из всех являющихся выбрать лексикографически наибольшую. Сложность такого решения составляет O(2n·n), где n — длина строки (в отличие от решения выше, сложность которого O(n)).Задача В(div 2) — Инновационно новая простая задачаОграничения в задаче были настолько малы, что проходило решение со сложностью O(m·kn). В описании каждой задачи достаточно перебрать все возможные подпоследовательности слов, являющиеся перестановками описания Лёшиной задачи, для каждой из них вычислить количество инверсий, и выбрать перестановку с минимальным количеством инверсий. Это можно сделать либо с помощью рекурсии, либо, например, с помощью необходимого количества вложенных циклов (от 1 до 4).Вот пример псевдокода для случая n = 4: w - массив слов задачи Лёши\ns - описание очередной задачи из архива\nbest = 100\nfor a = 1 to k do\n for b = 1 to k do\n for c = 1 to k do\n for d = 1 to k do\n if s[a] == w[1] and s[b] == w[2] and s[c] == w[3] and s[d] == w[4] then\n inversions = 0\n if a > b then inversions = inversions + 1\n if a > c then inversions = inversions + 1\n if a > d then inversions = inversions + 1\n if b > c then inversions = inversions + 1\n if b > d then inversions = inversions + 1\n if c > d then inversions = inversions + 1\n if inversions < best then\n best = inversionsВ конце нужно выбрать задачу с минимальным значением best и вывести ответ в соответствующем формате.Задача A(div 1)/C(div 2) — Чёткая симметрияИнтересно, что первоначально у авторов была идея не включать случай x = 3 в претесты. Представьте, сколько было бы в этом контесте сделано успешных взломов — при том, что из первых 43 решений по этой задаче ни одно претесты не прошло :)Заметим, что ответ n — всегда нечётное число. Действительно, если n чётно, то две центральные строки матрицы A обязаны содержать только нули — в противном случае найдутся две соседние клетки, содержащие единицы. Аналогичное требование относится и к двум центральным столбцам матрицы A. Заменив две центральные строки на одну и два центральных столбца на один, при этом оставив в них нули, получим матрицу с такой же остротой, но со стороной на единицу меньше.Заметим, что острота матрицы со стороной n не может превысить . Несложно убедиться, что на квадратное поле со стороной n можно выложить \"доминошек\" 1 на 2 так, чтобы \"доминошки\" не пересекались (иными словами, все клетки, кроме одной, можно разбить на пары так, что клетки в каждой паре имеют общую сторону). Тогда в соответствующей матрице под клетками, покрытыми одной \"доминошкой\", может располагаться не более одной единицы. Значит, общее количество единиц не превышает .Заметим, что матрица со стороной n и остротой при нечётном n существует. Раскрасим все клетки матрицы в шахматном порядке и в чёрные клетки поставим единицы, а в белые — нули. Несложно убедиться, что такая матрица является и чёткой, и симметричной, и при этом имеет остроту ровно .Интуитивно кажется, что раз существует матрица с остротой , то существует матрица и с любой меньшей остротой. Это верно всегда, кроме одного-единственного случая — не существует матрицы со стороной 3 и остротой 3, хотя и существует матрица со стороной 3 и остротой 5.Покажем, что утверждение выше верно при нечётных n ≥ 5. Построим матрицу с остротой , как показано выше, и будем постепенно превращать единицы в нули, уменьшая остроту. Клетки с единицами в матрице бывают трёх типов.Первый тип — центральная клетка. Она ровно одна, при этом можно превратить число в ней в ноль, и матрица не перестанет удовлетворять условию задачи.Второй тип — клетки в центральной строке и в центральном столбце (кроме центральной клетки). Такие клетки из условия симметричности разбиваются на пары — если мы заменяем значение в одной из них на ноль, мы обязаны также заменить на ноль значение в парной ей клетке.Третий тип — все остальные клетки. Из условия симметричности они разбиваются на четвёрки — если мы заменяем значение в некоторой клетке третьего типа на ноль, мы должны заменить на ноль значения во всех клетках той же четвёрки.Теперь для получения требуемой остроты x будем действовать жадно. Будем заменять единицы на нули в клетках третьего типа, делая это в четырёх клетках сразу, до тех пор, пока текущая острота превышает x как минимум на 4 и ещё есть клетки третьего типа с единицами. После этого начнём убирать клетки второго типа по парам, пока текущая острота превышает x хотя бы на 2. К этому моменту острота матрицы равна либо x, либо x + 1. Если она равна x + 1, поставим ноль в центральной клетке и получим матрицу с остротой x. Несложно проверить, что мы сможем получить матрицу любой остроты, действуя по этому жадному алгоритму.Почему такие же рассуждения не работают при n = 3? Потому что в матрице с остротой 5, полученной из шахматной раскраски, отсутствуют клетки второго типа. При n ≥ 5 в такой матрице присутствуют клетки всех типов, что и является залогом успеха. Ответы для x ≤ 5 лучше найти вручную, но аккуратно — например, многие участники решили, что при x = 2 ответ 5, а не 3.Задача В(div 1)/D(div 2) — Угадай автомобиль!Нам нужно найти такие x и y, при которых величина принимает минимальное возможное значение. Эту величину можно преобразовать к виду , и заметить, что поскольку левая часть не зависит от y, а правая от x, то можно минимизировать каждую из частей по отдельности. Рассмотрим, как минимизировать часть , вторая минимизируется аналогично. Поскольку выражение в скобках не зависит от j, эту часть можно переписать в виде , где . Теперь достаточно просто перебрать все возможные значения x, и вычислить для каждого из них искомую величину, после чего выбрать x, для которого это значение минимально. Точно так же находится оптимальное значение y.Итоговая сложность решения — O(n·m + n2 + m2).В силу выпуклости целевой функции возможны и другие подходы к решению задачи, например, градиентый спуск либо аналитический метод (вычисление производных).Главный действующий герой задачи — Ra16bit.Задача С(div 1)/E(div 2) — Хрупкие мостыЭту задачу можно решить несколькими способами, в разборе представлен один из них.Для любого решения полезно заметить следующий факт. Допустим, искомый путь начинается на платформе i и заканчивается на платформе j (i ≤ j, если это не так, можно поменять начало и конец пути местами). Тогда все мосты, находящиеся между платформами i и j, будут пройдены в этом пути нечётное число раз, а все остальные мосты — чётное число раз.Давайте найдём максимальную длину пути с концами на платформах i и j. Для этого для всех платформ найдём вспомогательные величины: lefti — максимальная длина пути, начинающегося и заканчивающегося на платформе i и при этом проходящего только по мостам левее платформы i; rightj — аналогично для мостов правее платформы j. Также для каждого моста определим oddi — наибольшее нечётное число, не превосходящее ai, и для каждой платформы определим sumOddi — сумму oddj по всем мостам левее платформы i.Тогда максимальная длина пути с концами на платформах i и j (i ≤ j) равна lefti + rightj + (sumOddj - sumOddi) или, что то же самое, (rightj + sumOddj) + (lefti - sumOddi).Теперь мы можем найти пару (i, j), для которых эта величина наибольшая, за линейное время. Переберём j. Из формулы очевидно, что нужно найти такое i ≤ j, что (lefti - sumOddi) максимально. Если перебирать j от 1 к n, то можно хранить текущее максимальное значение этой величины для всех i ≤ j и пересчитывать его при переходе к следующему j, сравнив (leftj - sumOddj) с текущим максимумом и, возможно, этот максимум обновив. Таким образом, для каждого j нужно проверять не все значения i ≤ j, а только одно.Осталось показать, как быстро искать все lefti (все rightj ищутся аналогично). Понятно, что left1 = 0, далее будем считать lefti, используя lefti - 1. Заметим, что если ai - 1 = 1, то lefti = 0, так как после перехода по мосту на платформу (i - 1) этот мост рухнет и вернуться на платформу i уже будет невозможно. Если же ai - 1 > 1, то lefti = lefti - 1 + eveni - 1, где eveni - 1 — наибольшее чётное число, не превосходящее ai - 1. Действительно, можно перейти по мосту на платформу (i - 1), проделать путь, соответствующий lefti - 1, а потом ходить по мосту между платформами (i - 1) и i, пока лимит на количество переходов не станет меньше 2 (при этом закончить нужно на платформе i).Таким образом, общая сложность этого решения — O(n).Задача D(div 1) — Инновационно новая задачаПервое решение, которое приходит на ум — рекуррентное соотношение f[i][j] =  (минимальное возможное количество инверсий, если среди первых j слов встречается перестановка слов, входящих в маску i). В таком решении параметр j изменяется от 0 до 500000, i — от 0 до 215 - 1, а пересчёт значений происходит за O(1) (либо используем очередное слово, либо нет). Это слишком много.Воспользуемся стандартным приёмом: перенесём значение соотношения в параметр, а один из параметров сделаем значением. Это можно сделать не для любого рекуррентного, но для этого как раз можно :)Понятно, что при фиксированном подмножестве слов и количестве инверсий оптимально выбрать самые ранние вхождения этих слов, которые дают такое количество инверсий. Пусть f[i][j] =  (минимальное число z такое, что среди первых z слов найдётся перестановка слов из маски i, содержащая в точности j инверсий). База — f[0][0] = 0, f[0][j] = ∞ для j > 0. Пересчёт значений происходит следующим образом: перебираем слово q из маски i, которое было последним. Зная это слово, и количество инверсий j, легко вычислить количество инверсий j', которое было без этого слова — это j минус количество слов в маске, больших q (по номеру в описании Лёшиной задачи). Пусть p = f[i^(1«q)][j']. Тогда в качестве очередного возможного значения для f[i][j] нужно рассмотреть индекс p2, равный позиции следующего вхождения слова q после позиции p. Для быстрого поиска таких значений необходимо заранее для каждой задачи из архива посчитать массив next[500010][15] такой, что next[i][j] = (минимальный индекс k > i такой, что k-е слово в описании текущей задачи равно j-му слову в описании задачи Лёши). Такой массив несложно посчитать за один проход справа налево.Суммарное количество операций можно вычислить по формуле m·(k·n + 2n·Cn2·n), где m — количество задач в архиве, k — количество слов в описании одной задачи, n — количество слов в описании задачи Лёши. При заданных ограничениях эта величина составляла около 200 миллионов, и авторские решения (включая решение на Java) работали не более двух секунд. TL был выставлен довольно-таки лояльно, 5 секунд.Главные действующие герои задач D(div 1) и B(div 2) — Chmel_Tolstiy и ivan.metelsky.Задача E(div 1) — Насквозь бюрократическая организацияДавайте представим, что у нас в распоряжении есть функция maxN(m, k), которая по заданным m и k возвращает максимальное значение n такое, что задачу для n людей и m пустых строчек в бланке можно решить за k запросов. Тогда можно применить бинарный поиск по ответу — количеству запросов k.Допустим, мы сделали какие-то k запросов. Сопоставим каждому из n человек строку из k бит, где i-ый бит равен единице, если этот человек был указан в i-ом запросе, и равен нулю в противном случае. Заметим, что мы сможем определить точную дату приёма для каждого человека в том и только в том случае, если всем n людям соответствуют попарно различные k-битовые строки. На самом деле, если двум людям соответствуют одинаковые строки, то они могли бы поменяться датами между собой и ответы на запросы не изменились бы. Если же всем людям соответствуют разные строки, для каждой даты можно определить, кто именно записан на эту дату, рассмотрев множество запросов, в ответах на которые эта дата фигурирует, и найдя человека, который указан ровно в том же множестве запросов.Ограничение в m пустых строчек в бланке означает, что в каждой из k позиций в строках суммарное число единиц по всем n числам не должно превышать m. Таким образом, функция maxN(m, k) должна возвращать максимальную мощность множества различных k-битовых строк, для которых выполняется это ограничение. Давайте ослабим это ограничение: будем искать множество, в котором в сумме по всем разрядам количество единиц не превышает k·m. Как мы докажем после, ответ от этого не изменится.С таким ослабленным ограничением задача решается простым жадным алгоритмом. Логично, что сначала лучше брать те строки, в которых меньше единиц. Будем перебирать количество единиц i в строке от 0 до k, а также хранить переменную t, обозначающую количество единиц, которое ещё можно поставить (изначально она равна k·m). Тогда на i-ом шаге максимально можно взять чисел с i единицами. Добавим p к ответу, а от t отнимем p·i. Отметим, что значения Cki нужно считать аккуратно — они могут оказаться слишком большими, и нужно не допустить переполнения.Можно показать, что сложность такого решения на один тест составляет не более O(log2n).Осталось доказать необходимое утверждение. Идея доказательства ниже принадлежит rng_58 (авторское было заметно сложнее).Решим задачу жадным алгоритмом с ограничением в k·m на общее число единиц. Полученное множество может не удовлетворять ограничению в m единиц на каждый разряд — тогда в некоторых разрядах количество единиц больше m, а в некоторых меньше m. Возьмём некоторый разряд X, в котором более m единиц, и некоторый разряд Y, в котором менее m единиц. Найдём строки, в которых стоит 1 в X и 0 в Y (допустим, таких строк x) и строки, в которых стоит 0 в X и 1 в Y (допустим, таких строк y). Понятно, что x > y. В каждой из x строк мы можем попробовать поставить 0 в X и 1 в Y — тогда полученная строка может либо остаться уникальной, либо совпасть с какой-то из y строк (но ровно одной). А поскольку x > y, точно найдётся одна из x строк такая, что в ней можно поменять местами цифры в разрядах X и Y и все строки останутся различными. Сделаем это. Теперь в разряде X стало на одну единицу меньше, а в разряде Y — на одну единицу больше. Это значит, что суммарное число лишних единиц в разрядах уменьшилось (т.к. в Y единиц не стало больше m). Таким образом, повторяя эту операцию необходимое число раз, мы сможем добиться того, чтобы в каждом разряде было не более m единиц.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/4808",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 15108
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #127 - Codeforces - Code 1",
          "code": ">популярная\n>-37",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4796",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #127 - Codeforces - Code 2",
          "code": ">популярная\n>-37",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4796",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #127 - Codeforces - Code 3",
          "code": "1 0 0\n0 1 0\n1 0 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4796",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #127 - Codeforces - Code 4",
          "code": "1 0 0\n0 1 0\n1 0 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4796",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #127 - Codeforces - Code 5",
          "code": "10001\n00000\n10001\n00000\n10001",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4796",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #127 - Codeforces - Code 6",
          "code": "10001\n00000\n10001\n00000\n10001",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4796",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #127 - Codeforces - Code 7",
          "code": "0 0 1 0 0\n0 0 0 0 0\n0 0 1 0 0\n0 0 0 0 0\n0 0 1 0 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4796",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #127 - Codeforces - Code 8",
          "code": "0 0 1 0 0\n0 0 0 0 0\n0 0 1 0 0\n0 0 0 0 0\n0 0 1 0 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4796",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #127 - Codeforces - Code 9",
          "code": "0 1 0\n0 0 0\n0 1 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4796",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #127 - Codeforces - Code 10",
          "code": "0 1 0\n0 0 0\n0 1 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4796",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #127 - Codeforces - Code 11",
          "code": "0 1 0\n0 0 0\n0 1 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4796",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #127 - Codeforces - Code 12",
          "code": "0 1 0\n0 0 0\n0 1 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4796",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #127 - Codeforces - Code 13",
          "code": "int n;\ncin >> n;\nif (n == 3)\n{\n  cout << 5;\n  return 0;\n}\nfor (int i = 1;; i += 2)\n  if ((i*i+1)/2>=n)\n  {\n    cout << i;\n    return 0;\n  }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4796",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #127 - Codeforces - Code 14",
          "code": "int n;\ncin >> n;\nif (n == 3)\n{\n  cout << 5;\n  return 0;\n}\nfor (int i = 1;; i += 2)\n  if ((i*i+1)/2>=n)\n  {\n    cout << i;\n    return 0;\n  }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4796",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #127 — разбор - Codeforces - Code 1",
          "code": "w - массив слов задачи Лёши\ns - описание очередной задачи из архива\nbest = 100\nfor a = 1 to k do\n    for b = 1 to k do\n        for c = 1 to k do\n            for d = 1 to k do\n                if s[a] == w[1] and s[b] == w[2] and s[c] == w[3] and s[d] == w[4] then\n                    inversions = 0\n                    if a > b then inversions = inversions + 1\n                    if a > c then inversions = inversions + 1\n                    if a > d then inversions = inversions + 1\n                    if b > c then inversions = inversions + 1\n                    if b > d then inversions = inversions + 1\n                    if c > d then inversions = inversions + 1\n                    if inversions < best then\n                        best = inversions",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4808",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #127 — разбор - Codeforces - Code 2",
          "code": "w - массив слов задачи Лёши\ns - описание очередной задачи из архива\nbest = 100\nfor a = 1 to k do\n    for b = 1 to k do\n        for c = 1 to k do\n            for d = 1 to k do\n                if s[a] == w[1] and s[b] == w[2] and s[c] == w[3] and s[d] == w[4] then\n                    inversions = 0\n                    if a > b then inversions = inversions + 1\n                    if a > c then inversions = inversions + 1\n                    if a > d then inversions = inversions + 1\n                    if b > c then inversions = inversions + 1\n                    if b > d then inversions = inversions + 1\n                    if c > d then inversions = inversions + 1\n                    if inversions < best then\n                        best = inversions",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4808",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #127 — разбор - Codeforces - Code 3",
          "code": "10 b c a b a d d d a a",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4808",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #127 — разбор - Codeforces - Code 4",
          "code": "REP(mask,(1<<15)) REP(i,15) for(j=i;j<15;j++) if(mask&(1<<j)) cost[mask][i]++;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4808",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #127 — разбор - Codeforces - Code 5",
          "code": "long sortAndCountInv(int []a, int l, int r) {\n   if (r - l <= 1) return 0;\n   int m = (l + r)  / 2;\n   long L = sortAndCountInv(a, l, m);\n   long R = sortAndCountInv(a, m + 1, r);\n   long M = 0; \n   int []t = a.clone();\n   int at = 0;\n   for (int i = 0, j = m + 1; i <= m && j <=r; ) {\n       if (t[i] > t[j])  { // если этот элемент больше элемента справа, то значит ( так как левая часть уже отсортирована) и все остальные элементы слева больше, значит, к числу инверсий добавим (m - i) \n        M += m -i; \n        a[at++] = t[j++];\n      } \n      else  a[at++] = t[i++];             \n   }\n   while (i <= m) a[at++] = t[i++];\n   while(j <= r) a[at++]=t[j++];\n   return L + M + R;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4808",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #127 — разбор - Codeforces - Code 6",
          "code": "long sortAndCountInv(int []a, int l, int r) {\n   if (r - l <= 1) return 0;\n   int m = (l + r)  / 2;\n   long L = sortAndCountInv(a, l, m);\n   long R = sortAndCountInv(a, m + 1, r);\n   long M = 0; \n   int []t = a.clone();\n   int at = 0;\n   for (int i = 0, j = m + 1; i <= m && j <=r; ) {\n       if (t[i] > t[j])  { // если этот элемент больше элемента справа, то значит ( так как левая часть уже отсортирована) и все остальные элементы слева больше, значит, к числу инверсий добавим (m - i) \n        M += m -i; \n        a[at++] = t[j++];\n      } \n      else  a[at++] = t[i++];             \n   }\n   while (i <= m) a[at++] = t[i++];\n   while(j <= r) a[at++]=t[j++];\n   return L + M + R;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4808",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    string s = inf.readLine(\"[a-z]{1,10}\", \"s\");\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    string s = inf.readLine(\"[a-z]{1,10}\", \"s\");\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    string s = inf.readLine(\"[a-z]{1,10}\", \"s\");\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare sequences of tokens\");\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string j, p;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n\r\n        ans.readWordTo(j);\r\n        ouf.readWordTo(p);\r\n\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s words differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  compress(j).c_str(), compress(p).c_str());\r\n    }\r\n\r\n    if (ans.seekEof() && ouf.seekEof()) {\r\n        if (n == 1)\r\n            quitf(_ok, \"\\\"%s\\\"\", compress(j).c_str());\r\n        else\r\n            quitf(_ok, \"%d tokens\", n);\r\n    } else {\r\n        if (ans.seekEof())\r\n            quitf(_wa, \"Participant output contains extra tokens\");\r\n        else\r\n            quitf(_wa, \"Unexpected EOF in the participants output\");\r\n    }\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\", -1); // default to -1 if n is not given\n    string type = opt<string>(\"type\", \"random\");\n\n    if (n == -1) n = rnd.next(1, 10);\n    n = max(1, min(n, 10)); // ensure n is between 1 and 10\n\n    string s;\n    if (type == \"random\") {\n        // Generate a random string of length n\n        s = \"\";\n        for (int i = 0; i < n; i++) {\n            s += (char)('a' + rnd.next(26));\n        }\n    } else if (type == \"same_char\") {\n        // Generate a string of length n with the same character\n        char c = (char)('a' + rnd.next(26));\n        s = string(n, c);\n    } else if (type == \"palindrome\") {\n        // Generate a palindrome of length n\n        string half;\n        int half_len = (n + 1) / 2;\n        for (int i = 0; i < half_len; i++) {\n            half += (char)('a' + rnd.next(26));\n        }\n        s = half;\n        // If n is odd, skip the middle character in reverse\n        int start = n % 2 == 0 ? half_len - 1 : half_len - 2;\n        for (int i = start; i >= 0; i--) {\n            s += half[i];\n        }\n    } else if (type == \"unique_chars\") {\n        // Generate a string of length n with unique letters\n        if (n > 26) n = 26; // Cannot have more than 26 unique letters\n        vector<char> letters;\n        for (int i = 0; i < 26; i++) letters.push_back('a' + i);\n        shuffle(letters.begin(), letters.end());\n        s = \"\";\n        for (int i = 0; i < n; i++) {\n            s += letters[i];\n        }\n    } else if (type == \"descending_letters\") {\n        // Generate a string of length n with letters from 'z' down\n        s = \"\";\n        for (int i = 0; i < n; i++) {\n            s += (char)('z' - i % 26);\n        }\n    } else if (type == \"ascending_letters\") {\n        // Generate a string of length n with letters from 'a' up\n        s = \"\";\n        for (int i = 0; i < n; i++) {\n            s += (char)('a' + i % 26);\n        }\n    } else if (type == \"corner_case\") {\n        // Choose from predefined corner case strings\n        vector<string> corner_cases = {\n            \"abcdefghij\", // Unique letters, length 10\n            \"zzzzzzzzzz\", // Same letters, length 10\n            \"codeforces\", // Sample input\n            \"mississipp\", // Sample input\n            \"bowwowwow\",  // Sample input\n            \"radar\",      // Sample input\n            \"abcdeedcba\", // Palindrome, length 10\n            \"abcba\",      // Palindrome\n            \"aaaaa\",      // All 'a's\n            \"abcde\",      // No palindromic subsequences longer than 1\n            \"aaabbbbcc\",  // Various counts\n            \"xyzzyx\",     // Palindromic subsequences\n            \"abcdedcba\",  // Palindrome\n            \"mnopqrst\",   // Unique letters\n            \"aaaabaaaaa\", // Palindromic subsequences\n            \"abcabcabc\",  // Repeating patterns\n            \"aabbccdd\",   // Pairs of letters\n            \"abcdefghijkl\", // Will be truncated to length 10\n            \"llllllllll\", // All 'l's, length 10\n            \"abcdefgh\",   // Unique letters, length 8\n            \"ababababab\", // Repeating 'ab'\n        };\n        s = corner_cases[rnd.next(corner_cases.size())];\n        // Adjust length if n is specified and shorter\n        if (n < s.length()) {\n            s = s.substr(0, n);\n        }\n    } else {\n        // Default to random string\n        s = \"\";\n        for (int i = 0; i < n; i++) {\n            s += (char)('a' + rnd.next(26));\n        }\n    }\n\n    // Ensure s is between length 1 and 10\n    if (s.length() == 0) s = \"a\";\n    if (s.length() > 10) s = s.substr(0, 10);\n\n    // Output the string\n    printf(\"%s\\n\", s.c_str());\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\", -1); // default to -1 if n is not given\n    string type = opt<string>(\"type\", \"random\");\n\n    if (n == -1) n = rnd.next(1, 10);\n    n = max(1, min(n, 10)); // ensure n is between 1 and 10\n\n    string s;\n    if (type == \"random\") {\n        // Generate a random string of length n\n        s = \"\";\n        for (int i = 0; i < n; i++) {\n            s += (char)('a' + rnd.next(26));\n        }\n    } else if (type == \"same_char\") {\n        // Generate a string of length n with the same character\n        char c = (char)('a' + rnd.next(26));\n        s = string(n, c);\n    } else if (type == \"palindrome\") {\n        // Generate a palindrome of length n\n        string half;\n        int half_len = (n + 1) / 2;\n        for (int i = 0; i < half_len; i++) {\n            half += (char)('a' + rnd.next(26));\n        }\n        s = half;\n        // If n is odd, skip the middle character in reverse\n        int start = n % 2 == 0 ? half_len - 1 : half_len - 2;\n        for (int i = start; i >= 0; i--) {\n            s += half[i];\n        }\n    } else if (type == \"unique_chars\") {\n        // Generate a string of length n with unique letters\n        if (n > 26) n = 26; // Cannot have more than 26 unique letters\n        vector<char> letters;\n        for (int i = 0; i < 26; i++) letters.push_back('a' + i);\n        shuffle(letters.begin(), letters.end());\n        s = \"\";\n        for (int i = 0; i < n; i++) {\n            s += letters[i];\n        }\n    } else if (type == \"descending_letters\") {\n        // Generate a string of length n with letters from 'z' down\n        s = \"\";\n        for (int i = 0; i < n; i++) {\n            s += (char)('z' - i % 26);\n        }\n    } else if (type == \"ascending_letters\") {\n        // Generate a string of length n with letters from 'a' up\n        s = \"\";\n        for (int i = 0; i < n; i++) {\n            s += (char)('a' + i % 26);\n        }\n    } else if (type == \"corner_case\") {\n        // Choose from predefined corner case strings\n        vector<string> corner_cases = {\n            \"abcdefghij\", // Unique letters, length 10\n            \"zzzzzzzzzz\", // Same letters, length 10\n            \"codeforces\", // Sample input\n            \"mississipp\", // Sample input\n            \"bowwowwow\",  // Sample input\n            \"radar\",      // Sample input\n            \"abcdeedcba\", // Palindrome, length 10\n            \"abcba\",      // Palindrome\n            \"aaaaa\",      // All 'a's\n            \"abcde\",      // No palindromic subsequences longer than 1\n            \"aaabbbbcc\",  // Various counts\n            \"xyzzyx\",     // Palindromic subsequences\n            \"abcdedcba\",  // Palindrome\n            \"mnopqrst\",   // Unique letters\n            \"aaaabaaaaa\", // Palindromic subsequences\n            \"abcabcabc\",  // Repeating patterns\n            \"aabbccdd\",   // Pairs of letters\n            \"abcdefghijkl\", // Will be truncated to length 10\n            \"llllllllll\", // All 'l's, length 10\n            \"abcdefgh\",   // Unique letters, length 8\n            \"ababababab\", // Repeating 'ab'\n        };\n        s = corner_cases[rnd.next(corner_cases.size())];\n        // Adjust length if n is specified and shorter\n        if (n < s.length()) {\n            s = s.substr(0, n);\n        }\n    } else {\n        // Default to random string\n        s = \"\";\n        for (int i = 0; i < n; i++) {\n            s += (char)('a' + rnd.next(26));\n        }\n    }\n\n    // Ensure s is between length 1 and 10\n    if (s.length() == 0) s = \"a\";\n    if (s.length() > 10) s = s.substr(0, 10);\n\n    // Output the string\n    printf(\"%s\\n\", s.c_str());\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -type random\n./gen -n 1 -type same_char\n./gen -n 1 -type palindrome\n./gen -n 1 -type unique_chars\n\n./gen -n 2 -type descending_letters\n./gen -n 2 -type ascending_letters\n\n./gen -n 3 -type same_char\n./gen -n 3 -type palindrome\n\n./gen -n 4 -type unique_chars\n./gen -n 4 -type descending_letters\n\n./gen -n 5 -type ascending_letters\n./gen -n 5 -type unique_chars\n\n./gen -n 6 -type palindrome\n./gen -n 6 -type same_char\n\n./gen -n 7 -type corner_case\n./gen -n 7 -type random\n\n./gen -n 8 -type descending_letters\n./gen -n 8 -type ascending_letters\n\n./gen -n 9 -type palindrome\n./gen -n 9 -type unique_chars\n\n./gen -n 10 -type same_char\n./gen -n 10 -type corner_case\n\n# Commands without specifying n (n will be random between 1 and 10)\n./gen -type random\n./gen -type same_char\n./gen -type palindrome\n./gen -type unique_chars\n\n# Additional random test cases\n./gen -n 10 -type random\n./gen -n 10 -type random\n./gen -n 10 -type random\n\n# Generate maximum length cases\n./gen -n 10 -type palindrome\n./gen -n 10 -type unique_chars\n\n# Generate corner cases\n./gen -type corner_case\n./gen -type corner_case\n./gen -type corner_case\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T19:48:12.576654",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "202/B",
      "title": "B. Brand New Easy Problem",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains a single integer n (1 ≤ n ≤ 4) — the number of words in Lesha's problem. The second line contains n space-separated words — the short description of the problem.The third line contains a single integer m (1 ≤ m ≤ 10) — the number of problems in the Torcoder.com archive. Next m lines contain the descriptions of the problems as \"k s1 s2 ... sk\", where k (1 ≤ k ≤ 20) is the number of words in the problem and si is a word of the problem description.All words from all problem descriptions contain no more than 10 lowercase English letters.",
      "output_spec": "OutputIf Lesha's problem is brand new, print string \"Brand new problem!\" (without quotes). Otherwise, on the first line print the index of the archive problem which resembles Lesha's problem most. If there are multiple such problems, print the one with the smallest index. On the second line print a string consisting of characters [:, character | repeated p times, and characters :], where p is the \"similarity\" between this problem and Lesha's one. The archive problems are numbered starting from one in the order in which they are given in the input.",
      "sample_tests": "ExamplesInputCopy4find the next palindrome110 find the previous palindrome or print better luck next timeOutputCopy1[:||||||:]InputCopy3add two numbers31 add2 two two3 numbers numbers numbersOutputCopyBrand new problem!InputCopy4these papers are formulas36 what are these formulas and papers5 papers are driving me crazy4 crazy into the nightOutputCopy1[:||||:]InputCopy3add two decimals54 please two decimals add5 decimals want to be added4 two add decimals add4 add one two three7 one plus two plus three equals sixOutputCopy3[:|||:]",
      "description": "B. Brand New Easy Problem\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains a single integer n (1 ≤ n ≤ 4) — the number of words in Lesha's problem. The second line contains n space-separated words — the short description of the problem.The third line contains a single integer m (1 ≤ m ≤ 10) — the number of problems in the Torcoder.com archive. Next m lines contain the descriptions of the problems as \"k s1 s2 ... sk\", where k (1 ≤ k ≤ 20) is the number of words in the problem and si is a word of the problem description.All words from all problem descriptions contain no more than 10 lowercase English letters.\n\nOutputIf Lesha's problem is brand new, print string \"Brand new problem!\" (without quotes). Otherwise, on the first line print the index of the archive problem which resembles Lesha's problem most. If there are multiple such problems, print the one with the smallest index. On the second line print a string consisting of characters [:, character | repeated p times, and characters :], where p is the \"similarity\" between this problem and Lesha's one. The archive problems are numbered starting from one in the order in which they are given in the input.\n\nInputCopy4find the next palindrome110 find the previous palindrome or print better luck next timeOutputCopy1[:||||||:]InputCopy3add two numbers31 add2 two two3 numbers numbers numbersOutputCopyBrand new problem!InputCopy4these papers are formulas36 what are these formulas and papers5 papers are driving me crazy4 crazy into the nightOutputCopy1[:||||:]InputCopy3add two decimals54 please two decimals add5 decimals want to be added4 two add decimals add4 add one two three7 one plus two plus three equals sixOutputCopy3[:|||:]\n\nInputCopy4find the next palindrome110 find the previous palindrome or print better luck next time\n\nOutputCopy1[:||||||:]\n\nInputCopy3add two numbers31 add2 two two3 numbers numbers numbers\n\nOutputCopyBrand new problem!\n\nInputCopy4these papers are formulas36 what are these formulas and papers5 papers are driving me crazy4 crazy into the night\n\nOutputCopy1[:||||:]\n\nInputCopy3add two decimals54 please two decimals add5 decimals want to be added4 two add decimals add4 add one two three7 one plus two plus three equals six\n\nOutputCopy3[:|||:]\n\nNoteLet us remind you that the number of inversions is the number of pairs of words that follow in the permutation not in their original order. Thus, for example, if the original problem is \"add two numbers\", then permutation \"numbers add two\" contains two inversions — pairs of words \"numbers\" and \"add\", \"numbers\" and \"two\". Sequence b1,  b2,  ...,  bk is a subsequence of sequence a1, a2,  ...,  an if there exists such a set of indices 1 ≤ i1 <  i2 < ...   < ik ≤ n that aij  =  bj (in other words, if sequence b can be obtained from a by deleting some of its elements).In the first test case the first problem contains the \"find the palindrome next\" permutation as a subsequence, in which the number of inversions equals 1 (words \"palindrome\" and \"next\").In the second test case there is no problem that contains a permutation of words from Lesha's problem as a subsequence.",
      "solutions": [
        {
          "title": "Codeforces Round #127 - Codeforces",
          "content": "Hello everyone!As many of you already know, today is the day for Codeforces Round #127 missing which is really undesirable ;)Original problems for you were created by tourist and Romka. We tried to emphasize the ideological component of the problems, thus we hope that you'll spend more time thinking than coding. Special thanks for helping in setting the contest go to Codeforces coordinator Gerald. We also thank Delinur for translating the problem statements and Alex_KPR for reviewing them.We hope that this round won't be just a regular Codeforces round for you, but will bring you new experience and new knowledge. For the authors all problems are equally easy, yet we tried to arrange them in decreasing order of simplicity :)Problems' point values in Division 1 are 1000-1000-1500-2000-2500. Problems' point values in Division 2 are 500-1000-2000-2000-2500.Wish you success!UPD: The contest is over, thanks all for participating. We hope you enjoyed it :)In Division 1 rng_58 was a clear winner, solving all 5 problems in an hour and a half! No one else managed to solve all problems in two hours.The winners in Division 1 are (full results): rng_58 peter50216 liympanda White_Bear havaliza In Division 2 every problem was solved by somebody, but nobody managed to solve all problems. The battle was very tough and the gaps were very small.The winners in Division 2 are (full results): Leewings snow_lotus 72VanVector_SevNTU Congratulations to the winners!UPD2: The editorial is available now.",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/4796",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1501
        },
        {
          "title": "Codeforces Round #127 — editorial - Codeforces",
          "content": "Problem A(div 2) — LLPSIt's assumed that this problem can be solved just looking at the samples and without reading the statement itself :)Let's find the letter in the given string which comes last in the alphabet, denote this letter by z. If this letter occurs p times in the given string, then the answer is string a consisting of letter z repeated p times.Why is it so? Using the definition of lexicographical comparison and the fact that z is the largest letter in the string it's easy to understand that if some other subsequence b of the given string is lexicographically larger than a, then string b should be longer than a and, moreover, a should be a prefix of b (that is, b should start with a). But string b must be a palindrome, therefore its last letter must be z. In this case string b must contain more occurrences of letter z than the original string s does, which is impossible as b is a subsequence of s.Besides that, the constraint on the length of the string was very low, so the problem could be solved using brute force. For every subsequence of the given string it's necessary to check whether it's a palindrome, and from all palindromic subsequences of s the lexicographically largest should be chosen as the answer. The complexity of such a solution is O(2n·n), where n is the length of the string (unlike the solution above with complexity O(n)).Problem В(div 2) — Brand New Easy ProblemThe constraints in this problem were so low that a solution with complexity O(m·kn) was just fine. In each problem's description it's enough to loop over all possible subsequences of words which are permutations of words in Lesha's problem, for each of them calculate the number of inversions and choose a permutation with the smallest number of inversions. This can result in a short solution using recursion or, for example, you can use several nested loops (from 1 to 4).Here is an example of pseudocode for n = 4: w - array of words of Lesha''s problem\ns - the description of the current problem\nbest = 100\nfor a = 1 to k do\n for b = 1 to k do\n for c = 1 to k do\n for d = 1 to k do\n if s[a] == w[1] and s[b] == w[2] and s[c] == w[3] and s[d] == w[4] then\n inversions = 0\n if a > b then inversions = inversions + 1\n if a > c then inversions = inversions + 1\n if a > d then inversions = inversions + 1\n if b > c then inversions = inversions + 1\n if b > d then inversions = inversions + 1\n if c > d then inversions = inversions + 1\n if inversions < best then\n best = inversionsAt the end you should choose the problem with the smallest value of best and print the answer in the corresponding form.Problem A(div 1)/C(div 2) — Clear SymmetryIt's interesting that originally the authors had an idea not to include the x = 3 case into pretests. Imagine the number of successful hacking attempts in this contest -- considering the fact that none of the first 43 solutions to this problem passed pretests :)Note that the sought n is always an odd number. Indeed, if n is even, then two central rows of matrix A must contain zeroes, otherwise there will exist two neighbouring cells containing ones. Similar restriction applies to two central columns of matrix A. Replacing two central rows with just one and two central columns with just one and leaving zeroes in them, we'll obtain a smaller matrix with the same sharpness.Note that the sharpness of a matrix with side n can't exceed . It's easy to see that it's possible to lay out \"domino pieces\" 1 by 2 without intersections on a field with side n (in other words, all cells except one can be divided into pairs so that each pair contains neighbouring cells). Then there can be at most one one in the cells under each \"domino piece\" in the corresponding matrix. Therefore, the total number of ones doesn't exceed .Note that a matrix with side n and sharpness exists for an odd n. Paint all cells of the matrix in chess order and put ones into black cells and zeroes into white cells. It's easy to see that such a matrix is both clear and symmetrical and has sharpenss exactly .Intuitively it seems that if there exists a matrix with sharpness there should also exist a matrix with every smaller sharpness. That's correct except only one case -- there doesn't exist a matrix with side 3 and sharpness 3, though there exists a matrix with side 3 and sharpness 5.Let's show that the claim above is correct for odd n ≥ 5. We'll build a matrix with sharpness as shown above and gradually turn ones into zeroes reducing the sharpness. Cells containing ones in the matrix can be divided into three types.The first type is the central cell. The number in it can be turned into zero and the matrix won't stop satisfying the required conditions.The second type is the cells in the central row and the central column (except central cell). Such cells are divided into pairs by the condition of symmetry -- if we turn the number in one of them into zero, we should turn the number in its pair cell into zero as well.The third type is all the other cells. Such cells are divided into groups of four by the condition of symmetry -- if we turn the number in one of them into zero, we should turn the number in all cells from this group into zero as well.Now for obtaining the required sharpness of x we'll act greedily. Let's turn ones into zeroes in third type cells by four until the current shapness exceeds x by less than 4 or there are no third type cells with ones remaining. After that let's turn ones into zeroes in second type cells by pairs while the current sharpness exceeds x by at least 2. At this moment the sharpness of our matrix is either x or x + 1. If it's equal to x + 1, let's put a zero into the central cell and obtain a matrix with sharpness x. It's easy to check that we'll be able to obtain a matrix with any sharpness acting this way.Why is this reasoning incorrect for n = 3? Because second type cells are absent in the matrix with sharpness 5 obtained from chess coloring. For n ≥ 5 this matrix contains cells of all types, which is important for the algorithm above. It's better to find the answers for x ≤ 5 by hand but carefully -- for example, a lot of contestants decided that the answer for x = 2 is 5 instead of 3.Problem В(div 1)/D(div 2) — Guess That Car!We need to find such x and y that the value of is minimum possible. This expression can be rewritten as . Note that the first part doesn't depend on y and the second part doesn't depend on x, so we can minimize these parts separately. Here is how to minimize , the second part is minimized similarly. As the expression in the brackets doesn't depend on j, this part can be rewritten as , where . Now it's enough to calculate the required value for all possible values of x and choose x for which this value is the smallest. The optimal value of y can be found similarly.The overall complexity of this solution is O(n·m + n2 + m2).As the objective function is convex, other approaches to this problem are possible, for example, ternary search, gradient descent or analytical approach (calculation of derivatives).The main hero of this problem is Ra16bit.Problem С(div 1)/E(div 2) — Fragile BridgesThere are a few different ways to solve this problem, the editorial contains one of them.For any solution the following fact is useful. Suppose the sought path starts on platform i and ends on platform j (i ≤ j, if that's not the case, we can reverse the path). Then all bridges between platforms i and j will be passed through an odd number of times, and all other bridges will be passed through an even number of times.Let's find the maximum length of a path with its ends on platforms i and j. To do that, let's find the following auxiliary values for each platform: lefti -- the maximum length of a path starting and ending on platform i and passing only through bridges to the left of platform i; rightj -- similarly for bridges to the right of platform j. Also for each bridge define oddi as the largest odd number not larger than ai, and for each platform define sumOddi as the sum of oddj for all bridges to the left of platform i.Then the maximum length of a path with its ends on platforms i and j is equal to lefti + rightj + (sumOddj - sumOddi), or, which is the same, (rightj + sumOddj) + (lefti - sumOddi).Now we can find the pair (i, j) for which this value is the largest in linear time. Let's loop over j. From the formula it's obvious that we should find such i ≤ j that (lefti - sumOddi) is the largest. If we loop over j from 1 to n, we can maintain the largest value of this expression for all i ≤ j and recalculate it when moving to the next j, comparing (leftj - sumOddj) with the current maximum and possibly updating this maximum. This way for each j we have to check only one value of i and not all i ≤ j.The last thing to show is how to find all lefti quickly (all rightj can be found similarly). Clearly left1 = 0, then we'll calculate lefti using lefti - 1. Note that when ai - 1 = 1, we have lefti = 0 as after passing the bridge to platform (i - 1) this bridge will collapse and it will be impossible to return to platform i. If ai - 1 > 1, then lefti = lefti - 1 + eveni - 1, where eveni - 1 is the largest even number not larger than ai - 1. Indeed, we can move to platform (i - 1), then move along the path corresponding to lefti - 1, and then move along the bridge between platforms (i - 1) and i until the limit on the number of transitions is less than 2 (finishing on platform i).The overall complexity of this solution is O(n).Problem D(div 1) — Brand New ProblemThe first solution coming to mind is dynamic programming f[i][j] =  (the smallest possible number of inversions to the moment if among the first j words of the archive problem we've found a permutation of words included in bitmask i). In this solution parameter j varies from 0 to 500000, parameter i varies from 0 to 215 - 1 and calculation of each value is possible in O(1) (we are either using the current word in the subsequence or not). That's too much.Let's make use of a standard technique: make the value of DP a new parameter and make one of the existing parameters the value of DP. Not for every DP this is possible, but at least it's possible for this one :)It's clear that with a fixed subset of words and a fixed number of inversions it's optimal to choose the first occurrences of these words giving this number of inversions. Let f[i][j] =  (the smallest number z such that among first z words of the archive problem there exists a permutation of words from bitmask i containing exactly j inversions). The basis of this DP is f[0][0] = 0, f[0][j] = ∞ for j > 0. Recalculation of values happens in the following way: loop over a word q from the bitmask i which was the last in the permutation. With the knowledge of this word and the number of inversions j it's easy to find how many inversions j' there were without this word — that's j minus the number of words in the mask which appeared later in Lesha's problem than word q. Let p = f[i^(1«q)][j']. Then we should consider p2 equal to the position of the next occurrence of word q after position p as a possible value for f[i][j]. To find p2 quickly we should fill an array next[500010][15] so that next[i][j] =  (the smallest position k > i such that the k-th word in the archive problem equals the j-th word in Lesha's problem) for each archive problem in advance. This array can be easily filled passing from right to left once.The total number of operations can be calculated as m·(k·n + 2n·Cn2·n), where m is the number of problems in the archive, k is the number of words in one archive problem description and n is the number of words in Lesha's problem description. Under the given constraints that is about 200 million operations, and the author's solutions (including a Java solution) worked for less than 2 seconds. The time limit was set with a margin -- 5 seconds.The main heroes of problems D(div 1) and B(div 2) are Chmel_Tolstiy and ivan.metelsky.Problem E(div 1) — Thoroughly Bureaucratic OrganizationLet's imagine that we have a magic function maxN(m, k) that returns, given m and k, the largest value of n such that it's possible to solve the problem for n people and m empty lines in the form using k requests. Then we'll be able to use binary search on the answer -- the number of requests k.Suppose we've made k requests. Let's match a string of length k to each person, where the i-th character is equal to 1 if this person is mentioned in the i-th request and 0 otherwise. Note that we'll be able to determine the exact appointment date for each person if and only if all n strings of length k are pairwise distinct. Indeed, if two persons' strings are the same, their appointment dates could be exchanged and the responses to the requests wouldn't have changed. If all strings are distinct, for each date we may find the person appointed for this date looking at the set of requests with responses containing this date and finding the person mentioned in the same set of requests.The constraint on m empty lines in the form means that each of k positions in the strings should contain no more than m ones in all n strings overall. Thus function maxN(m, k) should return the maximum size of a set of distinct k-bit strings meeting this condition. Let's make this restriction weaker: we'll search for a set such that the total number of ones in all n strings doesn't exceed k·m. As we'll prove later, the answer won't change.With this weaker restriction the problem can be solved using a simple greedy strategy. It's obvious that strings with smaller number of ones are better. Let's loop over the number of ones i in the string from 0 to k and also maintain a variable t containing the remaining number of ones (initially it's equal to k·m). Then at the i-th step we can take at most strings containing i ones. Let's add p to the answer and subtract p·i from t. Note that the values of Cki should be calculated with care -- they can turn out to be too large, so it's important not to allow overflows.It can be shown that the overall complexity of this algorithm is at most O(log2 n).The remaining thing is to prove the claim above. The idea of the proof below belongs to rng_58 (the author's proof is notably harder).Let's solve the problem with a greedy algorithm with the k·m constraint on the total number of ones. The resulting set of strings may not satisfy the restriction of m ones for each position. If it doesn't, some of the positions contain more than m ones and some contain less than m ones. Let's pick any position X containing more than m ones and any position Y containing less than m ones. Find all strings containing 1 at X and 0 at Y (suppose there are x such strings) and all strings containing 0 at X and 1 at Y (suppose there are y such strings). It's clear that x > y. In each of x strings we can try to put 0 at X and 1 at Y -- then the string we obtain will either remain unique in this set or coincide with one of those y strings (but only one). As x > y, for at least one of x strings the change above leaves this string unique. Let's take this string and put 0 at X and 1 at Y. Now position X contains one 1 less, and position Y contains one 1 more. It means that the total number of \"extra\" ones in the positions has been decreased (as Y still contains no more than m ones). Doing this operation for a needed number of times, we'll achieve our goal.",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/4808",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 15409
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #127 - Codeforces - Code 1",
          "code": "1 0 0\n0 1 0\n1 0 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4796",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #127 - Codeforces - Code 2",
          "code": "1 0 0\n0 1 0\n1 0 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4796",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #127 - Codeforces - Code 3",
          "code": "0 0 1 0 0\n0 0 0 0 0\n0 0 1 0 0\n0 0 0 0 0\n0 0 1 0 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4796",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #127 - Codeforces - Code 4",
          "code": "0 0 1 0 0\n0 0 0 0 0\n0 0 1 0 0\n0 0 0 0 0\n0 0 1 0 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4796",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #127 - Codeforces - Code 5",
          "code": "0 1 0\n0 0 0\n0 1 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4796",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #127 - Codeforces - Code 6",
          "code": "0 1 0\n0 0 0\n0 1 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4796",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #127 - Codeforces - Code 7",
          "code": "0 1 0\n0 0 0\n0 1 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4796",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #127 - Codeforces - Code 8",
          "code": "0 1 0\n0 0 0\n0 1 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4796",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #127 — editorial - Codeforces - Code 1",
          "code": "w - array of words of Lesha''s problem\ns - the description of the current problem\nbest = 100\nfor a = 1 to k do\n    for b = 1 to k do\n        for c = 1 to k do\n            for d = 1 to k do\n                if s[a] == w[1] and s[b] == w[2] and s[c] == w[3] and s[d] == w[4] then\n                    inversions = 0\n                    if a > b then inversions = inversions + 1\n                    if a > c then inversions = inversions + 1\n                    if a > d then inversions = inversions + 1\n                    if b > c then inversions = inversions + 1\n                    if b > d then inversions = inversions + 1\n                    if c > d then inversions = inversions + 1\n                    if inversions < best then\n                        best = inversions",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4808",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #127 — editorial - Codeforces - Code 2",
          "code": "w - array of words of Lesha''s problem\ns - the description of the current problem\nbest = 100\nfor a = 1 to k do\n    for b = 1 to k do\n        for c = 1 to k do\n            for d = 1 to k do\n                if s[a] == w[1] and s[b] == w[2] and s[c] == w[3] and s[d] == w[4] then\n                    inversions = 0\n                    if a > b then inversions = inversions + 1\n                    if a > c then inversions = inversions + 1\n                    if a > d then inversions = inversions + 1\n                    if b > c then inversions = inversions + 1\n                    if b > d then inversions = inversions + 1\n                    if c > d then inversions = inversions + 1\n                    if inversions < best then\n                        best = inversions",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4808",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #127 — editorial - Codeforces - Code 3",
          "code": "REP(mask,(1<<15)) REP(i,15) for(j=i;j<15;j++) if(mask&(1<<j)) cost[mask][i]++;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4808",
          "author": "Qingyu"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 4, \"n\");\n    inf.readEoln();\n\n    set<string> lesha_words;\n    for (int i = 0; i < n; ++i) {\n        if (i > 0)\n            inf.readSpace();\n        string word = inf.readToken(\"[a-z]{1,10}\", \"word\");\n        ensuref(lesha_words.count(word) == 0, \"Lesha's problem has duplicate word: '%s'\", word.c_str());\n        lesha_words.insert(word);\n    }\n    inf.readEoln();\n\n    int m = inf.readInt(1, 10, \"m\");\n    inf.readEoln();\n\n    for (int i = 0; i < m; ++i) {\n        int k = inf.readInt(1, 20, \"k\");\n        for (int j = 0; j < k; ++j) {\n            inf.readSpace();\n            string word = inf.readToken(\"[a-z]{1,10}\", \"word\");\n        }\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 4, \"n\");\n    inf.readEoln();\n\n    set<string> lesha_words;\n    for (int i = 0; i < n; ++i) {\n        if (i > 0)\n            inf.readSpace();\n        string word = inf.readToken(\"[a-z]{1,10}\", \"word\");\n        ensuref(lesha_words.count(word) == 0, \"Lesha's problem has duplicate word: '%s'\", word.c_str());\n        lesha_words.insert(word);\n    }\n    inf.readEoln();\n\n    int m = inf.readInt(1, 10, \"m\");\n    inf.readEoln();\n\n    for (int i = 0; i < m; ++i) {\n        int k = inf.readInt(1, 20, \"k\");\n        for (int j = 0; j < k; ++j) {\n            inf.readSpace();\n            string word = inf.readToken(\"[a-z]{1,10}\", \"word\");\n        }\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 4, \"n\");\n    inf.readEoln();\n\n    set<string> lesha_words;\n    for (int i = 0; i < n; ++i) {\n        if (i > 0)\n            inf.readSpace();\n        string word = inf.readToken(\"[a-z]{1,10}\", \"word\");\n        ensuref(lesha_words.count(word) == 0, \"Lesha's problem has duplicate word: '%s'\", word.c_str());\n        lesha_words.insert(word);\n    }\n    inf.readEoln();\n\n    int m = inf.readInt(1, 10, \"m\");\n    inf.readEoln();\n\n    for (int i = 0; i < m; ++i) {\n        int k = inf.readInt(1, 20, \"k\");\n        for (int j = 0; j < k; ++j) {\n            inf.readSpace();\n            string word = inf.readToken(\"[a-z]{1,10}\", \"word\");\n        }\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare sequences of tokens\");\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string j, p;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n\r\n        ans.readWordTo(j);\r\n        ouf.readWordTo(p);\r\n\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s words differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  compress(j).c_str(), compress(p).c_str());\r\n    }\r\n\r\n    if (ans.seekEof() && ouf.seekEof()) {\r\n        if (n == 1)\r\n            quitf(_ok, \"\\\"%s\\\"\", compress(j).c_str());\r\n        else\r\n            quitf(_ok, \"%d tokens\", n);\r\n    } else {\r\n        if (ans.seekEof())\r\n            quitf(_wa, \"Participant output contains extra tokens\");\r\n        else\r\n            quitf(_wa, \"Unexpected EOF in the participants output\");\r\n    }\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring randomWord(int minLength=1, int maxLength=10) {\n    int len = rnd.next(minLength, maxLength);\n    string s;\n    for (int i = 0; i < len; i++) {\n        s += (char)('a' + rnd.next(26));\n    }\n    return s;\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\", 0);   // default m = 0\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<string> leshaWords;\n\n    if (type == \"minimal\") {\n        n = 1;\n        m = 1;\n        // Lesha's problem word does not appear in archive problem\n        leshaWords.push_back(randomWord());\n        cout << n << endl;\n        cout << leshaWords[0] << endl;\n        cout << m << endl;\n        cout << \"1 \" << randomWord() << endl;\n    } else if (type == \"maximal\") {\n        n = 4;\n        m = 10;\n        cout << n << endl;\n        // Generate 4 random words\n        set<string> usedWords;\n        while (leshaWords.size() < n) {\n            string w = randomWord();\n            if (usedWords.count(w) == 0) {\n                leshaWords.push_back(w);\n                usedWords.insert(w);\n            }\n        }\n        for (int i = 0; i < n; i++) {\n            cout << leshaWords[i];\n            if (i != n - 1) cout << \" \";\n        }\n        cout << endl;\n        cout << m << endl;\n        for (int i = 0; i < m; i++) {\n            int k = 20;\n            cout << k;\n            for (int j = 0; j < k; j++) {\n                cout << \" \" << randomWord();\n            }\n            cout << endl;\n        }\n    } else if (type == \"brand_new\") {\n        // Generate Lesha's problem words\n        set<string> usedWords;\n        while (leshaWords.size() < n) {\n            string w = randomWord();\n            if (usedWords.count(w) == 0) {\n                leshaWords.push_back(w);\n                usedWords.insert(w);\n            }\n        }\n        cout << n << endl;\n        for (int i = 0; i < n; i++) {\n            cout << leshaWords[i];\n            if (i != n - 1) cout << \" \";\n        }\n        cout << endl;\n        // Generate m archive problems with words not including Lesha's words\n        cout << m << endl;\n        for (int i = 0; i < m; i++) {\n            int k = rnd.next(1, 20);\n            cout << k;\n            for (int j = 0; j < k; j++) {\n                string w;\n                do {\n                    w = randomWord();\n                } while (usedWords.count(w) != 0);\n                cout << \" \" << w;\n            }\n            cout << endl;\n        }\n    } else if (type == \"exact_match\") {\n        // Lesha's problem matches an archive problem exactly\n        set<string> usedWords;\n        while (leshaWords.size() < n) {\n            string w = randomWord();\n            if (usedWords.count(w) == 0) {\n                leshaWords.push_back(w);\n                usedWords.insert(w);\n            }\n        }\n        cout << n << endl;\n        for (int i = 0; i < n; i++) {\n            cout << leshaWords[i];\n            if (i != n - 1) cout << \" \";\n        }\n        cout << endl;\n        cout << m << endl;\n        cout << n;\n        for (int i = 0; i < n; i++) {\n            cout << \" \" << leshaWords[i];\n        }\n        cout << endl;\n        for (int i = 1; i < m; i++) {\n            int k = rnd.next(1, 20);\n            cout << k;\n            for (int j = 0; j < k; j++) {\n                string w;\n                do {\n                    w = randomWord();\n                } while (usedWords.count(w) != 0);\n                cout << \" \" << w;\n            }\n            cout << endl;\n        }\n    } else if (type == \"subsequence_ordered\") {\n        // Archive problem contains Lesha's problem words as subsequence, in order\n        set<string> usedWords;\n        while (leshaWords.size() < n) {\n            string w = randomWord();\n            if (usedWords.count(w) == 0) {\n                leshaWords.push_back(w);\n                usedWords.insert(w);\n            }\n        }\n        cout << n << endl;\n        for (int i = 0; i < n; i++) {\n            cout << leshaWords[i];\n            if (i != n - 1) cout << \" \";\n        }\n        cout << endl;\n        cout << m << endl;\n        for (int i = 0; i < m; i++) {\n            int k = rnd.next(n, 20);\n            cout << k;\n            int pos = 0;\n            for (int j = 0; j < k; j++) {\n                string w;\n                if (pos < n && rnd.next(3) == 0) {\n                    // Place Lesha's words in order at random positions\n                    w = leshaWords[pos++];\n                } else {\n                    do {\n                        w = randomWord();\n                    } while (usedWords.count(w) != 0);\n                }\n                cout << \" \" << w;\n            }\n            cout << endl;\n        }\n    } else if (type == \"subsequence_unordered\") {\n        // Archive problem contains Lesha's problem words as subsequence, in random order\n        set<string> usedWords;\n        while (leshaWords.size() < n) {\n            string w = randomWord();\n            if (usedWords.count(w) == 0) {\n                leshaWords.push_back(w);\n                usedWords.insert(w);\n            }\n        }\n        cout << n << endl;\n        for (int i = 0; i < n; i++) {\n            cout << leshaWords[i];\n            if (i != n - 1) cout << \" \";\n        }\n        cout << endl;\n        cout << m << endl;\n        // For the first archive problem, insert Lesha's words as subsequence in random order\n        for (int i = 0; i < m; i++) {\n            int k = rnd.next(n, 20);\n            vector<string> archWords;\n            int pos = 0;\n            for (int j = 0; j < k; j++) {\n                if (pos < n && rnd.next(k) < n) {\n                    archWords.push_back(leshaWords[pos++]);\n                } else {\n                    string w;\n                    do {\n                        w = randomWord();\n                    } while (usedWords.count(w) != 0);\n                    archWords.push_back(w);\n                }\n            }\n            // Shuffle Lesha's words before assigning them to positions\n            shuffle(leshaWords.begin(), leshaWords.end());\n            // Now place Lesha's words into archWords in random positions\n            int lpos = 0;\n            for (int j = 0; j < k && lpos < n; j++) {\n                if (archWords[j] == leshaWords[0]) {\n                    archWords[j] = leshaWords[lpos++];\n                }\n            }\n            cout << k;\n            for (int j = 0; j < archWords.size(); j++) {\n                cout << \" \" << archWords[j];\n            }\n            cout << endl;\n        }\n    } else {\n        // Random test case\n        set<string> usedWords;\n        while (leshaWords.size() < n) {\n            string w = randomWord();\n            if (usedWords.count(w) == 0) {\n                leshaWords.push_back(w);\n                usedWords.insert(w);\n            }\n        }\n        cout << n << endl;\n        for (int i = 0; i < n; i++) {\n            cout << leshaWords[i];\n            if (i != n - 1) cout << \" \";\n        }\n        cout << endl;\n        cout << m << endl;\n        for (int i = 0; i < m; i++) {\n            int k = rnd.next(1, 20);\n            cout << k;\n            for (int j = 0; j < k; j++) {\n                string w;\n                if (rnd.next(10) == 0 && !leshaWords.empty()) {\n                    w = leshaWords[rnd.next(leshaWords.size())];\n                } else {\n                    w = randomWord();\n                }\n                cout << \" \" << w;\n            }\n            cout << endl;\n        }\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring randomWord(int minLength=1, int maxLength=10) {\n    int len = rnd.next(minLength, maxLength);\n    string s;\n    for (int i = 0; i < len; i++) {\n        s += (char)('a' + rnd.next(26));\n    }\n    return s;\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\", 0);   // default m = 0\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<string> leshaWords;\n\n    if (type == \"minimal\") {\n        n = 1;\n        m = 1;\n        // Lesha's problem word does not appear in archive problem\n        leshaWords.push_back(randomWord());\n        cout << n << endl;\n        cout << leshaWords[0] << endl;\n        cout << m << endl;\n        cout << \"1 \" << randomWord() << endl;\n    } else if (type == \"maximal\") {\n        n = 4;\n        m = 10;\n        cout << n << endl;\n        // Generate 4 random words\n        set<string> usedWords;\n        while (leshaWords.size() < n) {\n            string w = randomWord();\n            if (usedWords.count(w) == 0) {\n                leshaWords.push_back(w);\n                usedWords.insert(w);\n            }\n        }\n        for (int i = 0; i < n; i++) {\n            cout << leshaWords[i];\n            if (i != n - 1) cout << \" \";\n        }\n        cout << endl;\n        cout << m << endl;\n        for (int i = 0; i < m; i++) {\n            int k = 20;\n            cout << k;\n            for (int j = 0; j < k; j++) {\n                cout << \" \" << randomWord();\n            }\n            cout << endl;\n        }\n    } else if (type == \"brand_new\") {\n        // Generate Lesha's problem words\n        set<string> usedWords;\n        while (leshaWords.size() < n) {\n            string w = randomWord();\n            if (usedWords.count(w) == 0) {\n                leshaWords.push_back(w);\n                usedWords.insert(w);\n            }\n        }\n        cout << n << endl;\n        for (int i = 0; i < n; i++) {\n            cout << leshaWords[i];\n            if (i != n - 1) cout << \" \";\n        }\n        cout << endl;\n        // Generate m archive problems with words not including Lesha's words\n        cout << m << endl;\n        for (int i = 0; i < m; i++) {\n            int k = rnd.next(1, 20);\n            cout << k;\n            for (int j = 0; j < k; j++) {\n                string w;\n                do {\n                    w = randomWord();\n                } while (usedWords.count(w) != 0);\n                cout << \" \" << w;\n            }\n            cout << endl;\n        }\n    } else if (type == \"exact_match\") {\n        // Lesha's problem matches an archive problem exactly\n        set<string> usedWords;\n        while (leshaWords.size() < n) {\n            string w = randomWord();\n            if (usedWords.count(w) == 0) {\n                leshaWords.push_back(w);\n                usedWords.insert(w);\n            }\n        }\n        cout << n << endl;\n        for (int i = 0; i < n; i++) {\n            cout << leshaWords[i];\n            if (i != n - 1) cout << \" \";\n        }\n        cout << endl;\n        cout << m << endl;\n        cout << n;\n        for (int i = 0; i < n; i++) {\n            cout << \" \" << leshaWords[i];\n        }\n        cout << endl;\n        for (int i = 1; i < m; i++) {\n            int k = rnd.next(1, 20);\n            cout << k;\n            for (int j = 0; j < k; j++) {\n                string w;\n                do {\n                    w = randomWord();\n                } while (usedWords.count(w) != 0);\n                cout << \" \" << w;\n            }\n            cout << endl;\n        }\n    } else if (type == \"subsequence_ordered\") {\n        // Archive problem contains Lesha's problem words as subsequence, in order\n        set<string> usedWords;\n        while (leshaWords.size() < n) {\n            string w = randomWord();\n            if (usedWords.count(w) == 0) {\n                leshaWords.push_back(w);\n                usedWords.insert(w);\n            }\n        }\n        cout << n << endl;\n        for (int i = 0; i < n; i++) {\n            cout << leshaWords[i];\n            if (i != n - 1) cout << \" \";\n        }\n        cout << endl;\n        cout << m << endl;\n        for (int i = 0; i < m; i++) {\n            int k = rnd.next(n, 20);\n            cout << k;\n            int pos = 0;\n            for (int j = 0; j < k; j++) {\n                string w;\n                if (pos < n && rnd.next(3) == 0) {\n                    // Place Lesha's words in order at random positions\n                    w = leshaWords[pos++];\n                } else {\n                    do {\n                        w = randomWord();\n                    } while (usedWords.count(w) != 0);\n                }\n                cout << \" \" << w;\n            }\n            cout << endl;\n        }\n    } else if (type == \"subsequence_unordered\") {\n        // Archive problem contains Lesha's problem words as subsequence, in random order\n        set<string> usedWords;\n        while (leshaWords.size() < n) {\n            string w = randomWord();\n            if (usedWords.count(w) == 0) {\n                leshaWords.push_back(w);\n                usedWords.insert(w);\n            }\n        }\n        cout << n << endl;\n        for (int i = 0; i < n; i++) {\n            cout << leshaWords[i];\n            if (i != n - 1) cout << \" \";\n        }\n        cout << endl;\n        cout << m << endl;\n        // For the first archive problem, insert Lesha's words as subsequence in random order\n        for (int i = 0; i < m; i++) {\n            int k = rnd.next(n, 20);\n            vector<string> archWords;\n            int pos = 0;\n            for (int j = 0; j < k; j++) {\n                if (pos < n && rnd.next(k) < n) {\n                    archWords.push_back(leshaWords[pos++]);\n                } else {\n                    string w;\n                    do {\n                        w = randomWord();\n                    } while (usedWords.count(w) != 0);\n                    archWords.push_back(w);\n                }\n            }\n            // Shuffle Lesha's words before assigning them to positions\n            shuffle(leshaWords.begin(), leshaWords.end());\n            // Now place Lesha's words into archWords in random positions\n            int lpos = 0;\n            for (int j = 0; j < k && lpos < n; j++) {\n                if (archWords[j] == leshaWords[0]) {\n                    archWords[j] = leshaWords[lpos++];\n                }\n            }\n            cout << k;\n            for (int j = 0; j < archWords.size(); j++) {\n                cout << \" \" << archWords[j];\n            }\n            cout << endl;\n        }\n    } else {\n        // Random test case\n        set<string> usedWords;\n        while (leshaWords.size() < n) {\n            string w = randomWord();\n            if (usedWords.count(w) == 0) {\n                leshaWords.push_back(w);\n                usedWords.insert(w);\n            }\n        }\n        cout << n << endl;\n        for (int i = 0; i < n; i++) {\n            cout << leshaWords[i];\n            if (i != n - 1) cout << \" \";\n        }\n        cout << endl;\n        cout << m << endl;\n        for (int i = 0; i < m; i++) {\n            int k = rnd.next(1, 20);\n            cout << k;\n            for (int j = 0; j < k; j++) {\n                string w;\n                if (rnd.next(10) == 0 && !leshaWords.empty()) {\n                    w = leshaWords[rnd.next(leshaWords.size())];\n                } else {\n                    w = randomWord();\n                }\n                cout << \" \" << w;\n            }\n            cout << endl;\n        }\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -m 1 -type minimal\n./gen -n 4 -m 10 -type maximal\n./gen -n 4 -m 10 -type brand_new\n./gen -n 4 -m 10 -type exact_match\n./gen -n 3 -m 5 -type subsequence_ordered\n./gen -n 3 -m 5 -type subsequence_unordered\n./gen -n 2 -m 3 -type random\n./gen -n 3 -m 2 -type random\n./gen -n 2 -m 5 -type exact_match\n./gen -n 1 -m 10 -type brand_new\n./gen -n 4 -m 5 -type subsequence_ordered\n./gen -n 4 -m 5 -type subsequence_unordered\n./gen -n 2 -m 5 -type brand_new\n./gen -n 3 -m 5 -type minimal\n./gen -n 1 -m 1 -type maximal\n./gen -n 4 -m 1 -type minimal\n./gen -n 2 -m 10 -type random\n./gen -n 3 -m 10 -type random\n./gen -n 1 -m 3 -type random\n./gen -n 4 -m 10 -type random\n./gen -n 2 -m 3 -type subsequence_ordered\n./gen -n 3 -m 2 -type subsequence_unordered\n./gen -n 2 -m 1 -type exact_match\n./gen -n 3 -m 10 -type brand_new\n./gen -n 4 -m 1 -type exact_match\n./gen -n 1 -m 5 -type subsequence_ordered\n./gen -n 1 -m 5 -type subsequence_unordered\n./gen -n 4 -m 10 -type minimal\n./gen -n 4 -m 10 -type random\n./gen -n 2 -m 10 -type maximal\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T19:48:14.915930",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "202/C",
      "title": "C. Clear Symmetry",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe only line contains a single integer x (1 ≤ x ≤ 100) — the required sharpness of the matrix.",
      "output_spec": "OutputPrint a single number — the sought value of n.",
      "sample_tests": "ExamplesInputCopy4OutputCopy3InputCopy9OutputCopy5",
      "description": "C. Clear Symmetry\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe only line contains a single integer x (1 ≤ x ≤ 100) — the required sharpness of the matrix.\n\nOutputPrint a single number — the sought value of n.\n\nInputCopy4OutputCopy3InputCopy9OutputCopy5\n\nOutputCopy3\n\nOutputCopy5\n\nNoteThe figure below shows the matrices that correspond to the samples:",
      "solutions": [
        {
          "title": "Codeforces Round #127 - Codeforces",
          "content": "Hello everyone!As many of you already know, today is the day for Codeforces Round #127 missing which is really undesirable ;)Original problems for you were created by tourist and Romka. We tried to emphasize the ideological component of the problems, thus we hope that you'll spend more time thinking than coding. Special thanks for helping in setting the contest go to Codeforces coordinator Gerald. We also thank Delinur for translating the problem statements and Alex_KPR for reviewing them.We hope that this round won't be just a regular Codeforces round for you, but will bring you new experience and new knowledge. For the authors all problems are equally easy, yet we tried to arrange them in decreasing order of simplicity :)Problems' point values in Division 1 are 1000-1000-1500-2000-2500. Problems' point values in Division 2 are 500-1000-2000-2000-2500.Wish you success!UPD: The contest is over, thanks all for participating. We hope you enjoyed it :)In Division 1 rng_58 was a clear winner, solving all 5 problems in an hour and a half! No one else managed to solve all problems in two hours.The winners in Division 1 are (full results): rng_58 peter50216 liympanda White_Bear havaliza In Division 2 every problem was solved by somebody, but nobody managed to solve all problems. The battle was very tough and the gaps were very small.The winners in Division 2 are (full results): Leewings snow_lotus 72VanVector_SevNTU Congratulations to the winners!UPD2: The editorial is available now.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/4796",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1501
        },
        {
          "title": "Codeforces Round #127 — editorial - Codeforces",
          "content": "Problem A(div 2) — LLPSIt's assumed that this problem can be solved just looking at the samples and without reading the statement itself :)Let's find the letter in the given string which comes last in the alphabet, denote this letter by z. If this letter occurs p times in the given string, then the answer is string a consisting of letter z repeated p times.Why is it so? Using the definition of lexicographical comparison and the fact that z is the largest letter in the string it's easy to understand that if some other subsequence b of the given string is lexicographically larger than a, then string b should be longer than a and, moreover, a should be a prefix of b (that is, b should start with a). But string b must be a palindrome, therefore its last letter must be z. In this case string b must contain more occurrences of letter z than the original string s does, which is impossible as b is a subsequence of s.Besides that, the constraint on the length of the string was very low, so the problem could be solved using brute force. For every subsequence of the given string it's necessary to check whether it's a palindrome, and from all palindromic subsequences of s the lexicographically largest should be chosen as the answer. The complexity of such a solution is O(2n·n), where n is the length of the string (unlike the solution above with complexity O(n)).Problem В(div 2) — Brand New Easy ProblemThe constraints in this problem were so low that a solution with complexity O(m·kn) was just fine. In each problem's description it's enough to loop over all possible subsequences of words which are permutations of words in Lesha's problem, for each of them calculate the number of inversions and choose a permutation with the smallest number of inversions. This can result in a short solution using recursion or, for example, you can use several nested loops (from 1 to 4).Here is an example of pseudocode for n = 4: w - array of words of Lesha''s problem\ns - the description of the current problem\nbest = 100\nfor a = 1 to k do\n for b = 1 to k do\n for c = 1 to k do\n for d = 1 to k do\n if s[a] == w[1] and s[b] == w[2] and s[c] == w[3] and s[d] == w[4] then\n inversions = 0\n if a > b then inversions = inversions + 1\n if a > c then inversions = inversions + 1\n if a > d then inversions = inversions + 1\n if b > c then inversions = inversions + 1\n if b > d then inversions = inversions + 1\n if c > d then inversions = inversions + 1\n if inversions < best then\n best = inversionsAt the end you should choose the problem with the smallest value of best and print the answer in the corresponding form.Problem A(div 1)/C(div 2) — Clear SymmetryIt's interesting that originally the authors had an idea not to include the x = 3 case into pretests. Imagine the number of successful hacking attempts in this contest -- considering the fact that none of the first 43 solutions to this problem passed pretests :)Note that the sought n is always an odd number. Indeed, if n is even, then two central rows of matrix A must contain zeroes, otherwise there will exist two neighbouring cells containing ones. Similar restriction applies to two central columns of matrix A. Replacing two central rows with just one and two central columns with just one and leaving zeroes in them, we'll obtain a smaller matrix with the same sharpness.Note that the sharpness of a matrix with side n can't exceed . It's easy to see that it's possible to lay out \"domino pieces\" 1 by 2 without intersections on a field with side n (in other words, all cells except one can be divided into pairs so that each pair contains neighbouring cells). Then there can be at most one one in the cells under each \"domino piece\" in the corresponding matrix. Therefore, the total number of ones doesn't exceed .Note that a matrix with side n and sharpness exists for an odd n. Paint all cells of the matrix in chess order and put ones into black cells and zeroes into white cells. It's easy to see that such a matrix is both clear and symmetrical and has sharpenss exactly .Intuitively it seems that if there exists a matrix with sharpness there should also exist a matrix with every smaller sharpness. That's correct except only one case -- there doesn't exist a matrix with side 3 and sharpness 3, though there exists a matrix with side 3 and sharpness 5.Let's show that the claim above is correct for odd n ≥ 5. We'll build a matrix with sharpness as shown above and gradually turn ones into zeroes reducing the sharpness. Cells containing ones in the matrix can be divided into three types.The first type is the central cell. The number in it can be turned into zero and the matrix won't stop satisfying the required conditions.The second type is the cells in the central row and the central column (except central cell). Such cells are divided into pairs by the condition of symmetry -- if we turn the number in one of them into zero, we should turn the number in its pair cell into zero as well.The third type is all the other cells. Such cells are divided into groups of four by the condition of symmetry -- if we turn the number in one of them into zero, we should turn the number in all cells from this group into zero as well.Now for obtaining the required sharpness of x we'll act greedily. Let's turn ones into zeroes in third type cells by four until the current shapness exceeds x by less than 4 or there are no third type cells with ones remaining. After that let's turn ones into zeroes in second type cells by pairs while the current sharpness exceeds x by at least 2. At this moment the sharpness of our matrix is either x or x + 1. If it's equal to x + 1, let's put a zero into the central cell and obtain a matrix with sharpness x. It's easy to check that we'll be able to obtain a matrix with any sharpness acting this way.Why is this reasoning incorrect for n = 3? Because second type cells are absent in the matrix with sharpness 5 obtained from chess coloring. For n ≥ 5 this matrix contains cells of all types, which is important for the algorithm above. It's better to find the answers for x ≤ 5 by hand but carefully -- for example, a lot of contestants decided that the answer for x = 2 is 5 instead of 3.Problem В(div 1)/D(div 2) — Guess That Car!We need to find such x and y that the value of is minimum possible. This expression can be rewritten as . Note that the first part doesn't depend on y and the second part doesn't depend on x, so we can minimize these parts separately. Here is how to minimize , the second part is minimized similarly. As the expression in the brackets doesn't depend on j, this part can be rewritten as , where . Now it's enough to calculate the required value for all possible values of x and choose x for which this value is the smallest. The optimal value of y can be found similarly.The overall complexity of this solution is O(n·m + n2 + m2).As the objective function is convex, other approaches to this problem are possible, for example, ternary search, gradient descent or analytical approach (calculation of derivatives).The main hero of this problem is Ra16bit.Problem С(div 1)/E(div 2) — Fragile BridgesThere are a few different ways to solve this problem, the editorial contains one of them.For any solution the following fact is useful. Suppose the sought path starts on platform i and ends on platform j (i ≤ j, if that's not the case, we can reverse the path). Then all bridges between platforms i and j will be passed through an odd number of times, and all other bridges will be passed through an even number of times.Let's find the maximum length of a path with its ends on platforms i and j. To do that, let's find the following auxiliary values for each platform: lefti -- the maximum length of a path starting and ending on platform i and passing only through bridges to the left of platform i; rightj -- similarly for bridges to the right of platform j. Also for each bridge define oddi as the largest odd number not larger than ai, and for each platform define sumOddi as the sum of oddj for all bridges to the left of platform i.Then the maximum length of a path with its ends on platforms i and j is equal to lefti + rightj + (sumOddj - sumOddi), or, which is the same, (rightj + sumOddj) + (lefti - sumOddi).Now we can find the pair (i, j) for which this value is the largest in linear time. Let's loop over j. From the formula it's obvious that we should find such i ≤ j that (lefti - sumOddi) is the largest. If we loop over j from 1 to n, we can maintain the largest value of this expression for all i ≤ j and recalculate it when moving to the next j, comparing (leftj - sumOddj) with the current maximum and possibly updating this maximum. This way for each j we have to check only one value of i and not all i ≤ j.The last thing to show is how to find all lefti quickly (all rightj can be found similarly). Clearly left1 = 0, then we'll calculate lefti using lefti - 1. Note that when ai - 1 = 1, we have lefti = 0 as after passing the bridge to platform (i - 1) this bridge will collapse and it will be impossible to return to platform i. If ai - 1 > 1, then lefti = lefti - 1 + eveni - 1, where eveni - 1 is the largest even number not larger than ai - 1. Indeed, we can move to platform (i - 1), then move along the path corresponding to lefti - 1, and then move along the bridge between platforms (i - 1) and i until the limit on the number of transitions is less than 2 (finishing on platform i).The overall complexity of this solution is O(n).Problem D(div 1) — Brand New ProblemThe first solution coming to mind is dynamic programming f[i][j] =  (the smallest possible number of inversions to the moment if among the first j words of the archive problem we've found a permutation of words included in bitmask i). In this solution parameter j varies from 0 to 500000, parameter i varies from 0 to 215 - 1 and calculation of each value is possible in O(1) (we are either using the current word in the subsequence or not). That's too much.Let's make use of a standard technique: make the value of DP a new parameter and make one of the existing parameters the value of DP. Not for every DP this is possible, but at least it's possible for this one :)It's clear that with a fixed subset of words and a fixed number of inversions it's optimal to choose the first occurrences of these words giving this number of inversions. Let f[i][j] =  (the smallest number z such that among first z words of the archive problem there exists a permutation of words from bitmask i containing exactly j inversions). The basis of this DP is f[0][0] = 0, f[0][j] = ∞ for j > 0. Recalculation of values happens in the following way: loop over a word q from the bitmask i which was the last in the permutation. With the knowledge of this word and the number of inversions j it's easy to find how many inversions j' there were without this word — that's j minus the number of words in the mask which appeared later in Lesha's problem than word q. Let p = f[i^(1«q)][j']. Then we should consider p2 equal to the position of the next occurrence of word q after position p as a possible value for f[i][j]. To find p2 quickly we should fill an array next[500010][15] so that next[i][j] =  (the smallest position k > i such that the k-th word in the archive problem equals the j-th word in Lesha's problem) for each archive problem in advance. This array can be easily filled passing from right to left once.The total number of operations can be calculated as m·(k·n + 2n·Cn2·n), where m is the number of problems in the archive, k is the number of words in one archive problem description and n is the number of words in Lesha's problem description. Under the given constraints that is about 200 million operations, and the author's solutions (including a Java solution) worked for less than 2 seconds. The time limit was set with a margin -- 5 seconds.The main heroes of problems D(div 1) and B(div 2) are Chmel_Tolstiy and ivan.metelsky.Problem E(div 1) — Thoroughly Bureaucratic OrganizationLet's imagine that we have a magic function maxN(m, k) that returns, given m and k, the largest value of n such that it's possible to solve the problem for n people and m empty lines in the form using k requests. Then we'll be able to use binary search on the answer -- the number of requests k.Suppose we've made k requests. Let's match a string of length k to each person, where the i-th character is equal to 1 if this person is mentioned in the i-th request and 0 otherwise. Note that we'll be able to determine the exact appointment date for each person if and only if all n strings of length k are pairwise distinct. Indeed, if two persons' strings are the same, their appointment dates could be exchanged and the responses to the requests wouldn't have changed. If all strings are distinct, for each date we may find the person appointed for this date looking at the set of requests with responses containing this date and finding the person mentioned in the same set of requests.The constraint on m empty lines in the form means that each of k positions in the strings should contain no more than m ones in all n strings overall. Thus function maxN(m, k) should return the maximum size of a set of distinct k-bit strings meeting this condition. Let's make this restriction weaker: we'll search for a set such that the total number of ones in all n strings doesn't exceed k·m. As we'll prove later, the answer won't change.With this weaker restriction the problem can be solved using a simple greedy strategy. It's obvious that strings with smaller number of ones are better. Let's loop over the number of ones i in the string from 0 to k and also maintain a variable t containing the remaining number of ones (initially it's equal to k·m). Then at the i-th step we can take at most strings containing i ones. Let's add p to the answer and subtract p·i from t. Note that the values of Cki should be calculated with care -- they can turn out to be too large, so it's important not to allow overflows.It can be shown that the overall complexity of this algorithm is at most O(log2 n).The remaining thing is to prove the claim above. The idea of the proof below belongs to rng_58 (the author's proof is notably harder).Let's solve the problem with a greedy algorithm with the k·m constraint on the total number of ones. The resulting set of strings may not satisfy the restriction of m ones for each position. If it doesn't, some of the positions contain more than m ones and some contain less than m ones. Let's pick any position X containing more than m ones and any position Y containing less than m ones. Find all strings containing 1 at X and 0 at Y (suppose there are x such strings) and all strings containing 0 at X and 1 at Y (suppose there are y such strings). It's clear that x > y. In each of x strings we can try to put 0 at X and 1 at Y -- then the string we obtain will either remain unique in this set or coincide with one of those y strings (but only one). As x > y, for at least one of x strings the change above leaves this string unique. Let's take this string and put 0 at X and 1 at Y. Now position X contains one 1 less, and position Y contains one 1 more. It means that the total number of \"extra\" ones in the positions has been decreased (as Y still contains no more than m ones). Doing this operation for a needed number of times, we'll achieve our goal.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/4808",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 15409
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #127 - Codeforces - Code 1",
          "code": "1 0 0\n0 1 0\n1 0 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4796",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #127 - Codeforces - Code 2",
          "code": "1 0 0\n0 1 0\n1 0 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4796",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #127 - Codeforces - Code 3",
          "code": "0 0 1 0 0\n0 0 0 0 0\n0 0 1 0 0\n0 0 0 0 0\n0 0 1 0 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4796",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #127 - Codeforces - Code 4",
          "code": "0 0 1 0 0\n0 0 0 0 0\n0 0 1 0 0\n0 0 0 0 0\n0 0 1 0 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4796",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #127 - Codeforces - Code 5",
          "code": "0 1 0\n0 0 0\n0 1 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4796",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #127 - Codeforces - Code 6",
          "code": "0 1 0\n0 0 0\n0 1 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4796",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #127 - Codeforces - Code 7",
          "code": "0 1 0\n0 0 0\n0 1 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4796",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #127 - Codeforces - Code 8",
          "code": "0 1 0\n0 0 0\n0 1 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4796",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #127 — editorial - Codeforces - Code 1",
          "code": "w - array of words of Lesha''s problem\ns - the description of the current problem\nbest = 100\nfor a = 1 to k do\n    for b = 1 to k do\n        for c = 1 to k do\n            for d = 1 to k do\n                if s[a] == w[1] and s[b] == w[2] and s[c] == w[3] and s[d] == w[4] then\n                    inversions = 0\n                    if a > b then inversions = inversions + 1\n                    if a > c then inversions = inversions + 1\n                    if a > d then inversions = inversions + 1\n                    if b > c then inversions = inversions + 1\n                    if b > d then inversions = inversions + 1\n                    if c > d then inversions = inversions + 1\n                    if inversions < best then\n                        best = inversions",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4808",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #127 — editorial - Codeforces - Code 2",
          "code": "w - array of words of Lesha''s problem\ns - the description of the current problem\nbest = 100\nfor a = 1 to k do\n    for b = 1 to k do\n        for c = 1 to k do\n            for d = 1 to k do\n                if s[a] == w[1] and s[b] == w[2] and s[c] == w[3] and s[d] == w[4] then\n                    inversions = 0\n                    if a > b then inversions = inversions + 1\n                    if a > c then inversions = inversions + 1\n                    if a > d then inversions = inversions + 1\n                    if b > c then inversions = inversions + 1\n                    if b > d then inversions = inversions + 1\n                    if c > d then inversions = inversions + 1\n                    if inversions < best then\n                        best = inversions",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4808",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #127 — editorial - Codeforces - Code 3",
          "code": "REP(mask,(1<<15)) REP(i,15) for(j=i;j<15;j++) if(mask&(1<<j)) cost[mask][i]++;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4808",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int x = inf.readInt(1, 100, \"x\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int x = inf.readInt(1, 100, \"x\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int x = inf.readInt(1, 100, \"x\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    // Register the generator with Testlib\n    registerGen(argc, argv, 1);\n\n    // We will produce exactly one integer x in [1..100].\n    // \"mode\" determines how x is generated.\n    // Supported modes:\n    //   1) \"min\": Always output 1\n    //   2) \"max\": Always output 100\n    //   3) \"smallRandom\": Random integer in [1..10]\n    //   4) \"mediumRandom\": Random integer in [11..50]\n    //   5) \"largeRandom\": Random integer in [51..100]\n    //   6) \"special\": Randomly pick from a small set of tricky values\n    //   7) \"direct\": Output the integer given by parameter \"val\", ensuring 1 <= val <= 100\n    //   8) \"random\" (default): Random integer in [1..100]\n\n    string mode = opt<string>(\"mode\", \"random\");\n    int val = opt<int>(\"val\", -1);   // only used when mode == \"direct\"\n\n    int x = 1; // default initialization\n\n    if (mode == \"min\") {\n        x = 1;\n    } \n    else if (mode == \"max\") {\n        x = 100;\n    }\n    else if (mode == \"smallRandom\") {\n        x = rnd.next(1, 10);\n    }\n    else if (mode == \"mediumRandom\") {\n        x = rnd.next(11, 50);\n    }\n    else if (mode == \"largeRandom\") {\n        x = rnd.next(51, 100);\n    }\n    else if (mode == \"special\") {\n        // a collection of tricky values within [1..100]\n        vector<int> specialVals {2, 3, 4, 5, 6, 7, 8, 9, 25, 49, 50, 51, 99, 100};\n        x = specialVals[rnd.next((int)specialVals.size())];\n    }\n    else if (mode == \"direct\") {\n        // direct usage of val, ensuring it is in range\n        // (the generator user must guarantee that val is valid)\n        // but we clamp just in case\n        x = max(1, min(100, val));\n    }\n    else {\n        // default \"random\"\n        x = rnd.next(1, 100);\n    }\n\n    // Output the single integer x\n    cout << x << endl;\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    // Register the generator with Testlib\n    registerGen(argc, argv, 1);\n\n    // We will produce exactly one integer x in [1..100].\n    // \"mode\" determines how x is generated.\n    // Supported modes:\n    //   1) \"min\": Always output 1\n    //   2) \"max\": Always output 100\n    //   3) \"smallRandom\": Random integer in [1..10]\n    //   4) \"mediumRandom\": Random integer in [11..50]\n    //   5) \"largeRandom\": Random integer in [51..100]\n    //   6) \"special\": Randomly pick from a small set of tricky values\n    //   7) \"direct\": Output the integer given by parameter \"val\", ensuring 1 <= val <= 100\n    //   8) \"random\" (default): Random integer in [1..100]\n\n    string mode = opt<string>(\"mode\", \"random\");\n    int val = opt<int>(\"val\", -1);   // only used when mode == \"direct\"\n\n    int x = 1; // default initialization\n\n    if (mode == \"min\") {\n        x = 1;\n    } \n    else if (mode == \"max\") {\n        x = 100;\n    }\n    else if (mode == \"smallRandom\") {\n        x = rnd.next(1, 10);\n    }\n    else if (mode == \"mediumRandom\") {\n        x = rnd.next(11, 50);\n    }\n    else if (mode == \"largeRandom\") {\n        x = rnd.next(51, 100);\n    }\n    else if (mode == \"special\") {\n        // a collection of tricky values within [1..100]\n        vector<int> specialVals {2, 3, 4, 5, 6, 7, 8, 9, 25, 49, 50, 51, 99, 100};\n        x = specialVals[rnd.next((int)specialVals.size())];\n    }\n    else if (mode == \"direct\") {\n        // direct usage of val, ensuring it is in range\n        // (the generator user must guarantee that val is valid)\n        // but we clamp just in case\n        x = max(1, min(100, val));\n    }\n    else {\n        // default \"random\"\n        x = rnd.next(1, 100);\n    }\n\n    // Output the single integer x\n    cout << x << endl;\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Below are approximately 20 DISTINCT commands to run this generator:\n# Each command prints exactly one integer x to stdout.\n\n# 1. Minimal possible value\n./gen -mode min\n\n# 2. Maximum possible value\n./gen -mode max\n\n# 3. Small random value in [1..10]\n./gen -mode smallRandom\n\n# 4. Another small random\n./gen -mode smallRandom\n\n# 5. Medium random in [11..50]\n./gen -mode mediumRandom\n\n# 6. Another medium random\n./gen -mode mediumRandom\n\n# 7. Large random in [51..100]\n./gen -mode largeRandom\n\n# 8. Another large random\n./gen -mode largeRandom\n\n# 9. Special set (includes interesting corner cases)\n./gen -mode special\n\n# 10. Another special\n./gen -mode special\n\n# 11. Direct value = 1\n./gen -mode direct -val 1\n\n# 12. Direct value = 3 (notable because the official solution has a small tweak for x=3)\n./gen -mode direct -val 3\n\n# 13. Direct value = 4 (from the sample input in the statement)\n./gen -mode direct -val 4\n\n# 14. Direct value = 9 (another sample input in the statement)\n./gen -mode direct -val 9\n\n# 15. Direct value = 50\n./gen -mode direct -val 50\n\n# 16. Direct value = 51\n./gen -mode direct -val 51\n\n# 17. Direct value = 99\n./gen -mode direct -val 99\n\n# 18. Direct value = 100\n./gen -mode direct -val 100\n\n# 19. Fully random in [1..100] (default mode)\n./gen\n\n# 20. Another fully random\n./gen\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T19:48:16.985528",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "202/D",
      "title": "D. Guess That Car!",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains two integers n and m (1 ≤ n, m ≤ 1000) — the sizes of the parking lot. Each of the next n lines contains m integers: the j-th number in the i-th line describes the \"rarity\" cij (0 ≤ cij ≤ 100000) of the car that is located in the square with coordinates (i, j).",
      "output_spec": "OutputIn the first line print the minimum total time Yura needs to guess all offered cars. In the second line print two numbers li and lj (0 ≤ li ≤ n, 0 ≤ lj ≤ m) — the numbers of dividing lines that form a junction that Yura should choose to stand on at the beginning of the game show. If there are multiple optimal starting points, print the point with smaller li. If there are still multiple such points, print the point with smaller lj.Please do not use the %lld specifier to read or write 64-bit integers in С++. It is preferred to use the cin, cout streams or the %I64d specifier.",
      "sample_tests": "ExamplesInputCopy2 33 4 53 9 1OutputCopy3921 1InputCopy3 41 0 0 00 0 3 00 0 5 5OutputCopy2402 3",
      "description": "D. Guess That Car!\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains two integers n and m (1 ≤ n, m ≤ 1000) — the sizes of the parking lot. Each of the next n lines contains m integers: the j-th number in the i-th line describes the \"rarity\" cij (0 ≤ cij ≤ 100000) of the car that is located in the square with coordinates (i, j).\n\nOutputIn the first line print the minimum total time Yura needs to guess all offered cars. In the second line print two numbers li and lj (0 ≤ li ≤ n, 0 ≤ lj ≤ m) — the numbers of dividing lines that form a junction that Yura should choose to stand on at the beginning of the game show. If there are multiple optimal starting points, print the point with smaller li. If there are still multiple such points, print the point with smaller lj.Please do not use the %lld specifier to read or write 64-bit integers in С++. It is preferred to use the cin, cout streams or the %I64d specifier.\n\nInputCopy2 33 4 53 9 1OutputCopy3921 1InputCopy3 41 0 0 00 0 3 00 0 5 5OutputCopy2402 3\n\nInputCopy2 33 4 53 9 1\n\nOutputCopy3921 1\n\nInputCopy3 41 0 0 00 0 3 00 0 5 5\n\nOutputCopy2402 3\n\nNoteIn the first test case the total time of guessing all cars is equal to 3·8 + 3·8 + 4·8 + 9·8 + 5·40 + 1·40 = 392.The coordinate system of the field:",
      "solutions": [
        {
          "title": "Codeforces Round #127 - Codeforces",
          "content": "Hello everyone!As many of you already know, today is the day for Codeforces Round #127 missing which is really undesirable ;)Original problems for you were created by tourist and Romka. We tried to emphasize the ideological component of the problems, thus we hope that you'll spend more time thinking than coding. Special thanks for helping in setting the contest go to Codeforces coordinator Gerald. We also thank Delinur for translating the problem statements and Alex_KPR for reviewing them.We hope that this round won't be just a regular Codeforces round for you, but will bring you new experience and new knowledge. For the authors all problems are equally easy, yet we tried to arrange them in decreasing order of simplicity :)Problems' point values in Division 1 are 1000-1000-1500-2000-2500. Problems' point values in Division 2 are 500-1000-2000-2000-2500.Wish you success!UPD: The contest is over, thanks all for participating. We hope you enjoyed it :)In Division 1 rng_58 was a clear winner, solving all 5 problems in an hour and a half! No one else managed to solve all problems in two hours.The winners in Division 1 are (full results): rng_58 peter50216 liympanda White_Bear havaliza In Division 2 every problem was solved by somebody, but nobody managed to solve all problems. The battle was very tough and the gaps were very small.The winners in Division 2 are (full results): Leewings snow_lotus 72VanVector_SevNTU Congratulations to the winners!UPD2: The editorial is available now.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/4796",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1501
        },
        {
          "title": "Codeforces Round #127 — editorial - Codeforces",
          "content": "Problem A(div 2) — LLPSIt's assumed that this problem can be solved just looking at the samples and without reading the statement itself :)Let's find the letter in the given string which comes last in the alphabet, denote this letter by z. If this letter occurs p times in the given string, then the answer is string a consisting of letter z repeated p times.Why is it so? Using the definition of lexicographical comparison and the fact that z is the largest letter in the string it's easy to understand that if some other subsequence b of the given string is lexicographically larger than a, then string b should be longer than a and, moreover, a should be a prefix of b (that is, b should start with a). But string b must be a palindrome, therefore its last letter must be z. In this case string b must contain more occurrences of letter z than the original string s does, which is impossible as b is a subsequence of s.Besides that, the constraint on the length of the string was very low, so the problem could be solved using brute force. For every subsequence of the given string it's necessary to check whether it's a palindrome, and from all palindromic subsequences of s the lexicographically largest should be chosen as the answer. The complexity of such a solution is O(2n·n), where n is the length of the string (unlike the solution above with complexity O(n)).Problem В(div 2) — Brand New Easy ProblemThe constraints in this problem were so low that a solution with complexity O(m·kn) was just fine. In each problem's description it's enough to loop over all possible subsequences of words which are permutations of words in Lesha's problem, for each of them calculate the number of inversions and choose a permutation with the smallest number of inversions. This can result in a short solution using recursion or, for example, you can use several nested loops (from 1 to 4).Here is an example of pseudocode for n = 4: w - array of words of Lesha''s problem\ns - the description of the current problem\nbest = 100\nfor a = 1 to k do\n for b = 1 to k do\n for c = 1 to k do\n for d = 1 to k do\n if s[a] == w[1] and s[b] == w[2] and s[c] == w[3] and s[d] == w[4] then\n inversions = 0\n if a > b then inversions = inversions + 1\n if a > c then inversions = inversions + 1\n if a > d then inversions = inversions + 1\n if b > c then inversions = inversions + 1\n if b > d then inversions = inversions + 1\n if c > d then inversions = inversions + 1\n if inversions < best then\n best = inversionsAt the end you should choose the problem with the smallest value of best and print the answer in the corresponding form.Problem A(div 1)/C(div 2) — Clear SymmetryIt's interesting that originally the authors had an idea not to include the x = 3 case into pretests. Imagine the number of successful hacking attempts in this contest -- considering the fact that none of the first 43 solutions to this problem passed pretests :)Note that the sought n is always an odd number. Indeed, if n is even, then two central rows of matrix A must contain zeroes, otherwise there will exist two neighbouring cells containing ones. Similar restriction applies to two central columns of matrix A. Replacing two central rows with just one and two central columns with just one and leaving zeroes in them, we'll obtain a smaller matrix with the same sharpness.Note that the sharpness of a matrix with side n can't exceed . It's easy to see that it's possible to lay out \"domino pieces\" 1 by 2 without intersections on a field with side n (in other words, all cells except one can be divided into pairs so that each pair contains neighbouring cells). Then there can be at most one one in the cells under each \"domino piece\" in the corresponding matrix. Therefore, the total number of ones doesn't exceed .Note that a matrix with side n and sharpness exists for an odd n. Paint all cells of the matrix in chess order and put ones into black cells and zeroes into white cells. It's easy to see that such a matrix is both clear and symmetrical and has sharpenss exactly .Intuitively it seems that if there exists a matrix with sharpness there should also exist a matrix with every smaller sharpness. That's correct except only one case -- there doesn't exist a matrix with side 3 and sharpness 3, though there exists a matrix with side 3 and sharpness 5.Let's show that the claim above is correct for odd n ≥ 5. We'll build a matrix with sharpness as shown above and gradually turn ones into zeroes reducing the sharpness. Cells containing ones in the matrix can be divided into three types.The first type is the central cell. The number in it can be turned into zero and the matrix won't stop satisfying the required conditions.The second type is the cells in the central row and the central column (except central cell). Such cells are divided into pairs by the condition of symmetry -- if we turn the number in one of them into zero, we should turn the number in its pair cell into zero as well.The third type is all the other cells. Such cells are divided into groups of four by the condition of symmetry -- if we turn the number in one of them into zero, we should turn the number in all cells from this group into zero as well.Now for obtaining the required sharpness of x we'll act greedily. Let's turn ones into zeroes in third type cells by four until the current shapness exceeds x by less than 4 or there are no third type cells with ones remaining. After that let's turn ones into zeroes in second type cells by pairs while the current sharpness exceeds x by at least 2. At this moment the sharpness of our matrix is either x or x + 1. If it's equal to x + 1, let's put a zero into the central cell and obtain a matrix with sharpness x. It's easy to check that we'll be able to obtain a matrix with any sharpness acting this way.Why is this reasoning incorrect for n = 3? Because second type cells are absent in the matrix with sharpness 5 obtained from chess coloring. For n ≥ 5 this matrix contains cells of all types, which is important for the algorithm above. It's better to find the answers for x ≤ 5 by hand but carefully -- for example, a lot of contestants decided that the answer for x = 2 is 5 instead of 3.Problem В(div 1)/D(div 2) — Guess That Car!We need to find such x and y that the value of is minimum possible. This expression can be rewritten as . Note that the first part doesn't depend on y and the second part doesn't depend on x, so we can minimize these parts separately. Here is how to minimize , the second part is minimized similarly. As the expression in the brackets doesn't depend on j, this part can be rewritten as , where . Now it's enough to calculate the required value for all possible values of x and choose x for which this value is the smallest. The optimal value of y can be found similarly.The overall complexity of this solution is O(n·m + n2 + m2).As the objective function is convex, other approaches to this problem are possible, for example, ternary search, gradient descent or analytical approach (calculation of derivatives).The main hero of this problem is Ra16bit.Problem С(div 1)/E(div 2) — Fragile BridgesThere are a few different ways to solve this problem, the editorial contains one of them.For any solution the following fact is useful. Suppose the sought path starts on platform i and ends on platform j (i ≤ j, if that's not the case, we can reverse the path). Then all bridges between platforms i and j will be passed through an odd number of times, and all other bridges will be passed through an even number of times.Let's find the maximum length of a path with its ends on platforms i and j. To do that, let's find the following auxiliary values for each platform: lefti -- the maximum length of a path starting and ending on platform i and passing only through bridges to the left of platform i; rightj -- similarly for bridges to the right of platform j. Also for each bridge define oddi as the largest odd number not larger than ai, and for each platform define sumOddi as the sum of oddj for all bridges to the left of platform i.Then the maximum length of a path with its ends on platforms i and j is equal to lefti + rightj + (sumOddj - sumOddi), or, which is the same, (rightj + sumOddj) + (lefti - sumOddi).Now we can find the pair (i, j) for which this value is the largest in linear time. Let's loop over j. From the formula it's obvious that we should find such i ≤ j that (lefti - sumOddi) is the largest. If we loop over j from 1 to n, we can maintain the largest value of this expression for all i ≤ j and recalculate it when moving to the next j, comparing (leftj - sumOddj) with the current maximum and possibly updating this maximum. This way for each j we have to check only one value of i and not all i ≤ j.The last thing to show is how to find all lefti quickly (all rightj can be found similarly). Clearly left1 = 0, then we'll calculate lefti using lefti - 1. Note that when ai - 1 = 1, we have lefti = 0 as after passing the bridge to platform (i - 1) this bridge will collapse and it will be impossible to return to platform i. If ai - 1 > 1, then lefti = lefti - 1 + eveni - 1, where eveni - 1 is the largest even number not larger than ai - 1. Indeed, we can move to platform (i - 1), then move along the path corresponding to lefti - 1, and then move along the bridge between platforms (i - 1) and i until the limit on the number of transitions is less than 2 (finishing on platform i).The overall complexity of this solution is O(n).Problem D(div 1) — Brand New ProblemThe first solution coming to mind is dynamic programming f[i][j] =  (the smallest possible number of inversions to the moment if among the first j words of the archive problem we've found a permutation of words included in bitmask i). In this solution parameter j varies from 0 to 500000, parameter i varies from 0 to 215 - 1 and calculation of each value is possible in O(1) (we are either using the current word in the subsequence or not). That's too much.Let's make use of a standard technique: make the value of DP a new parameter and make one of the existing parameters the value of DP. Not for every DP this is possible, but at least it's possible for this one :)It's clear that with a fixed subset of words and a fixed number of inversions it's optimal to choose the first occurrences of these words giving this number of inversions. Let f[i][j] =  (the smallest number z such that among first z words of the archive problem there exists a permutation of words from bitmask i containing exactly j inversions). The basis of this DP is f[0][0] = 0, f[0][j] = ∞ for j > 0. Recalculation of values happens in the following way: loop over a word q from the bitmask i which was the last in the permutation. With the knowledge of this word and the number of inversions j it's easy to find how many inversions j' there were without this word — that's j minus the number of words in the mask which appeared later in Lesha's problem than word q. Let p = f[i^(1«q)][j']. Then we should consider p2 equal to the position of the next occurrence of word q after position p as a possible value for f[i][j]. To find p2 quickly we should fill an array next[500010][15] so that next[i][j] =  (the smallest position k > i such that the k-th word in the archive problem equals the j-th word in Lesha's problem) for each archive problem in advance. This array can be easily filled passing from right to left once.The total number of operations can be calculated as m·(k·n + 2n·Cn2·n), where m is the number of problems in the archive, k is the number of words in one archive problem description and n is the number of words in Lesha's problem description. Under the given constraints that is about 200 million operations, and the author's solutions (including a Java solution) worked for less than 2 seconds. The time limit was set with a margin -- 5 seconds.The main heroes of problems D(div 1) and B(div 2) are Chmel_Tolstiy and ivan.metelsky.Problem E(div 1) — Thoroughly Bureaucratic OrganizationLet's imagine that we have a magic function maxN(m, k) that returns, given m and k, the largest value of n such that it's possible to solve the problem for n people and m empty lines in the form using k requests. Then we'll be able to use binary search on the answer -- the number of requests k.Suppose we've made k requests. Let's match a string of length k to each person, where the i-th character is equal to 1 if this person is mentioned in the i-th request and 0 otherwise. Note that we'll be able to determine the exact appointment date for each person if and only if all n strings of length k are pairwise distinct. Indeed, if two persons' strings are the same, their appointment dates could be exchanged and the responses to the requests wouldn't have changed. If all strings are distinct, for each date we may find the person appointed for this date looking at the set of requests with responses containing this date and finding the person mentioned in the same set of requests.The constraint on m empty lines in the form means that each of k positions in the strings should contain no more than m ones in all n strings overall. Thus function maxN(m, k) should return the maximum size of a set of distinct k-bit strings meeting this condition. Let's make this restriction weaker: we'll search for a set such that the total number of ones in all n strings doesn't exceed k·m. As we'll prove later, the answer won't change.With this weaker restriction the problem can be solved using a simple greedy strategy. It's obvious that strings with smaller number of ones are better. Let's loop over the number of ones i in the string from 0 to k and also maintain a variable t containing the remaining number of ones (initially it's equal to k·m). Then at the i-th step we can take at most strings containing i ones. Let's add p to the answer and subtract p·i from t. Note that the values of Cki should be calculated with care -- they can turn out to be too large, so it's important not to allow overflows.It can be shown that the overall complexity of this algorithm is at most O(log2 n).The remaining thing is to prove the claim above. The idea of the proof below belongs to rng_58 (the author's proof is notably harder).Let's solve the problem with a greedy algorithm with the k·m constraint on the total number of ones. The resulting set of strings may not satisfy the restriction of m ones for each position. If it doesn't, some of the positions contain more than m ones and some contain less than m ones. Let's pick any position X containing more than m ones and any position Y containing less than m ones. Find all strings containing 1 at X and 0 at Y (suppose there are x such strings) and all strings containing 0 at X and 1 at Y (suppose there are y such strings). It's clear that x > y. In each of x strings we can try to put 0 at X and 1 at Y -- then the string we obtain will either remain unique in this set or coincide with one of those y strings (but only one). As x > y, for at least one of x strings the change above leaves this string unique. Let's take this string and put 0 at X and 1 at Y. Now position X contains one 1 less, and position Y contains one 1 more. It means that the total number of \"extra\" ones in the positions has been decreased (as Y still contains no more than m ones). Doing this operation for a needed number of times, we'll achieve our goal.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/4808",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 15409
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #127 - Codeforces - Code 1",
          "code": "1 0 0\n0 1 0\n1 0 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4796",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #127 - Codeforces - Code 2",
          "code": "1 0 0\n0 1 0\n1 0 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4796",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #127 - Codeforces - Code 3",
          "code": "0 0 1 0 0\n0 0 0 0 0\n0 0 1 0 0\n0 0 0 0 0\n0 0 1 0 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4796",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #127 - Codeforces - Code 4",
          "code": "0 0 1 0 0\n0 0 0 0 0\n0 0 1 0 0\n0 0 0 0 0\n0 0 1 0 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4796",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #127 - Codeforces - Code 5",
          "code": "0 1 0\n0 0 0\n0 1 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4796",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #127 - Codeforces - Code 6",
          "code": "0 1 0\n0 0 0\n0 1 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4796",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #127 - Codeforces - Code 7",
          "code": "0 1 0\n0 0 0\n0 1 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4796",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #127 - Codeforces - Code 8",
          "code": "0 1 0\n0 0 0\n0 1 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4796",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #127 — editorial - Codeforces - Code 1",
          "code": "w - array of words of Lesha''s problem\ns - the description of the current problem\nbest = 100\nfor a = 1 to k do\n    for b = 1 to k do\n        for c = 1 to k do\n            for d = 1 to k do\n                if s[a] == w[1] and s[b] == w[2] and s[c] == w[3] and s[d] == w[4] then\n                    inversions = 0\n                    if a > b then inversions = inversions + 1\n                    if a > c then inversions = inversions + 1\n                    if a > d then inversions = inversions + 1\n                    if b > c then inversions = inversions + 1\n                    if b > d then inversions = inversions + 1\n                    if c > d then inversions = inversions + 1\n                    if inversions < best then\n                        best = inversions",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4808",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #127 — editorial - Codeforces - Code 2",
          "code": "w - array of words of Lesha''s problem\ns - the description of the current problem\nbest = 100\nfor a = 1 to k do\n    for b = 1 to k do\n        for c = 1 to k do\n            for d = 1 to k do\n                if s[a] == w[1] and s[b] == w[2] and s[c] == w[3] and s[d] == w[4] then\n                    inversions = 0\n                    if a > b then inversions = inversions + 1\n                    if a > c then inversions = inversions + 1\n                    if a > d then inversions = inversions + 1\n                    if b > c then inversions = inversions + 1\n                    if b > d then inversions = inversions + 1\n                    if c > d then inversions = inversions + 1\n                    if inversions < best then\n                        best = inversions",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4808",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #127 — editorial - Codeforces - Code 3",
          "code": "REP(mask,(1<<15)) REP(i,15) for(j=i;j<15;j++) if(mask&(1<<j)) cost[mask][i]++;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4808",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 1000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 1000, \"m\");\n    inf.readEoln();\n\n    for (int i = 0; i < n; ++i) {\n        vector<int> row = inf.readInts(m, 0, 100000);\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 1000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 1000, \"m\");\n    inf.readEoln();\n\n    for (int i = 0; i < n; ++i) {\n        vector<int> row = inf.readInts(m, 0, 100000);\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 1000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 1000, \"m\");\n    inf.readEoln();\n\n    for (int i = 0; i < n; ++i) {\n        vector<int> row = inf.readInts(m, 0, 100000);\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<vector<int>> c(n, vector<int>(m));\n\n    if (type == \"minsize\") {\n        // n and m should be 1\n        n = 1;\n        m = 1;\n        c.resize(n, vector<int>(m));\n        c[0][0] = rnd.next(0, 100000);\n    } else if (type == \"maxsize\") {\n        n = 1000;\n        m = 1000;\n        c.resize(n, vector<int>(m));\n        for (int i = 0; i < n; ++i)\n            for (int j = 0; j < m; ++j)\n                c[i][j] = rnd.next(0, 100000);\n    } else if (type == \"zeros\") {\n        // All zeros\n        for (int i = 0; i < n; ++i)\n            fill(c[i].begin(), c[i].end(), 0);\n    } else if (type == \"maxrarity\") {\n        // All max\n        for (int i = 0; i < n; ++i)\n            fill(c[i].begin(), c[i].end(), 100000);\n    } else if (type == \"mixed\") {\n        // Random c_{ij} in [0, 1e5]\n        for (int i = 0; i < n; ++i)\n            for (int j = 0; j < m; ++j)\n                c[i][j] = rnd.next(0, 100000);\n    } else if (type == \"line\") {\n        string direction = opt<string>(\"direction\", \"random\");\n        int value = rnd.next(1, 100000);\n        if (direction == \"horizontal\" || (direction == \"random\" && rnd.next(0,1) == 0)) {\n            int row = rnd.next(0, n - 1);\n            for (int j = 0; j < m; ++j)\n                c[row][j] = value;\n        } else {\n            int col = rnd.next(0, m -1);\n            for (int i = 0; i < n; ++i)\n                c[i][col] = value;\n        }\n    } else if (type == \"symmetrical\") {\n        for (int i = 0; i <= n/2; ++i)\n            for (int j = 0; j <= m/2; ++j) {\n                int value = rnd.next(0, 100000);\n                c[i][j] = c[i][m-j-1] = c[n-i-1][j] = c[n-i-1][m-j-1] = value;\n            }\n    } else if (type == \"tie-break\") {\n        c[0][0] = c[n-1][m-1] = 100000;\n        c[0][m-1] = c[n-1][0] = 100000;\n        for (int i = 0; i < n; ++i)\n            for (int j = 0; j < m; ++j)\n                if (!((i == 0 && (j == 0 || j == m-1)) || (i == n-1 && (j == 0 || j == m-1))))\n                    c[i][j] = 0;\n    } else if (type == \"edge-case1\") {\n        c[0][0] = c[0][m-1] = c[n-1][0] = c[n-1][m-1] = 100000;\n        for (int i = 0; i < n; ++i)\n            for (int j = 0; j < m; ++j)\n                if (!((i == 0 && (j == 0 || j == m-1)) || (i == n-1 && (j == 0 || j == m-1))))\n                    c[i][j] = 0;\n    } else if (type == \"singleton\") {\n        int i0 = rnd.next(0, n-1);\n        int j0 = rnd.next(0, m-1);\n        for (int i = 0; i < n; ++i)\n            fill(c[i].begin(), c[i].end(), 0);\n        c[i0][j0] = 100000;\n    } else if (type == \"edges\") {\n        for (int i = 0; i < n; ++i)\n            fill(c[i].begin(), c[i].end(), 0);\n        c[0][0] = c[0][m-1] = c[n-1][0] = c[n-1][m-1] = 100000;\n    } else if (type == \"checkerboard\") {\n        for (int i = 0; i < n; ++i)\n            for (int j = 0; j < m; ++j)\n                c[i][j] = ((i + j) % 2 == 0) ? 100000 : 0;\n    } else { // \"random\" or default\n        for (int i = 0; i < n; ++i)\n            for (int j = 0; j < m; ++j)\n                c[i][j] = rnd.next(0, 100000);\n    }\n\n    // Output\n    printf(\"%d %d\\n\", n, m);\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < m; ++j) {\n            printf(\"%d\", c[i][j]);\n            if (j < m - 1) printf(\" \");\n        }\n        printf(\"\\n\");\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<vector<int>> c(n, vector<int>(m));\n\n    if (type == \"minsize\") {\n        // n and m should be 1\n        n = 1;\n        m = 1;\n        c.resize(n, vector<int>(m));\n        c[0][0] = rnd.next(0, 100000);\n    } else if (type == \"maxsize\") {\n        n = 1000;\n        m = 1000;\n        c.resize(n, vector<int>(m));\n        for (int i = 0; i < n; ++i)\n            for (int j = 0; j < m; ++j)\n                c[i][j] = rnd.next(0, 100000);\n    } else if (type == \"zeros\") {\n        // All zeros\n        for (int i = 0; i < n; ++i)\n            fill(c[i].begin(), c[i].end(), 0);\n    } else if (type == \"maxrarity\") {\n        // All max\n        for (int i = 0; i < n; ++i)\n            fill(c[i].begin(), c[i].end(), 100000);\n    } else if (type == \"mixed\") {\n        // Random c_{ij} in [0, 1e5]\n        for (int i = 0; i < n; ++i)\n            for (int j = 0; j < m; ++j)\n                c[i][j] = rnd.next(0, 100000);\n    } else if (type == \"line\") {\n        string direction = opt<string>(\"direction\", \"random\");\n        int value = rnd.next(1, 100000);\n        if (direction == \"horizontal\" || (direction == \"random\" && rnd.next(0,1) == 0)) {\n            int row = rnd.next(0, n - 1);\n            for (int j = 0; j < m; ++j)\n                c[row][j] = value;\n        } else {\n            int col = rnd.next(0, m -1);\n            for (int i = 0; i < n; ++i)\n                c[i][col] = value;\n        }\n    } else if (type == \"symmetrical\") {\n        for (int i = 0; i <= n/2; ++i)\n            for (int j = 0; j <= m/2; ++j) {\n                int value = rnd.next(0, 100000);\n                c[i][j] = c[i][m-j-1] = c[n-i-1][j] = c[n-i-1][m-j-1] = value;\n            }\n    } else if (type == \"tie-break\") {\n        c[0][0] = c[n-1][m-1] = 100000;\n        c[0][m-1] = c[n-1][0] = 100000;\n        for (int i = 0; i < n; ++i)\n            for (int j = 0; j < m; ++j)\n                if (!((i == 0 && (j == 0 || j == m-1)) || (i == n-1 && (j == 0 || j == m-1))))\n                    c[i][j] = 0;\n    } else if (type == \"edge-case1\") {\n        c[0][0] = c[0][m-1] = c[n-1][0] = c[n-1][m-1] = 100000;\n        for (int i = 0; i < n; ++i)\n            for (int j = 0; j < m; ++j)\n                if (!((i == 0 && (j == 0 || j == m-1)) || (i == n-1 && (j == 0 || j == m-1))))\n                    c[i][j] = 0;\n    } else if (type == \"singleton\") {\n        int i0 = rnd.next(0, n-1);\n        int j0 = rnd.next(0, m-1);\n        for (int i = 0; i < n; ++i)\n            fill(c[i].begin(), c[i].end(), 0);\n        c[i0][j0] = 100000;\n    } else if (type == \"edges\") {\n        for (int i = 0; i < n; ++i)\n            fill(c[i].begin(), c[i].end(), 0);\n        c[0][0] = c[0][m-1] = c[n-1][0] = c[n-1][m-1] = 100000;\n    } else if (type == \"checkerboard\") {\n        for (int i = 0; i < n; ++i)\n            for (int j = 0; j < m; ++j)\n                c[i][j] = ((i + j) % 2 == 0) ? 100000 : 0;\n    } else { // \"random\" or default\n        for (int i = 0; i < n; ++i)\n            for (int j = 0; j < m; ++j)\n                c[i][j] = rnd.next(0, 100000);\n    }\n\n    // Output\n    printf(\"%d %d\\n\", n, m);\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < m; ++j) {\n            printf(\"%d\", c[i][j]);\n            if (j < m - 1) printf(\" \");\n        }\n        printf(\"\\n\");\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Small sizes\n./gen -n 1 -m 1 -type minsize\n./gen -n 1 -m 2 -type random\n./gen -n 2 -m 1 -type random\n\n# Medium sizes with different types\n./gen -n 10 -m 10 -type zeros\n./gen -n 10 -m 10 -type maxrarity\n./gen -n 10 -m 10 -type mixed\n./gen -n 10 -m 10 -type line -direction horizontal\n./gen -n 10 -m 10 -type line -direction vertical\n./gen -n 20 -m 20 -type symmetrical\n./gen -n 20 -m 20 -type checkerboard\n./gen -n 20 -m 20 -type tie-break\n./gen -n 20 -m 20 -type singleton\n\n# Large sizes\n./gen -n 1000 -m 1000 -type maxsize\n./gen -n 1000 -m 1000 -type zeros\n./gen -n 1000 -m 1000 -type maxrarity\n./gen -n 1000 -m 1000 -type mixed\n./gen -n 1000 -m 1000 -type line -direction horizontal\n./gen -n 1000 -m 1000 -type line -direction vertical\n./gen -n 1000 -m 1000 -type symmetrical\n./gen -n 1000 -m 1000 -type checkerboard\n./gen -n 1000 -m 1000 -type tie-break\n./gen -n 1000 -m 1000 -type edge-case1\n./gen -n 1000 -m 1000 -type singleton\n./gen -n 1000 -m 1000 -type edges\n\n# Other sizes\n./gen -n 500 -m 500 -type random\n./gen -n 1000 -m 1 -type random\n./gen -n 1 -m 1000 -type random\n\n# Random sizes and types\n./gen -n 123 -m 456 -type random\n./gen -n 789 -m 654 -type random\n\n# Additional cases\n./gen -n 999 -m 999 -type checkerboard\n./gen -n 999 -m 999 -type tie-break\n\n# Edge cases with heavy corner weights\n./gen -n 1000 -m 1000 -type edge-case1\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T19:48:19.138826",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "202/E",
      "title": "E. Хрупкие мосты",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест2 секунды",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеВ первой строке содержится целое число n (2 ≤ n ≤ 105) — количество платформ на бонусном уровне. Вторая строка содержит (n - 1) целых чисел ai (1 ≤ ai ≤ 109, 1 ≤ i < n) — количество переходов от одного конца до другого, которое может выдержать мост между платформами i и i + 1.",
      "output_spec": "Выходные данныеВыведите единственное число — максимальное количество очков, которое можно набрать на бонусном уровне.Пожалуйста, не используйте спецификатор %lld для чтения или записи 64-битных чисел на С++. Рекомендуется использовать потоки cin, cout или спецификатор %I64d.",
      "sample_tests": "ПримерыВходные данныеСкопировать52 1 2 1Выходные данныеСкопировать5",
      "description": "E. Хрупкие мосты\n\nограничение по времени на тест2 секунды\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвыводstdout\n\nВходные данныеВ первой строке содержится целое число n (2 ≤ n ≤ 105) — количество платформ на бонусном уровне. Вторая строка содержит (n - 1) целых чисел ai (1 ≤ ai ≤ 109, 1 ≤ i < n) — количество переходов от одного конца до другого, которое может выдержать мост между платформами i и i + 1.\n\nВходные данные\n\nВыходные данныеВыведите единственное число — максимальное количество очков, которое можно набрать на бонусном уровне.Пожалуйста, не используйте спецификатор %lld для чтения или записи 64-битных чисел на С++. Рекомендуется использовать потоки cin, cout или спецификатор %I64d.\n\nВыходные данные\n\nВходные данныеСкопировать52 1 2 1Выходные данныеСкопировать5\n\nВходные данныеСкопировать52 1 2 1\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать5\n\nВыходные данныеСкопировать\n\nСкопировать\n\nПримечаниеОдин из вариантов получить 5 очков в примере — начав с платформы 3, последовательно переходить на платформы 4, 3, 2, 1 и 2. После этого единственным нерухнувшим мостом останется мост между платформами 4 и 5, однако этот мост слишком далек от платформы 2, на которой расположен герой.",
      "solutions": [
        {
          "title": "Codeforces Round #127 - Codeforces",
          "content": "Всем привет!Как многие из вас уже знают, сегодня в обоих дивизионах состоится Codeforces Round #127, пропускать который очень не рекомендуется ;)Оригинальные задачи для вас придумывали и готовили tourist и Romka. Мы старались сделать упор на идейную составляющую задач, поэтому надеемся, что вам придётся думать дольше, чем набирать код. Отдельное спасибо за помощь в подготовке контеста координатору Codeforces Gerald. Также благодарим Delinur за перевод условий и Alex_KPR за вычитку условий.Надеемся, что этот раунд будет для вас не просто очередным раундом на Codeforces, а принесёт вам новый опыт и новые знания. Авторам все задачи кажутся одинаково простыми, но мы всё-таки постарались расположить их в порядке убывания простоты :)Разбалловка в первом дивизионе: 1000-1000-1500-2000-2500. Разбалловка во втором дивизионе: 500-1000-2000-2000-2500.Успехов!UPD: Соревнование закончено, всем спасибо за участие. Надеемся, вам понравилось :)В первом дивизионе безоговорочную победу одержал rng_58, решив все пять задач за полтора часа! Решить все задачи за два часа больше не удалось никому.Победители в первом дивизионе (полные результаты): rng_58 peter50216 liympanda White_Bear havaliza Во втором дивизионе каждая задача была кем-то решена, но решить все задачи не удалось никому. Борьба оказалась очень упорной, а разрывы -- очень маленькими.Победители во втором дивизионе (полные результаты): Leewings snow_lotus 72VanVector_SevNTU Поздравляем победителей!UPD2: Опубликован разбор задач.",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/4796",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 1493
        },
        {
          "title": "Codeforces Round #127 — разбор - Codeforces",
          "content": "Задача A(div 2) — ЛНПППредполагалось, что эту задачу можно решить, не читая её условия, а только глядя на примеры :)Найдём в заданной строке символ, который идёт в алфавите позже всех, обозначим его через z. Если этот символ встречается в строке p раз, то ответ — это строка a, состоящая из символа z, повторённого p раз.Почему это так? Из определения лексикографического сравнения и из того, что символ z — максимальный в строке, несложно понять, что если какая-то другая подпоследовательность b заданной строки лексикографически больше a, то строка b обязана иметь большую длину, чем a, и при этом a должна являться префиксом (началом) b. Однако строка b должна также быть палиндромом, поэтому последний её символ — обязательно z. В таком случае в строке b должно быть больше вхождений символа z, чем в исходной строке s, что невозможно, так как b --- подпоследовательность s.Кроме того, ограничение на длину строки было совсем небольшим, поэтому задачу можно было решить перебором всех подпоследовательностей строки. Для каждой из них нужно проверить, является ли она палиндромом, и из всех являющихся выбрать лексикографически наибольшую. Сложность такого решения составляет O(2n·n), где n — длина строки (в отличие от решения выше, сложность которого O(n)).Задача В(div 2) — Инновационно новая простая задачаОграничения в задаче были настолько малы, что проходило решение со сложностью O(m·kn). В описании каждой задачи достаточно перебрать все возможные подпоследовательности слов, являющиеся перестановками описания Лёшиной задачи, для каждой из них вычислить количество инверсий, и выбрать перестановку с минимальным количеством инверсий. Это можно сделать либо с помощью рекурсии, либо, например, с помощью необходимого количества вложенных циклов (от 1 до 4).Вот пример псевдокода для случая n = 4: w - массив слов задачи Лёши\ns - описание очередной задачи из архива\nbest = 100\nfor a = 1 to k do\n for b = 1 to k do\n for c = 1 to k do\n for d = 1 to k do\n if s[a] == w[1] and s[b] == w[2] and s[c] == w[3] and s[d] == w[4] then\n inversions = 0\n if a > b then inversions = inversions + 1\n if a > c then inversions = inversions + 1\n if a > d then inversions = inversions + 1\n if b > c then inversions = inversions + 1\n if b > d then inversions = inversions + 1\n if c > d then inversions = inversions + 1\n if inversions < best then\n best = inversionsВ конце нужно выбрать задачу с минимальным значением best и вывести ответ в соответствующем формате.Задача A(div 1)/C(div 2) — Чёткая симметрияИнтересно, что первоначально у авторов была идея не включать случай x = 3 в претесты. Представьте, сколько было бы в этом контесте сделано успешных взломов — при том, что из первых 43 решений по этой задаче ни одно претесты не прошло :)Заметим, что ответ n — всегда нечётное число. Действительно, если n чётно, то две центральные строки матрицы A обязаны содержать только нули — в противном случае найдутся две соседние клетки, содержащие единицы. Аналогичное требование относится и к двум центральным столбцам матрицы A. Заменив две центральные строки на одну и два центральных столбца на один, при этом оставив в них нули, получим матрицу с такой же остротой, но со стороной на единицу меньше.Заметим, что острота матрицы со стороной n не может превысить . Несложно убедиться, что на квадратное поле со стороной n можно выложить \"доминошек\" 1 на 2 так, чтобы \"доминошки\" не пересекались (иными словами, все клетки, кроме одной, можно разбить на пары так, что клетки в каждой паре имеют общую сторону). Тогда в соответствующей матрице под клетками, покрытыми одной \"доминошкой\", может располагаться не более одной единицы. Значит, общее количество единиц не превышает .Заметим, что матрица со стороной n и остротой при нечётном n существует. Раскрасим все клетки матрицы в шахматном порядке и в чёрные клетки поставим единицы, а в белые — нули. Несложно убедиться, что такая матрица является и чёткой, и симметричной, и при этом имеет остроту ровно .Интуитивно кажется, что раз существует матрица с остротой , то существует матрица и с любой меньшей остротой. Это верно всегда, кроме одного-единственного случая — не существует матрицы со стороной 3 и остротой 3, хотя и существует матрица со стороной 3 и остротой 5.Покажем, что утверждение выше верно при нечётных n ≥ 5. Построим матрицу с остротой , как показано выше, и будем постепенно превращать единицы в нули, уменьшая остроту. Клетки с единицами в матрице бывают трёх типов.Первый тип — центральная клетка. Она ровно одна, при этом можно превратить число в ней в ноль, и матрица не перестанет удовлетворять условию задачи.Второй тип — клетки в центральной строке и в центральном столбце (кроме центральной клетки). Такие клетки из условия симметричности разбиваются на пары — если мы заменяем значение в одной из них на ноль, мы обязаны также заменить на ноль значение в парной ей клетке.Третий тип — все остальные клетки. Из условия симметричности они разбиваются на четвёрки — если мы заменяем значение в некоторой клетке третьего типа на ноль, мы должны заменить на ноль значения во всех клетках той же четвёрки.Теперь для получения требуемой остроты x будем действовать жадно. Будем заменять единицы на нули в клетках третьего типа, делая это в четырёх клетках сразу, до тех пор, пока текущая острота превышает x как минимум на 4 и ещё есть клетки третьего типа с единицами. После этого начнём убирать клетки второго типа по парам, пока текущая острота превышает x хотя бы на 2. К этому моменту острота матрицы равна либо x, либо x + 1. Если она равна x + 1, поставим ноль в центральной клетке и получим матрицу с остротой x. Несложно проверить, что мы сможем получить матрицу любой остроты, действуя по этому жадному алгоритму.Почему такие же рассуждения не работают при n = 3? Потому что в матрице с остротой 5, полученной из шахматной раскраски, отсутствуют клетки второго типа. При n ≥ 5 в такой матрице присутствуют клетки всех типов, что и является залогом успеха. Ответы для x ≤ 5 лучше найти вручную, но аккуратно — например, многие участники решили, что при x = 2 ответ 5, а не 3.Задача В(div 1)/D(div 2) — Угадай автомобиль!Нам нужно найти такие x и y, при которых величина принимает минимальное возможное значение. Эту величину можно преобразовать к виду , и заметить, что поскольку левая часть не зависит от y, а правая от x, то можно минимизировать каждую из частей по отдельности. Рассмотрим, как минимизировать часть , вторая минимизируется аналогично. Поскольку выражение в скобках не зависит от j, эту часть можно переписать в виде , где . Теперь достаточно просто перебрать все возможные значения x, и вычислить для каждого из них искомую величину, после чего выбрать x, для которого это значение минимально. Точно так же находится оптимальное значение y.Итоговая сложность решения — O(n·m + n2 + m2).В силу выпуклости целевой функции возможны и другие подходы к решению задачи, например, градиентый спуск либо аналитический метод (вычисление производных).Главный действующий герой задачи — Ra16bit.Задача С(div 1)/E(div 2) — Хрупкие мостыЭту задачу можно решить несколькими способами, в разборе представлен один из них.Для любого решения полезно заметить следующий факт. Допустим, искомый путь начинается на платформе i и заканчивается на платформе j (i ≤ j, если это не так, можно поменять начало и конец пути местами). Тогда все мосты, находящиеся между платформами i и j, будут пройдены в этом пути нечётное число раз, а все остальные мосты — чётное число раз.Давайте найдём максимальную длину пути с концами на платформах i и j. Для этого для всех платформ найдём вспомогательные величины: lefti — максимальная длина пути, начинающегося и заканчивающегося на платформе i и при этом проходящего только по мостам левее платформы i; rightj — аналогично для мостов правее платформы j. Также для каждого моста определим oddi — наибольшее нечётное число, не превосходящее ai, и для каждой платформы определим sumOddi — сумму oddj по всем мостам левее платформы i.Тогда максимальная длина пути с концами на платформах i и j (i ≤ j) равна lefti + rightj + (sumOddj - sumOddi) или, что то же самое, (rightj + sumOddj) + (lefti - sumOddi).Теперь мы можем найти пару (i, j), для которых эта величина наибольшая, за линейное время. Переберём j. Из формулы очевидно, что нужно найти такое i ≤ j, что (lefti - sumOddi) максимально. Если перебирать j от 1 к n, то можно хранить текущее максимальное значение этой величины для всех i ≤ j и пересчитывать его при переходе к следующему j, сравнив (leftj - sumOddj) с текущим максимумом и, возможно, этот максимум обновив. Таким образом, для каждого j нужно проверять не все значения i ≤ j, а только одно.Осталось показать, как быстро искать все lefti (все rightj ищутся аналогично). Понятно, что left1 = 0, далее будем считать lefti, используя lefti - 1. Заметим, что если ai - 1 = 1, то lefti = 0, так как после перехода по мосту на платформу (i - 1) этот мост рухнет и вернуться на платформу i уже будет невозможно. Если же ai - 1 > 1, то lefti = lefti - 1 + eveni - 1, где eveni - 1 — наибольшее чётное число, не превосходящее ai - 1. Действительно, можно перейти по мосту на платформу (i - 1), проделать путь, соответствующий lefti - 1, а потом ходить по мосту между платформами (i - 1) и i, пока лимит на количество переходов не станет меньше 2 (при этом закончить нужно на платформе i).Таким образом, общая сложность этого решения — O(n).Задача D(div 1) — Инновационно новая задачаПервое решение, которое приходит на ум — рекуррентное соотношение f[i][j] =  (минимальное возможное количество инверсий, если среди первых j слов встречается перестановка слов, входящих в маску i). В таком решении параметр j изменяется от 0 до 500000, i — от 0 до 215 - 1, а пересчёт значений происходит за O(1) (либо используем очередное слово, либо нет). Это слишком много.Воспользуемся стандартным приёмом: перенесём значение соотношения в параметр, а один из параметров сделаем значением. Это можно сделать не для любого рекуррентного, но для этого как раз можно :)Понятно, что при фиксированном подмножестве слов и количестве инверсий оптимально выбрать самые ранние вхождения этих слов, которые дают такое количество инверсий. Пусть f[i][j] =  (минимальное число z такое, что среди первых z слов найдётся перестановка слов из маски i, содержащая в точности j инверсий). База — f[0][0] = 0, f[0][j] = ∞ для j > 0. Пересчёт значений происходит следующим образом: перебираем слово q из маски i, которое было последним. Зная это слово, и количество инверсий j, легко вычислить количество инверсий j', которое было без этого слова — это j минус количество слов в маске, больших q (по номеру в описании Лёшиной задачи). Пусть p = f[i^(1«q)][j']. Тогда в качестве очередного возможного значения для f[i][j] нужно рассмотреть индекс p2, равный позиции следующего вхождения слова q после позиции p. Для быстрого поиска таких значений необходимо заранее для каждой задачи из архива посчитать массив next[500010][15] такой, что next[i][j] = (минимальный индекс k > i такой, что k-е слово в описании текущей задачи равно j-му слову в описании задачи Лёши). Такой массив несложно посчитать за один проход справа налево.Суммарное количество операций можно вычислить по формуле m·(k·n + 2n·Cn2·n), где m — количество задач в архиве, k — количество слов в описании одной задачи, n — количество слов в описании задачи Лёши. При заданных ограничениях эта величина составляла около 200 миллионов, и авторские решения (включая решение на Java) работали не более двух секунд. TL был выставлен довольно-таки лояльно, 5 секунд.Главные действующие герои задач D(div 1) и B(div 2) — Chmel_Tolstiy и ivan.metelsky.Задача E(div 1) — Насквозь бюрократическая организацияДавайте представим, что у нас в распоряжении есть функция maxN(m, k), которая по заданным m и k возвращает максимальное значение n такое, что задачу для n людей и m пустых строчек в бланке можно решить за k запросов. Тогда можно применить бинарный поиск по ответу — количеству запросов k.Допустим, мы сделали какие-то k запросов. Сопоставим каждому из n человек строку из k бит, где i-ый бит равен единице, если этот человек был указан в i-ом запросе, и равен нулю в противном случае. Заметим, что мы сможем определить точную дату приёма для каждого человека в том и только в том случае, если всем n людям соответствуют попарно различные k-битовые строки. На самом деле, если двум людям соответствуют одинаковые строки, то они могли бы поменяться датами между собой и ответы на запросы не изменились бы. Если же всем людям соответствуют разные строки, для каждой даты можно определить, кто именно записан на эту дату, рассмотрев множество запросов, в ответах на которые эта дата фигурирует, и найдя человека, который указан ровно в том же множестве запросов.Ограничение в m пустых строчек в бланке означает, что в каждой из k позиций в строках суммарное число единиц по всем n числам не должно превышать m. Таким образом, функция maxN(m, k) должна возвращать максимальную мощность множества различных k-битовых строк, для которых выполняется это ограничение. Давайте ослабим это ограничение: будем искать множество, в котором в сумме по всем разрядам количество единиц не превышает k·m. Как мы докажем после, ответ от этого не изменится.С таким ослабленным ограничением задача решается простым жадным алгоритмом. Логично, что сначала лучше брать те строки, в которых меньше единиц. Будем перебирать количество единиц i в строке от 0 до k, а также хранить переменную t, обозначающую количество единиц, которое ещё можно поставить (изначально она равна k·m). Тогда на i-ом шаге максимально можно взять чисел с i единицами. Добавим p к ответу, а от t отнимем p·i. Отметим, что значения Cki нужно считать аккуратно — они могут оказаться слишком большими, и нужно не допустить переполнения.Можно показать, что сложность такого решения на один тест составляет не более O(log2n).Осталось доказать необходимое утверждение. Идея доказательства ниже принадлежит rng_58 (авторское было заметно сложнее).Решим задачу жадным алгоритмом с ограничением в k·m на общее число единиц. Полученное множество может не удовлетворять ограничению в m единиц на каждый разряд — тогда в некоторых разрядах количество единиц больше m, а в некоторых меньше m. Возьмём некоторый разряд X, в котором более m единиц, и некоторый разряд Y, в котором менее m единиц. Найдём строки, в которых стоит 1 в X и 0 в Y (допустим, таких строк x) и строки, в которых стоит 0 в X и 1 в Y (допустим, таких строк y). Понятно, что x > y. В каждой из x строк мы можем попробовать поставить 0 в X и 1 в Y — тогда полученная строка может либо остаться уникальной, либо совпасть с какой-то из y строк (но ровно одной). А поскольку x > y, точно найдётся одна из x строк такая, что в ней можно поменять местами цифры в разрядах X и Y и все строки останутся различными. Сделаем это. Теперь в разряде X стало на одну единицу меньше, а в разряде Y — на одну единицу больше. Это значит, что суммарное число лишних единиц в разрядах уменьшилось (т.к. в Y единиц не стало больше m). Таким образом, повторяя эту операцию необходимое число раз, мы сможем добиться того, чтобы в каждом разряде было не более m единиц.",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/4808",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 15108
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #127 - Codeforces - Code 1",
          "code": ">популярная\n>-37",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4796",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #127 - Codeforces - Code 2",
          "code": ">популярная\n>-37",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4796",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #127 - Codeforces - Code 3",
          "code": "1 0 0\n0 1 0\n1 0 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4796",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #127 - Codeforces - Code 4",
          "code": "1 0 0\n0 1 0\n1 0 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4796",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #127 - Codeforces - Code 5",
          "code": "10001\n00000\n10001\n00000\n10001",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4796",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #127 - Codeforces - Code 6",
          "code": "10001\n00000\n10001\n00000\n10001",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4796",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #127 - Codeforces - Code 7",
          "code": "0 0 1 0 0\n0 0 0 0 0\n0 0 1 0 0\n0 0 0 0 0\n0 0 1 0 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4796",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #127 - Codeforces - Code 8",
          "code": "0 0 1 0 0\n0 0 0 0 0\n0 0 1 0 0\n0 0 0 0 0\n0 0 1 0 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4796",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #127 - Codeforces - Code 9",
          "code": "0 1 0\n0 0 0\n0 1 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4796",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #127 - Codeforces - Code 10",
          "code": "0 1 0\n0 0 0\n0 1 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4796",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #127 - Codeforces - Code 11",
          "code": "0 1 0\n0 0 0\n0 1 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4796",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #127 - Codeforces - Code 12",
          "code": "0 1 0\n0 0 0\n0 1 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4796",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #127 - Codeforces - Code 13",
          "code": "int n;\ncin >> n;\nif (n == 3)\n{\n  cout << 5;\n  return 0;\n}\nfor (int i = 1;; i += 2)\n  if ((i*i+1)/2>=n)\n  {\n    cout << i;\n    return 0;\n  }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4796",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #127 - Codeforces - Code 14",
          "code": "int n;\ncin >> n;\nif (n == 3)\n{\n  cout << 5;\n  return 0;\n}\nfor (int i = 1;; i += 2)\n  if ((i*i+1)/2>=n)\n  {\n    cout << i;\n    return 0;\n  }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4796",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #127 — разбор - Codeforces - Code 1",
          "code": "w - массив слов задачи Лёши\ns - описание очередной задачи из архива\nbest = 100\nfor a = 1 to k do\n    for b = 1 to k do\n        for c = 1 to k do\n            for d = 1 to k do\n                if s[a] == w[1] and s[b] == w[2] and s[c] == w[3] and s[d] == w[4] then\n                    inversions = 0\n                    if a > b then inversions = inversions + 1\n                    if a > c then inversions = inversions + 1\n                    if a > d then inversions = inversions + 1\n                    if b > c then inversions = inversions + 1\n                    if b > d then inversions = inversions + 1\n                    if c > d then inversions = inversions + 1\n                    if inversions < best then\n                        best = inversions",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4808",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #127 — разбор - Codeforces - Code 2",
          "code": "w - массив слов задачи Лёши\ns - описание очередной задачи из архива\nbest = 100\nfor a = 1 to k do\n    for b = 1 to k do\n        for c = 1 to k do\n            for d = 1 to k do\n                if s[a] == w[1] and s[b] == w[2] and s[c] == w[3] and s[d] == w[4] then\n                    inversions = 0\n                    if a > b then inversions = inversions + 1\n                    if a > c then inversions = inversions + 1\n                    if a > d then inversions = inversions + 1\n                    if b > c then inversions = inversions + 1\n                    if b > d then inversions = inversions + 1\n                    if c > d then inversions = inversions + 1\n                    if inversions < best then\n                        best = inversions",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4808",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #127 — разбор - Codeforces - Code 3",
          "code": "10 b c a b a d d d a a",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4808",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #127 — разбор - Codeforces - Code 4",
          "code": "REP(mask,(1<<15)) REP(i,15) for(j=i;j<15;j++) if(mask&(1<<j)) cost[mask][i]++;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4808",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #127 — разбор - Codeforces - Code 5",
          "code": "long sortAndCountInv(int []a, int l, int r) {\n   if (r - l <= 1) return 0;\n   int m = (l + r)  / 2;\n   long L = sortAndCountInv(a, l, m);\n   long R = sortAndCountInv(a, m + 1, r);\n   long M = 0; \n   int []t = a.clone();\n   int at = 0;\n   for (int i = 0, j = m + 1; i <= m && j <=r; ) {\n       if (t[i] > t[j])  { // если этот элемент больше элемента справа, то значит ( так как левая часть уже отсортирована) и все остальные элементы слева больше, значит, к числу инверсий добавим (m - i) \n        M += m -i; \n        a[at++] = t[j++];\n      } \n      else  a[at++] = t[i++];             \n   }\n   while (i <= m) a[at++] = t[i++];\n   while(j <= r) a[at++]=t[j++];\n   return L + M + R;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4808",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #127 — разбор - Codeforces - Code 6",
          "code": "long sortAndCountInv(int []a, int l, int r) {\n   if (r - l <= 1) return 0;\n   int m = (l + r)  / 2;\n   long L = sortAndCountInv(a, l, m);\n   long R = sortAndCountInv(a, m + 1, r);\n   long M = 0; \n   int []t = a.clone();\n   int at = 0;\n   for (int i = 0, j = m + 1; i <= m && j <=r; ) {\n       if (t[i] > t[j])  { // если этот элемент больше элемента справа, то значит ( так как левая часть уже отсортирована) и все остальные элементы слева больше, значит, к числу инверсий добавим (m - i) \n        M += m -i; \n        a[at++] = t[j++];\n      } \n      else  a[at++] = t[i++];             \n   }\n   while (i <= m) a[at++] = t[i++];\n   while(j <= r) a[at++]=t[j++];\n   return L + M + R;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4808",
          "author": "Qingyu"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(2, 100000, \"n\");\n    inf.readEoln();\n    vector<int> a = inf.readInts(n - 1, 1, 1000000000, \"ai\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(2, 100000, \"n\");\n    inf.readEoln();\n    vector<int> a = inf.readInts(n - 1, 1, 1000000000, \"ai\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(2, 100000, \"n\");\n    inf.readEoln();\n    vector<int> a = inf.readInts(n - 1, 1, 1000000000, \"ai\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> a(n - 1);\n\n    if (type == \"min_ai\") {\n        // All ai = 1\n        for (int i = 0; i < n - 1; ++i)\n            a[i] = 1;\n    } else if (type == \"max_ai\") {\n        // All ai = 1e9\n        for (int i = 0; i < n - 1; ++i)\n            a[i] = 1000000000; // 1e9\n    } else if (type == \"random\") {\n        // Random ai in [1, 1e9]\n        for (int i = 0; i < n - 1; ++i)\n            a[i] = rnd.next(1, 1000000000);\n    } else if (type == \"small_random\") {\n        // Random ai in [1, 10]\n        for (int i = 0; i < n - 1; ++i)\n            a[i] = rnd.next(1, 10);\n    } else if (type == \"increasing\") {\n        // ai increases from 1 to 1e9\n        for (int i = 0; i < n - 1; ++i)\n            a[i] = 1 + (int)((long long)i * (1000000000 - 1) / max(1, n - 2));\n    } else if (type == \"decreasing\") {\n        // ai decreases from 1e9 to 1\n        for (int i = 0; i < n - 1; ++i)\n            a[i] = 1 + (int)((long long)(n - 2 - i) * (1000000000 - 1) / max(1, n - 2));\n    } else if (type == \"alternating\") {\n        // ai alternates between 1e9 and 1\n        for (int i = 0; i < n - 1; ++i)\n            a[i] = (i % 2 == 0) ? 1000000000 : 1;\n    } else if (type == \"big_small\") {\n        // ai alternates between 1e9 and small_value\n        int small_value = opt<int>(\"small_value\", 1);\n        for (int i = 0; i < n - 1; ++i)\n            a[i] = (i % 2 == 0) ? 1000000000 : small_value;\n    } else if (type == \"random1e9\") {\n        // Random values close to 1e9\n        for (int i = 0; i < n - 1; ++i)\n            a[i] = rnd.next(1000000000 - 1000, 1000000000);\n    } else if (type == \"random1\") {\n        // Random values close to 1\n        for (int i = 0; i < n - 1; ++i)\n            a[i] = rnd.next(1, 1000);\n    } else {\n        // Default random\n        for (int i = 0; i < n - 1; ++i)\n            a[i] = rnd.next(1, 1000000000);\n    }\n\n    // Output n\n    printf(\"%d\\n\", n);\n    // Output ai\n    for (int i = 0; i < n - 1; ++i) {\n        printf(\"%d\", a[i]);\n        if (i != n - 2)\n            printf(\" \");\n    }\n    printf(\"\\n\");\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> a(n - 1);\n\n    if (type == \"min_ai\") {\n        // All ai = 1\n        for (int i = 0; i < n - 1; ++i)\n            a[i] = 1;\n    } else if (type == \"max_ai\") {\n        // All ai = 1e9\n        for (int i = 0; i < n - 1; ++i)\n            a[i] = 1000000000; // 1e9\n    } else if (type == \"random\") {\n        // Random ai in [1, 1e9]\n        for (int i = 0; i < n - 1; ++i)\n            a[i] = rnd.next(1, 1000000000);\n    } else if (type == \"small_random\") {\n        // Random ai in [1, 10]\n        for (int i = 0; i < n - 1; ++i)\n            a[i] = rnd.next(1, 10);\n    } else if (type == \"increasing\") {\n        // ai increases from 1 to 1e9\n        for (int i = 0; i < n - 1; ++i)\n            a[i] = 1 + (int)((long long)i * (1000000000 - 1) / max(1, n - 2));\n    } else if (type == \"decreasing\") {\n        // ai decreases from 1e9 to 1\n        for (int i = 0; i < n - 1; ++i)\n            a[i] = 1 + (int)((long long)(n - 2 - i) * (1000000000 - 1) / max(1, n - 2));\n    } else if (type == \"alternating\") {\n        // ai alternates between 1e9 and 1\n        for (int i = 0; i < n - 1; ++i)\n            a[i] = (i % 2 == 0) ? 1000000000 : 1;\n    } else if (type == \"big_small\") {\n        // ai alternates between 1e9 and small_value\n        int small_value = opt<int>(\"small_value\", 1);\n        for (int i = 0; i < n - 1; ++i)\n            a[i] = (i % 2 == 0) ? 1000000000 : small_value;\n    } else if (type == \"random1e9\") {\n        // Random values close to 1e9\n        for (int i = 0; i < n - 1; ++i)\n            a[i] = rnd.next(1000000000 - 1000, 1000000000);\n    } else if (type == \"random1\") {\n        // Random values close to 1\n        for (int i = 0; i < n - 1; ++i)\n            a[i] = rnd.next(1, 1000);\n    } else {\n        // Default random\n        for (int i = 0; i < n - 1; ++i)\n            a[i] = rnd.next(1, 1000000000);\n    }\n\n    // Output n\n    printf(\"%d\\n\", n);\n    // Output ai\n    for (int i = 0; i < n - 1; ++i) {\n        printf(\"%d\", a[i]);\n        if (i != n - 2)\n            printf(\" \");\n    }\n    printf(\"\\n\");\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 2 -type min_ai\n./gen -n 2 -type max_ai\n./gen -n 2 -type random\n./gen -n 2 -type small_random\n./gen -n 2 -type increasing\n./gen -n 2 -type decreasing\n./gen -n 2 -type alternating\n\n./gen -n 3 -type min_ai\n./gen -n 3 -type max_ai\n./gen -n 3 -type increasing\n\n./gen -n 10 -type min_ai\n./gen -n 10 -type max_ai\n./gen -n 10 -type random\n./gen -n 10 -type small_random\n./gen -n 10 -type increasing\n./gen -n 10 -type decreasing\n./gen -n 10 -type alternating\n\n./gen -n 1000 -type min_ai\n./gen -n 1000 -type max_ai\n./gen -n 1000 -type random\n./gen -n 1000 -type small_random\n./gen -n 1000 -type increasing\n./gen -n 1000 -type decreasing\n./gen -n 1000 -type alternating\n\n./gen -n 100000 -type min_ai\n./gen -n 100000 -type max_ai\n./gen -n 100000 -type random\n./gen -n 100000 -type small_random\n./gen -n 100000 -type increasing\n./gen -n 100000 -type decreasing\n./gen -n 100000 -type alternating\n\n./gen -n 100000 -type big_small -small_value 1\n./gen -n 100000 -type big_small -small_value 10\n./gen -n 100000 -type big_small -small_value 100000\n\n./gen -n 100000 -type random1e9\n./gen -n 100000 -type random1\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T19:48:21.284301",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "203/A",
      "title": "A. Две задачи",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест2 секунды",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеВ единственной строке входных данных заданы шесть целых чисел x, t, a, b, da, db (0 ≤ x ≤ 600; 1 ≤ t, a, b, da, db ≤ 300) — результат Валеры, длительность соревнования, начальная стоимость первой задачи, начальная стоимость второй задачи, количество баллов, на которое уменьшается стоимость первой задачи и второй задачи за одну минуту, соответственно. Гарантируется, что в каждую минуту соревнования каждая задача имеет неотрицательную стоимость, то есть a - i·da ≥ 0 и b - i·db ≥ 0 для всех 0 ≤ i ≤ t - 1.",
      "output_spec": "Выходные данныеЕсли Валера мог набрать за соревнование ровно x баллов выведите «YES», в противном случае выведите «NO» (без кавычек).",
      "sample_tests": "ПримерыВходные данныеСкопировать30 5 20 20 3 5Выходные данныеСкопироватьYESВходные данныеСкопировать10 4 100 5 5 1Выходные данныеСкопироватьNO",
      "description": "A. Две задачи\n\nограничение по времени на тест2 секунды\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвыводstdout\n\nВходные данныеВ единственной строке входных данных заданы шесть целых чисел x, t, a, b, da, db (0 ≤ x ≤ 600; 1 ≤ t, a, b, da, db ≤ 300) — результат Валеры, длительность соревнования, начальная стоимость первой задачи, начальная стоимость второй задачи, количество баллов, на которое уменьшается стоимость первой задачи и второй задачи за одну минуту, соответственно. Гарантируется, что в каждую минуту соревнования каждая задача имеет неотрицательную стоимость, то есть a - i·da ≥ 0 и b - i·db ≥ 0 для всех 0 ≤ i ≤ t - 1.\n\nВходные данные\n\nВыходные данныеЕсли Валера мог набрать за соревнование ровно x баллов выведите «YES», в противном случае выведите «NO» (без кавычек).\n\nВыходные данные\n\nВходные данныеСкопировать30 5 20 20 3 5Выходные данныеСкопироватьYESВходные данныеСкопировать10 4 100 5 5 1Выходные данныеСкопироватьNO\n\nВходные данныеСкопировать30 5 20 20 3 5\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопироватьYES\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать10 4 100 5 5 1\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопироватьNO\n\nВыходные данныеСкопировать\n\nСкопировать\n\nПримечаниеВ первом примере Валера мог поступить следующим способом: первую задачу сдать на минуте под номером 0, вторую задачу сдать на минуте под номером 2. Тогда за первую задачу оп получит 20 баллов, за вторую 10 баллов, что в сумме дает требуемые 30 баллов.",
      "solutions": [
        {
          "title": "Codeforces Round #128 (Div. 2) - Codeforces",
          "content": "Друзья, привет!Через несколько часов Вам посчастливится участвовать в знаменательном раунде Codeforces Round #27 для участников Div. 21, но традиционно остальные могут поучаствовать вне конкурса. Он был подготовлен небольшой командой авторов: я (NALP), Игорь Кудряшов (Igor_Kudryashov), Павел Холкин (HolkinPV). Как всегда с нами были Геральд Агапов (Gerald), Мария Белова (Delinur) и Михаил Мирзаянов (MikeMirzayanov).Как вы все прекрасно знаете, только сегодня вы сможете поучаствовать в этом раунде в конкурсе, не упустите такую возможность! Другого раунда Codeforces Round #27 вы не увидите нигде! :)Традиционно всем удачи, полных решений и удачных взломов!UPD: Распределение баллов по задачам стандартное: 500, 1000, 1500, 2000, 2500.UPD: Соревнование закончено, всем спасибо за участие. Надеюсь вам понравилось, но не забывайте, что нас еще ждет системное тестирование.UPD: Уже опубликована предварительная версия разбора на русском языке",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/4818",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 944
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #128 (Div. 2) - Codeforces - Code 1",
          "code": "cout<<1<<endl;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4818",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #128 (Div. 2) - Codeforces - Code 2",
          "code": "-FAIL Expected EOF (stdin)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4818",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #128 (Div. 2) - Codeforces - Code 3",
          "code": "3 1000000000  \n10000 10000  \n100000 0  \n100000 100000  \n0 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4818",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #128 (Div. 2) - Codeforces - Code 4",
          "code": "3 1000000000  \n10000 10000  \n100000 0  \n100000 100000  \n0 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4818",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #128 (Div. 2) - Codeforces - Code 5",
          "code": "по-моему там все парные числа от 1..max.На паскале ето можно легко исправить рандомизацией. \n    procedure sort(l,r: longint);\n      var\n         i,j,x,y: longint;\n      begin\n         i:=l;\n         j:=r;\n         x:=a[l+random(r-l)];\n         repeat\n           while a[i]<x do\n            inc(i);\n           while x<a[j] do\n            dec(j);\n           if not(i>j) then\n             begin\n                y:=a[i];\n                a[i]:=a[j];\n                a[j]:=y;\n                inc(i);\n                j:=j-1;\n             end;\n         until i>j;\n         if l<j then\n           sort(l,j);\n         if i<r then\n           sort(i,r);\n      end;\nl+random(r-l) вместо (l+r) div 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4818",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #128 (Div. 2) - Codeforces - Code 6",
          "code": "по-моему там все парные числа от 1..max.На паскале ето можно легко исправить рандомизацией. \n    procedure sort(l,r: longint);\n      var\n         i,j,x,y: longint;\n      begin\n         i:=l;\n         j:=r;\n         x:=a[l+random(r-l)];\n         repeat\n           while a[i]<x do\n            inc(i);\n           while x<a[j] do\n            dec(j);\n           if not(i>j) then\n             begin\n                y:=a[i];\n                a[i]:=a[j];\n                a[j]:=y;\n                inc(i);\n                j:=j-1;\n             end;\n         until i>j;\n         if l<j then\n           sort(l,j);\n         if i<r then\n           sort(i,r);\n      end;\nl+random(r-l) вместо (l+r) div 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4818",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #128 (Div. 2) - Codeforces - Code 7",
          "code": "// System.Array\n[ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)]\nprivate static int GetMedian(int low, int hi)\n{\n\treturn low + (hi - low >> 1);\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4818",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #128 (Div. 2) - Codeforces - Code 8",
          "code": "// System.Array\n[ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)]\nprivate static int GetMedian(int low, int hi)\n{\n\treturn low + (hi - low >> 1);\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4818",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #128 (Div. 2) - Codeforces - Code 9",
          "code": "class Program\n{\n\tstatic void Main()\n\t{\n\t\tint[] array = GetBadArray();\n\t\tSystem.Array.Sort( array );\n\t}\n\tstatic int[] GetBadArray()\n\t{\n\t\t...\n\t}\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4818",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #128 (Div. 2) - Codeforces - Code 10",
          "code": "class Program\n{\n\tstatic void Main()\n\t{\n\t\tint[] array = GetBadArray();\n\t\tSystem.Array.Sort( array );\n\t}\n\tstatic int[] GetBadArray()\n\t{\n\t\t...\n\t}\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4818",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #128 (Div. 2) - Codeforces - Code 11",
          "code": "100000\n1918,8083\n15,6001",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4818",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #128 (Div. 2) - Codeforces - Code 12",
          "code": "100000\n1918,8083\n15,6001",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4818",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #128 (Div. 2) - Codeforces - Code 13",
          "code": "100000\n33,0019\n24,0014",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4818",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #128 (Div. 2) - Codeforces - Code 14",
          "code": "100000\n33,0019\n24,0014",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4818",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #128 (Div. 2) - Codeforces - Code 15",
          "code": "100000\n3683,358\n17,577",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4818",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #128 (Div. 2) - Codeforces - Code 16",
          "code": "100000\n3683,358\n17,577",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4818",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #128 (Div. 2) - Codeforces - Code 17",
          "code": "100000\n2246,4039\n15,6",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4818",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #128 (Div. 2) - Codeforces - Code 18",
          "code": "100000\n2246,4039\n15,6",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4818",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #128 (Div. 2) - Codeforces - Code 19",
          "code": "100000\n1937,562\n15,6255",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4818",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #128 (Div. 2) - Codeforces - Code 20",
          "code": "100000\n1937,562\n15,6255",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4818",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #128 (Div. 2) - Codeforces - Code 21",
          "code": "return a > b ? b : a;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4818",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #128 (Div. 2) - Codeforces - Code 22",
          "code": "for(int i = chmax(1, x - 2); i <= x; i++)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4818",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int x = inf.readInt(0, 600, \"x\");\n    inf.readSpace();\n    int t = inf.readInt(1, 300, \"t\");\n    inf.readSpace();\n    int a = inf.readInt(1, 300, \"a\");\n    inf.readSpace();\n    int b = inf.readInt(1, 300, \"b\");\n    inf.readSpace();\n    int da = inf.readInt(1, 300, \"da\");\n    inf.readSpace();\n    int db = inf.readInt(1, 300, \"db\");\n    inf.readEoln();\n\n    for (int i = 0; i <= t - 1; ++i) {\n        ensuref(a - i * da >= 0, \"At minute %d, cost of problem 1 is negative\", i);\n        ensuref(b - i * db >= 0, \"At minute %d, cost of problem 2 is negative\", i);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int x = inf.readInt(0, 600, \"x\");\n    inf.readSpace();\n    int t = inf.readInt(1, 300, \"t\");\n    inf.readSpace();\n    int a = inf.readInt(1, 300, \"a\");\n    inf.readSpace();\n    int b = inf.readInt(1, 300, \"b\");\n    inf.readSpace();\n    int da = inf.readInt(1, 300, \"da\");\n    inf.readSpace();\n    int db = inf.readInt(1, 300, \"db\");\n    inf.readEoln();\n\n    for (int i = 0; i <= t - 1; ++i) {\n        ensuref(a - i * da >= 0, \"At minute %d, cost of problem 1 is negative\", i);\n        ensuref(b - i * db >= 0, \"At minute %d, cost of problem 2 is negative\", i);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int x = inf.readInt(0, 600, \"x\");\n    inf.readSpace();\n    int t = inf.readInt(1, 300, \"t\");\n    inf.readSpace();\n    int a = inf.readInt(1, 300, \"a\");\n    inf.readSpace();\n    int b = inf.readInt(1, 300, \"b\");\n    inf.readSpace();\n    int da = inf.readInt(1, 300, \"da\");\n    inf.readSpace();\n    int db = inf.readInt(1, 300, \"db\");\n    inf.readEoln();\n\n    for (int i = 0; i <= t - 1; ++i) {\n        ensuref(a - i * da >= 0, \"At minute %d, cost of problem 1 is negative\", i);\n        ensuref(b - i * db >= 0, \"At minute %d, cost of problem 2 is negative\", i);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n#include <string>\r\n\r\nusing namespace std;\r\n\r\nconst string YES = \"YES\";\r\nconst string NO = \"NO\";\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"%s\", (\"multiple \" + YES + \"/\" + NO + \" (case insensitive)\").c_str());\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int index = 0, yesCount = 0, noCount = 0;\r\n    string pa;\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        index++;\r\n        string ja = upperCase(ans.readToken());\r\n        pa = upperCase(ouf.readToken());\r\n\r\n        if (ja != YES && ja != NO)\r\n            quitf(_fail, \"%s or %s expected in answer, but %s found [%d%s token]\",\r\n                  YES.c_str(), NO.c_str(), compress(ja).c_str(), index, englishEnding(index).c_str());\r\n\r\n        if (pa == YES)\r\n            yesCount++;\r\n        else if (pa == NO)\r\n            noCount++;\r\n        else\r\n            quitf(_pe, \"%s or %s expected, but %s found [%d%s token]\",\r\n                  YES.c_str(), NO.c_str(), compress(pa).c_str(), index, englishEnding(index).c_str());\r\n\r\n        if (ja != pa)\r\n            quitf(_wa, \"expected %s, found %s [%d%s token]\",\r\n                  compress(ja).c_str(), compress(pa).c_str(), index, englishEnding(index).c_str());\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n    while (!ans.seekEof()) {\r\n        ans.readToken();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n    while (!ouf.seekEof()) {\r\n        ouf.readToken();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              index + extraInAnsCount, index);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              index + extraInOufCount, index);\r\n\r\n    if (index == 0)\r\n        quitf(_ok, \"Empty output\");\r\n    else if (index == 1)\r\n        quitf(_ok, \"%s\", pa.c_str());\r\n    else\r\n        quitf(_ok, \"%d token(s): yes count is %d, no count is %d\", index, yesCount, noCount);\r\n\r\n    quitf(_fail, \"Impossible case\");\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    // Read parameters\n    int t = opt<int>(\"t\", 300);\n    string type = opt<string>(\"type\", \"random_possible\");\n\n    int a, b, da, db, x;\n    // x ∈ [0,600], t ∈ [1,300], a,b,da,db ∈ [1,300]\n\n    if (type == \"random_possible\") {\n        // Generate random possible test case where answer is \"YES\"\n\n        // Generate random a,b ∈ [1, 300]\n\n        a = rnd.next(1,300);\n        b = rnd.next(1,300);\n\n        // For t ≥2, da ∈ [1, floor(a / (t-1))], or 1 if denominator is zero\n\n        if ((t-1) > 0) {\n            da = rnd.next(1, max(1, a / (t-1)));\n        } else {\n            da = rnd.next(1, 300);\n        }\n\n        if ((t-1) > 0) {\n            db = rnd.next(1, max(1, b / (t-1)));\n        } else {\n            db = rnd.next(1, 300);\n        }\n\n        // Now generate x such that it's possible to obtain x\n\n        // Randomly select submission times iA and iB\n        int iA = rnd.next(-1, t-1); // -1 indicates not submitting problem A\n        int iB = rnd.next(-1, t-1);\n\n        int valA = 0;\n        if (iA != -1)\n            valA = a - iA * da;\n        int valB = 0;\n        if (iB != -1)\n            valB = b - iB * db;\n\n        x = valA + valB;\n\n        // Ensure x is within [0,600]\n        x = max(0, min(x, 600));\n\n    } else if (type == \"random_impossible\") {\n        // Generate test case where answer is \"NO\"\n\n        // Generate small random a,b to limit possible x values\n        a = rnd.next(1, 10);\n        b = rnd.next(1, 10);\n        t = rnd.next(1, 10);\n\n        if ((t-1) > 0) {\n            da = rnd.next(1, max(1, a / (t-1)));\n        } else {\n            da = rnd.next(1, 10);\n        }\n        if ((t-1) > 0) {\n            db = rnd.next(1, max(1, b / (t-1)));\n        } else {\n            db = rnd.next(1, 10);\n        }\n\n        // Compute all possible x values\n        set<int> possible_x;\n        for (int iA = -1; iA < t; ++iA) {\n            int valA = 0;\n            if (iA != -1)\n                valA = a - iA * da;\n            if (valA < 0) continue;\n            for (int iB = -1; iB < t; ++iB) {\n                int valB = 0;\n                if (iB != -1)\n                    valB = b - iB * db;\n                if (valB < 0) continue;\n                int total = valA + valB;\n                if (total >= 0 && total <= 600)\n                    possible_x.insert(total);\n            }\n        }\n\n        // Now pick an x in [0,600] not in possible_x\n        vector<int> impossible_x;\n        for (int i = 0; i <= 600; ++i) {\n            if (possible_x.find(i) == possible_x.end())\n                impossible_x.push_back(i);\n        }\n\n        if (impossible_x.empty()) {\n            // All x in [0,600] are possible, adjust parameters\n            x = 601; // x must be within [0,600], so we need to adjust\n            x = 0; // Edge case\n            a = 1; b = 1; da = 1; db = 1; t = 1;\n        } else {\n            x = impossible_x[rnd.next(0, (int)impossible_x.size() -1)];\n        }\n\n    } else if (type == \"max_input\") {\n        // Generate test case with maximal input values\n        t = 300;\n        a = 300;\n        b = 300;\n        x = 600;\n        da = 1;\n        db = 1;\n\n    } else if (type == \"edge_case\") {\n        // Generate specific edge cases\n        t = rnd.next(1, 2);\n        a = 1;\n        b = 1;\n        da = 1;\n        db = 1;\n        x = 0; // Edge case where it's possible to get zero points\n    } else {\n        // Default random test case\n        a = rnd.next(1,300);\n        b = rnd.next(1,300);\n        if ((t-1) > 0) {\n            da = rnd.next(1, max(1, a / (t-1)));\n            db = rnd.next(1, max(1, b / (t-1)));\n        } else {\n            da = rnd.next(1,300);\n            db = rnd.next(1,300);\n        }\n        x = rnd.next(0,600);\n    }\n\n    // Ensure that a - (t - 1) * da ≥ 0 and b - (t - 1) * db ≥ 0\n    if (a - (t - 1) * da < 0) {\n        a = (t - 1) * da;\n    }\n    if (b - (t - 1) * db < 0) {\n        b = (t - 1) * db;\n    }\n\n    // Output x t a b da db\n    printf(\"%d %d %d %d %d %d\\n\", x, t, a, b, da, db);\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    // Read parameters\n    int t = opt<int>(\"t\", 300);\n    string type = opt<string>(\"type\", \"random_possible\");\n\n    int a, b, da, db, x;\n    // x ∈ [0,600], t ∈ [1,300], a,b,da,db ∈ [1,300]\n\n    if (type == \"random_possible\") {\n        // Generate random possible test case where answer is \"YES\"\n\n        // Generate random a,b ∈ [1, 300]\n\n        a = rnd.next(1,300);\n        b = rnd.next(1,300);\n\n        // For t ≥2, da ∈ [1, floor(a / (t-1))], or 1 if denominator is zero\n\n        if ((t-1) > 0) {\n            da = rnd.next(1, max(1, a / (t-1)));\n        } else {\n            da = rnd.next(1, 300);\n        }\n\n        if ((t-1) > 0) {\n            db = rnd.next(1, max(1, b / (t-1)));\n        } else {\n            db = rnd.next(1, 300);\n        }\n\n        // Now generate x such that it's possible to obtain x\n\n        // Randomly select submission times iA and iB\n        int iA = rnd.next(-1, t-1); // -1 indicates not submitting problem A\n        int iB = rnd.next(-1, t-1);\n\n        int valA = 0;\n        if (iA != -1)\n            valA = a - iA * da;\n        int valB = 0;\n        if (iB != -1)\n            valB = b - iB * db;\n\n        x = valA + valB;\n\n        // Ensure x is within [0,600]\n        x = max(0, min(x, 600));\n\n    } else if (type == \"random_impossible\") {\n        // Generate test case where answer is \"NO\"\n\n        // Generate small random a,b to limit possible x values\n        a = rnd.next(1, 10);\n        b = rnd.next(1, 10);\n        t = rnd.next(1, 10);\n\n        if ((t-1) > 0) {\n            da = rnd.next(1, max(1, a / (t-1)));\n        } else {\n            da = rnd.next(1, 10);\n        }\n        if ((t-1) > 0) {\n            db = rnd.next(1, max(1, b / (t-1)));\n        } else {\n            db = rnd.next(1, 10);\n        }\n\n        // Compute all possible x values\n        set<int> possible_x;\n        for (int iA = -1; iA < t; ++iA) {\n            int valA = 0;\n            if (iA != -1)\n                valA = a - iA * da;\n            if (valA < 0) continue;\n            for (int iB = -1; iB < t; ++iB) {\n                int valB = 0;\n                if (iB != -1)\n                    valB = b - iB * db;\n                if (valB < 0) continue;\n                int total = valA + valB;\n                if (total >= 0 && total <= 600)\n                    possible_x.insert(total);\n            }\n        }\n\n        // Now pick an x in [0,600] not in possible_x\n        vector<int> impossible_x;\n        for (int i = 0; i <= 600; ++i) {\n            if (possible_x.find(i) == possible_x.end())\n                impossible_x.push_back(i);\n        }\n\n        if (impossible_x.empty()) {\n            // All x in [0,600] are possible, adjust parameters\n            x = 601; // x must be within [0,600], so we need to adjust\n            x = 0; // Edge case\n            a = 1; b = 1; da = 1; db = 1; t = 1;\n        } else {\n            x = impossible_x[rnd.next(0, (int)impossible_x.size() -1)];\n        }\n\n    } else if (type == \"max_input\") {\n        // Generate test case with maximal input values\n        t = 300;\n        a = 300;\n        b = 300;\n        x = 600;\n        da = 1;\n        db = 1;\n\n    } else if (type == \"edge_case\") {\n        // Generate specific edge cases\n        t = rnd.next(1, 2);\n        a = 1;\n        b = 1;\n        da = 1;\n        db = 1;\n        x = 0; // Edge case where it's possible to get zero points\n    } else {\n        // Default random test case\n        a = rnd.next(1,300);\n        b = rnd.next(1,300);\n        if ((t-1) > 0) {\n            da = rnd.next(1, max(1, a / (t-1)));\n            db = rnd.next(1, max(1, b / (t-1)));\n        } else {\n            da = rnd.next(1,300);\n            db = rnd.next(1,300);\n        }\n        x = rnd.next(0,600);\n    }\n\n    // Ensure that a - (t - 1) * da ≥ 0 and b - (t - 1) * db ≥ 0\n    if (a - (t - 1) * da < 0) {\n        a = (t - 1) * da;\n    }\n    if (b - (t - 1) * db < 0) {\n        b = (t - 1) * db;\n    }\n\n    // Output x t a b da db\n    printf(\"%d %d %d %d %d %d\\n\", x, t, a, b, da, db);\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -t 10 -type random_possible\n./gen -t 10 -type random_impossible\n\n./gen -t 50 -type random_possible\n./gen -t 50 -type random_impossible\n\n./gen -t 100 -type random_possible\n./gen -t 100 -type random_impossible\n\n./gen -t 300 -type random_possible\n./gen -t 300 -type random_impossible\n\n./gen -t 1 -type edge_case\n./gen -t 1 -type edge_case\n\n./gen -t 300 -type max_input\n./gen -t 1 -type max_input\n\n./gen -t 2 -type random_possible\n./gen -t 2 -type random_impossible\n\n./gen -t 5 -type random_possible\n./gen -t 5 -type random_impossible\n\n./gen -t 299 -type random_possible\n./gen -t 299 -type random_impossible\n\n./gen -t 100 -type random_possible\n./gen -t 100 -type random_impossible\n\n./gen -t 1 -type random_possible\n./gen -t 1 -type random_impossible\n\n./gen -t 300 -type edge_case\n\n./gen -t 10 -type random_possible\n./gen -t 10 -type random_impossible\n\n./gen -t 50 -type random_possible\n./gen -t 50 -type random_impossible\n\n./gen -t 100 -type random_possible\n./gen -t 100 -type random_impossible\n\n./gen -t 1 -type max_input\n./gen -t 300 -type edge_case\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T19:48:23.467232",
        "total_tutorials": 1,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "203/B",
      "title": "B. Game on Paper",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains two integers n and m (1 ≤ n ≤ 1000, 1 ≤ m ≤ min(n·n, 105)) — the size of the squared piece of paper and the number of moves, correspondingly. Then, m lines contain the description of the moves. The i-th line contains two integers xi, yi (1 ≤ xi, yi ≤ n) — the number of row and column of the square that gets painted on the i-th move. All numbers on the lines are separated by single spaces. It is guaranteed that all moves are different. The moves are numbered starting from 1 in the order, in which they are given in the input. The columns of the squared piece of paper are numbered starting from 1, from the left to the right. The rows of the squared piece of paper are numbered starting from 1, from top to bottom.",
      "output_spec": "OutputOn a single line print the answer to the problem — the minimum number of the move after which the piece of paper has a black square with side 3. If no such move exists, print -1.",
      "sample_tests": "ExamplesInputCopy4 111 11 21 32 22 31 42 43 43 23 34 1OutputCopy10InputCopy4 121 11 21 32 22 31 42 43 43 24 24 13 1OutputCopy-1",
      "description": "B. Game on Paper\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains two integers n and m (1 ≤ n ≤ 1000, 1 ≤ m ≤ min(n·n, 105)) — the size of the squared piece of paper and the number of moves, correspondingly. Then, m lines contain the description of the moves. The i-th line contains two integers xi, yi (1 ≤ xi, yi ≤ n) — the number of row and column of the square that gets painted on the i-th move. All numbers on the lines are separated by single spaces. It is guaranteed that all moves are different. The moves are numbered starting from 1 in the order, in which they are given in the input. The columns of the squared piece of paper are numbered starting from 1, from the left to the right. The rows of the squared piece of paper are numbered starting from 1, from top to bottom.\n\nOutputOn a single line print the answer to the problem — the minimum number of the move after which the piece of paper has a black square with side 3. If no such move exists, print -1.\n\nInputCopy4 111 11 21 32 22 31 42 43 43 23 34 1OutputCopy10InputCopy4 121 11 21 32 22 31 42 43 43 24 24 13 1OutputCopy-1\n\nInputCopy4 111 11 21 32 22 31 42 43 43 23 34 1\n\nOutputCopy10\n\nInputCopy4 121 11 21 32 22 31 42 43 43 24 24 13 1\n\nOutputCopy-1",
      "solutions": [
        {
          "title": "Codeforces Round #128 (Div. 2) - Codeforces",
          "content": "Hello, friends!A few hours later you're lucky to participate in this remarkable Codeforces Round #27 for Div. 21 participants, but traditionally the others can take part out of the competition.It has been prepared by a small band of authors: me (NALP), Igor Kudryashov (Igor_Kudryashov), and Pavel Kholkin (HolkinPV). There were Gerald Agapov (Gerald), Maria Belova (Delinur) and Mike Mirzayanov (MikeMirzayanov) with us as always.It’s well-known that you can participate in this Round into competition only today! There won’t be another Codeforces Round #27!Traditionally I wish good luck, accepted solutions and successful hacking attempts for you!UPD: Points are standard: 500, 1000, 1500, 2000, 2500.UPD: Round is over, thanks to all! We hope you have got a fun. Don't forget, system testing will be soon.",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/4818",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 809
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #128 (Div. 2) - Codeforces - Code 1",
          "code": "return a > b ? b : a;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4818",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #128 (Div. 2) - Codeforces - Code 2",
          "code": "for(int i = chmax(1, x - 2); i <= x; i++)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4818",
          "author": "Qingyu"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 1000, \"n\");\n    inf.readSpace();\n    int maxM = min(1LL * n * n, 100000LL);\n    int m = inf.readInt(1, maxM, \"m\");\n    inf.readEoln();\n\n    set<pair<int,int>> moves;\n\n    for (int i = 0; i < m; ++i) {\n        int xi = inf.readInt(1, n, \"xi\");\n        inf.readSpace();\n        int yi = inf.readInt(1, n, \"yi\");\n        inf.readEoln();\n        pair<int,int> move = make_pair(xi, yi);\n        ensuref(moves.count(move) == 0, \"Move #%d (%d %d) is duplicated\", i+1, xi, yi);\n        moves.insert(move);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 1000, \"n\");\n    inf.readSpace();\n    int maxM = min(1LL * n * n, 100000LL);\n    int m = inf.readInt(1, maxM, \"m\");\n    inf.readEoln();\n\n    set<pair<int,int>> moves;\n\n    for (int i = 0; i < m; ++i) {\n        int xi = inf.readInt(1, n, \"xi\");\n        inf.readSpace();\n        int yi = inf.readInt(1, n, \"yi\");\n        inf.readEoln();\n        pair<int,int> move = make_pair(xi, yi);\n        ensuref(moves.count(move) == 0, \"Move #%d (%d %d) is duplicated\", i+1, xi, yi);\n        moves.insert(move);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 1000, \"n\");\n    inf.readSpace();\n    int maxM = min(1LL * n * n, 100000LL);\n    int m = inf.readInt(1, maxM, \"m\");\n    inf.readEoln();\n\n    set<pair<int,int>> moves;\n\n    for (int i = 0; i < m; ++i) {\n        int xi = inf.readInt(1, n, \"xi\");\n        inf.readSpace();\n        int yi = inf.readInt(1, n, \"yi\");\n        inf.readEoln();\n        pair<int,int> move = make_pair(xi, yi);\n        ensuref(moves.count(move) == 0, \"Move #%d (%d %d) is duplicated\", i+1, xi, yi);\n        moves.insert(move);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string type = opt<string>(\"type\", \"random\");\n    int k = opt<int>(\"k\", -1);\n\n    vector<pair<int, int>> moves;\n\n    if (type == \"random\") {\n        // Generate m unique random cells\n        if (m > n * n) m = n * n;\n        vector<pair<int, int>> all_cells;\n        for (int i = 1; i <= n; ++i)\n            for (int j = 1; j <= n; ++j)\n                all_cells.push_back(make_pair(i, j));\n        shuffle(all_cells.begin(), all_cells.end());\n        moves.assign(all_cells.begin(), all_cells.begin() + m);\n    } else if (type == \"early\") {\n        // Ensure that at move k, a 3x3 square appears\n        if (k == -1) k = 9;  // Minimum moves to form a 3x3 square\n        if (k > m) {\n            fprintf(stderr, \"Invalid parameters: k should be <= m\\n\");\n            exit(1);\n        }\n        if (n < 3) {\n            // Cannot form a 3x3 square\n            printf(\"%d %d\\n\", n, m);\n            for (int i = 0; i < m; ++i) {\n                int x = rnd.next(1, n);\n                int y = rnd.next(1, n);\n                printf(\"%d %d\\n\", x, y);\n            }\n            return 0;\n        }\n\n        // Decide where to place the 3x3 square\n        int max_pos = n - 2;\n        int x0 = rnd.next(1, max_pos);\n        int y0 = rnd.next(1, max_pos);\n\n        // List of cells in the 3x3 square\n        vector<pair<int, int>> square_cells;\n        for (int i = x0; i <= x0 + 2; ++i)\n            for (int j = y0; j <= y0 + 2; ++j)\n                square_cells.push_back(make_pair(i, j));\n\n        // Randomly select one cell as the completion cell\n        shuffle(square_cells.begin(), square_cells.end());\n        pair<int, int> completion_cell = square_cells.back();\n        square_cells.pop_back();\n\n        // Shuffle the other 8 cells\n        shuffle(square_cells.begin(), square_cells.end());\n\n        // Build the moves\n        // First k-1 moves: paint the other 8 cells (up to k-1)\n        int moves_to_add = min(k - 1, 8);\n        for (int i = 0; i < moves_to_add; ++i) {\n            moves.push_back(square_cells[i]);\n        }\n        // If k - 1 < 8, we still have cells to paint later\n        vector<pair<int, int>> pending_cells;\n        for (int i = moves_to_add; i < 8; ++i) {\n            pending_cells.push_back(square_cells[i]);\n        }\n\n        // At move k, paint the completion cell\n        moves.push_back(completion_cell);\n\n        // For the rest of the moves, generate random cells not already used\n        set<pair<int, int>> used_cells(moves.begin(), moves.end());\n        used_cells.insert(pending_cells.begin(), pending_cells.end());\n\n        int remaining_moves = m - moves.size() - pending_cells.size();\n\n        vector<pair<int, int>> other_cells;\n        for (int i = 1; i <= n; ++i)\n            for (int j = 1; j <= n; ++j) {\n                pair<int, int> cell = make_pair(i, j);\n                if (used_cells.find(cell) == used_cells.end())\n                    other_cells.push_back(cell);\n            }\n        shuffle(other_cells.begin(), other_cells.end());\n        // Add pending cells first\n        moves.insert(moves.end(), pending_cells.begin(), pending_cells.end());\n        // Then fill up remaining moves\n        for (int i = 0; i < remaining_moves; ++i) {\n            moves.push_back(other_cells[i]);\n        }\n    } else if (type == \"impossible\") {\n        // Try to create a case where no 3x3 square can be formed\n        // Color cells where (i + j) % 2 == 0\n        vector<pair<int, int>> possible_cells;\n\n        for (int i = 1; i <= n; ++i)\n            for (int j = 1; j <= n; ++j)\n                if ((i + j) % 2 == 0)\n                    possible_cells.push_back(make_pair(i, j));\n        if (m > possible_cells.size()) {\n            fprintf(stderr, \"Cannot create 'impossible' case with m = %d, only %d cells available\\n\", m, (int)possible_cells.size());\n            exit(1);\n        }\n        shuffle(possible_cells.begin(), possible_cells.end());\n        moves.assign(possible_cells.begin(), possible_cells.begin() + m);\n    } else {\n        fprintf(stderr, \"Invalid type parameter: %s\\n\", type.c_str());\n        exit(1);\n    }\n\n    // Output n and m\n    printf(\"%d %d\\n\", n, m);\n\n    // Output the moves\n    for (int i = 0; i < m; ++i) {\n        printf(\"%d %d\\n\", moves[i].first, moves[i].second);\n    }\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string type = opt<string>(\"type\", \"random\");\n    int k = opt<int>(\"k\", -1);\n\n    vector<pair<int, int>> moves;\n\n    if (type == \"random\") {\n        // Generate m unique random cells\n        if (m > n * n) m = n * n;\n        vector<pair<int, int>> all_cells;\n        for (int i = 1; i <= n; ++i)\n            for (int j = 1; j <= n; ++j)\n                all_cells.push_back(make_pair(i, j));\n        shuffle(all_cells.begin(), all_cells.end());\n        moves.assign(all_cells.begin(), all_cells.begin() + m);\n    } else if (type == \"early\") {\n        // Ensure that at move k, a 3x3 square appears\n        if (k == -1) k = 9;  // Minimum moves to form a 3x3 square\n        if (k > m) {\n            fprintf(stderr, \"Invalid parameters: k should be <= m\\n\");\n            exit(1);\n        }\n        if (n < 3) {\n            // Cannot form a 3x3 square\n            printf(\"%d %d\\n\", n, m);\n            for (int i = 0; i < m; ++i) {\n                int x = rnd.next(1, n);\n                int y = rnd.next(1, n);\n                printf(\"%d %d\\n\", x, y);\n            }\n            return 0;\n        }\n\n        // Decide where to place the 3x3 square\n        int max_pos = n - 2;\n        int x0 = rnd.next(1, max_pos);\n        int y0 = rnd.next(1, max_pos);\n\n        // List of cells in the 3x3 square\n        vector<pair<int, int>> square_cells;\n        for (int i = x0; i <= x0 + 2; ++i)\n            for (int j = y0; j <= y0 + 2; ++j)\n                square_cells.push_back(make_pair(i, j));\n\n        // Randomly select one cell as the completion cell\n        shuffle(square_cells.begin(), square_cells.end());\n        pair<int, int> completion_cell = square_cells.back();\n        square_cells.pop_back();\n\n        // Shuffle the other 8 cells\n        shuffle(square_cells.begin(), square_cells.end());\n\n        // Build the moves\n        // First k-1 moves: paint the other 8 cells (up to k-1)\n        int moves_to_add = min(k - 1, 8);\n        for (int i = 0; i < moves_to_add; ++i) {\n            moves.push_back(square_cells[i]);\n        }\n        // If k - 1 < 8, we still have cells to paint later\n        vector<pair<int, int>> pending_cells;\n        for (int i = moves_to_add; i < 8; ++i) {\n            pending_cells.push_back(square_cells[i]);\n        }\n\n        // At move k, paint the completion cell\n        moves.push_back(completion_cell);\n\n        // For the rest of the moves, generate random cells not already used\n        set<pair<int, int>> used_cells(moves.begin(), moves.end());\n        used_cells.insert(pending_cells.begin(), pending_cells.end());\n\n        int remaining_moves = m - moves.size() - pending_cells.size();\n\n        vector<pair<int, int>> other_cells;\n        for (int i = 1; i <= n; ++i)\n            for (int j = 1; j <= n; ++j) {\n                pair<int, int> cell = make_pair(i, j);\n                if (used_cells.find(cell) == used_cells.end())\n                    other_cells.push_back(cell);\n            }\n        shuffle(other_cells.begin(), other_cells.end());\n        // Add pending cells first\n        moves.insert(moves.end(), pending_cells.begin(), pending_cells.end());\n        // Then fill up remaining moves\n        for (int i = 0; i < remaining_moves; ++i) {\n            moves.push_back(other_cells[i]);\n        }\n    } else if (type == \"impossible\") {\n        // Try to create a case where no 3x3 square can be formed\n        // Color cells where (i + j) % 2 == 0\n        vector<pair<int, int>> possible_cells;\n\n        for (int i = 1; i <= n; ++i)\n            for (int j = 1; j <= n; ++j)\n                if ((i + j) % 2 == 0)\n                    possible_cells.push_back(make_pair(i, j));\n        if (m > possible_cells.size()) {\n            fprintf(stderr, \"Cannot create 'impossible' case with m = %d, only %d cells available\\n\", m, (int)possible_cells.size());\n            exit(1);\n        }\n        shuffle(possible_cells.begin(), possible_cells.end());\n        moves.assign(possible_cells.begin(), possible_cells.begin() + m);\n    } else {\n        fprintf(stderr, \"Invalid type parameter: %s\\n\", type.c_str());\n        exit(1);\n    }\n\n    // Output n and m\n    printf(\"%d %d\\n\", n, m);\n\n    // Output the moves\n    for (int i = 0; i < m; ++i) {\n        printf(\"%d %d\\n\", moves[i].first, moves[i].second);\n    }\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Random cases with small n and m\n./gen -n 3 -m 5 -type random\n./gen -n 5 -m 10 -type random\n./gen -n 10 -m 50 -type random\n\n# Random cases with large n and m\n./gen -n 1000 -m 1000 -type random\n./gen -n 1000 -m 10000 -type random\n./gen -n 1000 -m 100000 -type random\n\n# Early cases with k = 9 (minimum number of moves to form a 3x3 square)\n./gen -n 5 -m 20 -type early -k 9\n./gen -n 10 -m 50 -type early -k 9\n\n# Early cases with k in the middle of m\n./gen -n 1000 -m 100000 -type early -k 50000\n\n# Early cases with k near m\n./gen -n 1000 -m 100000 -type early -k 99990\n\n# Early cases with maximum n and m\n./gen -n 1000 -m 100000 -type early\n\n# Impossible cases where m is small\n./gen -n 5 -m 12 -type impossible\n\n# Impossible cases with maximum possible m without forming a 3x3 square\n./gen -n 5 -m 13 -type impossible\n./gen -n 1000 -m 500000 -type impossible\n\n# Random cases with n small and m maximum\n./gen -n 31 -m 961 -type random\n\n# Early cases with n less than 3 (should handle gracefully)\n./gen -n 2 -m 4 -type early -k 3\n\n# Random cases with n = 3 (minimum size for a 3x3 square)\n./gen -n 3 -m 9 -type random\n\n# Random cases with n = 1 (no 3x3 square possible)\n./gen -n 1 -m 1 -type random\n\n# Early cases with n = 3 and k = 9\n./gen -n 3 -m 9 -type early -k 9\n\n# Random cases with m less than needed to form a 3x3 square\n./gen -n 100 -m 8 -type random\n\n# Random case with m = 1\n./gen -n 1000 -m 1 -type random\n\n# Random case with maximum n and m\n./gen -n 1000 -m 100000 -type random\n\n# Impossible case where m is maximum without forming a 3x3 square\n./gen -n 1000 -m 500000 -type impossible\n\n# Random case with n such that n*n = 100000 (maximum m)\n./gen -n 316 -m 100000 -type random\n\n# Early case with k = 1 (3x3 square formed at first move)\n./gen -n 1000 -m 100000 -type early -k 1\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T19:48:25.212529",
        "total_tutorials": 1,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "203/C",
      "title": "C. Photographer",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains two integers n and d (1 ≤ n ≤ 105, 1 ≤ d ≤ 109) — the number of clients and the camera memory size, correspondingly. The second line contains two integers a and b (1 ≤ a ≤ b ≤ 104) — the size of one low quality photo and of one high quality photo, correspondingly. Next n lines describe the clients. The i-th line contains two integers xi and yi (0 ≤ xi, yi ≤ 105) — the number of low quality photos and high quality photos the i-th client wants, correspondingly. All numbers on all lines are separated by single spaces.",
      "output_spec": "OutputOn the first line print the answer to the problem — the maximum number of clients that Valera can successfully serve. Print on the second line the numbers of the client in any order. All numbers must be distinct. If there are multiple answers, print any of them. The clients are numbered starting with 1 in the order in which they are defined in the input data.",
      "sample_tests": "ExamplesInputCopy3 102 31 42 11 0OutputCopy23 2 InputCopy3 66 61 11 01 0OutputCopy12",
      "description": "C. Photographer\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains two integers n and d (1 ≤ n ≤ 105, 1 ≤ d ≤ 109) — the number of clients and the camera memory size, correspondingly. The second line contains two integers a and b (1 ≤ a ≤ b ≤ 104) — the size of one low quality photo and of one high quality photo, correspondingly. Next n lines describe the clients. The i-th line contains two integers xi and yi (0 ≤ xi, yi ≤ 105) — the number of low quality photos and high quality photos the i-th client wants, correspondingly. All numbers on all lines are separated by single spaces.\n\nOutputOn the first line print the answer to the problem — the maximum number of clients that Valera can successfully serve. Print on the second line the numbers of the client in any order. All numbers must be distinct. If there are multiple answers, print any of them. The clients are numbered starting with 1 in the order in which they are defined in the input data.\n\nInputCopy3 102 31 42 11 0OutputCopy23 2 InputCopy3 66 61 11 01 0OutputCopy12\n\nInputCopy3 102 31 42 11 0\n\nOutputCopy23 2\n\nInputCopy3 66 61 11 01 0\n\nOutputCopy12",
      "solutions": [
        {
          "title": "Codeforces Round #128 (Div. 2) - Codeforces",
          "content": "Hello, friends!A few hours later you're lucky to participate in this remarkable Codeforces Round #27 for Div. 21 participants, but traditionally the others can take part out of the competition.It has been prepared by a small band of authors: me (NALP), Igor Kudryashov (Igor_Kudryashov), and Pavel Kholkin (HolkinPV). There were Gerald Agapov (Gerald), Maria Belova (Delinur) and Mike Mirzayanov (MikeMirzayanov) with us as always.It’s well-known that you can participate in this Round into competition only today! There won’t be another Codeforces Round #27!Traditionally I wish good luck, accepted solutions and successful hacking attempts for you!UPD: Points are standard: 500, 1000, 1500, 2000, 2500.UPD: Round is over, thanks to all! We hope you have got a fun. Don't forget, system testing will be soon.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/4818",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 809
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #128 (Div. 2) - Codeforces - Code 1",
          "code": "return a > b ? b : a;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4818",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #128 (Div. 2) - Codeforces - Code 2",
          "code": "for(int i = chmax(1, x - 2); i <= x; i++)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4818",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int d = inf.readInt(1, 1000000000, \"d\");\n    inf.readEoln();\n\n    int a = inf.readInt(1, 10000, \"a\");\n    inf.readSpace();\n    int b = inf.readInt(1, 10000, \"b\");\n    inf.readEoln();\n\n    ensuref(a <= b, \"a must be less than or equal to b\");\n\n    for (int i = 0; i < n; ++i) {\n        int xi = inf.readInt(0, 100000, \"xi\");\n        inf.readSpace();\n        int yi = inf.readInt(0, 100000, \"yi\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int d = inf.readInt(1, 1000000000, \"d\");\n    inf.readEoln();\n\n    int a = inf.readInt(1, 10000, \"a\");\n    inf.readSpace();\n    int b = inf.readInt(1, 10000, \"b\");\n    inf.readEoln();\n\n    ensuref(a <= b, \"a must be less than or equal to b\");\n\n    for (int i = 0; i < n; ++i) {\n        int xi = inf.readInt(0, 100000, \"xi\");\n        inf.readSpace();\n        int yi = inf.readInt(0, 100000, \"yi\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int d = inf.readInt(1, 1000000000, \"d\");\n    inf.readEoln();\n\n    int a = inf.readInt(1, 10000, \"a\");\n    inf.readSpace();\n    int b = inf.readInt(1, 10000, \"b\");\n    inf.readEoln();\n\n    ensuref(a <= b, \"a must be less than or equal to b\");\n\n    for (int i = 0; i < n; ++i) {\n        int xi = inf.readInt(0, 100000, \"xi\");\n        inf.readSpace();\n        int yi = inf.readInt(0, 100000, \"yi\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAX_N = 1e5;\nconst long long MAX_D = 1e9;\nconst int MAX_A_B = 1e4;\nconst int MAX_XI_YI = 1e5;\n\nint n;\nlong long d, a, b;\nvector<int> xi, yi;\nvector<long long> sizes;\n\nint readAns(InStream &stream, vector<int>& clients, long long& total_size) {\n    int k = stream.readInt(0, n, \"k\");\n    clients = stream.readInts(k, 1, n, \"client_numbers\");\n    set<int> client_set;\n    total_size = 0;\n    for (int i = 0; i < k; i++) {\n        int client_num = clients[i];\n        if (client_set.count(client_num)) {\n            stream.quitf(_wa, \"Client number %d is listed more than once\", client_num);\n        }\n        client_set.insert(client_num);\n        int client_index = client_num - 1; // zero-based index\n        total_size += sizes[client_index];\n    }\n    if (total_size > d) {\n        stream.quitf(_wa, \"Total size %lld exceeds camera memory d=%lld\", total_size, d);\n    }\n    return k;\n}\n\nint main(int argc, char* argv[]) {\n    registerTestlibCmd(argc, argv);\n\n    n = inf.readInt(1, MAX_N, \"n\");\n    d = inf.readLong(1, MAX_D, \"d\");\n    a = inf.readInt(1, MAX_A_B, \"a\");\n    b = inf.readInt(a, MAX_A_B, \"b\");\n\n    xi.resize(n);\n    yi.resize(n);\n    sizes.resize(n);\n    for (int i = 0; i < n; i++) {\n        xi[i] = inf.readInt(0, MAX_XI_YI, format(\"xi[%d]\", i + 1).c_str());\n        yi[i] = inf.readInt(0, MAX_XI_YI, format(\"yi[%d]\", i + 1).c_str());\n        sizes[i] = (long long)xi[i] * a + (long long)yi[i] * b;\n    }\n\n    vector<int> clients_jury, clients_participant;\n    long long total_size_jury, total_size_participant;\n\n    int k_jury = readAns(ans, clients_jury, total_size_jury);\n    int k_participant = readAns(ouf, clients_participant, total_size_participant);\n\n    if (k_participant > k_jury) {\n        quitf(_fail, \"Participant's answer is better than jury's: participant k=%d, jury k=%d\",\n              k_participant, k_jury);\n    } else if (k_participant < k_jury) {\n        quitf(_wa, \"Participant's answer is worse than jury's: participant k=%d, jury k=%d\",\n              k_participant, k_jury);\n    } else {\n        quitf(_ok, \"Correct answer with k=%d\", k_participant);\n    }\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int d = opt<int>(\"d\");\n    int a = opt<int>(\"a\");\n    int b = opt<int>(\"b\");\n    string type = opt<string>(\"type\", \"random\");\n\n    printf(\"%d %d\\n\", n, d);\n    printf(\"%d %d\\n\", a, b);\n\n    vector<pair<int, int> > clients(n);\n\n    if (type == \"min\") {\n        // All xi and yi are zero\n        for (int i = 0; i < n; ++i) {\n            clients[i] = make_pair(0, 0);\n        }\n    } else if (type == \"max\") {\n        // All xi and yi are maximum\n        for (int i = 0; i < n; ++i) {\n            clients[i].first = 100000; // xi\n            clients[i].second = 100000; // yi\n        }\n    } else if (type == \"random\") {\n        for (int i = 0; i < n; ++i) {\n            int xi = rnd.next(0, 100000);\n            int yi = rnd.next(0, 100000);\n            clients[i] = make_pair(xi, yi);\n        }\n    } else if (type == \"single_client_full\") {\n        // First client uses as much memory as possible\n        long long totalMemory = d;\n        long long xi = min(1LL * 100000, totalMemory / a);\n        totalMemory -= xi * a;\n        long long yi = min(1LL * 100000, totalMemory / b);\n        clients[0] = make_pair((int)xi, (int)yi);\n        for (int i = 1; i < n; ++i) {\n            clients[i] = make_pair(0, 0);\n        }\n    } else if (type == \"alternating\") {\n        for (int i = 0; i < n; ++i) {\n            if (i % 2 == 0) {\n                clients[i].first = 0;\n                clients[i].second = rnd.next(0, 100000);\n            } else {\n                clients[i].first = rnd.next(0, 100000);\n                clients[i].second = 0;\n            }\n        }\n    } else if (type == \"zero_xi\") {\n        for (int i = 0; i < n; ++i) {\n            clients[i].first = 0;\n            clients[i].second = rnd.next(0, 100000);\n        }\n    } else if (type == \"zero_yi\") {\n        for (int i = 0; i < n; ++i) {\n            clients[i].first = rnd.next(0, 100000);\n            clients[i].second = 0;\n        }\n    } else if (type == \"max_memory\") {\n        // Fill up the memory completely\n        long long total = 0;\n        vector<pair<int, int> > possible_clients;\n        for (int i = 0; i < n; ++i) {\n            int xi = rnd.next(0, 100000);\n            int yi = rnd.next(0, 100000);\n            possible_clients.push_back(make_pair(xi, yi));\n        }\n        // Sort clients by their required memory\n        sort(possible_clients.begin(), possible_clients.end(), [&](pair<int, int> a1, pair<int, int> a2){\n            return (long long)a1.first * a + (long long)a1.second * b < (long long)a2.first * a + (long long)a2.second * b;\n        });\n        int idx = 0;\n        while (idx < n && total <= d) {\n            long long req = (long long)possible_clients[idx].first * a + (long long)possible_clients[idx].second * b;\n            if (total + req <= d) {\n                clients[idx] = possible_clients[idx];\n                total += req;\n            } else {\n                break;\n            }\n            idx++;\n        }\n        for (; idx < n; ++idx) {\n            clients[idx] = make_pair(0, 0);\n        }\n    } else if (type == \"edge_case_d\") {\n        // Create clients where sum of required memory is close to d\n        long long total = 0;\n        for (int i = 0; i < n; ++i) {\n            int xi = rnd.next(0, min(100000, (int)(d / a)));\n            int yi = rnd.next(0, min(100000, (int)((d - xi * a) / b)));\n            long long req = (long long)xi * a + (long long)yi * b;\n            if (total + req > d) {\n                xi = 0;\n                yi = 0;\n            } else {\n                total += req;\n            }\n            clients[i] = make_pair(xi, yi);\n        }\n    } else {\n        // Default to random\n        for (int i = 0; i < n; ++i) {\n            int xi = rnd.next(0, 100000);\n            int yi = rnd.next(0, 100000);\n            clients[i] = make_pair(xi, yi);\n        }\n    }\n\n    // Output the clients\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d %d\\n\", clients[i].first, clients[i].second);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int d = opt<int>(\"d\");\n    int a = opt<int>(\"a\");\n    int b = opt<int>(\"b\");\n    string type = opt<string>(\"type\", \"random\");\n\n    printf(\"%d %d\\n\", n, d);\n    printf(\"%d %d\\n\", a, b);\n\n    vector<pair<int, int> > clients(n);\n\n    if (type == \"min\") {\n        // All xi and yi are zero\n        for (int i = 0; i < n; ++i) {\n            clients[i] = make_pair(0, 0);\n        }\n    } else if (type == \"max\") {\n        // All xi and yi are maximum\n        for (int i = 0; i < n; ++i) {\n            clients[i].first = 100000; // xi\n            clients[i].second = 100000; // yi\n        }\n    } else if (type == \"random\") {\n        for (int i = 0; i < n; ++i) {\n            int xi = rnd.next(0, 100000);\n            int yi = rnd.next(0, 100000);\n            clients[i] = make_pair(xi, yi);\n        }\n    } else if (type == \"single_client_full\") {\n        // First client uses as much memory as possible\n        long long totalMemory = d;\n        long long xi = min(1LL * 100000, totalMemory / a);\n        totalMemory -= xi * a;\n        long long yi = min(1LL * 100000, totalMemory / b);\n        clients[0] = make_pair((int)xi, (int)yi);\n        for (int i = 1; i < n; ++i) {\n            clients[i] = make_pair(0, 0);\n        }\n    } else if (type == \"alternating\") {\n        for (int i = 0; i < n; ++i) {\n            if (i % 2 == 0) {\n                clients[i].first = 0;\n                clients[i].second = rnd.next(0, 100000);\n            } else {\n                clients[i].first = rnd.next(0, 100000);\n                clients[i].second = 0;\n            }\n        }\n    } else if (type == \"zero_xi\") {\n        for (int i = 0; i < n; ++i) {\n            clients[i].first = 0;\n            clients[i].second = rnd.next(0, 100000);\n        }\n    } else if (type == \"zero_yi\") {\n        for (int i = 0; i < n; ++i) {\n            clients[i].first = rnd.next(0, 100000);\n            clients[i].second = 0;\n        }\n    } else if (type == \"max_memory\") {\n        // Fill up the memory completely\n        long long total = 0;\n        vector<pair<int, int> > possible_clients;\n        for (int i = 0; i < n; ++i) {\n            int xi = rnd.next(0, 100000);\n            int yi = rnd.next(0, 100000);\n            possible_clients.push_back(make_pair(xi, yi));\n        }\n        // Sort clients by their required memory\n        sort(possible_clients.begin(), possible_clients.end(), [&](pair<int, int> a1, pair<int, int> a2){\n            return (long long)a1.first * a + (long long)a1.second * b < (long long)a2.first * a + (long long)a2.second * b;\n        });\n        int idx = 0;\n        while (idx < n && total <= d) {\n            long long req = (long long)possible_clients[idx].first * a + (long long)possible_clients[idx].second * b;\n            if (total + req <= d) {\n                clients[idx] = possible_clients[idx];\n                total += req;\n            } else {\n                break;\n            }\n            idx++;\n        }\n        for (; idx < n; ++idx) {\n            clients[idx] = make_pair(0, 0);\n        }\n    } else if (type == \"edge_case_d\") {\n        // Create clients where sum of required memory is close to d\n        long long total = 0;\n        for (int i = 0; i < n; ++i) {\n            int xi = rnd.next(0, min(100000, (int)(d / a)));\n            int yi = rnd.next(0, min(100000, (int)((d - xi * a) / b)));\n            long long req = (long long)xi * a + (long long)yi * b;\n            if (total + req > d) {\n                xi = 0;\n                yi = 0;\n            } else {\n                total += req;\n            }\n            clients[i] = make_pair(xi, yi);\n        }\n    } else {\n        // Default to random\n        for (int i = 0; i < n; ++i) {\n            int xi = rnd.next(0, 100000);\n            int yi = rnd.next(0, 100000);\n            clients[i] = make_pair(xi, yi);\n        }\n    }\n\n    // Output the clients\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d %d\\n\", clients[i].first, clients[i].second);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 5 -d 10 -a 1 -b 2 -type small\n./gen -n 5 -d 10 -a 2 -b 2 -type min\n./gen -n 5 -d 10 -a 2 -b 2 -type max\n./gen -n 10 -d 100000 -a 2 -b 3 -type random\n./gen -n 100 -d 1000000 -a 10 -b 15 -type random\n./gen -n 1000 -d 10000000 -a 100 -b 200 -type random\n\n./gen -n 100000 -d 1000000000 -a 10000 -b 10000 -type random\n./gen -n 100000 -d 1000000000 -a 5000 -b 5000 -type alternating\n./gen -n 100000 -d 1000000000 -a 1 -b 1 -type zero_xi\n./gen -n 100000 -d 1000000000 -a 1 -b 1 -type zero_yi\n./gen -n 100000 -d 1000000000 -a 1 -b 10000 -type single_client_full\n./gen -n 100000 -d 1000000000 -a 10000 -b 10000 -type max_memory\n./gen -n 100000 -d 1000000000 -a 1 -b 1 -type edge_case_d\n./gen -n 100000 -d 1000000000 -a 1 -b 10000 -type min\n./gen -n 100000 -d 1000000000 -a 10000 -b 1 -type max\n./gen -n 100000 -d 1000000000 -a 5000 -b 5000 -type random\n./gen -n 1 -d 10 -a 1 -b 1 -type random\n./gen -n 2 -d 10 -a 1 -b 1 -type random\n./gen -n 100000 -d 1000000000 -a 1 -b 1 -type max_memory\n./gen -n 100000 -d 1000000000 -a 1 -b 1 -type edge_case_d\n./gen -n 100000 -d 1000000000 -a 1 -b 1 -type alternating\n./gen -n 100000 -d 1000000000 -a 10000 -b 10000 -type alternating\n./gen -n 100000 -d 1000000000 -a 1 -b 10000 -type zero_xi\n./gen -n 100000 -d 1000000000 -a 10000 -b 1 -type zero_yi\n./gen -n 100000 -d 1000000000 -a 10000 -b 5000 -type random\n./gen -n 100000 -d 1000000000 -a 5000 -b 10000 -type random\n./gen -n 100000 -d 1000000000 -a 1 -b 1 -type max_memory\n./gen -n 100000 -d 1 -a 10000 -b 10000 -type max_memory\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T19:48:27.410912",
        "total_tutorials": 1,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "203/D",
      "title": "D. Hit Ball",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains three space-separated integers a, b, m (1 ≤ a, b, m ≤ 100). The first two integers specify point (a, 0, b), through which the ceiling and one of the corridor walls pass. The third integer is the distance at which Valera went away from the door.The second line has three space-separated integers vx, vy, vz (|vx|, |vy|, |vz| ≤ 100, vy < 0, vz ≥ 0) — the speed of the ball after the hit.It is guaranteed that the ball hits the door.",
      "output_spec": "OutputPrint two real numbers x0, z0 — the x and z coordinates of point (x0, 0, z0), at which the ball hits the exit door. The answer will be considered correct, if its absolute or relative error does not exceed 10  - 6.",
      "sample_tests": "ExamplesInputCopy7 2 113 -11 2OutputCopy6.5000000000 2.0000000000InputCopy7 2 114 -3 3OutputCopy4.1666666667 1.0000000000",
      "description": "D. Hit Ball\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains three space-separated integers a, b, m (1 ≤ a, b, m ≤ 100). The first two integers specify point (a, 0, b), through which the ceiling and one of the corridor walls pass. The third integer is the distance at which Valera went away from the door.The second line has three space-separated integers vx, vy, vz (|vx|, |vy|, |vz| ≤ 100, vy < 0, vz ≥ 0) — the speed of the ball after the hit.It is guaranteed that the ball hits the door.\n\nOutputPrint two real numbers x0, z0 — the x and z coordinates of point (x0, 0, z0), at which the ball hits the exit door. The answer will be considered correct, if its absolute or relative error does not exceed 10  - 6.\n\nInputCopy7 2 113 -11 2OutputCopy6.5000000000 2.0000000000InputCopy7 2 114 -3 3OutputCopy4.1666666667 1.0000000000\n\nInputCopy7 2 113 -11 2\n\nOutputCopy6.5000000000 2.0000000000\n\nInputCopy7 2 114 -3 3\n\nOutputCopy4.1666666667 1.0000000000",
      "solutions": [
        {
          "title": "Codeforces Round #128 (Div. 2) - Codeforces",
          "content": "Hello, friends!A few hours later you're lucky to participate in this remarkable Codeforces Round #27 for Div. 21 participants, but traditionally the others can take part out of the competition.It has been prepared by a small band of authors: me (NALP), Igor Kudryashov (Igor_Kudryashov), and Pavel Kholkin (HolkinPV). There were Gerald Agapov (Gerald), Maria Belova (Delinur) and Mike Mirzayanov (MikeMirzayanov) with us as always.It’s well-known that you can participate in this Round into competition only today! There won’t be another Codeforces Round #27!Traditionally I wish good luck, accepted solutions and successful hacking attempts for you!UPD: Points are standard: 500, 1000, 1500, 2000, 2500.UPD: Round is over, thanks to all! We hope you have got a fun. Don't forget, system testing will be soon.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/4818",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 809
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #128 (Div. 2) - Codeforces - Code 1",
          "code": "return a > b ? b : a;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4818",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #128 (Div. 2) - Codeforces - Code 2",
          "code": "for(int i = chmax(1, x - 2); i <= x; i++)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4818",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int a = inf.readInt(1, 100, \"a\");\n    inf.readSpace();\n    int b = inf.readInt(1, 100, \"b\");\n    inf.readSpace();\n    int m = inf.readInt(1, 100, \"m\");\n    inf.readEoln();\n\n    int vx = inf.readInt(-100, 100, \"vx\");\n    inf.readSpace();\n    int vy = inf.readInt(-100, -1, \"vy\"); // vy < 0\n    inf.readSpace();\n    int vz = inf.readInt(0, 100, \"vz\"); // vz ≥ 0\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int a = inf.readInt(1, 100, \"a\");\n    inf.readSpace();\n    int b = inf.readInt(1, 100, \"b\");\n    inf.readSpace();\n    int m = inf.readInt(1, 100, \"m\");\n    inf.readEoln();\n\n    int vx = inf.readInt(-100, 100, \"vx\");\n    inf.readSpace();\n    int vy = inf.readInt(-100, -1, \"vy\"); // vy < 0\n    inf.readSpace();\n    int vz = inf.readInt(0, 100, \"vz\"); // vz ≥ 0\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int a = inf.readInt(1, 100, \"a\");\n    inf.readSpace();\n    int b = inf.readInt(1, 100, \"b\");\n    inf.readSpace();\n    int m = inf.readInt(1, 100, \"m\");\n    inf.readEoln();\n\n    int vx = inf.readInt(-100, 100, \"vx\");\n    inf.readSpace();\n    int vy = inf.readInt(-100, -1, \"vy\"); // vy < 0\n    inf.readSpace();\n    int vz = inf.readInt(0, 100, \"vz\"); // vz ≥ 0\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nconst double EPS = 1E-6;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare two sequences of doubles, max absolute or relative  error = %.7f\", EPS);\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    double j = 0, p = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        n++;\r\n        j = ans.readDouble();\r\n        p = ouf.readDouble();\r\n        if (!doubleCompare(j, p, EPS)) {\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%.7f', found: '%.7f', error = '%.7f'\",\r\n                  n, englishEnding(n).c_str(), j, p, doubleDelta(j, p));\r\n        }\r\n    }\r\n\r\n    if (n == 1)\r\n        quitf(_ok, \"found '%.7f', expected '%.7f', error '%.7f'\", p, j, doubleDelta(j, p));\r\n\r\n    quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int a = opt<int>(\"a\", rnd.next(1,100));\n    int b = opt<int>(\"b\", rnd.next(1,100));\n    int m = opt<int>(\"m\", rnd.next(1,100));\n    string type = opt<string>(\"type\", \"random\");\n\n    int vx = 0, vy = 0, vz = 0;\n\n    if (type == \"random\") {\n        // Generate random vx, vy, vz within constraints, vy < 0, vz ≥ 0\n        do {\n            vx = rnd.next(-100, 100);\n        } while (vx == 0);\n        vy = rnd.next(-100, -1);\n        vz = rnd.next(0, 100);\n    } else if (type == \"vx_zero\") {\n        vx = 0;\n        vy = rnd.next(-100, -1);\n        vz = rnd.next(0, 100);\n    } else if (type == \"vz_zero\") {\n        vz = 0;\n        vy = rnd.next(-100, -1);\n        do {\n            vx = rnd.next(-100, 100);\n        } while (vx == 0);\n    } else if (type == \"straight_line\") {\n        // Set vx and vz such that the ball goes straight to the door without bouncing\n        vy = rnd.next(-100, -1);\n        double T = m / (-double(vy));\n        double max_vx = (a / 2.0 - 1e-6) / T;\n        if (abs(max_vx) > 100) max_vx = 100;\n        vx = rnd.next(-int(max_vx), int(max_vx));\n        double max_vz = (b / 2.0 - 1e-6) / T;\n        if (max_vz > 100) max_vz = 100;\n        vz = rnd.next(0, int(max_vz));\n    } else if (type == \"edge_case\") {\n        // Ensure ball hits corner at x=0 or x=a\n        vy = rnd.next(-100, -1);\n        double T = m / (-double(vy));\n\n        // Target x0 = 0 or a\n        int target = rnd.next(0, 1) * a; // 0 or a\n        double vx_double = (target - a / 2.0) / T;  // vx = (x0 - x(0)) / T\n\n        if (abs(vx_double) > 100) {\n            // Adjust vy to make vx in [-100,100]\n            vx = rnd.next(-100, 100);\n            vy = int(-m / ((target - a / 2.0) / vx));\n            if (vy >= 0) vy = -1;\n        } else {\n            vx = int(vx_double);\n            if (vx == 0) vx = target == 0 ? -1 : 1;\n        }\n        vz = rnd.next(0, 100);\n    } else {\n        // Default to random\n        do {\n            vx = rnd.next(-100, 100);\n        } while(vx == 0);\n        vy = rnd.next(-100, -1);\n        vz = rnd.next(0, 100);\n    }\n\n    // Output\n    printf(\"%d %d %d\\n\", a, b, m);\n    printf(\"%d %d %d\\n\", vx, vy, vz);\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int a = opt<int>(\"a\", rnd.next(1,100));\n    int b = opt<int>(\"b\", rnd.next(1,100));\n    int m = opt<int>(\"m\", rnd.next(1,100));\n    string type = opt<string>(\"type\", \"random\");\n\n    int vx = 0, vy = 0, vz = 0;\n\n    if (type == \"random\") {\n        // Generate random vx, vy, vz within constraints, vy < 0, vz ≥ 0\n        do {\n            vx = rnd.next(-100, 100);\n        } while (vx == 0);\n        vy = rnd.next(-100, -1);\n        vz = rnd.next(0, 100);\n    } else if (type == \"vx_zero\") {\n        vx = 0;\n        vy = rnd.next(-100, -1);\n        vz = rnd.next(0, 100);\n    } else if (type == \"vz_zero\") {\n        vz = 0;\n        vy = rnd.next(-100, -1);\n        do {\n            vx = rnd.next(-100, 100);\n        } while (vx == 0);\n    } else if (type == \"straight_line\") {\n        // Set vx and vz such that the ball goes straight to the door without bouncing\n        vy = rnd.next(-100, -1);\n        double T = m / (-double(vy));\n        double max_vx = (a / 2.0 - 1e-6) / T;\n        if (abs(max_vx) > 100) max_vx = 100;\n        vx = rnd.next(-int(max_vx), int(max_vx));\n        double max_vz = (b / 2.0 - 1e-6) / T;\n        if (max_vz > 100) max_vz = 100;\n        vz = rnd.next(0, int(max_vz));\n    } else if (type == \"edge_case\") {\n        // Ensure ball hits corner at x=0 or x=a\n        vy = rnd.next(-100, -1);\n        double T = m / (-double(vy));\n\n        // Target x0 = 0 or a\n        int target = rnd.next(0, 1) * a; // 0 or a\n        double vx_double = (target - a / 2.0) / T;  // vx = (x0 - x(0)) / T\n\n        if (abs(vx_double) > 100) {\n            // Adjust vy to make vx in [-100,100]\n            vx = rnd.next(-100, 100);\n            vy = int(-m / ((target - a / 2.0) / vx));\n            if (vy >= 0) vy = -1;\n        } else {\n            vx = int(vx_double);\n            if (vx == 0) vx = target == 0 ? -1 : 1;\n        }\n        vz = rnd.next(0, 100);\n    } else {\n        // Default to random\n        do {\n            vx = rnd.next(-100, 100);\n        } while(vx == 0);\n        vy = rnd.next(-100, -1);\n        vz = rnd.next(0, 100);\n    }\n\n    // Output\n    printf(\"%d %d %d\\n\", a, b, m);\n    printf(\"%d %d %d\\n\", vx, vy, vz);\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Random test cases with default parameters\n./gen -type random\n./gen -type random\n./gen -type random\n./gen -type random\n\n# Test cases with specified a, b, m\n./gen -a 10 -b 20 -m 30 -type random\n./gen -a 50 -b 60 -m 70 -type random\n./gen -a 80 -b 90 -m 100 -type random\n\n# Test cases with vx_zero (vx = 0)\n./gen -type vx_zero\n./gen -a 100 -b 100 -m 100 -type vx_zero\n./gen -a 1 -b 1 -m 1 -type vx_zero\n\n# Test cases with vz_zero (vz = 0)\n./gen -type vz_zero\n./gen -a 100 -b 100 -m 100 -type vz_zero\n./gen -a 1 -b 1 -m 1 -type vz_zero\n\n# Test cases with straight_line (no bounces)\n./gen -type straight_line\n./gen -a 50 -b 50 -m 50 -type straight_line\n./gen -a 75 -b 75 -m 75 -type straight_line\n\n# Test cases with edge_case (ball hits corner)\n./gen -type edge_case\n./gen -a 100 -b 100 -m 100 -type edge_case\n./gen -a 1 -b 1 -m 1 -type edge_case\n./gen -a 50 -b 1 -m 100 -type edge_case\n./gen -a 1 -b 50 -m 100 -type edge_case\n\n# Additional random test cases\n./gen -type random\n./gen -type random\n./gen -type random\n./gen -type random\n\n# Random test cases with maximal m\n./gen -m 100 -type random\n./gen -a 100 -b 100 -m 100 -type random\n\n# Random test cases with minimal m\n./gen -m 1 -type random\n./gen -a 100 -b 100 -m 1 -type random\n\n# Random test cases with minimal a, b\n./gen -a 1 -b 1 -type random\n./gen -a 1 -b 1 -m 1 -type random\n\n# Large values for a, b, m\n./gen -a 100 -b 100 -m 100 -type random\n./gen -a 99 -b 99 -m 99 -type random\n\n# Edge cases with m = 1\n./gen -a 100 -b 100 -m 1 -type edge_case\n./gen -a 50 -b 50 -m 1 -type edge_case\n\n# Edge cases with maximum velocities\n./gen -a 100 -b 100 -m 100 -type random\n./gen -a 100 -b 100 -m 100 -type vx_zero\n./gen -a 100 -b 100 -m 100 -type vz_zero\n./gen -a 100 -b 100 -m 100 -type straight_line\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T19:48:29.559629",
        "total_tutorials": 1,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "203/E",
      "title": "E. Transportation",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains three space-separated integers n, d, S (1 ≤ n ≤ 105, 1 ≤ d, S ≤ 109). The first number represents the number of robots, the second one — the distance to the luggage compartment and the third one — the amount of available fuel.Next n lines specify the robots. The i-th line contains three space-separated integers ci, fi, li (0 ≤ ci, fi, li ≤ 109) — the i-th robot's features. The first number is the number of robots the i-th robot can carry, the second number is the amount of fuel needed for the i-th robot to move and the third one shows the maximum distance the i-th robot can go.",
      "output_spec": "OutputPrint two space-separated integers — the maximum number of robots Valera can transport to the luggage compartment and the minimum amount of fuel he will need for that. If Valera won't manage to get any robots to the luggage compartment, print two zeroes.",
      "sample_tests": "ExamplesInputCopy3 10 100 12 101 6 100 1 1OutputCopy2 6InputCopy2 7 103 12 105 16 8OutputCopy0 0InputCopy4 8 100 12 31 1 00 3 111 6 9OutputCopy4 9",
      "description": "E. Transportation\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains three space-separated integers n, d, S (1 ≤ n ≤ 105, 1 ≤ d, S ≤ 109). The first number represents the number of robots, the second one — the distance to the luggage compartment and the third one — the amount of available fuel.Next n lines specify the robots. The i-th line contains three space-separated integers ci, fi, li (0 ≤ ci, fi, li ≤ 109) — the i-th robot's features. The first number is the number of robots the i-th robot can carry, the second number is the amount of fuel needed for the i-th robot to move and the third one shows the maximum distance the i-th robot can go.\n\nOutputPrint two space-separated integers — the maximum number of robots Valera can transport to the luggage compartment and the minimum amount of fuel he will need for that. If Valera won't manage to get any robots to the luggage compartment, print two zeroes.\n\nInputCopy3 10 100 12 101 6 100 1 1OutputCopy2 6InputCopy2 7 103 12 105 16 8OutputCopy0 0InputCopy4 8 100 12 31 1 00 3 111 6 9OutputCopy4 9\n\nInputCopy3 10 100 12 101 6 100 1 1\n\nOutputCopy2 6\n\nInputCopy2 7 103 12 105 16 8\n\nOutputCopy0 0\n\nInputCopy4 8 100 12 31 1 00 3 111 6 9\n\nOutputCopy4 9",
      "solutions": [
        {
          "title": "Codeforces Round #128 (Div. 2) - Codeforces",
          "content": "Hello, friends!A few hours later you're lucky to participate in this remarkable Codeforces Round #27 for Div. 21 participants, but traditionally the others can take part out of the competition.It has been prepared by a small band of authors: me (NALP), Igor Kudryashov (Igor_Kudryashov), and Pavel Kholkin (HolkinPV). There were Gerald Agapov (Gerald), Maria Belova (Delinur) and Mike Mirzayanov (MikeMirzayanov) with us as always.It’s well-known that you can participate in this Round into competition only today! There won’t be another Codeforces Round #27!Traditionally I wish good luck, accepted solutions and successful hacking attempts for you!UPD: Points are standard: 500, 1000, 1500, 2000, 2500.UPD: Round is over, thanks to all! We hope you have got a fun. Don't forget, system testing will be soon.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/4818",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 809
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #128 (Div. 2) - Codeforces - Code 1",
          "code": "return a > b ? b : a;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4818",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #128 (Div. 2) - Codeforces - Code 2",
          "code": "for(int i = chmax(1, x - 2); i <= x; i++)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4818",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int d = inf.readInt(1, 1000000000, \"d\");\n    inf.readSpace();\n    int S = inf.readInt(1, 1000000000, \"S\");\n    inf.readEoln();\n    \n    for (int i = 0; i < n; i++) {\n        int ci = inf.readInt(0, 1000000000, \"ci\");\n        inf.readSpace();\n        int fi = inf.readInt(0, 1000000000, \"fi\");\n        inf.readSpace();\n        int li = inf.readInt(0, 1000000000, \"li\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int d = inf.readInt(1, 1000000000, \"d\");\n    inf.readSpace();\n    int S = inf.readInt(1, 1000000000, \"S\");\n    inf.readEoln();\n    \n    for (int i = 0; i < n; i++) {\n        int ci = inf.readInt(0, 1000000000, \"ci\");\n        inf.readSpace();\n        int fi = inf.readInt(0, 1000000000, \"fi\");\n        inf.readSpace();\n        int li = inf.readInt(0, 1000000000, \"li\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int d = inf.readInt(1, 1000000000, \"d\");\n    inf.readSpace();\n    int S = inf.readInt(1, 1000000000, \"S\");\n    inf.readEoln();\n    \n    for (int i = 0; i < n; i++) {\n        int ci = inf.readInt(0, 1000000000, \"ci\");\n        inf.readSpace();\n        int fi = inf.readInt(0, 1000000000, \"fi\");\n        inf.readSpace();\n        int li = inf.readInt(0, 1000000000, \"li\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int d = opt<int>(\"d\");\n    int S = opt<int>(\"S\");\n    int max_ci = opt<int>(\"max_ci\", 1000000000);\n    int max_fi = opt<int>(\"max_fi\", 1000000000);\n    int max_li = opt<int>(\"max_li\", 1000000000);\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> ci(n), fi(n), li(n);\n\n    if (type == \"small\") {\n        // n small\n        n = min(n, 10);\n        cout << n << \" \" << d << \" \" << S << \"\\n\";\n        for (int i = 0; i < n; ++i) {\n            ci[i] = rnd.next(0, 10);\n            fi[i] = rnd.next(0, 10);\n            li[i] = rnd.next(0, 10);\n            cout << ci[i] << \" \" << fi[i] << \" \" << li[i] << \"\\n\";\n        }\n        return 0;\n    }\n    else if (type == \"many_zero_ci\") {\n        for (int i = 0; i < n; ++i) {\n            ci[i] = 0;\n            fi[i] = rnd.next(0, max_fi);\n            li[i] = rnd.next(0, max_li);\n        }\n    }\n    else if (type == \"many_zero_fi\") {\n        for (int i = 0; i < n; ++i) {\n            ci[i] = rnd.next(0, max_ci);\n            fi[i] = 0;\n            li[i] = rnd.next(0, max_li);\n        }\n    }\n    else if (type == \"many_zero_li\") {\n        for (int i = 0; i < n; ++i) {\n            ci[i] = rnd.next(0, max_ci);\n            fi[i] = rnd.next(0, max_fi);\n            li[i] = 0;\n        }\n    }\n    else if (type == \"high_capacity_low_fuel\") {\n        for (int i = 0; i < n; ++i) {\n            ci[i] = rnd.next(max_ci / 2, max_ci);\n            fi[i] = rnd.next(0, 10);\n            li[i] = rnd.next(d, max_li);\n        }\n    }\n    else if (type == \"low_capacity_high_fuel\") {\n        for (int i = 0; i < n; ++i) {\n            ci[i] = rnd.next(0, 1);\n            fi[i] = rnd.next(max_fi / 2, max_fi);\n            li[i] = rnd.next(d, max_li);\n        }\n    }\n    else if (type == \"capacities_exhausted\") {\n        // All capacities add up exactly to n - 1 (excluding initial moving robot)\n        int initial_moving_robots = 1;\n        int remaining_robots = n - initial_moving_robots;\n        ci[0] = remaining_robots;\n        fi[0] = rnd.next(1, S); // Use some fuel\n        li[0] = rnd.next(d, max_li);\n        for (int i = 1; i < n; ++i) {\n            ci[i] = 0;\n            fi[i] = 0;\n            li[i] = 0;\n        }\n    }\n    else if (type == \"fuel_exhausted\") {\n        // Set total fi = S\n        int total_fi = S;\n        for (int i = 0; i < n; ++i) {\n            if (i == n - 1) {\n                fi[i] = total_fi;\n            } else {\n                fi[i] = rnd.next(0, total_fi);\n                total_fi -= fi[i];\n            }\n            ci[i] = rnd.next(0, max_ci);\n            li[i] = rnd.next(d, max_li);\n        }\n    }\n    else if (type == \"fuel_insufficient\") {\n        // Set total fi > S\n        int total_fi = S + rnd.next(1, max_fi);\n        for (int i = 0; i < n; ++i) {\n            fi[i] = total_fi / n + 1;\n            ci[i] = rnd.next(0, max_ci);\n            li[i] = rnd.next(d, max_li);\n        }\n    }\n    else if (type == \"deep_nesting\") {\n        for (int i = 0; i < n; ++i) {\n            ci[i] = 1;\n            fi[i] = 0;\n            li[i] = rnd.next(d, max_li);\n        }\n    }\n    else if (type == \"li_less_than_d\") {\n        for (int i = 0; i < n; ++i) {\n            ci[i] = rnd.next(0, max_ci);\n            fi[i] = rnd.next(0, max_fi);\n            li[i] = rnd.next(0, d - 1);\n        }\n    }\n    else if (type == \"edge_fi_equals_S\") {\n        for (int i = 0; i < n; ++i) {\n            ci[i] = rnd.next(0, max_ci);\n            fi[i] = S;\n            li[i] = rnd.next(d, max_li);\n        }\n    }\n    else {\n        // Default to \"random\"\n        for (int i = 0; i < n; ++i) {\n            ci[i] = rnd.next(0, max_ci);\n            fi[i] = rnd.next(0, max_fi);\n            li[i] = rnd.next(0, max_li);\n        }\n    }\n\n    // Output the test case\n    cout << n << \" \" << d << \" \" << S << \"\\n\";\n    for (int i = 0; i < n; ++i) {\n        cout << ci[i] << \" \" << fi[i] << \" \" << li[i] << \"\\n\";\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int d = opt<int>(\"d\");\n    int S = opt<int>(\"S\");\n    int max_ci = opt<int>(\"max_ci\", 1000000000);\n    int max_fi = opt<int>(\"max_fi\", 1000000000);\n    int max_li = opt<int>(\"max_li\", 1000000000);\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> ci(n), fi(n), li(n);\n\n    if (type == \"small\") {\n        // n small\n        n = min(n, 10);\n        cout << n << \" \" << d << \" \" << S << \"\\n\";\n        for (int i = 0; i < n; ++i) {\n            ci[i] = rnd.next(0, 10);\n            fi[i] = rnd.next(0, 10);\n            li[i] = rnd.next(0, 10);\n            cout << ci[i] << \" \" << fi[i] << \" \" << li[i] << \"\\n\";\n        }\n        return 0;\n    }\n    else if (type == \"many_zero_ci\") {\n        for (int i = 0; i < n; ++i) {\n            ci[i] = 0;\n            fi[i] = rnd.next(0, max_fi);\n            li[i] = rnd.next(0, max_li);\n        }\n    }\n    else if (type == \"many_zero_fi\") {\n        for (int i = 0; i < n; ++i) {\n            ci[i] = rnd.next(0, max_ci);\n            fi[i] = 0;\n            li[i] = rnd.next(0, max_li);\n        }\n    }\n    else if (type == \"many_zero_li\") {\n        for (int i = 0; i < n; ++i) {\n            ci[i] = rnd.next(0, max_ci);\n            fi[i] = rnd.next(0, max_fi);\n            li[i] = 0;\n        }\n    }\n    else if (type == \"high_capacity_low_fuel\") {\n        for (int i = 0; i < n; ++i) {\n            ci[i] = rnd.next(max_ci / 2, max_ci);\n            fi[i] = rnd.next(0, 10);\n            li[i] = rnd.next(d, max_li);\n        }\n    }\n    else if (type == \"low_capacity_high_fuel\") {\n        for (int i = 0; i < n; ++i) {\n            ci[i] = rnd.next(0, 1);\n            fi[i] = rnd.next(max_fi / 2, max_fi);\n            li[i] = rnd.next(d, max_li);\n        }\n    }\n    else if (type == \"capacities_exhausted\") {\n        // All capacities add up exactly to n - 1 (excluding initial moving robot)\n        int initial_moving_robots = 1;\n        int remaining_robots = n - initial_moving_robots;\n        ci[0] = remaining_robots;\n        fi[0] = rnd.next(1, S); // Use some fuel\n        li[0] = rnd.next(d, max_li);\n        for (int i = 1; i < n; ++i) {\n            ci[i] = 0;\n            fi[i] = 0;\n            li[i] = 0;\n        }\n    }\n    else if (type == \"fuel_exhausted\") {\n        // Set total fi = S\n        int total_fi = S;\n        for (int i = 0; i < n; ++i) {\n            if (i == n - 1) {\n                fi[i] = total_fi;\n            } else {\n                fi[i] = rnd.next(0, total_fi);\n                total_fi -= fi[i];\n            }\n            ci[i] = rnd.next(0, max_ci);\n            li[i] = rnd.next(d, max_li);\n        }\n    }\n    else if (type == \"fuel_insufficient\") {\n        // Set total fi > S\n        int total_fi = S + rnd.next(1, max_fi);\n        for (int i = 0; i < n; ++i) {\n            fi[i] = total_fi / n + 1;\n            ci[i] = rnd.next(0, max_ci);\n            li[i] = rnd.next(d, max_li);\n        }\n    }\n    else if (type == \"deep_nesting\") {\n        for (int i = 0; i < n; ++i) {\n            ci[i] = 1;\n            fi[i] = 0;\n            li[i] = rnd.next(d, max_li);\n        }\n    }\n    else if (type == \"li_less_than_d\") {\n        for (int i = 0; i < n; ++i) {\n            ci[i] = rnd.next(0, max_ci);\n            fi[i] = rnd.next(0, max_fi);\n            li[i] = rnd.next(0, d - 1);\n        }\n    }\n    else if (type == \"edge_fi_equals_S\") {\n        for (int i = 0; i < n; ++i) {\n            ci[i] = rnd.next(0, max_ci);\n            fi[i] = S;\n            li[i] = rnd.next(d, max_li);\n        }\n    }\n    else {\n        // Default to \"random\"\n        for (int i = 0; i < n; ++i) {\n            ci[i] = rnd.next(0, max_ci);\n            fi[i] = rnd.next(0, max_fi);\n            li[i] = rnd.next(0, max_li);\n        }\n    }\n\n    // Output the test case\n    cout << n << \" \" << d << \" \" << S << \"\\n\";\n    for (int i = 0; i < n; ++i) {\n        cout << ci[i] << \" \" << fi[i] << \" \" << li[i] << \"\\n\";\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 10 -d 10 -S 10 -type small\n./gen -n 100 -d 100 -S 100 -type small\n./gen -n 1000 -d 1000 -S 1000 -type small\n\n./gen -n 10 -d 5 -S 50 -type many_zero_ci\n./gen -n 100 -d 50 -S 500 -type many_zero_ci\n./gen -n 1000 -d 500 -S 5000 -type many_zero_ci\n\n./gen -n 10000 -d 1000 -S 10000 -type many_zero_fi\n./gen -n 10000 -d 1000 -S 10000 -type many_zero_li\n\n./gen -n 100000 -d 1000000000 -S 1000000000 -type high_capacity_low_fuel\n./gen -n 100000 -d 1000000000 -S 1000000000 -type low_capacity_high_fuel\n\n./gen -n 100000 -d 1000000000 -S 1000000000 -type capacities_exhausted\n\n./gen -n 100000 -d 1 -S 1 -type fuel_exhausted\n\n./gen -n 100000 -d 1000000000 -S 1 -type fuel_insufficient\n\n./gen -n 100000 -d 1000000000 -S 1000000000 -type deep_nesting\n\n./gen -n 100000 -d 1000000000 -S 1000000000 -type li_less_than_d\n\n./gen -n 100000 -d 1000000000 -S 1000000000 -type edge_fi_equals_S\n\n./gen -n 100000 -d 1000000000 -S 1000000000 -type random\n\n# Adding max_ci parameter:\n./gen -n 100000 -d 1000000000 -S 1000000000 -max_ci 0 -type many_zero_ci\n\n# Varying other parameters:\n./gen -n 50000 -d 500000000 -S 500000000 -type high_capacity_low_fuel\n./gen -n 50000 -d 500000000 -S 500000000 -type low_capacity_high_fuel\n./gen -n 50000 -d 500000000 -S 500000000 -type capacities_exhausted\n./gen -n 50000 -d 500000000 -S 500000000 -type fuel_exhausted\n./gen -n 50000 -d 500000000 -S 500000000 -type fuel_insufficient\n./gen -n 50000 -d 500000000 -S 500000000 -type deep_nesting\n./gen -n 50000 -d 500000000 -S 500000000 -type li_less_than_d\n./gen -n 50000 -d 500000000 -S 500000000 -type edge_fi_equals_S\n\n# Additional small test cases\n./gen -n 1000 -d 1000 -S 1000 -type small\n./gen -n 2 -d 1 -S 1 -type small\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T19:48:31.801648",
        "total_tutorials": 1,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "204/A",
      "title": "A. Маленький Слоник и промежуток",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест2 секунды",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеВ единственной строке задана пара целых чисел l и r (1 ≤ l ≤ r ≤ 1018) — границы промежутка.Пожалуйста, не используйте спецификатор %lld для чтения или записи 64-х битовых чисел на С++. Рекомендуется использовать потоки cin, cout или спецификатор %I64d.",
      "output_spec": "Выходные данныеВ единственной строке выведите одно целое число — ответ на задачу.",
      "sample_tests": "ПримерыВходные данныеСкопировать2 47Выходные данныеСкопировать12Входные данныеСкопировать47 1024Выходные данныеСкопировать98",
      "description": "A. Маленький Слоник и промежуток\n\nограничение по времени на тест2 секунды\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвыводstdout\n\nВходные данныеВ единственной строке задана пара целых чисел l и r (1 ≤ l ≤ r ≤ 1018) — границы промежутка.Пожалуйста, не используйте спецификатор %lld для чтения или записи 64-х битовых чисел на С++. Рекомендуется использовать потоки cin, cout или спецификатор %I64d.\n\nВходные данные\n\nВыходные данныеВ единственной строке выведите одно целое число — ответ на задачу.\n\nВыходные данные\n\nВходные данныеСкопировать2 47Выходные данныеСкопировать12Входные данныеСкопировать47 1024Выходные данныеСкопировать98\n\nВходные данныеСкопировать2 47\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать12\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать47 1024\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать98\n\nВыходные данныеСкопировать\n\nСкопировать\n\nПримечаниеВ первом примере в ответ входят следующие числа: 2, 3, 4, 5, 6, 7, 8, 9, 11, 22, 33, 44.",
      "solutions": [
        {
          "title": "Codeforces Round #129 - Codeforces",
          "content": "Привет!Вот и пришло время очередного раунда Codeforces, а именно раунда номер 129. Он состоится 11.07.2012 в 19:30 (по Москве). В этот раз задачи для Вас готовил я. В далеком прошлом я уже был 4 раза автором задач для Codeforces, тогда задачи были в основном о счастливых числах. Но ничего не вечно, поэтому в этот раз не будет задач о счастливых числах и тематика задач будет различной.Помогал мне готовить задачи Геральд Агапов (Gerald), Александр Куприн (Alex_KPR), Аксёнов Виталик (Aksenov239), а традиционно задачи перевела Мария Белова (Delinur), за что им всем спасибо.Надеюсь задачи вам понравятся и все пройдет гладко и я преждевременно не опубликую разбор, который сейчас у меня в блоге.Держитесь!Спасибо всем за участие. Результаты оказались следующими:Div1: tourist (теперь tourist первый в мире таргет Codeforces, с чем его поздравляем) winger RAVEman rng_58 RAD bmerry Shik Div2: xiaoshua2 ahm.kam_92 HanzhongBall_Quanling daidailanlan Разбор задач можно найти здесь.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/4848",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 981
        },
        {
          "title": "Codeforces Round #129 — Разбор задач - Codeforces",
          "content": "205A - Маленький Слоник и РоздолЭто была самая простая задача из набора. Нужно просто отсортировать все расстояния (при этом поддерживая индексы) и, если первые два расстояния равны, вывести \"Still Rozdil\", иначе вывести индекс первого элемента.Сложность решения O(NlogN).205B - Маленький Слоник и сортировкаВ этой задачи нужно заметить тот факт (который несложно доказать, но он понятен даже интуитивно), что, так как массив нужно сделать неубывающим, если делать какую-то операцию, то r (правая граница) должна быть равна n. Действительно, подняв правую часть массива мы точно не ухудшим результат. После этого нужно идти слева направо и жадно делать необходимое количество операций на каждом шагу.Сложность решения O(N).205C - Маленький Слоник и промежутокЕстественно, для того что-бы решить задачу нужно написать функцию F(x) которая будет решать задачу на промежутке 0..x, тогда ответом будет F(r) - F(l - 1). Опишем реализацию функции F(x). Если x < 10, результатом будем сам x. Пусть len — длина числа x, а x' — число x без первой и последней цифр, а xi — i-я цифра числа x (от 0 слева направо). Переберем первую цифру d (она и будет последней) и длину того что внутри (пусть это будет i). Тогда если i < len - 2 или (i = len - 2 и d < x0), к ответу нужно добавить 10i. Иначе, если i = len - 2 и d = x0 то к ответу нужно добавить x', а если еще и i = len - 2, d = x0 и xlen - 1 ≥ d то нужно добавить еще 1 к ответу. Также эту задачу можно было решить используя ДП.205D - Маленький Слоник и карточкиЭту задачу можно удобно решить используя структуру map, но можно и обойтись без нее (используя сортировку и бинарный поиск). Давайте переберем цвет-кандидат который и приведет к веселости набора, для каждого цвета узнаем минимальное количество переворачиваний (если возможно вообще) и выберем минимум. Если никакой цвет не подходит, ответ \"-1\". Для того чтобы найти минимальное количество переворачиваний нам нужно узнать два числа — количество карточек которые изначально лежат текущим цветом вверх, а также количество карточек у которых сзади есть текущий цвет (при этом сверху какой-то другой). Пусть это числа a и b. соответственно. Пусть m = (n + 1) / 2 — минимальное количество одинаковых карточек необходимых для того, что-бы сделать набор веселым. Тогда текущий цвет может сделать набор веселым только если a + b ≥ m. Если a ≥ m, то ничего переворачивать не надо, то есть ответ 0, иначе ответ равен m - a.205E - Маленький Слоник и Фурик и РубикЗадача на математическое ожидание. Здесь важно учесть факт линейности математического ожидания, иными словами, ответ для какой-то пары строк это сумма количеств совпадений по каждому символам алфавита. Поэтому давайте для каждого символа первой строки найдем вероятность того, что он войдет в ответ. Тогда общим ответом будет сумма этих вероятностей.Пусть у нас текущий символ в первой строки с номером i (всюду 1-нумерация). Сначала решим задачу за O(N2). Переберем все позиции j левее i (или равные i) такие что Bj = Ai. Тогда для какой-то позиции нужно найти количество возможных пар строк таких, что в них именно эти два символы Ai и Bj совпали. Это количество будет равно j(n - i + 1) (j возможных символов слева и (n - i + 1) справа, поэтому общее количество это их произведение). Это будет O(N2). Так как все это — сумма, то ответ будет равен Si(n - i + 1), где Si — сумма всех позиций j таких, что Bj = Ai. Массив S можно несложно посчитать за линейное время. Аналогичным образом нужно обработать все индексы что правее i. После того как количество пар подстрок в которых i-й символ первой строки имеет совпадение найдено (пусть это count), к ответу нужно добавить count / total, где total — полное количество возможных исходов, его можно найти циклом или несложной формулой.Сложность решения O(N).204D - Маленький Слоник и ретро строкиДля начала нам нужно решить следующую подзадачу: для каждого префикса найти количество его заполнений таких, что он не содержит подстроки длиной k состоящую только из букв B. Пусть это будет F(x), где x это номер последнего символа префикса. Давайте присвоим F(x) = F(x - 1) * cnt, где cnt = 2, если Sx = 'X', 1 иначе. После такого присвоения в результат могли быть включены некоторые способы такие, что блок из k есть в конце префикса (они могли быть включены только если в подстроке Sx - k + 1..x нет букв W, а символ Sx - k не есть B), а это плохо. Поэтому (если такое могло произойти) нужно от F(x) отнять F(x - k - 1), это уберет все плохие варианты.Аналогичное ДП нужно посчитать для для суффиксов (или, иначе говоря, для реверсовной строки S), только здесь нужно избегать блоков из W.Теперь подумаем как организовать все что-бы не появилось повторов. Давайте переберем позицию, в которой будет заканчиваться первый слева блок из k подряд идущих букв B. При этом будем перебирать эту позицию справа налево. Используя ранее подсчитано ДП мы можем найти количество вариантов заполнить все буквы левее так, что-бы там не образовался блок. Если писать решение за O(N2), то мы можем перебрать позицию, в которой будет начинаться первый справа блок из k букв W, аналогичным образом найти количество способов заполнить все правее что-бы там не образовался блок, а символы между левым и правым блоками мы, очевидно, можем заполнять как-угодно. Но, так как мы идем справа налево, мы можем по ходу поддерживать сумму этих количеств. Это обеспечит нам линейность решения. 204E - Маленький Слоник и строкиДля решения данной задачи воспользуемся свойствами суффиксного массива. Болле подробно о суффиксном массиве можно почитать здесь:http://e-maxx.ru/algo/suffix_arrayДля начала нужно конкатенировать все строки в одну, при этом разделяя их какими-то символами которые не встречаются в строках. Например, три строки abc, a, ab можно склеить в одну следующего вида: abc#a@ab. Теперь нам нужно построить суффиксный массив по новой строке, это позволит нам отсортировать все циклические сдвиги строки. При этом первый символ каждого циклического сдвига это либо вспомогательный символ, либо символ какой-то входной строки. Заметим теперь что для того что-бы найти результат нам нужно для каждого циклического сдвига, начало которого принадлежит какой-то входной строке, найти максимальную длину его префикса такую, что этот префикс является подстрокой как минимум k входных строк. Это число можно искать бинарным поиском, но для этого нужно какую-то функцию которая бы отвечала на вопрос: а сколько есть различных входных строк которые содержат префикс длины len циклического сдвига номер x (Пусть это функция F(x, len)).Как же сделать функцию F(x, len)? Рассмотрим все циклические сдвиги, префикс длины len которых ровен префиксу длины len x-го сдвига. Заметим что, так как все сдвиги отсортированы лексикографически, набор таких сдвигов будет представлен каким-то промежутком [l;r] (1 ≤ l ≤ x ≤ r). Как же найти этот промежуток? Для каждой пары соседних сдвигов можно найти их наибольший общий префикс. Тогда l, например, можно найти используя RMQ — для этого нужно найти самую правую пару соседних сдвигов (левее x) таких, что их наибольший общий префикс меньше len. Аналогично можно найти r. После этого у нас есть промежуток [l;r] и нужно найти количество различных строк которые соответствуют этим сдвигам (иными словами, найти количество различных чисел в подмассиве). Но, заметим, что самое количество различных нас не интересует, а интересует только не меньше ли оно за k или нет. Тогда пусть L[i] равно максимальному j (j ≤ i) такому, что количество различных чисел в помассиве [j;i] ровно k. Тогда если L[r] ≥ l то, логично, что и в промежутке [l;r] также будет не меньше k различных чисел.Осталось заполнить массив L. Это довольно просто сделать используя структуру set (можно также использовать RMQ). Будем идти слева направо и в сете поддерживать индексы самых правых k различных чисел. Тогда если поступает какое-то число, то (если оно встречалось раньше) его прежнее вхождение нужно удалить из сета (если оно еще осталось) и вставить текущее. При этом если размер сета превышает k нужно извлекать минимальный элемент. Тогда если в какой-то позиции i размер сета есть k (после описанных выше изменений), это означает, что L[i] ровно минимальному элементу сета.Так как мы O(N) раз используем бинарный поиск, а функция F(x, len) работает за O(logN), финальная асимптотика решения равна O(Nlog2N).",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/4849",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.6,
            "reason": "宽松匹配: 包含题目编号 204 和字母"
          },
          "content_length": 8301
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #129 - Codeforces - Code 1",
          "code": "He has n cards, each has exactly two colors",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4848",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #129 - Codeforces - Code 2",
          "code": "The color of the front of the card may coincide with the color of the back of the card",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4848",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #129 - Codeforces - Code 3",
          "code": "5\n1 1\n1 1\n3 4\n5 6\n7 8",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4848",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #129 - Codeforces - Code 4",
          "code": "5\n1 1\n1 1\n3 4\n5 6\n7 8",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4848",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #129 - Codeforces - Code 5",
          "code": "3\n1 1\n2 2\n3 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4848",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #129 - Codeforces - Code 6",
          "code": "3\n1 1\n2 2\n3 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4848",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #129 - Codeforces - Code 7",
          "code": "public void solve() throws IOException {\n\t\tlong l = nextLong();\n\t\tlong r = nextLong();\n\t\tout.println(f(r) - f(l - 1));\n\t}\n\t\n\tlong f(long x) {\n\t\tif (x < 10) {\n\t\t\treturn x;\n\t\t}\n\t\tString s = Long.toString(x);\n\t\treturn (x / 10 - 1) + (s.charAt(0) <= s.charAt(s.length() - 1) ? 1 : 0) + 9;\n\t}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4848",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #129 - Codeforces - Code 8",
          "code": "public void solve() throws IOException {\n\t\tlong l = nextLong();\n\t\tlong r = nextLong();\n\t\tout.println(f(r) - f(l - 1));\n\t}\n\t\n\tlong f(long x) {\n\t\tif (x < 10) {\n\t\t\treturn x;\n\t\t}\n\t\tString s = Long.toString(x);\n\t\treturn (x / 10 - 1) + (s.charAt(0) <= s.charAt(s.length() - 1) ? 1 : 0) + 9;\n\t}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4848",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #129 - Codeforces - Code 9",
          "code": "double div=n*(n+1)*(2*n+1);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4848",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #129 - Codeforces - Code 10",
          "code": "double div=n*(n+1)*(2*n+1);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4848",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #129 — Разбор задач - Codeforces - Code 1",
          "code": "void randomShuffle(int[] arr) {\n    Random rnd = new Random();\n    for (int i = arr.length() - 1; i >= 0; i--) {\n        int pos = rnd.nextInt(i + 1);\n        int temp = arr[pos];\n        arr[pos] = arr[i];\n        arr[i] = temp;\n    }\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4849",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #129 — Разбор задач - Codeforces - Code 2",
          "code": "void randomShuffle(int[] arr) {\n    Random rnd = new Random();\n    for (int i = arr.length() - 1; i >= 0; i--) {\n        int pos = rnd.nextInt(i + 1);\n        int temp = arr[pos];\n        arr[pos] = arr[i];\n        arr[i] = temp;\n    }\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4849",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #129 — Разбор задач - Codeforces - Code 3",
          "code": "ll D[10][20][2];\nstring w;\n\nlong long d(int i, int j, int k) {\n    if (D[i][j][k] != -1) return D[i][j][k];\n    if (j == 1) {\n        if (i == 0 and k == 0) return 9;\n        if (i == 0 and k == 1) return w[w.size() - 1] - '0';\n        else if (k == 1) return i <= w[w.size() - 1] - '0';\n        else return 1;\n    }\n    long long cont = 0;\n    for (int e = 0; e < ((k == 0)?10:w[w.size() - j] - '0' + 1); ++e)\n      cont += d((i == 0)?e:i, j-1, (k == 0)?0:e == w[w.size() - j] - '0');\n    return D[i][j][k] = cont;\n}\n\nlong long F(long long x) {\n    memset(D,-1,sizeof(D));\n    stringstream l; l << x;\n    l >> w;\n    return d(0,w.size(),1);    \n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4849",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #129 — Разбор задач - Codeforces - Code 4",
          "code": "ll D[10][20][2];\nstring w;\n\nlong long d(int i, int j, int k) {\n    if (D[i][j][k] != -1) return D[i][j][k];\n    if (j == 1) {\n        if (i == 0 and k == 0) return 9;\n        if (i == 0 and k == 1) return w[w.size() - 1] - '0';\n        else if (k == 1) return i <= w[w.size() - 1] - '0';\n        else return 1;\n    }\n    long long cont = 0;\n    for (int e = 0; e < ((k == 0)?10:w[w.size() - j] - '0' + 1); ++e)\n      cont += d((i == 0)?e:i, j-1, (k == 0)?0:e == w[w.size() - j] - '0');\n    return D[i][j][k] = cont;\n}\n\nlong long F(long long x) {\n    memset(D,-1,sizeof(D));\n    stringstream l; l << x;\n    l >> w;\n    return d(0,w.size(),1);    \n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4849",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #129 — Разбор задач - Codeforces - Code 5",
          "code": "long n = in.nextLong();\n        long min = Long.MAX_VALUE;\n        long idx = -1;\n        Set<Long> set = new HashSet<>();\n        boolean flag = false;\n        for(int i=0;i<n;i++){\n            long val = in.nextLong();\n            if(set.contains(val))\n                flag = true;\n            if(val<min) {\n                min = val;\n                idx = i;\n            }\n            set.add(val);\n        }\n        out.println((flag)?\"Still Rozdil\":idx+1);\n\n        out.close();\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4849",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    long long l = inf.readLong(1LL, 1000000000000000000LL, \"l\");\n    inf.readSpace();\n    long long r = inf.readLong(1LL, 1000000000000000000LL, \"r\");\n    inf.readEoln();\n    ensuref(l <= r, \"l must be less than or equal to r\");\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    long long l = inf.readLong(1LL, 1000000000000000000LL, \"l\");\n    inf.readSpace();\n    long long r = inf.readLong(1LL, 1000000000000000000LL, \"r\");\n    inf.readEoln();\n    ensuref(l <= r, \"l must be less than or equal to r\");\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    long long l = inf.readLong(1LL, 1000000000000000000LL, \"l\");\n    inf.readSpace();\n    long long r = inf.readLong(1LL, 1000000000000000000LL, \"r\");\n    inf.readEoln();\n    ensuref(l <= r, \"l must be less than or equal to r\");\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nlong long pow10(int n) {\n    long long res = 1LL;\n    while (n--) res *= 10LL;\n    return res;\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    // Parse command-line arguments\n    string type = opt<string>(\"type\");\n\n    long long l, r;\n\n    if (type == \"small\") {\n        /* Small numbers */\n        l = rnd.next(1LL, 100LL);\n        r = rnd.next(l, 100LL);\n    } else if (type == \"large\") {\n        /* Large numbers near 1e18 */\n        l = rnd.next((long long)1e18 - (long long)1e6, (long long)1e18);\n        r = rnd.next(l, (long long)1e18);\n    } else if (type == \"equal\") {\n        /* l equals r */\n        l = rnd.next(1LL, (long long)1e18);\n        r = l;\n    } else if (type == \"max_range\") {\n        /* l = 1, r = 1e18 */\n        l = 1LL;\n        r = (long long)1e18;\n    } else if (type == \"random\") {\n        /* Random l and r */\n        l = rnd.next(1LL, (long long)1e18);\n        r = rnd.next(l, (long long)1e18);\n    } else if (type == \"one_digit\") {\n        /* l and r between 1 and 9 */\n        l = rnd.next(1LL, 9LL);\n        r = rnd.next(l, 9LL);\n    } else if (type == \"min_l\") {\n        /* l is minimum */\n        l = 1LL;\n        r = rnd.next(1LL, (long long)1e18);\n    } else if (type == \"max_r\") {\n        /* r is maximum */\n        l = rnd.next(1LL, (long long)1e18);\n        r = (long long)1e18;\n    } else if (type == \"edge_case1\") {\n        /* l = r = 1 */\n        l = 1LL;\n        r = 1LL;\n    } else if (type == \"edge_case2\") {\n        /* l = r = 1e18 */\n        l = (long long)1e18;\n        r = (long long)1e18;\n    } else if (type == \"boundary\") {\n        /* l and r around powers of 10 */\n        int n = rnd.next(1, 17);\n        l = pow10(n) - 1;\n        r = pow10(n);\n    } else if (type == \"palindrome\") {\n        /* Palindrome numbers */\n        int len = rnd.next(1, 18);\n        string s;\n        for (int i = 0; i < (len + 1) / 2; ++i) {\n            char c = '0' + rnd.next(i == 0 ? 1 : 0, 9);\n            s += c;\n        }\n        string t = s;\n        if (len % 2 == 1) t.pop_back();\n        reverse(t.begin(), t.end());\n        s += t;\n        l = stoll(s);\n        r = l;\n    } else if (type == \"first_last_same\") {\n        /* Numbers where first and last digit are the same */\n        int len = rnd.next(1, 18);\n        char c = '0' + rnd.next(1, 9);\n        string s;\n        s += c;\n        for (int i = 1; i < len - 1; ++i) {\n            s += '0' + rnd.next(0, 9);\n        }\n        if (len > 1) {\n            s += c;\n        }\n        l = stoll(s);\n        r = l;\n    } else {\n        cerr << \"Invalid type: \" << type << endl;\n        return 1;\n    }\n\n    if (l > r) swap(l, r);\n    cout << l << \" \" << r << endl;\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nlong long pow10(int n) {\n    long long res = 1LL;\n    while (n--) res *= 10LL;\n    return res;\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    // Parse command-line arguments\n    string type = opt<string>(\"type\");\n\n    long long l, r;\n\n    if (type == \"small\") {\n        /* Small numbers */\n        l = rnd.next(1LL, 100LL);\n        r = rnd.next(l, 100LL);\n    } else if (type == \"large\") {\n        /* Large numbers near 1e18 */\n        l = rnd.next((long long)1e18 - (long long)1e6, (long long)1e18);\n        r = rnd.next(l, (long long)1e18);\n    } else if (type == \"equal\") {\n        /* l equals r */\n        l = rnd.next(1LL, (long long)1e18);\n        r = l;\n    } else if (type == \"max_range\") {\n        /* l = 1, r = 1e18 */\n        l = 1LL;\n        r = (long long)1e18;\n    } else if (type == \"random\") {\n        /* Random l and r */\n        l = rnd.next(1LL, (long long)1e18);\n        r = rnd.next(l, (long long)1e18);\n    } else if (type == \"one_digit\") {\n        /* l and r between 1 and 9 */\n        l = rnd.next(1LL, 9LL);\n        r = rnd.next(l, 9LL);\n    } else if (type == \"min_l\") {\n        /* l is minimum */\n        l = 1LL;\n        r = rnd.next(1LL, (long long)1e18);\n    } else if (type == \"max_r\") {\n        /* r is maximum */\n        l = rnd.next(1LL, (long long)1e18);\n        r = (long long)1e18;\n    } else if (type == \"edge_case1\") {\n        /* l = r = 1 */\n        l = 1LL;\n        r = 1LL;\n    } else if (type == \"edge_case2\") {\n        /* l = r = 1e18 */\n        l = (long long)1e18;\n        r = (long long)1e18;\n    } else if (type == \"boundary\") {\n        /* l and r around powers of 10 */\n        int n = rnd.next(1, 17);\n        l = pow10(n) - 1;\n        r = pow10(n);\n    } else if (type == \"palindrome\") {\n        /* Palindrome numbers */\n        int len = rnd.next(1, 18);\n        string s;\n        for (int i = 0; i < (len + 1) / 2; ++i) {\n            char c = '0' + rnd.next(i == 0 ? 1 : 0, 9);\n            s += c;\n        }\n        string t = s;\n        if (len % 2 == 1) t.pop_back();\n        reverse(t.begin(), t.end());\n        s += t;\n        l = stoll(s);\n        r = l;\n    } else if (type == \"first_last_same\") {\n        /* Numbers where first and last digit are the same */\n        int len = rnd.next(1, 18);\n        char c = '0' + rnd.next(1, 9);\n        string s;\n        s += c;\n        for (int i = 1; i < len - 1; ++i) {\n            s += '0' + rnd.next(0, 9);\n        }\n        if (len > 1) {\n            s += c;\n        }\n        l = stoll(s);\n        r = l;\n    } else {\n        cerr << \"Invalid type: \" << type << endl;\n        return 1;\n    }\n\n    if (l > r) swap(l, r);\n    cout << l << \" \" << r << endl;\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -type small\n./gen -type large\n./gen -type equal\n./gen -type max_range\n./gen -type random\n./gen -type one_digit\n./gen -type min_l\n./gen -type max_r\n./gen -type edge_case1\n./gen -type edge_case2\n./gen -type boundary\n./gen -type palindrome\n./gen -type first_last_same\n./gen -type small\n./gen -type small\n./gen -type random\n./gen -type random\n./gen -type random\n./gen -type large\n./gen -type large\n./gen -type equal\n./gen -type edge_case1\n./gen -type edge_case2\n./gen -type one_digit\n./gen -type one_digit\n./gen -type min_l\n./gen -type max_r\n./gen -type palindrome\n./gen -type palindrome\n./gen -type palindrome\n./gen -type first_last_same\n./gen -type first_last_same\n./gen -type boundary\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T19:48:33.626941",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "204/B",
      "title": "B. Маленький Слоник и карточки",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест2 секунды",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеВ первой строке задано единственное целое число n (1 ≤ n ≤ 105) — количество карточек. Следующие n строк содержат описание всех карточек, по одной карточке на строку. Карточки описываются парой целых положительных чисел, не превосходящих 109, — цветами на обеих сторонах. Первое число в строке — это цвет на передней стороне карточки, второе — на задней. Цвет на передней стороне может совпадать с цветом на задней.Числа в строках разделяются единичными пробелами.",
      "output_spec": "Выходные данныеВ единственной строке выведите единственное целое число — искомое минимальное количество шагов. Если превратить набор в веселый невозможно, выведите -1.",
      "sample_tests": "ПримерыВходные данныеСкопировать34 74 77 4Выходные данныеСкопировать0Входные данныеСкопировать54 77 42 119 71 1Выходные данныеСкопировать2",
      "description": "B. Маленький Слоник и карточки\n\nограничение по времени на тест2 секунды\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвыводstdout\n\nВходные данныеВ первой строке задано единственное целое число n (1 ≤ n ≤ 105) — количество карточек. Следующие n строк содержат описание всех карточек, по одной карточке на строку. Карточки описываются парой целых положительных чисел, не превосходящих 109, — цветами на обеих сторонах. Первое число в строке — это цвет на передней стороне карточки, второе — на задней. Цвет на передней стороне может совпадать с цветом на задней.Числа в строках разделяются единичными пробелами.\n\nВходные данные\n\nВыходные данныеВ единственной строке выведите единственное целое число — искомое минимальное количество шагов. Если превратить набор в веселый невозможно, выведите -1.\n\nВыходные данные\n\nВходные данныеСкопировать34 74 77 4Выходные данныеСкопировать0Входные данныеСкопировать54 77 42 119 71 1Выходные данныеСкопировать2\n\nВходные данныеСкопировать34 74 77 4\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать0\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать54 77 42 119 71 1\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать2\n\nВыходные данныеСкопировать\n\nСкопировать\n\nПримечаниеВ первом примере изначально лежат три карточки из цветами 4, 4, 7. Так как две из трех карточек имеют одинаковый цвет 4, менять ничего не нужно, поэтому ответ — 0.Во втором примере можно перевернуть первую и четвертую карточки. После этого три из пяти карточек будут иметь цвет 7.",
      "solutions": [
        {
          "title": "Codeforces Round #129 - Codeforces",
          "content": "Привет!Вот и пришло время очередного раунда Codeforces, а именно раунда номер 129. Он состоится 11.07.2012 в 19:30 (по Москве). В этот раз задачи для Вас готовил я. В далеком прошлом я уже был 4 раза автором задач для Codeforces, тогда задачи были в основном о счастливых числах. Но ничего не вечно, поэтому в этот раз не будет задач о счастливых числах и тематика задач будет различной.Помогал мне готовить задачи Геральд Агапов (Gerald), Александр Куприн (Alex_KPR), Аксёнов Виталик (Aksenov239), а традиционно задачи перевела Мария Белова (Delinur), за что им всем спасибо.Надеюсь задачи вам понравятся и все пройдет гладко и я преждевременно не опубликую разбор, который сейчас у меня в блоге.Держитесь!Спасибо всем за участие. Результаты оказались следующими:Div1: tourist (теперь tourist первый в мире таргет Codeforces, с чем его поздравляем) winger RAVEman rng_58 RAD bmerry Shik Div2: xiaoshua2 ahm.kam_92 HanzhongBall_Quanling daidailanlan Разбор задач можно найти здесь.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/4848",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 981
        },
        {
          "title": "Codeforces Round #129 — Разбор задач - Codeforces",
          "content": "205A - Маленький Слоник и РоздолЭто была самая простая задача из набора. Нужно просто отсортировать все расстояния (при этом поддерживая индексы) и, если первые два расстояния равны, вывести \"Still Rozdil\", иначе вывести индекс первого элемента.Сложность решения O(NlogN).205B - Маленький Слоник и сортировкаВ этой задачи нужно заметить тот факт (который несложно доказать, но он понятен даже интуитивно), что, так как массив нужно сделать неубывающим, если делать какую-то операцию, то r (правая граница) должна быть равна n. Действительно, подняв правую часть массива мы точно не ухудшим результат. После этого нужно идти слева направо и жадно делать необходимое количество операций на каждом шагу.Сложность решения O(N).205C - Маленький Слоник и промежутокЕстественно, для того что-бы решить задачу нужно написать функцию F(x) которая будет решать задачу на промежутке 0..x, тогда ответом будет F(r) - F(l - 1). Опишем реализацию функции F(x). Если x < 10, результатом будем сам x. Пусть len — длина числа x, а x' — число x без первой и последней цифр, а xi — i-я цифра числа x (от 0 слева направо). Переберем первую цифру d (она и будет последней) и длину того что внутри (пусть это будет i). Тогда если i < len - 2 или (i = len - 2 и d < x0), к ответу нужно добавить 10i. Иначе, если i = len - 2 и d = x0 то к ответу нужно добавить x', а если еще и i = len - 2, d = x0 и xlen - 1 ≥ d то нужно добавить еще 1 к ответу. Также эту задачу можно было решить используя ДП.205D - Маленький Слоник и карточкиЭту задачу можно удобно решить используя структуру map, но можно и обойтись без нее (используя сортировку и бинарный поиск). Давайте переберем цвет-кандидат который и приведет к веселости набора, для каждого цвета узнаем минимальное количество переворачиваний (если возможно вообще) и выберем минимум. Если никакой цвет не подходит, ответ \"-1\". Для того чтобы найти минимальное количество переворачиваний нам нужно узнать два числа — количество карточек которые изначально лежат текущим цветом вверх, а также количество карточек у которых сзади есть текущий цвет (при этом сверху какой-то другой). Пусть это числа a и b. соответственно. Пусть m = (n + 1) / 2 — минимальное количество одинаковых карточек необходимых для того, что-бы сделать набор веселым. Тогда текущий цвет может сделать набор веселым только если a + b ≥ m. Если a ≥ m, то ничего переворачивать не надо, то есть ответ 0, иначе ответ равен m - a.205E - Маленький Слоник и Фурик и РубикЗадача на математическое ожидание. Здесь важно учесть факт линейности математического ожидания, иными словами, ответ для какой-то пары строк это сумма количеств совпадений по каждому символам алфавита. Поэтому давайте для каждого символа первой строки найдем вероятность того, что он войдет в ответ. Тогда общим ответом будет сумма этих вероятностей.Пусть у нас текущий символ в первой строки с номером i (всюду 1-нумерация). Сначала решим задачу за O(N2). Переберем все позиции j левее i (или равные i) такие что Bj = Ai. Тогда для какой-то позиции нужно найти количество возможных пар строк таких, что в них именно эти два символы Ai и Bj совпали. Это количество будет равно j(n - i + 1) (j возможных символов слева и (n - i + 1) справа, поэтому общее количество это их произведение). Это будет O(N2). Так как все это — сумма, то ответ будет равен Si(n - i + 1), где Si — сумма всех позиций j таких, что Bj = Ai. Массив S можно несложно посчитать за линейное время. Аналогичным образом нужно обработать все индексы что правее i. После того как количество пар подстрок в которых i-й символ первой строки имеет совпадение найдено (пусть это count), к ответу нужно добавить count / total, где total — полное количество возможных исходов, его можно найти циклом или несложной формулой.Сложность решения O(N).204D - Маленький Слоник и ретро строкиДля начала нам нужно решить следующую подзадачу: для каждого префикса найти количество его заполнений таких, что он не содержит подстроки длиной k состоящую только из букв B. Пусть это будет F(x), где x это номер последнего символа префикса. Давайте присвоим F(x) = F(x - 1) * cnt, где cnt = 2, если Sx = 'X', 1 иначе. После такого присвоения в результат могли быть включены некоторые способы такие, что блок из k есть в конце префикса (они могли быть включены только если в подстроке Sx - k + 1..x нет букв W, а символ Sx - k не есть B), а это плохо. Поэтому (если такое могло произойти) нужно от F(x) отнять F(x - k - 1), это уберет все плохие варианты.Аналогичное ДП нужно посчитать для для суффиксов (или, иначе говоря, для реверсовной строки S), только здесь нужно избегать блоков из W.Теперь подумаем как организовать все что-бы не появилось повторов. Давайте переберем позицию, в которой будет заканчиваться первый слева блок из k подряд идущих букв B. При этом будем перебирать эту позицию справа налево. Используя ранее подсчитано ДП мы можем найти количество вариантов заполнить все буквы левее так, что-бы там не образовался блок. Если писать решение за O(N2), то мы можем перебрать позицию, в которой будет начинаться первый справа блок из k букв W, аналогичным образом найти количество способов заполнить все правее что-бы там не образовался блок, а символы между левым и правым блоками мы, очевидно, можем заполнять как-угодно. Но, так как мы идем справа налево, мы можем по ходу поддерживать сумму этих количеств. Это обеспечит нам линейность решения. 204E - Маленький Слоник и строкиДля решения данной задачи воспользуемся свойствами суффиксного массива. Болле подробно о суффиксном массиве можно почитать здесь:http://e-maxx.ru/algo/suffix_arrayДля начала нужно конкатенировать все строки в одну, при этом разделяя их какими-то символами которые не встречаются в строках. Например, три строки abc, a, ab можно склеить в одну следующего вида: abc#a@ab. Теперь нам нужно построить суффиксный массив по новой строке, это позволит нам отсортировать все циклические сдвиги строки. При этом первый символ каждого циклического сдвига это либо вспомогательный символ, либо символ какой-то входной строки. Заметим теперь что для того что-бы найти результат нам нужно для каждого циклического сдвига, начало которого принадлежит какой-то входной строке, найти максимальную длину его префикса такую, что этот префикс является подстрокой как минимум k входных строк. Это число можно искать бинарным поиском, но для этого нужно какую-то функцию которая бы отвечала на вопрос: а сколько есть различных входных строк которые содержат префикс длины len циклического сдвига номер x (Пусть это функция F(x, len)).Как же сделать функцию F(x, len)? Рассмотрим все циклические сдвиги, префикс длины len которых ровен префиксу длины len x-го сдвига. Заметим что, так как все сдвиги отсортированы лексикографически, набор таких сдвигов будет представлен каким-то промежутком [l;r] (1 ≤ l ≤ x ≤ r). Как же найти этот промежуток? Для каждой пары соседних сдвигов можно найти их наибольший общий префикс. Тогда l, например, можно найти используя RMQ — для этого нужно найти самую правую пару соседних сдвигов (левее x) таких, что их наибольший общий префикс меньше len. Аналогично можно найти r. После этого у нас есть промежуток [l;r] и нужно найти количество различных строк которые соответствуют этим сдвигам (иными словами, найти количество различных чисел в подмассиве). Но, заметим, что самое количество различных нас не интересует, а интересует только не меньше ли оно за k или нет. Тогда пусть L[i] равно максимальному j (j ≤ i) такому, что количество различных чисел в помассиве [j;i] ровно k. Тогда если L[r] ≥ l то, логично, что и в промежутке [l;r] также будет не меньше k различных чисел.Осталось заполнить массив L. Это довольно просто сделать используя структуру set (можно также использовать RMQ). Будем идти слева направо и в сете поддерживать индексы самых правых k различных чисел. Тогда если поступает какое-то число, то (если оно встречалось раньше) его прежнее вхождение нужно удалить из сета (если оно еще осталось) и вставить текущее. При этом если размер сета превышает k нужно извлекать минимальный элемент. Тогда если в какой-то позиции i размер сета есть k (после описанных выше изменений), это означает, что L[i] ровно минимальному элементу сета.Так как мы O(N) раз используем бинарный поиск, а функция F(x, len) работает за O(logN), финальная асимптотика решения равна O(Nlog2N).",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/4849",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.6,
            "reason": "宽松匹配: 包含题目编号 204 和字母"
          },
          "content_length": 8301
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #129 - Codeforces - Code 1",
          "code": "He has n cards, each has exactly two colors",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4848",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #129 - Codeforces - Code 2",
          "code": "The color of the front of the card may coincide with the color of the back of the card",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4848",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #129 - Codeforces - Code 3",
          "code": "5\n1 1\n1 1\n3 4\n5 6\n7 8",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4848",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #129 - Codeforces - Code 4",
          "code": "5\n1 1\n1 1\n3 4\n5 6\n7 8",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4848",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #129 - Codeforces - Code 5",
          "code": "3\n1 1\n2 2\n3 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4848",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #129 - Codeforces - Code 6",
          "code": "3\n1 1\n2 2\n3 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4848",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #129 - Codeforces - Code 7",
          "code": "public void solve() throws IOException {\n\t\tlong l = nextLong();\n\t\tlong r = nextLong();\n\t\tout.println(f(r) - f(l - 1));\n\t}\n\t\n\tlong f(long x) {\n\t\tif (x < 10) {\n\t\t\treturn x;\n\t\t}\n\t\tString s = Long.toString(x);\n\t\treturn (x / 10 - 1) + (s.charAt(0) <= s.charAt(s.length() - 1) ? 1 : 0) + 9;\n\t}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4848",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #129 - Codeforces - Code 8",
          "code": "public void solve() throws IOException {\n\t\tlong l = nextLong();\n\t\tlong r = nextLong();\n\t\tout.println(f(r) - f(l - 1));\n\t}\n\t\n\tlong f(long x) {\n\t\tif (x < 10) {\n\t\t\treturn x;\n\t\t}\n\t\tString s = Long.toString(x);\n\t\treturn (x / 10 - 1) + (s.charAt(0) <= s.charAt(s.length() - 1) ? 1 : 0) + 9;\n\t}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4848",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #129 - Codeforces - Code 9",
          "code": "double div=n*(n+1)*(2*n+1);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4848",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #129 - Codeforces - Code 10",
          "code": "double div=n*(n+1)*(2*n+1);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4848",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #129 — Разбор задач - Codeforces - Code 1",
          "code": "void randomShuffle(int[] arr) {\n    Random rnd = new Random();\n    for (int i = arr.length() - 1; i >= 0; i--) {\n        int pos = rnd.nextInt(i + 1);\n        int temp = arr[pos];\n        arr[pos] = arr[i];\n        arr[i] = temp;\n    }\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4849",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #129 — Разбор задач - Codeforces - Code 2",
          "code": "void randomShuffle(int[] arr) {\n    Random rnd = new Random();\n    for (int i = arr.length() - 1; i >= 0; i--) {\n        int pos = rnd.nextInt(i + 1);\n        int temp = arr[pos];\n        arr[pos] = arr[i];\n        arr[i] = temp;\n    }\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4849",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #129 — Разбор задач - Codeforces - Code 3",
          "code": "ll D[10][20][2];\nstring w;\n\nlong long d(int i, int j, int k) {\n    if (D[i][j][k] != -1) return D[i][j][k];\n    if (j == 1) {\n        if (i == 0 and k == 0) return 9;\n        if (i == 0 and k == 1) return w[w.size() - 1] - '0';\n        else if (k == 1) return i <= w[w.size() - 1] - '0';\n        else return 1;\n    }\n    long long cont = 0;\n    for (int e = 0; e < ((k == 0)?10:w[w.size() - j] - '0' + 1); ++e)\n      cont += d((i == 0)?e:i, j-1, (k == 0)?0:e == w[w.size() - j] - '0');\n    return D[i][j][k] = cont;\n}\n\nlong long F(long long x) {\n    memset(D,-1,sizeof(D));\n    stringstream l; l << x;\n    l >> w;\n    return d(0,w.size(),1);    \n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4849",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #129 — Разбор задач - Codeforces - Code 4",
          "code": "ll D[10][20][2];\nstring w;\n\nlong long d(int i, int j, int k) {\n    if (D[i][j][k] != -1) return D[i][j][k];\n    if (j == 1) {\n        if (i == 0 and k == 0) return 9;\n        if (i == 0 and k == 1) return w[w.size() - 1] - '0';\n        else if (k == 1) return i <= w[w.size() - 1] - '0';\n        else return 1;\n    }\n    long long cont = 0;\n    for (int e = 0; e < ((k == 0)?10:w[w.size() - j] - '0' + 1); ++e)\n      cont += d((i == 0)?e:i, j-1, (k == 0)?0:e == w[w.size() - j] - '0');\n    return D[i][j][k] = cont;\n}\n\nlong long F(long long x) {\n    memset(D,-1,sizeof(D));\n    stringstream l; l << x;\n    l >> w;\n    return d(0,w.size(),1);    \n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4849",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #129 — Разбор задач - Codeforces - Code 5",
          "code": "long n = in.nextLong();\n        long min = Long.MAX_VALUE;\n        long idx = -1;\n        Set<Long> set = new HashSet<>();\n        boolean flag = false;\n        for(int i=0;i<n;i++){\n            long val = in.nextLong();\n            if(set.contains(val))\n                flag = true;\n            if(val<min) {\n                min = val;\n                idx = i;\n            }\n            set.add(val);\n        }\n        out.println((flag)?\"Still Rozdil\":idx+1);\n\n        out.close();\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4849",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n    for (int i = 0; i < n; i++) {\n        int front_color = inf.readInt(1, 1000000000, \"front_color\");\n        inf.readSpace();\n        int back_color = inf.readInt(1, 1000000000, \"back_color\");\n        inf.readEoln();\n    }\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n    for (int i = 0; i < n; i++) {\n        int front_color = inf.readInt(1, 1000000000, \"front_color\");\n        inf.readSpace();\n        int back_color = inf.readInt(1, 1000000000, \"back_color\");\n        inf.readEoln();\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n    for (int i = 0; i < n; i++) {\n        int front_color = inf.readInt(1, 1000000000, \"front_color\");\n        inf.readSpace();\n        int back_color = inf.readInt(1, 1000000000, \"back_color\");\n        inf.readEoln();\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<pair<int,int>> cards(n); // First is front color, second is back color\n\n    if (type == \"all_same_front\") {\n        int c = rnd.next(1, int(1e9));\n        for(int i=0; i<n; i++) {\n            int back_color = rnd.next(1, int(1e9));\n            cards[i] = make_pair(c, back_color);\n        }\n    } else if (type == \"all_same_back\") {\n        int c = rnd.next(1, int(1e9));\n        for(int i=0; i<n; i++) {\n            int front_color = rnd.next(1, int(1e9));\n            cards[i] = make_pair(front_color, c);\n        }\n    } else if (type == \"random\") {\n        for(int i=0; i<n; i++) {\n            int front_color = rnd.next(1, int(1e9));\n            int back_color = rnd.next(1, int(1e9));\n            cards[i] = make_pair(front_color, back_color);\n        }\n    } else if (type == \"impossible\") {\n        // Assign unique colors to front and back sides\n        // So every color appears only once\n        set<int> used_colors;\n        for(int i=0; i<n; i++) {\n            int front_color;\n            do {\n                front_color = rnd.next(1, int(1e9));\n            } while (used_colors.count(front_color));\n            used_colors.insert(front_color);\n\n            int back_color;\n            do {\n                back_color = rnd.next(1, int(1e9));\n            } while (used_colors.count(back_color));\n            used_colors.insert(back_color);\n\n            cards[i] = make_pair(front_color, back_color);\n        }\n    } else if (type == \"max_flip\") {\n        // We choose a color c that appears on back of most cards, but on front of a few\n        int c = rnd.next(1, int(1e9));\n        int flips_needed = (n+1)/2; // Number of cards that we need to flip\n        for(int i=0; i<n; i++) {\n            if (i < flips_needed) {\n                // Front color is different\n                int front_color;\n                do {\n                    front_color = rnd.next(1, int(1e9));\n                } while (front_color == c);\n                cards[i] = make_pair(front_color, c);\n            } else {\n                // Front color is c\n                cards[i] = make_pair(c, c);\n            }\n        }\n        shuffle(cards.begin(), cards.end());\n    } else {\n        fprintf(stderr, \"Unknown type: %s\\n\", type.c_str());\n        return 1;\n    }\n\n    // Output\n    printf(\"%d\\n\", n);\n    for(int i=0; i<n; i++) {\n        printf(\"%d %d\\n\", cards[i].first, cards[i].second);\n    }\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<pair<int,int>> cards(n); // First is front color, second is back color\n\n    if (type == \"all_same_front\") {\n        int c = rnd.next(1, int(1e9));\n        for(int i=0; i<n; i++) {\n            int back_color = rnd.next(1, int(1e9));\n            cards[i] = make_pair(c, back_color);\n        }\n    } else if (type == \"all_same_back\") {\n        int c = rnd.next(1, int(1e9));\n        for(int i=0; i<n; i++) {\n            int front_color = rnd.next(1, int(1e9));\n            cards[i] = make_pair(front_color, c);\n        }\n    } else if (type == \"random\") {\n        for(int i=0; i<n; i++) {\n            int front_color = rnd.next(1, int(1e9));\n            int back_color = rnd.next(1, int(1e9));\n            cards[i] = make_pair(front_color, back_color);\n        }\n    } else if (type == \"impossible\") {\n        // Assign unique colors to front and back sides\n        // So every color appears only once\n        set<int> used_colors;\n        for(int i=0; i<n; i++) {\n            int front_color;\n            do {\n                front_color = rnd.next(1, int(1e9));\n            } while (used_colors.count(front_color));\n            used_colors.insert(front_color);\n\n            int back_color;\n            do {\n                back_color = rnd.next(1, int(1e9));\n            } while (used_colors.count(back_color));\n            used_colors.insert(back_color);\n\n            cards[i] = make_pair(front_color, back_color);\n        }\n    } else if (type == \"max_flip\") {\n        // We choose a color c that appears on back of most cards, but on front of a few\n        int c = rnd.next(1, int(1e9));\n        int flips_needed = (n+1)/2; // Number of cards that we need to flip\n        for(int i=0; i<n; i++) {\n            if (i < flips_needed) {\n                // Front color is different\n                int front_color;\n                do {\n                    front_color = rnd.next(1, int(1e9));\n                } while (front_color == c);\n                cards[i] = make_pair(front_color, c);\n            } else {\n                // Front color is c\n                cards[i] = make_pair(c, c);\n            }\n        }\n        shuffle(cards.begin(), cards.end());\n    } else {\n        fprintf(stderr, \"Unknown type: %s\\n\", type.c_str());\n        return 1;\n    }\n\n    // Output\n    printf(\"%d\\n\", n);\n    for(int i=0; i<n; i++) {\n        printf(\"%d %d\\n\", cards[i].first, cards[i].second);\n    }\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -type all_same_front\n./gen -n 2 -type all_same_front\n./gen -n 10 -type all_same_front\n./gen -n 100 -type all_same_front\n./gen -n 1000 -type all_same_front\n./gen -n 100000 -type all_same_front\n\n./gen -n 1 -type all_same_back\n./gen -n 2 -type all_same_back\n./gen -n 10 -type all_same_back\n./gen -n 100 -type all_same_back\n./gen -n 1000 -type all_same_back\n./gen -n 100000 -type all_same_back\n\n./gen -n 1 -type random\n./gen -n 2 -type random\n./gen -n 10 -type random\n./gen -n 100 -type random\n./gen -n 1000 -type random\n./gen -n 100000 -type random\n\n./gen -n 1 -type impossible\n./gen -n 2 -type impossible\n./gen -n 10 -type impossible\n./gen -n 100 -type impossible\n./gen -n 1000 -type impossible\n./gen -n 100000 -type impossible\n\n./gen -n 1 -type max_flip\n./gen -n 2 -type max_flip\n./gen -n 10 -type max_flip\n./gen -n 100 -type max_flip\n./gen -n 1000 -type max_flip\n./gen -n 100000 -type max_flip\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T19:48:35.373513",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "204/C",
      "title": "C. Маленький Слоник и Фурик и Рубик",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест2 секунды",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеВ первой строке задано единственное целое число n (1 ≤ n ≤ 2·105) — длина строк a и b. Во второй строке задана строка a, в третьей — строка b. Строки состоят только из прописных букв латинского алфавита. Длина обеих строк равна n.",
      "output_spec": "Выходные данныеВ единственной строке выведите вещественное число — ответ на задачу. Ответ будет считаться правильным, если его относительная или абсолютная погрешность не будет превышать 10 - 6.",
      "sample_tests": "ПримерыВходные данныеСкопировать2ABBAВыходные данныеСкопировать0.400000000Входные данныеСкопировать3AABCAAВыходные данныеСкопировать0.642857143",
      "description": "C. Маленький Слоник и Фурик и Рубик\n\nограничение по времени на тест2 секунды\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвыводstdout\n\nВходные данныеВ первой строке задано единственное целое число n (1 ≤ n ≤ 2·105) — длина строк a и b. Во второй строке задана строка a, в третьей — строка b. Строки состоят только из прописных букв латинского алфавита. Длина обеих строк равна n.\n\nВходные данные\n\nВыходные данныеВ единственной строке выведите вещественное число — ответ на задачу. Ответ будет считаться правильным, если его относительная или абсолютная погрешность не будет превышать 10 - 6.\n\nВыходные данные\n\nВходные данныеСкопировать2ABBAВыходные данныеСкопировать0.400000000Входные данныеСкопировать3AABCAAВыходные данныеСкопировать0.642857143\n\nВходные данныеСкопировать2ABBA\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать0.400000000\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать3AABCAA\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать0.642857143\n\nВыходные данныеСкопировать\n\nСкопировать\n\nПримечаниеПусть задана строка a = a1a2... a|a|, тогда обозначим через |a| длину строки, а через ai — i-й символ строки.Подстрокой a[l... r] (1 ≤ l ≤ r ≤ |a|) строки a называется строка alal + 1... ar.Строка a является подстрокой строки b, если существует такая пара целых чисел l и r (1 ≤ l ≤ r ≤ |b|), что b[l... r] = a.Рассмотрим первый тестовый пример. В первом примере есть 5 возможных пар подстрок: («A», «B»), («A», «A»), («B», «B»), («B», «A»), («AB», «BA»). Для второй и третьей пары знечение f(x, y) равно 1, для остальных — 0. Вероятность выбора каждой пары равна , поэтому ответ равен  · 0  +   · 1  +   · 1  +   · 0  +   · 0  =    =  0.4.",
      "solutions": [
        {
          "title": "Codeforces Round #129 - Codeforces",
          "content": "Привет!Вот и пришло время очередного раунда Codeforces, а именно раунда номер 129. Он состоится 11.07.2012 в 19:30 (по Москве). В этот раз задачи для Вас готовил я. В далеком прошлом я уже был 4 раза автором задач для Codeforces, тогда задачи были в основном о счастливых числах. Но ничего не вечно, поэтому в этот раз не будет задач о счастливых числах и тематика задач будет различной.Помогал мне готовить задачи Геральд Агапов (Gerald), Александр Куприн (Alex_KPR), Аксёнов Виталик (Aksenov239), а традиционно задачи перевела Мария Белова (Delinur), за что им всем спасибо.Надеюсь задачи вам понравятся и все пройдет гладко и я преждевременно не опубликую разбор, который сейчас у меня в блоге.Держитесь!Спасибо всем за участие. Результаты оказались следующими:Div1: tourist (теперь tourist первый в мире таргет Codeforces, с чем его поздравляем) winger RAVEman rng_58 RAD bmerry Shik Div2: xiaoshua2 ahm.kam_92 HanzhongBall_Quanling daidailanlan Разбор задач можно найти здесь.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/4848",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 981
        },
        {
          "title": "Codeforces Round #129 — Разбор задач - Codeforces",
          "content": "205A - Маленький Слоник и РоздолЭто была самая простая задача из набора. Нужно просто отсортировать все расстояния (при этом поддерживая индексы) и, если первые два расстояния равны, вывести \"Still Rozdil\", иначе вывести индекс первого элемента.Сложность решения O(NlogN).205B - Маленький Слоник и сортировкаВ этой задачи нужно заметить тот факт (который несложно доказать, но он понятен даже интуитивно), что, так как массив нужно сделать неубывающим, если делать какую-то операцию, то r (правая граница) должна быть равна n. Действительно, подняв правую часть массива мы точно не ухудшим результат. После этого нужно идти слева направо и жадно делать необходимое количество операций на каждом шагу.Сложность решения O(N).205C - Маленький Слоник и промежутокЕстественно, для того что-бы решить задачу нужно написать функцию F(x) которая будет решать задачу на промежутке 0..x, тогда ответом будет F(r) - F(l - 1). Опишем реализацию функции F(x). Если x < 10, результатом будем сам x. Пусть len — длина числа x, а x' — число x без первой и последней цифр, а xi — i-я цифра числа x (от 0 слева направо). Переберем первую цифру d (она и будет последней) и длину того что внутри (пусть это будет i). Тогда если i < len - 2 или (i = len - 2 и d < x0), к ответу нужно добавить 10i. Иначе, если i = len - 2 и d = x0 то к ответу нужно добавить x', а если еще и i = len - 2, d = x0 и xlen - 1 ≥ d то нужно добавить еще 1 к ответу. Также эту задачу можно было решить используя ДП.205D - Маленький Слоник и карточкиЭту задачу можно удобно решить используя структуру map, но можно и обойтись без нее (используя сортировку и бинарный поиск). Давайте переберем цвет-кандидат который и приведет к веселости набора, для каждого цвета узнаем минимальное количество переворачиваний (если возможно вообще) и выберем минимум. Если никакой цвет не подходит, ответ \"-1\". Для того чтобы найти минимальное количество переворачиваний нам нужно узнать два числа — количество карточек которые изначально лежат текущим цветом вверх, а также количество карточек у которых сзади есть текущий цвет (при этом сверху какой-то другой). Пусть это числа a и b. соответственно. Пусть m = (n + 1) / 2 — минимальное количество одинаковых карточек необходимых для того, что-бы сделать набор веселым. Тогда текущий цвет может сделать набор веселым только если a + b ≥ m. Если a ≥ m, то ничего переворачивать не надо, то есть ответ 0, иначе ответ равен m - a.205E - Маленький Слоник и Фурик и РубикЗадача на математическое ожидание. Здесь важно учесть факт линейности математического ожидания, иными словами, ответ для какой-то пары строк это сумма количеств совпадений по каждому символам алфавита. Поэтому давайте для каждого символа первой строки найдем вероятность того, что он войдет в ответ. Тогда общим ответом будет сумма этих вероятностей.Пусть у нас текущий символ в первой строки с номером i (всюду 1-нумерация). Сначала решим задачу за O(N2). Переберем все позиции j левее i (или равные i) такие что Bj = Ai. Тогда для какой-то позиции нужно найти количество возможных пар строк таких, что в них именно эти два символы Ai и Bj совпали. Это количество будет равно j(n - i + 1) (j возможных символов слева и (n - i + 1) справа, поэтому общее количество это их произведение). Это будет O(N2). Так как все это — сумма, то ответ будет равен Si(n - i + 1), где Si — сумма всех позиций j таких, что Bj = Ai. Массив S можно несложно посчитать за линейное время. Аналогичным образом нужно обработать все индексы что правее i. После того как количество пар подстрок в которых i-й символ первой строки имеет совпадение найдено (пусть это count), к ответу нужно добавить count / total, где total — полное количество возможных исходов, его можно найти циклом или несложной формулой.Сложность решения O(N).204D - Маленький Слоник и ретро строкиДля начала нам нужно решить следующую подзадачу: для каждого префикса найти количество его заполнений таких, что он не содержит подстроки длиной k состоящую только из букв B. Пусть это будет F(x), где x это номер последнего символа префикса. Давайте присвоим F(x) = F(x - 1) * cnt, где cnt = 2, если Sx = 'X', 1 иначе. После такого присвоения в результат могли быть включены некоторые способы такие, что блок из k есть в конце префикса (они могли быть включены только если в подстроке Sx - k + 1..x нет букв W, а символ Sx - k не есть B), а это плохо. Поэтому (если такое могло произойти) нужно от F(x) отнять F(x - k - 1), это уберет все плохие варианты.Аналогичное ДП нужно посчитать для для суффиксов (или, иначе говоря, для реверсовной строки S), только здесь нужно избегать блоков из W.Теперь подумаем как организовать все что-бы не появилось повторов. Давайте переберем позицию, в которой будет заканчиваться первый слева блок из k подряд идущих букв B. При этом будем перебирать эту позицию справа налево. Используя ранее подсчитано ДП мы можем найти количество вариантов заполнить все буквы левее так, что-бы там не образовался блок. Если писать решение за O(N2), то мы можем перебрать позицию, в которой будет начинаться первый справа блок из k букв W, аналогичным образом найти количество способов заполнить все правее что-бы там не образовался блок, а символы между левым и правым блоками мы, очевидно, можем заполнять как-угодно. Но, так как мы идем справа налево, мы можем по ходу поддерживать сумму этих количеств. Это обеспечит нам линейность решения. 204E - Маленький Слоник и строкиДля решения данной задачи воспользуемся свойствами суффиксного массива. Болле подробно о суффиксном массиве можно почитать здесь:http://e-maxx.ru/algo/suffix_arrayДля начала нужно конкатенировать все строки в одну, при этом разделяя их какими-то символами которые не встречаются в строках. Например, три строки abc, a, ab можно склеить в одну следующего вида: abc#a@ab. Теперь нам нужно построить суффиксный массив по новой строке, это позволит нам отсортировать все циклические сдвиги строки. При этом первый символ каждого циклического сдвига это либо вспомогательный символ, либо символ какой-то входной строки. Заметим теперь что для того что-бы найти результат нам нужно для каждого циклического сдвига, начало которого принадлежит какой-то входной строке, найти максимальную длину его префикса такую, что этот префикс является подстрокой как минимум k входных строк. Это число можно искать бинарным поиском, но для этого нужно какую-то функцию которая бы отвечала на вопрос: а сколько есть различных входных строк которые содержат префикс длины len циклического сдвига номер x (Пусть это функция F(x, len)).Как же сделать функцию F(x, len)? Рассмотрим все циклические сдвиги, префикс длины len которых ровен префиксу длины len x-го сдвига. Заметим что, так как все сдвиги отсортированы лексикографически, набор таких сдвигов будет представлен каким-то промежутком [l;r] (1 ≤ l ≤ x ≤ r). Как же найти этот промежуток? Для каждой пары соседних сдвигов можно найти их наибольший общий префикс. Тогда l, например, можно найти используя RMQ — для этого нужно найти самую правую пару соседних сдвигов (левее x) таких, что их наибольший общий префикс меньше len. Аналогично можно найти r. После этого у нас есть промежуток [l;r] и нужно найти количество различных строк которые соответствуют этим сдвигам (иными словами, найти количество различных чисел в подмассиве). Но, заметим, что самое количество различных нас не интересует, а интересует только не меньше ли оно за k или нет. Тогда пусть L[i] равно максимальному j (j ≤ i) такому, что количество различных чисел в помассиве [j;i] ровно k. Тогда если L[r] ≥ l то, логично, что и в промежутке [l;r] также будет не меньше k различных чисел.Осталось заполнить массив L. Это довольно просто сделать используя структуру set (можно также использовать RMQ). Будем идти слева направо и в сете поддерживать индексы самых правых k различных чисел. Тогда если поступает какое-то число, то (если оно встречалось раньше) его прежнее вхождение нужно удалить из сета (если оно еще осталось) и вставить текущее. При этом если размер сета превышает k нужно извлекать минимальный элемент. Тогда если в какой-то позиции i размер сета есть k (после описанных выше изменений), это означает, что L[i] ровно минимальному элементу сета.Так как мы O(N) раз используем бинарный поиск, а функция F(x, len) работает за O(logN), финальная асимптотика решения равна O(Nlog2N).",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/4849",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.6,
            "reason": "宽松匹配: 包含题目编号 204 和字母"
          },
          "content_length": 8301
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #129 - Codeforces - Code 1",
          "code": "He has n cards, each has exactly two colors",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4848",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #129 - Codeforces - Code 2",
          "code": "The color of the front of the card may coincide with the color of the back of the card",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4848",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #129 - Codeforces - Code 3",
          "code": "5\n1 1\n1 1\n3 4\n5 6\n7 8",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4848",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #129 - Codeforces - Code 4",
          "code": "5\n1 1\n1 1\n3 4\n5 6\n7 8",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4848",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #129 - Codeforces - Code 5",
          "code": "3\n1 1\n2 2\n3 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4848",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #129 - Codeforces - Code 6",
          "code": "3\n1 1\n2 2\n3 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4848",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #129 - Codeforces - Code 7",
          "code": "public void solve() throws IOException {\n\t\tlong l = nextLong();\n\t\tlong r = nextLong();\n\t\tout.println(f(r) - f(l - 1));\n\t}\n\t\n\tlong f(long x) {\n\t\tif (x < 10) {\n\t\t\treturn x;\n\t\t}\n\t\tString s = Long.toString(x);\n\t\treturn (x / 10 - 1) + (s.charAt(0) <= s.charAt(s.length() - 1) ? 1 : 0) + 9;\n\t}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4848",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #129 - Codeforces - Code 8",
          "code": "public void solve() throws IOException {\n\t\tlong l = nextLong();\n\t\tlong r = nextLong();\n\t\tout.println(f(r) - f(l - 1));\n\t}\n\t\n\tlong f(long x) {\n\t\tif (x < 10) {\n\t\t\treturn x;\n\t\t}\n\t\tString s = Long.toString(x);\n\t\treturn (x / 10 - 1) + (s.charAt(0) <= s.charAt(s.length() - 1) ? 1 : 0) + 9;\n\t}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4848",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #129 - Codeforces - Code 9",
          "code": "double div=n*(n+1)*(2*n+1);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4848",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #129 - Codeforces - Code 10",
          "code": "double div=n*(n+1)*(2*n+1);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4848",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #129 — Разбор задач - Codeforces - Code 1",
          "code": "void randomShuffle(int[] arr) {\n    Random rnd = new Random();\n    for (int i = arr.length() - 1; i >= 0; i--) {\n        int pos = rnd.nextInt(i + 1);\n        int temp = arr[pos];\n        arr[pos] = arr[i];\n        arr[i] = temp;\n    }\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4849",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #129 — Разбор задач - Codeforces - Code 2",
          "code": "void randomShuffle(int[] arr) {\n    Random rnd = new Random();\n    for (int i = arr.length() - 1; i >= 0; i--) {\n        int pos = rnd.nextInt(i + 1);\n        int temp = arr[pos];\n        arr[pos] = arr[i];\n        arr[i] = temp;\n    }\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4849",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #129 — Разбор задач - Codeforces - Code 3",
          "code": "ll D[10][20][2];\nstring w;\n\nlong long d(int i, int j, int k) {\n    if (D[i][j][k] != -1) return D[i][j][k];\n    if (j == 1) {\n        if (i == 0 and k == 0) return 9;\n        if (i == 0 and k == 1) return w[w.size() - 1] - '0';\n        else if (k == 1) return i <= w[w.size() - 1] - '0';\n        else return 1;\n    }\n    long long cont = 0;\n    for (int e = 0; e < ((k == 0)?10:w[w.size() - j] - '0' + 1); ++e)\n      cont += d((i == 0)?e:i, j-1, (k == 0)?0:e == w[w.size() - j] - '0');\n    return D[i][j][k] = cont;\n}\n\nlong long F(long long x) {\n    memset(D,-1,sizeof(D));\n    stringstream l; l << x;\n    l >> w;\n    return d(0,w.size(),1);    \n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4849",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #129 — Разбор задач - Codeforces - Code 4",
          "code": "ll D[10][20][2];\nstring w;\n\nlong long d(int i, int j, int k) {\n    if (D[i][j][k] != -1) return D[i][j][k];\n    if (j == 1) {\n        if (i == 0 and k == 0) return 9;\n        if (i == 0 and k == 1) return w[w.size() - 1] - '0';\n        else if (k == 1) return i <= w[w.size() - 1] - '0';\n        else return 1;\n    }\n    long long cont = 0;\n    for (int e = 0; e < ((k == 0)?10:w[w.size() - j] - '0' + 1); ++e)\n      cont += d((i == 0)?e:i, j-1, (k == 0)?0:e == w[w.size() - j] - '0');\n    return D[i][j][k] = cont;\n}\n\nlong long F(long long x) {\n    memset(D,-1,sizeof(D));\n    stringstream l; l << x;\n    l >> w;\n    return d(0,w.size(),1);    \n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4849",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #129 — Разбор задач - Codeforces - Code 5",
          "code": "long n = in.nextLong();\n        long min = Long.MAX_VALUE;\n        long idx = -1;\n        Set<Long> set = new HashSet<>();\n        boolean flag = false;\n        for(int i=0;i<n;i++){\n            long val = in.nextLong();\n            if(set.contains(val))\n                flag = true;\n            if(val<min) {\n                min = val;\n                idx = i;\n            }\n            set.add(val);\n        }\n        out.println((flag)?\"Still Rozdil\":idx+1);\n\n        out.close();\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4849",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 200000, \"n\");\n    inf.readEoln();\n\n    string a = inf.readLine();\n    ensuref((int)a.length() == n, \"Length of a is %d, expected %d\", (int)a.length(), n);\n    for (char c : a) {\n        ensuref('A' <= c && c <= 'Z', \"String a should only contain uppercase letters\");\n    }\n\n    string b = inf.readLine();\n    ensuref((int)b.length() == n, \"Length of b is %d, expected %d\", (int)b.length(), n);\n    for (char c : b) {\n        ensuref('A' <= c && c <= 'Z', \"String b should only contain uppercase letters\");\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 200000, \"n\");\n    inf.readEoln();\n\n    string a = inf.readLine();\n    ensuref((int)a.length() == n, \"Length of a is %d, expected %d\", (int)a.length(), n);\n    for (char c : a) {\n        ensuref('A' <= c && c <= 'Z', \"String a should only contain uppercase letters\");\n    }\n\n    string b = inf.readLine();\n    ensuref((int)b.length() == n, \"Length of b is %d, expected %d\", (int)b.length(), n);\n    for (char c : b) {\n        ensuref('A' <= c && c <= 'Z', \"String b should only contain uppercase letters\");\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 200000, \"n\");\n    inf.readEoln();\n\n    string a = inf.readLine();\n    ensuref((int)a.length() == n, \"Length of a is %d, expected %d\", (int)a.length(), n);\n    for (char c : a) {\n        ensuref('A' <= c && c <= 'Z', \"String a should only contain uppercase letters\");\n    }\n\n    string b = inf.readLine();\n    ensuref((int)b.length() == n, \"Length of b is %d, expected %d\", (int)b.length(), n);\n    for (char c : b) {\n        ensuref('A' <= c && c <= 'Z', \"String b should only contain uppercase letters\");\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nconst double EPS = 1E-6;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare two sequences of doubles, max absolute or relative  error = %.7f\", EPS);\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    double j = 0, p = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        n++;\r\n        j = ans.readDouble();\r\n        p = ouf.readDouble();\r\n        if (!doubleCompare(j, p, EPS)) {\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%.7f', found: '%.7f', error = '%.7f'\",\r\n                  n, englishEnding(n).c_str(), j, p, doubleDelta(j, p));\r\n        }\r\n    }\r\n\r\n    if (n == 1)\r\n        quitf(_ok, \"found '%.7f', expected '%.7f', error '%.7f'\", p, j, doubleDelta(j, p));\r\n\r\n    quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    string a(n, 'A'), b(n, 'A');\n\n    if (type == \"random\") {\n        // Generate random strings a and b\n        for (int i = 0; i < n; ++i) {\n            a[i] = (char)('A' + rnd.next(26));\n            b[i] = (char)('A' + rnd.next(26));\n        }\n    } else if (type == \"same\") {\n        // Generate a random string a, set b = a\n        for (int i = 0; i < n; ++i) {\n            a[i] = (char)('A' + rnd.next(26));\n        }\n        b = a;\n    } else if (type == \"reverse\") {\n        // Generate a random string a, set b = reverse of a\n        for (int i = 0; i < n; ++i) {\n            a[i] = (char)('A' + rnd.next(26));\n        }\n        b = a;\n        reverse(b.begin(), b.end());\n    } else if (type == \"same_letter\") {\n        // Pick a random uppercase letter, make strings a and b both be that letter\n        char c = 'A' + rnd.next(26);\n        a = string(n, c);\n        b = string(n, c);\n    } else if (type == \"alternate\") {\n        // Choose two different letters, make alternating strings\n        char c1 = 'A' + rnd.next(26);\n        char c2;\n        do {\n            c2 = 'A' + rnd.next(26);\n        } while (c1 == c2);\n        for (int i = 0; i < n; ++i) {\n            a[i] = (i % 2 == 0) ? c1 : c2;\n            b[i] = (i % 2 == 0) ? c2 : c1; // Alternate differently to create mismatches\n        }\n    } else if (type == \"max_characters\") {\n        // Use only 'A' and 'Z' in the strings\n        string letters = \"AZ\";\n        for (int i = 0; i < n; ++i) {\n            a[i] = letters[rnd.next(2)];\n            b[i] = letters[rnd.next(2)];\n        }\n    } else if (type == \"mismatch\") {\n        // Generate strings a and b such that at no position is a[i] == b[i]\n        for (int i = 0; i < n; ++i) {\n            a[i] = 'A' + rnd.next(26);\n            int offset = rnd.next(1, 25);\n            b[i] = 'A' + (a[i] - 'A' + offset) % 26;\n        }\n    } else {\n        // Default to random\n        for (int i = 0; i < n; ++i) {\n            a[i] = (char)('A' + rnd.next(26));\n            b[i] = (char)('A' + rnd.next(26));\n        }\n    }\n\n    // Output n\n    cout << n << '\\n';\n    // Output string a\n    cout << a << '\\n';\n    // Output string b\n    cout << b << '\\n';\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    string a(n, 'A'), b(n, 'A');\n\n    if (type == \"random\") {\n        // Generate random strings a and b\n        for (int i = 0; i < n; ++i) {\n            a[i] = (char)('A' + rnd.next(26));\n            b[i] = (char)('A' + rnd.next(26));\n        }\n    } else if (type == \"same\") {\n        // Generate a random string a, set b = a\n        for (int i = 0; i < n; ++i) {\n            a[i] = (char)('A' + rnd.next(26));\n        }\n        b = a;\n    } else if (type == \"reverse\") {\n        // Generate a random string a, set b = reverse of a\n        for (int i = 0; i < n; ++i) {\n            a[i] = (char)('A' + rnd.next(26));\n        }\n        b = a;\n        reverse(b.begin(), b.end());\n    } else if (type == \"same_letter\") {\n        // Pick a random uppercase letter, make strings a and b both be that letter\n        char c = 'A' + rnd.next(26);\n        a = string(n, c);\n        b = string(n, c);\n    } else if (type == \"alternate\") {\n        // Choose two different letters, make alternating strings\n        char c1 = 'A' + rnd.next(26);\n        char c2;\n        do {\n            c2 = 'A' + rnd.next(26);\n        } while (c1 == c2);\n        for (int i = 0; i < n; ++i) {\n            a[i] = (i % 2 == 0) ? c1 : c2;\n            b[i] = (i % 2 == 0) ? c2 : c1; // Alternate differently to create mismatches\n        }\n    } else if (type == \"max_characters\") {\n        // Use only 'A' and 'Z' in the strings\n        string letters = \"AZ\";\n        for (int i = 0; i < n; ++i) {\n            a[i] = letters[rnd.next(2)];\n            b[i] = letters[rnd.next(2)];\n        }\n    } else if (type == \"mismatch\") {\n        // Generate strings a and b such that at no position is a[i] == b[i]\n        for (int i = 0; i < n; ++i) {\n            a[i] = 'A' + rnd.next(26);\n            int offset = rnd.next(1, 25);\n            b[i] = 'A' + (a[i] - 'A' + offset) % 26;\n        }\n    } else {\n        // Default to random\n        for (int i = 0; i < n; ++i) {\n            a[i] = (char)('A' + rnd.next(26));\n            b[i] = (char)('A' + rnd.next(26));\n        }\n    }\n\n    // Output n\n    cout << n << '\\n';\n    // Output string a\n    cout << a << '\\n';\n    // Output string b\n    cout << b << '\\n';\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -type same_letter\n./gen -n 1 -type mismatch\n./gen -n 1 -type random\n./gen -n 2 -type same\n./gen -n 2 -type reverse\n./gen -n 2 -type alternate\n./gen -n 5 -type same_letter\n./gen -n 5 -type mismatch\n./gen -n 5 -type random\n./gen -n 10 -type same\n./gen -n 10 -type reverse\n./gen -n 10 -type max_characters\n./gen -n 100 -type random\n./gen -n 100 -type alternate\n./gen -n 100 -type mismatch\n./gen -n 1000 -type same\n./gen -n 1000 -type reverse\n./gen -n 1000 -type same_letter\n./gen -n 10000 -type random\n./gen -n 10000 -type max_characters\n./gen -n 10000 -type alternate\n./gen -n 100000 -type mismatch\n./gen -n 100000 -type same\n./gen -n 100000 -type reverse\n./gen -n 200000 -type random\n./gen -n 200000 -type same_letter\n./gen -n 200000 -type mismatch\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T19:48:37.454313",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "204/D",
      "title": "D. Little Elephant and Retro Strings",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains two space-separated integers n and k (1 ≤ k ≤ n ≤ 106). The second line contains string s. String s has length n and only consists of characters \"W\", \"B\" and \"X\".",
      "output_spec": "OutputOn a single line print an integer — the answer to the problem modulo 1000000007 (109 + 7).",
      "sample_tests": "ExamplesInputCopy3 2XXXOutputCopy0InputCopy4 2XXXXOutputCopy1InputCopy10 2XXBXXWXXXXOutputCopy166",
      "description": "D. Little Elephant and Retro Strings\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains two space-separated integers n and k (1 ≤ k ≤ n ≤ 106). The second line contains string s. String s has length n and only consists of characters \"W\", \"B\" and \"X\".\n\nOutputOn a single line print an integer — the answer to the problem modulo 1000000007 (109 + 7).\n\nInputCopy3 2XXXOutputCopy0InputCopy4 2XXXXOutputCopy1InputCopy10 2XXBXXWXXXXOutputCopy166\n\nInputCopy3 2XXX\n\nOutputCopy0\n\nInputCopy4 2XXXX\n\nOutputCopy1\n\nInputCopy10 2XXBXXWXXXX\n\nOutputCopy166",
      "solutions": [
        {
          "title": "Codeforces Round #129 - Codeforces",
          "content": "Hi!Time brings to you next Codeforces round, this time it is with number 129. It will take place in 11.07.2012 at 19:30 (Moscow time). This time the problems are authored by me, Vitaliy Herasymiv. Long time ago I was the author of 4 Codeforces rounds, they were about lucky numbers. But, unfortunately, nothing is constant, so this time there will be no problems about lucky numbers.A lot of help in preparing of the problems was from Gerald Agapov (Gerald), Alexander Kouprin (Alex_KPR), Vitaly Aksenov (Aksenov239), The problems were translated to English by Maria Belova (Delinur). Thanks to all of them.I hope you will like this all.Good Luck!Div1:Thanks all! The results are the following: tourist (now tourist become first Codeforces target, congratulations to him) winger RAVEman rng_58 RAD bmerry Shik Div2: xiaoshua2 ahm.kam_92 HanzhongBall_Quanling daidailanlan You can read editorials here.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/4848",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 901
        },
        {
          "title": "Codeforces Round #129 — Editorial - Codeforces",
          "content": "205A - Little Elephant and RozdilThis problem was the simplest in the problemset. All you need to do is just to sort all distances (keeping track on all indices). If the first two distances are equal, just output \"Still Rozdil\", otherwise output the index of the first element of the array.The complexity is O(NlogN).205B - Little Elephant and SortingIn this problem you need to notice the fact (which can be proven, but it is almost obvious) that if you are doing some operation for interval from l to r (inclusive), r must be equal to n. This is becuase when you add something to all right part the answer can't be worse. After that you need to go from left to right and greedly add appropriate number of turns.The complexity is O(N).205C - Little Elephant and IntervalIt is well-known that for such problem you need to write function F(x) which solves the problem for the interval 0..x, and the answer then is F(r) - F(l - 1).Now you need to write F(x) function. If x < 10, then answer is, of course, equal to x. Otherwise, let len be the length of x, x' — the integer x but without first and last digits, xi — the i-th digit of integer x (from left to right, starting from 0). Interate through all possible first digit d (which is the last at the same time) and through the length i of the number. Then if i < len - 2 or (i = len - 2 and d < x0) you need to add 10i to the answer. Otherwise, if i = len - 2 and d = x0 you need to add x' to the answer. Finally, if i = len - 2 and d = x0 and xlen - 1 ≥ d add 1 to the answer.This problems also can be solved using DP.205D - Little Elephant and CardsIt is nice to use the map structure in this problem, but you can solve it without map (using sorting and binary serach). Lets iterate through all possible colors that we have and suppose that this currect color is the one that will make our set funny. The minimal number through all this will be the answer. To find the minimal number of turns to make our set funny using current color we need to know two numbers: the number of cards with current color on the front side and the number of cards with the current color on back side (but not at the same time). Let it be integers a and b. Let m = (n + 1) / 2 — the minimal number of the same cards required to get the funny set. Then if a + b < m it is impossible to make set funny using current color at all. If a ≥ m then the answer is 0, otherwise the answer is m - a.205E - Little Elephant and Furik and RubikThis problem is to find the expected value. Important fact here is the linearity of the expected value. This means that we can for each element of the first strings find the probability that exactly this element will me matched with some other (but, of course, equal) from the second string. The answer will be the sum of all such probabilities.Let the current character of the first string be the i-th character (1-based numeration). Firstly we try to solve problem in O(N2) time. Namely, as it was said above, we need to find the number of such pairs of substrings that i-th character (which is on probably some other position in substring) is the same as the corresponding character of the second substring. Iterate through all j (j ≤ i) such that Ai = Bj. The number of such pairs of substrings that have match in that characters is j(n - i + 1) (considering 1-based numeration). This is O(N2). And because we need to find the sum of such values for all possible j, we can rewrite it as Si(n - i + 1), where Si equals to the sum of all integers j (j ≤ i) that Ai = Bi. Array S can be simply computed in a linear time. Analogically you should process all indices to the right from i.After we know the number of pairs of substrings with the match with the i-th character (let it be count), the probability is count / total, where total is the total number of pair of substrings (it can be found by loop or with some simple formula).The comlexity is O(N).204D - Little Elephant and Retro StringsFirstly we should solve following subproblem: for each prefix find the number of it's fillings such that there is no consecutive block of k characters B. Let it be F(x), where x is the index in of the last character if the prefix. Assing F(x) = F(x - 1) * cnt, where cnt = 2 if Sx = 'X' and 1 otherwise. After such assing there may be some bad filling included to F(x). Since we suppouse that F(x - 1) is caclulated correctly, all bad filling must contain blocks of k charcters B only at the end of the prefix (they may be included only if substring Sx - k + 1..x doesn't contain characters W and character Sx - k is not B). So, if it's possible, we must subtract from F(x) value F(x - k - 1), because it's exactly the number of bad fillings.With the same DP you should you calc the same values for suffixes (but this time changing B by W and vice versa). Now we should carefully calculate the result in such way that now repeatings occur. Let iterate (from right to left) through all possible positions of the first blocks of k characters B (this means that we suppose that no block occur to the left). Using our DP we can simply find the number of fillings of all characters to the left from that block in such way that no another blocks of k characters B occur. Considering O(N2) solutions, we can iterate through all possible indexes of the begging of the last block of k characters W (again we suppose that this blocks must be the last and no another may occur to the right) and agin using our DP count the number of fillings to the right. We don't care what is between that blocks, so we just multiply answer by 2^(the number of characters X between blocks). But, since we are going from right to the left, we can just keep tracking on all possible last blocks and get O(N) solution.204E - Little Elephant and StringsTo solve this problems we can use suffix array. More information about suffix arrays you can find in the Internet.Firstly, concatenate all strings into the one separating consecutive strings by some unique characters (it was also useful to not use strings, but arrays of integers). For example, three strings abc, a, ab may be concatenated in the following way: abc#a@ab. Now we should build suffix array using this total string, this allows to us to sort all cyclic shifts of the string. After that each cyclic shift will either begin with additional character or the character from the input strings.Notice now that to find the result we need to find for each cyclic shift (begging of which doesn't contain additional character) the largest size of it's prefix such that this prefix is substring of at least k different input strings. This value can be found by binary search, but for this we need some function F(x, len) which can answer the questions: how many input strings contain prefix of size len of x cyclic shift as a substring.How to make F(x, len)? Look at all cyclic shifts, prefix of size len of which is equal to preifx of size len of x-th shift. Since all shifts are sorted lexicoraphically, this set of shifts can be represented as integral [l;r] of indices of shifts (1 ≤ l ≤ x ≤ r). How to find l and r? For each pair of consecutive shifts we can find it's greatest common prefix (using properties of suffix array). Than l and r can be found using RMQ. For l we need to know the rigthmost pair of shift (but to the left from x) that their greatest common prefix is less than len. Analogically we can find r. After that we have interval [l;r] and we need to find the number of different input strings that belongs to the shifts from l-th to r-th (actually, we need to find the number of different integer on interval). But, notice that we dont need the exactly number of different integers, we need to know just it is at least k or not. So let L[i] equals to the greatest j (j ≤ i) such that the number of different integers on interval [j;i] is equal to k. Then if L[r] ≥ l, obiously, interval [l;r] will also contains at least k different. So F(x, len) is done.The only thing to done is to fill array L. This is pretty simple using set (but it is possible without it but using RMQ). We will go from left to righ at keep the indices of the last (the rightmost) k different integers in the set. If some integer comes, then (if it was earlier) we need to erase this previous index from set (if it was still in) and insert new current. While the size of set is greater than k, we should erase the minimal number from it. Then if in some position i the size of the set (after above changings) is equal to k, than L[i] is equal to the minimal number in set.Since we O(N) times use binary search, and function F(x, len) works in O(logN) time, the total complexity is O(Nlog2N).",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/4849",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 204\\s*D"
          },
          "content_length": 8674
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #129 - Codeforces - Code 1",
          "code": "He has n cards, each has exactly two colors",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4848",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #129 - Codeforces - Code 2",
          "code": "The color of the front of the card may coincide with the color of the back of the card",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4848",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #129 - Codeforces - Code 3",
          "code": "public void solve() throws IOException {\n\t\tlong l = nextLong();\n\t\tlong r = nextLong();\n\t\tout.println(f(r) - f(l - 1));\n\t}\n\t\n\tlong f(long x) {\n\t\tif (x < 10) {\n\t\t\treturn x;\n\t\t}\n\t\tString s = Long.toString(x);\n\t\treturn (x / 10 - 1) + (s.charAt(0) <= s.charAt(s.length() - 1) ? 1 : 0) + 9;\n\t}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4848",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #129 - Codeforces - Code 4",
          "code": "public void solve() throws IOException {\n\t\tlong l = nextLong();\n\t\tlong r = nextLong();\n\t\tout.println(f(r) - f(l - 1));\n\t}\n\t\n\tlong f(long x) {\n\t\tif (x < 10) {\n\t\t\treturn x;\n\t\t}\n\t\tString s = Long.toString(x);\n\t\treturn (x / 10 - 1) + (s.charAt(0) <= s.charAt(s.length() - 1) ? 1 : 0) + 9;\n\t}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4848",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #129 - Codeforces - Code 5",
          "code": "double div=n*(n+1)*(2*n+1);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4848",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #129 - Codeforces - Code 6",
          "code": "double div=n*(n+1)*(2*n+1);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4848",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #129 — Editorial - Codeforces - Code 1",
          "code": "ll D[10][20][2];\nstring w;\n\nlong long d(int i, int j, int k) {\n    if (D[i][j][k] != -1) return D[i][j][k];\n    if (j == 1) {\n        if (i == 0 and k == 0) return 9;\n        if (i == 0 and k == 1) return w[w.size() - 1] - '0';\n        else if (k == 1) return i <= w[w.size() - 1] - '0';\n        else return 1;\n    }\n    long long cont = 0;\n    for (int e = 0; e < ((k == 0)?10:w[w.size() - j] - '0' + 1); ++e)\n      cont += d((i == 0)?e:i, j-1, (k == 0)?0:e == w[w.size() - j] - '0');\n    return D[i][j][k] = cont;\n}\n\nlong long F(long long x) {\n    memset(D,-1,sizeof(D));\n    stringstream l; l << x;\n    l >> w;\n    return d(0,w.size(),1);    \n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4849",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #129 — Editorial - Codeforces - Code 2",
          "code": "ll D[10][20][2];\nstring w;\n\nlong long d(int i, int j, int k) {\n    if (D[i][j][k] != -1) return D[i][j][k];\n    if (j == 1) {\n        if (i == 0 and k == 0) return 9;\n        if (i == 0 and k == 1) return w[w.size() - 1] - '0';\n        else if (k == 1) return i <= w[w.size() - 1] - '0';\n        else return 1;\n    }\n    long long cont = 0;\n    for (int e = 0; e < ((k == 0)?10:w[w.size() - j] - '0' + 1); ++e)\n      cont += d((i == 0)?e:i, j-1, (k == 0)?0:e == w[w.size() - j] - '0');\n    return D[i][j][k] = cont;\n}\n\nlong long F(long long x) {\n    memset(D,-1,sizeof(D));\n    stringstream l; l << x;\n    l >> w;\n    return d(0,w.size(),1);    \n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4849",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #129 — Editorial - Codeforces - Code 3",
          "code": "long n = in.nextLong();\n        long min = Long.MAX_VALUE;\n        long idx = -1;\n        Set<Long> set = new HashSet<>();\n        boolean flag = false;\n        for(int i=0;i<n;i++){\n            long val = in.nextLong();\n            if(set.contains(val))\n                flag = true;\n            if(val<min) {\n                min = val;\n                idx = i;\n            }\n            set.add(val);\n        }\n        out.println((flag)?\"Still Rozdil\":idx+1);\n\n        out.close();\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4849",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    \n    int n = inf.readInt(1, 1000000, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(1, n, \"k\");\n    inf.readEoln();\n    \n    string s = inf.readLine(\"[BWX]{\" + to_string(n) + \"}\", \"s\");\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    \n    int n = inf.readInt(1, 1000000, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(1, n, \"k\");\n    inf.readEoln();\n    \n    string s = inf.readLine(\"[BWX]{\" + to_string(n) + \"}\", \"s\");\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    \n    int n = inf.readInt(1, 1000000, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(1, n, \"k\");\n    inf.readEoln();\n    \n    string s = inf.readLine(\"[BWX]{\" + to_string(n) + \"}\", \"s\");\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int k = opt<int>(\"k\");\n    string type = opt<string>(\"type\", \"random\");\n\n    // Generate s according to the type\n\n    string s(n, 'X');\n\n    if(type == \"all_X\") {\n        /* s is all 'X's */\n        s = string(n, 'X');\n    } else if(type == \"no_X\") {\n        /* s is random 'B's and 'W's */\n        s = \"\";\n        char chars[] = {'B', 'W'};\n        for(int i=0; i<n; ++i) {\n            s += chars[rnd.next(2)];\n        }\n    } else if(type == \"random\") {\n        /* s is random 'B', 'W', 'X' */\n        s = \"\";\n        char chars[] = {'B', 'W', 'X'};\n        for(int i=0; i<n; ++i) {\n            s += chars[rnd.next(3)];\n        }\n    } else if(type == \"impossible\") {\n        /* s is constructed so that it is impossible to be beautiful */\n        if (n >= 2 * k) {\n            // Block possible positions for 'B's and 'W's substrings\n            // First k positions are 'W's\n            s = string(k, 'W');\n            // Next k positions are 'B's\n            s += string(k, 'B');\n            // Rest are 'X's\n            s += string(n - 2 * k, 'X');\n        } else {\n            // Not enough length to block substrings, fill with random 'B's and 'W's\n            s = \"\";\n            char chars[] = {'B', 'W'};\n            for(int i = 0; i < n; ++i)\n                s += chars[rnd.next(2)];\n        }\n    } else if(type == \"single_solution\") {\n        /* Only one way to make s beautiful */\n        s = string(n, 'X');\n        if (n >= 2 * k) {\n            // Fix first k positions to 'B's\n            for(int i = 0; i < k; ++i) s[i] = 'B';\n            // Fix next k positions to 'W's\n            for(int i = k; i < 2 * k; ++i) s[i] = 'W';\n            // Other positions remain 'X's\n        }\n    } else {\n        /* default to random */\n        s = \"\";\n        char chars[] = {'B', 'W', 'X'};\n        for(int i=0; i<n; ++i) {\n            s += chars[rnd.next(3)];\n        }\n    }\n\n    /* Output n and k */\n    printf(\"%d %d\\n\", n, k);\n    /* Output s */\n    printf(\"%s\\n\", s.c_str());\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int k = opt<int>(\"k\");\n    string type = opt<string>(\"type\", \"random\");\n\n    // Generate s according to the type\n\n    string s(n, 'X');\n\n    if(type == \"all_X\") {\n        /* s is all 'X's */\n        s = string(n, 'X');\n    } else if(type == \"no_X\") {\n        /* s is random 'B's and 'W's */\n        s = \"\";\n        char chars[] = {'B', 'W'};\n        for(int i=0; i<n; ++i) {\n            s += chars[rnd.next(2)];\n        }\n    } else if(type == \"random\") {\n        /* s is random 'B', 'W', 'X' */\n        s = \"\";\n        char chars[] = {'B', 'W', 'X'};\n        for(int i=0; i<n; ++i) {\n            s += chars[rnd.next(3)];\n        }\n    } else if(type == \"impossible\") {\n        /* s is constructed so that it is impossible to be beautiful */\n        if (n >= 2 * k) {\n            // Block possible positions for 'B's and 'W's substrings\n            // First k positions are 'W's\n            s = string(k, 'W');\n            // Next k positions are 'B's\n            s += string(k, 'B');\n            // Rest are 'X's\n            s += string(n - 2 * k, 'X');\n        } else {\n            // Not enough length to block substrings, fill with random 'B's and 'W's\n            s = \"\";\n            char chars[] = {'B', 'W'};\n            for(int i = 0; i < n; ++i)\n                s += chars[rnd.next(2)];\n        }\n    } else if(type == \"single_solution\") {\n        /* Only one way to make s beautiful */\n        s = string(n, 'X');\n        if (n >= 2 * k) {\n            // Fix first k positions to 'B's\n            for(int i = 0; i < k; ++i) s[i] = 'B';\n            // Fix next k positions to 'W's\n            for(int i = k; i < 2 * k; ++i) s[i] = 'W';\n            // Other positions remain 'X's\n        }\n    } else {\n        /* default to random */\n        s = \"\";\n        char chars[] = {'B', 'W', 'X'};\n        for(int i=0; i<n; ++i) {\n            s += chars[rnd.next(3)];\n        }\n    }\n\n    /* Output n and k */\n    printf(\"%d %d\\n\", n, k);\n    /* Output s */\n    printf(\"%s\\n\", s.c_str());\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -k 1 -type all_X\n./gen -n 1 -k 1 -type no_X\n./gen -n 1 -k 1 -type random\n./gen -n 1 -k 1 -type impossible\n\n./gen -n 2 -k 1 -type all_X\n./gen -n 2 -k 1 -type random\n./gen -n 2 -k 2 -type impossible\n\n./gen -n 3 -k 1 -type all_X\n./gen -n 3 -k 2 -type random\n./gen -n 3 -k 3 -type impossible\n\n./gen -n 10 -k 2 -type all_X\n./gen -n 10 -k 5 -type no_X\n./gen -n 10 -k 1 -type random\n./gen -n 10 -k 3 -type impossible\n./gen -n 10 -k 4 -type single_solution\n\n./gen -n 100 -k 50 -type all_X\n./gen -n 100 -k 25 -type no_X\n./gen -n 100 -k 10 -type random\n./gen -n 100 -k 50 -type impossible\n./gen -n 100 -k 30 -type single_solution\n\n./gen -n 1000 -k 500 -type all_X\n./gen -n 1000 -k 500 -type no_X\n./gen -n 1000 -k 100 -type random\n./gen -n 1000 -k 300 -type impossible\n./gen -n 1000 -k 200 -type single_solution\n\n./gen -n 10000 -k 1 -type all_X\n./gen -n 10000 -k 5000 -type no_X\n./gen -n 10000 -k 2500 -type random\n./gen -n 10000 -k 4000 -type impossible\n./gen -n 10000 -k 2000 -type single_solution\n\n./gen -n 100000 -k 100000 -type all_X\n./gen -n 100000 -k 50000 -type no_X\n./gen -n 100000 -k 25000 -type random\n./gen -n 100000 -k 40000 -type impossible\n./gen -n 100000 -k 20000 -type single_solution\n\n./gen -n 1000000 -k 1 -type all_X\n./gen -n 1000000 -k 500000 -type no_X\n./gen -n 1000000 -k 250000 -type random\n./gen -n 1000000 -k 400000 -type impossible\n./gen -n 1000000 -k 200000 -type single_solution\n\n./gen -n 999999 -k 999999 -type all_X\n./gen -n 999999 -k 500000 -type random\n./gen -n 999999 -k 2 -type single_solution\n./gen -n 999999 -k 999998 -type impossible\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T19:48:39.783724",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "204/E",
      "title": "E. Little Elephant and Strings",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test3 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains two space-separated integers — n and k (1 ≤ n, k ≤ 105). Next n lines contain array a. The i-th line contains a non-empty string ai, consisting of lowercase English letter. The total length of all strings ai does not exceed 105.",
      "output_spec": "OutputOn a single line print n space-separated integers — the i-th number is the answer for string ai.Please, do not use the %lld specifier to read or write 64-bit integers in С++. It is preferred to use the cin, cout streams or the %I64d specifier.",
      "sample_tests": "ExamplesInputCopy3 1abcaabOutputCopy6 1 3 InputCopy7 4rubikfurikababbabaaaabbbababaabababababazeroOutputCopy1 0 9 9 21 30 0",
      "description": "E. Little Elephant and Strings\n\ntime limit per test3 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains two space-separated integers — n and k (1 ≤ n, k ≤ 105). Next n lines contain array a. The i-th line contains a non-empty string ai, consisting of lowercase English letter. The total length of all strings ai does not exceed 105.\n\nOutputOn a single line print n space-separated integers — the i-th number is the answer for string ai.Please, do not use the %lld specifier to read or write 64-bit integers in С++. It is preferred to use the cin, cout streams or the %I64d specifier.\n\nInputCopy3 1abcaabOutputCopy6 1 3 InputCopy7 4rubikfurikababbabaaaabbbababaabababababazeroOutputCopy1 0 9 9 21 30 0\n\nInputCopy3 1abcaab\n\nOutputCopy6 1 3\n\nInputCopy7 4rubikfurikababbabaaaabbbababaabababababazero\n\nOutputCopy1 0 9 9 21 30 0\n\nNoteLet's assume that you are given string a = a1a2... a|a|, then let's denote the string's length as |a| and the string's i-th character as ai.A substring a[l... r] (1 ≤ l ≤ r ≤ |a|) of string a is string alal + 1... ar.String a is a substring of string b, if there exists such pair of integers l and r (1 ≤ l ≤ r ≤ |b|), that b[l... r] = a.",
      "solutions": [
        {
          "title": "Codeforces Round #129 - Codeforces",
          "content": "Hi!Time brings to you next Codeforces round, this time it is with number 129. It will take place in 11.07.2012 at 19:30 (Moscow time). This time the problems are authored by me, Vitaliy Herasymiv. Long time ago I was the author of 4 Codeforces rounds, they were about lucky numbers. But, unfortunately, nothing is constant, so this time there will be no problems about lucky numbers.A lot of help in preparing of the problems was from Gerald Agapov (Gerald), Alexander Kouprin (Alex_KPR), Vitaly Aksenov (Aksenov239), The problems were translated to English by Maria Belova (Delinur). Thanks to all of them.I hope you will like this all.Good Luck!Div1:Thanks all! The results are the following: tourist (now tourist become first Codeforces target, congratulations to him) winger RAVEman rng_58 RAD bmerry Shik Div2: xiaoshua2 ahm.kam_92 HanzhongBall_Quanling daidailanlan You can read editorials here.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/4848",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 901
        },
        {
          "title": "Codeforces Round #129 — Editorial - Codeforces",
          "content": "205A - Little Elephant and RozdilThis problem was the simplest in the problemset. All you need to do is just to sort all distances (keeping track on all indices). If the first two distances are equal, just output \"Still Rozdil\", otherwise output the index of the first element of the array.The complexity is O(NlogN).205B - Little Elephant and SortingIn this problem you need to notice the fact (which can be proven, but it is almost obvious) that if you are doing some operation for interval from l to r (inclusive), r must be equal to n. This is becuase when you add something to all right part the answer can't be worse. After that you need to go from left to right and greedly add appropriate number of turns.The complexity is O(N).205C - Little Elephant and IntervalIt is well-known that for such problem you need to write function F(x) which solves the problem for the interval 0..x, and the answer then is F(r) - F(l - 1).Now you need to write F(x) function. If x < 10, then answer is, of course, equal to x. Otherwise, let len be the length of x, x' — the integer x but without first and last digits, xi — the i-th digit of integer x (from left to right, starting from 0). Interate through all possible first digit d (which is the last at the same time) and through the length i of the number. Then if i < len - 2 or (i = len - 2 and d < x0) you need to add 10i to the answer. Otherwise, if i = len - 2 and d = x0 you need to add x' to the answer. Finally, if i = len - 2 and d = x0 and xlen - 1 ≥ d add 1 to the answer.This problems also can be solved using DP.205D - Little Elephant and CardsIt is nice to use the map structure in this problem, but you can solve it without map (using sorting and binary serach). Lets iterate through all possible colors that we have and suppose that this currect color is the one that will make our set funny. The minimal number through all this will be the answer. To find the minimal number of turns to make our set funny using current color we need to know two numbers: the number of cards with current color on the front side and the number of cards with the current color on back side (but not at the same time). Let it be integers a and b. Let m = (n + 1) / 2 — the minimal number of the same cards required to get the funny set. Then if a + b < m it is impossible to make set funny using current color at all. If a ≥ m then the answer is 0, otherwise the answer is m - a.205E - Little Elephant and Furik and RubikThis problem is to find the expected value. Important fact here is the linearity of the expected value. This means that we can for each element of the first strings find the probability that exactly this element will me matched with some other (but, of course, equal) from the second string. The answer will be the sum of all such probabilities.Let the current character of the first string be the i-th character (1-based numeration). Firstly we try to solve problem in O(N2) time. Namely, as it was said above, we need to find the number of such pairs of substrings that i-th character (which is on probably some other position in substring) is the same as the corresponding character of the second substring. Iterate through all j (j ≤ i) such that Ai = Bj. The number of such pairs of substrings that have match in that characters is j(n - i + 1) (considering 1-based numeration). This is O(N2). And because we need to find the sum of such values for all possible j, we can rewrite it as Si(n - i + 1), where Si equals to the sum of all integers j (j ≤ i) that Ai = Bi. Array S can be simply computed in a linear time. Analogically you should process all indices to the right from i.After we know the number of pairs of substrings with the match with the i-th character (let it be count), the probability is count / total, where total is the total number of pair of substrings (it can be found by loop or with some simple formula).The comlexity is O(N).204D - Little Elephant and Retro StringsFirstly we should solve following subproblem: for each prefix find the number of it's fillings such that there is no consecutive block of k characters B. Let it be F(x), where x is the index in of the last character if the prefix. Assing F(x) = F(x - 1) * cnt, where cnt = 2 if Sx = 'X' and 1 otherwise. After such assing there may be some bad filling included to F(x). Since we suppouse that F(x - 1) is caclulated correctly, all bad filling must contain blocks of k charcters B only at the end of the prefix (they may be included only if substring Sx - k + 1..x doesn't contain characters W and character Sx - k is not B). So, if it's possible, we must subtract from F(x) value F(x - k - 1), because it's exactly the number of bad fillings.With the same DP you should you calc the same values for suffixes (but this time changing B by W and vice versa). Now we should carefully calculate the result in such way that now repeatings occur. Let iterate (from right to left) through all possible positions of the first blocks of k characters B (this means that we suppose that no block occur to the left). Using our DP we can simply find the number of fillings of all characters to the left from that block in such way that no another blocks of k characters B occur. Considering O(N2) solutions, we can iterate through all possible indexes of the begging of the last block of k characters W (again we suppose that this blocks must be the last and no another may occur to the right) and agin using our DP count the number of fillings to the right. We don't care what is between that blocks, so we just multiply answer by 2^(the number of characters X between blocks). But, since we are going from right to the left, we can just keep tracking on all possible last blocks and get O(N) solution.204E - Little Elephant and StringsTo solve this problems we can use suffix array. More information about suffix arrays you can find in the Internet.Firstly, concatenate all strings into the one separating consecutive strings by some unique characters (it was also useful to not use strings, but arrays of integers). For example, three strings abc, a, ab may be concatenated in the following way: abc#a@ab. Now we should build suffix array using this total string, this allows to us to sort all cyclic shifts of the string. After that each cyclic shift will either begin with additional character or the character from the input strings.Notice now that to find the result we need to find for each cyclic shift (begging of which doesn't contain additional character) the largest size of it's prefix such that this prefix is substring of at least k different input strings. This value can be found by binary search, but for this we need some function F(x, len) which can answer the questions: how many input strings contain prefix of size len of x cyclic shift as a substring.How to make F(x, len)? Look at all cyclic shifts, prefix of size len of which is equal to preifx of size len of x-th shift. Since all shifts are sorted lexicoraphically, this set of shifts can be represented as integral [l;r] of indices of shifts (1 ≤ l ≤ x ≤ r). How to find l and r? For each pair of consecutive shifts we can find it's greatest common prefix (using properties of suffix array). Than l and r can be found using RMQ. For l we need to know the rigthmost pair of shift (but to the left from x) that their greatest common prefix is less than len. Analogically we can find r. After that we have interval [l;r] and we need to find the number of different input strings that belongs to the shifts from l-th to r-th (actually, we need to find the number of different integer on interval). But, notice that we dont need the exactly number of different integers, we need to know just it is at least k or not. So let L[i] equals to the greatest j (j ≤ i) such that the number of different integers on interval [j;i] is equal to k. Then if L[r] ≥ l, obiously, interval [l;r] will also contains at least k different. So F(x, len) is done.The only thing to done is to fill array L. This is pretty simple using set (but it is possible without it but using RMQ). We will go from left to righ at keep the indices of the last (the rightmost) k different integers in the set. If some integer comes, then (if it was earlier) we need to erase this previous index from set (if it was still in) and insert new current. While the size of set is greater than k, we should erase the minimal number from it. Then if in some position i the size of the set (after above changings) is equal to k, than L[i] is equal to the minimal number in set.Since we O(N) times use binary search, and function F(x, len) works in O(logN) time, the total complexity is O(Nlog2N).",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/4849",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 204\\s*E"
          },
          "content_length": 8674
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #129 - Codeforces - Code 1",
          "code": "He has n cards, each has exactly two colors",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4848",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #129 - Codeforces - Code 2",
          "code": "The color of the front of the card may coincide with the color of the back of the card",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4848",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #129 - Codeforces - Code 3",
          "code": "public void solve() throws IOException {\n\t\tlong l = nextLong();\n\t\tlong r = nextLong();\n\t\tout.println(f(r) - f(l - 1));\n\t}\n\t\n\tlong f(long x) {\n\t\tif (x < 10) {\n\t\t\treturn x;\n\t\t}\n\t\tString s = Long.toString(x);\n\t\treturn (x / 10 - 1) + (s.charAt(0) <= s.charAt(s.length() - 1) ? 1 : 0) + 9;\n\t}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4848",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #129 - Codeforces - Code 4",
          "code": "public void solve() throws IOException {\n\t\tlong l = nextLong();\n\t\tlong r = nextLong();\n\t\tout.println(f(r) - f(l - 1));\n\t}\n\t\n\tlong f(long x) {\n\t\tif (x < 10) {\n\t\t\treturn x;\n\t\t}\n\t\tString s = Long.toString(x);\n\t\treturn (x / 10 - 1) + (s.charAt(0) <= s.charAt(s.length() - 1) ? 1 : 0) + 9;\n\t}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4848",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #129 - Codeforces - Code 5",
          "code": "double div=n*(n+1)*(2*n+1);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4848",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #129 - Codeforces - Code 6",
          "code": "double div=n*(n+1)*(2*n+1);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4848",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #129 — Editorial - Codeforces - Code 1",
          "code": "ll D[10][20][2];\nstring w;\n\nlong long d(int i, int j, int k) {\n    if (D[i][j][k] != -1) return D[i][j][k];\n    if (j == 1) {\n        if (i == 0 and k == 0) return 9;\n        if (i == 0 and k == 1) return w[w.size() - 1] - '0';\n        else if (k == 1) return i <= w[w.size() - 1] - '0';\n        else return 1;\n    }\n    long long cont = 0;\n    for (int e = 0; e < ((k == 0)?10:w[w.size() - j] - '0' + 1); ++e)\n      cont += d((i == 0)?e:i, j-1, (k == 0)?0:e == w[w.size() - j] - '0');\n    return D[i][j][k] = cont;\n}\n\nlong long F(long long x) {\n    memset(D,-1,sizeof(D));\n    stringstream l; l << x;\n    l >> w;\n    return d(0,w.size(),1);    \n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4849",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #129 — Editorial - Codeforces - Code 2",
          "code": "ll D[10][20][2];\nstring w;\n\nlong long d(int i, int j, int k) {\n    if (D[i][j][k] != -1) return D[i][j][k];\n    if (j == 1) {\n        if (i == 0 and k == 0) return 9;\n        if (i == 0 and k == 1) return w[w.size() - 1] - '0';\n        else if (k == 1) return i <= w[w.size() - 1] - '0';\n        else return 1;\n    }\n    long long cont = 0;\n    for (int e = 0; e < ((k == 0)?10:w[w.size() - j] - '0' + 1); ++e)\n      cont += d((i == 0)?e:i, j-1, (k == 0)?0:e == w[w.size() - j] - '0');\n    return D[i][j][k] = cont;\n}\n\nlong long F(long long x) {\n    memset(D,-1,sizeof(D));\n    stringstream l; l << x;\n    l >> w;\n    return d(0,w.size(),1);    \n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4849",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #129 — Editorial - Codeforces - Code 3",
          "code": "long n = in.nextLong();\n        long min = Long.MAX_VALUE;\n        long idx = -1;\n        Set<Long> set = new HashSet<>();\n        boolean flag = false;\n        for(int i=0;i<n;i++){\n            long val = in.nextLong();\n            if(set.contains(val))\n                flag = true;\n            if(val<min) {\n                min = val;\n                idx = i;\n            }\n            set.add(val);\n        }\n        out.println((flag)?\"Still Rozdil\":idx+1);\n\n        out.close();\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4849",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(1, 100000, \"k\");\n    inf.readEoln();\n    int totalLength = 0;\n    for (int i = 0; i < n; ++i) {\n        string ai = inf.readToken(\"[a-z]+\", \"ai\");\n        inf.readEoln();\n        totalLength += ai.length();\n    }\n    ensuref(totalLength <= 100000, \"Total length of all strings should not exceed 1e5, but it's %d\", totalLength);\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(1, 100000, \"k\");\n    inf.readEoln();\n    int totalLength = 0;\n    for (int i = 0; i < n; ++i) {\n        string ai = inf.readToken(\"[a-z]+\", \"ai\");\n        inf.readEoln();\n        totalLength += ai.length();\n    }\n    ensuref(totalLength <= 100000, \"Total length of all strings should not exceed 1e5, but it's %d\", totalLength);\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(1, 100000, \"k\");\n    inf.readEoln();\n    int totalLength = 0;\n    for (int i = 0; i < n; ++i) {\n        string ai = inf.readToken(\"[a-z]+\", \"ai\");\n        inf.readEoln();\n        totalLength += ai.length();\n    }\n    ensuref(totalLength <= 100000, \"Total length of all strings should not exceed 1e5, but it's %d\", totalLength);\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int k = opt<int>(\"k\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<string> a(n);\n\n    const int max_total_length = 100000;\n    int total_length = 0;\n\n    if (type == \"identical\") {\n        /* All strings are identical */\n        int length = opt<int>(\"length\", 1);\n        length = min(length, max_total_length / n);\n        if (length == 0) length = 1;\n\n        string s;\n        for (int i = 0; i < length; i++) {\n            s += (char)('a' + rnd.next(26));\n        }\n\n        for (int i = 0; i < n; i++) {\n            a[i] = s;\n        }\n\n    } else if (type == \"unique\") {\n        /* All strings are unique */\n        int length_per_string = max_total_length / n;\n        if (length_per_string == 0) length_per_string = 1;\n        int letters = 26;\n\n        for (int i = 0; i < n; i++) {\n            string s;\n            for (int j = 0; j < length_per_string; j++) {\n                s += (char)('a' + (i + j) % letters);\n            }\n            a[i] = s;\n        }\n\n    } else if (type == \"random\") {\n        /* Generate random strings */\n        int min_length = opt<int>(\"min_length\", 1);\n        int max_length = opt<int>(\"max_length\", max_total_length / n);\n        if (max_length < min_length) max_length = min_length;\n        vector<int> lengths(n);\n        int remaining_length = max_total_length;\n\n        for (int i = 0; i < n; i++) {\n            int length = rnd.next(min_length, max_length);\n            int max_possible_length = remaining_length - (n - i - 1) * min_length;\n            length = min(length, max_possible_length);\n            length = max(length, min_length);\n            lengths[i] = length;\n            remaining_length -= length;\n        }\n\n        for (int i = 0; i < n; i++) {\n            string s;\n            for (int j = 0; j < lengths[i]; j++) {\n                s += (char)('a' + rnd.next(26));\n            }\n            a[i] = s;\n        }\n\n    } else if (type == \"single_char\") {\n        /* Strings are repetitions of a single character */\n        int length_per_string = max_total_length / n;\n        if (length_per_string == 0) length_per_string = 1;\n\n        for (int i = 0; i < n; i++) {\n            char c = 'a' + rnd.next(26);\n            string s(length_per_string, c);\n            a[i] = s;\n        }\n\n    } else if (type == \"overlap\") {\n        /* Strings with overlapping substrings */\n        int L = opt<int>(\"L\", 100000);\n        L = min(L, max_total_length);\n        string base;\n        for (int i = 0; i < L; i++) {\n            base += (char)('a' + rnd.next(26));\n        }\n        total_length = 0;\n        for (int i = 0; i < n; i++) {\n            int start = rnd.next(0, L - 1);\n            int max_length = L - start;\n            int length = rnd.next(1, max_length);\n            if (total_length + length > max_total_length) {\n                length = max_total_length - total_length;\n                length = max(length, 1);\n            }\n            total_length += length;\n            a[i] = base.substr(start, length);\n            if (total_length == max_total_length) {\n                for (int j = i + 1; j < n; j++) {\n                    a[j] = base.substr(0, 1);\n                }\n                break;\n            }\n        }\n\n    } else if (type == \"max_length\") {\n        /* Strings of maximum possible length */\n        int length = max_total_length / n;\n        if (length == 0) length = 1;\n\n        string s;\n        for (int i = 0; i < length; i++) {\n            s += (char)('a' + rnd.next(26));\n        }\n\n        for (int i = 0; i < n; i++) {\n            a[i] = s;\n        }\n\n    } else if (type == \"minimal\") {\n        /* Strings of length 1 */\n        for (int i = 0; i < n; i++) {\n            a[i] = string(1, 'a' + rnd.next(26));\n        }\n\n    } else if (type == \"prefixes\") {\n        /* Strings are prefixes of a base string */\n        int length = opt<int>(\"length\", max_total_length / n);\n        if (length == 0) length = 1;\n        length = min(length, max_total_length / n);\n\n        string base;\n        for (int i = 0; i < length; i++) {\n            base += (char)('a' + rnd.next(26));\n        }\n\n        for (int i = 0; i < n; i++) {\n            int l = rnd.next(1, length);\n            a[i] = base.substr(0, l);\n        }\n    } else {\n        /* Default case, generate random strings of length 1 */\n        for (int i = 0; i < n; i++) {\n            a[i] = string(1, 'a' + rnd.next(26));\n        }\n    }\n\n    /* Output n and k */\n    printf(\"%d %d\\n\", n, k);\n\n    /* Output strings */\n    for (int i = 0; i < n; i++) {\n        printf(\"%s\\n\", a[i].c_str());\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int k = opt<int>(\"k\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<string> a(n);\n\n    const int max_total_length = 100000;\n    int total_length = 0;\n\n    if (type == \"identical\") {\n        /* All strings are identical */\n        int length = opt<int>(\"length\", 1);\n        length = min(length, max_total_length / n);\n        if (length == 0) length = 1;\n\n        string s;\n        for (int i = 0; i < length; i++) {\n            s += (char)('a' + rnd.next(26));\n        }\n\n        for (int i = 0; i < n; i++) {\n            a[i] = s;\n        }\n\n    } else if (type == \"unique\") {\n        /* All strings are unique */\n        int length_per_string = max_total_length / n;\n        if (length_per_string == 0) length_per_string = 1;\n        int letters = 26;\n\n        for (int i = 0; i < n; i++) {\n            string s;\n            for (int j = 0; j < length_per_string; j++) {\n                s += (char)('a' + (i + j) % letters);\n            }\n            a[i] = s;\n        }\n\n    } else if (type == \"random\") {\n        /* Generate random strings */\n        int min_length = opt<int>(\"min_length\", 1);\n        int max_length = opt<int>(\"max_length\", max_total_length / n);\n        if (max_length < min_length) max_length = min_length;\n        vector<int> lengths(n);\n        int remaining_length = max_total_length;\n\n        for (int i = 0; i < n; i++) {\n            int length = rnd.next(min_length, max_length);\n            int max_possible_length = remaining_length - (n - i - 1) * min_length;\n            length = min(length, max_possible_length);\n            length = max(length, min_length);\n            lengths[i] = length;\n            remaining_length -= length;\n        }\n\n        for (int i = 0; i < n; i++) {\n            string s;\n            for (int j = 0; j < lengths[i]; j++) {\n                s += (char)('a' + rnd.next(26));\n            }\n            a[i] = s;\n        }\n\n    } else if (type == \"single_char\") {\n        /* Strings are repetitions of a single character */\n        int length_per_string = max_total_length / n;\n        if (length_per_string == 0) length_per_string = 1;\n\n        for (int i = 0; i < n; i++) {\n            char c = 'a' + rnd.next(26);\n            string s(length_per_string, c);\n            a[i] = s;\n        }\n\n    } else if (type == \"overlap\") {\n        /* Strings with overlapping substrings */\n        int L = opt<int>(\"L\", 100000);\n        L = min(L, max_total_length);\n        string base;\n        for (int i = 0; i < L; i++) {\n            base += (char)('a' + rnd.next(26));\n        }\n        total_length = 0;\n        for (int i = 0; i < n; i++) {\n            int start = rnd.next(0, L - 1);\n            int max_length = L - start;\n            int length = rnd.next(1, max_length);\n            if (total_length + length > max_total_length) {\n                length = max_total_length - total_length;\n                length = max(length, 1);\n            }\n            total_length += length;\n            a[i] = base.substr(start, length);\n            if (total_length == max_total_length) {\n                for (int j = i + 1; j < n; j++) {\n                    a[j] = base.substr(0, 1);\n                }\n                break;\n            }\n        }\n\n    } else if (type == \"max_length\") {\n        /* Strings of maximum possible length */\n        int length = max_total_length / n;\n        if (length == 0) length = 1;\n\n        string s;\n        for (int i = 0; i < length; i++) {\n            s += (char)('a' + rnd.next(26));\n        }\n\n        for (int i = 0; i < n; i++) {\n            a[i] = s;\n        }\n\n    } else if (type == \"minimal\") {\n        /* Strings of length 1 */\n        for (int i = 0; i < n; i++) {\n            a[i] = string(1, 'a' + rnd.next(26));\n        }\n\n    } else if (type == \"prefixes\") {\n        /* Strings are prefixes of a base string */\n        int length = opt<int>(\"length\", max_total_length / n);\n        if (length == 0) length = 1;\n        length = min(length, max_total_length / n);\n\n        string base;\n        for (int i = 0; i < length; i++) {\n            base += (char)('a' + rnd.next(26));\n        }\n\n        for (int i = 0; i < n; i++) {\n            int l = rnd.next(1, length);\n            a[i] = base.substr(0, l);\n        }\n    } else {\n        /* Default case, generate random strings of length 1 */\n        for (int i = 0; i < n; i++) {\n            a[i] = string(1, 'a' + rnd.next(26));\n        }\n    }\n\n    /* Output n and k */\n    printf(\"%d %d\\n\", n, k);\n\n    /* Output strings */\n    for (int i = 0; i < n; i++) {\n        printf(\"%s\\n\", a[i].c_str());\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -k 1 -type max_length          # Test case 1: n=1, k=1, maximum length string\n./gen -n 100000 -k 1 -type minimal        # Test case 2: n=100000, k=1, strings of length 1\n./gen -n 100000 -k 100000 -type minimal   # Test case 3: n=100000, k=100000, strings of length 1\n./gen -n 1000 -k 1 -type identical -length 100  # Test case 4: n=1000, k=1, identical strings, length=100\n./gen -n 100000 -k 1 -type identical -length 1  # Test case 5: n=100000, k=1, identical strings, length=1\n./gen -n 100 -k 50 -type prefixes               # Test case 6: n=100, k=50, strings are prefixes\n./gen -n 10000 -k 5000 -type random -min_length 1 -max_length 10  # Test case 7: random strings of length 1-10\n./gen -n 20000 -k 10000 -type random -min_length 5 -max_length 5  # Test case 8: random strings length=5\n./gen -n 50000 -k 25000 -type random -min_length 1 -max_length 2  # Test case 9: random strings length=1-2\n./gen -n 1 -k 1 -type random -min_length 100000 -max_length 100000 # Test case 10: n=1, super long string\n./gen -n 50 -k 1 -type overlap -L 100000          # Test case 11: overlapping substrings, base length=100000\n./gen -n 5000 -k 2500 -type overlap -L 10000      # Test case 12: overlap, base length=10000\n./gen -n 100 -k 1 -type single_char               # Test case 13: n=100, single character strings\n./gen -n 1 -k 1 -type single_char                 # Test case 14: n=1, single character string\n./gen -n 100000 -k 1 -type single_char            # Test case 15: n=100000, single character strings\n./gen -n 10 -k 5 -type unique                     # Test case 16: n=10, k=5, unique strings\n./gen -n 5000 -k 2500 -type unique                # Test case 17: n=5000, unique strings\n./gen -n 25000 -k 1 -type unique                  # Test case 18: n=25000, k=1, unique strings\n./gen -n 1000 -k 1000 -type random -min_length 1  # Test case 19: n=1000, k=1000, random strings length=1\n./gen -n 100000 -k 50000 -type prefixes           # Test case 20: n=100000, k=50000, prefixes\n./gen -n 2 -k 1 -type random -min_length 50000 -max_length 50000  # Test case 21: n=2, long strings\n./gen -n 100 -k 1 -type overlap -L 1000           # Test case 22: n=100, overlapping substrings, base length=1000\n./gen -n 100000 -k 1 -type prefixes -length 1     # Test case 23: n=100000, prefixes of length 1\n./gen -n 1000 -k 1000 -type random -min_length 100 -max_length 100  # Test case 24: n=1000, random strings length=100\n./gen -n 1000 -k 1 -type random -min_length 1 -max_length 100  # Test case 25: n=1000, k=1, random strings\n./gen -n 50000 -k 50000 -type minimal             # Test case 26: n=50000, k=50000, strings length=1\n./gen -n 50000 -k 50000 -type identical -length 2 # Test case 27: n=50000, identical strings length=2\n./gen -n 100000 -k 100000 -type single_char       # Test case 28: n=100000, k=100000, single character strings\n./gen -n 37500 -k 20000 -type overlap -L 9000     # Test case 29: n=37500, overlapping strings\n./gen -n 25000 -k 5000 -type random -min_length 2 -max_length 10  # Test case 30: n=25000, random strings length=2-10\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T19:48:41.921923",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "205/A",
      "title": "A. Little Elephant and Rozdil",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains a single integer n (1 ≤ n ≤ 105) — the number of cities. The next line contains n integers, separated by single spaces: the i-th integer represents the time needed to go from town Rozdil to the i-th town. The time values are positive integers, not exceeding 109.You can consider the cities numbered from 1 to n, inclusive. Rozdil is not among the numbered cities.",
      "output_spec": "OutputPrint the answer on a single line — the number of the town the Little Elephant will go to. If there are multiple cities with minimum travel time, print \"Still Rozdil\" (without the quotes).",
      "sample_tests": "ExamplesInputCopy27 4OutputCopy2InputCopy77 4 47 100 4 9 12OutputCopyStill Rozdil",
      "description": "A. Little Elephant and Rozdil\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains a single integer n (1 ≤ n ≤ 105) — the number of cities. The next line contains n integers, separated by single spaces: the i-th integer represents the time needed to go from town Rozdil to the i-th town. The time values are positive integers, not exceeding 109.You can consider the cities numbered from 1 to n, inclusive. Rozdil is not among the numbered cities.\n\nOutputPrint the answer on a single line — the number of the town the Little Elephant will go to. If there are multiple cities with minimum travel time, print \"Still Rozdil\" (without the quotes).\n\nInputCopy27 4OutputCopy2InputCopy77 4 47 100 4 9 12OutputCopyStill Rozdil\n\nInputCopy27 4\n\nOutputCopy2\n\nInputCopy77 4 47 100 4 9 12\n\nOutputCopyStill Rozdil\n\nNoteIn the first sample there are only two cities where the Little Elephant can go. The travel time for the first town equals 7, to the second one — 4. The town which is closest to Rodzil (the only one) is the second one, so the answer is 2.In the second sample the closest cities are cities two and five, the travelling time to both of them equals 4, so the answer is \"Still Rozdil\".",
      "solutions": [
        {
          "title": "Codeforces Round #129 - Codeforces",
          "content": "Hi!Time brings to you next Codeforces round, this time it is with number 129. It will take place in 11.07.2012 at 19:30 (Moscow time). This time the problems are authored by me, Vitaliy Herasymiv. Long time ago I was the author of 4 Codeforces rounds, they were about lucky numbers. But, unfortunately, nothing is constant, so this time there will be no problems about lucky numbers.A lot of help in preparing of the problems was from Gerald Agapov (Gerald), Alexander Kouprin (Alex_KPR), Vitaly Aksenov (Aksenov239), The problems were translated to English by Maria Belova (Delinur). Thanks to all of them.I hope you will like this all.Good Luck!Div1:Thanks all! The results are the following: tourist (now tourist become first Codeforces target, congratulations to him) winger RAVEman rng_58 RAD bmerry Shik Div2: xiaoshua2 ahm.kam_92 HanzhongBall_Quanling daidailanlan You can read editorials here.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/4848",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 901
        },
        {
          "title": "Codeforces Round #129 — Editorial - Codeforces",
          "content": "205A - Little Elephant and RozdilThis problem was the simplest in the problemset. All you need to do is just to sort all distances (keeping track on all indices). If the first two distances are equal, just output \"Still Rozdil\", otherwise output the index of the first element of the array.The complexity is O(NlogN).205B - Little Elephant and SortingIn this problem you need to notice the fact (which can be proven, but it is almost obvious) that if you are doing some operation for interval from l to r (inclusive), r must be equal to n. This is becuase when you add something to all right part the answer can't be worse. After that you need to go from left to right and greedly add appropriate number of turns.The complexity is O(N).205C - Little Elephant and IntervalIt is well-known that for such problem you need to write function F(x) which solves the problem for the interval 0..x, and the answer then is F(r) - F(l - 1).Now you need to write F(x) function. If x < 10, then answer is, of course, equal to x. Otherwise, let len be the length of x, x' — the integer x but without first and last digits, xi — the i-th digit of integer x (from left to right, starting from 0). Interate through all possible first digit d (which is the last at the same time) and through the length i of the number. Then if i < len - 2 or (i = len - 2 and d < x0) you need to add 10i to the answer. Otherwise, if i = len - 2 and d = x0 you need to add x' to the answer. Finally, if i = len - 2 and d = x0 and xlen - 1 ≥ d add 1 to the answer.This problems also can be solved using DP.205D - Little Elephant and CardsIt is nice to use the map structure in this problem, but you can solve it without map (using sorting and binary serach). Lets iterate through all possible colors that we have and suppose that this currect color is the one that will make our set funny. The minimal number through all this will be the answer. To find the minimal number of turns to make our set funny using current color we need to know two numbers: the number of cards with current color on the front side and the number of cards with the current color on back side (but not at the same time). Let it be integers a and b. Let m = (n + 1) / 2 — the minimal number of the same cards required to get the funny set. Then if a + b < m it is impossible to make set funny using current color at all. If a ≥ m then the answer is 0, otherwise the answer is m - a.205E - Little Elephant and Furik and RubikThis problem is to find the expected value. Important fact here is the linearity of the expected value. This means that we can for each element of the first strings find the probability that exactly this element will me matched with some other (but, of course, equal) from the second string. The answer will be the sum of all such probabilities.Let the current character of the first string be the i-th character (1-based numeration). Firstly we try to solve problem in O(N2) time. Namely, as it was said above, we need to find the number of such pairs of substrings that i-th character (which is on probably some other position in substring) is the same as the corresponding character of the second substring. Iterate through all j (j ≤ i) such that Ai = Bj. The number of such pairs of substrings that have match in that characters is j(n - i + 1) (considering 1-based numeration). This is O(N2). And because we need to find the sum of such values for all possible j, we can rewrite it as Si(n - i + 1), where Si equals to the sum of all integers j (j ≤ i) that Ai = Bi. Array S can be simply computed in a linear time. Analogically you should process all indices to the right from i.After we know the number of pairs of substrings with the match with the i-th character (let it be count), the probability is count / total, where total is the total number of pair of substrings (it can be found by loop or with some simple formula).The comlexity is O(N).204D - Little Elephant and Retro StringsFirstly we should solve following subproblem: for each prefix find the number of it's fillings such that there is no consecutive block of k characters B. Let it be F(x), where x is the index in of the last character if the prefix. Assing F(x) = F(x - 1) * cnt, where cnt = 2 if Sx = 'X' and 1 otherwise. After such assing there may be some bad filling included to F(x). Since we suppouse that F(x - 1) is caclulated correctly, all bad filling must contain blocks of k charcters B only at the end of the prefix (they may be included only if substring Sx - k + 1..x doesn't contain characters W and character Sx - k is not B). So, if it's possible, we must subtract from F(x) value F(x - k - 1), because it's exactly the number of bad fillings.With the same DP you should you calc the same values for suffixes (but this time changing B by W and vice versa). Now we should carefully calculate the result in such way that now repeatings occur. Let iterate (from right to left) through all possible positions of the first blocks of k characters B (this means that we suppose that no block occur to the left). Using our DP we can simply find the number of fillings of all characters to the left from that block in such way that no another blocks of k characters B occur. Considering O(N2) solutions, we can iterate through all possible indexes of the begging of the last block of k characters W (again we suppose that this blocks must be the last and no another may occur to the right) and agin using our DP count the number of fillings to the right. We don't care what is between that blocks, so we just multiply answer by 2^(the number of characters X between blocks). But, since we are going from right to the left, we can just keep tracking on all possible last blocks and get O(N) solution.204E - Little Elephant and StringsTo solve this problems we can use suffix array. More information about suffix arrays you can find in the Internet.Firstly, concatenate all strings into the one separating consecutive strings by some unique characters (it was also useful to not use strings, but arrays of integers). For example, three strings abc, a, ab may be concatenated in the following way: abc#a@ab. Now we should build suffix array using this total string, this allows to us to sort all cyclic shifts of the string. After that each cyclic shift will either begin with additional character or the character from the input strings.Notice now that to find the result we need to find for each cyclic shift (begging of which doesn't contain additional character) the largest size of it's prefix such that this prefix is substring of at least k different input strings. This value can be found by binary search, but for this we need some function F(x, len) which can answer the questions: how many input strings contain prefix of size len of x cyclic shift as a substring.How to make F(x, len)? Look at all cyclic shifts, prefix of size len of which is equal to preifx of size len of x-th shift. Since all shifts are sorted lexicoraphically, this set of shifts can be represented as integral [l;r] of indices of shifts (1 ≤ l ≤ x ≤ r). How to find l and r? For each pair of consecutive shifts we can find it's greatest common prefix (using properties of suffix array). Than l and r can be found using RMQ. For l we need to know the rigthmost pair of shift (but to the left from x) that their greatest common prefix is less than len. Analogically we can find r. After that we have interval [l;r] and we need to find the number of different input strings that belongs to the shifts from l-th to r-th (actually, we need to find the number of different integer on interval). But, notice that we dont need the exactly number of different integers, we need to know just it is at least k or not. So let L[i] equals to the greatest j (j ≤ i) such that the number of different integers on interval [j;i] is equal to k. Then if L[r] ≥ l, obiously, interval [l;r] will also contains at least k different. So F(x, len) is done.The only thing to done is to fill array L. This is pretty simple using set (but it is possible without it but using RMQ). We will go from left to righ at keep the indices of the last (the rightmost) k different integers in the set. If some integer comes, then (if it was earlier) we need to erase this previous index from set (if it was still in) and insert new current. While the size of set is greater than k, we should erase the minimal number from it. Then if in some position i the size of the set (after above changings) is equal to k, than L[i] is equal to the minimal number in set.Since we O(N) times use binary search, and function F(x, len) works in O(logN) time, the total complexity is O(Nlog2N).",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/4849",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 205\\s*A"
          },
          "content_length": 8674
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #129 - Codeforces - Code 1",
          "code": "He has n cards, each has exactly two colors",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4848",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #129 - Codeforces - Code 2",
          "code": "The color of the front of the card may coincide with the color of the back of the card",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4848",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #129 - Codeforces - Code 3",
          "code": "public void solve() throws IOException {\n\t\tlong l = nextLong();\n\t\tlong r = nextLong();\n\t\tout.println(f(r) - f(l - 1));\n\t}\n\t\n\tlong f(long x) {\n\t\tif (x < 10) {\n\t\t\treturn x;\n\t\t}\n\t\tString s = Long.toString(x);\n\t\treturn (x / 10 - 1) + (s.charAt(0) <= s.charAt(s.length() - 1) ? 1 : 0) + 9;\n\t}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4848",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #129 - Codeforces - Code 4",
          "code": "public void solve() throws IOException {\n\t\tlong l = nextLong();\n\t\tlong r = nextLong();\n\t\tout.println(f(r) - f(l - 1));\n\t}\n\t\n\tlong f(long x) {\n\t\tif (x < 10) {\n\t\t\treturn x;\n\t\t}\n\t\tString s = Long.toString(x);\n\t\treturn (x / 10 - 1) + (s.charAt(0) <= s.charAt(s.length() - 1) ? 1 : 0) + 9;\n\t}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4848",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #129 - Codeforces - Code 5",
          "code": "double div=n*(n+1)*(2*n+1);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4848",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #129 - Codeforces - Code 6",
          "code": "double div=n*(n+1)*(2*n+1);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4848",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #129 — Editorial - Codeforces - Code 1",
          "code": "ll D[10][20][2];\nstring w;\n\nlong long d(int i, int j, int k) {\n    if (D[i][j][k] != -1) return D[i][j][k];\n    if (j == 1) {\n        if (i == 0 and k == 0) return 9;\n        if (i == 0 and k == 1) return w[w.size() - 1] - '0';\n        else if (k == 1) return i <= w[w.size() - 1] - '0';\n        else return 1;\n    }\n    long long cont = 0;\n    for (int e = 0; e < ((k == 0)?10:w[w.size() - j] - '0' + 1); ++e)\n      cont += d((i == 0)?e:i, j-1, (k == 0)?0:e == w[w.size() - j] - '0');\n    return D[i][j][k] = cont;\n}\n\nlong long F(long long x) {\n    memset(D,-1,sizeof(D));\n    stringstream l; l << x;\n    l >> w;\n    return d(0,w.size(),1);    \n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4849",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #129 — Editorial - Codeforces - Code 2",
          "code": "ll D[10][20][2];\nstring w;\n\nlong long d(int i, int j, int k) {\n    if (D[i][j][k] != -1) return D[i][j][k];\n    if (j == 1) {\n        if (i == 0 and k == 0) return 9;\n        if (i == 0 and k == 1) return w[w.size() - 1] - '0';\n        else if (k == 1) return i <= w[w.size() - 1] - '0';\n        else return 1;\n    }\n    long long cont = 0;\n    for (int e = 0; e < ((k == 0)?10:w[w.size() - j] - '0' + 1); ++e)\n      cont += d((i == 0)?e:i, j-1, (k == 0)?0:e == w[w.size() - j] - '0');\n    return D[i][j][k] = cont;\n}\n\nlong long F(long long x) {\n    memset(D,-1,sizeof(D));\n    stringstream l; l << x;\n    l >> w;\n    return d(0,w.size(),1);    \n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4849",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #129 — Editorial - Codeforces - Code 3",
          "code": "long n = in.nextLong();\n        long min = Long.MAX_VALUE;\n        long idx = -1;\n        Set<Long> set = new HashSet<>();\n        boolean flag = false;\n        for(int i=0;i<n;i++){\n            long val = in.nextLong();\n            if(set.contains(val))\n                flag = true;\n            if(val<min) {\n                min = val;\n                idx = i;\n            }\n            set.add(val);\n        }\n        out.println((flag)?\"Still Rozdil\":idx+1);\n\n        out.close();\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4849",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n    vector<int> t = inf.readInts(n, 1, 1000000000, \"t_i\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n    vector<int> t = inf.readInts(n, 1, 1000000000, \"t_i\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n    vector<int> t = inf.readInts(n, 1, 1000000000, \"t_i\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare sequences of tokens\");\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string j, p;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n\r\n        ans.readWordTo(j);\r\n        ouf.readWordTo(p);\r\n\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s words differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  compress(j).c_str(), compress(p).c_str());\r\n    }\r\n\r\n    if (ans.seekEof() && ouf.seekEof()) {\r\n        if (n == 1)\r\n            quitf(_ok, \"\\\"%s\\\"\", compress(j).c_str());\r\n        else\r\n            quitf(_ok, \"%d tokens\", n);\r\n    } else {\r\n        if (ans.seekEof())\r\n            quitf(_wa, \"Participant output contains extra tokens\");\r\n        else\r\n            quitf(_wa, \"Unexpected EOF in the participants output\");\r\n    }\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> t(n);\n    if (type == \"random\") {\n        // Generate random t_i values between 1 and 1e9\n        for (int i = 0; i < n; ++i)\n            t[i] = rnd.next(1, 1000000000);\n    } else if (type == \"unique_min\") {\n        // Ensure there is one unique minimum t_i value\n        int min_value = rnd.next(1, 1000000000);\n        int min_pos = rnd.next(0, n - 1);\n        for (int i = 0; i < n; ++i) {\n            if (i == min_pos) {\n                t[i] = min_value;\n            } else {\n                t[i] = rnd.next(min_value + 1, 1000000000);\n            }\n        }\n    } else if (type == \"multiple_min\") {\n        // The minimal value appears multiple times\n        int min_value = rnd.next(1, 1000000000);\n        int num_min = rnd.next(2, n);\n        vector<int> indices(n);\n        for (int i = 0; i < n; ++i) indices[i] = i;\n        shuffle(indices.begin(), indices.end());\n        for (int i = 0; i < n; ++i) {\n            if (i < num_min) {\n                t[indices[i]] = min_value;\n            } else {\n                t[indices[i]] = rnd.next(min_value + 1, 1000000000);\n            }\n        }\n    } else if (type == \"all_equal\") {\n        int value = rnd.next(1, 1000000000);\n        for (int i = 0; i < n; ++i)\n            t[i] = value;\n    } else if (type == \"increasing\") {\n        int value = rnd.next(1, 1000000000 - n);\n        for (int i = 0; i < n; ++i) {\n            t[i] = value + i;\n        }\n    } else if (type == \"decreasing\") {\n        int value = rnd.next(n, 1000000000);\n        for (int i = 0; i < n; ++i) {\n            t[i] = value - i;\n        }\n    } else if (type == \"min_values\") {\n        for (int i = 0; i < n; ++i) {\n            t[i] = 1;\n        }\n    } else if (type == \"max_values\") {\n        for (int i = 0; i < n; ++i) {\n            t[i] = 1000000000;\n        }\n    } else if (type == \"minmax_values\") {\n        int min_value = 1;\n        int max_value = 1000000000;\n        for (int i = 0; i < n; ++i) {\n            if (rnd.next(0, 1) == 0)\n                t[i] = min_value;\n            else\n                t[i] = max_value;\n        }\n    } else if(type == \"one_max_rest_min\") {\n        int min_value = 1;\n        int max_value = 1000000000;\n        int max_pos = rnd.next(0, n - 1);\n        for(int i = 0; i < n; ++i) {\n            if(i == max_pos)\n                t[i] = max_value;\n            else\n                t[i] = min_value;\n        }\n    } else if(type==\"one_min_rest_max\"){\n        int min_value = 1;\n        int max_value = 1000000000;\n        int min_pos = rnd.next(0, n - 1);\n        for(int i = 0; i < n; ++i) {\n            if(i == min_pos)\n                t[i] = min_value;\n            else\n                t[i] = max_value;\n        }\n    } else {\n        // Default to random\n        for (int i = 0; i < n; ++i)\n            t[i] = rnd.next(1, 1000000000);\n    }\n\n    // Output\n    cout << n << '\\n';\n    for (int i = 0; i < n; ++i) {\n        cout << t[i];\n        if (i != n -1)\n            cout << ' ';\n        else\n            cout << '\\n';\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> t(n);\n    if (type == \"random\") {\n        // Generate random t_i values between 1 and 1e9\n        for (int i = 0; i < n; ++i)\n            t[i] = rnd.next(1, 1000000000);\n    } else if (type == \"unique_min\") {\n        // Ensure there is one unique minimum t_i value\n        int min_value = rnd.next(1, 1000000000);\n        int min_pos = rnd.next(0, n - 1);\n        for (int i = 0; i < n; ++i) {\n            if (i == min_pos) {\n                t[i] = min_value;\n            } else {\n                t[i] = rnd.next(min_value + 1, 1000000000);\n            }\n        }\n    } else if (type == \"multiple_min\") {\n        // The minimal value appears multiple times\n        int min_value = rnd.next(1, 1000000000);\n        int num_min = rnd.next(2, n);\n        vector<int> indices(n);\n        for (int i = 0; i < n; ++i) indices[i] = i;\n        shuffle(indices.begin(), indices.end());\n        for (int i = 0; i < n; ++i) {\n            if (i < num_min) {\n                t[indices[i]] = min_value;\n            } else {\n                t[indices[i]] = rnd.next(min_value + 1, 1000000000);\n            }\n        }\n    } else if (type == \"all_equal\") {\n        int value = rnd.next(1, 1000000000);\n        for (int i = 0; i < n; ++i)\n            t[i] = value;\n    } else if (type == \"increasing\") {\n        int value = rnd.next(1, 1000000000 - n);\n        for (int i = 0; i < n; ++i) {\n            t[i] = value + i;\n        }\n    } else if (type == \"decreasing\") {\n        int value = rnd.next(n, 1000000000);\n        for (int i = 0; i < n; ++i) {\n            t[i] = value - i;\n        }\n    } else if (type == \"min_values\") {\n        for (int i = 0; i < n; ++i) {\n            t[i] = 1;\n        }\n    } else if (type == \"max_values\") {\n        for (int i = 0; i < n; ++i) {\n            t[i] = 1000000000;\n        }\n    } else if (type == \"minmax_values\") {\n        int min_value = 1;\n        int max_value = 1000000000;\n        for (int i = 0; i < n; ++i) {\n            if (rnd.next(0, 1) == 0)\n                t[i] = min_value;\n            else\n                t[i] = max_value;\n        }\n    } else if(type == \"one_max_rest_min\") {\n        int min_value = 1;\n        int max_value = 1000000000;\n        int max_pos = rnd.next(0, n - 1);\n        for(int i = 0; i < n; ++i) {\n            if(i == max_pos)\n                t[i] = max_value;\n            else\n                t[i] = min_value;\n        }\n    } else if(type==\"one_min_rest_max\"){\n        int min_value = 1;\n        int max_value = 1000000000;\n        int min_pos = rnd.next(0, n - 1);\n        for(int i = 0; i < n; ++i) {\n            if(i == min_pos)\n                t[i] = min_value;\n            else\n                t[i] = max_value;\n        }\n    } else {\n        // Default to random\n        for (int i = 0; i < n; ++i)\n            t[i] = rnd.next(1, 1000000000);\n    }\n\n    // Output\n    cout << n << '\\n';\n    for (int i = 0; i < n; ++i) {\n        cout << t[i];\n        if (i != n -1)\n            cout << ' ';\n        else\n            cout << '\\n';\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -type unique_min\n./gen -n 1 -type all_equal\n./gen -n 1 -type min_values\n./gen -n 1 -type max_values\n\n./gen -n 2 -type unique_min\n./gen -n 2 -type multiple_min\n./gen -n 2 -type minmax_values\n\n./gen -n 10 -type random\n./gen -n 10 -type all_equal\n./gen -n 10 -type increasing\n./gen -n 10 -type decreasing\n\n./gen -n 100 -type unique_min\n./gen -n 100 -type multiple_min\n./gen -n 100 -type random\n\n./gen -n 1000 -type unique_min\n./gen -n 1000 -type multiple_min\n./gen -n 1000 -type one_min_rest_max\n./gen -n 1000 -type one_max_rest_min\n\n./gen -n 100000 -type unique_min\n./gen -n 100000 -type multiple_min\n./gen -n 100000 -type min_values\n./gen -n 100000 -type max_values\n./gen -n 100000 -type minmax_values\n\n./gen -n 100000 -type random\n./gen -n 100000 -type increasing\n./gen -n 100000 -type decreasing\n\n./gen -n 99999 -type unique_min\n./gen -n 50000 -type multiple_min\n\n./gen -n 100000 -type one_min_rest_max\n./gen -n 100000 -type one_max_rest_min\n\n./gen -n 10 -type min_values\n./gen -n 10 -type max_values\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T19:48:44.127139",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "205/B",
      "title": "B. Little Elephant and Sorting",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test0.5 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains a single integer n (1 ≤ n ≤ 105) — the size of array a. The next line contains n integers, separated by single spaces — array a (1 ≤ ai ≤ 109). The array elements are listed in the line in the order of their index's increasing.",
      "output_spec": "OutputIn a single line print a single integer — the answer to the problem.Please, do not use the %lld specifier to read or write 64-bit integers in С++. It is preferred to use the cin, cout streams or the %I64d specifier.",
      "sample_tests": "ExamplesInputCopy31 2 3OutputCopy0InputCopy33 2 1OutputCopy2InputCopy47 4 1 47OutputCopy6",
      "description": "B. Little Elephant and Sorting\n\ntime limit per test0.5 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains a single integer n (1 ≤ n ≤ 105) — the size of array a. The next line contains n integers, separated by single spaces — array a (1 ≤ ai ≤ 109). The array elements are listed in the line in the order of their index's increasing.\n\nOutputIn a single line print a single integer — the answer to the problem.Please, do not use the %lld specifier to read or write 64-bit integers in С++. It is preferred to use the cin, cout streams or the %I64d specifier.\n\nInputCopy31 2 3OutputCopy0InputCopy33 2 1OutputCopy2InputCopy47 4 1 47OutputCopy6\n\nInputCopy31 2 3\n\nOutputCopy0\n\nInputCopy33 2 1\n\nOutputCopy2\n\nInputCopy47 4 1 47\n\nOutputCopy6\n\nNoteIn the first sample the array is already sorted in the non-decreasing order, so the answer is 0.In the second sample you need to perform two operations: first increase numbers from second to third (after that the array will be: [3, 3, 2]), and second increase only the last element (the array will be: [3, 3, 3]).In the third sample you should make at least 6 steps. The possible sequence of the operations is: (2; 3), (2; 3), (2; 3), (3; 3), (3; 3), (3; 3). After that the array converts to [7, 7, 7, 47].",
      "solutions": [
        {
          "title": "Codeforces Round #129 - Codeforces",
          "content": "Hi!Time brings to you next Codeforces round, this time it is with number 129. It will take place in 11.07.2012 at 19:30 (Moscow time). This time the problems are authored by me, Vitaliy Herasymiv. Long time ago I was the author of 4 Codeforces rounds, they were about lucky numbers. But, unfortunately, nothing is constant, so this time there will be no problems about lucky numbers.A lot of help in preparing of the problems was from Gerald Agapov (Gerald), Alexander Kouprin (Alex_KPR), Vitaly Aksenov (Aksenov239), The problems were translated to English by Maria Belova (Delinur). Thanks to all of them.I hope you will like this all.Good Luck!Div1:Thanks all! The results are the following: tourist (now tourist become first Codeforces target, congratulations to him) winger RAVEman rng_58 RAD bmerry Shik Div2: xiaoshua2 ahm.kam_92 HanzhongBall_Quanling daidailanlan You can read editorials here.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/4848",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 901
        },
        {
          "title": "Codeforces Round #129 — Editorial - Codeforces",
          "content": "205A - Little Elephant and RozdilThis problem was the simplest in the problemset. All you need to do is just to sort all distances (keeping track on all indices). If the first two distances are equal, just output \"Still Rozdil\", otherwise output the index of the first element of the array.The complexity is O(NlogN).205B - Little Elephant and SortingIn this problem you need to notice the fact (which can be proven, but it is almost obvious) that if you are doing some operation for interval from l to r (inclusive), r must be equal to n. This is becuase when you add something to all right part the answer can't be worse. After that you need to go from left to right and greedly add appropriate number of turns.The complexity is O(N).205C - Little Elephant and IntervalIt is well-known that for such problem you need to write function F(x) which solves the problem for the interval 0..x, and the answer then is F(r) - F(l - 1).Now you need to write F(x) function. If x < 10, then answer is, of course, equal to x. Otherwise, let len be the length of x, x' — the integer x but without first and last digits, xi — the i-th digit of integer x (from left to right, starting from 0). Interate through all possible first digit d (which is the last at the same time) and through the length i of the number. Then if i < len - 2 or (i = len - 2 and d < x0) you need to add 10i to the answer. Otherwise, if i = len - 2 and d = x0 you need to add x' to the answer. Finally, if i = len - 2 and d = x0 and xlen - 1 ≥ d add 1 to the answer.This problems also can be solved using DP.205D - Little Elephant and CardsIt is nice to use the map structure in this problem, but you can solve it without map (using sorting and binary serach). Lets iterate through all possible colors that we have and suppose that this currect color is the one that will make our set funny. The minimal number through all this will be the answer. To find the minimal number of turns to make our set funny using current color we need to know two numbers: the number of cards with current color on the front side and the number of cards with the current color on back side (but not at the same time). Let it be integers a and b. Let m = (n + 1) / 2 — the minimal number of the same cards required to get the funny set. Then if a + b < m it is impossible to make set funny using current color at all. If a ≥ m then the answer is 0, otherwise the answer is m - a.205E - Little Elephant and Furik and RubikThis problem is to find the expected value. Important fact here is the linearity of the expected value. This means that we can for each element of the first strings find the probability that exactly this element will me matched with some other (but, of course, equal) from the second string. The answer will be the sum of all such probabilities.Let the current character of the first string be the i-th character (1-based numeration). Firstly we try to solve problem in O(N2) time. Namely, as it was said above, we need to find the number of such pairs of substrings that i-th character (which is on probably some other position in substring) is the same as the corresponding character of the second substring. Iterate through all j (j ≤ i) such that Ai = Bj. The number of such pairs of substrings that have match in that characters is j(n - i + 1) (considering 1-based numeration). This is O(N2). And because we need to find the sum of such values for all possible j, we can rewrite it as Si(n - i + 1), where Si equals to the sum of all integers j (j ≤ i) that Ai = Bi. Array S can be simply computed in a linear time. Analogically you should process all indices to the right from i.After we know the number of pairs of substrings with the match with the i-th character (let it be count), the probability is count / total, where total is the total number of pair of substrings (it can be found by loop or with some simple formula).The comlexity is O(N).204D - Little Elephant and Retro StringsFirstly we should solve following subproblem: for each prefix find the number of it's fillings such that there is no consecutive block of k characters B. Let it be F(x), where x is the index in of the last character if the prefix. Assing F(x) = F(x - 1) * cnt, where cnt = 2 if Sx = 'X' and 1 otherwise. After such assing there may be some bad filling included to F(x). Since we suppouse that F(x - 1) is caclulated correctly, all bad filling must contain blocks of k charcters B only at the end of the prefix (they may be included only if substring Sx - k + 1..x doesn't contain characters W and character Sx - k is not B). So, if it's possible, we must subtract from F(x) value F(x - k - 1), because it's exactly the number of bad fillings.With the same DP you should you calc the same values for suffixes (but this time changing B by W and vice versa). Now we should carefully calculate the result in such way that now repeatings occur. Let iterate (from right to left) through all possible positions of the first blocks of k characters B (this means that we suppose that no block occur to the left). Using our DP we can simply find the number of fillings of all characters to the left from that block in such way that no another blocks of k characters B occur. Considering O(N2) solutions, we can iterate through all possible indexes of the begging of the last block of k characters W (again we suppose that this blocks must be the last and no another may occur to the right) and agin using our DP count the number of fillings to the right. We don't care what is between that blocks, so we just multiply answer by 2^(the number of characters X between blocks). But, since we are going from right to the left, we can just keep tracking on all possible last blocks and get O(N) solution.204E - Little Elephant and StringsTo solve this problems we can use suffix array. More information about suffix arrays you can find in the Internet.Firstly, concatenate all strings into the one separating consecutive strings by some unique characters (it was also useful to not use strings, but arrays of integers). For example, three strings abc, a, ab may be concatenated in the following way: abc#a@ab. Now we should build suffix array using this total string, this allows to us to sort all cyclic shifts of the string. After that each cyclic shift will either begin with additional character or the character from the input strings.Notice now that to find the result we need to find for each cyclic shift (begging of which doesn't contain additional character) the largest size of it's prefix such that this prefix is substring of at least k different input strings. This value can be found by binary search, but for this we need some function F(x, len) which can answer the questions: how many input strings contain prefix of size len of x cyclic shift as a substring.How to make F(x, len)? Look at all cyclic shifts, prefix of size len of which is equal to preifx of size len of x-th shift. Since all shifts are sorted lexicoraphically, this set of shifts can be represented as integral [l;r] of indices of shifts (1 ≤ l ≤ x ≤ r). How to find l and r? For each pair of consecutive shifts we can find it's greatest common prefix (using properties of suffix array). Than l and r can be found using RMQ. For l we need to know the rigthmost pair of shift (but to the left from x) that their greatest common prefix is less than len. Analogically we can find r. After that we have interval [l;r] and we need to find the number of different input strings that belongs to the shifts from l-th to r-th (actually, we need to find the number of different integer on interval). But, notice that we dont need the exactly number of different integers, we need to know just it is at least k or not. So let L[i] equals to the greatest j (j ≤ i) such that the number of different integers on interval [j;i] is equal to k. Then if L[r] ≥ l, obiously, interval [l;r] will also contains at least k different. So F(x, len) is done.The only thing to done is to fill array L. This is pretty simple using set (but it is possible without it but using RMQ). We will go from left to righ at keep the indices of the last (the rightmost) k different integers in the set. If some integer comes, then (if it was earlier) we need to erase this previous index from set (if it was still in) and insert new current. While the size of set is greater than k, we should erase the minimal number from it. Then if in some position i the size of the set (after above changings) is equal to k, than L[i] is equal to the minimal number in set.Since we O(N) times use binary search, and function F(x, len) works in O(logN) time, the total complexity is O(Nlog2N).",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/4849",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 205\\s*B"
          },
          "content_length": 8674
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #129 - Codeforces - Code 1",
          "code": "He has n cards, each has exactly two colors",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4848",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #129 - Codeforces - Code 2",
          "code": "The color of the front of the card may coincide with the color of the back of the card",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4848",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #129 - Codeforces - Code 3",
          "code": "public void solve() throws IOException {\n\t\tlong l = nextLong();\n\t\tlong r = nextLong();\n\t\tout.println(f(r) - f(l - 1));\n\t}\n\t\n\tlong f(long x) {\n\t\tif (x < 10) {\n\t\t\treturn x;\n\t\t}\n\t\tString s = Long.toString(x);\n\t\treturn (x / 10 - 1) + (s.charAt(0) <= s.charAt(s.length() - 1) ? 1 : 0) + 9;\n\t}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4848",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #129 - Codeforces - Code 4",
          "code": "public void solve() throws IOException {\n\t\tlong l = nextLong();\n\t\tlong r = nextLong();\n\t\tout.println(f(r) - f(l - 1));\n\t}\n\t\n\tlong f(long x) {\n\t\tif (x < 10) {\n\t\t\treturn x;\n\t\t}\n\t\tString s = Long.toString(x);\n\t\treturn (x / 10 - 1) + (s.charAt(0) <= s.charAt(s.length() - 1) ? 1 : 0) + 9;\n\t}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4848",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #129 - Codeforces - Code 5",
          "code": "double div=n*(n+1)*(2*n+1);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4848",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #129 - Codeforces - Code 6",
          "code": "double div=n*(n+1)*(2*n+1);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4848",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #129 — Editorial - Codeforces - Code 1",
          "code": "ll D[10][20][2];\nstring w;\n\nlong long d(int i, int j, int k) {\n    if (D[i][j][k] != -1) return D[i][j][k];\n    if (j == 1) {\n        if (i == 0 and k == 0) return 9;\n        if (i == 0 and k == 1) return w[w.size() - 1] - '0';\n        else if (k == 1) return i <= w[w.size() - 1] - '0';\n        else return 1;\n    }\n    long long cont = 0;\n    for (int e = 0; e < ((k == 0)?10:w[w.size() - j] - '0' + 1); ++e)\n      cont += d((i == 0)?e:i, j-1, (k == 0)?0:e == w[w.size() - j] - '0');\n    return D[i][j][k] = cont;\n}\n\nlong long F(long long x) {\n    memset(D,-1,sizeof(D));\n    stringstream l; l << x;\n    l >> w;\n    return d(0,w.size(),1);    \n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4849",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #129 — Editorial - Codeforces - Code 2",
          "code": "ll D[10][20][2];\nstring w;\n\nlong long d(int i, int j, int k) {\n    if (D[i][j][k] != -1) return D[i][j][k];\n    if (j == 1) {\n        if (i == 0 and k == 0) return 9;\n        if (i == 0 and k == 1) return w[w.size() - 1] - '0';\n        else if (k == 1) return i <= w[w.size() - 1] - '0';\n        else return 1;\n    }\n    long long cont = 0;\n    for (int e = 0; e < ((k == 0)?10:w[w.size() - j] - '0' + 1); ++e)\n      cont += d((i == 0)?e:i, j-1, (k == 0)?0:e == w[w.size() - j] - '0');\n    return D[i][j][k] = cont;\n}\n\nlong long F(long long x) {\n    memset(D,-1,sizeof(D));\n    stringstream l; l << x;\n    l >> w;\n    return d(0,w.size(),1);    \n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4849",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #129 — Editorial - Codeforces - Code 3",
          "code": "long n = in.nextLong();\n        long min = Long.MAX_VALUE;\n        long idx = -1;\n        Set<Long> set = new HashSet<>();\n        boolean flag = false;\n        for(int i=0;i<n;i++){\n            long val = in.nextLong();\n            if(set.contains(val))\n                flag = true;\n            if(val<min) {\n                min = val;\n                idx = i;\n            }\n            set.add(val);\n        }\n        out.println((flag)?\"Still Rozdil\":idx+1);\n\n        out.close();\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4849",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n    for (int i = 1; i <= n; i++) {\n        int ai = inf.readInt(1, 1000000000, \"a[\" + to_string(i) + \"]\");\n        if (i < n)\n            inf.readChar(' ');\n        else\n            inf.readEoln();\n    }\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n    for (int i = 1; i <= n; i++) {\n        int ai = inf.readInt(1, 1000000000, \"a[\" + to_string(i) + \"]\");\n        if (i < n)\n            inf.readChar(' ');\n        else\n            inf.readEoln();\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n    for (int i = 1; i <= n; i++) {\n        int ai = inf.readInt(1, 1000000000, \"a[\" + to_string(i) + \"]\");\n        if (i < n)\n            inf.readChar(' ');\n        else\n            inf.readEoln();\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    // Read parameters\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> a(n);\n\n    if (type == \"sorted\") {\n        // Generate a sorted array\n        a[0] = rnd.next(1, 10);\n        for (int i = 1; i < n; ++i) {\n            int delta = rnd.next(0, 10);\n            a[i] = a[i - 1] + delta;\n            if (a[i] > (int)1e9) a[i] = (int)1e9;\n        }\n    } else if (type == \"reverse\") {\n        // Generate a reverse sorted array\n        a[0] = rnd.next(n, (int)1e9);\n        for (int i = 1; i < n; ++i) {\n            a[i] = a[i - 1] - 1;\n            if (a[i] < 1) a[i] = 1;\n        }\n    } else if (type == \"constant\") {\n        // All elements are the same\n        int val = rnd.next(1, (int)1e9);\n        for (int i = 0; i < n; ++i) {\n            a[i] = val;\n        }\n    } else if (type == \"random\") {\n        // Random elements within the full range\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, (int)1e9);\n        }\n    } else if (type == \"minmax\") {\n        // Alternating between minimum and maximum values\n        for (int i = 0; i < n; ++i) {\n            if (i % 2 == 0)\n                a[i] = 1;\n            else\n                a[i] = (int)1e9;\n        }\n    } else if (type == \"hills\") {\n        // Elements increase then decrease\n        int mid = n / 2;\n        int val = rnd.next(1, 10);\n        for (int i = 0; i <= mid; ++i) {\n            a[i] = val;\n            val += rnd.next(0, 10);\n            if (a[i] > (int)1e9) a[i] = (int)1e9;\n        }\n        val = a[mid];\n        for (int i = mid + 1; i < n; ++i) {\n            val -= rnd.next(0, 10);\n            if (val < 1) val = 1;\n            a[i] = val;\n        }\n    } else if (type == \"valleys\") {\n        // Elements decrease then increase\n        int mid = n / 2;\n        int val = rnd.next((int)1e9 - 10 * n, (int)1e9);\n        if (val < 1) val = (int)1e9;\n        for (int i = 0; i <= mid; ++i) {\n            a[i] = val;\n            val -= rnd.next(0, 10);\n            if (val < 1) val = 1;\n        }\n        val = a[mid];\n        for (int i = mid + 1; i < n; ++i) {\n            val += rnd.next(0, 10);\n            if (val > (int)1e9) val = (int)1e9;\n            a[i] = val;\n        }\n    } else if (type == \"duplicates\") {\n        // Many duplicates\n        int num_values = rnd.next(1, min(n, 10));\n        vector<int> vals(num_values);\n        for (int i = 0; i < num_values; ++i) {\n            vals[i] = rnd.next(1, (int)1e9);\n        }\n        for (int i = 0; i < n; ++i) {\n            a[i] = vals[rnd.next(0, num_values - 1)];\n        }\n    } else if (type == \"worst_case\") {\n        // Designed to cause maximum moves\n        a[0] = rnd.next(n, (int)1e9);\n        for (int i = 1; i < n; ++i) {\n            a[i] = a[i - 1] - 1;\n            if (a[i] < 1) a[i] = 1;\n        }\n    } else {\n        // Default to random\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, (int)1e9);\n        }\n    }\n\n    // Output the array\n    printf(\"%d\\n\", n);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d\", a[i]);\n        if (i < n - 1)\n            printf(\" \");\n        else\n            printf(\"\\n\");\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    // Read parameters\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> a(n);\n\n    if (type == \"sorted\") {\n        // Generate a sorted array\n        a[0] = rnd.next(1, 10);\n        for (int i = 1; i < n; ++i) {\n            int delta = rnd.next(0, 10);\n            a[i] = a[i - 1] + delta;\n            if (a[i] > (int)1e9) a[i] = (int)1e9;\n        }\n    } else if (type == \"reverse\") {\n        // Generate a reverse sorted array\n        a[0] = rnd.next(n, (int)1e9);\n        for (int i = 1; i < n; ++i) {\n            a[i] = a[i - 1] - 1;\n            if (a[i] < 1) a[i] = 1;\n        }\n    } else if (type == \"constant\") {\n        // All elements are the same\n        int val = rnd.next(1, (int)1e9);\n        for (int i = 0; i < n; ++i) {\n            a[i] = val;\n        }\n    } else if (type == \"random\") {\n        // Random elements within the full range\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, (int)1e9);\n        }\n    } else if (type == \"minmax\") {\n        // Alternating between minimum and maximum values\n        for (int i = 0; i < n; ++i) {\n            if (i % 2 == 0)\n                a[i] = 1;\n            else\n                a[i] = (int)1e9;\n        }\n    } else if (type == \"hills\") {\n        // Elements increase then decrease\n        int mid = n / 2;\n        int val = rnd.next(1, 10);\n        for (int i = 0; i <= mid; ++i) {\n            a[i] = val;\n            val += rnd.next(0, 10);\n            if (a[i] > (int)1e9) a[i] = (int)1e9;\n        }\n        val = a[mid];\n        for (int i = mid + 1; i < n; ++i) {\n            val -= rnd.next(0, 10);\n            if (val < 1) val = 1;\n            a[i] = val;\n        }\n    } else if (type == \"valleys\") {\n        // Elements decrease then increase\n        int mid = n / 2;\n        int val = rnd.next((int)1e9 - 10 * n, (int)1e9);\n        if (val < 1) val = (int)1e9;\n        for (int i = 0; i <= mid; ++i) {\n            a[i] = val;\n            val -= rnd.next(0, 10);\n            if (val < 1) val = 1;\n        }\n        val = a[mid];\n        for (int i = mid + 1; i < n; ++i) {\n            val += rnd.next(0, 10);\n            if (val > (int)1e9) val = (int)1e9;\n            a[i] = val;\n        }\n    } else if (type == \"duplicates\") {\n        // Many duplicates\n        int num_values = rnd.next(1, min(n, 10));\n        vector<int> vals(num_values);\n        for (int i = 0; i < num_values; ++i) {\n            vals[i] = rnd.next(1, (int)1e9);\n        }\n        for (int i = 0; i < n; ++i) {\n            a[i] = vals[rnd.next(0, num_values - 1)];\n        }\n    } else if (type == \"worst_case\") {\n        // Designed to cause maximum moves\n        a[0] = rnd.next(n, (int)1e9);\n        for (int i = 1; i < n; ++i) {\n            a[i] = a[i - 1] - 1;\n            if (a[i] < 1) a[i] = 1;\n        }\n    } else {\n        // Default to random\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, (int)1e9);\n        }\n    }\n\n    // Output the array\n    printf(\"%d\\n\", n);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d\", a[i]);\n        if (i < n - 1)\n            printf(\" \");\n        else\n            printf(\"\\n\");\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -type sorted\n./gen -n 1 -type reverse\n./gen -n 1 -type constant\n./gen -n 1 -type random\n\n./gen -n 2 -type sorted\n./gen -n 2 -type reverse\n./gen -n 2 -type random\n\n./gen -n 5 -type minmax\n./gen -n 5 -type duplicates\n\n./gen -n 10 -type sorted\n./gen -n 10 -type reverse\n./gen -n 10 -type worst_case\n\n./gen -n 50 -type random\n./gen -n 50 -type minmax\n\n./gen -n 100 -type duplicates\n./gen -n 100 -type hills\n./gen -n 100 -type valleys\n\n./gen -n 1000 -type sorted\n./gen -n 1000 -type reverse\n./gen -n 1000 -type random\n./gen -n 1000 -type worst_case\n\n./gen -n 10000 -type random\n./gen -n 10000 -type constant\n\n./gen -n 99999 -type random\n./gen -n 99999 -type worst_case\n\n./gen -n 100000 -type sorted\n./gen -n 100000 -type reverse\n./gen -n 100000 -type constant\n./gen -n 100000 -type minmax\n./gen -n 100000 -type random\n./gen -n 100000 -type duplicates\n./gen -n 100000 -type worst_case\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T19:48:46.161751",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "205/C",
      "title": "C. Маленький Слоник и промежуток",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест2 секунды",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеВ единственной строке задана пара целых чисел l и r (1 ≤ l ≤ r ≤ 1018) — границы промежутка.Пожалуйста, не используйте спецификатор %lld для чтения или записи 64-х битовых чисел на С++. Рекомендуется использовать потоки cin, cout или спецификатор %I64d.",
      "output_spec": "Выходные данныеВ единственной строке выведите одно целое число — ответ на задачу.",
      "sample_tests": "ПримерыВходные данныеСкопировать2 47Выходные данныеСкопировать12Входные данныеСкопировать47 1024Выходные данныеСкопировать98",
      "description": "C. Маленький Слоник и промежуток\n\nограничение по времени на тест2 секунды\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвыводstdout\n\nВходные данныеВ единственной строке задана пара целых чисел l и r (1 ≤ l ≤ r ≤ 1018) — границы промежутка.Пожалуйста, не используйте спецификатор %lld для чтения или записи 64-х битовых чисел на С++. Рекомендуется использовать потоки cin, cout или спецификатор %I64d.\n\nВходные данные\n\nВыходные данныеВ единственной строке выведите одно целое число — ответ на задачу.\n\nВыходные данные\n\nВходные данныеСкопировать2 47Выходные данныеСкопировать12Входные данныеСкопировать47 1024Выходные данныеСкопировать98\n\nВходные данныеСкопировать2 47\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать12\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать47 1024\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать98\n\nВыходные данныеСкопировать\n\nСкопировать\n\nПримечаниеВ первом примере в ответ входят следующие числа: 2, 3, 4, 5, 6, 7, 8, 9, 11, 22, 33, 44.",
      "solutions": [
        {
          "title": "Codeforces Round #129 - Codeforces",
          "content": "Привет!Вот и пришло время очередного раунда Codeforces, а именно раунда номер 129. Он состоится 11.07.2012 в 19:30 (по Москве). В этот раз задачи для Вас готовил я. В далеком прошлом я уже был 4 раза автором задач для Codeforces, тогда задачи были в основном о счастливых числах. Но ничего не вечно, поэтому в этот раз не будет задач о счастливых числах и тематика задач будет различной.Помогал мне готовить задачи Геральд Агапов (Gerald), Александр Куприн (Alex_KPR), Аксёнов Виталик (Aksenov239), а традиционно задачи перевела Мария Белова (Delinur), за что им всем спасибо.Надеюсь задачи вам понравятся и все пройдет гладко и я преждевременно не опубликую разбор, который сейчас у меня в блоге.Держитесь!Спасибо всем за участие. Результаты оказались следующими:Div1: tourist (теперь tourist первый в мире таргет Codeforces, с чем его поздравляем) winger RAVEman rng_58 RAD bmerry Shik Div2: xiaoshua2 ahm.kam_92 HanzhongBall_Quanling daidailanlan Разбор задач можно найти здесь.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/4848",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 981
        },
        {
          "title": "Codeforces Round #129 — Разбор задач - Codeforces",
          "content": "205A - Маленький Слоник и РоздолЭто была самая простая задача из набора. Нужно просто отсортировать все расстояния (при этом поддерживая индексы) и, если первые два расстояния равны, вывести \"Still Rozdil\", иначе вывести индекс первого элемента.Сложность решения O(NlogN).205B - Маленький Слоник и сортировкаВ этой задачи нужно заметить тот факт (который несложно доказать, но он понятен даже интуитивно), что, так как массив нужно сделать неубывающим, если делать какую-то операцию, то r (правая граница) должна быть равна n. Действительно, подняв правую часть массива мы точно не ухудшим результат. После этого нужно идти слева направо и жадно делать необходимое количество операций на каждом шагу.Сложность решения O(N).205C - Маленький Слоник и промежутокЕстественно, для того что-бы решить задачу нужно написать функцию F(x) которая будет решать задачу на промежутке 0..x, тогда ответом будет F(r) - F(l - 1). Опишем реализацию функции F(x). Если x < 10, результатом будем сам x. Пусть len — длина числа x, а x' — число x без первой и последней цифр, а xi — i-я цифра числа x (от 0 слева направо). Переберем первую цифру d (она и будет последней) и длину того что внутри (пусть это будет i). Тогда если i < len - 2 или (i = len - 2 и d < x0), к ответу нужно добавить 10i. Иначе, если i = len - 2 и d = x0 то к ответу нужно добавить x', а если еще и i = len - 2, d = x0 и xlen - 1 ≥ d то нужно добавить еще 1 к ответу. Также эту задачу можно было решить используя ДП.205D - Маленький Слоник и карточкиЭту задачу можно удобно решить используя структуру map, но можно и обойтись без нее (используя сортировку и бинарный поиск). Давайте переберем цвет-кандидат который и приведет к веселости набора, для каждого цвета узнаем минимальное количество переворачиваний (если возможно вообще) и выберем минимум. Если никакой цвет не подходит, ответ \"-1\". Для того чтобы найти минимальное количество переворачиваний нам нужно узнать два числа — количество карточек которые изначально лежат текущим цветом вверх, а также количество карточек у которых сзади есть текущий цвет (при этом сверху какой-то другой). Пусть это числа a и b. соответственно. Пусть m = (n + 1) / 2 — минимальное количество одинаковых карточек необходимых для того, что-бы сделать набор веселым. Тогда текущий цвет может сделать набор веселым только если a + b ≥ m. Если a ≥ m, то ничего переворачивать не надо, то есть ответ 0, иначе ответ равен m - a.205E - Маленький Слоник и Фурик и РубикЗадача на математическое ожидание. Здесь важно учесть факт линейности математического ожидания, иными словами, ответ для какой-то пары строк это сумма количеств совпадений по каждому символам алфавита. Поэтому давайте для каждого символа первой строки найдем вероятность того, что он войдет в ответ. Тогда общим ответом будет сумма этих вероятностей.Пусть у нас текущий символ в первой строки с номером i (всюду 1-нумерация). Сначала решим задачу за O(N2). Переберем все позиции j левее i (или равные i) такие что Bj = Ai. Тогда для какой-то позиции нужно найти количество возможных пар строк таких, что в них именно эти два символы Ai и Bj совпали. Это количество будет равно j(n - i + 1) (j возможных символов слева и (n - i + 1) справа, поэтому общее количество это их произведение). Это будет O(N2). Так как все это — сумма, то ответ будет равен Si(n - i + 1), где Si — сумма всех позиций j таких, что Bj = Ai. Массив S можно несложно посчитать за линейное время. Аналогичным образом нужно обработать все индексы что правее i. После того как количество пар подстрок в которых i-й символ первой строки имеет совпадение найдено (пусть это count), к ответу нужно добавить count / total, где total — полное количество возможных исходов, его можно найти циклом или несложной формулой.Сложность решения O(N).204D - Маленький Слоник и ретро строкиДля начала нам нужно решить следующую подзадачу: для каждого префикса найти количество его заполнений таких, что он не содержит подстроки длиной k состоящую только из букв B. Пусть это будет F(x), где x это номер последнего символа префикса. Давайте присвоим F(x) = F(x - 1) * cnt, где cnt = 2, если Sx = 'X', 1 иначе. После такого присвоения в результат могли быть включены некоторые способы такие, что блок из k есть в конце префикса (они могли быть включены только если в подстроке Sx - k + 1..x нет букв W, а символ Sx - k не есть B), а это плохо. Поэтому (если такое могло произойти) нужно от F(x) отнять F(x - k - 1), это уберет все плохие варианты.Аналогичное ДП нужно посчитать для для суффиксов (или, иначе говоря, для реверсовной строки S), только здесь нужно избегать блоков из W.Теперь подумаем как организовать все что-бы не появилось повторов. Давайте переберем позицию, в которой будет заканчиваться первый слева блок из k подряд идущих букв B. При этом будем перебирать эту позицию справа налево. Используя ранее подсчитано ДП мы можем найти количество вариантов заполнить все буквы левее так, что-бы там не образовался блок. Если писать решение за O(N2), то мы можем перебрать позицию, в которой будет начинаться первый справа блок из k букв W, аналогичным образом найти количество способов заполнить все правее что-бы там не образовался блок, а символы между левым и правым блоками мы, очевидно, можем заполнять как-угодно. Но, так как мы идем справа налево, мы можем по ходу поддерживать сумму этих количеств. Это обеспечит нам линейность решения. 204E - Маленький Слоник и строкиДля решения данной задачи воспользуемся свойствами суффиксного массива. Болле подробно о суффиксном массиве можно почитать здесь:http://e-maxx.ru/algo/suffix_arrayДля начала нужно конкатенировать все строки в одну, при этом разделяя их какими-то символами которые не встречаются в строках. Например, три строки abc, a, ab можно склеить в одну следующего вида: abc#a@ab. Теперь нам нужно построить суффиксный массив по новой строке, это позволит нам отсортировать все циклические сдвиги строки. При этом первый символ каждого циклического сдвига это либо вспомогательный символ, либо символ какой-то входной строки. Заметим теперь что для того что-бы найти результат нам нужно для каждого циклического сдвига, начало которого принадлежит какой-то входной строке, найти максимальную длину его префикса такую, что этот префикс является подстрокой как минимум k входных строк. Это число можно искать бинарным поиском, но для этого нужно какую-то функцию которая бы отвечала на вопрос: а сколько есть различных входных строк которые содержат префикс длины len циклического сдвига номер x (Пусть это функция F(x, len)).Как же сделать функцию F(x, len)? Рассмотрим все циклические сдвиги, префикс длины len которых ровен префиксу длины len x-го сдвига. Заметим что, так как все сдвиги отсортированы лексикографически, набор таких сдвигов будет представлен каким-то промежутком [l;r] (1 ≤ l ≤ x ≤ r). Как же найти этот промежуток? Для каждой пары соседних сдвигов можно найти их наибольший общий префикс. Тогда l, например, можно найти используя RMQ — для этого нужно найти самую правую пару соседних сдвигов (левее x) таких, что их наибольший общий префикс меньше len. Аналогично можно найти r. После этого у нас есть промежуток [l;r] и нужно найти количество различных строк которые соответствуют этим сдвигам (иными словами, найти количество различных чисел в подмассиве). Но, заметим, что самое количество различных нас не интересует, а интересует только не меньше ли оно за k или нет. Тогда пусть L[i] равно максимальному j (j ≤ i) такому, что количество различных чисел в помассиве [j;i] ровно k. Тогда если L[r] ≥ l то, логично, что и в промежутке [l;r] также будет не меньше k различных чисел.Осталось заполнить массив L. Это довольно просто сделать используя структуру set (можно также использовать RMQ). Будем идти слева направо и в сете поддерживать индексы самых правых k различных чисел. Тогда если поступает какое-то число, то (если оно встречалось раньше) его прежнее вхождение нужно удалить из сета (если оно еще осталось) и вставить текущее. При этом если размер сета превышает k нужно извлекать минимальный элемент. Тогда если в какой-то позиции i размер сета есть k (после описанных выше изменений), это означает, что L[i] ровно минимальному элементу сета.Так как мы O(N) раз используем бинарный поиск, а функция F(x, len) работает за O(logN), финальная асимптотика решения равна O(Nlog2N).",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/4849",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 205\\s*C"
          },
          "content_length": 8301
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #129 - Codeforces - Code 1",
          "code": "He has n cards, each has exactly two colors",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4848",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #129 - Codeforces - Code 2",
          "code": "The color of the front of the card may coincide with the color of the back of the card",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4848",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #129 - Codeforces - Code 3",
          "code": "5\n1 1\n1 1\n3 4\n5 6\n7 8",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4848",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #129 - Codeforces - Code 4",
          "code": "5\n1 1\n1 1\n3 4\n5 6\n7 8",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4848",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #129 - Codeforces - Code 5",
          "code": "3\n1 1\n2 2\n3 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4848",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #129 - Codeforces - Code 6",
          "code": "3\n1 1\n2 2\n3 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4848",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #129 - Codeforces - Code 7",
          "code": "public void solve() throws IOException {\n\t\tlong l = nextLong();\n\t\tlong r = nextLong();\n\t\tout.println(f(r) - f(l - 1));\n\t}\n\t\n\tlong f(long x) {\n\t\tif (x < 10) {\n\t\t\treturn x;\n\t\t}\n\t\tString s = Long.toString(x);\n\t\treturn (x / 10 - 1) + (s.charAt(0) <= s.charAt(s.length() - 1) ? 1 : 0) + 9;\n\t}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4848",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #129 - Codeforces - Code 8",
          "code": "public void solve() throws IOException {\n\t\tlong l = nextLong();\n\t\tlong r = nextLong();\n\t\tout.println(f(r) - f(l - 1));\n\t}\n\t\n\tlong f(long x) {\n\t\tif (x < 10) {\n\t\t\treturn x;\n\t\t}\n\t\tString s = Long.toString(x);\n\t\treturn (x / 10 - 1) + (s.charAt(0) <= s.charAt(s.length() - 1) ? 1 : 0) + 9;\n\t}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4848",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #129 - Codeforces - Code 9",
          "code": "double div=n*(n+1)*(2*n+1);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4848",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #129 - Codeforces - Code 10",
          "code": "double div=n*(n+1)*(2*n+1);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4848",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #129 — Разбор задач - Codeforces - Code 1",
          "code": "void randomShuffle(int[] arr) {\n    Random rnd = new Random();\n    for (int i = arr.length() - 1; i >= 0; i--) {\n        int pos = rnd.nextInt(i + 1);\n        int temp = arr[pos];\n        arr[pos] = arr[i];\n        arr[i] = temp;\n    }\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4849",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #129 — Разбор задач - Codeforces - Code 2",
          "code": "void randomShuffle(int[] arr) {\n    Random rnd = new Random();\n    for (int i = arr.length() - 1; i >= 0; i--) {\n        int pos = rnd.nextInt(i + 1);\n        int temp = arr[pos];\n        arr[pos] = arr[i];\n        arr[i] = temp;\n    }\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4849",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #129 — Разбор задач - Codeforces - Code 3",
          "code": "ll D[10][20][2];\nstring w;\n\nlong long d(int i, int j, int k) {\n    if (D[i][j][k] != -1) return D[i][j][k];\n    if (j == 1) {\n        if (i == 0 and k == 0) return 9;\n        if (i == 0 and k == 1) return w[w.size() - 1] - '0';\n        else if (k == 1) return i <= w[w.size() - 1] - '0';\n        else return 1;\n    }\n    long long cont = 0;\n    for (int e = 0; e < ((k == 0)?10:w[w.size() - j] - '0' + 1); ++e)\n      cont += d((i == 0)?e:i, j-1, (k == 0)?0:e == w[w.size() - j] - '0');\n    return D[i][j][k] = cont;\n}\n\nlong long F(long long x) {\n    memset(D,-1,sizeof(D));\n    stringstream l; l << x;\n    l >> w;\n    return d(0,w.size(),1);    \n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4849",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #129 — Разбор задач - Codeforces - Code 4",
          "code": "ll D[10][20][2];\nstring w;\n\nlong long d(int i, int j, int k) {\n    if (D[i][j][k] != -1) return D[i][j][k];\n    if (j == 1) {\n        if (i == 0 and k == 0) return 9;\n        if (i == 0 and k == 1) return w[w.size() - 1] - '0';\n        else if (k == 1) return i <= w[w.size() - 1] - '0';\n        else return 1;\n    }\n    long long cont = 0;\n    for (int e = 0; e < ((k == 0)?10:w[w.size() - j] - '0' + 1); ++e)\n      cont += d((i == 0)?e:i, j-1, (k == 0)?0:e == w[w.size() - j] - '0');\n    return D[i][j][k] = cont;\n}\n\nlong long F(long long x) {\n    memset(D,-1,sizeof(D));\n    stringstream l; l << x;\n    l >> w;\n    return d(0,w.size(),1);    \n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4849",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #129 — Разбор задач - Codeforces - Code 5",
          "code": "long n = in.nextLong();\n        long min = Long.MAX_VALUE;\n        long idx = -1;\n        Set<Long> set = new HashSet<>();\n        boolean flag = false;\n        for(int i=0;i<n;i++){\n            long val = in.nextLong();\n            if(set.contains(val))\n                flag = true;\n            if(val<min) {\n                min = val;\n                idx = i;\n            }\n            set.add(val);\n        }\n        out.println((flag)?\"Still Rozdil\":idx+1);\n\n        out.close();\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4849",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    long long l = inf.readLong(1LL, 1000000000000000000LL, \"l\");\n    inf.readSpace();\n    long long r = inf.readLong(l, 1000000000000000000LL, \"r\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    long long l = inf.readLong(1LL, 1000000000000000000LL, \"l\");\n    inf.readSpace();\n    long long r = inf.readLong(l, 1000000000000000000LL, \"r\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    long long l = inf.readLong(1LL, 1000000000000000000LL, \"l\");\n    inf.readSpace();\n    long long r = inf.readLong(l, 1000000000000000000LL, \"r\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nlong long pow10(int exponent) {\n    long long res = 1;\n    for (int i = 0; i < exponent; ++i) {\n        res *= 10;\n    }\n    return res;\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    string type = opt<string>(\"type\", \"random\");\n    long long l, r;\n    \n    if (type == \"min_input\") {\n        l = 1;\n        r = 1;\n    } else if (type == \"max_input\") {\n        l = (long long)1e18;\n        r = (long long)1e18;\n    } else if (type == \"l_equals_r\") {\n        l = rnd.next(1LL, (long long)1e18);\n        r = l;\n    } else if (type == \"random_small\") {\n        l = rnd.next(1LL, (long long)1e5);\n        r = rnd.next(l, l + (long long)1e5);\n        if (r > (long long)1e18) r = (long long)1e18;\n    } else if (type == \"random_large\") {\n        l = rnd.next(1LL, (long long)1e18 - (long long)1e12);\n        r = rnd.next(l, l + (long long)1e12);\n        if (r > (long long)1e18) r = (long long)1e18;\n    } else if (type == \"full_range\") {\n        l = 1;\n        r = (long long)1e18;\n    } else if (type == \"power_of_ten\") {\n        int exponent = rnd.next(1, 18);\n        l = pow10(exponent - 1);\n        r = pow10(exponent) - 1;\n    } else if (type == \"around_power_of_ten\") {\n        int exponent = rnd.next(1, 17); // avoid exceeding 1e18\n        long long pow_ten = pow10(exponent);\n        l = pow_ten - rnd.next(1LL, (long long)1e3);\n        if (l < 1) l = 1;\n        r = pow_ten + rnd.next(1LL, (long long)1e3);\n        if (r > (long long)1e18) r = (long long)1e18;\n    } else if (type == \"no_valid_numbers\") {\n        // Generate l and r where no numbers have first digit == last digit\n        int fd = rnd.next(1, 8); // First digit 1..8\n        int ld = fd + 1;         // Last digit greater than first digit\n        int len = rnd.next(2, 18); // Length of the number\n        string l_str = to_string(fd);\n        for (int i = 1; i < len - 1; ++i)\n            l_str += '0';\n        l_str += to_string(ld);\n        l = stoll(l_str);\n        r = l + rnd.next(0LL, 1000LL);\n        if (r > (long long)1e18) r = (long long)1e18;\n    } else if (type == \"all_valid_numbers\") {\n        int d = rnd.next(1,9); // Digit from 1 to 9\n        int len_l = rnd.next(1, 18);\n        int len_r = len_l + rnd.next(0,2);\n        if (len_r > 18) len_r = 18;\n\n        // Construct l\n        string l_str = to_string(d);\n        if (len_l == 1) {\n            l = d;\n        } else {\n            for (int i = 1; i < len_l -1; ++i)\n                l_str += '0';\n            l_str += to_string(d);\n            l = stoll(l_str);\n        }\n        // Construct r\n        string r_str = to_string(d);\n        if (len_r == 1) {\n            r = d;\n        } else {\n            for (int i = 1; i < len_r -1; ++i)\n                r_str += '9';\n            r_str += to_string(d);\n            r = stoll(r_str);\n        }\n\n        if (l > r) swap(l, r);\n        if (r > (long long)1e18) r = (long long)1e18;\n    } else {\n        // Default is random\n        l = rnd.next(1LL, (long long)1e18 - 1);\n        r = rnd.next(l, (long long)1e18);\n    }\n\n    cout << l << \" \" << r << endl;\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nlong long pow10(int exponent) {\n    long long res = 1;\n    for (int i = 0; i < exponent; ++i) {\n        res *= 10;\n    }\n    return res;\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    string type = opt<string>(\"type\", \"random\");\n    long long l, r;\n    \n    if (type == \"min_input\") {\n        l = 1;\n        r = 1;\n    } else if (type == \"max_input\") {\n        l = (long long)1e18;\n        r = (long long)1e18;\n    } else if (type == \"l_equals_r\") {\n        l = rnd.next(1LL, (long long)1e18);\n        r = l;\n    } else if (type == \"random_small\") {\n        l = rnd.next(1LL, (long long)1e5);\n        r = rnd.next(l, l + (long long)1e5);\n        if (r > (long long)1e18) r = (long long)1e18;\n    } else if (type == \"random_large\") {\n        l = rnd.next(1LL, (long long)1e18 - (long long)1e12);\n        r = rnd.next(l, l + (long long)1e12);\n        if (r > (long long)1e18) r = (long long)1e18;\n    } else if (type == \"full_range\") {\n        l = 1;\n        r = (long long)1e18;\n    } else if (type == \"power_of_ten\") {\n        int exponent = rnd.next(1, 18);\n        l = pow10(exponent - 1);\n        r = pow10(exponent) - 1;\n    } else if (type == \"around_power_of_ten\") {\n        int exponent = rnd.next(1, 17); // avoid exceeding 1e18\n        long long pow_ten = pow10(exponent);\n        l = pow_ten - rnd.next(1LL, (long long)1e3);\n        if (l < 1) l = 1;\n        r = pow_ten + rnd.next(1LL, (long long)1e3);\n        if (r > (long long)1e18) r = (long long)1e18;\n    } else if (type == \"no_valid_numbers\") {\n        // Generate l and r where no numbers have first digit == last digit\n        int fd = rnd.next(1, 8); // First digit 1..8\n        int ld = fd + 1;         // Last digit greater than first digit\n        int len = rnd.next(2, 18); // Length of the number\n        string l_str = to_string(fd);\n        for (int i = 1; i < len - 1; ++i)\n            l_str += '0';\n        l_str += to_string(ld);\n        l = stoll(l_str);\n        r = l + rnd.next(0LL, 1000LL);\n        if (r > (long long)1e18) r = (long long)1e18;\n    } else if (type == \"all_valid_numbers\") {\n        int d = rnd.next(1,9); // Digit from 1 to 9\n        int len_l = rnd.next(1, 18);\n        int len_r = len_l + rnd.next(0,2);\n        if (len_r > 18) len_r = 18;\n\n        // Construct l\n        string l_str = to_string(d);\n        if (len_l == 1) {\n            l = d;\n        } else {\n            for (int i = 1; i < len_l -1; ++i)\n                l_str += '0';\n            l_str += to_string(d);\n            l = stoll(l_str);\n        }\n        // Construct r\n        string r_str = to_string(d);\n        if (len_r == 1) {\n            r = d;\n        } else {\n            for (int i = 1; i < len_r -1; ++i)\n                r_str += '9';\n            r_str += to_string(d);\n            r = stoll(r_str);\n        }\n\n        if (l > r) swap(l, r);\n        if (r > (long long)1e18) r = (long long)1e18;\n    } else {\n        // Default is random\n        l = rnd.next(1LL, (long long)1e18 - 1);\n        r = rnd.next(l, (long long)1e18);\n    }\n\n    cout << l << \" \" << r << endl;\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -type min_input\n./gen -type max_input\n\n./gen -type l_equals_r\n./gen -type l_equals_r\n\n./gen -type random_small\n./gen -type random_small\n./gen -type random_small\n\n./gen -type random_large\n./gen -type random_large\n./gen -type random_large\n\n./gen -type full_range\n\n./gen -type power_of_ten\n./gen -type power_of_ten\n./gen -type power_of_ten\n\n./gen -type around_power_of_ten\n./gen -type around_power_of_ten\n./gen -type around_power_of_ten\n\n./gen -type no_valid_numbers\n./gen -type no_valid_numbers\n./gen -type no_valid_numbers\n\n./gen -type all_valid_numbers\n./gen -type all_valid_numbers\n./gen -type all_valid_numbers\n\n./gen -type random\n./gen -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T19:48:48.295377",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "205/D",
      "title": "D. Little Elephant and Cards",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains a single integer n (1 ≤ n ≤ 105) — the number of the cards. The following n lines contain the description of all cards, one card per line. The cards are described by a pair of positive integers not exceeding 109 — colors of both sides. The first number in a line is the color of the front of the card, the second one — of the back. The color of the front of the card may coincide with the color of the back of the card.The numbers in the lines are separated by single spaces.",
      "output_spec": "OutputOn a single line print a single integer — the sought minimum number of moves. If it is impossible to make the set funny, print -1.",
      "sample_tests": "ExamplesInputCopy34 74 77 4OutputCopy0InputCopy54 77 42 119 71 1OutputCopy2",
      "description": "D. Little Elephant and Cards\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains a single integer n (1 ≤ n ≤ 105) — the number of the cards. The following n lines contain the description of all cards, one card per line. The cards are described by a pair of positive integers not exceeding 109 — colors of both sides. The first number in a line is the color of the front of the card, the second one — of the back. The color of the front of the card may coincide with the color of the back of the card.The numbers in the lines are separated by single spaces.\n\nOutputOn a single line print a single integer — the sought minimum number of moves. If it is impossible to make the set funny, print -1.\n\nInputCopy34 74 77 4OutputCopy0InputCopy54 77 42 119 71 1OutputCopy2\n\nInputCopy34 74 77 4\n\nOutputCopy0\n\nInputCopy54 77 42 119 71 1\n\nOutputCopy2\n\nNoteIn the first sample there initially are three cards lying with colors 4, 4, 7. Since two of the three cards are of the same color 4, you do not need to change anything, so the answer is 0.In the second sample, you can turn the first and the fourth cards. After that three of the five cards will be of color 7.",
      "solutions": [
        {
          "title": "Codeforces Round #129 - Codeforces",
          "content": "Hi!Time brings to you next Codeforces round, this time it is with number 129. It will take place in 11.07.2012 at 19:30 (Moscow time). This time the problems are authored by me, Vitaliy Herasymiv. Long time ago I was the author of 4 Codeforces rounds, they were about lucky numbers. But, unfortunately, nothing is constant, so this time there will be no problems about lucky numbers.A lot of help in preparing of the problems was from Gerald Agapov (Gerald), Alexander Kouprin (Alex_KPR), Vitaly Aksenov (Aksenov239), The problems were translated to English by Maria Belova (Delinur). Thanks to all of them.I hope you will like this all.Good Luck!Div1:Thanks all! The results are the following: tourist (now tourist become first Codeforces target, congratulations to him) winger RAVEman rng_58 RAD bmerry Shik Div2: xiaoshua2 ahm.kam_92 HanzhongBall_Quanling daidailanlan You can read editorials here.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/4848",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 901
        },
        {
          "title": "Codeforces Round #129 — Editorial - Codeforces",
          "content": "205A - Little Elephant and RozdilThis problem was the simplest in the problemset. All you need to do is just to sort all distances (keeping track on all indices). If the first two distances are equal, just output \"Still Rozdil\", otherwise output the index of the first element of the array.The complexity is O(NlogN).205B - Little Elephant and SortingIn this problem you need to notice the fact (which can be proven, but it is almost obvious) that if you are doing some operation for interval from l to r (inclusive), r must be equal to n. This is becuase when you add something to all right part the answer can't be worse. After that you need to go from left to right and greedly add appropriate number of turns.The complexity is O(N).205C - Little Elephant and IntervalIt is well-known that for such problem you need to write function F(x) which solves the problem for the interval 0..x, and the answer then is F(r) - F(l - 1).Now you need to write F(x) function. If x < 10, then answer is, of course, equal to x. Otherwise, let len be the length of x, x' — the integer x but without first and last digits, xi — the i-th digit of integer x (from left to right, starting from 0). Interate through all possible first digit d (which is the last at the same time) and through the length i of the number. Then if i < len - 2 or (i = len - 2 and d < x0) you need to add 10i to the answer. Otherwise, if i = len - 2 and d = x0 you need to add x' to the answer. Finally, if i = len - 2 and d = x0 and xlen - 1 ≥ d add 1 to the answer.This problems also can be solved using DP.205D - Little Elephant and CardsIt is nice to use the map structure in this problem, but you can solve it without map (using sorting and binary serach). Lets iterate through all possible colors that we have and suppose that this currect color is the one that will make our set funny. The minimal number through all this will be the answer. To find the minimal number of turns to make our set funny using current color we need to know two numbers: the number of cards with current color on the front side and the number of cards with the current color on back side (but not at the same time). Let it be integers a and b. Let m = (n + 1) / 2 — the minimal number of the same cards required to get the funny set. Then if a + b < m it is impossible to make set funny using current color at all. If a ≥ m then the answer is 0, otherwise the answer is m - a.205E - Little Elephant and Furik and RubikThis problem is to find the expected value. Important fact here is the linearity of the expected value. This means that we can for each element of the first strings find the probability that exactly this element will me matched with some other (but, of course, equal) from the second string. The answer will be the sum of all such probabilities.Let the current character of the first string be the i-th character (1-based numeration). Firstly we try to solve problem in O(N2) time. Namely, as it was said above, we need to find the number of such pairs of substrings that i-th character (which is on probably some other position in substring) is the same as the corresponding character of the second substring. Iterate through all j (j ≤ i) such that Ai = Bj. The number of such pairs of substrings that have match in that characters is j(n - i + 1) (considering 1-based numeration). This is O(N2). And because we need to find the sum of such values for all possible j, we can rewrite it as Si(n - i + 1), where Si equals to the sum of all integers j (j ≤ i) that Ai = Bi. Array S can be simply computed in a linear time. Analogically you should process all indices to the right from i.After we know the number of pairs of substrings with the match with the i-th character (let it be count), the probability is count / total, where total is the total number of pair of substrings (it can be found by loop or with some simple formula).The comlexity is O(N).204D - Little Elephant and Retro StringsFirstly we should solve following subproblem: for each prefix find the number of it's fillings such that there is no consecutive block of k characters B. Let it be F(x), where x is the index in of the last character if the prefix. Assing F(x) = F(x - 1) * cnt, where cnt = 2 if Sx = 'X' and 1 otherwise. After such assing there may be some bad filling included to F(x). Since we suppouse that F(x - 1) is caclulated correctly, all bad filling must contain blocks of k charcters B only at the end of the prefix (they may be included only if substring Sx - k + 1..x doesn't contain characters W and character Sx - k is not B). So, if it's possible, we must subtract from F(x) value F(x - k - 1), because it's exactly the number of bad fillings.With the same DP you should you calc the same values for suffixes (but this time changing B by W and vice versa). Now we should carefully calculate the result in such way that now repeatings occur. Let iterate (from right to left) through all possible positions of the first blocks of k characters B (this means that we suppose that no block occur to the left). Using our DP we can simply find the number of fillings of all characters to the left from that block in such way that no another blocks of k characters B occur. Considering O(N2) solutions, we can iterate through all possible indexes of the begging of the last block of k characters W (again we suppose that this blocks must be the last and no another may occur to the right) and agin using our DP count the number of fillings to the right. We don't care what is between that blocks, so we just multiply answer by 2^(the number of characters X between blocks). But, since we are going from right to the left, we can just keep tracking on all possible last blocks and get O(N) solution.204E - Little Elephant and StringsTo solve this problems we can use suffix array. More information about suffix arrays you can find in the Internet.Firstly, concatenate all strings into the one separating consecutive strings by some unique characters (it was also useful to not use strings, but arrays of integers). For example, three strings abc, a, ab may be concatenated in the following way: abc#a@ab. Now we should build suffix array using this total string, this allows to us to sort all cyclic shifts of the string. After that each cyclic shift will either begin with additional character or the character from the input strings.Notice now that to find the result we need to find for each cyclic shift (begging of which doesn't contain additional character) the largest size of it's prefix such that this prefix is substring of at least k different input strings. This value can be found by binary search, but for this we need some function F(x, len) which can answer the questions: how many input strings contain prefix of size len of x cyclic shift as a substring.How to make F(x, len)? Look at all cyclic shifts, prefix of size len of which is equal to preifx of size len of x-th shift. Since all shifts are sorted lexicoraphically, this set of shifts can be represented as integral [l;r] of indices of shifts (1 ≤ l ≤ x ≤ r). How to find l and r? For each pair of consecutive shifts we can find it's greatest common prefix (using properties of suffix array). Than l and r can be found using RMQ. For l we need to know the rigthmost pair of shift (but to the left from x) that their greatest common prefix is less than len. Analogically we can find r. After that we have interval [l;r] and we need to find the number of different input strings that belongs to the shifts from l-th to r-th (actually, we need to find the number of different integer on interval). But, notice that we dont need the exactly number of different integers, we need to know just it is at least k or not. So let L[i] equals to the greatest j (j ≤ i) such that the number of different integers on interval [j;i] is equal to k. Then if L[r] ≥ l, obiously, interval [l;r] will also contains at least k different. So F(x, len) is done.The only thing to done is to fill array L. This is pretty simple using set (but it is possible without it but using RMQ). We will go from left to righ at keep the indices of the last (the rightmost) k different integers in the set. If some integer comes, then (if it was earlier) we need to erase this previous index from set (if it was still in) and insert new current. While the size of set is greater than k, we should erase the minimal number from it. Then if in some position i the size of the set (after above changings) is equal to k, than L[i] is equal to the minimal number in set.Since we O(N) times use binary search, and function F(x, len) works in O(logN) time, the total complexity is O(Nlog2N).",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/4849",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 205\\s*D"
          },
          "content_length": 8674
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #129 - Codeforces - Code 1",
          "code": "He has n cards, each has exactly two colors",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4848",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #129 - Codeforces - Code 2",
          "code": "The color of the front of the card may coincide with the color of the back of the card",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4848",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #129 - Codeforces - Code 3",
          "code": "public void solve() throws IOException {\n\t\tlong l = nextLong();\n\t\tlong r = nextLong();\n\t\tout.println(f(r) - f(l - 1));\n\t}\n\t\n\tlong f(long x) {\n\t\tif (x < 10) {\n\t\t\treturn x;\n\t\t}\n\t\tString s = Long.toString(x);\n\t\treturn (x / 10 - 1) + (s.charAt(0) <= s.charAt(s.length() - 1) ? 1 : 0) + 9;\n\t}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4848",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #129 - Codeforces - Code 4",
          "code": "public void solve() throws IOException {\n\t\tlong l = nextLong();\n\t\tlong r = nextLong();\n\t\tout.println(f(r) - f(l - 1));\n\t}\n\t\n\tlong f(long x) {\n\t\tif (x < 10) {\n\t\t\treturn x;\n\t\t}\n\t\tString s = Long.toString(x);\n\t\treturn (x / 10 - 1) + (s.charAt(0) <= s.charAt(s.length() - 1) ? 1 : 0) + 9;\n\t}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4848",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #129 - Codeforces - Code 5",
          "code": "double div=n*(n+1)*(2*n+1);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4848",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #129 - Codeforces - Code 6",
          "code": "double div=n*(n+1)*(2*n+1);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4848",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #129 — Editorial - Codeforces - Code 1",
          "code": "ll D[10][20][2];\nstring w;\n\nlong long d(int i, int j, int k) {\n    if (D[i][j][k] != -1) return D[i][j][k];\n    if (j == 1) {\n        if (i == 0 and k == 0) return 9;\n        if (i == 0 and k == 1) return w[w.size() - 1] - '0';\n        else if (k == 1) return i <= w[w.size() - 1] - '0';\n        else return 1;\n    }\n    long long cont = 0;\n    for (int e = 0; e < ((k == 0)?10:w[w.size() - j] - '0' + 1); ++e)\n      cont += d((i == 0)?e:i, j-1, (k == 0)?0:e == w[w.size() - j] - '0');\n    return D[i][j][k] = cont;\n}\n\nlong long F(long long x) {\n    memset(D,-1,sizeof(D));\n    stringstream l; l << x;\n    l >> w;\n    return d(0,w.size(),1);    \n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4849",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #129 — Editorial - Codeforces - Code 2",
          "code": "ll D[10][20][2];\nstring w;\n\nlong long d(int i, int j, int k) {\n    if (D[i][j][k] != -1) return D[i][j][k];\n    if (j == 1) {\n        if (i == 0 and k == 0) return 9;\n        if (i == 0 and k == 1) return w[w.size() - 1] - '0';\n        else if (k == 1) return i <= w[w.size() - 1] - '0';\n        else return 1;\n    }\n    long long cont = 0;\n    for (int e = 0; e < ((k == 0)?10:w[w.size() - j] - '0' + 1); ++e)\n      cont += d((i == 0)?e:i, j-1, (k == 0)?0:e == w[w.size() - j] - '0');\n    return D[i][j][k] = cont;\n}\n\nlong long F(long long x) {\n    memset(D,-1,sizeof(D));\n    stringstream l; l << x;\n    l >> w;\n    return d(0,w.size(),1);    \n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4849",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #129 — Editorial - Codeforces - Code 3",
          "code": "long n = in.nextLong();\n        long min = Long.MAX_VALUE;\n        long idx = -1;\n        Set<Long> set = new HashSet<>();\n        boolean flag = false;\n        for(int i=0;i<n;i++){\n            long val = in.nextLong();\n            if(set.contains(val))\n                flag = true;\n            if(val<min) {\n                min = val;\n                idx = i;\n            }\n            set.add(val);\n        }\n        out.println((flag)?\"Still Rozdil\":idx+1);\n\n        out.close();\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4849",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n    for (int i=0; i<n; ++i) {\n        int a = inf.readInt(1, 1000000000, \"front color\");\n        inf.readSpace();\n        int b = inf.readInt(1, 1000000000, \"back color\");\n        inf.readEoln();\n    }\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n    for (int i=0; i<n; ++i) {\n        int a = inf.readInt(1, 1000000000, \"front color\");\n        inf.readSpace();\n        int b = inf.readInt(1, 1000000000, \"back color\");\n        inf.readEoln();\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n    for (int i=0; i<n; ++i) {\n        int a = inf.readInt(1, 1000000000, \"front color\");\n        inf.readSpace();\n        int b = inf.readInt(1, 1000000000, \"back color\");\n        inf.readEoln();\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<pair<int, int>> cards(n);\n\n    if (type == \"all_same\") {\n        // All cards have the same color on both sides\n        int c = rnd.next(1, 1000000000);\n        for (int i = 0; i < n; ++i)\n            cards[i] = make_pair(c, c);\n    } else if (type == \"front_same\") {\n        // All front colors are the same, back colors are random\n        int c = rnd.next(1, 1000000000);\n        for (int i = 0; i < n; ++i)\n            cards[i] = make_pair(c, rnd.next(1, 1000000000));\n    } else if (type == \"back_same\") {\n        // All back colors are the same, front colors are random\n        int c = rnd.next(1, 1000000000);\n        for (int i = 0; i < n; ++i)\n            cards[i] = make_pair(rnd.next(1, 1000000000), c);\n    } else if (type == \"impossible\") {\n        // Total count of any color is less than ceil(n/2)\n        set<int> used_colors;\n        for (int i = 0; i < n; ++i) {\n            int fc, bc;\n            do {\n                fc = rnd.next(1, 1000000000);\n            } while (used_colors.count(fc));\n            used_colors.insert(fc);\n            do {\n                bc = rnd.next(1, 1000000000);\n            } while (used_colors.count(bc));\n            used_colors.insert(bc);\n            cards[i] = make_pair(fc, bc);\n        }\n    } else if (type == \"min_flips_zero\") {\n        // The set is already funny without flips\n        int c = rnd.next(1, 1000000000);\n        int required = (n + 1) / 2;\n        for (int i = 0; i < n; ++i) {\n            if (i < required)\n                cards[i] = make_pair(c, rnd.next(1, 1000000000));\n            else\n                cards[i] = make_pair(rnd.next(1, 1000000000), rnd.next(1, 1000000000));\n        }\n    } else if (type == \"min_flips_n\") {\n        // Need to flip all cards to make the set funny\n        int c = rnd.next(1, 1000000000);\n        for (int i = 0; i < n; ++i) {\n            int fc;\n            do {\n                fc = rnd.next(1, 1000000000);\n            } while (fc == c);\n            cards[i] = make_pair(fc, c);\n        }\n    } else if (type == \"maximum_color_numbers\") {\n        // All colors are maximum allowed numbers\n        for (int i = 0; i < n; ++i)\n            cards[i] = make_pair(1000000000, 1000000000);\n    } else if (type == \"n_equals_1\") {\n        // n = 1\n        n = 1;\n        cards.resize(n);\n        int c = rnd.next(1, 1000000000);\n        cards[0] = make_pair(c, c);\n    } else if (type == \"half_same_front\") {\n        // Exactly ceil(n/2) cards have the same front color\n        int c = rnd.next(1, 1000000000);\n        int required = (n + 1) / 2;\n        for (int i = 0; i < n; ++i) {\n            if (i < required)\n                cards[i] = make_pair(c, rnd.next(1, 1000000000));\n            else\n                cards[i] = make_pair(rnd.next(1, 1000000000), rnd.next(1, 1000000000));\n        }\n    } else if (type == \"half_same_back\") {\n        // Exactly ceil(n/2) cards have the same back color\n        int c = rnd.next(1, 1000000000);\n        int required = (n + 1) / 2;\n        for (int i = 0; i < n; ++i) {\n            if (i < required)\n                cards[i] = make_pair(rnd.next(1, 1000000000), c);\n            else\n                cards[i] = make_pair(rnd.next(1, 1000000000), rnd.next(1, 1000000000));\n        }\n    } else if (type == \"half_same_mixed\") {\n        // Exactly ceil(n/2) cards have the same color on either side\n        int c = rnd.next(1, 1000000000);\n        int required = (n + 1) / 2;\n        for (int i = 0; i < n; ++i) {\n            if (i < required) {\n                if (rnd.next(2))\n                    cards[i] = make_pair(c, rnd.next(1, 1000000000));\n                else\n                    cards[i] = make_pair(rnd.next(1, 1000000000), c);\n            } else {\n                cards[i] = make_pair(rnd.next(1, 1000000000), rnd.next(1, 1000000000));\n            }\n        }\n    } else {\n        // Random data\n        for (int i = 0; i < n; ++i)\n            cards[i] = make_pair(rnd.next(1, 1000000000), rnd.next(1, 1000000000));\n    }\n\n    // Output\n    printf(\"%d\\n\", n);\n    for (int i = 0; i < n; ++i)\n        printf(\"%d %d\\n\", cards[i].first, cards[i].second);\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<pair<int, int>> cards(n);\n\n    if (type == \"all_same\") {\n        // All cards have the same color on both sides\n        int c = rnd.next(1, 1000000000);\n        for (int i = 0; i < n; ++i)\n            cards[i] = make_pair(c, c);\n    } else if (type == \"front_same\") {\n        // All front colors are the same, back colors are random\n        int c = rnd.next(1, 1000000000);\n        for (int i = 0; i < n; ++i)\n            cards[i] = make_pair(c, rnd.next(1, 1000000000));\n    } else if (type == \"back_same\") {\n        // All back colors are the same, front colors are random\n        int c = rnd.next(1, 1000000000);\n        for (int i = 0; i < n; ++i)\n            cards[i] = make_pair(rnd.next(1, 1000000000), c);\n    } else if (type == \"impossible\") {\n        // Total count of any color is less than ceil(n/2)\n        set<int> used_colors;\n        for (int i = 0; i < n; ++i) {\n            int fc, bc;\n            do {\n                fc = rnd.next(1, 1000000000);\n            } while (used_colors.count(fc));\n            used_colors.insert(fc);\n            do {\n                bc = rnd.next(1, 1000000000);\n            } while (used_colors.count(bc));\n            used_colors.insert(bc);\n            cards[i] = make_pair(fc, bc);\n        }\n    } else if (type == \"min_flips_zero\") {\n        // The set is already funny without flips\n        int c = rnd.next(1, 1000000000);\n        int required = (n + 1) / 2;\n        for (int i = 0; i < n; ++i) {\n            if (i < required)\n                cards[i] = make_pair(c, rnd.next(1, 1000000000));\n            else\n                cards[i] = make_pair(rnd.next(1, 1000000000), rnd.next(1, 1000000000));\n        }\n    } else if (type == \"min_flips_n\") {\n        // Need to flip all cards to make the set funny\n        int c = rnd.next(1, 1000000000);\n        for (int i = 0; i < n; ++i) {\n            int fc;\n            do {\n                fc = rnd.next(1, 1000000000);\n            } while (fc == c);\n            cards[i] = make_pair(fc, c);\n        }\n    } else if (type == \"maximum_color_numbers\") {\n        // All colors are maximum allowed numbers\n        for (int i = 0; i < n; ++i)\n            cards[i] = make_pair(1000000000, 1000000000);\n    } else if (type == \"n_equals_1\") {\n        // n = 1\n        n = 1;\n        cards.resize(n);\n        int c = rnd.next(1, 1000000000);\n        cards[0] = make_pair(c, c);\n    } else if (type == \"half_same_front\") {\n        // Exactly ceil(n/2) cards have the same front color\n        int c = rnd.next(1, 1000000000);\n        int required = (n + 1) / 2;\n        for (int i = 0; i < n; ++i) {\n            if (i < required)\n                cards[i] = make_pair(c, rnd.next(1, 1000000000));\n            else\n                cards[i] = make_pair(rnd.next(1, 1000000000), rnd.next(1, 1000000000));\n        }\n    } else if (type == \"half_same_back\") {\n        // Exactly ceil(n/2) cards have the same back color\n        int c = rnd.next(1, 1000000000);\n        int required = (n + 1) / 2;\n        for (int i = 0; i < n; ++i) {\n            if (i < required)\n                cards[i] = make_pair(rnd.next(1, 1000000000), c);\n            else\n                cards[i] = make_pair(rnd.next(1, 1000000000), rnd.next(1, 1000000000));\n        }\n    } else if (type == \"half_same_mixed\") {\n        // Exactly ceil(n/2) cards have the same color on either side\n        int c = rnd.next(1, 1000000000);\n        int required = (n + 1) / 2;\n        for (int i = 0; i < n; ++i) {\n            if (i < required) {\n                if (rnd.next(2))\n                    cards[i] = make_pair(c, rnd.next(1, 1000000000));\n                else\n                    cards[i] = make_pair(rnd.next(1, 1000000000), c);\n            } else {\n                cards[i] = make_pair(rnd.next(1, 1000000000), rnd.next(1, 1000000000));\n            }\n        }\n    } else {\n        // Random data\n        for (int i = 0; i < n; ++i)\n            cards[i] = make_pair(rnd.next(1, 1000000000), rnd.next(1, 1000000000));\n    }\n\n    // Output\n    printf(\"%d\\n\", n);\n    for (int i = 0; i < n; ++i)\n        printf(\"%d %d\\n\", cards[i].first, cards[i].second);\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Small n tests\n./gen -n 1 -type n_equals_1\n./gen -n 1 -type all_same\n./gen -n 1 -type random\n\n./gen -n 2 -type min_flips_zero\n./gen -n 2 -type min_flips_n\n./gen -n 2 -type impossible\n\n# Medium n tests\n./gen -n 10 -type all_same\n./gen -n 10 -type front_same\n./gen -n 10 -type back_same\n./gen -n 10 -type impossible\n./gen -n 10 -type min_flips_zero\n./gen -n 10 -type min_flips_n\n./gen -n 10 -type half_same_front\n./gen -n 10 -type half_same_back\n./gen -n 10 -type half_same_mixed\n\n# Large n tests\n./gen -n 1000 -type random\n./gen -n 1000 -type all_same\n./gen -n 1000 -type impossible\n./gen -n 1000 -type min_flips_n\n./gen -n 1000 -type min_flips_zero\n\n# Max n tests\n./gen -n 100000 -type random\n./gen -n 100000 -type all_same\n./gen -n 100000 -type impossible\n./gen -n 100000 -type min_flips_n\n./gen -n 100000 -type min_flips_zero\n./gen -n 100000 -type half_same_mixed\n./gen -n 100000 -type half_same_front\n\n# Maximum color numbers test\n./gen -n 100000 -type maximum_color_numbers\n\n# Additional tests\n./gen -n 99999 -type random\n./gen -n 100000 -type front_same\n./gen -n 100000 -type back_same\n\n# Edge case tests\n./gen -n 99999 -type impossible\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T19:48:50.038660",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "205/E",
      "title": "E. Little Elephant and Furik and Rubik",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains a single integer n (1 ≤ n ≤ 2·105) — the length of strings a and b. The second line contains string a, the third line contains string b. The strings consist of uppercase English letters only. The length of both strings equals n.",
      "output_spec": "OutputOn a single line print a real number — the answer to the problem. The answer will be considered correct if its relative or absolute error does not exceed 10 - 6.",
      "sample_tests": "ExamplesInputCopy2ABBAOutputCopy0.400000000InputCopy3AABCAAOutputCopy0.642857143",
      "description": "E. Little Elephant and Furik and Rubik\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains a single integer n (1 ≤ n ≤ 2·105) — the length of strings a and b. The second line contains string a, the third line contains string b. The strings consist of uppercase English letters only. The length of both strings equals n.\n\nOutputOn a single line print a real number — the answer to the problem. The answer will be considered correct if its relative or absolute error does not exceed 10 - 6.\n\nInputCopy2ABBAOutputCopy0.400000000InputCopy3AABCAAOutputCopy0.642857143\n\nInputCopy2ABBA\n\nOutputCopy0.400000000\n\nInputCopy3AABCAA\n\nOutputCopy0.642857143\n\nNoteLet's assume that we are given string a = a1a2... a|a|, then let's denote the string's length as |a|, and its i-th character — as ai.A substring a[l... r] (1 ≤ l ≤ r ≤ |a|) of string a is string alal + 1... ar.String a is a substring of string b, if there exists such pair of integers l and r (1 ≤ l ≤ r ≤ |b|), that b[l... r] = a.Let's consider the first test sample. The first sample has 5 possible substring pairs: (\"A\", \"B\"), (\"A\", \"A\"), (\"B\", \"B\"), (\"B\", \"A\"), (\"AB\", \"BA\"). For the second and third pair value f(x, y) equals 1, for the rest it equals 0. The probability of choosing each pair equals , that's why the answer is  · 0  +   · 1  +   · 1  +   · 0  +   · 0  =    =  0.4.",
      "solutions": [
        {
          "title": "Codeforces Round #129 - Codeforces",
          "content": "Hi!Time brings to you next Codeforces round, this time it is with number 129. It will take place in 11.07.2012 at 19:30 (Moscow time). This time the problems are authored by me, Vitaliy Herasymiv. Long time ago I was the author of 4 Codeforces rounds, they were about lucky numbers. But, unfortunately, nothing is constant, so this time there will be no problems about lucky numbers.A lot of help in preparing of the problems was from Gerald Agapov (Gerald), Alexander Kouprin (Alex_KPR), Vitaly Aksenov (Aksenov239), The problems were translated to English by Maria Belova (Delinur). Thanks to all of them.I hope you will like this all.Good Luck!Div1:Thanks all! The results are the following: tourist (now tourist become first Codeforces target, congratulations to him) winger RAVEman rng_58 RAD bmerry Shik Div2: xiaoshua2 ahm.kam_92 HanzhongBall_Quanling daidailanlan You can read editorials here.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/4848",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 901
        },
        {
          "title": "Codeforces Round #129 — Editorial - Codeforces",
          "content": "205A - Little Elephant and RozdilThis problem was the simplest in the problemset. All you need to do is just to sort all distances (keeping track on all indices). If the first two distances are equal, just output \"Still Rozdil\", otherwise output the index of the first element of the array.The complexity is O(NlogN).205B - Little Elephant and SortingIn this problem you need to notice the fact (which can be proven, but it is almost obvious) that if you are doing some operation for interval from l to r (inclusive), r must be equal to n. This is becuase when you add something to all right part the answer can't be worse. After that you need to go from left to right and greedly add appropriate number of turns.The complexity is O(N).205C - Little Elephant and IntervalIt is well-known that for such problem you need to write function F(x) which solves the problem for the interval 0..x, and the answer then is F(r) - F(l - 1).Now you need to write F(x) function. If x < 10, then answer is, of course, equal to x. Otherwise, let len be the length of x, x' — the integer x but without first and last digits, xi — the i-th digit of integer x (from left to right, starting from 0). Interate through all possible first digit d (which is the last at the same time) and through the length i of the number. Then if i < len - 2 or (i = len - 2 and d < x0) you need to add 10i to the answer. Otherwise, if i = len - 2 and d = x0 you need to add x' to the answer. Finally, if i = len - 2 and d = x0 and xlen - 1 ≥ d add 1 to the answer.This problems also can be solved using DP.205D - Little Elephant and CardsIt is nice to use the map structure in this problem, but you can solve it without map (using sorting and binary serach). Lets iterate through all possible colors that we have and suppose that this currect color is the one that will make our set funny. The minimal number through all this will be the answer. To find the minimal number of turns to make our set funny using current color we need to know two numbers: the number of cards with current color on the front side and the number of cards with the current color on back side (but not at the same time). Let it be integers a and b. Let m = (n + 1) / 2 — the minimal number of the same cards required to get the funny set. Then if a + b < m it is impossible to make set funny using current color at all. If a ≥ m then the answer is 0, otherwise the answer is m - a.205E - Little Elephant and Furik and RubikThis problem is to find the expected value. Important fact here is the linearity of the expected value. This means that we can for each element of the first strings find the probability that exactly this element will me matched with some other (but, of course, equal) from the second string. The answer will be the sum of all such probabilities.Let the current character of the first string be the i-th character (1-based numeration). Firstly we try to solve problem in O(N2) time. Namely, as it was said above, we need to find the number of such pairs of substrings that i-th character (which is on probably some other position in substring) is the same as the corresponding character of the second substring. Iterate through all j (j ≤ i) such that Ai = Bj. The number of such pairs of substrings that have match in that characters is j(n - i + 1) (considering 1-based numeration). This is O(N2). And because we need to find the sum of such values for all possible j, we can rewrite it as Si(n - i + 1), where Si equals to the sum of all integers j (j ≤ i) that Ai = Bi. Array S can be simply computed in a linear time. Analogically you should process all indices to the right from i.After we know the number of pairs of substrings with the match with the i-th character (let it be count), the probability is count / total, where total is the total number of pair of substrings (it can be found by loop or with some simple formula).The comlexity is O(N).204D - Little Elephant and Retro StringsFirstly we should solve following subproblem: for each prefix find the number of it's fillings such that there is no consecutive block of k characters B. Let it be F(x), where x is the index in of the last character if the prefix. Assing F(x) = F(x - 1) * cnt, where cnt = 2 if Sx = 'X' and 1 otherwise. After such assing there may be some bad filling included to F(x). Since we suppouse that F(x - 1) is caclulated correctly, all bad filling must contain blocks of k charcters B only at the end of the prefix (they may be included only if substring Sx - k + 1..x doesn't contain characters W and character Sx - k is not B). So, if it's possible, we must subtract from F(x) value F(x - k - 1), because it's exactly the number of bad fillings.With the same DP you should you calc the same values for suffixes (but this time changing B by W and vice versa). Now we should carefully calculate the result in such way that now repeatings occur. Let iterate (from right to left) through all possible positions of the first blocks of k characters B (this means that we suppose that no block occur to the left). Using our DP we can simply find the number of fillings of all characters to the left from that block in such way that no another blocks of k characters B occur. Considering O(N2) solutions, we can iterate through all possible indexes of the begging of the last block of k characters W (again we suppose that this blocks must be the last and no another may occur to the right) and agin using our DP count the number of fillings to the right. We don't care what is between that blocks, so we just multiply answer by 2^(the number of characters X between blocks). But, since we are going from right to the left, we can just keep tracking on all possible last blocks and get O(N) solution.204E - Little Elephant and StringsTo solve this problems we can use suffix array. More information about suffix arrays you can find in the Internet.Firstly, concatenate all strings into the one separating consecutive strings by some unique characters (it was also useful to not use strings, but arrays of integers). For example, three strings abc, a, ab may be concatenated in the following way: abc#a@ab. Now we should build suffix array using this total string, this allows to us to sort all cyclic shifts of the string. After that each cyclic shift will either begin with additional character or the character from the input strings.Notice now that to find the result we need to find for each cyclic shift (begging of which doesn't contain additional character) the largest size of it's prefix such that this prefix is substring of at least k different input strings. This value can be found by binary search, but for this we need some function F(x, len) which can answer the questions: how many input strings contain prefix of size len of x cyclic shift as a substring.How to make F(x, len)? Look at all cyclic shifts, prefix of size len of which is equal to preifx of size len of x-th shift. Since all shifts are sorted lexicoraphically, this set of shifts can be represented as integral [l;r] of indices of shifts (1 ≤ l ≤ x ≤ r). How to find l and r? For each pair of consecutive shifts we can find it's greatest common prefix (using properties of suffix array). Than l and r can be found using RMQ. For l we need to know the rigthmost pair of shift (but to the left from x) that their greatest common prefix is less than len. Analogically we can find r. After that we have interval [l;r] and we need to find the number of different input strings that belongs to the shifts from l-th to r-th (actually, we need to find the number of different integer on interval). But, notice that we dont need the exactly number of different integers, we need to know just it is at least k or not. So let L[i] equals to the greatest j (j ≤ i) such that the number of different integers on interval [j;i] is equal to k. Then if L[r] ≥ l, obiously, interval [l;r] will also contains at least k different. So F(x, len) is done.The only thing to done is to fill array L. This is pretty simple using set (but it is possible without it but using RMQ). We will go from left to righ at keep the indices of the last (the rightmost) k different integers in the set. If some integer comes, then (if it was earlier) we need to erase this previous index from set (if it was still in) and insert new current. While the size of set is greater than k, we should erase the minimal number from it. Then if in some position i the size of the set (after above changings) is equal to k, than L[i] is equal to the minimal number in set.Since we O(N) times use binary search, and function F(x, len) works in O(logN) time, the total complexity is O(Nlog2N).",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/4849",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 205\\s*E"
          },
          "content_length": 8674
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #129 - Codeforces - Code 1",
          "code": "He has n cards, each has exactly two colors",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4848",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #129 - Codeforces - Code 2",
          "code": "The color of the front of the card may coincide with the color of the back of the card",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4848",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #129 - Codeforces - Code 3",
          "code": "public void solve() throws IOException {\n\t\tlong l = nextLong();\n\t\tlong r = nextLong();\n\t\tout.println(f(r) - f(l - 1));\n\t}\n\t\n\tlong f(long x) {\n\t\tif (x < 10) {\n\t\t\treturn x;\n\t\t}\n\t\tString s = Long.toString(x);\n\t\treturn (x / 10 - 1) + (s.charAt(0) <= s.charAt(s.length() - 1) ? 1 : 0) + 9;\n\t}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4848",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #129 - Codeforces - Code 4",
          "code": "public void solve() throws IOException {\n\t\tlong l = nextLong();\n\t\tlong r = nextLong();\n\t\tout.println(f(r) - f(l - 1));\n\t}\n\t\n\tlong f(long x) {\n\t\tif (x < 10) {\n\t\t\treturn x;\n\t\t}\n\t\tString s = Long.toString(x);\n\t\treturn (x / 10 - 1) + (s.charAt(0) <= s.charAt(s.length() - 1) ? 1 : 0) + 9;\n\t}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4848",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #129 - Codeforces - Code 5",
          "code": "double div=n*(n+1)*(2*n+1);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4848",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #129 - Codeforces - Code 6",
          "code": "double div=n*(n+1)*(2*n+1);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4848",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #129 — Editorial - Codeforces - Code 1",
          "code": "ll D[10][20][2];\nstring w;\n\nlong long d(int i, int j, int k) {\n    if (D[i][j][k] != -1) return D[i][j][k];\n    if (j == 1) {\n        if (i == 0 and k == 0) return 9;\n        if (i == 0 and k == 1) return w[w.size() - 1] - '0';\n        else if (k == 1) return i <= w[w.size() - 1] - '0';\n        else return 1;\n    }\n    long long cont = 0;\n    for (int e = 0; e < ((k == 0)?10:w[w.size() - j] - '0' + 1); ++e)\n      cont += d((i == 0)?e:i, j-1, (k == 0)?0:e == w[w.size() - j] - '0');\n    return D[i][j][k] = cont;\n}\n\nlong long F(long long x) {\n    memset(D,-1,sizeof(D));\n    stringstream l; l << x;\n    l >> w;\n    return d(0,w.size(),1);    \n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4849",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #129 — Editorial - Codeforces - Code 2",
          "code": "ll D[10][20][2];\nstring w;\n\nlong long d(int i, int j, int k) {\n    if (D[i][j][k] != -1) return D[i][j][k];\n    if (j == 1) {\n        if (i == 0 and k == 0) return 9;\n        if (i == 0 and k == 1) return w[w.size() - 1] - '0';\n        else if (k == 1) return i <= w[w.size() - 1] - '0';\n        else return 1;\n    }\n    long long cont = 0;\n    for (int e = 0; e < ((k == 0)?10:w[w.size() - j] - '0' + 1); ++e)\n      cont += d((i == 0)?e:i, j-1, (k == 0)?0:e == w[w.size() - j] - '0');\n    return D[i][j][k] = cont;\n}\n\nlong long F(long long x) {\n    memset(D,-1,sizeof(D));\n    stringstream l; l << x;\n    l >> w;\n    return d(0,w.size(),1);    \n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4849",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #129 — Editorial - Codeforces - Code 3",
          "code": "long n = in.nextLong();\n        long min = Long.MAX_VALUE;\n        long idx = -1;\n        Set<Long> set = new HashSet<>();\n        boolean flag = false;\n        for(int i=0;i<n;i++){\n            long val = in.nextLong();\n            if(set.contains(val))\n                flag = true;\n            if(val<min) {\n                min = val;\n                idx = i;\n            }\n            set.add(val);\n        }\n        out.println((flag)?\"Still Rozdil\":idx+1);\n\n        out.close();\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4849",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 200000, \"n\");\n    inf.readEoln();\n\n    string a = inf.readToken();\n    inf.readEoln();\n    ensuref(int(a.size()) == n, \"Length of 'a' (%d) is not equal to n (%d)\", int(a.size()), n);\n    for (size_t i = 0; i < a.size(); ++i) {\n        ensuref('A' <= a[i] && a[i] <= 'Z', \"String 'a' contains invalid character '%c' at position %zu\", a[i], i+1);\n    }\n\n    string b = inf.readToken();\n    inf.readEoln();\n    ensuref(int(b.size()) == n, \"Length of 'b' (%d) is not equal to n (%d)\", int(b.size()), n);\n    for (size_t i = 0; i < b.size(); ++i) {\n        ensuref('A' <= b[i] && b[i] <= 'Z', \"String 'b' contains invalid character '%c' at position %zu\", b[i], i+1);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 200000, \"n\");\n    inf.readEoln();\n\n    string a = inf.readToken();\n    inf.readEoln();\n    ensuref(int(a.size()) == n, \"Length of 'a' (%d) is not equal to n (%d)\", int(a.size()), n);\n    for (size_t i = 0; i < a.size(); ++i) {\n        ensuref('A' <= a[i] && a[i] <= 'Z', \"String 'a' contains invalid character '%c' at position %zu\", a[i], i+1);\n    }\n\n    string b = inf.readToken();\n    inf.readEoln();\n    ensuref(int(b.size()) == n, \"Length of 'b' (%d) is not equal to n (%d)\", int(b.size()), n);\n    for (size_t i = 0; i < b.size(); ++i) {\n        ensuref('A' <= b[i] && b[i] <= 'Z', \"String 'b' contains invalid character '%c' at position %zu\", b[i], i+1);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 200000, \"n\");\n    inf.readEoln();\n\n    string a = inf.readToken();\n    inf.readEoln();\n    ensuref(int(a.size()) == n, \"Length of 'a' (%d) is not equal to n (%d)\", int(a.size()), n);\n    for (size_t i = 0; i < a.size(); ++i) {\n        ensuref('A' <= a[i] && a[i] <= 'Z', \"String 'a' contains invalid character '%c' at position %zu\", a[i], i+1);\n    }\n\n    string b = inf.readToken();\n    inf.readEoln();\n    ensuref(int(b.size()) == n, \"Length of 'b' (%d) is not equal to n (%d)\", int(b.size()), n);\n    for (size_t i = 0; i < b.size(); ++i) {\n        ensuref('A' <= b[i] && b[i] <= 'Z', \"String 'b' contains invalid character '%c' at position %zu\", b[i], i+1);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nconst double EPS = 1E-6;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare two sequences of doubles, max absolute or relative  error = %.7f\", EPS);\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    double j = 0, p = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        n++;\r\n        j = ans.readDouble();\r\n        p = ouf.readDouble();\r\n        if (!doubleCompare(j, p, EPS)) {\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%.7f', found: '%.7f', error = '%.7f'\",\r\n                  n, englishEnding(n).c_str(), j, p, doubleDelta(j, p));\r\n        }\r\n    }\r\n\r\n    if (n == 1)\r\n        quitf(_ok, \"found '%.7f', expected '%.7f', error '%.7f'\", p, j, doubleDelta(j, p));\r\n\r\n    quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring randomString(int n, char from='A', char to='Z') {\n    string s(n, 'A');\n    for(int i = 0; i < n; ++i) {\n        s[i] = rnd.next(from, to);\n    }\n    return s;\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    string a, b;\n\n    if (type == \"random\") {\n        a = randomString(n);\n        b = randomString(n);\n    } else if (type == \"same\") {\n        a = randomString(n);\n        b = a;\n    } else if (type == \"opposite\") {\n        a = randomString(n);\n        b = randomString(n);\n        for (int i = 0; i < n; ++i) {\n            while (b[i] == a[i]) {\n                b[i] = rnd.next('A', 'Z'); // Change b[i] to ensure it's different from a[i]\n            }\n        }\n    } else if (type == \"small_abc\") {\n        a = randomString(n, 'A', 'C'); // 'A', 'B', 'C'\n        b = randomString(n, 'A', 'C');\n    } else if (type == \"reverse\") {\n        a = randomString(n);\n        b = a;\n        reverse(b.begin(), b.end());\n    } else if (type == \"shift\") {\n        a = randomString(n);\n        int shift = rnd.next(1, n-1);\n        b = a.substr(shift) + a.substr(0, shift);\n    } else if (type == \"alternate\") {\n        a = string(n, 'A');\n        b = string(n, 'B');\n        for (int i = 0; i < n; ++i) {\n            if (i % 2 == 0) {\n                a[i] = 'A';\n                b[i] = 'B';\n            } else {\n                a[i] = 'B';\n                b[i] = 'A';\n            }\n        }\n    } else if (type == \"identical_chars\") {\n        char ch = rnd.next('A', 'Z');\n        a = string(n, ch);\n        b = string(n, ch);\n    } else if (type == \"single_char_diff\") {\n        a = randomString(n);\n        b = a;\n        int pos = rnd.next(0, n-1);\n        char ch = a[pos];\n        char new_ch = ch;\n        while (new_ch == ch) {\n            new_ch = rnd.next('A', 'Z');\n        }\n        b[pos] = new_ch;\n    } else if (type == \"max_matches\") {\n        // a and b are the same\n        a = randomString(n);\n        b = a;\n    } else if (type == \"min_matches\") {\n        // a and b differ at every position\n        a = randomString(n);\n        b = a;\n        for (int i = 0; i < n; ++i) {\n            char ch = a[i];\n            char new_ch = ch;\n            while (new_ch == ch) {\n                new_ch = rnd.next('A', 'Z');\n            }\n            b[i] = new_ch;\n        }\n    } else if (type == \"palindrome\") {\n        a = randomString(n/2);\n        string rev_a = a;\n        reverse(rev_a.begin(), rev_a.end());\n        if (n % 2 == 1) {\n            a += rnd.next('A', 'Z');\n        }\n        a += rev_a;\n        b = a;\n    } else {\n        // default to random if unknown type\n        a = randomString(n);\n        b = randomString(n);\n    }\n\n    // Output\n    printf(\"%d\\n\", n);\n    printf(\"%s\\n\", a.c_str());\n    printf(\"%s\\n\", b.c_str());\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring randomString(int n, char from='A', char to='Z') {\n    string s(n, 'A');\n    for(int i = 0; i < n; ++i) {\n        s[i] = rnd.next(from, to);\n    }\n    return s;\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    string a, b;\n\n    if (type == \"random\") {\n        a = randomString(n);\n        b = randomString(n);\n    } else if (type == \"same\") {\n        a = randomString(n);\n        b = a;\n    } else if (type == \"opposite\") {\n        a = randomString(n);\n        b = randomString(n);\n        for (int i = 0; i < n; ++i) {\n            while (b[i] == a[i]) {\n                b[i] = rnd.next('A', 'Z'); // Change b[i] to ensure it's different from a[i]\n            }\n        }\n    } else if (type == \"small_abc\") {\n        a = randomString(n, 'A', 'C'); // 'A', 'B', 'C'\n        b = randomString(n, 'A', 'C');\n    } else if (type == \"reverse\") {\n        a = randomString(n);\n        b = a;\n        reverse(b.begin(), b.end());\n    } else if (type == \"shift\") {\n        a = randomString(n);\n        int shift = rnd.next(1, n-1);\n        b = a.substr(shift) + a.substr(0, shift);\n    } else if (type == \"alternate\") {\n        a = string(n, 'A');\n        b = string(n, 'B');\n        for (int i = 0; i < n; ++i) {\n            if (i % 2 == 0) {\n                a[i] = 'A';\n                b[i] = 'B';\n            } else {\n                a[i] = 'B';\n                b[i] = 'A';\n            }\n        }\n    } else if (type == \"identical_chars\") {\n        char ch = rnd.next('A', 'Z');\n        a = string(n, ch);\n        b = string(n, ch);\n    } else if (type == \"single_char_diff\") {\n        a = randomString(n);\n        b = a;\n        int pos = rnd.next(0, n-1);\n        char ch = a[pos];\n        char new_ch = ch;\n        while (new_ch == ch) {\n            new_ch = rnd.next('A', 'Z');\n        }\n        b[pos] = new_ch;\n    } else if (type == \"max_matches\") {\n        // a and b are the same\n        a = randomString(n);\n        b = a;\n    } else if (type == \"min_matches\") {\n        // a and b differ at every position\n        a = randomString(n);\n        b = a;\n        for (int i = 0; i < n; ++i) {\n            char ch = a[i];\n            char new_ch = ch;\n            while (new_ch == ch) {\n                new_ch = rnd.next('A', 'Z');\n            }\n            b[i] = new_ch;\n        }\n    } else if (type == \"palindrome\") {\n        a = randomString(n/2);\n        string rev_a = a;\n        reverse(rev_a.begin(), rev_a.end());\n        if (n % 2 == 1) {\n            a += rnd.next('A', 'Z');\n        }\n        a += rev_a;\n        b = a;\n    } else {\n        // default to random if unknown type\n        a = randomString(n);\n        b = randomString(n);\n    }\n\n    // Output\n    printf(\"%d\\n\", n);\n    printf(\"%s\\n\", a.c_str());\n    printf(\"%s\\n\", b.c_str());\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -type same\n./gen -n 1 -type opposite\n./gen -n 1 -type random\n\n./gen -n 2 -type same\n./gen -n 2 -type opposite\n./gen -n 2 -type random\n\n./gen -n 5 -type reverse\n./gen -n 5 -type shift\n./gen -n 5 -type palindrome\n./gen -n 5 -type single_char_diff\n./gen -n 5 -type small_abc\n./gen -n 5 -type alternate\n\n./gen -n 50 -type random\n./gen -n 50 -type small_abc\n./gen -n 100 -type same\n./gen -n 100 -type opposite\n\n./gen -n 1000 -type random\n./gen -n 1000 -type small_abc\n./gen -n 1000 -type shift\n./gen -n 1000 -type reverse\n\n./gen -n 10000 -type random\n./gen -n 10000 -type alternate\n./gen -n 10000 -type min_matches\n./gen -n 10000 -type max_matches\n\n./gen -n 50000 -type min_matches\n./gen -n 50000 -type max_matches\n\n./gen -n 100000 -type random\n./gen -n 100000 -type same\n./gen -n 100000 -type opposite\n./gen -n 100000 -type single_char_diff\n\n./gen -n 200000 -type random\n./gen -n 200000 -type same\n./gen -n 200000 -type opposite\n./gen -n 200000 -type min_matches\n./gen -n 200000 -type max_matches\n./gen -n 200000 -type single_char_diff\n./gen -n 200000 -type palindrome\n./gen -n 200000 -type shift\n./gen -n 200000 -type reverse\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T19:48:52.473773",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "208/A",
      "title": "A. Dubstep",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe input consists of a single non-empty string, consisting only of uppercase English letters, the string's length doesn't exceed 200 characters. It is guaranteed that before Vasya remixed the song, no word contained substring \"WUB\" in it; Vasya didn't change the word order. It is also guaranteed that initially the song had at least one word.",
      "output_spec": "OutputPrint the words of the initial song that Vasya used to make a dubsteb remix. Separate the words with a space.",
      "sample_tests": "ExamplesInputCopyWUBWUBABCWUBOutputCopyABC InputCopyWUBWEWUBAREWUBWUBTHEWUBCHAMPIONSWUBMYWUBFRIENDWUBOutputCopyWE ARE THE CHAMPIONS MY FRIEND",
      "description": "time limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe input consists of a single non-empty string, consisting only of uppercase English letters, the string's length doesn't exceed 200 characters. It is guaranteed that before Vasya remixed the song, no word contained substring \"WUB\" in it; Vasya didn't change the word order. It is also guaranteed that initially the song had at least one word.\n\nOutputPrint the words of the initial song that Vasya used to make a dubsteb remix. Separate the words with a space.\n\nInputCopyWUBWUBABCWUBOutputCopyABC InputCopyWUBWEWUBAREWUBWUBTHEWUBCHAMPIONSWUBMYWUBFRIENDWUBOutputCopyWE ARE THE CHAMPIONS MY FRIEND\n\nInputCopyWUBWUBABCWUB\n\nOutputCopyABC\n\nInputCopyWUBWEWUBAREWUBWUBTHEWUBCHAMPIONSWUBMYWUBFRIENDWUB\n\nOutputCopyWE ARE THE CHAMPIONS MY FRIEND\n\nNoteIn the first sample: \"WUBWUBABCWUB\" = \"WUB\" + \"WUB\" + \"ABC\" + \"WUB\". That means that the song originally consisted of a single word \"ABC\", and all words \"WUB\" were added by Vasya.In the second sample Vasya added a single word \"WUB\" between all neighbouring words, in the beginning and in the end, except for words \"ARE\" and \"THE\" — between them Vasya added two \"WUB\".",
      "solutions": [
        {
          "title": "Codeforces Round #130 (Div. 2) - Codeforces",
          "content": "Welcome, friends)We are glad to introduce you regular Codeforces round #130 for Div.2 participants. Everyone can traditionally participate in it. There were some problems with registration of Div.1 participants, but now everything is alright)Problems are prepared by command of authors: Pavel Kholkin (HolkinPV), Nikolay Kuznetsov (NALP) and Gerald Agapov (Gerald). Traditionally thanks to Michael Mirzayanov (MikeMirzayanov) for perfect Codeforces system and Mary Belova (Delinur) for translating problems. Also thanks to Alexander Kouprin (Alex_KPR) and Pavel Kunyavskiy (PavelKunyavskiy) for their help.And again score distribution will be dynamic) More information you can find here.Note that all problems will be given in random order.We wish you good luck, successful hacks and high rating!UPD: the contest is over, no matter what, we hope you enjoyed the competitionUPD2: The authors apologize for the situation with the problem E. The problem has affected a small number of participants from div2 (22 participants) and the solution of original version of the problem doesn’t differ a lot (in most solutions is sufficient to remove a couple of lines, solutions become more simple). Therefore, it was adopted the following decision: for all 22 participants,who has problems with problem E and will have decrease of rating, the round is unrated. for everybody else the round is rated UPD3: after recalculation it was found that there are 20 such participants, not 22UPD4: unsuccessful hacks, which answers differed from the correct whitespaces, are decided to ignoreUPD5: tutorial can be found here",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/4924",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1603
        },
        {
          "title": "Codeforces Round #130 (Div. 2) Tutorial - Codeforces",
          "content": "First, arrange the problems in order of their difficulties. The authors assume such order: A, D, B, C, E. Now make the tutorial of problems in their order in the contest.208A - DubstepThis problem was technical. First, you should erase all occurrences or word WUB in the beginning and in the end of the string. And then parse the remaining string separating tokens by word WUB. Empty tokens should be also erased. Given string was rather small, you can realize the algorithm in any way.208B - SolitaireIn this problem you could write breadth-first search. The state is the following four elements: number of remaining piles and three strings — three rightmost cards on the top of three rightmost piles. We have two transitions in general case. We can take the rightmost pile and shift it left by 1 or 3 on another pile. If the number of remaining piles become 0 at some moment print YES, else print NO. The number of states is O(N4), the number of transitions 2, so the complexity of solution is O(N4).208C - Police StationIn this problem we will find the sought quantity for every vertex and find the maximum value. For this for every vertex v count two values: cnt1[v] and cnt2[v] — number of shortest paths from vertex v to n-th and 1-st vertices respectively. For this you should construct graph of shortest paths and use dynamic programming on the constructed graph (because the new graph will be acyclic). To construct the graph of shortest paths you should leave only useful edges in original graph. It can be done, for example, using breadth-first search launched from vertices 1 and n respectively.After values cnt1[v] and cnt2[v] are found consider every useful edge (u, v) and add to vertices u and v value (cnt2[u] * cnt1[v]) / (cnt2[n–1]), which is the contribution of this edge in the sought quantity for the vertices u and v. Note that value (cnt2[n–1]) is the number of shortest paths between 1 and n. All said values can be found in time O(N + M). The complexity of solution is O(N + M).208D - Prizes, Prizes, more PrizesIn this problem every time you get points you should greedily get as much prizes as you can. For this, consider every prize from the most expensive and try to get as much as you can. If we have cnt points and the prize costs p points you can get prizes. So we get simple solution with complexity O(5 * N).208E - Blood CousinsIn this problem you have some set of rooted down- oriented trees. First, launch depth-first search from every root of every tree and renumber the vertices. Denote size of subtree of vertex v as cnt[v]. In this way all descendants of vertex v (including v) wiil have numbers [v;v + cnt[v]–1].Then we wiil handle requests (v, p) in their order. First, go up from vertex v on p steps to the root using binary rise like in LCA algorithm. Denote this vertex u. If u doesn’t exist print 0 else you should count the number of descendants of vertex u on the same height as vertex v.For this write all numbers of vertices for every height in some array. Then you should determine which of these vertices are descendants of u. You can do it using binary search in corresponding array. Find the segment of appropriate vertices (because we know the numbers of all descendants of u), find the amount of them, subtract one (vertex v), and this is the answer. The complexity of the solution is O(Nlog(N)).",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/4930",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 208\\s*A"
          },
          "content_length": 3353
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #130 (Div. 2) - Codeforces - Code 1",
          "code": "Solve the wrong version of problem E and got WA on pretest 8.\nNotice that the contest extended for 10 minutes.\nNotice the problem statement change and fix it quickly and submit it.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4924",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #130 (Div. 2) - Codeforces - Code 2",
          "code": "4\n0 1 2 2\n1\n4 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4924",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #130 (Div. 2) - Codeforces - Code 3",
          "code": "4\n0 1 2 2\n1\n4 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4924",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    string s = inf.readLine(\"[A-Z]+\", \"s\"); // Read line matching only uppercase letters\n    ensuref(s.length() <= 200, \"Length of input string must be at most 200, but it's %d\", (int)s.length());\n\n    vector<string> words;\n    size_t pos = 0;\n    while (pos < s.size()) {\n        if (s.substr(pos, 3) == \"WUB\") {\n            pos += 3;\n        } else {\n            size_t start = pos;\n            while (pos < s.size() && s.substr(pos, 3) != \"WUB\") {\n                pos++;\n            }\n            string word = s.substr(start, pos - start);\n            ensuref(word.find(\"WUB\") == string::npos, \"Found 'WUB' inside a word\");\n            words.push_back(word);\n        }\n    }\n\n    ensuref(!words.empty(), \"Initial song must contain at least one word\");\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    string s = inf.readLine(\"[A-Z]+\", \"s\"); // Read line matching only uppercase letters\n    ensuref(s.length() <= 200, \"Length of input string must be at most 200, but it's %d\", (int)s.length());\n\n    vector<string> words;\n    size_t pos = 0;\n    while (pos < s.size()) {\n        if (s.substr(pos, 3) == \"WUB\") {\n            pos += 3;\n        } else {\n            size_t start = pos;\n            while (pos < s.size() && s.substr(pos, 3) != \"WUB\") {\n                pos++;\n            }\n            string word = s.substr(start, pos - start);\n            ensuref(word.find(\"WUB\") == string::npos, \"Found 'WUB' inside a word\");\n            words.push_back(word);\n        }\n    }\n\n    ensuref(!words.empty(), \"Initial song must contain at least one word\");\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    string s = inf.readLine(\"[A-Z]+\", \"s\"); // Read line matching only uppercase letters\n    ensuref(s.length() <= 200, \"Length of input string must be at most 200, but it's %d\", (int)s.length());\n\n    vector<string> words;\n    size_t pos = 0;\n    while (pos < s.size()) {\n        if (s.substr(pos, 3) == \"WUB\") {\n            pos += 3;\n        } else {\n            size_t start = pos;\n            while (pos < s.size() && s.substr(pos, 3) != \"WUB\") {\n                pos++;\n            }\n            string word = s.substr(start, pos - start);\n            ensuref(word.find(\"WUB\") == string::npos, \"Found 'WUB' inside a word\");\n            words.push_back(word);\n        }\n    }\n\n    ensuref(!words.empty(), \"Initial song must contain at least one word\");\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare sequences of tokens\");\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string j, p;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n\r\n        ans.readWordTo(j);\r\n        ouf.readWordTo(p);\r\n\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s words differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  compress(j).c_str(), compress(p).c_str());\r\n    }\r\n\r\n    if (ans.seekEof() && ouf.seekEof()) {\r\n        if (n == 1)\r\n            quitf(_ok, \"\\\"%s\\\"\", compress(j).c_str());\r\n        else\r\n            quitf(_ok, \"%d tokens\", n);\r\n    } else {\r\n        if (ans.seekEof())\r\n            quitf(_wa, \"Participant output contains extra tokens\");\r\n        else\r\n            quitf(_wa, \"Unexpected EOF in the participants output\");\r\n    }\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring generate_word(int length) {\n    string word;\n    for (int i = 0; i < length; ++i) {\n        char c = rnd.next('A', 'Z');\n        word += c;\n    }\n    // Ensure word does not contain \"WUB\"\n    while (word.find(\"WUB\") != string::npos) {\n        int pos = word.find(\"WUB\");\n        word[pos] = rnd.next('A', 'Z');\n    }\n    return word;\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\", 1);\n    int maxl = opt<int>(\"maxl\", 10);\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<string> words;\n    int words_length = 0;\n    int min_total_length;\n\n    if (type == \"min\") {\n        n = 1;\n        string word = generate_word(1);\n        words.push_back(word);\n        words_length = 1;\n    } else if (type == \"max\") {\n        string word = generate_word(200);\n        words.push_back(word);\n        words_length = 200;\n    } else {\n        words_length = 0;\n        int max_words = n;\n        n = 0;\n        while (n < max_words) {\n            int max_word_length = min(maxl, 200 - words_length - (n) * 3);\n            if (max_word_length <= 0)\n                break;\n            int word_length = rnd.next(1, max_word_length);\n            string word = generate_word(word_length);\n            words.push_back(word);\n            words_length += word_length;\n            n++;\n        }\n        if (n == 0) {\n            n = 1;\n            int word_length = min(200, maxl);\n            string word = generate_word(word_length);\n            words.push_back(word);\n            words_length = word_length;\n        }\n        min_total_length = words_length + (n - 1) * 3;\n    }\n\n    int total_length = min_total_length;\n    int remaining_length = 200 - total_length;\n\n    int num_wubs_before = 0, num_wubs_after = 0;\n    vector<int> num_wubs_between(n - 1, 1);\n\n    if (type == \"min\") {\n    } else if (type == \"no_wubs\") {\n    } else if (type == \"wubs_max\") {\n        int total_wub_positions = n - 1 + 2;\n\n        int max_additional_wubs = remaining_length / 3;\n        int wubs_per_position = max_additional_wubs / total_wub_positions;\n\n        num_wubs_before += wubs_per_position;\n        num_wubs_after += wubs_per_position;\n        for (int i = 0; i < n - 1; ++i)\n            num_wubs_between[i] += wubs_per_position;\n\n        remaining_length -= wubs_per_position * 3 * total_wub_positions;\n\n        int position = 0;\n        while (remaining_length >= 3) {\n            if (position == 0)\n                num_wubs_before++;\n            else if (position == total_wub_positions - 1)\n                num_wubs_after++;\n            else\n                num_wubs_between[position - 1]++;\n            remaining_length -=3;\n            position = (position + 1) % total_wub_positions;\n        }\n    } else if (type == \"random\") {\n        int total_wub_positions = n - 1 + 2;\n        int max_additional_wubs = remaining_length / 3;\n\n        while (remaining_length >= 3 && max_additional_wubs > 0) {\n            int pos = rnd.next(0, total_wub_positions - 1);\n            if (pos == 0)\n                num_wubs_before++;\n            else if (pos == total_wub_positions - 1)\n                num_wubs_after++;\n            else\n                num_wubs_between[pos - 1]++;\n            remaining_length -= 3;\n            max_additional_wubs--;\n        }\n    }\n\n    string S;\n\n    for (int i = 0; i < num_wubs_before; ++i)\n        S += \"WUB\";\n\n    S += words[0];\n\n    for (int i = 1; i < n; ++i) {\n        for (int j = 0; j < num_wubs_between[i -1]; ++j)\n            S += \"WUB\";\n        S += words[i];\n    }\n\n    for (int i = 0; i < num_wubs_after; ++i)\n        S += \"WUB\";\n\n    if ((int)S.length() > 200) {\n        S = S.substr(0,200);\n    }\n\n    cout << S << endl;\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring generate_word(int length) {\n    string word;\n    for (int i = 0; i < length; ++i) {\n        char c = rnd.next('A', 'Z');\n        word += c;\n    }\n    // Ensure word does not contain \"WUB\"\n    while (word.find(\"WUB\") != string::npos) {\n        int pos = word.find(\"WUB\");\n        word[pos] = rnd.next('A', 'Z');\n    }\n    return word;\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\", 1);\n    int maxl = opt<int>(\"maxl\", 10);\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<string> words;\n    int words_length = 0;\n    int min_total_length;\n\n    if (type == \"min\") {\n        n = 1;\n        string word = generate_word(1);\n        words.push_back(word);\n        words_length = 1;\n    } else if (type == \"max\") {\n        string word = generate_word(200);\n        words.push_back(word);\n        words_length = 200;\n    } else {\n        words_length = 0;\n        int max_words = n;\n        n = 0;\n        while (n < max_words) {\n            int max_word_length = min(maxl, 200 - words_length - (n) * 3);\n            if (max_word_length <= 0)\n                break;\n            int word_length = rnd.next(1, max_word_length);\n            string word = generate_word(word_length);\n            words.push_back(word);\n            words_length += word_length;\n            n++;\n        }\n        if (n == 0) {\n            n = 1;\n            int word_length = min(200, maxl);\n            string word = generate_word(word_length);\n            words.push_back(word);\n            words_length = word_length;\n        }\n        min_total_length = words_length + (n - 1) * 3;\n    }\n\n    int total_length = min_total_length;\n    int remaining_length = 200 - total_length;\n\n    int num_wubs_before = 0, num_wubs_after = 0;\n    vector<int> num_wubs_between(n - 1, 1);\n\n    if (type == \"min\") {\n    } else if (type == \"no_wubs\") {\n    } else if (type == \"wubs_max\") {\n        int total_wub_positions = n - 1 + 2;\n\n        int max_additional_wubs = remaining_length / 3;\n        int wubs_per_position = max_additional_wubs / total_wub_positions;\n\n        num_wubs_before += wubs_per_position;\n        num_wubs_after += wubs_per_position;\n        for (int i = 0; i < n - 1; ++i)\n            num_wubs_between[i] += wubs_per_position;\n\n        remaining_length -= wubs_per_position * 3 * total_wub_positions;\n\n        int position = 0;\n        while (remaining_length >= 3) {\n            if (position == 0)\n                num_wubs_before++;\n            else if (position == total_wub_positions - 1)\n                num_wubs_after++;\n            else\n                num_wubs_between[position - 1]++;\n            remaining_length -=3;\n            position = (position + 1) % total_wub_positions;\n        }\n    } else if (type == \"random\") {\n        int total_wub_positions = n - 1 + 2;\n        int max_additional_wubs = remaining_length / 3;\n\n        while (remaining_length >= 3 && max_additional_wubs > 0) {\n            int pos = rnd.next(0, total_wub_positions - 1);\n            if (pos == 0)\n                num_wubs_before++;\n            else if (pos == total_wub_positions - 1)\n                num_wubs_after++;\n            else\n                num_wubs_between[pos - 1]++;\n            remaining_length -= 3;\n            max_additional_wubs--;\n        }\n    }\n\n    string S;\n\n    for (int i = 0; i < num_wubs_before; ++i)\n        S += \"WUB\";\n\n    S += words[0];\n\n    for (int i = 1; i < n; ++i) {\n        for (int j = 0; j < num_wubs_between[i -1]; ++j)\n            S += \"WUB\";\n        S += words[i];\n    }\n\n    for (int i = 0; i < num_wubs_after; ++i)\n        S += \"WUB\";\n\n    if ((int)S.length() > 200) {\n        S = S.substr(0,200);\n    }\n\n    cout << S << endl;\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -type min\n./gen -type max\n\n./gen -type single -n 1 -maxl 1\n./gen -type single -n 1 -maxl 10\n./gen -type single -n 1 -maxl 200\n\n./gen -type random -n 5 -maxl 5\n./gen -type random -n 10 -maxl 10\n./gen -type random -n 20 -maxl 5\n./gen -type random -n 50 -maxl 1\n./gen -type random -n 100 -maxl 2\n\n./gen -type wubs_max -n 5 -maxl 5\n./gen -type wubs_max -n 10 -maxl 10\n./gen -type wubs_max -n 20 -maxl 5\n\n./gen -type no_wubs -n 1 -maxl 200\n./gen -type no_wubs -n 2 -maxl 100\n./gen -type no_wubs -n 5 -maxl 40\n./gen -type no_wubs -n 10 -maxl 20\n\n./gen -type random -n 1 -maxl 200\n./gen -type random -n 2 -maxl 100\n./gen -type random -n 4 -maxl 50\n./gen -type random -n 20 -maxl 5\n\n./gen -type wubs_max -n 1 -maxl 200\n./gen -type wubs_max -n 2 -maxl 100\n./gen -type wubs_max -n 4 -maxl 50\n./gen -type wubs_max -n 20 -maxl 5\n\n./gen -type random -n 66 -maxl 1\n./gen -type random -n 33 -maxl 2\n./gen -type random -n 22 -maxl 3\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T19:48:54.335590",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "208/B",
      "title": "B. Solitaire",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first input line contains a single integer n (1 ≤ n ≤ 52) — the number of cards in Vasya's deck. The next line contains n space-separated strings c1, c2, ..., cn, where string ci describes the i-th card on the table. Each string ci consists of exactly two characters, the first one represents the card's value, the second one represents its suit. Cards on the table are numbered from left to right. A card's value is specified by one of these characters: \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\", \"T\", \"J\", \"Q\", \"K\", \"A\". A card's suit is specified by one of these characters: \"S\", \"D\", \"H\", \"C\".It is not guaranteed that the deck has all possible cards. Also, the cards in Vasya's deck can repeat.",
      "output_spec": "OutputOn a single line print the answer to the problem: string \"YES\" (without the quotes) if completing the solitaire is possible, string \"NO\" (without the quotes) otherwise.",
      "sample_tests": "ExamplesInputCopy42S 2S 2C 2COutputCopyYESInputCopy23S 2COutputCopyNO",
      "description": "B. Solitaire\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first input line contains a single integer n (1 ≤ n ≤ 52) — the number of cards in Vasya's deck. The next line contains n space-separated strings c1, c2, ..., cn, where string ci describes the i-th card on the table. Each string ci consists of exactly two characters, the first one represents the card's value, the second one represents its suit. Cards on the table are numbered from left to right. A card's value is specified by one of these characters: \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\", \"T\", \"J\", \"Q\", \"K\", \"A\". A card's suit is specified by one of these characters: \"S\", \"D\", \"H\", \"C\".It is not guaranteed that the deck has all possible cards. Also, the cards in Vasya's deck can repeat.\n\nOutputOn a single line print the answer to the problem: string \"YES\" (without the quotes) if completing the solitaire is possible, string \"NO\" (without the quotes) otherwise.\n\nInputCopy42S 2S 2C 2COutputCopyYESInputCopy23S 2COutputCopyNO\n\nInputCopy42S 2S 2C 2C\n\nOutputCopyYES\n\nInputCopy23S 2C\n\nOutputCopyNO\n\nNoteIn the first sample you can act like that:   put the 4-th pile on the 1-st one;  put the 3-rd pile on the 2-nd one;  put the 2-nd pile on the 1-st one. In the second sample there is no way to complete the solitaire.",
      "solutions": [
        {
          "title": "Codeforces Round #130 (Div. 2) - Codeforces",
          "content": "Welcome, friends)We are glad to introduce you regular Codeforces round #130 for Div.2 participants. Everyone can traditionally participate in it. There were some problems with registration of Div.1 participants, but now everything is alright)Problems are prepared by command of authors: Pavel Kholkin (HolkinPV), Nikolay Kuznetsov (NALP) and Gerald Agapov (Gerald). Traditionally thanks to Michael Mirzayanov (MikeMirzayanov) for perfect Codeforces system and Mary Belova (Delinur) for translating problems. Also thanks to Alexander Kouprin (Alex_KPR) and Pavel Kunyavskiy (PavelKunyavskiy) for their help.And again score distribution will be dynamic) More information you can find here.Note that all problems will be given in random order.We wish you good luck, successful hacks and high rating!UPD: the contest is over, no matter what, we hope you enjoyed the competitionUPD2: The authors apologize for the situation with the problem E. The problem has affected a small number of participants from div2 (22 participants) and the solution of original version of the problem doesn’t differ a lot (in most solutions is sufficient to remove a couple of lines, solutions become more simple). Therefore, it was adopted the following decision: for all 22 participants,who has problems with problem E and will have decrease of rating, the round is unrated. for everybody else the round is rated UPD3: after recalculation it was found that there are 20 such participants, not 22UPD4: unsuccessful hacks, which answers differed from the correct whitespaces, are decided to ignoreUPD5: tutorial can be found here",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/4924",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1603
        },
        {
          "title": "Codeforces Round #130 (Div. 2) Tutorial - Codeforces",
          "content": "First, arrange the problems in order of their difficulties. The authors assume such order: A, D, B, C, E. Now make the tutorial of problems in their order in the contest.208A - DubstepThis problem was technical. First, you should erase all occurrences or word WUB in the beginning and in the end of the string. And then parse the remaining string separating tokens by word WUB. Empty tokens should be also erased. Given string was rather small, you can realize the algorithm in any way.208B - SolitaireIn this problem you could write breadth-first search. The state is the following four elements: number of remaining piles and three strings — three rightmost cards on the top of three rightmost piles. We have two transitions in general case. We can take the rightmost pile and shift it left by 1 or 3 on another pile. If the number of remaining piles become 0 at some moment print YES, else print NO. The number of states is O(N4), the number of transitions 2, so the complexity of solution is O(N4).208C - Police StationIn this problem we will find the sought quantity for every vertex and find the maximum value. For this for every vertex v count two values: cnt1[v] and cnt2[v] — number of shortest paths from vertex v to n-th and 1-st vertices respectively. For this you should construct graph of shortest paths and use dynamic programming on the constructed graph (because the new graph will be acyclic). To construct the graph of shortest paths you should leave only useful edges in original graph. It can be done, for example, using breadth-first search launched from vertices 1 and n respectively.After values cnt1[v] and cnt2[v] are found consider every useful edge (u, v) and add to vertices u and v value (cnt2[u] * cnt1[v]) / (cnt2[n–1]), which is the contribution of this edge in the sought quantity for the vertices u and v. Note that value (cnt2[n–1]) is the number of shortest paths between 1 and n. All said values can be found in time O(N + M). The complexity of solution is O(N + M).208D - Prizes, Prizes, more PrizesIn this problem every time you get points you should greedily get as much prizes as you can. For this, consider every prize from the most expensive and try to get as much as you can. If we have cnt points and the prize costs p points you can get prizes. So we get simple solution with complexity O(5 * N).208E - Blood CousinsIn this problem you have some set of rooted down- oriented trees. First, launch depth-first search from every root of every tree and renumber the vertices. Denote size of subtree of vertex v as cnt[v]. In this way all descendants of vertex v (including v) wiil have numbers [v;v + cnt[v]–1].Then we wiil handle requests (v, p) in their order. First, go up from vertex v on p steps to the root using binary rise like in LCA algorithm. Denote this vertex u. If u doesn’t exist print 0 else you should count the number of descendants of vertex u on the same height as vertex v.For this write all numbers of vertices for every height in some array. Then you should determine which of these vertices are descendants of u. You can do it using binary search in corresponding array. Find the segment of appropriate vertices (because we know the numbers of all descendants of u), find the amount of them, subtract one (vertex v), and this is the answer. The complexity of the solution is O(Nlog(N)).",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/4930",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 208\\s*B"
          },
          "content_length": 3353
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #130 (Div. 2) - Codeforces - Code 1",
          "code": "Solve the wrong version of problem E and got WA on pretest 8.\nNotice that the contest extended for 10 minutes.\nNotice the problem statement change and fix it quickly and submit it.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4924",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #130 (Div. 2) - Codeforces - Code 2",
          "code": "4\n0 1 2 2\n1\n4 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4924",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #130 (Div. 2) - Codeforces - Code 3",
          "code": "4\n0 1 2 2\n1\n4 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4924",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 52, \"n\");\n    inf.readEoln();\n\n    string valid_values = \"23456789TJQKA\";\n    string valid_suits = \"SDHC\";\n\n    for (int i = 0; i < n; ++i) {\n        if (i > 0)\n            inf.readSpace();\n\n        string ci = inf.readToken();\n\n        ensuref(ci.size() == 2, \"Card %d has length %d, expected length 2\", i+1, int(ci.size()));\n        ensuref(valid_values.find(ci[0]) != string::npos, \"Card %d has invalid value character '%c'\", i+1, ci[0]);\n        ensuref(valid_suits.find(ci[1]) != string::npos, \"Card %d has invalid suit character '%c'\", i+1, ci[1]);\n    }\n\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 52, \"n\");\n    inf.readEoln();\n\n    string valid_values = \"23456789TJQKA\";\n    string valid_suits = \"SDHC\";\n\n    for (int i = 0; i < n; ++i) {\n        if (i > 0)\n            inf.readSpace();\n\n        string ci = inf.readToken();\n\n        ensuref(ci.size() == 2, \"Card %d has length %d, expected length 2\", i+1, int(ci.size()));\n        ensuref(valid_values.find(ci[0]) != string::npos, \"Card %d has invalid value character '%c'\", i+1, ci[0]);\n        ensuref(valid_suits.find(ci[1]) != string::npos, \"Card %d has invalid suit character '%c'\", i+1, ci[1]);\n    }\n\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 52, \"n\");\n    inf.readEoln();\n\n    string valid_values = \"23456789TJQKA\";\n    string valid_suits = \"SDHC\";\n\n    for (int i = 0; i < n; ++i) {\n        if (i > 0)\n            inf.readSpace();\n\n        string ci = inf.readToken();\n\n        ensuref(ci.size() == 2, \"Card %d has length %d, expected length 2\", i+1, int(ci.size()));\n        ensuref(valid_values.find(ci[0]) != string::npos, \"Card %d has invalid value character '%c'\", i+1, ci[0]);\n        ensuref(valid_suits.find(ci[1]) != string::npos, \"Card %d has invalid suit character '%c'\", i+1, ci[1]);\n    }\n\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n#include <string>\r\n\r\nusing namespace std;\r\n\r\nconst string YES = \"YES\";\r\nconst string NO = \"NO\";\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"%s\", (\"multiple \" + YES + \"/\" + NO + \" (case insensitive)\").c_str());\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int index = 0, yesCount = 0, noCount = 0;\r\n    string pa;\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        index++;\r\n        string ja = upperCase(ans.readToken());\r\n        pa = upperCase(ouf.readToken());\r\n\r\n        if (ja != YES && ja != NO)\r\n            quitf(_fail, \"%s or %s expected in answer, but %s found [%d%s token]\",\r\n                  YES.c_str(), NO.c_str(), compress(ja).c_str(), index, englishEnding(index).c_str());\r\n\r\n        if (pa == YES)\r\n            yesCount++;\r\n        else if (pa == NO)\r\n            noCount++;\r\n        else\r\n            quitf(_pe, \"%s or %s expected, but %s found [%d%s token]\",\r\n                  YES.c_str(), NO.c_str(), compress(pa).c_str(), index, englishEnding(index).c_str());\r\n\r\n        if (ja != pa)\r\n            quitf(_wa, \"expected %s, found %s [%d%s token]\",\r\n                  compress(ja).c_str(), compress(pa).c_str(), index, englishEnding(index).c_str());\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n    while (!ans.seekEof()) {\r\n        ans.readToken();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n    while (!ouf.seekEof()) {\r\n        ouf.readToken();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              index + extraInAnsCount, index);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              index + extraInOufCount, index);\r\n\r\n    if (index == 0)\r\n        quitf(_ok, \"Empty output\");\r\n    else if (index == 1)\r\n        quitf(_ok, \"%s\", pa.c_str());\r\n    else\r\n        quitf(_ok, \"%d token(s): yes count is %d, no count is %d\", index, yesCount, noCount);\r\n\r\n    quitf(_fail, \"Impossible case\");\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    // Validate n\n    if (n < 1 || n > 52) {\n        fprintf(stderr, \"Invalid n: n should be between 1 and 52.\\n\");\n        return 1;\n    }\n\n    vector<string> suits = {\"S\", \"H\", \"D\", \"C\"};\n    vector<string> values = {\"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\", \"T\", \"J\", \"Q\", \"K\", \"A\"};\n\n    // Stores the cards\n    vector<string> cards;\n\n    if (type == \"random\") {\n        // Generate random cards; duplicates allowed\n        for (int i = 0; i < n; ++i) {\n            string card = values[rnd.next(13)] + suits[rnd.next(4)];\n            cards.push_back(card);\n        }\n    } else if (type == \"same_value\") {\n        // All cards have the same value\n        string value = values[rnd.next(13)];\n        for (int i = 0; i < n; ++i) {\n            string suit = suits[rnd.next(4)];\n            cards.push_back(value + suit);\n        }\n    } else if (type == \"same_suit\") {\n        // All cards have the same suit\n        string suit = suits[rnd.next(4)];\n        for (int i = 0; i < n; ++i) {\n            string value = values[rnd.next(13)];\n            cards.push_back(value + suit);\n        }\n    } else if (type == \"alternating\") {\n        // Generate cards that alternate suits and values\n        for (int i = 0; i < n; ++i) {\n            string value = values[i % 13];\n            string suit = suits[i % 4];\n            cards.push_back(value + suit);\n        }\n        // Shuffle to avoid creating solvable patterns\n        shuffle(cards.begin(), cards.end());\n    } else if (type == \"unsolvable\") {\n        // For n <= 17\n        if (n > 17) {\n            fprintf(stderr, \"Invalid n for unsolvable type: n should be <= 17.\\n\");\n            return 1;\n        }\n        set<string> usedValues;\n        set<string> usedSuits;\n\n        vector<string> availableValues = values;\n        vector<string> availableSuits = suits;\n\n        shuffle(availableValues.begin(), availableValues.end());\n        shuffle(availableSuits.begin(), availableSuits.end());\n\n        for (int i = 0; i < n; ++i) {\n            string value, suit;\n            if (i < 13) {\n                value = availableValues[i];\n                usedValues.insert(value);\n            } else {\n                // Use remaining values\n                value = values[rnd.next(13)];\n                while (usedValues.count(value)) {\n                    value = values[rnd.next(13)];\n                }\n                usedValues.insert(value);\n            }\n            if (i < 4) {\n                suit = availableSuits[i];\n                usedSuits.insert(suit);\n            } else {\n                // Use remaining suits\n                suit = suits[rnd.next(4)];\n                while (usedSuits.count(suit)) {\n                    suit = suits[rnd.next(4)];\n                }\n                usedSuits.insert(suit);\n            }\n            cards.push_back(value + suit);\n        }\n        // Shuffle to avoid patterns\n        shuffle(cards.begin(), cards.end());\n    } else {\n        // Default to random\n        for (int i = 0; i < n; ++i) {\n            string card = values[rnd.next(13)] + suits[rnd.next(4)];\n            cards.push_back(card);\n        }\n    }\n\n    // Output the test case\n    printf(\"%d\\n\", n);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%s\", cards[i].c_str());\n        if (i != n - 1) printf(\" \");\n    }\n    printf(\"\\n\");\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    // Validate n\n    if (n < 1 || n > 52) {\n        fprintf(stderr, \"Invalid n: n should be between 1 and 52.\\n\");\n        return 1;\n    }\n\n    vector<string> suits = {\"S\", \"H\", \"D\", \"C\"};\n    vector<string> values = {\"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\", \"T\", \"J\", \"Q\", \"K\", \"A\"};\n\n    // Stores the cards\n    vector<string> cards;\n\n    if (type == \"random\") {\n        // Generate random cards; duplicates allowed\n        for (int i = 0; i < n; ++i) {\n            string card = values[rnd.next(13)] + suits[rnd.next(4)];\n            cards.push_back(card);\n        }\n    } else if (type == \"same_value\") {\n        // All cards have the same value\n        string value = values[rnd.next(13)];\n        for (int i = 0; i < n; ++i) {\n            string suit = suits[rnd.next(4)];\n            cards.push_back(value + suit);\n        }\n    } else if (type == \"same_suit\") {\n        // All cards have the same suit\n        string suit = suits[rnd.next(4)];\n        for (int i = 0; i < n; ++i) {\n            string value = values[rnd.next(13)];\n            cards.push_back(value + suit);\n        }\n    } else if (type == \"alternating\") {\n        // Generate cards that alternate suits and values\n        for (int i = 0; i < n; ++i) {\n            string value = values[i % 13];\n            string suit = suits[i % 4];\n            cards.push_back(value + suit);\n        }\n        // Shuffle to avoid creating solvable patterns\n        shuffle(cards.begin(), cards.end());\n    } else if (type == \"unsolvable\") {\n        // For n <= 17\n        if (n > 17) {\n            fprintf(stderr, \"Invalid n for unsolvable type: n should be <= 17.\\n\");\n            return 1;\n        }\n        set<string> usedValues;\n        set<string> usedSuits;\n\n        vector<string> availableValues = values;\n        vector<string> availableSuits = suits;\n\n        shuffle(availableValues.begin(), availableValues.end());\n        shuffle(availableSuits.begin(), availableSuits.end());\n\n        for (int i = 0; i < n; ++i) {\n            string value, suit;\n            if (i < 13) {\n                value = availableValues[i];\n                usedValues.insert(value);\n            } else {\n                // Use remaining values\n                value = values[rnd.next(13)];\n                while (usedValues.count(value)) {\n                    value = values[rnd.next(13)];\n                }\n                usedValues.insert(value);\n            }\n            if (i < 4) {\n                suit = availableSuits[i];\n                usedSuits.insert(suit);\n            } else {\n                // Use remaining suits\n                suit = suits[rnd.next(4)];\n                while (usedSuits.count(suit)) {\n                    suit = suits[rnd.next(4)];\n                }\n                usedSuits.insert(suit);\n            }\n            cards.push_back(value + suit);\n        }\n        // Shuffle to avoid patterns\n        shuffle(cards.begin(), cards.end());\n    } else {\n        // Default to random\n        for (int i = 0; i < n; ++i) {\n            string card = values[rnd.next(13)] + suits[rnd.next(4)];\n            cards.push_back(card);\n        }\n    }\n\n    // Output the test case\n    printf(\"%d\\n\", n);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%s\", cards[i].c_str());\n        if (i != n - 1) printf(\" \");\n    }\n    printf(\"\\n\");\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -type random\n./gen -n 2 -type same_value\n./gen -n 3 -type same_suit\n./gen -n 4 -type unsolvable\n./gen -n 5 -type alternating\n\n./gen -n 10 -type random\n./gen -n 10 -type same_value\n./gen -n 10 -type same_suit\n./gen -n 10 -type alternating\n\n./gen -n 15 -type random\n./gen -n 17 -type unsolvable\n\n./gen -n 20 -type random\n./gen -n 20 -type same_value\n./gen -n 20 -type same_suit\n./gen -n 20 -type alternating\n\n./gen -n 30 -type random\n./gen -n 30 -type same_value\n./gen -n 30 -type same_suit\n./gen -n 30 -type alternating\n\n./gen -n 40 -type random\n\n./gen -n 50 -type random\n\n./gen -n 52 -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T19:48:56.351319",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "208/C",
      "title": "C. Police Station",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first input line contains two integers n and m (2 ≤ n ≤ 100, ) — the number of cities and the number of roads in Berland, correspondingly. Next m lines contain pairs of integers vi, ui (1 ≤ vi, ui ≤ n, vi ≠ ui) — the numbers of cities that are connected by the i-th road. The numbers on a line are separated by a space. It is guaranteed that each pair of cities is connected with no more than one road and that it is possible to get from any city to any other one along Berland roads.",
      "output_spec": "OutputPrint the maximum possible value of the average number of safe roads among all shortest paths from the culture capital to the main one. The answer will be considered valid if its absolute or relative inaccuracy does not exceed 10 - 6.",
      "sample_tests": "ExamplesInputCopy4 41 22 41 33 4OutputCopy1.000000000000InputCopy11 141 21 32 43 44 54 65 116 111 88 99 711 71 1010 4OutputCopy1.714285714286",
      "description": "C. Police Station\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first input line contains two integers n and m (2 ≤ n ≤ 100, ) — the number of cities and the number of roads in Berland, correspondingly. Next m lines contain pairs of integers vi, ui (1 ≤ vi, ui ≤ n, vi ≠ ui) — the numbers of cities that are connected by the i-th road. The numbers on a line are separated by a space. It is guaranteed that each pair of cities is connected with no more than one road and that it is possible to get from any city to any other one along Berland roads.\n\nOutputPrint the maximum possible value of the average number of safe roads among all shortest paths from the culture capital to the main one. The answer will be considered valid if its absolute or relative inaccuracy does not exceed 10 - 6.\n\nInputCopy4 41 22 41 33 4OutputCopy1.000000000000InputCopy11 141 21 32 43 44 54 65 116 111 88 99 711 71 1010 4OutputCopy1.714285714286\n\nInputCopy4 41 22 41 33 4\n\nOutputCopy1.000000000000\n\nInputCopy11 141 21 32 43 44 54 65 116 111 88 99 711 71 1010 4\n\nOutputCopy1.714285714286\n\nNoteIn the first sample you can put a police station in one of the capitals, then each path will have exactly one safe road. If we place the station not in the capital, then the average number of safe roads will also make .In the second sample we can obtain the maximum sought value if we put the station in city 4, then 6 paths will have 2 safe roads each, and one path will have 0 safe roads, so the answer will equal .",
      "solutions": [
        {
          "title": "Codeforces Round #130 (Div. 2) - Codeforces",
          "content": "Welcome, friends)We are glad to introduce you regular Codeforces round #130 for Div.2 participants. Everyone can traditionally participate in it. There were some problems with registration of Div.1 participants, but now everything is alright)Problems are prepared by command of authors: Pavel Kholkin (HolkinPV), Nikolay Kuznetsov (NALP) and Gerald Agapov (Gerald). Traditionally thanks to Michael Mirzayanov (MikeMirzayanov) for perfect Codeforces system and Mary Belova (Delinur) for translating problems. Also thanks to Alexander Kouprin (Alex_KPR) and Pavel Kunyavskiy (PavelKunyavskiy) for their help.And again score distribution will be dynamic) More information you can find here.Note that all problems will be given in random order.We wish you good luck, successful hacks and high rating!UPD: the contest is over, no matter what, we hope you enjoyed the competitionUPD2: The authors apologize for the situation with the problem E. The problem has affected a small number of participants from div2 (22 participants) and the solution of original version of the problem doesn’t differ a lot (in most solutions is sufficient to remove a couple of lines, solutions become more simple). Therefore, it was adopted the following decision: for all 22 participants,who has problems with problem E and will have decrease of rating, the round is unrated. for everybody else the round is rated UPD3: after recalculation it was found that there are 20 such participants, not 22UPD4: unsuccessful hacks, which answers differed from the correct whitespaces, are decided to ignoreUPD5: tutorial can be found here",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/4924",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1603
        },
        {
          "title": "Codeforces Round #130 (Div. 2) Tutorial - Codeforces",
          "content": "First, arrange the problems in order of their difficulties. The authors assume such order: A, D, B, C, E. Now make the tutorial of problems in their order in the contest.208A - DubstepThis problem was technical. First, you should erase all occurrences or word WUB in the beginning and in the end of the string. And then parse the remaining string separating tokens by word WUB. Empty tokens should be also erased. Given string was rather small, you can realize the algorithm in any way.208B - SolitaireIn this problem you could write breadth-first search. The state is the following four elements: number of remaining piles and three strings — three rightmost cards on the top of three rightmost piles. We have two transitions in general case. We can take the rightmost pile and shift it left by 1 or 3 on another pile. If the number of remaining piles become 0 at some moment print YES, else print NO. The number of states is O(N4), the number of transitions 2, so the complexity of solution is O(N4).208C - Police StationIn this problem we will find the sought quantity for every vertex and find the maximum value. For this for every vertex v count two values: cnt1[v] and cnt2[v] — number of shortest paths from vertex v to n-th and 1-st vertices respectively. For this you should construct graph of shortest paths and use dynamic programming on the constructed graph (because the new graph will be acyclic). To construct the graph of shortest paths you should leave only useful edges in original graph. It can be done, for example, using breadth-first search launched from vertices 1 and n respectively.After values cnt1[v] and cnt2[v] are found consider every useful edge (u, v) and add to vertices u and v value (cnt2[u] * cnt1[v]) / (cnt2[n–1]), which is the contribution of this edge in the sought quantity for the vertices u and v. Note that value (cnt2[n–1]) is the number of shortest paths between 1 and n. All said values can be found in time O(N + M). The complexity of solution is O(N + M).208D - Prizes, Prizes, more PrizesIn this problem every time you get points you should greedily get as much prizes as you can. For this, consider every prize from the most expensive and try to get as much as you can. If we have cnt points and the prize costs p points you can get prizes. So we get simple solution with complexity O(5 * N).208E - Blood CousinsIn this problem you have some set of rooted down- oriented trees. First, launch depth-first search from every root of every tree and renumber the vertices. Denote size of subtree of vertex v as cnt[v]. In this way all descendants of vertex v (including v) wiil have numbers [v;v + cnt[v]–1].Then we wiil handle requests (v, p) in their order. First, go up from vertex v on p steps to the root using binary rise like in LCA algorithm. Denote this vertex u. If u doesn’t exist print 0 else you should count the number of descendants of vertex u on the same height as vertex v.For this write all numbers of vertices for every height in some array. Then you should determine which of these vertices are descendants of u. You can do it using binary search in corresponding array. Find the segment of appropriate vertices (because we know the numbers of all descendants of u), find the amount of them, subtract one (vertex v), and this is the answer. The complexity of the solution is O(Nlog(N)).",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/4930",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 208\\s*C"
          },
          "content_length": 3353
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #130 (Div. 2) - Codeforces - Code 1",
          "code": "Solve the wrong version of problem E and got WA on pretest 8.\nNotice that the contest extended for 10 minutes.\nNotice the problem statement change and fix it quickly and submit it.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4924",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #130 (Div. 2) - Codeforces - Code 2",
          "code": "4\n0 1 2 2\n1\n4 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4924",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #130 (Div. 2) - Codeforces - Code 3",
          "code": "4\n0 1 2 2\n1\n4 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4924",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<vector<int>> adj;\nvector<bool> visited;\n\nvoid dfs(int u) {\n    visited[u] = true;\n    for (int v : adj[u]) {\n        if (!visited[v]) dfs(v);\n    }\n}\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    \n    int n = inf.readInt(2, 100, \"n\");\n    inf.readSpace();\n    int mMax = n * (n - 1) / 2;\n    int mMin = n - 1;\n    int m = inf.readInt(mMin, mMax, \"m\");\n    inf.readEoln();\n\n    set<pair<int,int>> edges;\n    adj.resize(n + 1);\n\n    for (int i = 0; i < m; ++i) {\n        int vi = inf.readInt(1, n, \"vi\");\n        inf.readSpace();\n        int ui = inf.readInt(1, n, \"ui\");\n        inf.readEoln();\n        \n        ensuref(vi != ui, \"Self-loops are not allowed: edge from %d to %d\", vi, ui);\n\n        int a = min(vi, ui);\n        int b = max(vi, ui);\n        ensuref(edges.count({a, b}) == 0, \"Multiple edges between %d and %d are not allowed\", vi, ui);\n\n        edges.insert({a, b});\n\n        // Build adjacency list\n        adj[vi].push_back(ui);\n        adj[ui].push_back(vi);\n    }\n\n    // Check if the graph is connected\n    visited.resize(n + 1, false);\n    dfs(1);\n\n    for (int i = 1; i <= n; ++i) {\n        ensuref(visited[i], \"Graph is not connected: node %d is unreachable\", i);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<vector<int>> adj;\nvector<bool> visited;\n\nvoid dfs(int u) {\n    visited[u] = true;\n    for (int v : adj[u]) {\n        if (!visited[v]) dfs(v);\n    }\n}\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    \n    int n = inf.readInt(2, 100, \"n\");\n    inf.readSpace();\n    int mMax = n * (n - 1) / 2;\n    int mMin = n - 1;\n    int m = inf.readInt(mMin, mMax, \"m\");\n    inf.readEoln();\n\n    set<pair<int,int>> edges;\n    adj.resize(n + 1);\n\n    for (int i = 0; i < m; ++i) {\n        int vi = inf.readInt(1, n, \"vi\");\n        inf.readSpace();\n        int ui = inf.readInt(1, n, \"ui\");\n        inf.readEoln();\n        \n        ensuref(vi != ui, \"Self-loops are not allowed: edge from %d to %d\", vi, ui);\n\n        int a = min(vi, ui);\n        int b = max(vi, ui);\n        ensuref(edges.count({a, b}) == 0, \"Multiple edges between %d and %d are not allowed\", vi, ui);\n\n        edges.insert({a, b});\n\n        // Build adjacency list\n        adj[vi].push_back(ui);\n        adj[ui].push_back(vi);\n    }\n\n    // Check if the graph is connected\n    visited.resize(n + 1, false);\n    dfs(1);\n\n    for (int i = 1; i <= n; ++i) {\n        ensuref(visited[i], \"Graph is not connected: node %d is unreachable\", i);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<vector<int>> adj;\nvector<bool> visited;\n\nvoid dfs(int u) {\n    visited[u] = true;\n    for (int v : adj[u]) {\n        if (!visited[v]) dfs(v);\n    }\n}\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    \n    int n = inf.readInt(2, 100, \"n\");\n    inf.readSpace();\n    int mMax = n * (n - 1) / 2;\n    int mMin = n - 1;\n    int m = inf.readInt(mMin, mMax, \"m\");\n    inf.readEoln();\n\n    set<pair<int,int>> edges;\n    adj.resize(n + 1);\n\n    for (int i = 0; i < m; ++i) {\n        int vi = inf.readInt(1, n, \"vi\");\n        inf.readSpace();\n        int ui = inf.readInt(1, n, \"ui\");\n        inf.readEoln();\n        \n        ensuref(vi != ui, \"Self-loops are not allowed: edge from %d to %d\", vi, ui);\n\n        int a = min(vi, ui);\n        int b = max(vi, ui);\n        ensuref(edges.count({a, b}) == 0, \"Multiple edges between %d and %d are not allowed\", vi, ui);\n\n        edges.insert({a, b});\n\n        // Build adjacency list\n        adj[vi].push_back(ui);\n        adj[ui].push_back(vi);\n    }\n\n    // Check if the graph is connected\n    visited.resize(n + 1, false);\n    dfs(1);\n\n    for (int i = 1; i <= n; ++i) {\n        ensuref(visited[i], \"Graph is not connected: node %d is unreachable\", i);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nconst double EPS = 1E-6;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare two sequences of doubles, max absolute or relative  error = %.7f\", EPS);\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    double j = 0, p = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        n++;\r\n        j = ans.readDouble();\r\n        p = ouf.readDouble();\r\n        if (!doubleCompare(j, p, EPS)) {\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%.7f', found: '%.7f', error = '%.7f'\",\r\n                  n, englishEnding(n).c_str(), j, p, doubleDelta(j, p));\r\n        }\r\n    }\r\n\r\n    if (n == 1)\r\n        quitf(_ok, \"found '%.7f', expected '%.7f', error '%.7f'\", p, j, doubleDelta(j, p));\r\n\r\n    quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nvoid generate_line(int n) {\n    printf(\"%d %d\\n\", n, n - 1);\n    for (int i = 1; i < n; i++) {\n        printf(\"%d %d\\n\", i, i + 1);\n    }\n}\n\nvoid generate_star(int n) {\n    printf(\"%d %d\\n\", n, n - 1);\n    for (int i = 2; i <= n; i++) {\n        printf(\"%d %d\\n\", 1, i);\n    }\n}\n\nvoid generate_complete(int n) {\n    int m = n * (n - 1) / 2;\n    printf(\"%d %d\\n\", n, m);\n    for (int i = 1; i <= n; i++)\n        for (int j = i + 1; j <= n; j++)\n            printf(\"%d %d\\n\", i, j);\n}\n\nvoid generate_random(int n, int m) {\n    if (m < n - 1 || m > n * (n - 1) / 2) {\n        fprintf(stderr, \"Invalid number of edges m=%d for n=%d\\n\", m, n);\n        exit(1);\n    }\n\n    // Use DSU to generate a random tree\n    vector<int> parent(n + 1);\n    for (int i = 1; i <= n; ++i)\n        parent[i] = i;\n\n    function<int(int)> find = [&](int x) {\n        if (parent[x] != x)\n            parent[x] = find(parent[x]);\n        return parent[x];\n    };\n\n    set<pair<int, int>> edges;\n\n    // Build a random spanning tree\n    for (int i = 2; i <= n; ++i) {\n        int u = i;\n        int v = rnd.next(1, i - 1);\n\n        int pu = find(u);\n        int pv = find(v);\n        if (pu != pv) {\n            parent[pu] = pv;\n            if (u > v) swap(u, v);\n            edges.insert({u, v});\n        }\n    }\n\n    int required_edges = m - (n - 1);\n\n    // Generate all possible remaining edges\n    vector<pair<int, int>> possible_edges;\n    for (int u = 1; u <= n; ++u) {\n        for (int v = u + 1; v <= n; ++v) {\n            if (edges.count({u, v}) == 0) {\n                possible_edges.emplace_back(u, v);\n            }\n        }\n    }\n\n    shuffle(possible_edges.begin(), possible_edges.end());\n\n    for (int i = 0; i < required_edges; ++i) {\n        edges.insert(possible_edges[i]);\n    }\n\n    printf(\"%d %d\\n\", n, m);\n    for (auto e : edges) {\n        printf(\"%d %d\\n\", e.first, e.second);\n    }\n}\n\nvoid generate_multi_shortest(int n, int k) {\n    if (k + 2 > n) {\n        fprintf(stderr, \"k + 2 must be <= n\\n\");\n        exit(1);\n    }\n\n    vector<pair<int, int>> edges;\n\n    // Edges from node 1 to nodes 2 to k+1\n    for (int i = 2; i <= k + 1; ++i) {\n        edges.emplace_back(1, i);\n    }\n\n    // Edges from nodes 2 to k+1 to node n\n    for (int i = 2; i <= k + 1; ++i) {\n        edges.emplace_back(i, n);\n    }\n\n    // Connecting remaining nodes to 1 to ensure connectivity\n    for (int i = k + 2; i < n; ++i) {\n        edges.emplace_back(1, i);\n    }\n\n    int m = edges.size();\n\n    printf(\"%d %d\\n\", n, m);\n    for (auto e : edges) {\n        printf(\"%d %d\\n\", e.first, e.second);\n    }\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    if (type == \"line\") {\n        generate_line(n);\n    } else if (type == \"star\") {\n        generate_star(n);\n    } else if (type == \"complete\") {\n        generate_complete(n);\n    } else if (type == \"random\") {\n        int m = opt<int>(\"m\");\n        generate_random(n, m);\n    } else if (type == \"multi_shortest\") {\n        int k = opt<int>(\"k\");\n        generate_multi_shortest(n, k);\n    } else {\n        fprintf(stderr, \"Unknown type: %s\\n\", type.c_str());\n        exit(1);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nvoid generate_line(int n) {\n    printf(\"%d %d\\n\", n, n - 1);\n    for (int i = 1; i < n; i++) {\n        printf(\"%d %d\\n\", i, i + 1);\n    }\n}\n\nvoid generate_star(int n) {\n    printf(\"%d %d\\n\", n, n - 1);\n    for (int i = 2; i <= n; i++) {\n        printf(\"%d %d\\n\", 1, i);\n    }\n}\n\nvoid generate_complete(int n) {\n    int m = n * (n - 1) / 2;\n    printf(\"%d %d\\n\", n, m);\n    for (int i = 1; i <= n; i++)\n        for (int j = i + 1; j <= n; j++)\n            printf(\"%d %d\\n\", i, j);\n}\n\nvoid generate_random(int n, int m) {\n    if (m < n - 1 || m > n * (n - 1) / 2) {\n        fprintf(stderr, \"Invalid number of edges m=%d for n=%d\\n\", m, n);\n        exit(1);\n    }\n\n    // Use DSU to generate a random tree\n    vector<int> parent(n + 1);\n    for (int i = 1; i <= n; ++i)\n        parent[i] = i;\n\n    function<int(int)> find = [&](int x) {\n        if (parent[x] != x)\n            parent[x] = find(parent[x]);\n        return parent[x];\n    };\n\n    set<pair<int, int>> edges;\n\n    // Build a random spanning tree\n    for (int i = 2; i <= n; ++i) {\n        int u = i;\n        int v = rnd.next(1, i - 1);\n\n        int pu = find(u);\n        int pv = find(v);\n        if (pu != pv) {\n            parent[pu] = pv;\n            if (u > v) swap(u, v);\n            edges.insert({u, v});\n        }\n    }\n\n    int required_edges = m - (n - 1);\n\n    // Generate all possible remaining edges\n    vector<pair<int, int>> possible_edges;\n    for (int u = 1; u <= n; ++u) {\n        for (int v = u + 1; v <= n; ++v) {\n            if (edges.count({u, v}) == 0) {\n                possible_edges.emplace_back(u, v);\n            }\n        }\n    }\n\n    shuffle(possible_edges.begin(), possible_edges.end());\n\n    for (int i = 0; i < required_edges; ++i) {\n        edges.insert(possible_edges[i]);\n    }\n\n    printf(\"%d %d\\n\", n, m);\n    for (auto e : edges) {\n        printf(\"%d %d\\n\", e.first, e.second);\n    }\n}\n\nvoid generate_multi_shortest(int n, int k) {\n    if (k + 2 > n) {\n        fprintf(stderr, \"k + 2 must be <= n\\n\");\n        exit(1);\n    }\n\n    vector<pair<int, int>> edges;\n\n    // Edges from node 1 to nodes 2 to k+1\n    for (int i = 2; i <= k + 1; ++i) {\n        edges.emplace_back(1, i);\n    }\n\n    // Edges from nodes 2 to k+1 to node n\n    for (int i = 2; i <= k + 1; ++i) {\n        edges.emplace_back(i, n);\n    }\n\n    // Connecting remaining nodes to 1 to ensure connectivity\n    for (int i = k + 2; i < n; ++i) {\n        edges.emplace_back(1, i);\n    }\n\n    int m = edges.size();\n\n    printf(\"%d %d\\n\", n, m);\n    for (auto e : edges) {\n        printf(\"%d %d\\n\", e.first, e.second);\n    }\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    if (type == \"line\") {\n        generate_line(n);\n    } else if (type == \"star\") {\n        generate_star(n);\n    } else if (type == \"complete\") {\n        generate_complete(n);\n    } else if (type == \"random\") {\n        int m = opt<int>(\"m\");\n        generate_random(n, m);\n    } else if (type == \"multi_shortest\") {\n        int k = opt<int>(\"k\");\n        generate_multi_shortest(n, k);\n    } else {\n        fprintf(stderr, \"Unknown type: %s\\n\", type.c_str());\n        exit(1);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Line graphs\n./gen -n 2 -type line\n./gen -n 10 -type line\n./gen -n 100 -type line\n\n# Star graphs\n./gen -n 2 -type star\n./gen -n 10 -type star\n./gen -n 100 -type star\n\n# Complete graphs\n./gen -n 2 -type complete\n./gen -n 10 -type complete\n./gen -n 20 -type complete\n\n# Random graphs with varying m\n./gen -n 10 -m 15 -type random\n./gen -n 50 -m 100 -type random\n./gen -n 100 -m 1000 -type random\n./gen -n 100 -m 4950 -type random  # Maximum m for n=100\n\n# Graphs with multiple shortest paths\n./gen -n 10 -type multi_shortest -k 3\n./gen -n 20 -type multi_shortest -k 5\n./gen -n 50 -type multi_shortest -k 10\n./gen -n 100 -type multi_shortest -k 20\n\n# Edge cases\n./gen -n 3 -type multi_shortest -k 1\n./gen -n 4 -type multi_shortest -k 2\n\n# Random graphs with m = n(n-1)/2\n./gen -n 100 -m 4950 -type random\n./gen -n 50 -m 1225 -type random\n\n# Random graphs with m = n - 1 (minimal connected graphs)\n./gen -n 100 -m 99 -type random\n./gen -n 50 -m 49 -type random\n\n# Random graphs with m in middle range\n./gen -n 100 -m 2500 -type random\n./gen -n 50 -m 600 -type random\n\n# Additional small random graphs\n./gen -n 10 -m 9 -type random\n./gen -n 10 -m 45 -type random  # Complete graph for n=10\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T19:48:58.532506",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "208/D",
      "title": "D. Prizes, Prizes, more Prizes",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains a single integer n (1 ≤ n ≤ 50) — the number of chocolate bar wrappings that brought points to Vasya. The second line contains space-separated integers p1, p2, ..., pn (1 ≤ pi ≤ 109). The third line contains 5 integers a, b, c, d, e (1 ≤ a < b < c < d < e ≤ 109) — the prizes' costs.",
      "output_spec": "OutputPrint on the first line 5 integers, separated by a space — the number of mugs, towels, bags, bicycles and cars that Vasya has got, respectively. On the second line print a single integer — the number of points Vasya will have left after all operations of exchange are completed.Please, do not use the %lld specifier to read or write 64-bit integers in С++. It is preferred to use the cin, cout streams or the %I64d specifier.",
      "sample_tests": "ExamplesInputCopy33 10 42 4 10 15 20OutputCopy1 1 1 0 0 1InputCopy410 4 39 23 5 10 11 12OutputCopy3 0 1 0 3 0",
      "description": "D. Prizes, Prizes, more Prizes\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains a single integer n (1 ≤ n ≤ 50) — the number of chocolate bar wrappings that brought points to Vasya. The second line contains space-separated integers p1, p2, ..., pn (1 ≤ pi ≤ 109). The third line contains 5 integers a, b, c, d, e (1 ≤ a < b < c < d < e ≤ 109) — the prizes' costs.\n\nOutputPrint on the first line 5 integers, separated by a space — the number of mugs, towels, bags, bicycles and cars that Vasya has got, respectively. On the second line print a single integer — the number of points Vasya will have left after all operations of exchange are completed.Please, do not use the %lld specifier to read or write 64-bit integers in С++. It is preferred to use the cin, cout streams or the %I64d specifier.\n\nInputCopy33 10 42 4 10 15 20OutputCopy1 1 1 0 0 1InputCopy410 4 39 23 5 10 11 12OutputCopy3 0 1 0 3 0\n\nInputCopy33 10 42 4 10 15 20\n\nOutputCopy1 1 1 0 0 1\n\nInputCopy410 4 39 23 5 10 11 12\n\nOutputCopy3 0 1 0 3 0\n\nNoteIn the first sample Vasya gets 3 points after eating the first chocolate bar. Then he exchanges 2 points and gets a mug. Vasya wins a bag after eating the second chocolate bar. Then he wins a towel after eating the third chocolate bar. After all chocolate bars 3 - 2 + 10 - 10 + 4 - 4 = 1 points remains.",
      "solutions": [
        {
          "title": "Codeforces Round #130 (Div. 2) - Codeforces",
          "content": "Welcome, friends)We are glad to introduce you regular Codeforces round #130 for Div.2 participants. Everyone can traditionally participate in it. There were some problems with registration of Div.1 participants, but now everything is alright)Problems are prepared by command of authors: Pavel Kholkin (HolkinPV), Nikolay Kuznetsov (NALP) and Gerald Agapov (Gerald). Traditionally thanks to Michael Mirzayanov (MikeMirzayanov) for perfect Codeforces system and Mary Belova (Delinur) for translating problems. Also thanks to Alexander Kouprin (Alex_KPR) and Pavel Kunyavskiy (PavelKunyavskiy) for their help.And again score distribution will be dynamic) More information you can find here.Note that all problems will be given in random order.We wish you good luck, successful hacks and high rating!UPD: the contest is over, no matter what, we hope you enjoyed the competitionUPD2: The authors apologize for the situation with the problem E. The problem has affected a small number of participants from div2 (22 participants) and the solution of original version of the problem doesn’t differ a lot (in most solutions is sufficient to remove a couple of lines, solutions become more simple). Therefore, it was adopted the following decision: for all 22 participants,who has problems with problem E and will have decrease of rating, the round is unrated. for everybody else the round is rated UPD3: after recalculation it was found that there are 20 such participants, not 22UPD4: unsuccessful hacks, which answers differed from the correct whitespaces, are decided to ignoreUPD5: tutorial can be found here",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/4924",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1603
        },
        {
          "title": "Codeforces Round #130 (Div. 2) Tutorial - Codeforces",
          "content": "First, arrange the problems in order of their difficulties. The authors assume such order: A, D, B, C, E. Now make the tutorial of problems in their order in the contest.208A - DubstepThis problem was technical. First, you should erase all occurrences or word WUB in the beginning and in the end of the string. And then parse the remaining string separating tokens by word WUB. Empty tokens should be also erased. Given string was rather small, you can realize the algorithm in any way.208B - SolitaireIn this problem you could write breadth-first search. The state is the following four elements: number of remaining piles and three strings — three rightmost cards on the top of three rightmost piles. We have two transitions in general case. We can take the rightmost pile and shift it left by 1 or 3 on another pile. If the number of remaining piles become 0 at some moment print YES, else print NO. The number of states is O(N4), the number of transitions 2, so the complexity of solution is O(N4).208C - Police StationIn this problem we will find the sought quantity for every vertex and find the maximum value. For this for every vertex v count two values: cnt1[v] and cnt2[v] — number of shortest paths from vertex v to n-th and 1-st vertices respectively. For this you should construct graph of shortest paths and use dynamic programming on the constructed graph (because the new graph will be acyclic). To construct the graph of shortest paths you should leave only useful edges in original graph. It can be done, for example, using breadth-first search launched from vertices 1 and n respectively.After values cnt1[v] and cnt2[v] are found consider every useful edge (u, v) and add to vertices u and v value (cnt2[u] * cnt1[v]) / (cnt2[n–1]), which is the contribution of this edge in the sought quantity for the vertices u and v. Note that value (cnt2[n–1]) is the number of shortest paths between 1 and n. All said values can be found in time O(N + M). The complexity of solution is O(N + M).208D - Prizes, Prizes, more PrizesIn this problem every time you get points you should greedily get as much prizes as you can. For this, consider every prize from the most expensive and try to get as much as you can. If we have cnt points and the prize costs p points you can get prizes. So we get simple solution with complexity O(5 * N).208E - Blood CousinsIn this problem you have some set of rooted down- oriented trees. First, launch depth-first search from every root of every tree and renumber the vertices. Denote size of subtree of vertex v as cnt[v]. In this way all descendants of vertex v (including v) wiil have numbers [v;v + cnt[v]–1].Then we wiil handle requests (v, p) in their order. First, go up from vertex v on p steps to the root using binary rise like in LCA algorithm. Denote this vertex u. If u doesn’t exist print 0 else you should count the number of descendants of vertex u on the same height as vertex v.For this write all numbers of vertices for every height in some array. Then you should determine which of these vertices are descendants of u. You can do it using binary search in corresponding array. Find the segment of appropriate vertices (because we know the numbers of all descendants of u), find the amount of them, subtract one (vertex v), and this is the answer. The complexity of the solution is O(Nlog(N)).",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/4930",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 208\\s*D"
          },
          "content_length": 3353
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #130 (Div. 2) - Codeforces - Code 1",
          "code": "Solve the wrong version of problem E and got WA on pretest 8.\nNotice that the contest extended for 10 minutes.\nNotice the problem statement change and fix it quickly and submit it.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4924",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #130 (Div. 2) - Codeforces - Code 2",
          "code": "4\n0 1 2 2\n1\n4 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4924",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #130 (Div. 2) - Codeforces - Code 3",
          "code": "4\n0 1 2 2\n1\n4 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4924",
          "author": "Qingyu"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 50, \"n\");\n    inf.readEoln();\n\n    vector<int> p = inf.readInts(n, 1, 1000000000, \"p\");\n    inf.readEoln();\n\n    int a = inf.readInt(1, 1000000000, \"a\");\n    inf.readSpace();\n    int b = inf.readInt(1, 1000000000, \"b\");\n    inf.readSpace();\n    int c = inf.readInt(1, 1000000000, \"c\");\n    inf.readSpace();\n    int d = inf.readInt(1, 1000000000, \"d\");\n    inf.readSpace();\n    int e = inf.readInt(1, 1000000000, \"e\");\n    inf.readEoln();\n\n    ensuref(a < b, \"Prizes' costs should satisfy a < b, but a=%d, b=%d\", a, b);\n    ensuref(b < c, \"Prizes' costs should satisfy b < c, but b=%d, c=%d\", b, c);\n    ensuref(c < d, \"Prizes' costs should satisfy c < d, but c=%d, d=%d\", c, d);\n    ensuref(d < e, \"Prizes' costs should satisfy d < e, but d=%d, e=%d\", d, e);\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 50, \"n\");\n    inf.readEoln();\n\n    vector<int> p = inf.readInts(n, 1, 1000000000, \"p\");\n    inf.readEoln();\n\n    int a = inf.readInt(1, 1000000000, \"a\");\n    inf.readSpace();\n    int b = inf.readInt(1, 1000000000, \"b\");\n    inf.readSpace();\n    int c = inf.readInt(1, 1000000000, \"c\");\n    inf.readSpace();\n    int d = inf.readInt(1, 1000000000, \"d\");\n    inf.readSpace();\n    int e = inf.readInt(1, 1000000000, \"e\");\n    inf.readEoln();\n\n    ensuref(a < b, \"Prizes' costs should satisfy a < b, but a=%d, b=%d\", a, b);\n    ensuref(b < c, \"Prizes' costs should satisfy b < c, but b=%d, c=%d\", b, c);\n    ensuref(c < d, \"Prizes' costs should satisfy c < d, but c=%d, d=%d\", c, d);\n    ensuref(d < e, \"Prizes' costs should satisfy d < e, but d=%d, e=%d\", d, e);\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 50, \"n\");\n    inf.readEoln();\n\n    vector<int> p = inf.readInts(n, 1, 1000000000, \"p\");\n    inf.readEoln();\n\n    int a = inf.readInt(1, 1000000000, \"a\");\n    inf.readSpace();\n    int b = inf.readInt(1, 1000000000, \"b\");\n    inf.readSpace();\n    int c = inf.readInt(1, 1000000000, \"c\");\n    inf.readSpace();\n    int d = inf.readInt(1, 1000000000, \"d\");\n    inf.readSpace();\n    int e = inf.readInt(1, 1000000000, \"e\");\n    inf.readEoln();\n\n    ensuref(a < b, \"Prizes' costs should satisfy a < b, but a=%d, b=%d\", a, b);\n    ensuref(b < c, \"Prizes' costs should satisfy b < c, but b=%d, c=%d\", b, c);\n    ensuref(c < d, \"Prizes' costs should satisfy c < d, but c=%d, d=%d\", c, d);\n    ensuref(d < e, \"Prizes' costs should satisfy d < e, but d=%d, e=%d\", d, e);\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n    int n = opt<int>(\"n\");\n    string pi_type = opt<string>(\"pi_type\", \"random\");\n    string prize_type = opt<string>(\"prize_type\", \"random\");\n\n    // Generate prize costs\n    vector<int> a(5);\n    if (prize_type == \"random\") {\n        set<int> st;\n        while ((int)st.size() < 5) {\n            st.insert(rnd.next(1, 1000000000));\n        }\n        a.assign(st.begin(), st.end());\n        sort(a.begin(), a.end());\n    } else if (prize_type == \"small\") {\n        set<int> st;\n        while ((int)st.size() < 5) {\n            st.insert(rnd.next(1,100));\n        }\n        a.assign(st.begin(), st.end());\n        sort(a.begin(), a.end());\n    } else if (prize_type == \"big\") {\n        set<int> st;\n        while ((int)st.size() < 5) {\n            st.insert(rnd.next(1000000000 - 100,1000000000));\n        }\n        a.assign(st.begin(), st.end());\n        sort(a.begin(), a.end());\n    } else if (prize_type == \"equal_gap\") {\n        int min_a = 1;\n        int max_a = 1000000000;\n        int gap = (max_a - min_a) / 5;\n        a[0] = min_a + gap;\n        for(int i = 1; i < 5; ++i) {\n            a[i] = a[i-1] + gap;\n        }\n        // Ensure prizes are strictly increasing and within bounds\n        for(int i = 1; i < 5; ++i) {\n            if (a[i] <= a[i-1]) {\n                a[i] = a[i-1] + 1;\n            }\n        }\n        if(a[4] > max_a) a[4] = max_a;\n    } else if (prize_type == \"equal_prizes\") {\n        a[0] = 1000000000 - 4;\n        a[1] = 1000000000 - 3;\n        a[2] = 1000000000 - 2;\n        a[3] = 1000000000 - 1;\n        a[4] = 1000000000;\n    } else {\n        // Default random\n        set<int> st;\n        while ((int)st.size() < 5) {\n            st.insert(rnd.next(1, 1000000000));\n        }\n        a.assign(st.begin(), st.end());\n        sort(a.begin(), a.end());\n    }\n\n    // Generate p[i]\n    vector<long long> p(n);\n    if (pi_type == \"random\") {\n        for(int i = 0; i < n; ++i) {\n            p[i] = rnd.next(1LL, 1000000000LL);\n        }\n    } else if (pi_type == \"max\") {\n        for(int i = 0; i < n; ++i) {\n            p[i] = 1000000000LL;\n        }\n    } else if (pi_type == \"min\") {\n        for(int i = 0; i < n; ++i) {\n            p[i] = 1LL;\n        }\n    } else if (pi_type == \"increasing\") {\n        p[0] = 1;\n        long long max_p = 1000000000LL;\n        long long delta = (max_p - 1) / (n -1 > 0 ? n -1 : 1);\n        for(int i = 1; i < n; ++i) {\n            p[i] = p[i-1] + delta;\n            if(p[i] > max_p) p[i] = max_p;\n        }\n    } else if (pi_type == \"decreasing\") {\n        p[0] = 1000000000LL;\n        long long min_p = 1;\n        long long delta = (1000000000LL - 1) / (n -1 > 0 ? n -1 : 1);\n        for(int i = 1; i < n; ++i) {\n            p[i] = p[i-1] - delta;\n            if(p[i] < min_p) p[i] = min_p;\n        }\n    } else if (pi_type == \"exact_exchange\") {\n        if(n < 5) {\n            for(int i = 0; i < n; ++i)\n                p[i] = 1LL;\n        } else {\n            p[0] = a[0];\n            for(int i = 1; i < 5; ++i) {\n                p[i] = a[i] - a[i-1];\n            }\n            for(int i = 5; i < n; ++i) {\n                p[i] = 1LL;\n            }\n        }\n    } else {\n        // Default random\n        for(int i = 0; i < n; ++i) {\n            p[i] = rnd.next(1LL, 1000000000LL);\n        }\n    }\n\n    // Output\n    printf(\"%d\\n\", n);\n    for(int i = 0; i < n; ++i) {\n        printf(\"%lld%c\", p[i], i == n -1 ? '\\n' : ' ');\n    }\n    for(int i = 0; i < 5; ++i) {\n        printf(\"%d%c\", a[i], i == 4 ? '\\n' : ' ');\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n    int n = opt<int>(\"n\");\n    string pi_type = opt<string>(\"pi_type\", \"random\");\n    string prize_type = opt<string>(\"prize_type\", \"random\");\n\n    // Generate prize costs\n    vector<int> a(5);\n    if (prize_type == \"random\") {\n        set<int> st;\n        while ((int)st.size() < 5) {\n            st.insert(rnd.next(1, 1000000000));\n        }\n        a.assign(st.begin(), st.end());\n        sort(a.begin(), a.end());\n    } else if (prize_type == \"small\") {\n        set<int> st;\n        while ((int)st.size() < 5) {\n            st.insert(rnd.next(1,100));\n        }\n        a.assign(st.begin(), st.end());\n        sort(a.begin(), a.end());\n    } else if (prize_type == \"big\") {\n        set<int> st;\n        while ((int)st.size() < 5) {\n            st.insert(rnd.next(1000000000 - 100,1000000000));\n        }\n        a.assign(st.begin(), st.end());\n        sort(a.begin(), a.end());\n    } else if (prize_type == \"equal_gap\") {\n        int min_a = 1;\n        int max_a = 1000000000;\n        int gap = (max_a - min_a) / 5;\n        a[0] = min_a + gap;\n        for(int i = 1; i < 5; ++i) {\n            a[i] = a[i-1] + gap;\n        }\n        // Ensure prizes are strictly increasing and within bounds\n        for(int i = 1; i < 5; ++i) {\n            if (a[i] <= a[i-1]) {\n                a[i] = a[i-1] + 1;\n            }\n        }\n        if(a[4] > max_a) a[4] = max_a;\n    } else if (prize_type == \"equal_prizes\") {\n        a[0] = 1000000000 - 4;\n        a[1] = 1000000000 - 3;\n        a[2] = 1000000000 - 2;\n        a[3] = 1000000000 - 1;\n        a[4] = 1000000000;\n    } else {\n        // Default random\n        set<int> st;\n        while ((int)st.size() < 5) {\n            st.insert(rnd.next(1, 1000000000));\n        }\n        a.assign(st.begin(), st.end());\n        sort(a.begin(), a.end());\n    }\n\n    // Generate p[i]\n    vector<long long> p(n);\n    if (pi_type == \"random\") {\n        for(int i = 0; i < n; ++i) {\n            p[i] = rnd.next(1LL, 1000000000LL);\n        }\n    } else if (pi_type == \"max\") {\n        for(int i = 0; i < n; ++i) {\n            p[i] = 1000000000LL;\n        }\n    } else if (pi_type == \"min\") {\n        for(int i = 0; i < n; ++i) {\n            p[i] = 1LL;\n        }\n    } else if (pi_type == \"increasing\") {\n        p[0] = 1;\n        long long max_p = 1000000000LL;\n        long long delta = (max_p - 1) / (n -1 > 0 ? n -1 : 1);\n        for(int i = 1; i < n; ++i) {\n            p[i] = p[i-1] + delta;\n            if(p[i] > max_p) p[i] = max_p;\n        }\n    } else if (pi_type == \"decreasing\") {\n        p[0] = 1000000000LL;\n        long long min_p = 1;\n        long long delta = (1000000000LL - 1) / (n -1 > 0 ? n -1 : 1);\n        for(int i = 1; i < n; ++i) {\n            p[i] = p[i-1] - delta;\n            if(p[i] < min_p) p[i] = min_p;\n        }\n    } else if (pi_type == \"exact_exchange\") {\n        if(n < 5) {\n            for(int i = 0; i < n; ++i)\n                p[i] = 1LL;\n        } else {\n            p[0] = a[0];\n            for(int i = 1; i < 5; ++i) {\n                p[i] = a[i] - a[i-1];\n            }\n            for(int i = 5; i < n; ++i) {\n                p[i] = 1LL;\n            }\n        }\n    } else {\n        // Default random\n        for(int i = 0; i < n; ++i) {\n            p[i] = rnd.next(1LL, 1000000000LL);\n        }\n    }\n\n    // Output\n    printf(\"%d\\n\", n);\n    for(int i = 0; i < n; ++i) {\n        printf(\"%lld%c\", p[i], i == n -1 ? '\\n' : ' ');\n    }\n    for(int i = 0; i < 5; ++i) {\n        printf(\"%d%c\", a[i], i == 4 ? '\\n' : ' ');\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 50 -pi_type random -prize_type random\n./gen -n 50 -pi_type max -prize_type random\n./gen -n 50 -pi_type min -prize_type random\n./gen -n 50 -pi_type increasing -prize_type random\n./gen -n 50 -pi_type decreasing -prize_type random\n./gen -n 50 -pi_type exact_exchange -prize_type random\n\n./gen -n 50 -pi_type random -prize_type small\n./gen -n 50 -pi_type max -prize_type small\n./gen -n 50 -pi_type min -prize_type small\n./gen -n 50 -pi_type increasing -prize_type small\n./gen -n 50 -pi_type decreasing -prize_type small\n./gen -n 50 -pi_type exact_exchange -prize_type small\n\n./gen -n 50 -pi_type random -prize_type big\n./gen -n 50 -pi_type max -prize_type big\n./gen -n 50 -pi_type min -prize_type big\n./gen -n 50 -pi_type increasing -prize_type big\n./gen -n 50 -pi_type decreasing -prize_type big\n./gen -n 50 -pi_type exact_exchange -prize_type big\n\n./gen -n 1 -pi_type random -prize_type random\n./gen -n 1 -pi_type exact_exchange -prize_type random\n\n./gen -n 10 -pi_type random -prize_type random\n./gen -n 20 -pi_type random -prize_type equal_gap\n./gen -n 30 -pi_type random -prize_type equal_prizes\n\n./gen -n 50 -pi_type increasing -prize_type equal_prizes\n./gen -n 50 -pi_type decreasing -prize_type equal_gap\n./gen -n 50 -pi_type exact_exchange -prize_type equal_prizes\n\n./gen -n 50 -pi_type exact_exchange -prize_type equal_gap\n\n./gen -n 50 -pi_type random -prize_type equal_gap\n\n./gen -n 50 -pi_type min -prize_type equal_gap\n\n./gen -n 50 -pi_type max -prize_type equal_prizes\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T19:49:00.677656",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "208/E",
      "title": "E. Blood Cousins",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first input line contains a single integer n (1 ≤ n ≤ 105) — the number of people in the tree. The next line contains n space-separated integers r1, r2, ..., rn, where ri (1 ≤ ri ≤ n) is the number of person i's parent or 0, if person i has no parent. It is guaranteed that family relationships don't form cycles.The third line contains a single number m (1 ≤ m ≤ 105) — the number of family relationship queries Polycarus has. Next m lines contain pairs of space-separated integers. The i-th line contains numbers vi, pi (1 ≤ vi, pi ≤ n).",
      "output_spec": "OutputPrint m space-separated integers — the answers to Polycarpus' queries. Print the answers to the queries in the order, in which the queries occur in the input.",
      "sample_tests": "ExamplesInputCopy60 1 1 0 4 471 11 22 12 24 15 16 1OutputCopy0 0 1 0 0 1 1",
      "description": "E. Blood Cousins\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first input line contains a single integer n (1 ≤ n ≤ 105) — the number of people in the tree. The next line contains n space-separated integers r1, r2, ..., rn, where ri (1 ≤ ri ≤ n) is the number of person i's parent or 0, if person i has no parent. It is guaranteed that family relationships don't form cycles.The third line contains a single number m (1 ≤ m ≤ 105) — the number of family relationship queries Polycarus has. Next m lines contain pairs of space-separated integers. The i-th line contains numbers vi, pi (1 ≤ vi, pi ≤ n).\n\nOutputPrint m space-separated integers — the answers to Polycarpus' queries. Print the answers to the queries in the order, in which the queries occur in the input.\n\nInputCopy60 1 1 0 4 471 11 22 12 24 15 16 1OutputCopy0 0 1 0 0 1 1\n\nInputCopy60 1 1 0 4 471 11 22 12 24 15 16 1\n\nOutputCopy0 0 1 0 0 1 1",
      "solutions": [
        {
          "title": "Codeforces Round #130 (Div. 2) - Codeforces",
          "content": "Welcome, friends)We are glad to introduce you regular Codeforces round #130 for Div.2 participants. Everyone can traditionally participate in it. There were some problems with registration of Div.1 participants, but now everything is alright)Problems are prepared by command of authors: Pavel Kholkin (HolkinPV), Nikolay Kuznetsov (NALP) and Gerald Agapov (Gerald). Traditionally thanks to Michael Mirzayanov (MikeMirzayanov) for perfect Codeforces system and Mary Belova (Delinur) for translating problems. Also thanks to Alexander Kouprin (Alex_KPR) and Pavel Kunyavskiy (PavelKunyavskiy) for their help.And again score distribution will be dynamic) More information you can find here.Note that all problems will be given in random order.We wish you good luck, successful hacks and high rating!UPD: the contest is over, no matter what, we hope you enjoyed the competitionUPD2: The authors apologize for the situation with the problem E. The problem has affected a small number of participants from div2 (22 participants) and the solution of original version of the problem doesn’t differ a lot (in most solutions is sufficient to remove a couple of lines, solutions become more simple). Therefore, it was adopted the following decision: for all 22 participants,who has problems with problem E and will have decrease of rating, the round is unrated. for everybody else the round is rated UPD3: after recalculation it was found that there are 20 such participants, not 22UPD4: unsuccessful hacks, which answers differed from the correct whitespaces, are decided to ignoreUPD5: tutorial can be found here",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/4924",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1603
        },
        {
          "title": "Codeforces Round #130 (Div. 2) Tutorial - Codeforces",
          "content": "First, arrange the problems in order of their difficulties. The authors assume such order: A, D, B, C, E. Now make the tutorial of problems in their order in the contest.208A - DubstepThis problem was technical. First, you should erase all occurrences or word WUB in the beginning and in the end of the string. And then parse the remaining string separating tokens by word WUB. Empty tokens should be also erased. Given string was rather small, you can realize the algorithm in any way.208B - SolitaireIn this problem you could write breadth-first search. The state is the following four elements: number of remaining piles and three strings — three rightmost cards on the top of three rightmost piles. We have two transitions in general case. We can take the rightmost pile and shift it left by 1 or 3 on another pile. If the number of remaining piles become 0 at some moment print YES, else print NO. The number of states is O(N4), the number of transitions 2, so the complexity of solution is O(N4).208C - Police StationIn this problem we will find the sought quantity for every vertex and find the maximum value. For this for every vertex v count two values: cnt1[v] and cnt2[v] — number of shortest paths from vertex v to n-th and 1-st vertices respectively. For this you should construct graph of shortest paths and use dynamic programming on the constructed graph (because the new graph will be acyclic). To construct the graph of shortest paths you should leave only useful edges in original graph. It can be done, for example, using breadth-first search launched from vertices 1 and n respectively.After values cnt1[v] and cnt2[v] are found consider every useful edge (u, v) and add to vertices u and v value (cnt2[u] * cnt1[v]) / (cnt2[n–1]), which is the contribution of this edge in the sought quantity for the vertices u and v. Note that value (cnt2[n–1]) is the number of shortest paths between 1 and n. All said values can be found in time O(N + M). The complexity of solution is O(N + M).208D - Prizes, Prizes, more PrizesIn this problem every time you get points you should greedily get as much prizes as you can. For this, consider every prize from the most expensive and try to get as much as you can. If we have cnt points and the prize costs p points you can get prizes. So we get simple solution with complexity O(5 * N).208E - Blood CousinsIn this problem you have some set of rooted down- oriented trees. First, launch depth-first search from every root of every tree and renumber the vertices. Denote size of subtree of vertex v as cnt[v]. In this way all descendants of vertex v (including v) wiil have numbers [v;v + cnt[v]–1].Then we wiil handle requests (v, p) in their order. First, go up from vertex v on p steps to the root using binary rise like in LCA algorithm. Denote this vertex u. If u doesn’t exist print 0 else you should count the number of descendants of vertex u on the same height as vertex v.For this write all numbers of vertices for every height in some array. Then you should determine which of these vertices are descendants of u. You can do it using binary search in corresponding array. Find the segment of appropriate vertices (because we know the numbers of all descendants of u), find the amount of them, subtract one (vertex v), and this is the answer. The complexity of the solution is O(Nlog(N)).",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/4930",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 208\\s*E"
          },
          "content_length": 3353
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #130 (Div. 2) - Codeforces - Code 1",
          "code": "Solve the wrong version of problem E and got WA on pretest 8.\nNotice that the contest extended for 10 minutes.\nNotice the problem statement change and fix it quickly and submit it.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4924",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #130 (Div. 2) - Codeforces - Code 2",
          "code": "4\n0 1 2 2\n1\n4 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4924",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #130 (Div. 2) - Codeforces - Code 3",
          "code": "4\n0 1 2 2\n1\n4 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4924",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAXN = 100005;\nvector<int> parent(MAXN);\nvector<int> state(MAXN); // 0 = unvisited, 1 = processing, 2 = processed\n\nvoid dfs(int u) {\n    if (state[u] == 1) {\n        ensuref(false, \"Cycle detected at person %d\", u);\n    }\n    if (state[u] == 2) return;\n    state[u] = 1;\n    if (parent[u] != 0) {\n        dfs(parent[u]);\n    }\n    state[u] = 2;\n}\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n    vector<int> ri = inf.readInts(n, 0, n, \"ri\");\n    inf.readEoln();\n    for (int i = 0; i < n; i++) {\n        int p = ri[i];\n        int u = i + 1;\n        parent[u] = p;\n        if (p != 0) {\n            ensuref(p != u, \"Person %d cannot be his own parent\", u);\n        }\n    }\n    for (int u = 1; u <= n; u++) {\n        if (state[u] == 0) {\n            dfs(u);\n        }\n    }\n    int m = inf.readInt(1, 100000, \"m\");\n    inf.readEoln();\n    for (int i = 0; i < m; i++) {\n        int vi = inf.readInt(1, n, \"vi\");\n        inf.readSpace();\n        int pi = inf.readInt(1, n, \"pi\");\n        inf.readEoln();\n    }\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAXN = 100005;\nvector<int> parent(MAXN);\nvector<int> state(MAXN); // 0 = unvisited, 1 = processing, 2 = processed\n\nvoid dfs(int u) {\n    if (state[u] == 1) {\n        ensuref(false, \"Cycle detected at person %d\", u);\n    }\n    if (state[u] == 2) return;\n    state[u] = 1;\n    if (parent[u] != 0) {\n        dfs(parent[u]);\n    }\n    state[u] = 2;\n}\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n    vector<int> ri = inf.readInts(n, 0, n, \"ri\");\n    inf.readEoln();\n    for (int i = 0; i < n; i++) {\n        int p = ri[i];\n        int u = i + 1;\n        parent[u] = p;\n        if (p != 0) {\n            ensuref(p != u, \"Person %d cannot be his own parent\", u);\n        }\n    }\n    for (int u = 1; u <= n; u++) {\n        if (state[u] == 0) {\n            dfs(u);\n        }\n    }\n    int m = inf.readInt(1, 100000, \"m\");\n    inf.readEoln();\n    for (int i = 0; i < m; i++) {\n        int vi = inf.readInt(1, n, \"vi\");\n        inf.readSpace();\n        int pi = inf.readInt(1, n, \"pi\");\n        inf.readEoln();\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAXN = 100005;\nvector<int> parent(MAXN);\nvector<int> state(MAXN); // 0 = unvisited, 1 = processing, 2 = processed\n\nvoid dfs(int u) {\n    if (state[u] == 1) {\n        ensuref(false, \"Cycle detected at person %d\", u);\n    }\n    if (state[u] == 2) return;\n    state[u] = 1;\n    if (parent[u] != 0) {\n        dfs(parent[u]);\n    }\n    state[u] = 2;\n}\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n    vector<int> ri = inf.readInts(n, 0, n, \"ri\");\n    inf.readEoln();\n    for (int i = 0; i < n; i++) {\n        int p = ri[i];\n        int u = i + 1;\n        parent[u] = p;\n        if (p != 0) {\n            ensuref(p != u, \"Person %d cannot be his own parent\", u);\n        }\n    }\n    for (int u = 1; u <= n; u++) {\n        if (state[u] == 0) {\n            dfs(u);\n        }\n    }\n    int m = inf.readInt(1, 100000, \"m\");\n    inf.readEoln();\n    for (int i = 0; i < m; i++) {\n        int vi = inf.readInt(1, n, \"vi\");\n        inf.readSpace();\n        int pi = inf.readInt(1, n, \"pi\");\n        inf.readEoln();\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 100005;\nint p[N];\nint depth[N];\nint n, m, k;\nstring tree_type;\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    n = opt<int>(\"n\");\n    m = opt<int>(\"m\", n); // default m = n\n    tree_type = opt<string>(\"type\", \"random\");\n    k = opt<int>(\"k\", 2); // default k=2\n\n    if (n >= N) n = N - 1; // Ensure n is within N\n    if (m > n) m = n;\n\n    // Generate the tree\n    if (tree_type == \"chain\") {\n        p[1] = 0;\n        depth[1] = 1;\n        for (int i = 2; i <= n; ++i) {\n            p[i] = i - 1;\n            depth[i] = depth[p[i]] + 1;\n        }\n    } else if (tree_type == \"star\") {\n        p[1] = 0;\n        depth[1] = 1;\n        for (int i = 2; i <= n; ++i) {\n            p[i] = 1;\n            depth[i] = depth[p[i]] + 1;\n        }\n    } else if (tree_type == \"random\") {\n        p[1] = 0;\n        depth[1] = 1;\n        for (int i = 2; i <= n; ++i) {\n            p[i] = rnd.next(1, i - 1);\n            depth[i] = depth[p[i]] + 1;\n        }\n    } else if (tree_type == \"complete\") {\n        p[1] = 0;\n        depth[1] = 1;\n        for (int i = 2; i <= n; ++i) {\n            p[i] = (i - 2) / k + 1;\n            depth[i] = depth[p[i]] + 1;\n        }\n    } else {\n        fprintf(stderr, \"Unknown tree type: %s\\n\", tree_type.c_str());\n        exit(1);\n    }\n\n    // Output the tree\n    printf(\"%d\\n\", n);\n    for (int i = 1; i <= n; ++i) {\n        if (i > 1) printf(\" \");\n        printf(\"%d\", p[i]);\n    }\n    printf(\"\\n\");\n\n    // Generate the queries\n\n    vector< pair<int,int> > queries;\n\n    int quarters = m / 4;\n    // First quarter: p_i = 1\n    for (int i = 0; i < quarters; ++i) {\n        int v_i = rnd.next(1, n);\n        int p_i = 1;\n        queries.emplace_back(v_i, p_i);\n    }\n    // Second quarter: p_i = max(depth[v_i] - 1, 1)\n    for (int i = 0; i < quarters; ++i) {\n        int v_i = rnd.next(1, n);\n        int p_i = depth[v_i] > 1 ? depth[v_i] - 1 : 1;\n        queries.emplace_back(v_i, p_i);\n    }\n    // Third quarter: p_i = min(depth[v_i] + 1, n)\n    for (int i = 0; i < quarters; ++i) {\n        int v_i = rnd.next(1, n);\n        int p_i = depth[v_i] + 1;\n        if (p_i > n) p_i = n;\n        queries.emplace_back(v_i, p_i);\n    }\n    // Remaining queries: random\n    while ((int)queries.size() < m) {\n        int v_i = rnd.next(1, n);\n        int p_i = rnd.next(1, n);\n        queries.emplace_back(v_i, p_i);\n    }\n\n    // Shuffle queries\n    shuffle(queries.begin(), queries.end());\n\n    // Output m\n    printf(\"%d\\n\", m);\n    // Output queries\n    for (size_t i = 0; i < queries.size(); ++i) {\n        printf(\"%d %d\\n\", queries[i].first, queries[i].second);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 100005;\nint p[N];\nint depth[N];\nint n, m, k;\nstring tree_type;\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    n = opt<int>(\"n\");\n    m = opt<int>(\"m\", n); // default m = n\n    tree_type = opt<string>(\"type\", \"random\");\n    k = opt<int>(\"k\", 2); // default k=2\n\n    if (n >= N) n = N - 1; // Ensure n is within N\n    if (m > n) m = n;\n\n    // Generate the tree\n    if (tree_type == \"chain\") {\n        p[1] = 0;\n        depth[1] = 1;\n        for (int i = 2; i <= n; ++i) {\n            p[i] = i - 1;\n            depth[i] = depth[p[i]] + 1;\n        }\n    } else if (tree_type == \"star\") {\n        p[1] = 0;\n        depth[1] = 1;\n        for (int i = 2; i <= n; ++i) {\n            p[i] = 1;\n            depth[i] = depth[p[i]] + 1;\n        }\n    } else if (tree_type == \"random\") {\n        p[1] = 0;\n        depth[1] = 1;\n        for (int i = 2; i <= n; ++i) {\n            p[i] = rnd.next(1, i - 1);\n            depth[i] = depth[p[i]] + 1;\n        }\n    } else if (tree_type == \"complete\") {\n        p[1] = 0;\n        depth[1] = 1;\n        for (int i = 2; i <= n; ++i) {\n            p[i] = (i - 2) / k + 1;\n            depth[i] = depth[p[i]] + 1;\n        }\n    } else {\n        fprintf(stderr, \"Unknown tree type: %s\\n\", tree_type.c_str());\n        exit(1);\n    }\n\n    // Output the tree\n    printf(\"%d\\n\", n);\n    for (int i = 1; i <= n; ++i) {\n        if (i > 1) printf(\" \");\n        printf(\"%d\", p[i]);\n    }\n    printf(\"\\n\");\n\n    // Generate the queries\n\n    vector< pair<int,int> > queries;\n\n    int quarters = m / 4;\n    // First quarter: p_i = 1\n    for (int i = 0; i < quarters; ++i) {\n        int v_i = rnd.next(1, n);\n        int p_i = 1;\n        queries.emplace_back(v_i, p_i);\n    }\n    // Second quarter: p_i = max(depth[v_i] - 1, 1)\n    for (int i = 0; i < quarters; ++i) {\n        int v_i = rnd.next(1, n);\n        int p_i = depth[v_i] > 1 ? depth[v_i] - 1 : 1;\n        queries.emplace_back(v_i, p_i);\n    }\n    // Third quarter: p_i = min(depth[v_i] + 1, n)\n    for (int i = 0; i < quarters; ++i) {\n        int v_i = rnd.next(1, n);\n        int p_i = depth[v_i] + 1;\n        if (p_i > n) p_i = n;\n        queries.emplace_back(v_i, p_i);\n    }\n    // Remaining queries: random\n    while ((int)queries.size() < m) {\n        int v_i = rnd.next(1, n);\n        int p_i = rnd.next(1, n);\n        queries.emplace_back(v_i, p_i);\n    }\n\n    // Shuffle queries\n    shuffle(queries.begin(), queries.end());\n\n    // Output m\n    printf(\"%d\\n\", m);\n    // Output queries\n    for (size_t i = 0; i < queries.size(); ++i) {\n        printf(\"%d %d\\n\", queries[i].first, queries[i].second);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -m 1 -type chain\n./gen -n 1 -m 1 -type star\n\n./gen -n 10 -m 10 -type chain\n./gen -n 10 -m 10 -type star\n./gen -n 10 -m 10 -type random\n./gen -n 10 -m 10 -type complete -k 2\n\n./gen -n 100 -m 100 -type chain\n./gen -n 100 -m 100 -type star\n./gen -n 100 -m 100 -type random\n./gen -n 100 -m 100 -type complete -k 2\n\n./gen -n 1000 -m 1000 -type chain\n./gen -n 1000 -m 1000 -type star\n./gen -n 1000 -m 1000 -type random\n./gen -n 1000 -m 1000 -type complete -k 10\n\n./gen -n 10000 -m 10000 -type chain\n./gen -n 10000 -m 10000 -type star\n./gen -n 10000 -m 10000 -type random\n./gen -n 10000 -m 10000 -type complete -k 100\n\n./gen -n 50000 -m 50000 -type chain\n./gen -n 50000 -m 50000 -type star\n./gen -n 50000 -m 50000 -type random\n./gen -n 50000 -m 50000 -type complete -k 1000\n\n./gen -n 100000 -m 100000 -type chain\n./gen -n 100000 -m 100000 -type star\n./gen -n 100000 -m 100000 -type random\n./gen -n 100000 -m 100000 -type complete -k 1000\n\n# Edge cases with minimal m\n./gen -n 100000 -m 1 -type random\n./gen -n 100000 -m 1 -type chain\n./gen -n 100000 -m 1 -type star\n\n# Edge case with maximal m\n./gen -n 100000 -m 100000 -type random\n\n# Random tree with shuffled nodes\n./gen -n 100000 -m 100000 -type random\n\n# Complete tree with k = n (degenerate to star)\n./gen -n 100000 -m 100000 -type complete -k 99999\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T19:49:02.633448",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "209/A",
      "title": "A. Multicolored Marbles",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains a single integer n (1 ≤ n ≤ 106) — the number of marbles in Polycarpus's sequence.",
      "output_spec": "OutputPrint a single number — the answer to the problem modulo 1000000007 (109 + 7).",
      "sample_tests": "ExamplesInputCopy3OutputCopy6InputCopy4OutputCopy11",
      "description": "A. Multicolored Marbles\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains a single integer n (1 ≤ n ≤ 106) — the number of marbles in Polycarpus's sequence.\n\nOutputPrint a single number — the answer to the problem modulo 1000000007 (109 + 7).\n\nInputCopy3OutputCopy6InputCopy4OutputCopy11\n\nOutputCopy6\n\nOutputCopy11\n\nNoteLet's consider the first test sample. Let's assume that Polycarpus initially had sequence (red; blue; red), so there are six ways to pick a zebroid:   pick the first marble;  pick the second marble;  pick the third marble;  pick the first and second marbles;  pick the second and third marbles;  pick the first, second and third marbles. It can be proven that if Polycarpus picks (blue; red; blue) as the initial sequence, the number of ways won't change.",
      "solutions": [
        {
          "title": "VK Cup 2012 — Финал! - Codeforces",
          "content": "Today is the main VK Cup event: VK Cup 2012 Finals! Good luck to all participants. And to those who don't participate — enjoy the interesting competition. VK CEO Pavel Durov announced the upgrade of a prize fund in the greeting speech at the finals' opening! I'm starting to really regret that I am not a participant.The participants compete for: 1st place — $30000 2nd place — $20000 3rd place — $10000 4-5 places — $2000 6-10 places — $1000 Good luck! Wish you only positive emotions. Ready! Steady!...UPD: The contest is over! I believe Alex_KPR will write about the contest and the closing ceremony soon. Thank you for participation and your interest. Here are the complete standings.Congrats to the winners. The top-3 is: sevenkplus (Yuzhou Gu) China s-quark (Qinshi Wang) China tourist (Gennady Korotkevich) Belarus UPD: As you have already noticed, the 16th July at 19:00 will start an unofficial online-version of the VK Cup 2012 Finals. Anyone can participate and feel himself as a finalist. Round will be unrated. If you already took part in the Finals or familiar with the problems, please refrain from participation. All problems will appear in the archive and will be available to everyone.",
          "author": "MikeMirzayanov",
          "url": "https://codeforces.com/blog/entry/4885",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1203
        }
      ],
      "code_examples": [],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 1000000, \"n\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 1000000, \"n\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 1000000, \"n\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\", 1);\n\n    // Ensure n is within the specified constraints\n    ensure(1 <= n && n <= 1000000);\n\n    printf(\"%d\\n\", n);\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\", 1);\n\n    // Ensure n is within the specified constraints\n    ensure(1 <= n && n <= 1000000);\n\n    printf(\"%d\\n\", n);\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1\n./gen -n 2\n./gen -n 3\n./gen -n 4\n./gen -n 5\n./gen -n 6\n./gen -n 7\n./gen -n 8\n./gen -n 9\n./gen -n 10\n./gen -n 11\n./gen -n 12\n./gen -n 17\n./gen -n 42\n./gen -n 100\n./gen -n 256\n./gen -n 512\n./gen -n 999\n./gen -n 1000\n./gen -n 1001\n./gen -n 1024\n./gen -n 1234\n./gen -n 5000\n./gen -n 99999\n./gen -n 100000\n./gen -n 100001\n./gen -n 500000\n./gen -n 999999\n./gen -n 1000000\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T19:49:04.644853",
        "total_tutorials": 1,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "209/B",
      "title": "B. Pixels",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains three space-separated integers a, b and c (0 ≤ a, b, c ≤ 231; a + b + c > 0) — the number of red, green and blue pixels, correspondingly.",
      "output_spec": "OutputPrint a single number — the minimum number of pixel fights before the country becomes peaceful and prosperous. If making the country peaceful and prosperous is impossible, print -1.",
      "sample_tests": "ExamplesInputCopy1 1 1OutputCopy1InputCopy3 1 0OutputCopy3",
      "description": "time limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains three space-separated integers a, b and c (0 ≤ a, b, c ≤ 231; a + b + c > 0) — the number of red, green and blue pixels, correspondingly.\n\nOutputPrint a single number — the minimum number of pixel fights before the country becomes peaceful and prosperous. If making the country peaceful and prosperous is impossible, print -1.\n\nInputCopy1 1 1OutputCopy1InputCopy3 1 0OutputCopy3\n\nInputCopy1 1 1\n\nOutputCopy1\n\nInputCopy3 1 0\n\nOutputCopy3\n\nNoteIn the first test sample the country needs only one fight to achieve peace and prosperity. Besides, it can be any fight whatsoever. For example, let's assume that the green and the blue pixels fight, then the surviving pixel will be red. As a result, after the fight there are two red pixels. There won't be other pixels.In the second sample the following sequence of fights is possible: red and blue, green and red, red and blue. As a result, after all fights there is one green pixel left.",
      "solutions": [
        {
          "title": "VK Cup 2012 — Финал! - Codeforces",
          "content": "Today is the main VK Cup event: VK Cup 2012 Finals! Good luck to all participants. And to those who don't participate — enjoy the interesting competition. VK CEO Pavel Durov announced the upgrade of a prize fund in the greeting speech at the finals' opening! I'm starting to really regret that I am not a participant.The participants compete for: 1st place — $30000 2nd place — $20000 3rd place — $10000 4-5 places — $2000 6-10 places — $1000 Good luck! Wish you only positive emotions. Ready! Steady!...UPD: The contest is over! I believe Alex_KPR will write about the contest and the closing ceremony soon. Thank you for participation and your interest. Here are the complete standings.Congrats to the winners. The top-3 is: sevenkplus (Yuzhou Gu) China s-quark (Qinshi Wang) China tourist (Gennady Korotkevich) Belarus UPD: As you have already noticed, the 16th July at 19:00 will start an unofficial online-version of the VK Cup 2012 Finals. Anyone can participate and feel himself as a finalist. Round will be unrated. If you already took part in the Finals or familiar with the problems, please refrain from participation. All problems will appear in the archive and will be available to everyone.",
          "author": "MikeMirzayanov",
          "url": "https://codeforces.com/blog/entry/4885",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1203
        }
      ],
      "code_examples": [],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    long long a = inf.readLong(0, 2147483648LL, \"a\");\n    inf.readSpace();\n    long long b = inf.readLong(0, 2147483648LL, \"b\");\n    inf.readSpace();\n    long long c = inf.readLong(0, 2147483648LL, \"c\");\n    inf.readEoln();\n    ensuref(a + b + c > 0, \"At least one of a, b, c must be greater than zero\");\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    long long a = inf.readLong(0, 2147483648LL, \"a\");\n    inf.readSpace();\n    long long b = inf.readLong(0, 2147483648LL, \"b\");\n    inf.readSpace();\n    long long c = inf.readLong(0, 2147483648LL, \"c\");\n    inf.readEoln();\n    ensuref(a + b + c > 0, \"At least one of a, b, c must be greater than zero\");\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    long long a = inf.readLong(0, 2147483648LL, \"a\");\n    inf.readSpace();\n    long long b = inf.readLong(0, 2147483648LL, \"b\");\n    inf.readSpace();\n    long long c = inf.readLong(0, 2147483648LL, \"c\");\n    inf.readEoln();\n    ensuref(a + b + c > 0, \"At least one of a, b, c must be greater than zero\");\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    string type = opt<string>(\"type\", \"random\");\n    int max_value = opt<int>(\"max_value\", 1000);\n\n    long long a = 0, b = 0, c = 0;\n    if (type == \"random\") {\n        a = rnd.next((long long)0, (long long)max_value);\n        b = rnd.next((long long)0, (long long)max_value);\n        c = rnd.next((long long)0, (long long)max_value);\n\n        // Ensure that sum(a,b,c) > 0\n        if (a + b + c == 0) {\n            int idx = rnd.next(1,3);\n            if (idx == 1) a = 1;\n            else if (idx == 2) b = 1;\n            else c = 1;\n        }\n    } else if (type == \"large_random\") {\n        long long max_int = (1LL << 31) - 1;\n        long long min_value = max_int - max_value;\n        a = rnd.next(min_value, max_int);\n        b = rnd.next(min_value, max_int);\n        c = rnd.next(min_value, max_int);\n    } else if (type == \"zeros\") {\n        a = max_value;\n        b = 0;\n        c = 0;\n    } else if (type == \"two_zero\") {\n        int idx = rnd.next(1,3);\n        if (idx == 1) {\n            a = rnd.next(1LL, 1LL*max_value);\n            b = 0;\n            c = 0;\n        } else if (idx == 2) {\n            b = rnd.next(1LL, 1LL*max_value);\n            a = 0;\n            c = 0;\n        } else {\n            c = rnd.next(1LL, 1LL*max_value);\n            a = 0;\n            b = 0;\n        }\n    } else if (type == \"one_zero\") {\n        int idx = rnd.next(1,3);\n        if (idx == 1) a = 0;\n        else if (idx == 2) b = 0;\n        else c = 0;\n\n        a += rnd.next(1LL, 1LL*max_value);\n        b += rnd.next(1LL, 1LL*max_value);\n        c += rnd.next(1LL, 1LL*max_value);\n    } else if (type == \"max\") {\n        long long max_int = (1LL << 31) - 1;\n        a = max_int; b = max_int; c = max_int;\n    } else if (type == \"max_one_zero\") {\n        long long max_int = (1LL << 31) - 1;\n        int idx = rnd.next(1,3);\n        if (idx == 1) a = 0;\n        else if (idx == 2) b = 0;\n        else c = 0;\n        if (a == 0) { b = max_int; c = max_int; }\n        else if (b == 0) { a = max_int; c = max_int; }\n        else { a = max_int; b = max_int; }\n    } else if (type == \"max_two_zero\") {\n        long long max_int = (1LL << 31) - 1;\n        int idx = rnd.next(1,3);\n        if (idx == 1) { a = max_int; b = 0; c = 0; }\n        else if (idx == 2) { b = max_int; a = 0; c = 0; }\n        else { c = max_int; a = 0; b = 0; }\n    } else if (type == \"big_difference\") {\n        long long max_int = (1LL << 31) - 1;\n        a = rnd.next((long long)1, (long long)1e3);\n        b = rnd.next((long long)1e9, max_int);\n        c = rnd.next((long long)1, (long long)1e3);\n    } else if (type == \"equal_counts\") {\n        a = rnd.next(1LL, 1LL*max_value);\n        b = a;\n        c = a;\n    } else if (type == \"arithmetic_progression\") {\n        long long d = rnd.next(1LL, max_value);\n        long long start = rnd.next(1LL, max_value);\n\n        a = start;\n        b = start + d;\n        c = start + 2*d;\n    } else if (type == \"powers_of_two\") {\n        a = 1LL << rnd.next(0, 30);\n        b = 1LL << rnd.next(0, 30);\n        c = 1LL << rnd.next(0, 30);\n    } else if (type == \"primes\") {\n        vector<int> primes = {2, 3, 5, 7, 11, 13, 17, 19,23,29,31,37,41};\n        a = primes[rnd.next(0, (int)primes.size()-1)];\n        b = primes[rnd.next(0, (int)primes.size()-1)];\n        c = primes[rnd.next(0, (int)primes.size()-1)];\n    } else {\n        // Default, generate random counts\n        a = rnd.next(0LL, (long long)max_value);\n        b = rnd.next(0LL, (long long)max_value);\n        c = rnd.next(0LL, (long long)max_value);\n\n        if (a + b + c == 0) {\n            int idx = rnd.next(1,3);\n            if (idx == 1) a = 1;\n            else if (idx == 2) b = 1;\n            else c = 1;\n        }\n    }\n\n    // Ensure that sum(a,b,c) > 0\n    if (a + b + c == 0) {\n        int idx = rnd.next(1,3);\n        if (idx == 1) a = 1;\n        else if (idx == 2) b = 1;\n        else c = 1;\n    }\n\n    // Output the test case\n    printf(\"%lld %lld %lld\\n\", a, b, c);\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    string type = opt<string>(\"type\", \"random\");\n    int max_value = opt<int>(\"max_value\", 1000);\n\n    long long a = 0, b = 0, c = 0;\n    if (type == \"random\") {\n        a = rnd.next((long long)0, (long long)max_value);\n        b = rnd.next((long long)0, (long long)max_value);\n        c = rnd.next((long long)0, (long long)max_value);\n\n        // Ensure that sum(a,b,c) > 0\n        if (a + b + c == 0) {\n            int idx = rnd.next(1,3);\n            if (idx == 1) a = 1;\n            else if (idx == 2) b = 1;\n            else c = 1;\n        }\n    } else if (type == \"large_random\") {\n        long long max_int = (1LL << 31) - 1;\n        long long min_value = max_int - max_value;\n        a = rnd.next(min_value, max_int);\n        b = rnd.next(min_value, max_int);\n        c = rnd.next(min_value, max_int);\n    } else if (type == \"zeros\") {\n        a = max_value;\n        b = 0;\n        c = 0;\n    } else if (type == \"two_zero\") {\n        int idx = rnd.next(1,3);\n        if (idx == 1) {\n            a = rnd.next(1LL, 1LL*max_value);\n            b = 0;\n            c = 0;\n        } else if (idx == 2) {\n            b = rnd.next(1LL, 1LL*max_value);\n            a = 0;\n            c = 0;\n        } else {\n            c = rnd.next(1LL, 1LL*max_value);\n            a = 0;\n            b = 0;\n        }\n    } else if (type == \"one_zero\") {\n        int idx = rnd.next(1,3);\n        if (idx == 1) a = 0;\n        else if (idx == 2) b = 0;\n        else c = 0;\n\n        a += rnd.next(1LL, 1LL*max_value);\n        b += rnd.next(1LL, 1LL*max_value);\n        c += rnd.next(1LL, 1LL*max_value);\n    } else if (type == \"max\") {\n        long long max_int = (1LL << 31) - 1;\n        a = max_int; b = max_int; c = max_int;\n    } else if (type == \"max_one_zero\") {\n        long long max_int = (1LL << 31) - 1;\n        int idx = rnd.next(1,3);\n        if (idx == 1) a = 0;\n        else if (idx == 2) b = 0;\n        else c = 0;\n        if (a == 0) { b = max_int; c = max_int; }\n        else if (b == 0) { a = max_int; c = max_int; }\n        else { a = max_int; b = max_int; }\n    } else if (type == \"max_two_zero\") {\n        long long max_int = (1LL << 31) - 1;\n        int idx = rnd.next(1,3);\n        if (idx == 1) { a = max_int; b = 0; c = 0; }\n        else if (idx == 2) { b = max_int; a = 0; c = 0; }\n        else { c = max_int; a = 0; b = 0; }\n    } else if (type == \"big_difference\") {\n        long long max_int = (1LL << 31) - 1;\n        a = rnd.next((long long)1, (long long)1e3);\n        b = rnd.next((long long)1e9, max_int);\n        c = rnd.next((long long)1, (long long)1e3);\n    } else if (type == \"equal_counts\") {\n        a = rnd.next(1LL, 1LL*max_value);\n        b = a;\n        c = a;\n    } else if (type == \"arithmetic_progression\") {\n        long long d = rnd.next(1LL, max_value);\n        long long start = rnd.next(1LL, max_value);\n\n        a = start;\n        b = start + d;\n        c = start + 2*d;\n    } else if (type == \"powers_of_two\") {\n        a = 1LL << rnd.next(0, 30);\n        b = 1LL << rnd.next(0, 30);\n        c = 1LL << rnd.next(0, 30);\n    } else if (type == \"primes\") {\n        vector<int> primes = {2, 3, 5, 7, 11, 13, 17, 19,23,29,31,37,41};\n        a = primes[rnd.next(0, (int)primes.size()-1)];\n        b = primes[rnd.next(0, (int)primes.size()-1)];\n        c = primes[rnd.next(0, (int)primes.size()-1)];\n    } else {\n        // Default, generate random counts\n        a = rnd.next(0LL, (long long)max_value);\n        b = rnd.next(0LL, (long long)max_value);\n        c = rnd.next(0LL, (long long)max_value);\n\n        if (a + b + c == 0) {\n            int idx = rnd.next(1,3);\n            if (idx == 1) a = 1;\n            else if (idx == 2) b = 1;\n            else c = 1;\n        }\n    }\n\n    // Ensure that sum(a,b,c) > 0\n    if (a + b + c == 0) {\n        int idx = rnd.next(1,3);\n        if (idx == 1) a = 1;\n        else if (idx == 2) b = 1;\n        else c = 1;\n    }\n\n    // Output the test case\n    printf(\"%lld %lld %lld\\n\", a, b, c);\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -type random -max_value 1\n./gen -type random -max_value 2\n./gen -type random -max_value 3\n./gen -type random -max_value 10\n./gen -type random -max_value 100\n./gen -type random -max_value 1000\n./gen -type random -max_value 1000000\n./gen -type random -max_value 1000000000\n./gen -type random -max_value 2147483647\n\n./gen -type large_random -max_value 10\n./gen -type large_random -max_value 1000\n./gen -type large_random -max_value 1000000\n\n./gen -type zeros -max_value 1\n./gen -type zeros -max_value 1000000\n\n./gen -type two_zero -max_value 1\n./gen -type two_zero -max_value 100\n./gen -type two_zero -max_value 1000000000\n\n./gen -type one_zero -max_value 1\n./gen -type one_zero -max_value 100\n./gen -type one_zero -max_value 1000000000\n\n./gen -type max\n\n./gen -type max_one_zero\n\n./gen -type max_two_zero\n\n./gen -type big_difference\n\n./gen -type equal_counts -max_value 10\n./gen -type equal_counts -max_value 1000\n./gen -type equal_counts -max_value 1000000\n\n./gen -type arithmetic_progression -max_value 10\n./gen -type arithmetic_progression -max_value 1000\n./gen -type arithmetic_progression -max_value 1000000\n\n./gen -type powers_of_two\n\n./gen -type primes\n\n./gen -type random -max_value 1000000000\n./gen -type random -max_value 2147483647\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T19:49:07.112127",
        "total_tutorials": 1,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "209/C",
      "title": "C. Trails and Glades",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test4 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains two integers n and m (1 ≤ n ≤ 106; 0 ≤ m ≤ 106) — the number of glades in the park and the number of trails in the park, respectively. Next m lines specify the trails. The i-th line specifies the i-th trail as two space-separated numbers, xi, yi (1 ≤ xi, yi ≤ n) — the numbers of the glades connected by this trail.",
      "output_spec": "OutputPrint the single integer — the answer to the problem. If Vasya's walk is possible without adding extra trails, print 0, otherwise print the minimum number of trails the authorities need to add to the park in order to make Vasya's walk possible.",
      "sample_tests": "ExamplesInputCopy3 31 22 33 1OutputCopy0InputCopy2 51 11 21 22 21 2OutputCopy1",
      "description": "C. Trails and Glades\n\ntime limit per test4 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains two integers n and m (1 ≤ n ≤ 106; 0 ≤ m ≤ 106) — the number of glades in the park and the number of trails in the park, respectively. Next m lines specify the trails. The i-th line specifies the i-th trail as two space-separated numbers, xi, yi (1 ≤ xi, yi ≤ n) — the numbers of the glades connected by this trail.\n\nOutputPrint the single integer — the answer to the problem. If Vasya's walk is possible without adding extra trails, print 0, otherwise print the minimum number of trails the authorities need to add to the park in order to make Vasya's walk possible.\n\nInputCopy3 31 22 33 1OutputCopy0InputCopy2 51 11 21 22 21 2OutputCopy1\n\nInputCopy3 31 22 33 1\n\nOutputCopy0\n\nInputCopy2 51 11 21 22 21 2\n\nOutputCopy1\n\nNoteIn the first test case the described walk is possible without building extra trails. For example, let's first go on the first trail, then on the second one, and finally on the third one.In the second test case the described walk is impossible without adding extra trails. To make the walk possible, it is enough to add one trail, for example, between glades number one and two.",
      "solutions": [
        {
          "title": "VK Cup 2012 — Финал! - Codeforces",
          "content": "Today is the main VK Cup event: VK Cup 2012 Finals! Good luck to all participants. And to those who don't participate — enjoy the interesting competition. VK CEO Pavel Durov announced the upgrade of a prize fund in the greeting speech at the finals' opening! I'm starting to really regret that I am not a participant.The participants compete for: 1st place — $30000 2nd place — $20000 3rd place — $10000 4-5 places — $2000 6-10 places — $1000 Good luck! Wish you only positive emotions. Ready! Steady!...UPD: The contest is over! I believe Alex_KPR will write about the contest and the closing ceremony soon. Thank you for participation and your interest. Here are the complete standings.Congrats to the winners. The top-3 is: sevenkplus (Yuzhou Gu) China s-quark (Qinshi Wang) China tourist (Gennady Korotkevich) Belarus UPD: As you have already noticed, the 16th July at 19:00 will start an unofficial online-version of the VK Cup 2012 Finals. Anyone can participate and feel himself as a finalist. Round will be unrated. If you already took part in the Finals or familiar with the problems, please refrain from participation. All problems will appear in the archive and will be available to everyone.",
          "author": "MikeMirzayanov",
          "url": "https://codeforces.com/blog/entry/4885",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1203
        }
      ],
      "code_examples": [],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 1000000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(0, 1000000, \"m\");\n    inf.readEoln();\n\n    for (int i = 0; i < m; i++) {\n        int xi = inf.readInt(1, n, \"xi\");\n        inf.readSpace();\n        int yi = inf.readInt(1, n, \"yi\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 1000000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(0, 1000000, \"m\");\n    inf.readEoln();\n\n    for (int i = 0; i < m; i++) {\n        int xi = inf.readInt(1, n, \"xi\");\n        inf.readSpace();\n        int yi = inf.readInt(1, n, \"yi\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 1000000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(0, 1000000, \"m\");\n    inf.readEoln();\n\n    for (int i = 0; i < m; i++) {\n        int xi = inf.readInt(1, n, \"xi\");\n        inf.readSpace();\n        int yi = inf.readInt(1, n, \"yi\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\", 1);\n    int m = opt<int>(\"m\", 0);\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<pair<int,int>> edges;\n    vector<int> degree(n + 1, 0);\n\n    if (type == \"connected_eulerian\") {\n        // Generate a connected graph with even degrees\n        if (m < n - 1) {\n            m = n - 1;\n        }\n\n        // Generate a random spanning tree\n        for(int i = 2; i <= n; ++i) {\n            int u = i;\n            int v = rnd.next(1, i - 1);  // Random parent\n            edges.emplace_back(u, v);\n            degree[u]++;\n            degree[v]++;\n        }\n\n        // Collect vertices with odd degrees\n        vector<int> odd_vertices;\n        for(int i = 1; i <= n; ++i) {\n            if (degree[i] % 2 == 1) {\n                odd_vertices.push_back(i);\n            }\n        }\n\n        // Pair up odd-degree vertices to make degrees even\n        for(size_t i = 0; i + 1 < odd_vertices.size(); i += 2) {\n            int u = odd_vertices[i];\n            int v = odd_vertices[i + 1];\n            edges.emplace_back(u, v);\n            degree[u]++;\n            degree[v]++;\n        }\n\n        // Add random edges to reach m edges\n        while((int)edges.size() < m) {\n            int u = rnd.next(1, n);\n            int v = rnd.next(1, n);\n            edges.emplace_back(u, v);\n            degree[u]++;\n            degree[v]++;\n        }\n\n    } else if (type == \"connected_non_eulerian\") {\n        // Generate a connected graph with some odd degrees\n        if (m < n - 1) {\n            m = n - 1;\n        }\n\n        // Generate a random spanning tree\n        for(int i = 2; i <= n; ++i) {\n            int u = i;\n            int v = rnd.next(1, i - 1);  // Random parent\n            edges.emplace_back(u, v);\n            degree[u]++;\n            degree[v]++;\n        }\n\n        // Add random edges to reach m edges\n        while((int)edges.size() < m) {\n            int u = rnd.next(1, n);\n            int v = rnd.next(1, n);\n            edges.emplace_back(u, v);\n            degree[u]++;\n            degree[v]++;\n        }\n\n        // Ensure there are odd-degree vertices\n        int num_odd = 0;\n        for(int i = 1; i <= n; ++i) {\n            if (degree[i] % 2 == 1) {\n                num_odd++;\n            }\n        }\n        // If all degrees are even, modify one edge to create odd degrees\n        if (num_odd == 0 && n >= 2) {\n            int u = 1;\n            int v = 2;\n            edges.emplace_back(u, v);\n            degree[u]++;\n            degree[v]++;\n        }\n\n    } else if (type == \"disconnected\") {\n        // Generate a disconnected graph\n        int num_components = rnd.next(2, min(n, 5));\n        vector<int> component_sizes(num_components, n / num_components);\n        int remaining = n - (n / num_components) * num_components;\n        for(int i = 0; i < remaining; ++i) {\n            component_sizes[i]++;\n        }\n\n        int current_node = 1;\n        for(int c = 0; c < num_components; ++c) {\n            int size = component_sizes[c];\n            for(int i = current_node + 1; i < current_node + size; ++i) {\n                int u = i;\n                int v = rnd.next(current_node, i - 1);\n                edges.emplace_back(u, v);\n                degree[u]++;\n                degree[v]++;\n            }\n            current_node += size;\n        }\n\n        // Add random edges within components to reach m edges\n        while((int)edges.size() < m) {\n            int c = rnd.next(0, num_components - 1);\n            int start = 1;\n            for(int i = 0; i < c; ++i) {\n                start += component_sizes[i];\n            }\n            int end = start + component_sizes[c] - 1;\n            int u = rnd.next(start, end);\n            int v = rnd.next(start, end);\n            edges.emplace_back(u, v);\n            degree[u]++;\n            degree[v]++;\n        }\n\n    } else if (type == \"self_loops\") {\n        // Generate edges with self-loops\n        for(int i = 0; i < m; ++i) {\n            int u = rnd.next(1, n);\n            int v = u; // Self-loop\n            edges.emplace_back(u, v);\n            degree[u]++;\n        }\n\n    } else if (type == \"multi_edges\") {\n        // Generate edges with multiple edges between same pairs\n        if (m < n - 1) {\n            m = n - 1;\n        }\n\n        // Generate a random spanning tree\n        for(int i = 2; i <= n; ++i) {\n            int u = i;\n            int v = rnd.next(1, i - 1);\n            edges.emplace_back(u, v);\n            degree[u]++;\n            degree[v]++;\n        }\n\n        // Add multiple edges between same pairs\n        while((int)edges.size() < m) {\n            int u = rnd.next(1, n);\n            int v = rnd.next(1, n);\n            edges.emplace_back(u, v);\n            degree[u]++;\n            degree[v]++;\n        }\n\n    } else if (type == \"minimal_case\") {\n        // Generate minimal values\n        n = 1;\n        m = 0;\n        // No edges\n\n    } else { // Random case\n        // Generate random edges\n        for(int i = 0; i < m; ++i) {\n            int u = rnd.next(1, n);\n            int v = rnd.next(1, n);\n            edges.emplace_back(u, v);\n            degree[u]++;\n            if (u != v) degree[v]++;\n        }\n    }\n\n    // Output n and m\n    printf(\"%d %d\\n\", n, (int)edges.size());\n\n    // Output edges\n    for (auto& e : edges) {\n        printf(\"%d %d\\n\", e.first, e.second);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\", 1);\n    int m = opt<int>(\"m\", 0);\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<pair<int,int>> edges;\n    vector<int> degree(n + 1, 0);\n\n    if (type == \"connected_eulerian\") {\n        // Generate a connected graph with even degrees\n        if (m < n - 1) {\n            m = n - 1;\n        }\n\n        // Generate a random spanning tree\n        for(int i = 2; i <= n; ++i) {\n            int u = i;\n            int v = rnd.next(1, i - 1);  // Random parent\n            edges.emplace_back(u, v);\n            degree[u]++;\n            degree[v]++;\n        }\n\n        // Collect vertices with odd degrees\n        vector<int> odd_vertices;\n        for(int i = 1; i <= n; ++i) {\n            if (degree[i] % 2 == 1) {\n                odd_vertices.push_back(i);\n            }\n        }\n\n        // Pair up odd-degree vertices to make degrees even\n        for(size_t i = 0; i + 1 < odd_vertices.size(); i += 2) {\n            int u = odd_vertices[i];\n            int v = odd_vertices[i + 1];\n            edges.emplace_back(u, v);\n            degree[u]++;\n            degree[v]++;\n        }\n\n        // Add random edges to reach m edges\n        while((int)edges.size() < m) {\n            int u = rnd.next(1, n);\n            int v = rnd.next(1, n);\n            edges.emplace_back(u, v);\n            degree[u]++;\n            degree[v]++;\n        }\n\n    } else if (type == \"connected_non_eulerian\") {\n        // Generate a connected graph with some odd degrees\n        if (m < n - 1) {\n            m = n - 1;\n        }\n\n        // Generate a random spanning tree\n        for(int i = 2; i <= n; ++i) {\n            int u = i;\n            int v = rnd.next(1, i - 1);  // Random parent\n            edges.emplace_back(u, v);\n            degree[u]++;\n            degree[v]++;\n        }\n\n        // Add random edges to reach m edges\n        while((int)edges.size() < m) {\n            int u = rnd.next(1, n);\n            int v = rnd.next(1, n);\n            edges.emplace_back(u, v);\n            degree[u]++;\n            degree[v]++;\n        }\n\n        // Ensure there are odd-degree vertices\n        int num_odd = 0;\n        for(int i = 1; i <= n; ++i) {\n            if (degree[i] % 2 == 1) {\n                num_odd++;\n            }\n        }\n        // If all degrees are even, modify one edge to create odd degrees\n        if (num_odd == 0 && n >= 2) {\n            int u = 1;\n            int v = 2;\n            edges.emplace_back(u, v);\n            degree[u]++;\n            degree[v]++;\n        }\n\n    } else if (type == \"disconnected\") {\n        // Generate a disconnected graph\n        int num_components = rnd.next(2, min(n, 5));\n        vector<int> component_sizes(num_components, n / num_components);\n        int remaining = n - (n / num_components) * num_components;\n        for(int i = 0; i < remaining; ++i) {\n            component_sizes[i]++;\n        }\n\n        int current_node = 1;\n        for(int c = 0; c < num_components; ++c) {\n            int size = component_sizes[c];\n            for(int i = current_node + 1; i < current_node + size; ++i) {\n                int u = i;\n                int v = rnd.next(current_node, i - 1);\n                edges.emplace_back(u, v);\n                degree[u]++;\n                degree[v]++;\n            }\n            current_node += size;\n        }\n\n        // Add random edges within components to reach m edges\n        while((int)edges.size() < m) {\n            int c = rnd.next(0, num_components - 1);\n            int start = 1;\n            for(int i = 0; i < c; ++i) {\n                start += component_sizes[i];\n            }\n            int end = start + component_sizes[c] - 1;\n            int u = rnd.next(start, end);\n            int v = rnd.next(start, end);\n            edges.emplace_back(u, v);\n            degree[u]++;\n            degree[v]++;\n        }\n\n    } else if (type == \"self_loops\") {\n        // Generate edges with self-loops\n        for(int i = 0; i < m; ++i) {\n            int u = rnd.next(1, n);\n            int v = u; // Self-loop\n            edges.emplace_back(u, v);\n            degree[u]++;\n        }\n\n    } else if (type == \"multi_edges\") {\n        // Generate edges with multiple edges between same pairs\n        if (m < n - 1) {\n            m = n - 1;\n        }\n\n        // Generate a random spanning tree\n        for(int i = 2; i <= n; ++i) {\n            int u = i;\n            int v = rnd.next(1, i - 1);\n            edges.emplace_back(u, v);\n            degree[u]++;\n            degree[v]++;\n        }\n\n        // Add multiple edges between same pairs\n        while((int)edges.size() < m) {\n            int u = rnd.next(1, n);\n            int v = rnd.next(1, n);\n            edges.emplace_back(u, v);\n            degree[u]++;\n            degree[v]++;\n        }\n\n    } else if (type == \"minimal_case\") {\n        // Generate minimal values\n        n = 1;\n        m = 0;\n        // No edges\n\n    } else { // Random case\n        // Generate random edges\n        for(int i = 0; i < m; ++i) {\n            int u = rnd.next(1, n);\n            int v = rnd.next(1, n);\n            edges.emplace_back(u, v);\n            degree[u]++;\n            if (u != v) degree[v]++;\n        }\n    }\n\n    // Output n and m\n    printf(\"%d %d\\n\", n, (int)edges.size());\n\n    // Output edges\n    for (auto& e : edges) {\n        printf(\"%d %d\\n\", e.first, e.second);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Minimal case with n=1, m=0\n./gen -n 1 -m 0 -type minimal_case\n\n# Random small graph\n./gen -n 5 -m 4 -type random\n\n# Random medium graph\n./gen -n 100 -m 200 -type random\n\n# Random large graph\n./gen -n 1000000 -m 1000000 -type random\n\n# Connected Eulerian graph (Euler circuit exists)\n./gen -n 10 -m 15 -type connected_eulerian\n./gen -n 1000 -m 1500 -type connected_eulerian\n./gen -n 100000 -m 150000 -type connected_eulerian\n\n# Connected non-Eulerian graph (Euler circuit does not exist)\n./gen -n 10 -m 15 -type connected_non_eulerian\n./gen -n 1000 -m 1500 -type connected_non_eulerian\n./gen -n 100000 -m 150000 -type connected_non_eulerian\n\n# Disconnected graph\n./gen -n 10 -m 8 -type disconnected\n./gen -n 1000 -m 900 -type disconnected\n./gen -n 100000 -m 90000 -type disconnected\n\n# Graph with self-loops\n./gen -n 10 -m 20 -type self_loops\n./gen -n 1000 -m 2000 -type self_loops\n./gen -n 100000 -m 200000 -type self_loops\n\n# Graph with multiple edges\n./gen -n 10 -m 30 -type multi_edges\n./gen -n 1000 -m 5000 -type multi_edges\n./gen -n 100000 -m 500000 -type multi_edges\n\n# Max size graph with Eulerian circuit\n./gen -n 1000000 -m 1000000 -type connected_eulerian\n\n# Max size graph without Eulerian circuit\n./gen -n 1000000 -m 1000000 -type connected_non_eulerian\n\n# Graph with both self-loops and multiple edges\n./gen -n 50000 -m 100000 -type self_loops\n./gen -n 50000 -m 200000 -type multi_edges\n\n# Small graph where Vasya cannot make the walk\n./gen -n 3 -m 2 -type connected_non_eulerian\n\n# Small graph where Vasya can make the walk\n./gen -n 3 -m 3 -type connected_eulerian\n\n# Random graphs to test edge cases\n./gen -n 2 -m 0 -type random\n./gen -n 2 -m 1 -type random\n./gen -n 2 -m 2 -type random\n\n# Graph with maximum number of edges (complete graph with multi-edges)\n./gen -n 5000 -m 1000000 -type multi_edges\n\n# Graph with only self-loops\n./gen -n 10000 -m 5000 -type self_loops\n\n# Disconnected graph with multiple components\n./gen -n 1000000 -m 999990 -type disconnected\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T19:49:09.119554",
        "total_tutorials": 1,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "21/A",
      "title": "A. Jabber ID",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test0.5 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe input contains of a single line. The line has the length between 1 and 100 characters, inclusive. Each characters has ASCII-code between 33 and 127, inclusive.",
      "output_spec": "OutputPrint YES or NO.",
      "sample_tests": "ExamplesInputCopymike@codeforces.comOutputCopyYESInputCopyjohn.smith@codeforces.ru/contest.icpc/12OutputCopyNO",
      "description": "A. Jabber ID\n\ntime limit per test0.5 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe input contains of a single line. The line has the length between 1 and 100 characters, inclusive. Each characters has ASCII-code between 33 and 127, inclusive.\n\nOutputPrint YES or NO.\n\nInputCopymike@codeforces.comOutputCopyYESInputCopyjohn.smith@codeforces.ru/contest.icpc/12OutputCopyNO\n\nInputCopymike@codeforces.com\n\nOutputCopyYES\n\nInputCopyjohn.smith@codeforces.ru/contest.icpc/12\n\nOutputCopyNO",
      "solutions": [
        {
          "title": "Codeforces Alpha Round #21 (Codeforces format) - Codeforces",
          "content": "I invite you to participate:) Round will be non-rated, but there will not be limited registration at this time! Please, read the rules before the contest!",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/496",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 154
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Alpha Round #21 (Codeforces format) - Codeforces - Code 1",
          "code": "0 0 10 0 1Expected 0, found -1.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/496",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    string s = inf.readLine();\n    ensuref(1 <= s.length() && s.length() <= 100, \"Line length must be between 1 and 100 inclusive\");\n\n    for (char c : s){\n        int ascii = (unsigned char)c;\n        ensuref(33 <= ascii && ascii <= 127, \"Each character must have ASCII code between 33 and 127 inclusive\");\n    }\n\n    inf.readEof();\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    string s = inf.readLine();\n    ensuref(1 <= s.length() && s.length() <= 100, \"Line length must be between 1 and 100 inclusive\");\n\n    for (char c : s){\n        int ascii = (unsigned char)c;\n        ensuref(33 <= ascii && ascii <= 127, \"Each character must have ASCII code between 33 and 127 inclusive\");\n    }\n\n    inf.readEof();\n\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    string s = inf.readLine();\n    ensuref(1 <= s.length() && s.length() <= 100, \"Line length must be between 1 and 100 inclusive\");\n\n    for (char c : s){\n        int ascii = (unsigned char)c;\n        ensuref(33 <= ascii && ascii <= 127, \"Each character must have ASCII code between 33 and 127 inclusive\");\n    }\n\n    inf.readEof();\n\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n#include <string>\r\n\r\nusing namespace std;\r\n\r\nconst string YES = \"YES\";\r\nconst string NO = \"NO\";\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"%s\", (\"multiple \" + YES + \"/\" + NO + \" (case insensitive)\").c_str());\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int index = 0, yesCount = 0, noCount = 0;\r\n    string pa;\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        index++;\r\n        string ja = upperCase(ans.readToken());\r\n        pa = upperCase(ouf.readToken());\r\n\r\n        if (ja != YES && ja != NO)\r\n            quitf(_fail, \"%s or %s expected in answer, but %s found [%d%s token]\",\r\n                  YES.c_str(), NO.c_str(), compress(ja).c_str(), index, englishEnding(index).c_str());\r\n\r\n        if (pa == YES)\r\n            yesCount++;\r\n        else if (pa == NO)\r\n            noCount++;\r\n        else\r\n            quitf(_pe, \"%s or %s expected, but %s found [%d%s token]\",\r\n                  YES.c_str(), NO.c_str(), compress(pa).c_str(), index, englishEnding(index).c_str());\r\n\r\n        if (ja != pa)\r\n            quitf(_wa, \"expected %s, found %s [%d%s token]\",\r\n                  compress(ja).c_str(), compress(pa).c_str(), index, englishEnding(index).c_str());\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n    while (!ans.seekEof()) {\r\n        ans.readToken();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n    while (!ouf.seekEof()) {\r\n        ouf.readToken();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              index + extraInAnsCount, index);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              index + extraInOufCount, index);\r\n\r\n    if (index == 0)\r\n        quitf(_ok, \"Empty output\");\r\n    else if (index == 1)\r\n        quitf(_ok, \"%s\", pa.c_str());\r\n    else\r\n        quitf(_ok, \"%d token(s): yes count is %d, no count is %d\", index, yesCount, noCount);\r\n\r\n    quitf(_fail, \"Impossible case\");\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring random_username(int min_len = 1, int max_len = 16) {\n    int len = rnd.next(min_len, max_len);\n    string s(len, ' ');\n    static const string chars = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789_\";\n    for(int i = 0; i < len; ++i) {\n        s[i] = chars[rnd.next((int)chars.size())];\n    }\n    return s;\n}\n\nstring random_hostname() {\n    static const string chars = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789_\";\n    int total_len = rnd.next(1, 32);\n    vector<string> words;\n    while (total_len > 0) {\n        int max_word_len = min(16, total_len);\n        int word_len = rnd.next(1, max_word_len);\n        string word(word_len, ' ');\n        for(int i = 0; i < word_len; ++i) {\n            word[i] = chars[rnd.next((int)chars.size())];\n        }\n        words.push_back(word);\n        total_len -= word_len;\n        if (total_len > 0) {\n            total_len--; // subtract for the dot\n        }\n    }\n    string hostname = words[0];\n    for(int i = 1; i < words.size(); ++i) {\n        hostname += '.';\n        hostname += words[i];\n    }\n    return hostname;\n}\n\nstring random_resource(int min_len = 1, int max_len = 16) {\n    return random_username(min_len, max_len);\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    string type = opt<string>(\"type\", \"default\");\n\n    if (type == \"valid_random\") {\n        string username = random_username();\n        string hostname = random_hostname();\n        string resource;\n        if (rnd.next(2) == 0) {\n            // with resource\n            resource = random_resource();\n            printf(\"%s@%s/%s\\n\", username.c_str(), hostname.c_str(), resource.c_str());\n        } else {\n            // without resource\n            printf(\"%s@%s\\n\", username.c_str(), hostname.c_str());\n        }\n    } else if (type == \"valid_max\") {\n        string username = random_username(16, 16);\n        string hostname;\n        {\n            // Generate hostname with total length 32\n            int remaining_len = 32;\n            vector<string> words;\n            while(remaining_len > 0) {\n                int word_len = min(16, remaining_len); // words can't be longer than 16\n                string word = random_username(word_len, word_len);\n                words.push_back(word);\n                remaining_len -= word_len;\n                if (remaining_len > 0) {\n                    remaining_len--; // subtract for the dot\n                }\n            }\n            hostname = words[0];\n            for(int i = 1; i < words.size(); ++i) {\n                hostname += '.';\n                hostname += words[i];\n            }\n        }\n        string resource = random_resource(16, 16);\n        // Both options: with or without resource\n        if (rnd.next(2) == 0) {\n            printf(\"%s@%s/%s\\n\", username.c_str(), hostname.c_str(), resource.c_str());\n        } else {\n            printf(\"%s@%s\\n\", username.c_str(), hostname.c_str());\n        }\n    } else if (type == \"invalid_username_length\") {\n        // Generate username with length 0 or >16\n        int len;\n        if (rnd.next(2) == 0) {\n            len = 0;\n        } else {\n            len = rnd.next(17, 20);\n        }\n        string username(len, 'a'); // can be any allowed character\n        string hostname = random_hostname();\n        string resource;\n        if (rnd.next(2) == 0) {\n            resource = random_resource();\n            printf(\"%s@%s/%s\\n\", username.c_str(), hostname.c_str(), resource.c_str());\n        } else {\n            printf(\"%s@%s\\n\", username.c_str(), hostname.c_str());\n        }\n    } else if (type == \"invalid_hostname_length\") {\n        // Generate hostname with length 0 or >32\n        string username = random_username();\n        int len;\n        if (rnd.next(2) == 0) {\n            len = 0;\n        } else {\n            len = rnd.next(33, 50);\n        }\n        // Create a hostname of length len\n        string hostname(len, 'a'); // use allowed characters\n        string resource;\n        if (rnd.next(2) == 0) {\n            resource = random_resource();\n            printf(\"%s@%s/%s\\n\", username.c_str(), hostname.c_str(), resource.c_str());\n        } else {\n            printf(\"%s@%s\\n\", username.c_str(), hostname.c_str());\n        }\n    } else if (type == \"invalid_hostname_word_length\") {\n        // Generate a hostname where a word has length 0 or >16\n        string username = random_username();\n        string hostname;\n        vector<string> words;\n        // Decide whether to have a word of length 0 or >16\n        if (rnd.next(2) == 0) {\n            // Word of length 0\n            int num_words = rnd.next(2, 5);\n            for(int i = 0; i < num_words; ++i) {\n                if (i == rnd.next(0, num_words -1)) {\n                    // Empty word\n                    words.push_back(\"\");\n                } else {\n                    words.push_back(random_username(1, 16));\n                }\n            }\n        } else {\n            // Word of length >16\n            int num_words = rnd.next(1, 5);\n            for(int i = 0; i < num_words; ++i) {\n                if (i == rnd.next(0, num_words -1)) {\n                    // Long word\n                    words.push_back(random_username(17, 20));\n                } else {\n                    words.push_back(random_username(1, 16));\n                }\n            }\n        }\n        hostname = words[0];\n        for(int i = 1; i < words.size(); ++i) {\n            hostname += '.';\n            hostname += words[i];\n        }\n        string resource;\n        if (rnd.next(2) == 0) {\n            resource = random_resource();\n            printf(\"%s@%s/%s\\n\", username.c_str(), hostname.c_str(), resource.c_str());\n        } else {\n            printf(\"%s@%s\\n\", username.c_str(), hostname.c_str());\n        }\n    } else if (type == \"invalid_chars\") {\n        // Introduce invalid characters into username, hostname, or resource\n        // Decide where to introduce invalid characters\n        int location = rnd.next(0, 2); // 0: username, 1: hostname, 2: resource\n        string username = random_username();\n        string hostname = random_hostname();\n        string resource;\n        if (rnd.next(2) == 0) {\n            resource = random_resource();\n        }\n\n        // Generate invalid character\n        static const string invalid_chars = \"!@#$%^&*()-=+[]{}|;:'\\\",<>./?`~\\\\\";\n        char invalid_char = invalid_chars[rnd.next((int)invalid_chars.size())];\n\n        if (location == 0) {\n            // Insert invalid character into username\n            int pos = rnd.next(0, (int)username.length());\n            username.insert(username.begin() + pos, invalid_char);\n        } else if (location == 1) {\n            // Insert invalid character into hostname\n            int pos = rnd.next(0, (int)hostname.length());\n            hostname.insert(hostname.begin() + pos, invalid_char);\n        } else {\n            // Insert invalid character into resource\n            if (resource.empty()) {\n                resource = random_resource();\n            }\n            int pos = rnd.next(0, (int)resource.length());\n            resource.insert(resource.begin() + pos, invalid_char);\n        }\n        if (!resource.empty()) {\n            printf(\"%s@%s/%s\\n\", username.c_str(), hostname.c_str(), resource.c_str());\n        } else {\n            printf(\"%s@%s\\n\", username.c_str(), hostname.c_str());\n        }\n    } else if (type == \"missing_at\") {\n        // Omit the '@' symbol\n        string username = random_username();\n        string hostname = random_hostname();\n        string resource;\n        if (rnd.next(2) == 0) {\n            resource = random_resource();\n            printf(\"%s%s/%s\\n\", username.c_str(), hostname.c_str(), resource.c_str());\n        } else {\n            printf(\"%s%s\\n\", username.c_str(), hostname.c_str());\n        }\n    } else if (type == \"multiple_at\") {\n        // Include multiple '@' symbols\n        string username = random_username();\n        string hostname = random_hostname();\n        string resource;\n        if (rnd.next(2) == 0) {\n            resource = random_resource();\n        }\n        // Insert extra '@' in random place\n        string s = username + '@' + hostname;\n        int pos = rnd.next(0, (int)s.length());\n        s.insert(s.begin() + pos, '@');\n        if (!resource.empty()) {\n            s += '/';\n            s += resource;\n        }\n        printf(\"%s\\n\", s.c_str());\n    } else if (type == \"invalid_resource_length\") {\n        // Generate resource with length 0 or >16\n        string username = random_username();\n        string hostname = random_hostname();\n        int len;\n        if (rnd.next(2) == 0) {\n            len = 0;\n        } else {\n            len = rnd.next(17, 25);\n        }\n        string resource(len, 'a'); // can be any allowed character\n        // The resource is optional, so we need to decide to include it\n        if (resource.empty()) {\n            // No resource\n            printf(\"%s@%s/\\n\", username.c_str(), hostname.c_str()); // Add a slash but empty resource\n        } else {\n            printf(\"%s@%s/%s\\n\", username.c_str(), hostname.c_str(), resource.c_str());\n        }\n    } else if (type == \"invalid_resource_structure\") {\n        // Include extra slashes or other invalid structures in resource\n        string username = random_username();\n        string hostname = random_hostname();\n        string resource = random_resource();\n        // Introduce invalid structure\n        if (rnd.next(2) == 0) {\n            // Multiple slashes\n            printf(\"%s@%s//%s\\n\", username.c_str(), hostname.c_str(), resource.c_str());\n        } else {\n            // Slash in resource itself\n            resource.insert(rnd.next(0, (int)resource.length()), \"/\");\n            printf(\"%s@%s/%s\\n\", username.c_str(), hostname.c_str(), resource.c_str());\n        }\n    } else if (type == \"leading_trailing_dots\") {\n        // Leading or trailing dots in hostname\n        string username = random_username();\n        string hostname = random_hostname();\n        if (rnd.next(2) == 0) {\n            // Leading dot\n            hostname = \".\" + hostname;\n        } else {\n            // Trailing dot\n            hostname = hostname + \".\";\n        }\n        string resource;\n        if (rnd.next(2) == 0) {\n            resource = random_resource();\n            printf(\"%s@%s/%s\\n\", username.c_str(), hostname.c_str(), resource.c_str());\n        } else {\n            printf(\"%s@%s\\n\", username.c_str(), hostname.c_str());\n        }\n    } else if (type == \"long_input_line\") {\n        // Total input length >100\n        // Generate valid username, hostname, resource but total length >100\n        string username = random_username();\n        string hostname = random_hostname();\n        string resource = random_resource();\n        string s = username + \"@\" + hostname + \"/\" + resource;\n        // Now append extra characters to exceed length\n        while (s.length() <= 100) {\n            s += \"a\";\n        }\n        printf(\"%s\\n\", s.c_str());\n    } else {\n        // Default action: generate a random test case\n        // Let's generate a random test case, valid or invalid\n        if (rnd.next(2) == 0) {\n            // Generate valid test case\n            string username = random_username();\n            string hostname = random_hostname();\n            string resource;\n            if (rnd.next(2) == 0) {\n                resource = random_resource();\n                printf(\"%s@%s/%s\\n\", username.c_str(), hostname.c_str(), resource.c_str());\n            } else {\n                printf(\"%s@%s\\n\", username.c_str(), hostname.c_str());\n            }\n        } else {\n            // Generate invalid test case\n            // Let's randomly pick one of the invalid cases above\n            int invalid_type = rnd.next(1, 9);\n            string invalid_type_str;\n            switch (invalid_type) {\n                case 1: invalid_type_str = \"invalid_username_length\"; break;\n                case 2: invalid_type_str = \"invalid_hostname_length\"; break;\n                case 3: invalid_type_str = \"invalid_hostname_word_length\"; break;\n                case 4: invalid_type_str = \"invalid_chars\"; break;\n                case 5: invalid_type_str = \"missing_at\"; break;\n                case 6: invalid_type_str = \"multiple_at\"; break;\n                case 7: invalid_type_str = \"invalid_resource_length\"; break;\n                case 8: invalid_type_str = \"invalid_resource_structure\"; break;\n                case 9: invalid_type_str = \"leading_trailing_dots\"; break;\n            }\n            // We can call our own program recursively with that type\n            string cmd = string(argv[0]) + \" -type \" + invalid_type_str;\n            system(cmd.c_str());\n            return 0;\n        }\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring random_username(int min_len = 1, int max_len = 16) {\n    int len = rnd.next(min_len, max_len);\n    string s(len, ' ');\n    static const string chars = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789_\";\n    for(int i = 0; i < len; ++i) {\n        s[i] = chars[rnd.next((int)chars.size())];\n    }\n    return s;\n}\n\nstring random_hostname() {\n    static const string chars = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789_\";\n    int total_len = rnd.next(1, 32);\n    vector<string> words;\n    while (total_len > 0) {\n        int max_word_len = min(16, total_len);\n        int word_len = rnd.next(1, max_word_len);\n        string word(word_len, ' ');\n        for(int i = 0; i < word_len; ++i) {\n            word[i] = chars[rnd.next((int)chars.size())];\n        }\n        words.push_back(word);\n        total_len -= word_len;\n        if (total_len > 0) {\n            total_len--; // subtract for the dot\n        }\n    }\n    string hostname = words[0];\n    for(int i = 1; i < words.size(); ++i) {\n        hostname += '.';\n        hostname += words[i];\n    }\n    return hostname;\n}\n\nstring random_resource(int min_len = 1, int max_len = 16) {\n    return random_username(min_len, max_len);\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    string type = opt<string>(\"type\", \"default\");\n\n    if (type == \"valid_random\") {\n        string username = random_username();\n        string hostname = random_hostname();\n        string resource;\n        if (rnd.next(2) == 0) {\n            // with resource\n            resource = random_resource();\n            printf(\"%s@%s/%s\\n\", username.c_str(), hostname.c_str(), resource.c_str());\n        } else {\n            // without resource\n            printf(\"%s@%s\\n\", username.c_str(), hostname.c_str());\n        }\n    } else if (type == \"valid_max\") {\n        string username = random_username(16, 16);\n        string hostname;\n        {\n            // Generate hostname with total length 32\n            int remaining_len = 32;\n            vector<string> words;\n            while(remaining_len > 0) {\n                int word_len = min(16, remaining_len); // words can't be longer than 16\n                string word = random_username(word_len, word_len);\n                words.push_back(word);\n                remaining_len -= word_len;\n                if (remaining_len > 0) {\n                    remaining_len--; // subtract for the dot\n                }\n            }\n            hostname = words[0];\n            for(int i = 1; i < words.size(); ++i) {\n                hostname += '.';\n                hostname += words[i];\n            }\n        }\n        string resource = random_resource(16, 16);\n        // Both options: with or without resource\n        if (rnd.next(2) == 0) {\n            printf(\"%s@%s/%s\\n\", username.c_str(), hostname.c_str(), resource.c_str());\n        } else {\n            printf(\"%s@%s\\n\", username.c_str(), hostname.c_str());\n        }\n    } else if (type == \"invalid_username_length\") {\n        // Generate username with length 0 or >16\n        int len;\n        if (rnd.next(2) == 0) {\n            len = 0;\n        } else {\n            len = rnd.next(17, 20);\n        }\n        string username(len, 'a'); // can be any allowed character\n        string hostname = random_hostname();\n        string resource;\n        if (rnd.next(2) == 0) {\n            resource = random_resource();\n            printf(\"%s@%s/%s\\n\", username.c_str(), hostname.c_str(), resource.c_str());\n        } else {\n            printf(\"%s@%s\\n\", username.c_str(), hostname.c_str());\n        }\n    } else if (type == \"invalid_hostname_length\") {\n        // Generate hostname with length 0 or >32\n        string username = random_username();\n        int len;\n        if (rnd.next(2) == 0) {\n            len = 0;\n        } else {\n            len = rnd.next(33, 50);\n        }\n        // Create a hostname of length len\n        string hostname(len, 'a'); // use allowed characters\n        string resource;\n        if (rnd.next(2) == 0) {\n            resource = random_resource();\n            printf(\"%s@%s/%s\\n\", username.c_str(), hostname.c_str(), resource.c_str());\n        } else {\n            printf(\"%s@%s\\n\", username.c_str(), hostname.c_str());\n        }\n    } else if (type == \"invalid_hostname_word_length\") {\n        // Generate a hostname where a word has length 0 or >16\n        string username = random_username();\n        string hostname;\n        vector<string> words;\n        // Decide whether to have a word of length 0 or >16\n        if (rnd.next(2) == 0) {\n            // Word of length 0\n            int num_words = rnd.next(2, 5);\n            for(int i = 0; i < num_words; ++i) {\n                if (i == rnd.next(0, num_words -1)) {\n                    // Empty word\n                    words.push_back(\"\");\n                } else {\n                    words.push_back(random_username(1, 16));\n                }\n            }\n        } else {\n            // Word of length >16\n            int num_words = rnd.next(1, 5);\n            for(int i = 0; i < num_words; ++i) {\n                if (i == rnd.next(0, num_words -1)) {\n                    // Long word\n                    words.push_back(random_username(17, 20));\n                } else {\n                    words.push_back(random_username(1, 16));\n                }\n            }\n        }\n        hostname = words[0];\n        for(int i = 1; i < words.size(); ++i) {\n            hostname += '.';\n            hostname += words[i];\n        }\n        string resource;\n        if (rnd.next(2) == 0) {\n            resource = random_resource();\n            printf(\"%s@%s/%s\\n\", username.c_str(), hostname.c_str(), resource.c_str());\n        } else {\n            printf(\"%s@%s\\n\", username.c_str(), hostname.c_str());\n        }\n    } else if (type == \"invalid_chars\") {\n        // Introduce invalid characters into username, hostname, or resource\n        // Decide where to introduce invalid characters\n        int location = rnd.next(0, 2); // 0: username, 1: hostname, 2: resource\n        string username = random_username();\n        string hostname = random_hostname();\n        string resource;\n        if (rnd.next(2) == 0) {\n            resource = random_resource();\n        }\n\n        // Generate invalid character\n        static const string invalid_chars = \"!@#$%^&*()-=+[]{}|;:'\\\",<>./?`~\\\\\";\n        char invalid_char = invalid_chars[rnd.next((int)invalid_chars.size())];\n\n        if (location == 0) {\n            // Insert invalid character into username\n            int pos = rnd.next(0, (int)username.length());\n            username.insert(username.begin() + pos, invalid_char);\n        } else if (location == 1) {\n            // Insert invalid character into hostname\n            int pos = rnd.next(0, (int)hostname.length());\n            hostname.insert(hostname.begin() + pos, invalid_char);\n        } else {\n            // Insert invalid character into resource\n            if (resource.empty()) {\n                resource = random_resource();\n            }\n            int pos = rnd.next(0, (int)resource.length());\n            resource.insert(resource.begin() + pos, invalid_char);\n        }\n        if (!resource.empty()) {\n            printf(\"%s@%s/%s\\n\", username.c_str(), hostname.c_str(), resource.c_str());\n        } else {\n            printf(\"%s@%s\\n\", username.c_str(), hostname.c_str());\n        }\n    } else if (type == \"missing_at\") {\n        // Omit the '@' symbol\n        string username = random_username();\n        string hostname = random_hostname();\n        string resource;\n        if (rnd.next(2) == 0) {\n            resource = random_resource();\n            printf(\"%s%s/%s\\n\", username.c_str(), hostname.c_str(), resource.c_str());\n        } else {\n            printf(\"%s%s\\n\", username.c_str(), hostname.c_str());\n        }\n    } else if (type == \"multiple_at\") {\n        // Include multiple '@' symbols\n        string username = random_username();\n        string hostname = random_hostname();\n        string resource;\n        if (rnd.next(2) == 0) {\n            resource = random_resource();\n        }\n        // Insert extra '@' in random place\n        string s = username + '@' + hostname;\n        int pos = rnd.next(0, (int)s.length());\n        s.insert(s.begin() + pos, '@');\n        if (!resource.empty()) {\n            s += '/';\n            s += resource;\n        }\n        printf(\"%s\\n\", s.c_str());\n    } else if (type == \"invalid_resource_length\") {\n        // Generate resource with length 0 or >16\n        string username = random_username();\n        string hostname = random_hostname();\n        int len;\n        if (rnd.next(2) == 0) {\n            len = 0;\n        } else {\n            len = rnd.next(17, 25);\n        }\n        string resource(len, 'a'); // can be any allowed character\n        // The resource is optional, so we need to decide to include it\n        if (resource.empty()) {\n            // No resource\n            printf(\"%s@%s/\\n\", username.c_str(), hostname.c_str()); // Add a slash but empty resource\n        } else {\n            printf(\"%s@%s/%s\\n\", username.c_str(), hostname.c_str(), resource.c_str());\n        }\n    } else if (type == \"invalid_resource_structure\") {\n        // Include extra slashes or other invalid structures in resource\n        string username = random_username();\n        string hostname = random_hostname();\n        string resource = random_resource();\n        // Introduce invalid structure\n        if (rnd.next(2) == 0) {\n            // Multiple slashes\n            printf(\"%s@%s//%s\\n\", username.c_str(), hostname.c_str(), resource.c_str());\n        } else {\n            // Slash in resource itself\n            resource.insert(rnd.next(0, (int)resource.length()), \"/\");\n            printf(\"%s@%s/%s\\n\", username.c_str(), hostname.c_str(), resource.c_str());\n        }\n    } else if (type == \"leading_trailing_dots\") {\n        // Leading or trailing dots in hostname\n        string username = random_username();\n        string hostname = random_hostname();\n        if (rnd.next(2) == 0) {\n            // Leading dot\n            hostname = \".\" + hostname;\n        } else {\n            // Trailing dot\n            hostname = hostname + \".\";\n        }\n        string resource;\n        if (rnd.next(2) == 0) {\n            resource = random_resource();\n            printf(\"%s@%s/%s\\n\", username.c_str(), hostname.c_str(), resource.c_str());\n        } else {\n            printf(\"%s@%s\\n\", username.c_str(), hostname.c_str());\n        }\n    } else if (type == \"long_input_line\") {\n        // Total input length >100\n        // Generate valid username, hostname, resource but total length >100\n        string username = random_username();\n        string hostname = random_hostname();\n        string resource = random_resource();\n        string s = username + \"@\" + hostname + \"/\" + resource;\n        // Now append extra characters to exceed length\n        while (s.length() <= 100) {\n            s += \"a\";\n        }\n        printf(\"%s\\n\", s.c_str());\n    } else {\n        // Default action: generate a random test case\n        // Let's generate a random test case, valid or invalid\n        if (rnd.next(2) == 0) {\n            // Generate valid test case\n            string username = random_username();\n            string hostname = random_hostname();\n            string resource;\n            if (rnd.next(2) == 0) {\n                resource = random_resource();\n                printf(\"%s@%s/%s\\n\", username.c_str(), hostname.c_str(), resource.c_str());\n            } else {\n                printf(\"%s@%s\\n\", username.c_str(), hostname.c_str());\n            }\n        } else {\n            // Generate invalid test case\n            // Let's randomly pick one of the invalid cases above\n            int invalid_type = rnd.next(1, 9);\n            string invalid_type_str;\n            switch (invalid_type) {\n                case 1: invalid_type_str = \"invalid_username_length\"; break;\n                case 2: invalid_type_str = \"invalid_hostname_length\"; break;\n                case 3: invalid_type_str = \"invalid_hostname_word_length\"; break;\n                case 4: invalid_type_str = \"invalid_chars\"; break;\n                case 5: invalid_type_str = \"missing_at\"; break;\n                case 6: invalid_type_str = \"multiple_at\"; break;\n                case 7: invalid_type_str = \"invalid_resource_length\"; break;\n                case 8: invalid_type_str = \"invalid_resource_structure\"; break;\n                case 9: invalid_type_str = \"leading_trailing_dots\"; break;\n            }\n            // We can call our own program recursively with that type\n            string cmd = string(argv[0]) + \" -type \" + invalid_type_str;\n            system(cmd.c_str());\n            return 0;\n        }\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -type valid_random\n./gen -type valid_random\n./gen -type valid_random\n./gen -type valid_random\n./gen -type valid_random\n\n./gen -type valid_max\n./gen -type valid_max\n\n./gen -type invalid_username_length\n./gen -type invalid_hostname_length\n./gen -type invalid_hostname_word_length\n./gen -type invalid_chars\n./gen -type missing_at\n./gen -type multiple_at\n./gen -type invalid_resource_length\n./gen -type invalid_resource_structure\n./gen -type leading_trailing_dots\n./gen -type long_input_line\n\n./gen -type invalid_username_length\n./gen -type invalid_hostname_length\n./gen -type invalid_hostname_word_length\n./gen -type invalid_chars\n./gen -type missing_at\n./gen -type multiple_at\n./gen -type invalid_resource_length\n./gen -type invalid_resource_structure\n./gen -type leading_trailing_dots\n./gen -type long_input_line\n\n./gen -type valid_random\n./gen -type valid_random\n./gen -type valid_random\n\n./gen -type default\n./gen -type default\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T19:49:11.137354",
        "total_tutorials": 1,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "21/B",
      "title": "B. Intersection",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line of the input contains three integer numbers A1, B1, C1 separated by space. The second line contains three integer numbers A2, B2, C2 separated by space. All the numbers are between -100 and 100, inclusive.",
      "output_spec": "OutputPrint the number of points in the intersection or -1 if there are infinite number of points.",
      "sample_tests": "ExamplesInputCopy1 1 02 2 0OutputCopy-1InputCopy1 1 02 -2 0OutputCopy1",
      "description": "B. Intersection\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line of the input contains three integer numbers A1, B1, C1 separated by space. The second line contains three integer numbers A2, B2, C2 separated by space. All the numbers are between -100 and 100, inclusive.\n\nOutputPrint the number of points in the intersection or -1 if there are infinite number of points.\n\nInputCopy1 1 02 2 0OutputCopy-1InputCopy1 1 02 -2 0OutputCopy1\n\nInputCopy1 1 02 2 0\n\nOutputCopy-1\n\nInputCopy1 1 02 -2 0\n\nOutputCopy1",
      "solutions": [
        {
          "title": "Codeforces Alpha Round #21 (Codeforces format) - Codeforces",
          "content": "I invite you to participate:) Round will be non-rated, but there will not be limited registration at this time! Please, read the rules before the contest!",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/496",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 154
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Alpha Round #21 (Codeforces format) - Codeforces - Code 1",
          "code": "0 0 10 0 1Expected 0, found -1.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/496",
          "author": "Qingyu"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int A1 = inf.readInt(-100, 100, \"A1\");\n    inf.readSpace();\n    int B1 = inf.readInt(-100, 100, \"B1\");\n    inf.readSpace();\n    int C1 = inf.readInt(-100, 100, \"C1\");\n    inf.readEoln();\n\n    int A2 = inf.readInt(-100, 100, \"A2\");\n    inf.readSpace();\n    int B2 = inf.readInt(-100, 100, \"B2\");\n    inf.readSpace();\n    int C2 = inf.readInt(-100, 100, \"C2\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int A1 = inf.readInt(-100, 100, \"A1\");\n    inf.readSpace();\n    int B1 = inf.readInt(-100, 100, \"B1\");\n    inf.readSpace();\n    int C1 = inf.readInt(-100, 100, \"C1\");\n    inf.readEoln();\n\n    int A2 = inf.readInt(-100, 100, \"A2\");\n    inf.readSpace();\n    int B2 = inf.readInt(-100, 100, \"B2\");\n    inf.readSpace();\n    int C2 = inf.readInt(-100, 100, \"C2\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int A1 = inf.readInt(-100, 100, \"A1\");\n    inf.readSpace();\n    int B1 = inf.readInt(-100, 100, \"B1\");\n    inf.readSpace();\n    int C1 = inf.readInt(-100, 100, \"C1\");\n    inf.readEoln();\n\n    int A2 = inf.readInt(-100, 100, \"A2\");\n    inf.readSpace();\n    int B2 = inf.readInt(-100, 100, \"B2\");\n    inf.readSpace();\n    int C2 = inf.readInt(-100, 100, \"C2\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n// Function to generate a non-zero integer in the range [from, to]\nint nextNonZero(int from, int to) {\n    int res = rnd.next(from, to);\n    while (res == 0) {\n        res = rnd.next(from, to);\n    }\n    return res;\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    string type = opt<string>(\"type\", \"random\");\n    int max_coeff = opt<int>(\"max_coeff\", 100);\n\n    int A1, B1, C1;\n    int A2, B2, C2;\n\n    if (type == \"identical\") {\n        // Generate coefficients A1, B1, C1\n        A1 = rnd.next(-max_coeff, max_coeff);\n        B1 = rnd.next(-max_coeff, max_coeff);\n        C1 = rnd.next(-max_coeff, max_coeff);\n\n        // Make sure that A1, B1, C1 are not all zero\n        while (A1 == 0 && B1 == 0 && C1 == 0) {\n            A1 = rnd.next(-max_coeff, max_coeff);\n            B1 = rnd.next(-max_coeff, max_coeff);\n            C1 = rnd.next(-max_coeff, max_coeff);\n        }\n\n        // Choose a random multiplier k\n        int k = nextNonZero(1, 10); // Multiplier\n        A2 = A1 * k;\n        B2 = B1 * k;\n        C2 = C1 * k;\n    } else if (type == \"parallel\") {\n        // Generate coefficients A1, B1, C1\n        A1 = rnd.next(-max_coeff, max_coeff);\n        B1 = rnd.next(-max_coeff, max_coeff);\n        C1 = rnd.next(-max_coeff, max_coeff);\n\n        // Make sure that A1 and B1 are not both zero\n        while (A1 == 0 && B1 == 0) {\n            A1 = rnd.next(-max_coeff, max_coeff);\n            B1 = rnd.next(-max_coeff, max_coeff);\n        }\n\n        // Generate C2 different from C1\n        C2 = rnd.next(-max_coeff, max_coeff);\n        while (C2 == C1) {\n            C2 = rnd.next(-max_coeff, max_coeff);\n        }\n\n        A2 = A1;\n        B2 = B1;\n    } else if (type == \"intersecting\") {\n        // Generate random coefficients for first line\n        A1 = rnd.next(-max_coeff, max_coeff);\n        B1 = rnd.next(-max_coeff, max_coeff);\n        C1 = rnd.next(-max_coeff, max_coeff);\n\n        // Make sure that A1 and B1 are not both zero\n        while (A1 == 0 && B1 == 0) {\n            A1 = rnd.next(-max_coeff, max_coeff);\n            B1 = rnd.next(-max_coeff, max_coeff);\n        }\n\n        // Generate random coefficients for second line\n        A2 = rnd.next(-max_coeff, max_coeff);\n        B2 = rnd.next(-max_coeff, max_coeff);\n        C2 = rnd.next(-max_coeff, max_coeff);\n\n        // Make sure that A2 and B2 are not both zero\n        while (A2 == 0 && B2 == 0) {\n            A2 = rnd.next(-max_coeff, max_coeff);\n            B2 = rnd.next(-max_coeff, max_coeff);\n        }\n\n        // Ensure lines are not parallel or identical\n        while (A1 * B2 == A2 * B1) {\n            A2 = rnd.next(-max_coeff, max_coeff);\n            B2 = rnd.next(-max_coeff, max_coeff);\n            while (A2 == 0 && B2 == 0) {\n                A2 = rnd.next(-max_coeff, max_coeff);\n                B2 = rnd.next(-max_coeff, max_coeff);\n            }\n            C2 = rnd.next(-max_coeff, max_coeff);\n        }\n    } else if (type == \"zero_case\") {\n        // Both equations are 0=0\n        A1 = 0; B1 = 0; C1 = 0;\n        A2 = 0; B2 = 0; C2 = 0;\n    } else if (type == \"contradictory\") {\n        // One equation is 0=0, the other is 0=C2≠0\n        A1 = 0; B1 = 0; C1 = 0;\n        A2 = 0; B2 = 0;\n        C2 = nextNonZero(-max_coeff, max_coeff);\n    } else if (type == \"vertical_lines\") {\n        // Lines with A≠0, B=0 (vertical)\n        A1 = nextNonZero(-max_coeff, max_coeff);\n        B1 = 0;\n        C1 = rnd.next(-max_coeff, max_coeff);\n\n        A2 = A1;\n        B2 = B1;\n        C2 = rnd.next(-max_coeff, max_coeff);\n        // Make sure they are not identical\n        while (C2 == C1) {\n            C2 = rnd.next(-max_coeff, max_coeff);\n        }\n    } else if (type == \"horizontal_lines\") {\n        // Lines with A=0, B≠0 (horizontal)\n        A1 = 0;\n        B1 = nextNonZero(-max_coeff, max_coeff);\n        C1 = rnd.next(-max_coeff, max_coeff);\n\n        A2 = A1;\n        B2 = B1;\n        C2 = rnd.next(-max_coeff, max_coeff);\n        // Make sure they are not identical\n        while (C2 == C1) {\n            C2 = rnd.next(-max_coeff, max_coeff);\n        }\n    } else if (type == \"degenerate_lines\") {\n        // A=B=0, C≠0 (equation has no solution)\n        A1 = 0;\n        B1 = 0;\n        C1 = nextNonZero(-max_coeff, max_coeff);\n\n        A2 = 0;\n        B2 = 0;\n        C2 = rnd.next(-max_coeff, max_coeff);\n    } else {\n        // Random case\n        A1 = rnd.next(-max_coeff, max_coeff);\n        B1 = rnd.next(-max_coeff, max_coeff);\n        C1 = rnd.next(-max_coeff, max_coeff);\n\n        // Make sure that A1 and B1 are not both zero\n        while (A1 == 0 && B1 == 0) {\n            A1 = rnd.next(-max_coeff, max_coeff);\n            B1 = rnd.next(-max_coeff, max_coeff);\n        }\n\n        A2 = rnd.next(-max_coeff, max_coeff);\n        B2 = rnd.next(-max_coeff, max_coeff);\n        C2 = rnd.next(-max_coeff, max_coeff);\n\n        // Make sure that A2 and B2 are not both zero\n        while (A2 == 0 && B2 == 0) {\n            A2 = rnd.next(-max_coeff, max_coeff);\n            B2 = rnd.next(-max_coeff, max_coeff);\n        }\n    }\n\n    // Output the equations\n    printf(\"%d %d %d\\n\", A1, B1, C1);\n    printf(\"%d %d %d\\n\", A2, B2, C2);\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n// Function to generate a non-zero integer in the range [from, to]\nint nextNonZero(int from, int to) {\n    int res = rnd.next(from, to);\n    while (res == 0) {\n        res = rnd.next(from, to);\n    }\n    return res;\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    string type = opt<string>(\"type\", \"random\");\n    int max_coeff = opt<int>(\"max_coeff\", 100);\n\n    int A1, B1, C1;\n    int A2, B2, C2;\n\n    if (type == \"identical\") {\n        // Generate coefficients A1, B1, C1\n        A1 = rnd.next(-max_coeff, max_coeff);\n        B1 = rnd.next(-max_coeff, max_coeff);\n        C1 = rnd.next(-max_coeff, max_coeff);\n\n        // Make sure that A1, B1, C1 are not all zero\n        while (A1 == 0 && B1 == 0 && C1 == 0) {\n            A1 = rnd.next(-max_coeff, max_coeff);\n            B1 = rnd.next(-max_coeff, max_coeff);\n            C1 = rnd.next(-max_coeff, max_coeff);\n        }\n\n        // Choose a random multiplier k\n        int k = nextNonZero(1, 10); // Multiplier\n        A2 = A1 * k;\n        B2 = B1 * k;\n        C2 = C1 * k;\n    } else if (type == \"parallel\") {\n        // Generate coefficients A1, B1, C1\n        A1 = rnd.next(-max_coeff, max_coeff);\n        B1 = rnd.next(-max_coeff, max_coeff);\n        C1 = rnd.next(-max_coeff, max_coeff);\n\n        // Make sure that A1 and B1 are not both zero\n        while (A1 == 0 && B1 == 0) {\n            A1 = rnd.next(-max_coeff, max_coeff);\n            B1 = rnd.next(-max_coeff, max_coeff);\n        }\n\n        // Generate C2 different from C1\n        C2 = rnd.next(-max_coeff, max_coeff);\n        while (C2 == C1) {\n            C2 = rnd.next(-max_coeff, max_coeff);\n        }\n\n        A2 = A1;\n        B2 = B1;\n    } else if (type == \"intersecting\") {\n        // Generate random coefficients for first line\n        A1 = rnd.next(-max_coeff, max_coeff);\n        B1 = rnd.next(-max_coeff, max_coeff);\n        C1 = rnd.next(-max_coeff, max_coeff);\n\n        // Make sure that A1 and B1 are not both zero\n        while (A1 == 0 && B1 == 0) {\n            A1 = rnd.next(-max_coeff, max_coeff);\n            B1 = rnd.next(-max_coeff, max_coeff);\n        }\n\n        // Generate random coefficients for second line\n        A2 = rnd.next(-max_coeff, max_coeff);\n        B2 = rnd.next(-max_coeff, max_coeff);\n        C2 = rnd.next(-max_coeff, max_coeff);\n\n        // Make sure that A2 and B2 are not both zero\n        while (A2 == 0 && B2 == 0) {\n            A2 = rnd.next(-max_coeff, max_coeff);\n            B2 = rnd.next(-max_coeff, max_coeff);\n        }\n\n        // Ensure lines are not parallel or identical\n        while (A1 * B2 == A2 * B1) {\n            A2 = rnd.next(-max_coeff, max_coeff);\n            B2 = rnd.next(-max_coeff, max_coeff);\n            while (A2 == 0 && B2 == 0) {\n                A2 = rnd.next(-max_coeff, max_coeff);\n                B2 = rnd.next(-max_coeff, max_coeff);\n            }\n            C2 = rnd.next(-max_coeff, max_coeff);\n        }\n    } else if (type == \"zero_case\") {\n        // Both equations are 0=0\n        A1 = 0; B1 = 0; C1 = 0;\n        A2 = 0; B2 = 0; C2 = 0;\n    } else if (type == \"contradictory\") {\n        // One equation is 0=0, the other is 0=C2≠0\n        A1 = 0; B1 = 0; C1 = 0;\n        A2 = 0; B2 = 0;\n        C2 = nextNonZero(-max_coeff, max_coeff);\n    } else if (type == \"vertical_lines\") {\n        // Lines with A≠0, B=0 (vertical)\n        A1 = nextNonZero(-max_coeff, max_coeff);\n        B1 = 0;\n        C1 = rnd.next(-max_coeff, max_coeff);\n\n        A2 = A1;\n        B2 = B1;\n        C2 = rnd.next(-max_coeff, max_coeff);\n        // Make sure they are not identical\n        while (C2 == C1) {\n            C2 = rnd.next(-max_coeff, max_coeff);\n        }\n    } else if (type == \"horizontal_lines\") {\n        // Lines with A=0, B≠0 (horizontal)\n        A1 = 0;\n        B1 = nextNonZero(-max_coeff, max_coeff);\n        C1 = rnd.next(-max_coeff, max_coeff);\n\n        A2 = A1;\n        B2 = B1;\n        C2 = rnd.next(-max_coeff, max_coeff);\n        // Make sure they are not identical\n        while (C2 == C1) {\n            C2 = rnd.next(-max_coeff, max_coeff);\n        }\n    } else if (type == \"degenerate_lines\") {\n        // A=B=0, C≠0 (equation has no solution)\n        A1 = 0;\n        B1 = 0;\n        C1 = nextNonZero(-max_coeff, max_coeff);\n\n        A2 = 0;\n        B2 = 0;\n        C2 = rnd.next(-max_coeff, max_coeff);\n    } else {\n        // Random case\n        A1 = rnd.next(-max_coeff, max_coeff);\n        B1 = rnd.next(-max_coeff, max_coeff);\n        C1 = rnd.next(-max_coeff, max_coeff);\n\n        // Make sure that A1 and B1 are not both zero\n        while (A1 == 0 && B1 == 0) {\n            A1 = rnd.next(-max_coeff, max_coeff);\n            B1 = rnd.next(-max_coeff, max_coeff);\n        }\n\n        A2 = rnd.next(-max_coeff, max_coeff);\n        B2 = rnd.next(-max_coeff, max_coeff);\n        C2 = rnd.next(-max_coeff, max_coeff);\n\n        // Make sure that A2 and B2 are not both zero\n        while (A2 == 0 && B2 == 0) {\n            A2 = rnd.next(-max_coeff, max_coeff);\n            B2 = rnd.next(-max_coeff, max_coeff);\n        }\n    }\n\n    // Output the equations\n    printf(\"%d %d %d\\n\", A1, B1, C1);\n    printf(\"%d %d %d\\n\", A2, B2, C2);\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Identical lines\n./gen -type identical -max_coeff 100\n./gen -type identical -max_coeff 1\n./gen -type identical -max_coeff 50\n./gen -type identical -max_coeff 100\n./gen -type identical -max_coeff 100\n\n# Parallel lines\n./gen -type parallel -max_coeff 100\n./gen -type parallel -max_coeff 1\n./gen -type parallel -max_coeff 50\n./gen -type parallel -max_coeff 100\n./gen -type parallel -max_coeff 100\n\n# Intersecting lines\n./gen -type intersecting -max_coeff 100\n./gen -type intersecting -max_coeff 1\n./gen -type intersecting -max_coeff 50\n./gen -type intersecting -max_coeff 100\n./gen -type intersecting -max_coeff 100\n\n# Zero case (0 = 0 and 0 = 0)\n./gen -type zero_case\n\n# Contradictory equations (0 = 0 and 0 = C ≠ 0)\n./gen -type contradictory\n\n# Vertical lines\n./gen -type vertical_lines -max_coeff 100\n./gen -type vertical_lines -max_coeff 1\n./gen -type vertical_lines -max_coeff 50\n./gen -type vertical_lines -max_coeff 100\n./gen -type vertical_lines -max_coeff 100\n\n# Horizontal lines\n./gen -type horizontal_lines -max_coeff 100\n./gen -type horizontal_lines -max_coeff 1\n./gen -type horizontal_lines -max_coeff 50\n./gen -type horizontal_lines -max_coeff 100\n./gen -type horizontal_lines -max_coeff 100\n\n# Degenerate lines (no solution)\n./gen -type degenerate_lines\n./gen -type degenerate_lines -max_coeff 50\n\n# Random cases\n./gen\n./gen\n./gen\n./gen\n./gen\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T19:49:13.400104",
        "total_tutorials": 1,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "21/C",
      "title": "C. Stripe 2",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test64 megabytes",
      "input_spec": "InputThe first input line contains integer n (1 ≤ n ≤ 105) — amount of squares in the stripe. The second line contains n space-separated numbers — they are the numbers written in the squares of the stripe. These numbers are integer and do not exceed 10000 in absolute value.",
      "output_spec": "OutputOutput the amount of ways to cut the stripe into three non-empty pieces so that the sum of numbers from each piece is equal to the sum of numbers from any other piece. Don't forget that it's allowed to cut the stripe along the squares' borders only.",
      "sample_tests": "ExamplesInputCopy41 2 3 3OutputCopy1InputCopy51 2 3 4 5OutputCopy0",
      "description": "C. Stripe 2\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test64 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first input line contains integer n (1 ≤ n ≤ 105) — amount of squares in the stripe. The second line contains n space-separated numbers — they are the numbers written in the squares of the stripe. These numbers are integer and do not exceed 10000 in absolute value.\n\nOutputOutput the amount of ways to cut the stripe into three non-empty pieces so that the sum of numbers from each piece is equal to the sum of numbers from any other piece. Don't forget that it's allowed to cut the stripe along the squares' borders only.\n\nInputCopy41 2 3 3OutputCopy1InputCopy51 2 3 4 5OutputCopy0\n\nInputCopy41 2 3 3\n\nOutputCopy1\n\nInputCopy51 2 3 4 5\n\nOutputCopy0",
      "solutions": [
        {
          "title": "Codeforces Alpha Round #21 (Codeforces format) - Codeforces",
          "content": "I invite you to participate:) Round will be non-rated, but there will not be limited registration at this time! Please, read the rules before the contest!",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/496",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 154
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Alpha Round #21 (Codeforces format) - Codeforces - Code 1",
          "code": "0 0 10 0 1Expected 0, found -1.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/496",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n    vector<int> a = inf.readInts(n, -10000, 10000);\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n    vector<int> a = inf.readInts(n, -10000, 10000);\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n    vector<int> a = inf.readInts(n, -10000, 10000);\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n    int maxA = opt<int>(\"maxA\", 10000);\n    // Ensure that maxA is within [-10000, 10000]\n    if (maxA > 10000) maxA = 10000;\n    if (maxA < -10000) maxA = -10000;\n\n    vector<int> a(n);\n\n    if (type == \"random\") {\n        // Generate random numbers between -maxA and maxA\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(-maxA, maxA);\n        }\n    } else if (type == \"allzeros\") {\n        // All zeros\n        for (int i = 0; i < n; ++i) {\n            a[i] = 0;\n        }\n    } else if (type == \"allones\") {\n        // All ones\n        for (int i = 0; i < n; ++i) {\n            a[i] = 1;\n        }\n    } else if (type == \"alternating\") {\n        // Alternating maxA and -maxA\n        for (int i = 0; i < n; ++i) {\n            a[i] = (i % 2 == 0) ? maxA : -maxA;\n        }\n    } else if (type == \"max\") {\n        // All maxA\n        for (int i = 0; i < n; ++i) {\n            a[i] = maxA;\n        }\n    } else if (type == \"min\") {\n        // All -maxA\n        for (int i = 0; i < n; ++i) {\n            a[i] = -maxA;\n        }\n    } else if (type == \"sumdivby3\") {\n        // Generate numbers so that sum is divisible by 3\n        long long sum = 0;\n        for (int i = 0; i < n-1; ++i) {\n            a[i] = rnd.next(-maxA, maxA);\n            sum += a[i];\n        }\n        // Adjust the last number to make total sum divisible by 3\n        long long adjust = ((3 - (sum % 3)) % 3);\n        a[n-1] = rnd.next(-maxA, maxA);\n        a[n-1] += adjust;\n        if (a[n-1] > maxA) a[n-1] -= 3;\n        if (a[n-1] < -maxA) a[n-1] += 3;\n    } else if (type == \"sumnotdivby3\") {\n        // Generate numbers so that sum is NOT divisible by 3\n        long long sum = 0;\n        for (int i = 0; i < n-1; ++i) {\n            a[i] = rnd.next(-maxA, maxA);\n            sum += a[i];\n        }\n        // Adjust the last number to make total sum not divisible by 3\n        long long adjust = ((2 - (sum % 3)) % 3);\n        a[n-1] = rnd.next(-maxA, maxA);\n        a[n-1] += adjust;\n        if (a[n-1] > maxA) a[n-1] -= 3;\n        if (a[n-1] < -maxA) a[n-1] += 3;\n    } else if (type == \"zerosandones\") {\n        // Random zeros and ones\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(0, 1);\n        }\n    } else if (type == \"manyways\") {\n        // Build an array where there are many ways to split\n        // An array of all zeros has maximum number of ways\n        for (int i = 0; i < n; ++i) {\n            a[i] = 0;\n        }\n    } else if (type == \"negative\") {\n        // All negative numbers\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(-maxA, -1);\n        }\n    } else if (type == \"sumzero\") {\n        // Generate array where the total sum is zero\n        long long sum = 0;\n        for (int i = 0; i < n-1; ++i) {\n            a[i] = rnd.next(-maxA, maxA);\n            sum += a[i];\n        }\n        a[n-1] = -sum;\n        if (a[n-1] > maxA) {\n            a[n-1] = maxA - (a[n-1] - maxA);\n        }\n        if (a[n-1] < -maxA) {\n            a[n-1] = -maxA - (a[n-1] + maxA);\n        }\n    } else {\n        // Default to random\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(-maxA, maxA);\n        }\n    }\n\n    // Output\n    printf(\"%d\\n\", n);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d\", a[i]);\n        if (i < n -1) printf(\" \");\n    }\n    printf(\"\\n\");\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n    int maxA = opt<int>(\"maxA\", 10000);\n    // Ensure that maxA is within [-10000, 10000]\n    if (maxA > 10000) maxA = 10000;\n    if (maxA < -10000) maxA = -10000;\n\n    vector<int> a(n);\n\n    if (type == \"random\") {\n        // Generate random numbers between -maxA and maxA\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(-maxA, maxA);\n        }\n    } else if (type == \"allzeros\") {\n        // All zeros\n        for (int i = 0; i < n; ++i) {\n            a[i] = 0;\n        }\n    } else if (type == \"allones\") {\n        // All ones\n        for (int i = 0; i < n; ++i) {\n            a[i] = 1;\n        }\n    } else if (type == \"alternating\") {\n        // Alternating maxA and -maxA\n        for (int i = 0; i < n; ++i) {\n            a[i] = (i % 2 == 0) ? maxA : -maxA;\n        }\n    } else if (type == \"max\") {\n        // All maxA\n        for (int i = 0; i < n; ++i) {\n            a[i] = maxA;\n        }\n    } else if (type == \"min\") {\n        // All -maxA\n        for (int i = 0; i < n; ++i) {\n            a[i] = -maxA;\n        }\n    } else if (type == \"sumdivby3\") {\n        // Generate numbers so that sum is divisible by 3\n        long long sum = 0;\n        for (int i = 0; i < n-1; ++i) {\n            a[i] = rnd.next(-maxA, maxA);\n            sum += a[i];\n        }\n        // Adjust the last number to make total sum divisible by 3\n        long long adjust = ((3 - (sum % 3)) % 3);\n        a[n-1] = rnd.next(-maxA, maxA);\n        a[n-1] += adjust;\n        if (a[n-1] > maxA) a[n-1] -= 3;\n        if (a[n-1] < -maxA) a[n-1] += 3;\n    } else if (type == \"sumnotdivby3\") {\n        // Generate numbers so that sum is NOT divisible by 3\n        long long sum = 0;\n        for (int i = 0; i < n-1; ++i) {\n            a[i] = rnd.next(-maxA, maxA);\n            sum += a[i];\n        }\n        // Adjust the last number to make total sum not divisible by 3\n        long long adjust = ((2 - (sum % 3)) % 3);\n        a[n-1] = rnd.next(-maxA, maxA);\n        a[n-1] += adjust;\n        if (a[n-1] > maxA) a[n-1] -= 3;\n        if (a[n-1] < -maxA) a[n-1] += 3;\n    } else if (type == \"zerosandones\") {\n        // Random zeros and ones\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(0, 1);\n        }\n    } else if (type == \"manyways\") {\n        // Build an array where there are many ways to split\n        // An array of all zeros has maximum number of ways\n        for (int i = 0; i < n; ++i) {\n            a[i] = 0;\n        }\n    } else if (type == \"negative\") {\n        // All negative numbers\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(-maxA, -1);\n        }\n    } else if (type == \"sumzero\") {\n        // Generate array where the total sum is zero\n        long long sum = 0;\n        for (int i = 0; i < n-1; ++i) {\n            a[i] = rnd.next(-maxA, maxA);\n            sum += a[i];\n        }\n        a[n-1] = -sum;\n        if (a[n-1] > maxA) {\n            a[n-1] = maxA - (a[n-1] - maxA);\n        }\n        if (a[n-1] < -maxA) {\n            a[n-1] = -maxA - (a[n-1] + maxA);\n        }\n    } else {\n        // Default to random\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(-maxA, maxA);\n        }\n    }\n\n    // Output\n    printf(\"%d\\n\", n);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d\", a[i]);\n        if (i < n -1) printf(\" \");\n    }\n    printf(\"\\n\");\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Small n, random\n./gen -n 1 -type random\n./gen -n 2 -type random\n./gen -n 3 -type random\n./gen -n 4 -type random\n./gen -n 5 -type random\n\n# Small n, special cases\n./gen -n 5 -type allzeros\n./gen -n 5 -type allones\n./gen -n 5 -type alternating -maxA 10\n\n# Medium n, random\n./gen -n 100 -type random\n./gen -n 100 -type sumdivby3\n./gen -n 100 -type sumnotdivby3\n\n# Medium n, special cases\n./gen -n 100 -type allzeros\n./gen -n 100 -type negative -maxA 100\n\n# Larger n, random\n./gen -n 1000 -type random\n./gen -n 1000 -type sumdivby3\n./gen -n 1000 -type sumnotdivby3\n\n# Larger n, special cases\n./gen -n 1000 -type allzeros\n./gen -n 1000 -type negative -maxA 10000\n\n# Even larger n, random\n./gen -n 10000 -type random\n./gen -n 10000 -type sumdivby3\n./gen -n 10000 -type sumnotdivby3\n\n# Maximum n, random\n./gen -n 100000 -type random\n./gen -n 100000 -type sumdivby3\n./gen -n 100000 -type sumnotdivby3\n\n# Maximum n, special cases\n./gen -n 100000 -type allzeros\n./gen -n 100000 -type allones -maxA 10000\n./gen -n 100000 -type alternating -maxA 10000\n./gen -n 100000 -type negative -maxA 10000\n\n# Small n, multiple ways\n./gen -n 5 -type manyways\n# Medium n, multiple ways\n./gen -n 1000 -type manyways\n# Maximum n, multiple ways\n./gen -n 100000 -type manyways\n\n# Edge cases\n./gen -n 1 -type allzeros\n./gen -n 1 -type negative -maxA 10000\n\n# Sum zero cases\n./gen -n 1000 -type sumzero\n./gen -n 100000 -type sumzero\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T19:49:15.262092",
        "total_tutorials": 1,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "21/D",
      "title": "D. Traveling Graph",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test0.5 second",
      "memory_limit": "memory limit per test64 megabytes",
      "input_spec": "InputThe first line of the input contains two integers n and m (1 ≤ n ≤ 15, 0 ≤ m ≤ 2000), n is the amount of vertices, and m is the amount of edges. Following m lines contain edges as a triples x, y, w (1 ≤ x, y ≤ n, 1 ≤ w ≤ 10000), x, y are edge endpoints, and w is the edge length.",
      "output_spec": "OutputOutput minimal cycle length or -1 if it doesn't exists.",
      "sample_tests": "ExamplesInputCopy3 31 2 12 3 13 1 1OutputCopy3InputCopy3 21 2 32 3 4OutputCopy14",
      "description": "D. Traveling Graph\n\ntime limit per test0.5 second\n\ntime limit per test\n\nmemory limit per test64 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line of the input contains two integers n and m (1 ≤ n ≤ 15, 0 ≤ m ≤ 2000), n is the amount of vertices, and m is the amount of edges. Following m lines contain edges as a triples x, y, w (1 ≤ x, y ≤ n, 1 ≤ w ≤ 10000), x, y are edge endpoints, and w is the edge length.\n\nOutputOutput minimal cycle length or -1 if it doesn't exists.\n\nInputCopy3 31 2 12 3 13 1 1OutputCopy3InputCopy3 21 2 32 3 4OutputCopy14\n\nInputCopy3 31 2 12 3 13 1 1\n\nOutputCopy3\n\nInputCopy3 21 2 32 3 4\n\nOutputCopy14",
      "solutions": [
        {
          "title": "Codeforces Alpha Round #21 (Codeforces format) - Codeforces",
          "content": "I invite you to participate:) Round will be non-rated, but there will not be limited registration at this time! Please, read the rules before the contest!",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/496",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 154
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Alpha Round #21 (Codeforces format) - Codeforces - Code 1",
          "code": "0 0 10 0 1Expected 0, found -1.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/496",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char *argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 15, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(0, 2000, \"m\");\n    inf.readEoln();\n    \n    for (int i = 0; i < m; i++) {\n        string xi_name = \"x[\" + to_string(i+1) + \"]\";\n        int x = inf.readInt(1, n, xi_name.c_str());\n        inf.readSpace();\n        \n        string yi_name = \"y[\" + to_string(i+1) + \"]\";\n        int y = inf.readInt(1, n, yi_name.c_str());\n        inf.readSpace();\n        \n        string wi_name = \"w[\" + to_string(i+1) + \"]\";\n        int w = inf.readInt(1, 10000, wi_name.c_str());\n        inf.readEoln();\n    }\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char *argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 15, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(0, 2000, \"m\");\n    inf.readEoln();\n    \n    for (int i = 0; i < m; i++) {\n        string xi_name = \"x[\" + to_string(i+1) + \"]\";\n        int x = inf.readInt(1, n, xi_name.c_str());\n        inf.readSpace();\n        \n        string yi_name = \"y[\" + to_string(i+1) + \"]\";\n        int y = inf.readInt(1, n, yi_name.c_str());\n        inf.readSpace();\n        \n        string wi_name = \"w[\" + to_string(i+1) + \"]\";\n        int w = inf.readInt(1, 10000, wi_name.c_str());\n        inf.readEoln();\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char *argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 15, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(0, 2000, \"m\");\n    inf.readEoln();\n    \n    for (int i = 0; i < m; i++) {\n        string xi_name = \"x[\" + to_string(i+1) + \"]\";\n        int x = inf.readInt(1, n, xi_name.c_str());\n        inf.readSpace();\n        \n        string yi_name = \"y[\" + to_string(i+1) + \"]\";\n        int y = inf.readInt(1, n, yi_name.c_str());\n        inf.readSpace();\n        \n        string wi_name = \"w[\" + to_string(i+1) + \"]\";\n        int w = inf.readInt(1, 10000, wi_name.c_str());\n        inf.readEoln();\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\", 0); // default m=0 if not provided\n    string type = opt<string>(\"type\", \"random\");\n\n    // Ensure m is within bounds\n    m = min(m, 2000); // Max m is 2000\n\n    vector<tuple<int,int,int>> edges;\n\n    if (type == \"random\") {\n        // Generate m random edges, with possible loops and multiple edges\n        for (int i = 0; i < m; ++i) {\n            int u = rnd.next(1, n);\n            int v = rnd.next(1, n);\n            int w = rnd.next(1, 10000);\n            edges.emplace_back(u, v, w);\n        }\n    } else if (type == \"loops_only\") {\n        // Generate m loops\n        for (int i = 0; i < m; ++i) {\n            int u = rnd.next(1, n);\n            int w = rnd.next(1, 10000);\n            edges.emplace_back(u, u, w);\n        }\n    } else if (type == \"max_edges\") {\n        // Generate as many edges as possible, including multiple edges and loops\n        for (int u = 1; u <= n && edges.size() < m; ++u) {\n            for (int v = 1; v <= n && edges.size() < m; ++v) {\n                int edge_count = min(m - (int)edges.size(), 10); // Limit to 10 edges between each pair to avoid too many duplicates\n                for (int k = 0; k < edge_count && edges.size() < m; ++k) {\n                    int w = rnd.next(1, 10000);\n                    edges.emplace_back(u, v, w);\n                }\n            }\n        }\n        // If we still have less than m edges, fill with random edges\n        while (edges.size() < m) {\n            int u = rnd.next(1, n);\n            int v = rnd.next(1, n);\n            int w = rnd.next(1, 10000);\n            edges.emplace_back(u, v, w);\n        }\n    } else if (type == \"min_edges\") {\n        // Generate minimal number of edges without repeats\n        int max_possible_edges = n * n;\n        if (m > max_possible_edges) m = max_possible_edges;\n        int count = 0;\n        for (int u = 1; u <= n && count < m; ++u) {\n            for (int v = 1; v <= n && count < m; ++v) {\n                int w = rnd.next(1, 10000);\n                edges.emplace_back(u, v, w);\n                count++;\n            }\n        }\n    } else if (type == \"impossible\") {\n        if (n >= 2) {\n            // Generate edges that do not connect to vertex 1\n            for (int i = 0; i < m; ++i) {\n                int u = rnd.next(2, n);\n                int v = rnd.next(2, n);\n                int w = rnd.next(1, 10000);\n                edges.emplace_back(u, v, w);\n            }\n        } else {\n            // n = 1\n            // Generate edges from 1 to 1 if m > 0\n            for (int i = 0; i < m; ++i) {\n                int w = rnd.next(1, 10000);\n                edges.emplace_back(1, 1, w);\n            }\n        }\n    } else {\n        // Default to random\n        for (int i = 0; i < m; ++i) {\n            int u = rnd.next(1, n);\n            int v = rnd.next(1, n);\n            int w = rnd.next(1, 10000);\n            edges.emplace_back(u, v, w);\n        }\n    }\n\n    // Output n and m\n    printf(\"%d %d\\n\", n, (int)edges.size());\n\n    // Output edges\n    for (auto& e : edges) {\n        int x, y, w;\n        tie(x, y, w) = e;\n        printf(\"%d %d %d\\n\", x, y, w);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\", 0); // default m=0 if not provided\n    string type = opt<string>(\"type\", \"random\");\n\n    // Ensure m is within bounds\n    m = min(m, 2000); // Max m is 2000\n\n    vector<tuple<int,int,int>> edges;\n\n    if (type == \"random\") {\n        // Generate m random edges, with possible loops and multiple edges\n        for (int i = 0; i < m; ++i) {\n            int u = rnd.next(1, n);\n            int v = rnd.next(1, n);\n            int w = rnd.next(1, 10000);\n            edges.emplace_back(u, v, w);\n        }\n    } else if (type == \"loops_only\") {\n        // Generate m loops\n        for (int i = 0; i < m; ++i) {\n            int u = rnd.next(1, n);\n            int w = rnd.next(1, 10000);\n            edges.emplace_back(u, u, w);\n        }\n    } else if (type == \"max_edges\") {\n        // Generate as many edges as possible, including multiple edges and loops\n        for (int u = 1; u <= n && edges.size() < m; ++u) {\n            for (int v = 1; v <= n && edges.size() < m; ++v) {\n                int edge_count = min(m - (int)edges.size(), 10); // Limit to 10 edges between each pair to avoid too many duplicates\n                for (int k = 0; k < edge_count && edges.size() < m; ++k) {\n                    int w = rnd.next(1, 10000);\n                    edges.emplace_back(u, v, w);\n                }\n            }\n        }\n        // If we still have less than m edges, fill with random edges\n        while (edges.size() < m) {\n            int u = rnd.next(1, n);\n            int v = rnd.next(1, n);\n            int w = rnd.next(1, 10000);\n            edges.emplace_back(u, v, w);\n        }\n    } else if (type == \"min_edges\") {\n        // Generate minimal number of edges without repeats\n        int max_possible_edges = n * n;\n        if (m > max_possible_edges) m = max_possible_edges;\n        int count = 0;\n        for (int u = 1; u <= n && count < m; ++u) {\n            for (int v = 1; v <= n && count < m; ++v) {\n                int w = rnd.next(1, 10000);\n                edges.emplace_back(u, v, w);\n                count++;\n            }\n        }\n    } else if (type == \"impossible\") {\n        if (n >= 2) {\n            // Generate edges that do not connect to vertex 1\n            for (int i = 0; i < m; ++i) {\n                int u = rnd.next(2, n);\n                int v = rnd.next(2, n);\n                int w = rnd.next(1, 10000);\n                edges.emplace_back(u, v, w);\n            }\n        } else {\n            // n = 1\n            // Generate edges from 1 to 1 if m > 0\n            for (int i = 0; i < m; ++i) {\n                int w = rnd.next(1, 10000);\n                edges.emplace_back(1, 1, w);\n            }\n        }\n    } else {\n        // Default to random\n        for (int i = 0; i < m; ++i) {\n            int u = rnd.next(1, n);\n            int v = rnd.next(1, n);\n            int w = rnd.next(1, 10000);\n            edges.emplace_back(u, v, w);\n        }\n    }\n\n    // Output n and m\n    printf(\"%d %d\\n\", n, (int)edges.size());\n\n    // Output edges\n    for (auto& e : edges) {\n        int x, y, w;\n        tie(x, y, w) = e;\n        printf(\"%d %d %d\\n\", x, y, w);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -m 0 -type min_edges\n./gen -n 1 -m 1 -type loops_only\n./gen -n 1 -m 2000 -type max_edges\n\n./gen -n 2 -m 0 -type impossible\n./gen -n 2 -m 1 -type min_edges\n./gen -n 2 -m 4 -type random\n./gen -n 2 -m 10 -type max_edges\n\n./gen -n 3 -m 0 -type impossible\n./gen -n 3 -m 3 -type min_edges\n./gen -n 3 -m 10 -type random\n./gen -n 3 -m 10 -type loops_only\n\n./gen -n 5 -m 10 -type random\n./gen -n 5 -m 10 -type impossible\n./gen -n 5 -m 15 -type min_edges\n./gen -n 5 -m 2000 -type max_edges\n\n./gen -n 10 -m 0 -type impossible\n./gen -n 10 -m 20 -type random\n./gen -n 10 -m 45 -type min_edges\n./gen -n 10 -m 2000 -type max_edges\n\n./gen -n 15 -m 0 -type impossible\n./gen -n 15 -m 30 -type random\n./gen -n 15 -m 105 -type min_edges\n./gen -n 15 -m 2000 -type max_edges\n./gen -n 15 -m 2000 -type loops_only\n\n./gen -n 15 -m 1 -type min_edges\n./gen -n 15 -m 15 -type loops_only\n\n./gen -n 10 -m 100 -type random\n./gen -n 10 -m 500 -type random\n./gen -n 10 -m 2000 -type random\n\n./gen -n 10 -m 2000 -type impossible\n./gen -n 5 -m 0 -type impossible\n\n./gen -n 7 -m 100 -type loops_only\n\n./gen -n 7 -m 2000 -type max_edges\n\n./gen -n 5 -m 1500 -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T19:49:17.341006",
        "total_tutorials": 1,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "212/A",
      "title": "A. Приватизация",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест2 секунды",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеВ первой строке входных данных записано четыре целых числа n, m, k и t (1 ≤ n, m, t ≤ 200;1 ≤ k ≤ 5000), где n, m — количество городов в Берляндии и Бирляндии, соответственно, k — количество авиарейсов между ними, а t — количество частных компаний. Далее в k строках описаны авиарейсы по одному в строке парами натуральных чисел xi, yi (1 ≤ xi ≤ n;1 ≤ yi ≤ m), где xi и yi — номера городов в Берляндии и Бирляндии, соответственно, которые соединены i-ым рейсом. Между любой парой городов не более одного рейса, каждый рейс соединяет города разных стран. Города в Берляндии пронумерованы от 1 до n, а в Бирляндии — от 1 до m.",
      "output_spec": "Выходные данныеВ первую строку выведите неравномерность искомого способа. Во вторую строку выведите последовательность k целых чисел c1, c2, ..., ck (1 ≤ ci ≤ t), где ci — номер авиакомпании, которой следует продать i-ый авиарейс. Считайте, что авиарейсы пронумерованы от 1 до k в порядке появления во входных данных. Если решений несколько, выведите любое из них.",
      "sample_tests": "ПримерыВходные данныеСкопировать3 5 8 21 41 33 31 21 12 11 52 2Выходные данныеСкопировать42 1 2 1 2 1 2 2",
      "description": "A. Приватизация\n\nограничение по времени на тест2 секунды\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвыводstdout\n\nВходные данныеВ первой строке входных данных записано четыре целых числа n, m, k и t (1 ≤ n, m, t ≤ 200;1 ≤ k ≤ 5000), где n, m — количество городов в Берляндии и Бирляндии, соответственно, k — количество авиарейсов между ними, а t — количество частных компаний. Далее в k строках описаны авиарейсы по одному в строке парами натуральных чисел xi, yi (1 ≤ xi ≤ n;1 ≤ yi ≤ m), где xi и yi — номера городов в Берляндии и Бирляндии, соответственно, которые соединены i-ым рейсом. Между любой парой городов не более одного рейса, каждый рейс соединяет города разных стран. Города в Берляндии пронумерованы от 1 до n, а в Бирляндии — от 1 до m.\n\nВходные данные\n\nВыходные данныеВ первую строку выведите неравномерность искомого способа. Во вторую строку выведите последовательность k целых чисел c1, c2, ..., ck (1 ≤ ci ≤ t), где ci — номер авиакомпании, которой следует продать i-ый авиарейс. Считайте, что авиарейсы пронумерованы от 1 до k в порядке появления во входных данных. Если решений несколько, выведите любое из них.\n\nВыходные данные\n\nВходные данныеСкопировать3 5 8 21 41 33 31 21 12 11 52 2Выходные данныеСкопировать42 1 2 1 2 1 2 2\n\nВходные данныеСкопировать3 5 8 21 41 33 31 21 12 11 52 2\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать42 1 2 1 2 1 2 2\n\nВыходные данныеСкопировать\n\nСкопировать",
      "solutions": [
        {
          "title": "VK Cup 2012 — Финал! - Codeforces",
          "content": "Сегодня состоится финал VK Cup 2012, Финал! Мы желаем удачи всем участникам, а болельщикам — насладится интересным соревнованием. На открытии финала кубка в своей приветственной речи генеральный директор \"В Контакте\" Павел Дуров анонсировал апгрейд призового фонда. Я начинаю по-настоящему жалеть, что я не участник! Финалисты поборются за: 1 место — $30000 2 место — $20000 3 место — $10000 4-5 места — $2000 6-10 места — $1000 Удачи! Желаем только положительных эмоций. На старт! Внимание! ...UPD: Соревнования завершено! О его ходе и церемонии закрытия, я полагаю, совсем скоро напишет Alex_KPR. Всем спасибо за участие и интерес! Вот полные результаты.Поздравляем победителей. Тройка лидеров: sevenkplus (Yuzhou Gu) Китай s-quark (Qinshi Wang) Китай tourist (Геннадий Короткевич) Беларусь UPD: Как вы уже успели заметить, 16-го июля в 19:00 стартует неофициальная онлайн-версия финала VK Cup 2012. Любой желающий может принять участие и почувствовать себя на месте финалиста. Раунд будет нерейтинговым. Если вы решали или в какой-то степени знакомы с задачами, пожалуйста, воздержитесь от участия. Все задачи появятся в архиве и будут доступны всем желающим.",
          "author": "MikeMirzayanov",
          "url": "https://codeforces.com/blog/entry/4885",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 1162
        }
      ],
      "code_examples": [],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 200, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 200, \"m\");\n    inf.readSpace();\n    int k = inf.readInt(1, 5000, \"k\");\n    inf.readSpace();\n    int t = inf.readInt(1, 200, \"t\");\n    inf.readEoln();\n\n    set<pair<int, int>> flights;\n\n    for (int i = 0; i < k; ++i) {\n        int xi = inf.readInt(1, n, \"xi\");\n        inf.readSpace();\n        int yi = inf.readInt(1, m, \"yi\");\n        inf.readEoln();\n\n        pair<int, int> flight = make_pair(xi, yi);\n        ensuref(flights.count(flight) == 0, \"Duplicate flight between cities %d and %d\", xi, yi);\n        flights.insert(flight);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 200, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 200, \"m\");\n    inf.readSpace();\n    int k = inf.readInt(1, 5000, \"k\");\n    inf.readSpace();\n    int t = inf.readInt(1, 200, \"t\");\n    inf.readEoln();\n\n    set<pair<int, int>> flights;\n\n    for (int i = 0; i < k; ++i) {\n        int xi = inf.readInt(1, n, \"xi\");\n        inf.readSpace();\n        int yi = inf.readInt(1, m, \"yi\");\n        inf.readEoln();\n\n        pair<int, int> flight = make_pair(xi, yi);\n        ensuref(flights.count(flight) == 0, \"Duplicate flight between cities %d and %d\", xi, yi);\n        flights.insert(flight);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 200, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 200, \"m\");\n    inf.readSpace();\n    int k = inf.readInt(1, 5000, \"k\");\n    inf.readSpace();\n    int t = inf.readInt(1, 200, \"t\");\n    inf.readEoln();\n\n    set<pair<int, int>> flights;\n\n    for (int i = 0; i < k; ++i) {\n        int xi = inf.readInt(1, n, \"xi\");\n        inf.readSpace();\n        int yi = inf.readInt(1, m, \"yi\");\n        inf.readEoln();\n\n        pair<int, int> flight = make_pair(xi, yi);\n        ensuref(flights.count(flight) == 0, \"Duplicate flight between cities %d and %d\", xi, yi);\n        flights.insert(flight);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint n, m, k, t;\nvector<pair<int, int>> flights;\n\nint readAns(InStream& stream) {\n    int U = stream.readInt(0, INT_MAX, \"unevenness\");\n    vector<int> c(k);\n    for (int i = 0; i < k; ++i) {\n        c[i] = stream.readInt(1, t, format(\"c[%d]\", i + 1).c_str());\n    }\n\n    // Initialize counts for each city and company\n    vector<vector<int>> counts(n + m, vector<int>(t, 0));\n    for (int i = 0; i < k; ++i) {\n        int ci = c[i] - 1; // Convert to 0-based index\n        int xi = flights[i].first;         // City in Berland (0-based)\n        int yi = flights[i].second + n;    // City in Beerland (shifted index)\n        counts[xi][ci]++;\n        counts[yi][ci]++;\n    }\n\n    // Compute total unevenness\n    int total_u = 0;\n    for (int i = 0; i < n + m; ++i) {\n        int max_count = counts[i][0];\n        int min_count = counts[i][0];\n        for (int j = 1; j < t; ++j) {\n            max_count = max(max_count, counts[i][j]);\n            min_count = min(min_count, counts[i][j]);\n        }\n        total_u += max_count - min_count;\n    }\n\n    // Verify that the computed unevenness matches the printed unevenness\n    if (total_u != U) {\n        stream.quitf(_fail, \"Printed unevenness %d does not match computed unevenness %d\", U, total_u);\n    }\n\n    return U;\n}\n\nint main(int argc, char* argv[]) {\n    registerTestlibCmd(argc, argv);\n\n    n = inf.readInt(1, 200, \"n\");\n    m = inf.readInt(1, 200, \"m\");\n    k = inf.readInt(1, 5000, \"k\");\n    t = inf.readInt(1, 200, \"t\");\n\n    flights.resize(k);\n    for (int i = 0; i < k; ++i) {\n        int xi = inf.readInt(1, n, format(\"xi[%d]\", i + 1).c_str()) - 1;\n        int yi = inf.readInt(1, m, format(\"yi[%d]\", i + 1).c_str()) - 1;\n        flights[i] = make_pair(xi, yi);\n    }\n\n    // Read and validate jury's answer\n    int U_jury = readAns(ans);\n\n    // Read and validate participant's answer\n    int U_participant = readAns(ouf);\n\n    if (U_participant > U_jury) {\n        quitf(_wa, \"Participant's unevenness %d is worse than jury's unevenness %d\", U_participant, U_jury);\n    } else if (U_participant == U_jury) {\n        quitf(_ok, \"Correct solution with unevenness %d\", U_participant);\n    } else { // U_participant < U_jury\n        quitf(_fail, \"Participant's unevenness %d is better than jury's unevenness %d\", U_participant, U_jury);\n    }\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    int k = opt<int>(\"k\");\n    int t = opt<int>(\"t\");\n    string type = opt<string>(\"type\", \"random\");\n\n    const int MAX_N = 200;\n    const int MAX_K = 5000;\n\n    // Check constraints\n    ensure(1 <= n && n <= MAX_N);\n    ensure(1 <= m && m <= MAX_N);\n    ensure(1 <= t && t <= MAX_N);\n    ensure(1 <= k && k <= MAX_K);\n\n    vector<pair<int,int>> flights;\n\n    if (type == \"random\") {\n        if (k > n * m) {\n            cerr << \"k is too large for random unique flights\" << endl;\n            return 1;\n        }\n        vector<pair<int,int>> all_flights;\n        for (int i = 1; i <= n; i++)\n            for (int j = 1; j <= m; j++)\n                all_flights.emplace_back(i, j);\n        shuffle(all_flights.begin(), all_flights.end());\n        flights.assign(all_flights.begin(), all_flights.begin() + k);\n    } else if (type == \"full_bipartite\") {\n        int total = n * m;\n        if (k > total) k = total;\n        for (int i = 1; i <= n && flights.size() < k; i++)\n            for (int j = 1; j <= m && flights.size() < k; j++) {\n                flights.emplace_back(i, j);\n            }\n    } else if (type == \"star_berland\") {\n        if (k > m) k = m;\n        for (int j = 1; j <= m && flights.size() < k; j++) {\n            flights.emplace_back(1, j);\n        }\n    } else if (type == \"star_beerland\") {\n        if (k > n) k = n;\n        for (int i = 1; i <= n && flights.size() < k; i++) {\n            flights.emplace_back(i, 1);\n        }\n    } else if (type == \"one_to_one\") {\n        if (n != m) {\n            cerr << \"For type one_to_one, n must equal m\" << endl;\n            return 1;\n        }\n        if (k > n) k = n;\n        for (int i = 1; i <= n && flights.size() < k; i++) {\n            flights.emplace_back(i, i);\n        }\n    } else if (type == \"one_flight\") {\n        if (k != 1) {\n            cerr << \"For type one_flight, k must be 1\" << endl;\n            return 1;\n        }\n        flights.emplace_back(1, 1);\n    } else {\n        cerr << \"Unknown type: \" << type << endl;\n        return 1;\n    }\n\n    // Now output n, m, k, t\n    printf(\"%d %d %d %d\\n\", n, m, k, t);\n    for (size_t i = 0; i < flights.size(); i++) {\n        printf(\"%d %d\\n\", flights[i].first, flights[i].second);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    int k = opt<int>(\"k\");\n    int t = opt<int>(\"t\");\n    string type = opt<string>(\"type\", \"random\");\n\n    const int MAX_N = 200;\n    const int MAX_K = 5000;\n\n    // Check constraints\n    ensure(1 <= n && n <= MAX_N);\n    ensure(1 <= m && m <= MAX_N);\n    ensure(1 <= t && t <= MAX_N);\n    ensure(1 <= k && k <= MAX_K);\n\n    vector<pair<int,int>> flights;\n\n    if (type == \"random\") {\n        if (k > n * m) {\n            cerr << \"k is too large for random unique flights\" << endl;\n            return 1;\n        }\n        vector<pair<int,int>> all_flights;\n        for (int i = 1; i <= n; i++)\n            for (int j = 1; j <= m; j++)\n                all_flights.emplace_back(i, j);\n        shuffle(all_flights.begin(), all_flights.end());\n        flights.assign(all_flights.begin(), all_flights.begin() + k);\n    } else if (type == \"full_bipartite\") {\n        int total = n * m;\n        if (k > total) k = total;\n        for (int i = 1; i <= n && flights.size() < k; i++)\n            for (int j = 1; j <= m && flights.size() < k; j++) {\n                flights.emplace_back(i, j);\n            }\n    } else if (type == \"star_berland\") {\n        if (k > m) k = m;\n        for (int j = 1; j <= m && flights.size() < k; j++) {\n            flights.emplace_back(1, j);\n        }\n    } else if (type == \"star_beerland\") {\n        if (k > n) k = n;\n        for (int i = 1; i <= n && flights.size() < k; i++) {\n            flights.emplace_back(i, 1);\n        }\n    } else if (type == \"one_to_one\") {\n        if (n != m) {\n            cerr << \"For type one_to_one, n must equal m\" << endl;\n            return 1;\n        }\n        if (k > n) k = n;\n        for (int i = 1; i <= n && flights.size() < k; i++) {\n            flights.emplace_back(i, i);\n        }\n    } else if (type == \"one_flight\") {\n        if (k != 1) {\n            cerr << \"For type one_flight, k must be 1\" << endl;\n            return 1;\n        }\n        flights.emplace_back(1, 1);\n    } else {\n        cerr << \"Unknown type: \" << type << endl;\n        return 1;\n    }\n\n    // Now output n, m, k, t\n    printf(\"%d %d %d %d\\n\", n, m, k, t);\n    for (size_t i = 0; i < flights.size(); i++) {\n        printf(\"%d %d\\n\", flights[i].first, flights[i].second);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Test case 1: Small random test case\n./gen -n 5 -m 5 -k 10 -t 2 -type random\n\n# Test case 2: Small full bipartite\n./gen -n 5 -m 5 -k 25 -t 3 -type full_bipartite\n\n# Test case 3: Star Berland with one Berland city\n./gen -n 1 -m 5 -k 5 -t 2 -type star_berland\n\n# Test case 4: Star Beerland with one Beerland city\n./gen -n 5 -m 1 -k 5 -t 2 -type star_beerland\n\n# Test case 5: One to one mapping\n./gen -n 5 -m 5 -k 5 -t 2 -type one_to_one\n\n# Test case 6: One flight\n./gen -n 5 -m 5 -k 1 -t 1 -type one_flight\n\n# Test case 7: Random with n=m and k=n*m\n./gen -n 10 -m 10 -k 100 -t 5 -type random\n\n# Test case 8: Random with t=1\n./gen -n 20 -m 20 -k 100 -t 1 -type random\n\n# Test case 9: Random with t=max\n./gen -n 20 -m 20 -k 400 -t 200 -type random\n\n# Test case 10: Random with k=max\n./gen -n 100 -m 100 -k 5000 -t 50 -type random\n\n# Test case 11: Star Berland with max m\n./gen -n 1 -m 200 -k 200 -t 20 -type star_berland\n\n# Test case 12: Star Beerland with max n\n./gen -n 200 -m 1 -k 200 -t 20 -type star_beerland\n\n# Test case 13: Full bipartite max n and m\n./gen -n 50 -m 50 -k 2500 -t 100 -type full_bipartite\n\n# Test case 14: Random with k less than n*m\n./gen -n 100 -m 100 -k 3000 -t 50 -type random\n\n# Test case 15: Random with small t\n./gen -n 100 -m 100 -k 5000 -t 2 -type random\n\n# Test case 16: Random with n and m unequal\n./gen -n 150 -m 100 -k 5000 -t 70 -type random\n\n# Test case 17: Random with n=1\n./gen -n 1 -m 100 -k 100 -t 10 -type random\n\n# Test case 18: Random with m=1\n./gen -n 100 -m 1 -k 100 -t 10 -type random\n\n# Test case 19: Random with both n and m small\n./gen -n 3 -m 3 -k 5 -t 2 -type random\n\n# Test case 20: Random with t=k\n./gen -n 10 -m 10 -k 50 -t 50 -type random\n\n# Test case 21: Random with larger t than k\n./gen -n 10 -m 10 -k 50 -t 100 -type random\n\n# Test case 22: One flight with n=m=1\n./gen -n 1 -m 1 -k 1 -t 1 -type one_flight\n\n# Test case 23: Full bipartite with k less than n*m\n./gen -n 20 -m 20 -k 300 -t 30 -type full_bipartite\n\n# Test case 24: Star Berland with k less than m\n./gen -n 1 -m 100 -k 50 -t 5 -type star_berland\n\n# Test case 25: Star Beerland with k less than n\n./gen -n 100 -m 1 -k 50 -t 5 -type star_beerland\n\n# Test case 26: Random with t=200, n=200, m=200, k=5000\n./gen -n 200 -m 200 -k 5000 -t 200 -type random\n\n# Test case 27: Random with t=2, k=5000\n./gen -n 200 -m 200 -k 5000 -t 2 -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T19:49:19.156938",
        "total_tutorials": 1,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "212/B",
      "title": "B. Polycarpus is Looking for Good Substrings",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test4 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains a non-empty string s (1 ≤ |s| ≤ 106).The second line contains a single integer m (1 ≤ m ≤ 104). Next m lines contain descriptions of sets Ci. The i-th line contains string ci such that its trace equals Ci. It is guaranteed that all characters of each string ci are different.Note that Ci are not necessarily different. All given strings consist of lowercase English letters.",
      "output_spec": "OutputPrint m integers — the i-th integer must equal r(Ci, s).",
      "sample_tests": "ExamplesInputCopyaaaaa2aaOutputCopy11InputCopyabacaba3acbaaOutputCopy124",
      "description": "B. Polycarpus is Looking for Good Substrings\n\ntime limit per test4 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains a non-empty string s (1 ≤ |s| ≤ 106).The second line contains a single integer m (1 ≤ m ≤ 104). Next m lines contain descriptions of sets Ci. The i-th line contains string ci such that its trace equals Ci. It is guaranteed that all characters of each string ci are different.Note that Ci are not necessarily different. All given strings consist of lowercase English letters.\n\nOutputPrint m integers — the i-th integer must equal r(Ci, s).\n\nInputCopyaaaaa2aaOutputCopy11InputCopyabacaba3acbaaOutputCopy124\n\nInputCopyaaaaa2aa\n\nOutputCopy11\n\nInputCopyabacaba3acbaa\n\nOutputCopy124",
      "solutions": [
        {
          "title": "VK Cup 2012 — Финал! - Codeforces",
          "content": "Today is the main VK Cup event: VK Cup 2012 Finals! Good luck to all participants. And to those who don't participate — enjoy the interesting competition. VK CEO Pavel Durov announced the upgrade of a prize fund in the greeting speech at the finals' opening! I'm starting to really regret that I am not a participant.The participants compete for: 1st place — $30000 2nd place — $20000 3rd place — $10000 4-5 places — $2000 6-10 places — $1000 Good luck! Wish you only positive emotions. Ready! Steady!...UPD: The contest is over! I believe Alex_KPR will write about the contest and the closing ceremony soon. Thank you for participation and your interest. Here are the complete standings.Congrats to the winners. The top-3 is: sevenkplus (Yuzhou Gu) China s-quark (Qinshi Wang) China tourist (Gennady Korotkevich) Belarus UPD: As you have already noticed, the 16th July at 19:00 will start an unofficial online-version of the VK Cup 2012 Finals. Anyone can participate and feel himself as a finalist. Round will be unrated. If you already took part in the Finals or familiar with the problems, please refrain from participation. All problems will appear in the archive and will be available to everyone.",
          "author": "MikeMirzayanov",
          "url": "https://codeforces.com/blog/entry/4885",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1203
        }
      ],
      "code_examples": [],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    // Read and validate the string 's'\n    string s = inf.readToken(\"[a-z]+\", \"s\");\n    inf.readEoln();\n    ensuref(1 <= s.length() && s.length() <= 1000000, \"Length of s is %d, expected to be between 1 and 1,000,000\", (int)s.length());\n\n    // Read and validate the integer 'm'\n    int m = inf.readInt(1, 10000, \"m\");\n    inf.readEoln();\n\n    // Read and validate each string 'ci'\n    for (int i = 0; i < m; ++i) {\n        string ci = inf.readToken(\"[a-z]+\", \"ci\");\n        inf.readEoln();\n        ensuref((int)ci.length() <= 26, \"Length of ci at line %d is %d, expected to be at most 26\", i + 3, (int)ci.length());\n        \n        // Check that all characters in 'ci' are distinct\n        set<char> ci_chars(ci.begin(), ci.end());\n        ensuref((int)ci_chars.size() == (int)ci.length(), \"String ci at line %d has duplicate characters\", i + 3);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    // Read and validate the string 's'\n    string s = inf.readToken(\"[a-z]+\", \"s\");\n    inf.readEoln();\n    ensuref(1 <= s.length() && s.length() <= 1000000, \"Length of s is %d, expected to be between 1 and 1,000,000\", (int)s.length());\n\n    // Read and validate the integer 'm'\n    int m = inf.readInt(1, 10000, \"m\");\n    inf.readEoln();\n\n    // Read and validate each string 'ci'\n    for (int i = 0; i < m; ++i) {\n        string ci = inf.readToken(\"[a-z]+\", \"ci\");\n        inf.readEoln();\n        ensuref((int)ci.length() <= 26, \"Length of ci at line %d is %d, expected to be at most 26\", i + 3, (int)ci.length());\n        \n        // Check that all characters in 'ci' are distinct\n        set<char> ci_chars(ci.begin(), ci.end());\n        ensuref((int)ci_chars.size() == (int)ci.length(), \"String ci at line %d has duplicate characters\", i + 3);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    // Read and validate the string 's'\n    string s = inf.readToken(\"[a-z]+\", \"s\");\n    inf.readEoln();\n    ensuref(1 <= s.length() && s.length() <= 1000000, \"Length of s is %d, expected to be between 1 and 1,000,000\", (int)s.length());\n\n    // Read and validate the integer 'm'\n    int m = inf.readInt(1, 10000, \"m\");\n    inf.readEoln();\n\n    // Read and validate each string 'ci'\n    for (int i = 0; i < m; ++i) {\n        string ci = inf.readToken(\"[a-z]+\", \"ci\");\n        inf.readEoln();\n        ensuref((int)ci.length() <= 26, \"Length of ci at line %d is %d, expected to be at most 26\", i + 3, (int)ci.length());\n        \n        // Check that all characters in 'ci' are distinct\n        set<char> ci_chars(ci.begin(), ci.end());\n        ensuref((int)ci_chars.size() == (int)ci.length(), \"String ci at line %d has duplicate characters\", i + 3);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string s_type = opt<string>(\"s_type\", \"random\");\n    string c_type = opt<string>(\"c_type\", \"random\");\n\n    // Generate string s\n    string s;\n    if (s_type == \"random\") {\n        for (int i = 0; i < n; ++i)\n            s += (char)('a' + rnd.next(26));\n    } else if (s_type == \"same_char\") {\n        char c = 'a' + rnd.next(26);\n        s = string(n, c);\n    } else if (s_type == \"all_distinct\") {\n        s = \"\";\n        string letters = \"abcdefghijklmnopqrstuvwxyz\";\n        shuffle(letters.begin(), letters.end());\n        while ((int)s.size() < n) {\n            int rem = min(n - (int)s.size(), 26);\n            s += letters.substr(0, rem);\n            shuffle(letters.begin(), letters.end());\n        }\n    } else if (s_type == \"palindrome\") {\n        string half;\n        for (int i = 0; i < (n+1)/2; ++i)\n            half += (char)('a' + rnd.next(26));\n        s = half;\n        if (n % 2 == 1)\n            half.pop_back();\n        reverse(half.begin(), half.end());\n        s += half;\n    } else if (s_type == \"periodic\") {\n        int period = rnd.next(1, min(n, 10)); // small period\n        string ptn;\n        for (int i = 0; i < period; ++i)\n            ptn += (char)('a' + rnd.next(26));\n        while ((int)s.size() < n)\n            s += ptn.substr(0, min(period, n - (int)s.size()));\n    } else {\n        // default to random\n        for (int i = 0; i < n; ++i)\n            s += (char)('a' + rnd.next(26));\n    }\n\n    // Generate Ci strings\n    vector<string> cis;\n    if (c_type == \"random\") {\n        for (int i = 0; i < m; ++i) {\n            int len = rnd.next(1, min(5, 26));\n            set<char> letters;\n            for (int j = 0; j < len; ++j) {\n                char c;\n                do {\n                    c = 'a' + rnd.next(26);\n                } while (letters.count(c));\n                letters.insert(c);\n            }\n            string ci(letters.begin(), letters.end());\n            cis.push_back(ci);\n        }\n    } else if (c_type == \"one_letter\") {\n        for (int i = 0; i < m; ++i) {\n            char c = 'a' + rnd.next(26);\n            cis.push_back(string(1, c));\n        }\n    } else if (c_type == \"maximal\") {\n        // ci's are of maximal size (26)\n        string letters = \"abcdefghijklmnopqrstuvwxyz\";\n        for (int i = 0; i < m; ++i) {\n            shuffle(letters.begin(), letters.end());\n            string ci = letters;\n            cis.push_back(ci);\n        }\n    } else if (c_type == \"full_alphabet\") {\n        string ci = \"abcdefghijklmnopqrstuvwxyz\";\n        for (int i = 0; i < m; ++i)\n            cis.push_back(ci);\n    } else if (c_type == \"from_s\") {\n        // ci's are subsets of letters from s\n        set<char> unique_letters(s.begin(), s.end());\n        vector<char> letters(unique_letters.begin(), unique_letters.end());\n        for (int i = 0; i < m; ++i) {\n            int len = rnd.next(1, min(5, (int)letters.size()));\n            shuffle(letters.begin(), letters.end());\n            string ci(letters.begin(), letters.begin() + len);\n            cis.push_back(ci);\n        }\n    } else {\n        // default to random\n        for (int i = 0; i < m; ++i) {\n            int len = rnd.next(1, min(5, 26));\n            set<char> letters;\n            for (int j = 0; j < len; ++j) {\n                char c;\n                do {\n                    c = 'a' + rnd.next(26);\n                } while (letters.count(c));\n                letters.insert(c);\n            }\n            string ci(letters.begin(), letters.end());\n            cis.push_back(ci);\n        }\n    }\n\n    // Output s\n    printf(\"%s\\n\", s.c_str());\n    // Output m\n    printf(\"%d\\n\", m);\n    // Output Ci strings\n    for (int i = 0; i < m; ++i) {\n        printf(\"%s\\n\", cis[i].c_str());\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string s_type = opt<string>(\"s_type\", \"random\");\n    string c_type = opt<string>(\"c_type\", \"random\");\n\n    // Generate string s\n    string s;\n    if (s_type == \"random\") {\n        for (int i = 0; i < n; ++i)\n            s += (char)('a' + rnd.next(26));\n    } else if (s_type == \"same_char\") {\n        char c = 'a' + rnd.next(26);\n        s = string(n, c);\n    } else if (s_type == \"all_distinct\") {\n        s = \"\";\n        string letters = \"abcdefghijklmnopqrstuvwxyz\";\n        shuffle(letters.begin(), letters.end());\n        while ((int)s.size() < n) {\n            int rem = min(n - (int)s.size(), 26);\n            s += letters.substr(0, rem);\n            shuffle(letters.begin(), letters.end());\n        }\n    } else if (s_type == \"palindrome\") {\n        string half;\n        for (int i = 0; i < (n+1)/2; ++i)\n            half += (char)('a' + rnd.next(26));\n        s = half;\n        if (n % 2 == 1)\n            half.pop_back();\n        reverse(half.begin(), half.end());\n        s += half;\n    } else if (s_type == \"periodic\") {\n        int period = rnd.next(1, min(n, 10)); // small period\n        string ptn;\n        for (int i = 0; i < period; ++i)\n            ptn += (char)('a' + rnd.next(26));\n        while ((int)s.size() < n)\n            s += ptn.substr(0, min(period, n - (int)s.size()));\n    } else {\n        // default to random\n        for (int i = 0; i < n; ++i)\n            s += (char)('a' + rnd.next(26));\n    }\n\n    // Generate Ci strings\n    vector<string> cis;\n    if (c_type == \"random\") {\n        for (int i = 0; i < m; ++i) {\n            int len = rnd.next(1, min(5, 26));\n            set<char> letters;\n            for (int j = 0; j < len; ++j) {\n                char c;\n                do {\n                    c = 'a' + rnd.next(26);\n                } while (letters.count(c));\n                letters.insert(c);\n            }\n            string ci(letters.begin(), letters.end());\n            cis.push_back(ci);\n        }\n    } else if (c_type == \"one_letter\") {\n        for (int i = 0; i < m; ++i) {\n            char c = 'a' + rnd.next(26);\n            cis.push_back(string(1, c));\n        }\n    } else if (c_type == \"maximal\") {\n        // ci's are of maximal size (26)\n        string letters = \"abcdefghijklmnopqrstuvwxyz\";\n        for (int i = 0; i < m; ++i) {\n            shuffle(letters.begin(), letters.end());\n            string ci = letters;\n            cis.push_back(ci);\n        }\n    } else if (c_type == \"full_alphabet\") {\n        string ci = \"abcdefghijklmnopqrstuvwxyz\";\n        for (int i = 0; i < m; ++i)\n            cis.push_back(ci);\n    } else if (c_type == \"from_s\") {\n        // ci's are subsets of letters from s\n        set<char> unique_letters(s.begin(), s.end());\n        vector<char> letters(unique_letters.begin(), unique_letters.end());\n        for (int i = 0; i < m; ++i) {\n            int len = rnd.next(1, min(5, (int)letters.size()));\n            shuffle(letters.begin(), letters.end());\n            string ci(letters.begin(), letters.begin() + len);\n            cis.push_back(ci);\n        }\n    } else {\n        // default to random\n        for (int i = 0; i < m; ++i) {\n            int len = rnd.next(1, min(5, 26));\n            set<char> letters;\n            for (int j = 0; j < len; ++j) {\n                char c;\n                do {\n                    c = 'a' + rnd.next(26);\n                } while (letters.count(c));\n                letters.insert(c);\n            }\n            string ci(letters.begin(), letters.end());\n            cis.push_back(ci);\n        }\n    }\n\n    // Output s\n    printf(\"%s\\n\", s.c_str());\n    // Output m\n    printf(\"%d\\n\", m);\n    // Output Ci strings\n    for (int i = 0; i < m; ++i) {\n        printf(\"%s\\n\", cis[i].c_str());\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -m 1 -s_type same_char -c_type one_letter\n./gen -n 1 -m 1 -s_type random -c_type random\n./gen -n 2 -m 1 -s_type same_char -c_type random\n./gen -n 2 -m 10000 -s_type random -c_type full_alphabet\n./gen -n 3 -m 10 -s_type all_distinct -c_type one_letter\n./gen -n 3 -m 100 -s_type periodic -c_type maximal\n./gen -n 3 -m 5000 -s_type same_char -c_type one_letter\n./gen -n 10 -m 10 -s_type all_distinct -c_type full_alphabet\n./gen -n 100 -m 100 -s_type palindrome -c_type random\n./gen -n 1000 -m 1000 -s_type periodic -c_type from_s\n./gen -n 1000 -m 1 -s_type same_char -c_type maximal\n./gen -n 1000 -m 1 -s_type same_char -c_type one_letter\n./gen -n 10000 -m 10000 -s_type random -c_type random\n./gen -n 100000 -m 10000 -s_type same_char -c_type from_s\n./gen -n 999999 -m 9999 -s_type palindrome -c_type one_letter\n./gen -n 1000000 -m 10000 -s_type all_distinct -c_type full_alphabet\n./gen -n 1000000 -m 10000 -s_type palindrome -c_type maximal\n./gen -n 1000000 -m 1 -s_type periodic -c_type random\n./gen -n 1000000 -m 1 -s_type random -c_type one_letter\n./gen -n 100000 -m 10000 -s_type periodic -c_type maximal\n./gen -n 100000 -m 10000 -s_type random -c_type from_s\n./gen -n 500000 -m 1000 -s_type random -c_type from_s\n./gen -n 500000 -m 10000 -s_type random -c_type random\n./gen -n 50000 -m 10000 -s_type random -c_type random\n./gen -n 1 -m 10000 -s_type same_char -c_type one_letter\n./gen -n 1 -m 10000 -s_type random -c_type one_letter\n./gen -n 1000000 -m 10000 -s_type same_char -c_type full_alphabet\n./gen -n 500000 -m 10000 -s_type periodic -c_type random\n./gen -n 1000000 -m 10000 -s_type random -c_type maximal\n./gen -n 1000000 -m 10000 -s_type same_char -c_type maximal\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T19:49:21.403853",
        "total_tutorials": 1,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "212/C",
      "title": "C. Cowboys",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe input data consists of a single string s. Its length is from 3 to 100 characters, inclusive. Line s consists of letters \"A\" and \"B\".",
      "output_spec": "OutputPrint the sought number of states.",
      "sample_tests": "ExamplesInputCopyBABBBABBAOutputCopy2InputCopyABABBOutputCopy2InputCopyABABABOutputCopy4",
      "description": "time limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe input data consists of a single string s. Its length is from 3 to 100 characters, inclusive. Line s consists of letters \"A\" and \"B\".\n\nOutputPrint the sought number of states.\n\nInputCopyBABBBABBAOutputCopy2InputCopyABABBOutputCopy2InputCopyABABABOutputCopy4\n\nInputCopyBABBBABBA\n\nOutputCopy2\n\nInputCopyABABB\n\nOutputCopy2\n\nInputCopyABABAB\n\nOutputCopy4\n\nNoteIn the first sample the possible initial states are \"ABBBABBAB\" and \"ABBBABBBA\".In the second sample the possible initial states are \"AABBB\" and \"BABBA\".",
      "solutions": [
        {
          "title": "VK Cup 2012 — Финал! - Codeforces",
          "content": "Today is the main VK Cup event: VK Cup 2012 Finals! Good luck to all participants. And to those who don't participate — enjoy the interesting competition. VK CEO Pavel Durov announced the upgrade of a prize fund in the greeting speech at the finals' opening! I'm starting to really regret that I am not a participant.The participants compete for: 1st place — $30000 2nd place — $20000 3rd place — $10000 4-5 places — $2000 6-10 places — $1000 Good luck! Wish you only positive emotions. Ready! Steady!...UPD: The contest is over! I believe Alex_KPR will write about the contest and the closing ceremony soon. Thank you for participation and your interest. Here are the complete standings.Congrats to the winners. The top-3 is: sevenkplus (Yuzhou Gu) China s-quark (Qinshi Wang) China tourist (Gennady Korotkevich) Belarus UPD: As you have already noticed, the 16th July at 19:00 will start an unofficial online-version of the VK Cup 2012 Finals. Anyone can participate and feel himself as a finalist. Round will be unrated. If you already took part in the Finals or familiar with the problems, please refrain from participation. All problems will appear in the archive and will be available to everyone.",
          "author": "MikeMirzayanov",
          "url": "https://codeforces.com/blog/entry/4885",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1203
        }
      ],
      "code_examples": [],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    string s = inf.readLine(\"[AB]{3,100}\", \"s\");\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    string s = inf.readLine(\"[AB]{3,100}\", \"s\");\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    string s = inf.readLine(\"[AB]{3,100}\", \"s\");\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    string s(n, 'A');\n\n    if (type == \"allA\") {\n        // All cowboys aim clockwise\n        s = string(n, 'A');\n    } else if (type == \"allB\") {\n        // All cowboys aim counterclockwise\n        s = string(n, 'B');\n    } else if (type == \"alternating\") {\n        // Cowboys alternate between 'A' and 'B'\n        for (int i = 0; i < n; ++i) {\n            s[i] = (i % 2 == 0) ? 'A' : 'B';\n        }\n    } else if (type == \"oneA_restB\") {\n        // One 'A', rest 'B's\n        s = string(n, 'B');\n        int pos = rnd.next(0, n - 1);\n        s[pos] = 'A';\n    } else if (type == \"oneB_restA\") {\n        // One 'B', rest 'A's\n        s = string(n, 'A');\n        int pos = rnd.next(0, n - 1);\n        s[pos] = 'B';\n    } else if (type == \"pattern\") {\n        // Repeat a given pattern\n        string p = opt<string>(\"pattern\", \"AB\");\n        int plen = p.length();\n        for (int i = 0; i < n; ++i) {\n            s[i] = p[i % plen];\n        }\n    } else if (type == \"special\") {\n        // Create a palindromic string\n        for (int i = 0; i < n / 2; ++i) {\n            s[i] = rnd.next(0, 1) ? 'A' : 'B';\n            s[n - i - 1] = s[i];\n        }\n        if (n % 2 == 1) {\n            s[n / 2] = rnd.next(0, 1) ? 'A' : 'B';\n        }\n    } else {\n        // Randomly generate 'A's and 'B's\n        for (int i = 0; i < n; ++i) {\n            s[i] = rnd.next(0, 1) ? 'A' : 'B';\n        }\n    }\n\n    // Output the string s\n    printf(\"%s\\n\", s.c_str());\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    string s(n, 'A');\n\n    if (type == \"allA\") {\n        // All cowboys aim clockwise\n        s = string(n, 'A');\n    } else if (type == \"allB\") {\n        // All cowboys aim counterclockwise\n        s = string(n, 'B');\n    } else if (type == \"alternating\") {\n        // Cowboys alternate between 'A' and 'B'\n        for (int i = 0; i < n; ++i) {\n            s[i] = (i % 2 == 0) ? 'A' : 'B';\n        }\n    } else if (type == \"oneA_restB\") {\n        // One 'A', rest 'B's\n        s = string(n, 'B');\n        int pos = rnd.next(0, n - 1);\n        s[pos] = 'A';\n    } else if (type == \"oneB_restA\") {\n        // One 'B', rest 'A's\n        s = string(n, 'A');\n        int pos = rnd.next(0, n - 1);\n        s[pos] = 'B';\n    } else if (type == \"pattern\") {\n        // Repeat a given pattern\n        string p = opt<string>(\"pattern\", \"AB\");\n        int plen = p.length();\n        for (int i = 0; i < n; ++i) {\n            s[i] = p[i % plen];\n        }\n    } else if (type == \"special\") {\n        // Create a palindromic string\n        for (int i = 0; i < n / 2; ++i) {\n            s[i] = rnd.next(0, 1) ? 'A' : 'B';\n            s[n - i - 1] = s[i];\n        }\n        if (n % 2 == 1) {\n            s[n / 2] = rnd.next(0, 1) ? 'A' : 'B';\n        }\n    } else {\n        // Randomly generate 'A's and 'B's\n        for (int i = 0; i < n; ++i) {\n            s[i] = rnd.next(0, 1) ? 'A' : 'B';\n        }\n    }\n\n    // Output the string s\n    printf(\"%s\\n\", s.c_str());\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 3 -type allA\n./gen -n 3 -type allB\n./gen -n 3 -type alternating\n\n./gen -n 4 -type allA\n./gen -n 4 -type allB\n./gen -n 4 -type alternating\n\n./gen -n 5 -type allA\n./gen -n 5 -type oneA_restB\n./gen -n 5 -type oneB_restA\n\n./gen -n 6 -type pattern -pattern AB\n\n./gen -n 7 -type pattern -pattern ABA\n\n./gen -n 10 -type random\n./gen -n 10 -type special\n\n./gen -n 15 -type pattern -pattern ABBAB\n\n./gen -n 20 -type random\n\n./gen -n 50 -type allA\n./gen -n 50 -type allB\n\n./gen -n 50 -type random\n./gen -n 50 -type special\n\n./gen -n 100 -type alternating\n./gen -n 100 -type random\n\n./gen -n 100 -type special\n\n./gen -n 100 -type pattern -pattern BABABA\n\n./gen -n 3 -type special\n\n./gen -n 99 -type random\n\n./gen -n 100 -type oneA_restB\n\n./gen -n 100 -type oneB_restA\n\n./gen -n 100 -type pattern -pattern ABABABABAB\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T19:49:23.348282",
        "total_tutorials": 1,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "212/D",
      "title": "D. Cutting a Fence",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test5 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains a single integer n (1 ≤ n ≤ 106) — the number of planks in the fence. The second line contains a sequence of integers a1, a2, ..., an (1 ≤ ai ≤ 109) where ai is the height of the i-th plank of the fence.The third line contains an integer m (1 ≤ m ≤ 106) and the next line contains m space-separated integers k1, k2, ..., km (1 ≤ ki ≤ n) where ki is the width of the desired fuchsia-colored rectangle in planks.",
      "output_spec": "OutputPrint m whitespace-separated real numbers, the i-th number equals the expected value of the rectangle height, if its width in planks equals ki. The value will be considered correct if its absolute or relative error doesn't exceed 10 - 9.",
      "sample_tests": "ExamplesInputCopy33 2 131 2 3OutputCopy2.0000000000000001.5000000000000001.000000000000000InputCopy21 131 2 1OutputCopy1.0000000000000001.0000000000000001.000000000000000",
      "description": "D. Cutting a Fence\n\ntime limit per test5 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains a single integer n (1 ≤ n ≤ 106) — the number of planks in the fence. The second line contains a sequence of integers a1, a2, ..., an (1 ≤ ai ≤ 109) where ai is the height of the i-th plank of the fence.The third line contains an integer m (1 ≤ m ≤ 106) and the next line contains m space-separated integers k1, k2, ..., km (1 ≤ ki ≤ n) where ki is the width of the desired fuchsia-colored rectangle in planks.\n\nOutputPrint m whitespace-separated real numbers, the i-th number equals the expected value of the rectangle height, if its width in planks equals ki. The value will be considered correct if its absolute or relative error doesn't exceed 10 - 9.\n\nInputCopy33 2 131 2 3OutputCopy2.0000000000000001.5000000000000001.000000000000000InputCopy21 131 2 1OutputCopy1.0000000000000001.0000000000000001.000000000000000\n\nInputCopy33 2 131 2 3\n\nOutputCopy2.0000000000000001.5000000000000001.000000000000000\n\nInputCopy21 131 2 1\n\nOutputCopy1.0000000000000001.0000000000000001.000000000000000\n\nNoteLet's consider the first sample test.   There are three possible positions of the fence for k1 = 1. For the first position (x = 1) the height is 3, for the second one (x = 2) the height is 2, for the third one (x = 3) the height is 1. As the fence position is chosen uniformly, the expected height of the fence equals ;  There are two possible positions of the fence for k2 = 2. For the first position (x = 1) the height is 2, for the second one (x = 2) the height is 1. The expected height of the fence equals ;  There is the only possible position of the fence for k3 = 3. The expected height of the fence equals 1.",
      "solutions": [
        {
          "title": "VK Cup 2012 — Финал! - Codeforces",
          "content": "Today is the main VK Cup event: VK Cup 2012 Finals! Good luck to all participants. And to those who don't participate — enjoy the interesting competition. VK CEO Pavel Durov announced the upgrade of a prize fund in the greeting speech at the finals' opening! I'm starting to really regret that I am not a participant.The participants compete for: 1st place — $30000 2nd place — $20000 3rd place — $10000 4-5 places — $2000 6-10 places — $1000 Good luck! Wish you only positive emotions. Ready! Steady!...UPD: The contest is over! I believe Alex_KPR will write about the contest and the closing ceremony soon. Thank you for participation and your interest. Here are the complete standings.Congrats to the winners. The top-3 is: sevenkplus (Yuzhou Gu) China s-quark (Qinshi Wang) China tourist (Gennady Korotkevich) Belarus UPD: As you have already noticed, the 16th July at 19:00 will start an unofficial online-version of the VK Cup 2012 Finals. Anyone can participate and feel himself as a finalist. Round will be unrated. If you already took part in the Finals or familiar with the problems, please refrain from participation. All problems will appear in the archive and will be available to everyone.",
          "author": "MikeMirzayanov",
          "url": "https://codeforces.com/blog/entry/4885",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1203
        }
      ],
      "code_examples": [],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 1000000, \"n\");\n    inf.readEoln();\n    vector<int> a = inf.readInts(n, 1, 1000000000, \"a_i\");\n    inf.readEoln();\n    int m = inf.readInt(1, 1000000, \"m\");\n    inf.readEoln();\n    vector<int> k = inf.readInts(m, 1, n, \"k_i\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 1000000, \"n\");\n    inf.readEoln();\n    vector<int> a = inf.readInts(n, 1, 1000000000, \"a_i\");\n    inf.readEoln();\n    int m = inf.readInt(1, 1000000, \"m\");\n    inf.readEoln();\n    vector<int> k = inf.readInts(m, 1, n, \"k_i\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 1000000, \"n\");\n    inf.readEoln();\n    vector<int> a = inf.readInts(n, 1, 1000000000, \"a_i\");\n    inf.readEoln();\n    int m = inf.readInt(1, 1000000, \"m\");\n    inf.readEoln();\n    vector<int> k = inf.readInts(m, 1, n, \"k_i\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nconst double EPS = 1E-9;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare two sequences of doubles, max absolute or relative error = %.10f\", EPS);\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    double j = 0, p = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        n++;\r\n        j = ans.readDouble();\r\n        p = ouf.readDouble();\r\n        if (!doubleCompare(j, p, EPS)) {\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%.10f', found: '%.10f', error = '%.10f'\",\r\n                  n, englishEnding(n).c_str(), j, p, doubleDelta(j, p));\r\n        }\r\n    }\r\n\r\n    if (n == 1)\r\n        quitf(_ok, \"found '%.10f', expected '%.10f', error '%.10f'\", p, j, doubleDelta(j, p));\r\n\r\n    quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    \n    int n = opt<int>(\"n\");\n    string ai_type = opt<string>(\"ai_type\", \"random\");\n    int m = opt<int>(\"m\");\n    string ki_type = opt<string>(\"ki_type\", \"random\");\n\n    vector<int> a(n);\n    if (ai_type == \"constant\") {\n        int val = opt<int>(\"val\", 1);\n        for (int i = 0; i < n; ++i)\n            a[i] = val;\n    } else if (ai_type == \"increasing\") {\n        int start = opt<int>(\"start\", 1);\n        for (int i = 0; i < n; ++i)\n            a[i] = start + i;\n    } else if (ai_type == \"decreasing\") {\n        int start = opt<int>(\"start\", n);\n        for (int i = 0; i < n; ++i)\n            a[i] = start - i;\n    } else if (ai_type == \"max\") {\n        for (int i = 0; i < n; ++i)\n            a[i] = 1000000000;\n    } else if (ai_type == \"min\") {\n        for (int i = 0; i < n; ++i)\n            a[i] = 1;\n    } else if (ai_type == \"random\") {\n        int min_val = opt<int>(\"min_val\", 1);\n        int max_val = opt<int>(\"max_val\", 1000000000);\n        for (int i = 0; i < n; ++i)\n            a[i] = rnd.next(min_val, max_val);\n    } else if (ai_type == \"alternate\") {\n        int val1 = opt<int>(\"val1\", 1);\n        int val2 = opt<int>(\"val2\", 1000000000);\n        for (int i = 0; i < n; ++i)\n            a[i] = (i % 2 == 0) ? val1 : val2;\n    } else if (ai_type == \"small_random\") {\n        int max_val = opt<int>(\"max_val\", 10);\n        for (int i = 0; i < n; ++i)\n            a[i] = rnd.next(1, max_val);\n    } else {\n        // Default to random\n        for (int i = 0; i < n; ++i)\n            a[i] = rnd.next(1, 1000000000);\n    }\n\n    vector<int> k(m);\n    if (ki_type == \"constant\") {\n        int val = opt<int>(\"k_val\", 1);\n        for (int i = 0; i < m; ++i)\n            k[i] = val;\n    } else if (ki_type == \"min\") {\n        for (int i = 0; i < m; ++i)\n            k[i] = 1;\n    } else if (ki_type == \"max\") {\n        for (int i = 0; i < m; ++i)\n            k[i] = n;\n    } else if (ki_type == \"random\") {\n        int min_k = opt<int>(\"min_k\", 1);\n        int max_k = opt<int>(\"max_k\", n);\n        for (int i = 0; i < m; ++i)\n            k[i] = rnd.next(min_k, max_k);\n    } else if (ki_type == \"sequential\") {\n        for (int i = 0; i < m; ++i)\n            k[i] = (i % n) + 1;\n    } else if (ki_type == \"repetition\") {\n        int val = opt<int>(\"k_val\", n / 2);\n        for (int i = 0; i < m; ++i)\n            k[i] = val;\n    } else if (ki_type == \"random_large\") {\n        int min_k = opt<int>(\"min_k\", n / 2);\n        int max_k = n;\n        for (int i = 0; i < m; ++i)\n            k[i] = rnd.next(min_k, max_k);\n    } else if (ki_type == \"random_small\") {\n        int min_k = 1;\n        int max_k = opt<int>(\"max_k\", n / 2);\n        for (int i = 0; i < m; ++i)\n            k[i] = rnd.next(min_k, max_k);\n    } else {\n        // Default to random\n        for (int i = 0; i < m; ++i)\n            k[i] = rnd.next(1, n);\n    }\n\n    printf(\"%d\\n\", n);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d%c\", a[i], i == n - 1 ? '\\n' : ' ');\n    }\n\n    printf(\"%d\\n\", m);\n    for (int i = 0; i < m; ++i) {\n        printf(\"%d%c\", k[i], i == m - 1 ? '\\n' : ' ');\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    \n    int n = opt<int>(\"n\");\n    string ai_type = opt<string>(\"ai_type\", \"random\");\n    int m = opt<int>(\"m\");\n    string ki_type = opt<string>(\"ki_type\", \"random\");\n\n    vector<int> a(n);\n    if (ai_type == \"constant\") {\n        int val = opt<int>(\"val\", 1);\n        for (int i = 0; i < n; ++i)\n            a[i] = val;\n    } else if (ai_type == \"increasing\") {\n        int start = opt<int>(\"start\", 1);\n        for (int i = 0; i < n; ++i)\n            a[i] = start + i;\n    } else if (ai_type == \"decreasing\") {\n        int start = opt<int>(\"start\", n);\n        for (int i = 0; i < n; ++i)\n            a[i] = start - i;\n    } else if (ai_type == \"max\") {\n        for (int i = 0; i < n; ++i)\n            a[i] = 1000000000;\n    } else if (ai_type == \"min\") {\n        for (int i = 0; i < n; ++i)\n            a[i] = 1;\n    } else if (ai_type == \"random\") {\n        int min_val = opt<int>(\"min_val\", 1);\n        int max_val = opt<int>(\"max_val\", 1000000000);\n        for (int i = 0; i < n; ++i)\n            a[i] = rnd.next(min_val, max_val);\n    } else if (ai_type == \"alternate\") {\n        int val1 = opt<int>(\"val1\", 1);\n        int val2 = opt<int>(\"val2\", 1000000000);\n        for (int i = 0; i < n; ++i)\n            a[i] = (i % 2 == 0) ? val1 : val2;\n    } else if (ai_type == \"small_random\") {\n        int max_val = opt<int>(\"max_val\", 10);\n        for (int i = 0; i < n; ++i)\n            a[i] = rnd.next(1, max_val);\n    } else {\n        // Default to random\n        for (int i = 0; i < n; ++i)\n            a[i] = rnd.next(1, 1000000000);\n    }\n\n    vector<int> k(m);\n    if (ki_type == \"constant\") {\n        int val = opt<int>(\"k_val\", 1);\n        for (int i = 0; i < m; ++i)\n            k[i] = val;\n    } else if (ki_type == \"min\") {\n        for (int i = 0; i < m; ++i)\n            k[i] = 1;\n    } else if (ki_type == \"max\") {\n        for (int i = 0; i < m; ++i)\n            k[i] = n;\n    } else if (ki_type == \"random\") {\n        int min_k = opt<int>(\"min_k\", 1);\n        int max_k = opt<int>(\"max_k\", n);\n        for (int i = 0; i < m; ++i)\n            k[i] = rnd.next(min_k, max_k);\n    } else if (ki_type == \"sequential\") {\n        for (int i = 0; i < m; ++i)\n            k[i] = (i % n) + 1;\n    } else if (ki_type == \"repetition\") {\n        int val = opt<int>(\"k_val\", n / 2);\n        for (int i = 0; i < m; ++i)\n            k[i] = val;\n    } else if (ki_type == \"random_large\") {\n        int min_k = opt<int>(\"min_k\", n / 2);\n        int max_k = n;\n        for (int i = 0; i < m; ++i)\n            k[i] = rnd.next(min_k, max_k);\n    } else if (ki_type == \"random_small\") {\n        int min_k = 1;\n        int max_k = opt<int>(\"max_k\", n / 2);\n        for (int i = 0; i < m; ++i)\n            k[i] = rnd.next(min_k, max_k);\n    } else {\n        // Default to random\n        for (int i = 0; i < m; ++i)\n            k[i] = rnd.next(1, n);\n    }\n\n    printf(\"%d\\n\", n);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d%c\", a[i], i == n - 1 ? '\\n' : ' ');\n    }\n\n    printf(\"%d\\n\", m);\n    for (int i = 0; i < m; ++i) {\n        printf(\"%d%c\", k[i], i == m - 1 ? '\\n' : ' ');\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -ai_type constant -val 1 -m 1 -ki_type constant -k_val 1\n./gen -n 2 -ai_type increasing -m 2 -ki_type min\n./gen -n 2 -ai_type decreasing -m 2 -ki_type max\n./gen -n 3 -ai_type constant -val 1000000000 -m 3 -ki_type sequential\n./gen -n 10 -ai_type random -min_val 1 -max_val 100 -m 5 -ki_type random\n./gen -n 50 -ai_type min -m 10 -ki_type random\n./gen -n 100 -ai_type max -m 100 -ki_type random\n./gen -n 1000 -ai_type alternate -val1 1 -val2 1000000000 -m 1000 -ki_type random\n./gen -n 1000 -ai_type small_random -max_val 10 -m 1000 -ki_type random_small -max_k 100\n./gen -n 5000 -ai_type increasing -m 5000 -ki_type sequential\n./gen -n 5000 -ai_type decreasing -m 5000 -ki_type sequential\n./gen -n 10000 -ai_type random -min_val 1 -max_val 1000000000 -m 10000 -ki_type random\n./gen -n 100000 -ai_type constant -val 1 -m 1 -ki_type constant -k_val 1\n./gen -n 100000 -ai_type constant -val 1000000000 -m 1 -ki_type constant -k_val 1\n./gen -n 100000 -ai_type max -m 1 -ki_type constant -k_val 100000\n./gen -n 100000 -ai_type min -m 1 -ki_type constant -k_val 100000\n./gen -n 100000 -ai_type random -min_val 1 -max_val 1000000 -m 1000 -ki_type random_large -min_k 50000\n./gen -n 100000 -ai_type random -min_val 1 -max_val 1000000000 -m 1000 -ki_type random_small -max_k 100\n./gen -n 100000 -ai_type random -min_val 1000000000 -max_val 1000000000 -m 1000 -ki_type random\n./gen -n 1000000 -ai_type max -m 1 -ki_type constant -k_val 1\n./gen -n 1000000 -ai_type min -m 1 -ki_type constant -k_val 1\n./gen -n 1000000 -ai_type random -min_val 1 -max_val 1000000000 -m 1000000 -ki_type random\n./gen -n 1000000 -ai_type small_random -max_val 10 -m 1000000 -ki_type random\n./gen -n 1000000 -ai_type alternate -val1 1 -val2 1000000000 -m 1000000 -ki_type random\n./gen -n 1000000 -ai_type increasing -m 1000000 -ki_type random\n./gen -n 1000000 -ai_type decreasing -m 1000000 -ki_type random\n./gen -n 1000000 -ai_type random -min_val 1 -max_val 1000000000 -m 1000000 -ki_type min\n./gen -n 1000000 -ai_type random -min_val 1 -max_val 1000000000 -m 1000000 -ki_type max\n./gen -n 1000000 -ai_type random -min_val 1 -max_val 1000000000 -m 1000000 -ki_type constant -k_val 1\n./gen -n 1000000 -ai_type random -min_val 1 -max_val 1000000000 -m 1 -ki_type constant -k_val 1\n./gen -n 1000000 -ai_type random -min_val 1 -max_val 1000000000 -m 1 -ki_type constant -k_val 1000000\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T19:49:25.484507",
        "total_tutorials": 1,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "212/E",
      "title": "E. IT Restaurants",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1.5 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first input line contains integer n (3 ≤ n ≤ 5000) — the number of junctions in the city. Next n - 1 lines list all roads one per line. Each road is given as a pair of integers xi, yi (1 ≤ xi, yi ≤ n) — the indexes of connected junctions. Consider the junctions indexed from 1 to n.It is guaranteed that the given road network is represented by an undirected tree with n vertexes.",
      "output_spec": "OutputPrint on the first line integer z — the number of sought pairs. Then print all sought pairs (a, b) in the order of increasing of the first component a.",
      "sample_tests": "ExamplesInputCopy51 22 33 44 5OutputCopy31 32 23 1InputCopy101 22 33 45 66 77 48 99 1010 4OutputCopy61 82 73 66 37 28 1",
      "description": "E. IT Restaurants\n\ntime limit per test1.5 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first input line contains integer n (3 ≤ n ≤ 5000) — the number of junctions in the city. Next n - 1 lines list all roads one per line. Each road is given as a pair of integers xi, yi (1 ≤ xi, yi ≤ n) — the indexes of connected junctions. Consider the junctions indexed from 1 to n.It is guaranteed that the given road network is represented by an undirected tree with n vertexes.\n\nOutputPrint on the first line integer z — the number of sought pairs. Then print all sought pairs (a, b) in the order of increasing of the first component a.\n\nInputCopy51 22 33 44 5OutputCopy31 32 23 1InputCopy101 22 33 45 66 77 48 99 1010 4OutputCopy61 82 73 66 37 28 1\n\nInputCopy51 22 33 44 5\n\nOutputCopy31 32 23 1\n\nInputCopy101 22 33 45 66 77 48 99 1010 4\n\nOutputCopy61 82 73 66 37 28 1\n\nNoteThe figure below shows the answers to the first test case. The junctions with \"iMac D0naldz\" restaurants are marked red and \"Burger Bing\" restaurants are marked blue.",
      "solutions": [
        {
          "title": "VK Cup 2012 — Финал! - Codeforces",
          "content": "Today is the main VK Cup event: VK Cup 2012 Finals! Good luck to all participants. And to those who don't participate — enjoy the interesting competition. VK CEO Pavel Durov announced the upgrade of a prize fund in the greeting speech at the finals' opening! I'm starting to really regret that I am not a participant.The participants compete for: 1st place — $30000 2nd place — $20000 3rd place — $10000 4-5 places — $2000 6-10 places — $1000 Good luck! Wish you only positive emotions. Ready! Steady!...UPD: The contest is over! I believe Alex_KPR will write about the contest and the closing ceremony soon. Thank you for participation and your interest. Here are the complete standings.Congrats to the winners. The top-3 is: sevenkplus (Yuzhou Gu) China s-quark (Qinshi Wang) China tourist (Gennady Korotkevich) Belarus UPD: As you have already noticed, the 16th July at 19:00 will start an unofficial online-version of the VK Cup 2012 Finals. Anyone can participate and feel himself as a finalist. Round will be unrated. If you already took part in the Finals or familiar with the problems, please refrain from participation. All problems will appear in the archive and will be available to everyone.",
          "author": "MikeMirzayanov",
          "url": "https://codeforces.com/blog/entry/4885",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1203
        }
      ],
      "code_examples": [],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAXN = 5000 + 5;\n\nint parent[MAXN];\n\nint find(int x) {\n    if (parent[x] != x)\n        parent[x] = find(parent[x]); // path compression\n    return parent[x];\n}\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(3, 5000, \"n\");\n    inf.readEoln();\n\n    for (int i = 1; i <= n; ++i) {\n        parent[i] = i;\n    }\n\n    int components = n;\n\n    for (int i = 0; i < n - 1; ++i) {\n        int x = inf.readInt(1, n, \"x_i\");\n        inf.readSpace();\n        int y = inf.readInt(1, n, \"y_i\");\n        inf.readEoln();\n\n        int px = find(x);\n        int py = find(y);\n        if (px == py) {\n            ensuref(false, \"Graph contains a cycle when adding edge between nodes %d and %d\", x, y);\n        }\n        else {\n            parent[px] = py;\n            components -= 1;\n        }\n    }\n\n    ensuref(components == 1, \"Graph is not connected\");\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAXN = 5000 + 5;\n\nint parent[MAXN];\n\nint find(int x) {\n    if (parent[x] != x)\n        parent[x] = find(parent[x]); // path compression\n    return parent[x];\n}\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(3, 5000, \"n\");\n    inf.readEoln();\n\n    for (int i = 1; i <= n; ++i) {\n        parent[i] = i;\n    }\n\n    int components = n;\n\n    for (int i = 0; i < n - 1; ++i) {\n        int x = inf.readInt(1, n, \"x_i\");\n        inf.readSpace();\n        int y = inf.readInt(1, n, \"y_i\");\n        inf.readEoln();\n\n        int px = find(x);\n        int py = find(y);\n        if (px == py) {\n            ensuref(false, \"Graph contains a cycle when adding edge between nodes %d and %d\", x, y);\n        }\n        else {\n            parent[px] = py;\n            components -= 1;\n        }\n    }\n\n    ensuref(components == 1, \"Graph is not connected\");\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAXN = 5000 + 5;\n\nint parent[MAXN];\n\nint find(int x) {\n    if (parent[x] != x)\n        parent[x] = find(parent[x]); // path compression\n    return parent[x];\n}\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(3, 5000, \"n\");\n    inf.readEoln();\n\n    for (int i = 1; i <= n; ++i) {\n        parent[i] = i;\n    }\n\n    int components = n;\n\n    for (int i = 0; i < n - 1; ++i) {\n        int x = inf.readInt(1, n, \"x_i\");\n        inf.readSpace();\n        int y = inf.readInt(1, n, \"y_i\");\n        inf.readEoln();\n\n        int px = find(x);\n        int py = find(y);\n        if (px == py) {\n            ensuref(false, \"Graph contains a cycle when adding edge between nodes %d and %d\", x, y);\n        }\n        else {\n            parent[px] = py;\n            components -= 1;\n        }\n    }\n\n    ensuref(components == 1, \"Graph is not connected\");\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    \n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n    \n    vector<pair<int,int>> edges;\n    \n    if (type == \"chain\") {\n        // Generate a chain\n        for(int i = 2; i <= n; ++i)\n            edges.push_back({i-1, i});\n    } else if (type == \"star\") {\n        // Generate a star\n        for(int i = 2; i <= n; ++i)\n            edges.push_back({1, i});\n    } else if (type == \"binary\") {\n        // Generate a balanced binary tree\n        vector<int> parent(n+1);\n        int next_node = 2;\n        queue<int> q;\n        q.push(1);\n        while(next_node <= n && !q.empty()) {\n            int u = q.front();\n            q.pop();\n            for(int i = 0; i < 2 && next_node <= n; ++i) {\n                edges.push_back({u, next_node});\n                q.push(next_node);\n                ++next_node;\n            }\n        }\n    } else if (type == \"skewed\") {\n        // Generate a skewed tree (like a right-skewed tree)\n        for(int i = 2; i <= n; ++i)\n            edges.push_back({i-1, i});\n    } else if (type == \"random\") {\n        // Generate a random tree\n        for(int i = 2; i <= n; ++i) {\n            int parent = rnd.next(1, i-1);\n            edges.push_back({parent, i});\n        }\n        // Shuffle nodes\n        vector<int> perm(n+1);\n        for(int i = 1; i <= n; ++i)\n            perm[i] = i;\n        shuffle(perm.begin()+1, perm.end());\n        for(auto &edge : edges) {\n            edge.first = perm[edge.first];\n            edge.second = perm[edge.second];\n        }\n        // Shuffle edges\n        shuffle(edges.begin(), edges.end());\n    } else {\n        cerr << \"Unknown type\\n\";\n        return 1;\n    }\n    // Output n\n    printf(\"%d\\n\", n);\n    // Output edges\n    for(auto &e : edges)\n        printf(\"%d %d\\n\", e.first, e.second);\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    \n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n    \n    vector<pair<int,int>> edges;\n    \n    if (type == \"chain\") {\n        // Generate a chain\n        for(int i = 2; i <= n; ++i)\n            edges.push_back({i-1, i});\n    } else if (type == \"star\") {\n        // Generate a star\n        for(int i = 2; i <= n; ++i)\n            edges.push_back({1, i});\n    } else if (type == \"binary\") {\n        // Generate a balanced binary tree\n        vector<int> parent(n+1);\n        int next_node = 2;\n        queue<int> q;\n        q.push(1);\n        while(next_node <= n && !q.empty()) {\n            int u = q.front();\n            q.pop();\n            for(int i = 0; i < 2 && next_node <= n; ++i) {\n                edges.push_back({u, next_node});\n                q.push(next_node);\n                ++next_node;\n            }\n        }\n    } else if (type == \"skewed\") {\n        // Generate a skewed tree (like a right-skewed tree)\n        for(int i = 2; i <= n; ++i)\n            edges.push_back({i-1, i});\n    } else if (type == \"random\") {\n        // Generate a random tree\n        for(int i = 2; i <= n; ++i) {\n            int parent = rnd.next(1, i-1);\n            edges.push_back({parent, i});\n        }\n        // Shuffle nodes\n        vector<int> perm(n+1);\n        for(int i = 1; i <= n; ++i)\n            perm[i] = i;\n        shuffle(perm.begin()+1, perm.end());\n        for(auto &edge : edges) {\n            edge.first = perm[edge.first];\n            edge.second = perm[edge.second];\n        }\n        // Shuffle edges\n        shuffle(edges.begin(), edges.end());\n    } else {\n        cerr << \"Unknown type\\n\";\n        return 1;\n    }\n    // Output n\n    printf(\"%d\\n\", n);\n    // Output edges\n    for(auto &e : edges)\n        printf(\"%d %d\\n\", e.first, e.second);\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 3 -type chain\n./gen -n 3 -type star\n./gen -n 3 -type binary\n./gen -n 3 -type skewed\n./gen -n 3 -type random\n\n./gen -n 10 -type chain\n./gen -n 10 -type star\n./gen -n 10 -type binary\n./gen -n 10 -type skewed\n./gen -n 10 -type random\n\n./gen -n 100 -type chain\n./gen -n 100 -type star\n./gen -n 100 -type binary\n./gen -n 100 -type skewed\n./gen -n 100 -type random\n\n./gen -n 5000 -type chain\n./gen -n 5000 -type star\n./gen -n 5000 -type binary\n./gen -n 5000 -type skewed\n./gen -n 5000 -type random\n\n./gen -n 2500 -type chain\n./gen -n 2500 -type star\n./gen -n 2500 -type binary\n./gen -n 2500 -type skewed\n./gen -n 2500 -type random\n\n./gen -n 4999 -type random\n./gen -n 4 -type star\n./gen -n 4 -type skewed\n\n# Generate additional random trees of maximum size\n./gen -n 5000 -type random\n./gen -n 5000 -type random\n./gen -n 5000 -type random\n./gen -n 5000 -type random\n./gen -n 5000 -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T19:49:27.458354",
        "total_tutorials": 1,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "213/A",
      "title": "A. Game",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains integer n (1 ≤ n ≤ 200) — the number of game parts. The next line contains n integers, the i-th integer — ci (1 ≤ ci ≤ 3) represents the number of the computer, on which you can complete the game part number i. Next n lines contain descriptions of game parts. The i-th line first contains integer ki (0 ≤ ki ≤ n - 1), then ki distinct integers ai, j (1 ≤ ai, j ≤ n; ai, j ≠ i) — the numbers of parts to complete before part i.Numbers on all lines are separated by single spaces. You can assume that the parts of the game are numbered from 1 to n in some way. It is guaranteed that there are no cyclic dependencies between the parts of the game.",
      "output_spec": "OutputOn a single line print the answer to the problem.",
      "sample_tests": "ExamplesInputCopy110OutputCopy1InputCopy52 2 1 1 31 52 5 12 5 41 50OutputCopy7",
      "description": "time limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains integer n (1 ≤ n ≤ 200) — the number of game parts. The next line contains n integers, the i-th integer — ci (1 ≤ ci ≤ 3) represents the number of the computer, on which you can complete the game part number i. Next n lines contain descriptions of game parts. The i-th line first contains integer ki (0 ≤ ki ≤ n - 1), then ki distinct integers ai, j (1 ≤ ai, j ≤ n; ai, j ≠ i) — the numbers of parts to complete before part i.Numbers on all lines are separated by single spaces. You can assume that the parts of the game are numbered from 1 to n in some way. It is guaranteed that there are no cyclic dependencies between the parts of the game.\n\nOutputOn a single line print the answer to the problem.\n\nInputCopy110OutputCopy1InputCopy52 2 1 1 31 52 5 12 5 41 50OutputCopy7\n\nInputCopy110\n\nOutputCopy1\n\nInputCopy52 2 1 1 31 52 5 12 5 41 50\n\nOutputCopy7\n\nNoteNote to the second sample: before the beginning of the game the best strategy is to stand by the third computer. First we complete part 5. Then we go to the 1-st computer and complete parts 3 and 4. Then we go to the 2-nd computer and complete parts 1 and 2. In total we get 1+1+2+1+2, which equals 7 hours.",
      "solutions": [
        {
          "title": "Codeforces Round #131 - Codeforces",
          "content": "Hello everybody!Welcome all to Codeforces Round #131, which will be held on Monday, 30th of July at 19:30 MSK. I am (Sergey Nagin) an author of the problems. This will be my First Codeforces round and I hope it won't be the last one :).I would like to thank Mike Mirzayanov(MikeMirzayanov) who made this contest possible, Roman Furko(Furko) and Gerald Agapov(Gerald) for helping to prepare this round and Maria Belova(Delinur) for the translation of problem statements into English. I hope that problems will be interesting for you.Good luck!Problems’ point values in Division 1 are 1000-1000-1500-2000-2500. Problems’ point values in Division 2 are 500-1000-2000-2000-2500.I strongly recommend you to read ALL the problems.The contest is over! Congratulations' to winners!First division:1 place: Egor2 place: Petr3 place: touristSecond division:1 place: antimatter2 place: c1753533 place: takaramono I hope, that problems were interesting for you.You can view tutorial. Some personal information. This year I finished school and I will go to university. I study programming during almost five years. In addition to computer science, I like sports: powerlifting, arm wrestling and swimming.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/4965",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1190
        },
        {
          "title": "Codeforces Round #131 Tutorial - Codeforces",
          "content": "Sorry for my poor English, this blog will be corrected soon.214A - System of EquationsSolution for this problem — just go through the possible pairs of numbers and check them for correctness. We can do that in any way. 214B - HometaskNuber is divisible by 2,3,5 only if sum of the digits is divisible by 3 and last digit is 0, so if we havent 0 in our set answer is -1, otherwise solution exists(we can return 0 as solution). A further solution — analysis of the cases.Lets sort all didgits in nonincreasing order. If sum of all digits is divisible by 3 — answer is our set of digits(without spaces ofcourse :) ). If modulo equals 1 — we must delete minimum digit from out set with modulo after division by 3 equals 1, if we haven't such we must delete 2 minimal digits with modulo after division by 3 equals 2. If we have modulo equals 2 — we have identical case.Also we must remember that we cannot use leading zeros. In case when we have more then one 0 and no another digit we must print only one zero.213A - GameSolution — Greedy.Lets our computers settled on circle, and moves (1->2, 2->3, 3->1) will be steps \"forward\", and moves (1->3,3->2,2->1) will steps \"back\". Note that \"back\" moves is not optimal, as we can make two moves \"forward\" that is identical in time. We will look over all starts. Further, we will go by circle while we not complited all game. For every level we will remember number ne[i] — count of another level that \"direct\" need for it. We will complited levels with ne[i]=0 and update all ne[i] that we must. It can be implemented with O(n^3) time.213B - NumbersSolution — dynamic programming.Look over for length of the number that we will build. Further, we will use DP f(len,i) — how many numbers with length len we can make with digits i..9.Recount:- f(len,0) = sum(f(len-i,1)*C(len-1,i), i=a[0]..len);- f(len,j) = sum(f(len-i,j+1)*C(len,i), i=a[j]..len), 0<j<9;- f(len,9) = 1, если len>=a[9], 0 если len<a[9].C(n,k) — binomial coefficient.213C - Relay RaceSolution — dynamic programming.Note, that we can make 2 pathes form cell (1,1) to cell (n,n).Note, that after each move our cells will be located on the same diagonal.We will solve the problem with DP f(d,i1,i2), d — diagonal number, i1 — 1st coordinate 1st path, i2 — 1st coordinate 2nd path. It is clear that we can calculate 2nd coordinate when we know number of the diagonal and 1st coordinate. Recount — obvious, we make all 4 transition, and if pathes are intersected in temporary point, we add value of the cell only one, otherwise we add both values of the cells. We can imlement this solution with O(n^2) memory if we will rewrite array of DP after increasing of diagonal number. Also we must remember that answer can be lower then 0. 213D - StarsI present solution as few pictures:https://get.google.com/albumarchive/pwa/115317317397602031319/Solutions131Implementation.We have only one difficult moment — how to count coordinates? We can calculate them from regular pentagon, all that you need, you can read there.213E - Two PermutationsFor given two permutation we will make two another by next transformation: New_A[A[i]] = i, where New_A — news permutation, A — given permutation. Lets we get two permutation A and B. Now our problem is next: how many sub-arrays of length n are equals to firs permutation. Two arrays will be equal if after swaping every element with its number in sorted array obtained arrays will be element-wise equal.Further solution hashes, but we will use not only modulo 2^64, we will use some big modulos, but they must be smaller then 2^32-1.Lets step[i] = 1000003^i.Lets F(A) = num[1]*step[1] + num[2]*step[2] + ... + num[n]*step[n], where num[i] — number of the element A[i] in sorted array.If we will compare arrays, we can use this function. But it can be very big, so we will count it by modulos.So now our problem is to calculate F function to every subarray. Lets look what will change after adding/deleting some elent from set: some element from num array willnot change, and some will become grater after adding, and become lower after deleting. So we must use some interval-tree to recount our F function. We need to know sum of step[i] on some interval of added numbers and count of elements on some interval. Uses this information we can simply recount out function. Also we must remember that after adding element with coeficinet step[i], where i>n and deleting some previos element our function will become grater that we need. So we will multiple hash of first array by 1000003 to avoid this issue.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/4982",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 213\\s*A"
          },
          "content_length": 4543
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #131 - Codeforces - Code 1",
          "code": "int n = 300;\nfprintf(stdout, \"%d\\n\", n);\nfor (int i = 0; i < n; i++)\n    for (int c = 0; c < n; c++)\n        fprintf(stdout, \"%d%c\", ((i + c == 580) ? -1 : 0), c + 1 == n ? '\\n' : ' ');",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4965",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #131 - Codeforces - Code 2",
          "code": "int n = 300;\nfprintf(stdout, \"%d\\n\", n);\nfor (int i = 0; i < n; i++)\n    for (int c = 0; c < n; c++)\n        fprintf(stdout, \"%d%c\", ((i + c == 580) ? -1 : 0), c + 1 == n ? '\\n' : ' ');",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4965",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #131 - Codeforces - Code 3",
          "code": "Comb[len - 1][j]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4965",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #131 Tutorial - Codeforces - Code 1",
          "code": "(a-b)(a+b-1)=n-m",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4982",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<vector<int>> adj;\nvector<int> color; // 0 - unvisited, 1 - visiting, 2 - visited\n\nvoid dfs(int u) {\n    color[u] = 1;\n    for (int v : adj[u]) {\n        if (color[v] == 1) {\n            // Found a cycle\n            ensuref(false, \"Cycle detected in dependencies\");\n        } else if (color[v] == 0) {\n            dfs(v);\n        }\n    }\n    color[u] = 2;\n}\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 200);\n    inf.readEoln();\n\n    vector<int> c(n);\n    c[0] = inf.readInt(1, 3);\n    for (int i = 1; i < n; ++i) {\n        inf.readSpace();\n        c[i] = inf.readInt(1, 3);\n    }\n    inf.readEoln();\n\n    adj.resize(n);\n\n    for (int i = 0; i < n; ++i) {\n        int ki = inf.readInt(0, n - 1);\n        set<int> deps;\n        if (ki == 0) {\n            inf.readEoln();\n        } else {\n            for (int j = 0; j < ki; ++j) {\n                inf.readSpace();\n                int aij = inf.readInt(1, n);\n                ensuref(aij != i + 1, \"Dependency cannot be equal to itself at line %d\", i + 3);\n                ensuref(deps.find(aij) == deps.end(), \"Duplicate dependency %d in line %d\", aij, i + 3);\n                deps.insert(aij);\n                adj[i].push_back(aij - 1);\n            }\n            inf.readEoln();\n        }\n    }\n\n    color.assign(n, 0);\n    for (int u = 0; u < n; ++u) {\n        if (color[u] == 0) {\n            dfs(u);\n        }\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<vector<int>> adj;\nvector<int> color; // 0 - unvisited, 1 - visiting, 2 - visited\n\nvoid dfs(int u) {\n    color[u] = 1;\n    for (int v : adj[u]) {\n        if (color[v] == 1) {\n            // Found a cycle\n            ensuref(false, \"Cycle detected in dependencies\");\n        } else if (color[v] == 0) {\n            dfs(v);\n        }\n    }\n    color[u] = 2;\n}\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 200);\n    inf.readEoln();\n\n    vector<int> c(n);\n    c[0] = inf.readInt(1, 3);\n    for (int i = 1; i < n; ++i) {\n        inf.readSpace();\n        c[i] = inf.readInt(1, 3);\n    }\n    inf.readEoln();\n\n    adj.resize(n);\n\n    for (int i = 0; i < n; ++i) {\n        int ki = inf.readInt(0, n - 1);\n        set<int> deps;\n        if (ki == 0) {\n            inf.readEoln();\n        } else {\n            for (int j = 0; j < ki; ++j) {\n                inf.readSpace();\n                int aij = inf.readInt(1, n);\n                ensuref(aij != i + 1, \"Dependency cannot be equal to itself at line %d\", i + 3);\n                ensuref(deps.find(aij) == deps.end(), \"Duplicate dependency %d in line %d\", aij, i + 3);\n                deps.insert(aij);\n                adj[i].push_back(aij - 1);\n            }\n            inf.readEoln();\n        }\n    }\n\n    color.assign(n, 0);\n    for (int u = 0; u < n; ++u) {\n        if (color[u] == 0) {\n            dfs(u);\n        }\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<vector<int>> adj;\nvector<int> color; // 0 - unvisited, 1 - visiting, 2 - visited\n\nvoid dfs(int u) {\n    color[u] = 1;\n    for (int v : adj[u]) {\n        if (color[v] == 1) {\n            // Found a cycle\n            ensuref(false, \"Cycle detected in dependencies\");\n        } else if (color[v] == 0) {\n            dfs(v);\n        }\n    }\n    color[u] = 2;\n}\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 200);\n    inf.readEoln();\n\n    vector<int> c(n);\n    c[0] = inf.readInt(1, 3);\n    for (int i = 1; i < n; ++i) {\n        inf.readSpace();\n        c[i] = inf.readInt(1, 3);\n    }\n    inf.readEoln();\n\n    adj.resize(n);\n\n    for (int i = 0; i < n; ++i) {\n        int ki = inf.readInt(0, n - 1);\n        set<int> deps;\n        if (ki == 0) {\n            inf.readEoln();\n        } else {\n            for (int j = 0; j < ki; ++j) {\n                inf.readSpace();\n                int aij = inf.readInt(1, n);\n                ensuref(aij != i + 1, \"Dependency cannot be equal to itself at line %d\", i + 3);\n                ensuref(deps.find(aij) == deps.end(), \"Duplicate dependency %d in line %d\", aij, i + 3);\n                deps.insert(aij);\n                adj[i].push_back(aij - 1);\n            }\n            inf.readEoln();\n        }\n    }\n\n    color.assign(n, 0);\n    for (int u = 0; u < n; ++u) {\n        if (color[u] == 0) {\n            dfs(u);\n        }\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\n/*\n  This generator produces a single test case for the problem described.\n\n  Parameters (all optional except -n):\n    -n: number of parts (1 <= n <= 200).\n    -depType: type of dependency structure. Possible values:\n        \"none\"   => no dependencies.\n        \"chain\"  => forms a single chain: part i depends on part i-1.\n        \"star\"   => forms a single star: parts 2..n depend on part 1.\n        \"random\" => a random DAG (no cycles). (default)\n\n    -cType: distribution of computers for each part. Possible values:\n        \"all1\"   => all parts can only be done on computer 1.\n        \"all2\"   => all parts can only be done on computer 2.\n        \"all3\"   => all parts can only be done on computer 3.\n        \"random\" => each part can be on computer 1..3, chosen at random. (default)\n*/\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string depType = opt<string>(\"depType\", \"random\");\n    string cType = opt<string>(\"cType\", \"random\");\n\n    // 1) Generate c[i]: which computer each part i (1-based) must be completed on\n    vector<int> comp(n);\n    if (cType == \"all1\") {\n        for (int i = 0; i < n; i++) {\n            comp[i] = 1;\n        }\n    }\n    else if (cType == \"all2\") {\n        for (int i = 0; i < n; i++) {\n            comp[i] = 2;\n        }\n    }\n    else if (cType == \"all3\") {\n        for (int i = 0; i < n; i++) {\n            comp[i] = 3;\n        }\n    }\n    else {\n        // random c in [1..3]\n        for (int i = 0; i < n; i++) {\n            comp[i] = rnd.next(1, 3);\n        }\n    }\n\n    // 2) Generate dependencies in a DAG.\n    //    Each part i has some prerequisites. We'll store them in prereq[i].\n    //    Then we'll output them according to the problem format.\n    //    No cycles are allowed.\n\n    vector<vector<int>> prereq(n);\n\n    if (depType == \"none\") {\n        // no dependencies, so all parts have 0 prerequisites\n    }\n    else if (depType == \"chain\") {\n        // part i depends on part i-1 for i=2..n\n        // (1-based indexing in problem statement)\n        for (int i = 1; i < n; i++) {\n            prereq[i].push_back(i - 1); // i-th part depends on (i-1)-th\n        }\n    }\n    else if (depType == \"star\") {\n        // part 1 has no dependencies\n        // parts 2..n each depend on part 1\n        for (int i = 1; i < n; i++) {\n            prereq[i].push_back(0);\n        }\n    }\n    else {\n        // random: for each i, pick some subset of [0..i-1] to be prerequisites\n        // This ensures no cycle, because we only depend on earlier indices.\n        for (int i = 0; i < n; i++) {\n            int maxParents = i; // i can have up to i distinct prerequisites\n            // For variety, choose a random number in [0, i].\n            int k = rnd.next(0, maxParents);\n            // collect the range [0..i-1]\n            vector<int> possible;\n            for (int j = 0; j < i; j++) {\n                possible.push_back(j);\n            }\n            // shuffle and take the first k\n            shuffle(possible.begin(), possible.end());\n            prereq[i].insert(prereq[i].end(), possible.begin(), possible.begin() + k);\n        }\n    }\n\n    // 3) Output according to the problem format.\n    //    First line: n\n    //    Second line: c1, c2, ..., cn\n    //    Next n lines: for i in 1..n:\n    //        k_i  a_i,1  a_i,2 ... a_i,k_i\n    //    where a_i,j are the parts that must be completed before part i.\n\n    // NOTE: The problem states that parts are numbered 1..n. But internally\n    //       we've used 0..(n-1). We'll adjust the indices when printing.\n\n    cout << n << \"\\n\";\n    for (int i = 0; i < n; i++) {\n        cout << comp[i];\n        if (i + 1 < n) cout << \" \";\n    }\n    cout << \"\\n\";\n\n    // For each part i in 1..n, print the size of prerequisites and then the list\n    for (int i = 0; i < n; i++) {\n        // prereq[i] has zero-based indices. We must print them as 1-based.\n        cout << prereq[i].size();\n        for (int p : prereq[i]) {\n            cout << \" \" << (p + 1);\n        }\n        cout << \"\\n\";\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\n/*\n  This generator produces a single test case for the problem described.\n\n  Parameters (all optional except -n):\n    -n: number of parts (1 <= n <= 200).\n    -depType: type of dependency structure. Possible values:\n        \"none\"   => no dependencies.\n        \"chain\"  => forms a single chain: part i depends on part i-1.\n        \"star\"   => forms a single star: parts 2..n depend on part 1.\n        \"random\" => a random DAG (no cycles). (default)\n\n    -cType: distribution of computers for each part. Possible values:\n        \"all1\"   => all parts can only be done on computer 1.\n        \"all2\"   => all parts can only be done on computer 2.\n        \"all3\"   => all parts can only be done on computer 3.\n        \"random\" => each part can be on computer 1..3, chosen at random. (default)\n*/\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string depType = opt<string>(\"depType\", \"random\");\n    string cType = opt<string>(\"cType\", \"random\");\n\n    // 1) Generate c[i]: which computer each part i (1-based) must be completed on\n    vector<int> comp(n);\n    if (cType == \"all1\") {\n        for (int i = 0; i < n; i++) {\n            comp[i] = 1;\n        }\n    }\n    else if (cType == \"all2\") {\n        for (int i = 0; i < n; i++) {\n            comp[i] = 2;\n        }\n    }\n    else if (cType == \"all3\") {\n        for (int i = 0; i < n; i++) {\n            comp[i] = 3;\n        }\n    }\n    else {\n        // random c in [1..3]\n        for (int i = 0; i < n; i++) {\n            comp[i] = rnd.next(1, 3);\n        }\n    }\n\n    // 2) Generate dependencies in a DAG.\n    //    Each part i has some prerequisites. We'll store them in prereq[i].\n    //    Then we'll output them according to the problem format.\n    //    No cycles are allowed.\n\n    vector<vector<int>> prereq(n);\n\n    if (depType == \"none\") {\n        // no dependencies, so all parts have 0 prerequisites\n    }\n    else if (depType == \"chain\") {\n        // part i depends on part i-1 for i=2..n\n        // (1-based indexing in problem statement)\n        for (int i = 1; i < n; i++) {\n            prereq[i].push_back(i - 1); // i-th part depends on (i-1)-th\n        }\n    }\n    else if (depType == \"star\") {\n        // part 1 has no dependencies\n        // parts 2..n each depend on part 1\n        for (int i = 1; i < n; i++) {\n            prereq[i].push_back(0);\n        }\n    }\n    else {\n        // random: for each i, pick some subset of [0..i-1] to be prerequisites\n        // This ensures no cycle, because we only depend on earlier indices.\n        for (int i = 0; i < n; i++) {\n            int maxParents = i; // i can have up to i distinct prerequisites\n            // For variety, choose a random number in [0, i].\n            int k = rnd.next(0, maxParents);\n            // collect the range [0..i-1]\n            vector<int> possible;\n            for (int j = 0; j < i; j++) {\n                possible.push_back(j);\n            }\n            // shuffle and take the first k\n            shuffle(possible.begin(), possible.end());\n            prereq[i].insert(prereq[i].end(), possible.begin(), possible.begin() + k);\n        }\n    }\n\n    // 3) Output according to the problem format.\n    //    First line: n\n    //    Second line: c1, c2, ..., cn\n    //    Next n lines: for i in 1..n:\n    //        k_i  a_i,1  a_i,2 ... a_i,k_i\n    //    where a_i,j are the parts that must be completed before part i.\n\n    // NOTE: The problem states that parts are numbered 1..n. But internally\n    //       we've used 0..(n-1). We'll adjust the indices when printing.\n\n    cout << n << \"\\n\";\n    for (int i = 0; i < n; i++) {\n        cout << comp[i];\n        if (i + 1 < n) cout << \" \";\n    }\n    cout << \"\\n\";\n\n    // For each part i in 1..n, print the size of prerequisites and then the list\n    for (int i = 0; i < n; i++) {\n        // prereq[i] has zero-based indices. We must print them as 1-based.\n        cout << prereq[i].size();\n        for (int p : prereq[i]) {\n            cout << \" \" << (p + 1);\n        }\n        cout << \"\\n\";\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Below are sample commands that run the above generator to produce\n# a variety of test cases covering edge and typical scenarios.\n\n# Smallest n, no dependencies, all on computer 1\n./gen -n 1 -depType none -cType all1\n\n# Smallest n, no dependencies, random computer\n./gen -n 1 -depType none -cType random\n\n# n=2, chain dependencies, all on computer 1\n./gen -n 2 -depType chain -cType all1\n\n# n=2, chain dependencies, all on computer 2\n./gen -n 2 -depType chain -cType all2\n\n# n=2, chain dependencies, all on computer 3\n./gen -n 2 -depType chain -cType all3\n\n# n=2, chain dependencies, random computer\n./gen -n 2 -depType chain -cType random\n\n# n=5, no dependencies, all on computer 1\n./gen -n 5 -depType none -cType all1\n\n# n=5, no dependencies, random computer\n./gen -n 5 -depType none -cType random\n\n# n=5, star dependencies, all on computer 3\n./gen -n 5 -depType star -cType all3\n\n# n=5, random dependencies, random computer\n./gen -n 5 -depType random -cType random\n\n# n=10, chain dependencies, all on computer 2\n./gen -n 10 -depType chain -cType all2\n\n# n=10, star dependencies, random computer\n./gen -n 10 -depType star -cType random\n\n# n=10, random dependencies, all on computer 1\n./gen -n 10 -depType random -cType all1\n\n# n=20, chain dependencies, random computer\n./gen -n 20 -depType chain -cType random\n\n# n=20, random dependencies, all on computer 3\n./gen -n 20 -depType random -cType all3\n\n# n=50, none dependencies, random computer\n./gen -n 50 -depType none -cType random\n\n# n=50, star dependencies, random computer\n./gen -n 50 -depType star -cType random\n\n# n=100, chain dependencies, all on computer 1\n./gen -n 100 -depType chain -cType all1\n\n# n=100, random dependencies, random computer\n./gen -n 100 -depType random -cType random\n\n# n=200, none dependencies, random computer\n./gen -n 200 -depType none -cType random\n\n# n=200, star dependencies, all on computer 2\n./gen -n 200 -depType star -cType all2\n\n# n=200, random dependencies, random computer\n./gen -n 200 -depType random -cType random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T19:49:29.527540",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "213/B",
      "title": "B. Числа",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест2 секунды",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеВ первой строке записано целое число n (1 ≤ n ≤ 100). В следующей строке записаны 10 целых чисел a[0], a[1], ..., a[9] (0 ≤ a[i] ≤ 100) — элементы массива a. Числа разделены пробельными символами.",
      "output_spec": "Выходные данныеВ единственной строке выведите остаток от деления ответа на задачу на 1000000007 (109 + 7).",
      "sample_tests": "ПримерыВходные данныеСкопировать10 0 0 0 0 0 0 0 0 1Выходные данныеСкопировать1Входные данныеСкопировать21 1 0 0 0 0 0 0 0 0Выходные данныеСкопировать1Входные данныеСкопировать31 1 0 0 0 0 0 0 0 0Выходные данныеСкопировать36",
      "description": "ограничение по времени на тест2 секунды\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвыводstdout\n\nВходные данныеВ первой строке записано целое число n (1 ≤ n ≤ 100). В следующей строке записаны 10 целых чисел a[0], a[1], ..., a[9] (0 ≤ a[i] ≤ 100) — элементы массива a. Числа разделены пробельными символами.\n\nВходные данные\n\nВыходные данныеВ единственной строке выведите остаток от деления ответа на задачу на 1000000007 (109 + 7).\n\nВыходные данные\n\nВходные данныеСкопировать10 0 0 0 0 0 0 0 0 1Выходные данныеСкопировать1Входные данныеСкопировать21 1 0 0 0 0 0 0 0 0Выходные данныеСкопировать1Входные данныеСкопировать31 1 0 0 0 0 0 0 0 0Выходные данныеСкопировать36\n\nВходные данныеСкопировать10 0 0 0 0 0 0 0 0 1\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать1\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать21 1 0 0 0 0 0 0 0 0\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать1\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать31 1 0 0 0 0 0 0 0 0\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать36\n\nВыходные данныеСкопировать\n\nСкопировать\n\nПримечаниеВ первом примере подходит число 9.Во втором примере подходит число 10.В третьем примере подходят числа: 10, 110, 210, 120, 103. Есть и другие подходящие числа, всего их 36.",
      "solutions": [
        {
          "title": "Codeforces Round #131 - Codeforces",
          "content": "Всем привет!Сегодня, 30 июля в 19:30 MSK состоится Codeforces Round #131, автором которого являюсь я(Сергей Нагин). Это мой первый раунд на Codeforces и надеюсь, что не последний.Спасибо Фурко Роману(Furko) и Геральду Агапову(Gerald) за помощь в подготовке задач, а Марии Беловой(Delinur) за перевод условий. Также выражаю благодарность создателю Codeforces Михаилу Мирзаянову (MikeMirzayanov) за прекрасную систему.Удачи на раунде! Разбалловка в первом дивизионе: 1000-1000-1500-2000-2500. Разбалловка во втором дивизионе: 500-1000-2000-2000-2500. Настоятельно рекомендую прочитать условия ВСЕХ задач.Контест завершен! Поздравляю победителей!1й дивизион:1 место: Egor2 место: Petr3 место: tourist2й дивизион:1 место: antimatter2 место: c1753533 место: takaramono Надеюсь, задачи вам понравились. Разбор задач. Немного личной информации.В этом году я закончил школу и буду поступать в университет. Программированием занимаюсь почти 5 лет (с 7го класса). Помимо информатики, любительски увлекаюсь спортом: пауэрлифтинг, армрестлинг и плаванье.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/4965",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 1042
        },
        {
          "title": "Разбор задач Codeforces Round #131 - Codeforces",
          "content": "214A - Система уравненийВ данной задаче решение — просто перебрать возможные пары чисел и проверить их на правильность. Делать это можно было любым способом. 214B - Домашнее заданиеЧисло делится на 2,3,5 только в том случае, если сумма цифр кратна 3, а последняя цифра 0, то есть если в наборе нету нулей, то ответ -1. Дальнейшее решение — разбор случаев.Возьмем все цифры в невозрастающем порядке, если сумма цифр кратна 3, то это и есть ответ. Если остаток от деления вышел 1, то нужно убрать 1 цифру у которой остаток от деления на 3 равен 1. Если такой не нашли то нужно убрать 2 цифры с остатком 2. Аналогично рассматривается случай когда изначальный остаток равен 2. Так-же нужно рассмотреть случай когда остались только нули, в этом случае нужно вывести только 1 ноль. 213A - ИграРешение — жадность. Пусть у нас компьютеры стоят по кругу, и ходами \"вперед\" назовем перемещения (1->2, 2->3, 3->1), а перемещением \"назад\" (1->3,3->2,2->1). Заметим что ходить \"назад\" не выгодно, так как можно 2 раза походить \"вперед\", что в сумме равноценно. Будем перебирать стартовую вершину. Дальше будем ходить по кругу до тех пор, пока не \"откроем\" все уровни. В авторском решении для каждого уровня поддерживается количество уровней, которые нужны для него. После того как мы находим очередной 0 в этом списке, мы просто уменьшаем такую величину для всех уровней, которые от него непосредственно зависят. Сложность решения O(n^3). 213B - ЧислаРешение — динамика. Перебираем длину числа, которое будем строить. Далее будем пользоваться динамикой f(len,i) — сколько чисел диной len можно составить из цифр i..9.Пересчет:- f(len,0) = sum(f(len-i,1)*C(len-1,i), i=a[0]..len);- f(len,j) = sum(f(len-i,j+1)*C(len,i), i=a[j]..len), 0<j<9;- f(len,9) = 1, если len>=a[9], 0 если len<a[9].C(n,k) — количество способов выбрать k элементов из n.213C - ЭстафетаРешение — динамика.Заметим, что мы можем просто провести два пути их клетки (1,1) в клетку (n,n).Заметим, что после каждого шага клетки будут оставаться на одной диагонали. Будем решать задачу динамикой f(d,i1,i2), d — номер диагонали, i1 — 1я координата 1го маршрута, i2 — 1я координата 2го маршрута. Понятно что вторую координату мы можем определить однозначно. Переходы — очевидны, делаем 4 возможных перехода, если маршруты пересеклись, то добавляем величину клеточки один раз, иначе добавляем величины посещенных клеток. Так как данная динамика не влазит по памяти, то ее нужно делать двумерной, просто перенося значения из прошлой диагонали в новую.Еще нужно не забыть про то, что ответ может выйти отрицательным.213D - ЗвездыПредоставлю разбор как небольшую презентацию картинками:https://get.google.com/albumarchive/pwa/115317317397602031319/Solutions131Реализация.Единственную сложность могло составить определение координат, все координаты можно найти из правильного пятиугольника. Все что о нем нужно описано тут.213E - Две перестановкиПервый шаг: заменить перестановки на обратные, то есть из перестановки A мы делаем перестановку B, такую что B[A[i]] = i. Если посмотреть на то, что получилось, то выходит такая задача: сколько подотрезков второй перестановки равны первой, в случае если мы \"сожмем координаты\", то есть числам сопоставим их номер в отсортированном виде. Эту задачу предполагалась решать хэшами, но брать их нужно было не только по основанию 2^64, а и еще по нескольким простым модулям, тайм лимит специально стоял 3 секунды.Теперь, собственно, как ее решать: Для каждой позиции i — сопоставим коєфициент step[i], где step[i] = 1000003^i. Теперь Рассмотрим такую функцию: F(A) = num[1]*step[1] + num[2]*step[2] + num[3]*step[3] + ... + num[n]*step[n], где num[i] — порядковый номер элемента A[i] в отсортированном списке. Понято что эта функция однозначно задает множество, от нее и будем считать хэш.Как пересчитывать при переходе не следующий элемент.Заметим что когда мы убираем какой-то элемент, то все элементы которые больше его уменьшают значение num на единицу. Ровно как и после добавления они его увеличивают. То есть заведем Дерево отрезков/Фенвика для хранения таких величин как сумма степеней на отрезке и количество элементов на отрезку, что-бы за O(log(n)) находить величину num для числа и после каждого добавления/удаления будем пересчитывать хэш, тоже за O(log(n)). Так-же нужно будем умножать хэш на от первой перестановки на 1000003 после каждого смещения на 1 элемент вправо, так как коэффициенты step уже не будут идти от единицы. Все замечания просьба писать в комментарии.Через некоторое время постараюсь сделать формулы более красивыми.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/4982",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 213\\s*B"
          },
          "content_length": 4533
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #131 - Codeforces - Code 1",
          "code": "'Немного личной информации.\nВ этом году я закончил школу и буду поступать в университет. Программированием занимаюсь почти 5 лет (с 7го класса). Помимо информатики, любительски увлекаюсь спортом: пауэрлифтинг, армрестлинг и плаванье.'\nА я Никита, ...",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4965",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #131 - Codeforces - Code 2",
          "code": "'Немного личной информации.\nВ этом году я закончил школу и буду поступать в университет. Программированием занимаюсь почти 5 лет (с 7го класса). Помимо информатики, любительски увлекаюсь спортом: пауэрлифтинг, армрестлинг и плаванье.'\nА я Никита, ...",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4965",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #131 - Codeforces - Code 3",
          "code": "vector<>::erase",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4965",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #131 - Codeforces - Code 4",
          "code": "5\n4 32 1 18 41\n47 38 7 43 43\n48 23 39 40 23\n26 39 33 5 36\n31 29 7 26 47",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4965",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #131 - Codeforces - Code 5",
          "code": "5\n4 32 1 18 41\n47 38 7 43 43\n48 23 39 40 23\n26 39 33 5 36\n31 29 7 26 47",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4965",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #131 - Codeforces - Code 6",
          "code": "int n = 300;\nfprintf(stdout, \"%d\\n\", n);\nfor (int i = 0; i < n; i++)\n    for (int c = 0; c < n; c++)\n        fprintf(stdout, \"%d%c\", ((i + c == 580) ? -1 : 0), c + 1 == n ? '\\n' : ' ');",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4965",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #131 - Codeforces - Code 7",
          "code": "int n = 300;\nfprintf(stdout, \"%d\\n\", n);\nfor (int i = 0; i < n; i++)\n    for (int c = 0; c < n; c++)\n        fprintf(stdout, \"%d%c\", ((i + c == 580) ? -1 : 0), c + 1 == n ? '\\n' : ' ');",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4965",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #131 - Codeforces - Code 8",
          "code": "Comb[len - 1][j]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4965",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Codeforces Round #131 - Codeforces - Code 1",
          "code": "import java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tInputStream inputStream = System.in;\n\t\tOutputStream outputStream = System.out;\n\t\tPrintWriter out = new PrintWriter(outputStream);\n\t\tBadGen solver = new BadGen();\n\t\tsolver.solve(out);\n\t\tout.close();\n\t}\n}\n\nclass BadGen {\n\tpublic void solve(PrintWriter out) {\n        int n = 1 << 12;\n        int m = 1 << 17;\n        out.println(n + \" \" + m);\n        int[] pn = buildBadPerm(n);\n        for (int i = 0; i < n; ++i) {\n            if (i > 0) out.print(\" \");\n            out.print(pn[i] + 1);\n        }\n        out.println();\n        int[] pm = buildBadPerm(m);\n        for (int i = 0; i < m; ++i) {\n            if (i > 0) out.print(\" \");\n            out.print(pm[i] + 1);\n        }\n        out.println();\n    }\n\n    private int[] buildBadPerm(int n) {\n        int[] invs = new int[]{0};\n        while (invs.length < n) {\n            int[] ninvs = new int[2 * invs.length];\n            for (int i = 0; i < invs.length; ++i) {\n                ninvs[i] = invs[i];\n                ninvs[i + invs.length] = 1 - invs[i];\n            }\n            invs = ninvs;\n        }\n        int[] perm = new int[n];\n        for (int i = 0; i * 2 < n; ++i) {\n            if (invs[i * 2] == 0) {\n                perm[i * 2] = i * 2;\n                perm[i * 2 + 1] = i * 2 + 1;\n            } else {\n                perm[i * 2] = i * 2 + 1;\n                perm[i * 2 + 1] = i * 2;\n            }\n        }\n        return perm;\n    }\n}",
          "language": "Python",
          "source": "https://codeforces.com/blog/entry/4982",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Codeforces Round #131 - Codeforces - Code 2",
          "code": "import java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tInputStream inputStream = System.in;\n\t\tOutputStream outputStream = System.out;\n\t\tPrintWriter out = new PrintWriter(outputStream);\n\t\tBadGen solver = new BadGen();\n\t\tsolver.solve(out);\n\t\tout.close();\n\t}\n}\n\nclass BadGen {\n\tpublic void solve(PrintWriter out) {\n        int n = 1 << 12;\n        int m = 1 << 17;\n        out.println(n + \" \" + m);\n        int[] pn = buildBadPerm(n);\n        for (int i = 0; i < n; ++i) {\n            if (i > 0) out.print(\" \");\n            out.print(pn[i] + 1);\n        }\n        out.println();\n        int[] pm = buildBadPerm(m);\n        for (int i = 0; i < m; ++i) {\n            if (i > 0) out.print(\" \");\n            out.print(pm[i] + 1);\n        }\n        out.println();\n    }\n\n    private int[] buildBadPerm(int n) {\n        int[] invs = new int[]{0};\n        while (invs.length < n) {\n            int[] ninvs = new int[2 * invs.length];\n            for (int i = 0; i < invs.length; ++i) {\n                ninvs[i] = invs[i];\n                ninvs[i + invs.length] = 1 - invs[i];\n            }\n            invs = ninvs;\n        }\n        int[] perm = new int[n];\n        for (int i = 0; i * 2 < n; ++i) {\n            if (invs[i * 2] == 0) {\n                perm[i * 2] = i * 2;\n                perm[i * 2 + 1] = i * 2 + 1;\n            } else {\n                perm[i * 2] = i * 2 + 1;\n                perm[i * 2 + 1] = i * 2;\n            }\n        }\n        return perm;\n    }\n}",
          "language": "Python",
          "source": "https://codeforces.com/blog/entry/4982",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Codeforces Round #131 - Codeforces - Code 3",
          "code": "if(len >= a[9])\n    f(len, 9) = 1\nelse\n    f(len, 9) = 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4982",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Codeforces Round #131 - Codeforces - Code 4",
          "code": "if(len >= a[9])\n    f(len, 9) = 1\nelse\n    f(len, 9) = 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4982",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Codeforces Round #131 - Codeforces - Code 5",
          "code": "- f(len,j) = sum( f(len-i,1)*C(len,i), i=a[j]..len ), 0<j<9;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4982",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Codeforces Round #131 - Codeforces - Code 6",
          "code": "f(len-i,j+1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4982",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Codeforces Round #131 - Codeforces - Code 7",
          "code": "3\n99 99 98\n98 99 99\n11 98 99",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4982",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Codeforces Round #131 - Codeforces - Code 8",
          "code": "3\n99 99 98\n98 99 99\n11 98 99",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4982",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Codeforces Round #131 - Codeforces - Code 9",
          "code": "(a-b)(a+b-1)=n-m",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4982",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readEoln();\n    vector<int> a = inf.readInts(10, 0, 100);\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readEoln();\n    vector<int> a = inf.readInts(10, 0, 100);\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readEoln();\n    vector<int> a = inf.readInts(10, 0, 100);\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n    vector<int> a(10, 0);\n\n    if (type == \"max\") {\n        /* All a[i] = 100 */\n        fill(a.begin(), a.end(), 100);\n    } else if (type == \"min\") {\n        /* All a[i] = 0 */\n        fill(a.begin(), a.end(), 0);\n    } else if (type == \"random\") {\n        /* Random a[i] in range [0,100] */\n        for(int i = 0; i < 10; ++i)\n            a[i] = rnd.next(0, 100);\n    } else if (type == \"one_digit\") {\n        /* Only one digit has non-zero a[i] */\n        int digit = rnd.next(0, 9);\n        a[digit] = rnd.next(1, 100);\n    } else if (type == \"leading_zero\") {\n        /* a[0] > 0, potential leading zero issues */\n        a[0] = rnd.next(1, min(100, n));\n    } else if (type == \"impossible\") {\n        /* Sum of a[i] exceeds n, impossible to satisfy */\n        int sum_a = 0;\n        for(int i = 0; i < 10; ++i) {\n            a[i] = rnd.next(0, min(100, n));\n            sum_a += a[i];\n        }\n        while(sum_a <= n) {\n            int idx = rnd.next(0, 9);\n            int add = rnd.next(1, min(100 - a[idx], n));\n            a[idx] += add;\n            sum_a += add;\n        }\n    } else if (type == \"sum_equals_n\") {\n        /* Sum of a[i] equals n */\n        int remaining = n;\n        while(remaining > 0) {\n            int idx = rnd.next(0, 9);\n            int add = rnd.next(1, min(remaining, 100 - a[idx]));\n            a[idx] += add;\n            remaining -= add;\n        }\n    } else if (type == \"sum_less_n\") {\n        /* Sum of a[i] less than n */\n        int max_sum = n - 1;\n        int sum_a = 0;\n        for(int i = 0; i < 10; ++i) {\n            int remaining = max_sum - sum_a;\n            if (remaining <= 0) break;\n            a[i] = rnd.next(0, min(remaining, 100));\n            sum_a += a[i];\n        }\n    } else if (type == \"single_digit_max\") {\n        /* All zeros except one digit with a[i]=n */\n        int digit = rnd.next(1, 9);\n        a[digit] = n;\n    } else if (type == \"all_ones\") {\n        /* All a[i]=1 */\n        fill(a.begin(), a.end(), 1);\n    } else {\n        /* Default to random */\n        for(int i = 0; i < 10; ++i)\n            a[i] = rnd.next(0, 100);\n    }\n\n    /* Output n and a[0..9] */\n    printf(\"%d\\n\", n);\n    for(int i = 0; i < 10; ++i)\n        printf(\"%d%c\", a[i], i == 9 ? '\\n' : ' ');\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n    vector<int> a(10, 0);\n\n    if (type == \"max\") {\n        /* All a[i] = 100 */\n        fill(a.begin(), a.end(), 100);\n    } else if (type == \"min\") {\n        /* All a[i] = 0 */\n        fill(a.begin(), a.end(), 0);\n    } else if (type == \"random\") {\n        /* Random a[i] in range [0,100] */\n        for(int i = 0; i < 10; ++i)\n            a[i] = rnd.next(0, 100);\n    } else if (type == \"one_digit\") {\n        /* Only one digit has non-zero a[i] */\n        int digit = rnd.next(0, 9);\n        a[digit] = rnd.next(1, 100);\n    } else if (type == \"leading_zero\") {\n        /* a[0] > 0, potential leading zero issues */\n        a[0] = rnd.next(1, min(100, n));\n    } else if (type == \"impossible\") {\n        /* Sum of a[i] exceeds n, impossible to satisfy */\n        int sum_a = 0;\n        for(int i = 0; i < 10; ++i) {\n            a[i] = rnd.next(0, min(100, n));\n            sum_a += a[i];\n        }\n        while(sum_a <= n) {\n            int idx = rnd.next(0, 9);\n            int add = rnd.next(1, min(100 - a[idx], n));\n            a[idx] += add;\n            sum_a += add;\n        }\n    } else if (type == \"sum_equals_n\") {\n        /* Sum of a[i] equals n */\n        int remaining = n;\n        while(remaining > 0) {\n            int idx = rnd.next(0, 9);\n            int add = rnd.next(1, min(remaining, 100 - a[idx]));\n            a[idx] += add;\n            remaining -= add;\n        }\n    } else if (type == \"sum_less_n\") {\n        /* Sum of a[i] less than n */\n        int max_sum = n - 1;\n        int sum_a = 0;\n        for(int i = 0; i < 10; ++i) {\n            int remaining = max_sum - sum_a;\n            if (remaining <= 0) break;\n            a[i] = rnd.next(0, min(remaining, 100));\n            sum_a += a[i];\n        }\n    } else if (type == \"single_digit_max\") {\n        /* All zeros except one digit with a[i]=n */\n        int digit = rnd.next(1, 9);\n        a[digit] = n;\n    } else if (type == \"all_ones\") {\n        /* All a[i]=1 */\n        fill(a.begin(), a.end(), 1);\n    } else {\n        /* Default to random */\n        for(int i = 0; i < 10; ++i)\n            a[i] = rnd.next(0, 100);\n    }\n\n    /* Output n and a[0..9] */\n    printf(\"%d\\n\", n);\n    for(int i = 0; i < 10; ++i)\n        printf(\"%d%c\", a[i], i == 9 ? '\\n' : ' ');\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -type min\n./gen -n 100 -type min\n./gen -n 1 -type max\n./gen -n 100 -type max\n./gen -n 50 -type random\n./gen -n 100 -type random\n./gen -n 100 -type one_digit\n./gen -n 50 -type one_digit\n./gen -n 10 -type leading_zero\n./gen -n 1 -type leading_zero\n./gen -n 1 -type impossible\n./gen -n 100 -type impossible\n./gen -n 50 -type sum_equals_n\n./gen -n 100 -type sum_equals_n\n./gen -n 50 -type sum_less_n\n./gen -n 100 -type sum_less_n\n./gen -n 100 -type single_digit_max\n./gen -n 50 -type single_digit_max\n./gen -n 50 -type all_ones\n./gen -n 100 -type all_ones\n./gen -n 30 -type random\n./gen -n 80 -type random\n./gen -n 90 -type leading_zero\n./gen -n 100 -type leading_zero\n./gen -n 100 -type impossible\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T19:49:31.667799",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "213/C",
      "title": "C. Relay Race",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test4 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains a single integer (1 ≤ n ≤ 300). The next n lines contain n integers each: the j-th number on the i-th line ai, j ( - 1000 ≤ ai, j ≤ 1000) is the number written in the cell with coordinates (i, j).",
      "output_spec": "OutputOn a single line print a single number — the answer to the problem.",
      "sample_tests": "ExamplesInputCopy15OutputCopy5InputCopy211 1416 12OutputCopy53InputCopy325 16 2512 18 1911 13 8OutputCopy136",
      "description": "C. Relay Race\n\ntime limit per test4 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains a single integer (1 ≤ n ≤ 300). The next n lines contain n integers each: the j-th number on the i-th line ai, j ( - 1000 ≤ ai, j ≤ 1000) is the number written in the cell with coordinates (i, j).\n\nOutputOn a single line print a single number — the answer to the problem.\n\nInputCopy15OutputCopy5InputCopy211 1416 12OutputCopy53InputCopy325 16 2512 18 1911 13 8OutputCopy136\n\nInputCopy15\n\nOutputCopy5\n\nInputCopy211 1416 12\n\nOutputCopy53\n\nInputCopy325 16 2512 18 1911 13 8\n\nOutputCopy136\n\nNoteComments to the second sample: The profitable path for Furik is: (1, 1), (1, 2), (2, 2), and for Rubik: (2, 2), (2, 1), (1, 1). Comments to the third sample: The optimal path for Furik is: (1, 1), (1, 2), (1, 3), (2, 3), (3, 3), and for Rubik: (3, 3), (3, 2), (2, 2), (2, 1), (1, 1). The figure to the sample:    Furik's path is marked with yellow, and Rubik's path is marked with pink.",
      "solutions": [
        {
          "title": "Codeforces Round #131 - Codeforces",
          "content": "Hello everybody!Welcome all to Codeforces Round #131, which will be held on Monday, 30th of July at 19:30 MSK. I am (Sergey Nagin) an author of the problems. This will be my First Codeforces round and I hope it won't be the last one :).I would like to thank Mike Mirzayanov(MikeMirzayanov) who made this contest possible, Roman Furko(Furko) and Gerald Agapov(Gerald) for helping to prepare this round and Maria Belova(Delinur) for the translation of problem statements into English. I hope that problems will be interesting for you.Good luck!Problems’ point values in Division 1 are 1000-1000-1500-2000-2500. Problems’ point values in Division 2 are 500-1000-2000-2000-2500.I strongly recommend you to read ALL the problems.The contest is over! Congratulations' to winners!First division:1 place: Egor2 place: Petr3 place: touristSecond division:1 place: antimatter2 place: c1753533 place: takaramono I hope, that problems were interesting for you.You can view tutorial. Some personal information. This year I finished school and I will go to university. I study programming during almost five years. In addition to computer science, I like sports: powerlifting, arm wrestling and swimming.",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/4965",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1190
        },
        {
          "title": "Codeforces Round #131 Tutorial - Codeforces",
          "content": "Sorry for my poor English, this blog will be corrected soon.214A - System of EquationsSolution for this problem — just go through the possible pairs of numbers and check them for correctness. We can do that in any way. 214B - HometaskNuber is divisible by 2,3,5 only if sum of the digits is divisible by 3 and last digit is 0, so if we havent 0 in our set answer is -1, otherwise solution exists(we can return 0 as solution). A further solution — analysis of the cases.Lets sort all didgits in nonincreasing order. If sum of all digits is divisible by 3 — answer is our set of digits(without spaces ofcourse :) ). If modulo equals 1 — we must delete minimum digit from out set with modulo after division by 3 equals 1, if we haven't such we must delete 2 minimal digits with modulo after division by 3 equals 2. If we have modulo equals 2 — we have identical case.Also we must remember that we cannot use leading zeros. In case when we have more then one 0 and no another digit we must print only one zero.213A - GameSolution — Greedy.Lets our computers settled on circle, and moves (1->2, 2->3, 3->1) will be steps \"forward\", and moves (1->3,3->2,2->1) will steps \"back\". Note that \"back\" moves is not optimal, as we can make two moves \"forward\" that is identical in time. We will look over all starts. Further, we will go by circle while we not complited all game. For every level we will remember number ne[i] — count of another level that \"direct\" need for it. We will complited levels with ne[i]=0 and update all ne[i] that we must. It can be implemented with O(n^3) time.213B - NumbersSolution — dynamic programming.Look over for length of the number that we will build. Further, we will use DP f(len,i) — how many numbers with length len we can make with digits i..9.Recount:- f(len,0) = sum(f(len-i,1)*C(len-1,i), i=a[0]..len);- f(len,j) = sum(f(len-i,j+1)*C(len,i), i=a[j]..len), 0<j<9;- f(len,9) = 1, если len>=a[9], 0 если len<a[9].C(n,k) — binomial coefficient.213C - Relay RaceSolution — dynamic programming.Note, that we can make 2 pathes form cell (1,1) to cell (n,n).Note, that after each move our cells will be located on the same diagonal.We will solve the problem with DP f(d,i1,i2), d — diagonal number, i1 — 1st coordinate 1st path, i2 — 1st coordinate 2nd path. It is clear that we can calculate 2nd coordinate when we know number of the diagonal and 1st coordinate. Recount — obvious, we make all 4 transition, and if pathes are intersected in temporary point, we add value of the cell only one, otherwise we add both values of the cells. We can imlement this solution with O(n^2) memory if we will rewrite array of DP after increasing of diagonal number. Also we must remember that answer can be lower then 0. 213D - StarsI present solution as few pictures:https://get.google.com/albumarchive/pwa/115317317397602031319/Solutions131Implementation.We have only one difficult moment — how to count coordinates? We can calculate them from regular pentagon, all that you need, you can read there.213E - Two PermutationsFor given two permutation we will make two another by next transformation: New_A[A[i]] = i, where New_A — news permutation, A — given permutation. Lets we get two permutation A and B. Now our problem is next: how many sub-arrays of length n are equals to firs permutation. Two arrays will be equal if after swaping every element with its number in sorted array obtained arrays will be element-wise equal.Further solution hashes, but we will use not only modulo 2^64, we will use some big modulos, but they must be smaller then 2^32-1.Lets step[i] = 1000003^i.Lets F(A) = num[1]*step[1] + num[2]*step[2] + ... + num[n]*step[n], where num[i] — number of the element A[i] in sorted array.If we will compare arrays, we can use this function. But it can be very big, so we will count it by modulos.So now our problem is to calculate F function to every subarray. Lets look what will change after adding/deleting some elent from set: some element from num array willnot change, and some will become grater after adding, and become lower after deleting. So we must use some interval-tree to recount our F function. We need to know sum of step[i] on some interval of added numbers and count of elements on some interval. Uses this information we can simply recount out function. Also we must remember that after adding element with coeficinet step[i], where i>n and deleting some previos element our function will become grater that we need. So we will multiple hash of first array by 1000003 to avoid this issue.",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/4982",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 213\\s*C"
          },
          "content_length": 4543
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #131 - Codeforces - Code 1",
          "code": "int n = 300;\nfprintf(stdout, \"%d\\n\", n);\nfor (int i = 0; i < n; i++)\n    for (int c = 0; c < n; c++)\n        fprintf(stdout, \"%d%c\", ((i + c == 580) ? -1 : 0), c + 1 == n ? '\\n' : ' ');",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4965",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #131 - Codeforces - Code 2",
          "code": "int n = 300;\nfprintf(stdout, \"%d\\n\", n);\nfor (int i = 0; i < n; i++)\n    for (int c = 0; c < n; c++)\n        fprintf(stdout, \"%d%c\", ((i + c == 580) ? -1 : 0), c + 1 == n ? '\\n' : ' ');",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4965",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #131 - Codeforces - Code 3",
          "code": "Comb[len - 1][j]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4965",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #131 Tutorial - Codeforces - Code 1",
          "code": "(a-b)(a+b-1)=n-m",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4982",
          "author": "Qingyu"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h> \nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 300, \"n\");\n    inf.readEoln();\n    for (int i = 0; i < n; ++i) {\n        vector<int> row = inf.readInts(n, -1000, 1000, \"a_i_j\");\n        inf.readEoln();\n    }\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h> \nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 300, \"n\");\n    inf.readEoln();\n    for (int i = 0; i < n; ++i) {\n        vector<int> row = inf.readInts(n, -1000, 1000, \"a_i_j\");\n        inf.readEoln();\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h> \nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 300, \"n\");\n    inf.readEoln();\n    for (int i = 0; i < n; ++i) {\n        vector<int> row = inf.readInts(n, -1000, 1000, \"a_i_j\");\n        inf.readEoln();\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n    int min_a = opt<int>(\"min_a\", -1000);\n    int max_a = opt<int>(\"max_a\", 1000);\n\n    printf(\"%d\\n\", n);\n    if (type == \"random\") {\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < n; ++j) {\n                int val = rnd.next(min_a, max_a);\n                printf(\"%d%c\", val, (j == n-1) ? '\\n' : ' ');\n            }\n        }\n    } else if (type == \"max\") {\n        int val = max_a;\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < n; ++j) {\n                printf(\"%d%c\", val, (j == n-1) ? '\\n' : ' ');\n            }\n        }\n    } else if (type == \"min\") {\n        int val = min_a;\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < n; ++j) {\n                printf(\"%d%c\", val, (j == n-1) ? '\\n' : ' ');\n            }\n        }\n    } else if (type == \"diagonal\") {\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < n; ++j) {\n                int val = (i == j) ? max_a : min_a;\n                printf(\"%d%c\", val, (j == n-1) ? '\\n' : ' ');\n            }\n        }\n    } else if (type == \"anti_diagonal\") {\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < n; ++j) {\n                int val = (i + j == n - 1) ? max_a : min_a;\n                printf(\"%d%c\", val, (j == n-1) ? '\\n' : ' ');\n            }\n        }\n    } else if (type == \"path\") {\n        /*\n        Create a grid where the optimal path for Furik and Rubik overlaps as much as possible.\n        For example, set high values along a common path, low values elsewhere.\n        */\n        vector<vector<int>> grid(n, vector<int>(n, min_a));\n        int i = 0, j = 0;\n        while (i < n && j < n) {\n            grid[i][j] = max_a;\n            if (rnd.next(2)) {\n                ++i;\n            } else {\n                ++j;\n            }\n        }\n        while (i < n) {\n            grid[i][n - 1] = max_a;\n            ++i;\n        }\n        while (j < n) {\n            grid[n - 1][j] = max_a;\n            ++j;\n        }\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < n; ++j) {\n                printf(\"%d%c\", grid[i][j], (j == n -1) ? '\\n' : ' ');\n            }\n        }\n    } else if (type == \"worst_case\") {\n        /*\n        Create a grid where the optimal path requires careful choosing to avoid overlapping cells,\n        testing the solution's correctness on double counting cells.\n        */\n        vector<vector<int>> grid(n, vector<int>(n, min_a));\n        // High values near (1,1) and (n,n), low values in between.\n        grid[0][0] = max_a;\n        grid[n-1][n-1] = max_a;\n        for (int i = 1; i < n-1; ++i) {\n            grid[i][i] = min_a;\n        }\n        for (int i = 0; i < n; ++i) {\n            grid[0][i] = rnd.next(min_a, max_a);\n            grid[i][n-1] = rnd.next(min_a, max_a);\n        }\n        for (int i = 0; i < n; ++i) {\n            grid[i][0] = rnd.next(min_a, max_a);\n            grid[n-1][i] = rnd.next(min_a, max_a);\n        }\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < n; ++j) {\n                printf(\"%d%c\", grid[i][j], (j == n -1) ? '\\n' : ' ');\n            }\n        }\n    } else {\n        fprintf(stderr, \"Unknown type: %s\\n\", type.c_str());\n        return 1;\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n    int min_a = opt<int>(\"min_a\", -1000);\n    int max_a = opt<int>(\"max_a\", 1000);\n\n    printf(\"%d\\n\", n);\n    if (type == \"random\") {\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < n; ++j) {\n                int val = rnd.next(min_a, max_a);\n                printf(\"%d%c\", val, (j == n-1) ? '\\n' : ' ');\n            }\n        }\n    } else if (type == \"max\") {\n        int val = max_a;\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < n; ++j) {\n                printf(\"%d%c\", val, (j == n-1) ? '\\n' : ' ');\n            }\n        }\n    } else if (type == \"min\") {\n        int val = min_a;\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < n; ++j) {\n                printf(\"%d%c\", val, (j == n-1) ? '\\n' : ' ');\n            }\n        }\n    } else if (type == \"diagonal\") {\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < n; ++j) {\n                int val = (i == j) ? max_a : min_a;\n                printf(\"%d%c\", val, (j == n-1) ? '\\n' : ' ');\n            }\n        }\n    } else if (type == \"anti_diagonal\") {\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < n; ++j) {\n                int val = (i + j == n - 1) ? max_a : min_a;\n                printf(\"%d%c\", val, (j == n-1) ? '\\n' : ' ');\n            }\n        }\n    } else if (type == \"path\") {\n        /*\n        Create a grid where the optimal path for Furik and Rubik overlaps as much as possible.\n        For example, set high values along a common path, low values elsewhere.\n        */\n        vector<vector<int>> grid(n, vector<int>(n, min_a));\n        int i = 0, j = 0;\n        while (i < n && j < n) {\n            grid[i][j] = max_a;\n            if (rnd.next(2)) {\n                ++i;\n            } else {\n                ++j;\n            }\n        }\n        while (i < n) {\n            grid[i][n - 1] = max_a;\n            ++i;\n        }\n        while (j < n) {\n            grid[n - 1][j] = max_a;\n            ++j;\n        }\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < n; ++j) {\n                printf(\"%d%c\", grid[i][j], (j == n -1) ? '\\n' : ' ');\n            }\n        }\n    } else if (type == \"worst_case\") {\n        /*\n        Create a grid where the optimal path requires careful choosing to avoid overlapping cells,\n        testing the solution's correctness on double counting cells.\n        */\n        vector<vector<int>> grid(n, vector<int>(n, min_a));\n        // High values near (1,1) and (n,n), low values in between.\n        grid[0][0] = max_a;\n        grid[n-1][n-1] = max_a;\n        for (int i = 1; i < n-1; ++i) {\n            grid[i][i] = min_a;\n        }\n        for (int i = 0; i < n; ++i) {\n            grid[0][i] = rnd.next(min_a, max_a);\n            grid[i][n-1] = rnd.next(min_a, max_a);\n        }\n        for (int i = 0; i < n; ++i) {\n            grid[i][0] = rnd.next(min_a, max_a);\n            grid[n-1][i] = rnd.next(min_a, max_a);\n        }\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < n; ++j) {\n                printf(\"%d%c\", grid[i][j], (j == n -1) ? '\\n' : ' ');\n            }\n        }\n    } else {\n        fprintf(stderr, \"Unknown type: %s\\n\", type.c_str());\n        return 1;\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -type random\n./gen -n 1 -type max -max_a 1000\n./gen -n 1 -type min -min_a -1000\n\n./gen -n 2 -type random\n./gen -n 2 -type diagonal -max_a 1000 -min_a -1000\n./gen -n 2 -type anti_diagonal -max_a 1000 -min_a -1000\n\n./gen -n 3 -type path -max_a 1000 -min_a -1000\n./gen -n 3 -type worst_case -max_a 1000 -min_a -1000\n\n./gen -n 10 -type random\n./gen -n 10 -type max -max_a 1000\n./gen -n 10 -type min -min_a -1000\n./gen -n 10 -type diagonal -max_a 1000 -min_a -1000\n./gen -n 10 -type anti_diagonal -max_a 1000 -min_a -1000\n./gen -n 10 -type path -max_a 1000 -min_a -1000\n./gen -n 10 -type worst_case -max_a 1000 -min_a -1000\n\n./gen -n 10 -type random -min_a 0 -max_a 0\n./gen -n 10 -type random -min_a -10 -max_a 10\n\n./gen -n 100 -type random\n./gen -n 100 -type diagonal -max_a 1000 -min_a -1000\n./gen -n 100 -type max -max_a 1000\n./gen -n 100 -type min -min_a -1000\n./gen -n 100 -type path -max_a 1000 -min_a -1000\n./gen -n 100 -type worst_case -max_a 1000 -min_a -1000\n\n./gen -n 300 -type random\n./gen -n 300 -type diagonal -max_a 1000 -min_a -1000\n./gen -n 300 -type anti_diagonal -max_a 1000 -min_a -1000\n./gen -n 300 -type max -max_a 1000\n./gen -n 300 -type min -min_a -1000\n./gen -n 300 -type path -max_a 1000 -min_a -1000\n./gen -n 300 -type worst_case -max_a 1000 -min_a -1000\n\n./gen -n 300 -type random -min_a -1000 -max_a 1000\n./gen -n 300 -type random -min_a -1000 -max_a -500\n./gen -n 300 -type random -min_a 500 -max_a 1000\n./gen -n 300 -type random -min_a 0 -max_a 0\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T19:49:33.920631",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "213/D",
      "title": "D. Звезды",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест2 секунды",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеВ единственной строке дано целое число (1 ≤ n ≤ 100) — количество звезд, которые надо нарисовать.",
      "output_spec": "Выходные данныеВ первой строке выведите целое число m (1 ≤ m ≤ 5·n). В следующих m строках выведите координаты m различных точек с точностью не менее 9 и не более 100 знаков после десятичной точки. Все координаты не должны превышать 5000 по модулю. В следующих n строках выведите по 5 целых чисел — номера точек, которые образовывают данную звезду в порядке обхода по или против часовой стрелки. В следующей строке выведите 5·n + 1 целых чисел — номера точек в порядке, в котором рисует звезды Рубик. То есть если число номер i — ai, а i + 1 — ai + 1, то между точками с номерами ai и ai + 1 будет нарисован отрезок. Считайте, что выведенные m точек пронумерованы от 1 до m в том порядке, в котором они выведены. Числа в строках разделяйте пробельными символами.Обратите внимание, что правильность ответа проверяется не абсолютно точно. Постарайтесь получить как можно более точное решение. Все вычисления в проверяющей программе выполняются в предположении, что абсолютная погрешность ответа участника не более 10 - 8.",
      "sample_tests": "ПримерыВходные данныеСкопировать1Выходные данныеСкопировать53.830127018922193 3.366025403784439-3.601321235851749 10.0573314673730210.466045194906253 19.19278604379903010.411264148588986 18.14750141112249512.490381056766580 8.3660254037844391 2 3 4 51 3 5 2 4 1",
      "description": "ограничение по времени на тест2 секунды\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвыводstdout\n\nВходные данныеВ единственной строке дано целое число (1 ≤ n ≤ 100) — количество звезд, которые надо нарисовать.\n\nВходные данные\n\nВыходные данныеВ первой строке выведите целое число m (1 ≤ m ≤ 5·n). В следующих m строках выведите координаты m различных точек с точностью не менее 9 и не более 100 знаков после десятичной точки. Все координаты не должны превышать 5000 по модулю. В следующих n строках выведите по 5 целых чисел — номера точек, которые образовывают данную звезду в порядке обхода по или против часовой стрелки. В следующей строке выведите 5·n + 1 целых чисел — номера точек в порядке, в котором рисует звезды Рубик. То есть если число номер i — ai, а i + 1 — ai + 1, то между точками с номерами ai и ai + 1 будет нарисован отрезок. Считайте, что выведенные m точек пронумерованы от 1 до m в том порядке, в котором они выведены. Числа в строках разделяйте пробельными символами.Обратите внимание, что правильность ответа проверяется не абсолютно точно. Постарайтесь получить как можно более точное решение. Все вычисления в проверяющей программе выполняются в предположении, что абсолютная погрешность ответа участника не более 10 - 8.\n\nВыходные данные\n\nВходные данныеСкопировать1Выходные данныеСкопировать53.830127018922193 3.366025403784439-3.601321235851749 10.0573314673730210.466045194906253 19.19278604379903010.411264148588986 18.14750141112249512.490381056766580 8.3660254037844391 2 3 4 51 3 5 2 4 1\n\nВходные данныеСкопировать1\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать53.830127018922193 3.366025403784439-3.601321235851749 10.0573314673730210.466045194906253 19.19278604379903010.411264148588986 18.14750141112249512.490381056766580 8.3660254037844391 2 3 4 51 3 5 2 4 1\n\nВыходные данныеСкопировать\n\nСкопировать\n\nПримечаниеИзначальное положение точек в примере:  Порядок, в котором можно рисовать отрезки:",
      "solutions": [
        {
          "title": "Codeforces Round #131 - Codeforces",
          "content": "Всем привет!Сегодня, 30 июля в 19:30 MSK состоится Codeforces Round #131, автором которого являюсь я(Сергей Нагин). Это мой первый раунд на Codeforces и надеюсь, что не последний.Спасибо Фурко Роману(Furko) и Геральду Агапову(Gerald) за помощь в подготовке задач, а Марии Беловой(Delinur) за перевод условий. Также выражаю благодарность создателю Codeforces Михаилу Мирзаянову (MikeMirzayanov) за прекрасную систему.Удачи на раунде! Разбалловка в первом дивизионе: 1000-1000-1500-2000-2500. Разбалловка во втором дивизионе: 500-1000-2000-2000-2500. Настоятельно рекомендую прочитать условия ВСЕХ задач.Контест завершен! Поздравляю победителей!1й дивизион:1 место: Egor2 место: Petr3 место: tourist2й дивизион:1 место: antimatter2 место: c1753533 место: takaramono Надеюсь, задачи вам понравились. Разбор задач. Немного личной информации.В этом году я закончил школу и буду поступать в университет. Программированием занимаюсь почти 5 лет (с 7го класса). Помимо информатики, любительски увлекаюсь спортом: пауэрлифтинг, армрестлинг и плаванье.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/4965",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 1042
        },
        {
          "title": "Разбор задач Codeforces Round #131 - Codeforces",
          "content": "214A - Система уравненийВ данной задаче решение — просто перебрать возможные пары чисел и проверить их на правильность. Делать это можно было любым способом. 214B - Домашнее заданиеЧисло делится на 2,3,5 только в том случае, если сумма цифр кратна 3, а последняя цифра 0, то есть если в наборе нету нулей, то ответ -1. Дальнейшее решение — разбор случаев.Возьмем все цифры в невозрастающем порядке, если сумма цифр кратна 3, то это и есть ответ. Если остаток от деления вышел 1, то нужно убрать 1 цифру у которой остаток от деления на 3 равен 1. Если такой не нашли то нужно убрать 2 цифры с остатком 2. Аналогично рассматривается случай когда изначальный остаток равен 2. Так-же нужно рассмотреть случай когда остались только нули, в этом случае нужно вывести только 1 ноль. 213A - ИграРешение — жадность. Пусть у нас компьютеры стоят по кругу, и ходами \"вперед\" назовем перемещения (1->2, 2->3, 3->1), а перемещением \"назад\" (1->3,3->2,2->1). Заметим что ходить \"назад\" не выгодно, так как можно 2 раза походить \"вперед\", что в сумме равноценно. Будем перебирать стартовую вершину. Дальше будем ходить по кругу до тех пор, пока не \"откроем\" все уровни. В авторском решении для каждого уровня поддерживается количество уровней, которые нужны для него. После того как мы находим очередной 0 в этом списке, мы просто уменьшаем такую величину для всех уровней, которые от него непосредственно зависят. Сложность решения O(n^3). 213B - ЧислаРешение — динамика. Перебираем длину числа, которое будем строить. Далее будем пользоваться динамикой f(len,i) — сколько чисел диной len можно составить из цифр i..9.Пересчет:- f(len,0) = sum(f(len-i,1)*C(len-1,i), i=a[0]..len);- f(len,j) = sum(f(len-i,j+1)*C(len,i), i=a[j]..len), 0<j<9;- f(len,9) = 1, если len>=a[9], 0 если len<a[9].C(n,k) — количество способов выбрать k элементов из n.213C - ЭстафетаРешение — динамика.Заметим, что мы можем просто провести два пути их клетки (1,1) в клетку (n,n).Заметим, что после каждого шага клетки будут оставаться на одной диагонали. Будем решать задачу динамикой f(d,i1,i2), d — номер диагонали, i1 — 1я координата 1го маршрута, i2 — 1я координата 2го маршрута. Понятно что вторую координату мы можем определить однозначно. Переходы — очевидны, делаем 4 возможных перехода, если маршруты пересеклись, то добавляем величину клеточки один раз, иначе добавляем величины посещенных клеток. Так как данная динамика не влазит по памяти, то ее нужно делать двумерной, просто перенося значения из прошлой диагонали в новую.Еще нужно не забыть про то, что ответ может выйти отрицательным.213D - ЗвездыПредоставлю разбор как небольшую презентацию картинками:https://get.google.com/albumarchive/pwa/115317317397602031319/Solutions131Реализация.Единственную сложность могло составить определение координат, все координаты можно найти из правильного пятиугольника. Все что о нем нужно описано тут.213E - Две перестановкиПервый шаг: заменить перестановки на обратные, то есть из перестановки A мы делаем перестановку B, такую что B[A[i]] = i. Если посмотреть на то, что получилось, то выходит такая задача: сколько подотрезков второй перестановки равны первой, в случае если мы \"сожмем координаты\", то есть числам сопоставим их номер в отсортированном виде. Эту задачу предполагалась решать хэшами, но брать их нужно было не только по основанию 2^64, а и еще по нескольким простым модулям, тайм лимит специально стоял 3 секунды.Теперь, собственно, как ее решать: Для каждой позиции i — сопоставим коєфициент step[i], где step[i] = 1000003^i. Теперь Рассмотрим такую функцию: F(A) = num[1]*step[1] + num[2]*step[2] + num[3]*step[3] + ... + num[n]*step[n], где num[i] — порядковый номер элемента A[i] в отсортированном списке. Понято что эта функция однозначно задает множество, от нее и будем считать хэш.Как пересчитывать при переходе не следующий элемент.Заметим что когда мы убираем какой-то элемент, то все элементы которые больше его уменьшают значение num на единицу. Ровно как и после добавления они его увеличивают. То есть заведем Дерево отрезков/Фенвика для хранения таких величин как сумма степеней на отрезке и количество элементов на отрезку, что-бы за O(log(n)) находить величину num для числа и после каждого добавления/удаления будем пересчитывать хэш, тоже за O(log(n)). Так-же нужно будем умножать хэш на от первой перестановки на 1000003 после каждого смещения на 1 элемент вправо, так как коэффициенты step уже не будут идти от единицы. Все замечания просьба писать в комментарии.Через некоторое время постараюсь сделать формулы более красивыми.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/4982",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 213\\s*D"
          },
          "content_length": 4533
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #131 - Codeforces - Code 1",
          "code": "'Немного личной информации.\nВ этом году я закончил школу и буду поступать в университет. Программированием занимаюсь почти 5 лет (с 7го класса). Помимо информатики, любительски увлекаюсь спортом: пауэрлифтинг, армрестлинг и плаванье.'\nА я Никита, ...",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4965",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #131 - Codeforces - Code 2",
          "code": "'Немного личной информации.\nВ этом году я закончил школу и буду поступать в университет. Программированием занимаюсь почти 5 лет (с 7го класса). Помимо информатики, любительски увлекаюсь спортом: пауэрлифтинг, армрестлинг и плаванье.'\nА я Никита, ...",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4965",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #131 - Codeforces - Code 3",
          "code": "vector<>::erase",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4965",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #131 - Codeforces - Code 4",
          "code": "5\n4 32 1 18 41\n47 38 7 43 43\n48 23 39 40 23\n26 39 33 5 36\n31 29 7 26 47",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4965",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #131 - Codeforces - Code 5",
          "code": "5\n4 32 1 18 41\n47 38 7 43 43\n48 23 39 40 23\n26 39 33 5 36\n31 29 7 26 47",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4965",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #131 - Codeforces - Code 6",
          "code": "int n = 300;\nfprintf(stdout, \"%d\\n\", n);\nfor (int i = 0; i < n; i++)\n    for (int c = 0; c < n; c++)\n        fprintf(stdout, \"%d%c\", ((i + c == 580) ? -1 : 0), c + 1 == n ? '\\n' : ' ');",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4965",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #131 - Codeforces - Code 7",
          "code": "int n = 300;\nfprintf(stdout, \"%d\\n\", n);\nfor (int i = 0; i < n; i++)\n    for (int c = 0; c < n; c++)\n        fprintf(stdout, \"%d%c\", ((i + c == 580) ? -1 : 0), c + 1 == n ? '\\n' : ' ');",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4965",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #131 - Codeforces - Code 8",
          "code": "Comb[len - 1][j]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4965",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Codeforces Round #131 - Codeforces - Code 1",
          "code": "import java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tInputStream inputStream = System.in;\n\t\tOutputStream outputStream = System.out;\n\t\tPrintWriter out = new PrintWriter(outputStream);\n\t\tBadGen solver = new BadGen();\n\t\tsolver.solve(out);\n\t\tout.close();\n\t}\n}\n\nclass BadGen {\n\tpublic void solve(PrintWriter out) {\n        int n = 1 << 12;\n        int m = 1 << 17;\n        out.println(n + \" \" + m);\n        int[] pn = buildBadPerm(n);\n        for (int i = 0; i < n; ++i) {\n            if (i > 0) out.print(\" \");\n            out.print(pn[i] + 1);\n        }\n        out.println();\n        int[] pm = buildBadPerm(m);\n        for (int i = 0; i < m; ++i) {\n            if (i > 0) out.print(\" \");\n            out.print(pm[i] + 1);\n        }\n        out.println();\n    }\n\n    private int[] buildBadPerm(int n) {\n        int[] invs = new int[]{0};\n        while (invs.length < n) {\n            int[] ninvs = new int[2 * invs.length];\n            for (int i = 0; i < invs.length; ++i) {\n                ninvs[i] = invs[i];\n                ninvs[i + invs.length] = 1 - invs[i];\n            }\n            invs = ninvs;\n        }\n        int[] perm = new int[n];\n        for (int i = 0; i * 2 < n; ++i) {\n            if (invs[i * 2] == 0) {\n                perm[i * 2] = i * 2;\n                perm[i * 2 + 1] = i * 2 + 1;\n            } else {\n                perm[i * 2] = i * 2 + 1;\n                perm[i * 2 + 1] = i * 2;\n            }\n        }\n        return perm;\n    }\n}",
          "language": "Python",
          "source": "https://codeforces.com/blog/entry/4982",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Codeforces Round #131 - Codeforces - Code 2",
          "code": "import java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tInputStream inputStream = System.in;\n\t\tOutputStream outputStream = System.out;\n\t\tPrintWriter out = new PrintWriter(outputStream);\n\t\tBadGen solver = new BadGen();\n\t\tsolver.solve(out);\n\t\tout.close();\n\t}\n}\n\nclass BadGen {\n\tpublic void solve(PrintWriter out) {\n        int n = 1 << 12;\n        int m = 1 << 17;\n        out.println(n + \" \" + m);\n        int[] pn = buildBadPerm(n);\n        for (int i = 0; i < n; ++i) {\n            if (i > 0) out.print(\" \");\n            out.print(pn[i] + 1);\n        }\n        out.println();\n        int[] pm = buildBadPerm(m);\n        for (int i = 0; i < m; ++i) {\n            if (i > 0) out.print(\" \");\n            out.print(pm[i] + 1);\n        }\n        out.println();\n    }\n\n    private int[] buildBadPerm(int n) {\n        int[] invs = new int[]{0};\n        while (invs.length < n) {\n            int[] ninvs = new int[2 * invs.length];\n            for (int i = 0; i < invs.length; ++i) {\n                ninvs[i] = invs[i];\n                ninvs[i + invs.length] = 1 - invs[i];\n            }\n            invs = ninvs;\n        }\n        int[] perm = new int[n];\n        for (int i = 0; i * 2 < n; ++i) {\n            if (invs[i * 2] == 0) {\n                perm[i * 2] = i * 2;\n                perm[i * 2 + 1] = i * 2 + 1;\n            } else {\n                perm[i * 2] = i * 2 + 1;\n                perm[i * 2 + 1] = i * 2;\n            }\n        }\n        return perm;\n    }\n}",
          "language": "Python",
          "source": "https://codeforces.com/blog/entry/4982",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Codeforces Round #131 - Codeforces - Code 3",
          "code": "if(len >= a[9])\n    f(len, 9) = 1\nelse\n    f(len, 9) = 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4982",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Codeforces Round #131 - Codeforces - Code 4",
          "code": "if(len >= a[9])\n    f(len, 9) = 1\nelse\n    f(len, 9) = 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4982",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Codeforces Round #131 - Codeforces - Code 5",
          "code": "- f(len,j) = sum( f(len-i,1)*C(len,i), i=a[j]..len ), 0<j<9;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4982",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Codeforces Round #131 - Codeforces - Code 6",
          "code": "f(len-i,j+1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4982",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Codeforces Round #131 - Codeforces - Code 7",
          "code": "3\n99 99 98\n98 99 99\n11 98 99",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4982",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Codeforces Round #131 - Codeforces - Code 8",
          "code": "3\n99 99 98\n98 99 99\n11 98 99",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4982",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Codeforces Round #131 - Codeforces - Code 9",
          "code": "(a-b)(a+b-1)=n-m",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4982",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint n;\n\nint main(int argc, char* argv[]) {\n    registerTestlibCmd(argc, argv);\n\n    n = inf.readInt(1, 100, \"n\");\n\n    // Read m from contestant's output.\n    int m = ouf.readInt(1, 5 * n, \"m\");\n\n    // Read m points.\n    vector<pair<double, double>> points(m);\n    for (int i = 0; i < m; ++i) {\n        // Read x and y as strings to check the number of digits after the decimal point.\n        string x_str = ouf.readWord();\n        string y_str = ouf.readWord();\n\n        // Parse the strings to doubles.\n        double x = atof(x_str.c_str());\n        double y = atof(y_str.c_str());\n\n        // Check |x| ≤ 5000\n        if (fabs(x) > 5000 + 1e-8)\n            ouf.quitf(_wa, \"x coordinate of point %d is out of range [-5000, 5000]\", i + 1);\n\n        // Check |y| ≤ 5000\n        if (fabs(y) > 5000 + 1e-8)\n            ouf.quitf(_wa, \"y coordinate of point %d is out of range [-5000, 5000]\", i + 1);\n\n        // Function to count the number of digits after the decimal point.\n        auto count_digits_after_decimal = [](const string& s) -> int {\n            size_t pos = s.find('.');\n            if (pos == string::npos) return 0;\n            return s.length() - pos - 1;\n        };\n\n        int x_digits = count_digits_after_decimal(x_str);\n        int y_digits = count_digits_after_decimal(y_str);\n        if (x_digits < 9 || x_digits > 100)\n            ouf.quitf(_wa, \"x coordinate of point %d has %d digits after decimal point, requirement is at least 9 and at most 100\", i + 1, x_digits);\n        if (y_digits < 9 || y_digits > 100)\n            ouf.quitf(_wa, \"y coordinate of point %d has %d digits after decimal point, requirement is at least 9 and at most 100\", i + 1, y_digits);\n\n        points[i] = make_pair(x, y);\n    }\n\n    // Check that points are distinct (within acceptable error).\n    for (int i = 0; i < m; ++i) {\n        for (int j = i + 1; j < m; ++j) {\n            double dx = points[i].first - points[j].first;\n            double dy = points[i].second - points[j].second;\n            double dist = sqrt(dx * dx + dy * dy);\n            if (dist < 1e-8)\n                ouf.quitf(_wa, \"points %d and %d are too close (distance %e), points must be distinct\", i + 1, j + 1, dist);\n        }\n    }\n\n    // Read n stars.\n    vector<vector<int>> stars(n, vector<int>(5));\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < 5; ++j) {\n            int idx = ouf.readInt(1, m, format(\"star[%d][%d]\", i + 1, j + 1).c_str());\n            stars[i][j] = idx - 1; // zero-based index\n        }\n    }\n\n    // Read 5n + 1 integers for the drawing sequence.\n    int seq_len = 5 * n + 1;\n    vector<int> seq(seq_len);\n    for (int i = 0; i < seq_len; ++i) {\n        int idx = ouf.readInt(1, m, format(\"drawing_sequence[%d]\", i + 1).c_str());\n        seq[i] = idx - 1; // zero-based index\n    }\n\n    // Build set of segments and ensure no segment is repeated.\n    set<pair<int, int>> segments;\n    for (int i = 0; i < seq_len - 1; ++i) {\n        int a = seq[i];\n        int b = seq[i + 1];\n        // Check if segment is non-zero length.\n        if (a == b)\n            ouf.quitf(_wa, \"segment between identical points at positions %d and %d\", i + 1, i + 2);\n        int u = min(a, b);\n        int v = max(a, b);\n        pair<int, int> edge = make_pair(u, v);\n        if (segments.count(edge))\n            ouf.quitf(_wa, \"segment between points %d and %d is repeated\", u + 1, v + 1);\n        segments.insert(edge);\n    }\n\n    // Check that each star forms a regular pentagon with side length 10.\n    for (int k = 0; k < n; ++k) {\n        vector<int>& star = stars[k];\n        // Get the points of the star.\n        vector<pair<double, double>> pts(5);\n        for (int i = 0; i < 5; ++i) {\n            pts[i] = points[star[i]];\n        }\n        // Check side lengths between consecutive vertices.\n        for (int i = 0; i < 5; ++i) {\n            int j = (i + 1) % 5;\n            double dx = pts[i].first - pts[j].first;\n            double dy = pts[i].second - pts[j].second;\n            double dist = sqrt(dx * dx + dy * dy);\n            if (fabs(dist - 10.0) > 1e-8)\n                ouf.quitf(_wa, \"in star %d, side length between points %d and %d is %e, expected 10\", k + 1, star[i] + 1, star[j] + 1, dist);\n        }\n    }\n\n    // All constraints are satisfied.\n    quitf(_ok, \"answer is correct\");\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    // Register this program as a generator.\n    // Do NOT set any random seed so that the invoker (judge) controls randomness.\n    registerGen(argc, argv, 1);\n\n    // Read parameters from the command line.\n    // \"n\" is the number of stars; default is 1 if not specified.\n    int n = opt<int>(\"n\", 1);\n\n    // If \"random\" is provided (e.g., -random), then ignore the given n\n    // and generate a random integer in [1..100].\n    bool doRandom = opt<bool>(\"random\", false);\n\n    if (doRandom) {\n        n = rnd.next(1, 100);\n    }\n\n    // Output exactly one integer (the test case), as specified by the problem.\n    cout << n << \"\\n\";\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    // Register this program as a generator.\n    // Do NOT set any random seed so that the invoker (judge) controls randomness.\n    registerGen(argc, argv, 1);\n\n    // Read parameters from the command line.\n    // \"n\" is the number of stars; default is 1 if not specified.\n    int n = opt<int>(\"n\", 1);\n\n    // If \"random\" is provided (e.g., -random), then ignore the given n\n    // and generate a random integer in [1..100].\n    bool doRandom = opt<bool>(\"random\", false);\n\n    if (doRandom) {\n        n = rnd.next(1, 100);\n    }\n\n    // Output exactly one integer (the test case), as specified by the problem.\n    cout << n << \"\\n\";\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1\n./gen -n 2\n./gen -n 3\n./gen -n 4\n./gen -n 5\n./gen -n 6\n./gen -n 10\n./gen -n 20\n./gen -n 25\n./gen -n 30\n./gen -n 50\n./gen -n 60\n./gen -n 80\n./gen -n 90\n./gen -n 99\n./gen -n 100\n\n./gen -random\n./gen -random\n./gen -random\n./gen -random\n./gen -random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T19:49:36.180345",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "213/E",
      "title": "E. Two Permutations",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains two integers n and m (1 ≤ n ≤ m ≤ 200000) — the sizes of the given permutations. The second line contains n distinct integers — permutation a, the third line contains m distinct integers — permutation b. Numbers on the lines are separated by spaces.",
      "output_spec": "OutputOn a single line print the answer to the problem.",
      "sample_tests": "ExamplesInputCopy1 111OutputCopy1InputCopy1 212 1OutputCopy2InputCopy3 32 3 11 2 3OutputCopy0",
      "description": "E. Two Permutations\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains two integers n and m (1 ≤ n ≤ m ≤ 200000) — the sizes of the given permutations. The second line contains n distinct integers — permutation a, the third line contains m distinct integers — permutation b. Numbers on the lines are separated by spaces.\n\nOutputOn a single line print the answer to the problem.\n\nInputCopy1 111OutputCopy1InputCopy1 212 1OutputCopy2InputCopy3 32 3 11 2 3OutputCopy0\n\nInputCopy1 111\n\nOutputCopy1\n\nInputCopy1 212 1\n\nOutputCopy2\n\nInputCopy3 32 3 11 2 3\n\nOutputCopy0",
      "solutions": [
        {
          "title": "Codeforces Round #131 - Codeforces",
          "content": "Hello everybody!Welcome all to Codeforces Round #131, which will be held on Monday, 30th of July at 19:30 MSK. I am (Sergey Nagin) an author of the problems. This will be my First Codeforces round and I hope it won't be the last one :).I would like to thank Mike Mirzayanov(MikeMirzayanov) who made this contest possible, Roman Furko(Furko) and Gerald Agapov(Gerald) for helping to prepare this round and Maria Belova(Delinur) for the translation of problem statements into English. I hope that problems will be interesting for you.Good luck!Problems’ point values in Division 1 are 1000-1000-1500-2000-2500. Problems’ point values in Division 2 are 500-1000-2000-2000-2500.I strongly recommend you to read ALL the problems.The contest is over! Congratulations' to winners!First division:1 place: Egor2 place: Petr3 place: touristSecond division:1 place: antimatter2 place: c1753533 place: takaramono I hope, that problems were interesting for you.You can view tutorial. Some personal information. This year I finished school and I will go to university. I study programming during almost five years. In addition to computer science, I like sports: powerlifting, arm wrestling and swimming.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/4965",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1190
        },
        {
          "title": "Codeforces Round #131 Tutorial - Codeforces",
          "content": "Sorry for my poor English, this blog will be corrected soon.214A - System of EquationsSolution for this problem — just go through the possible pairs of numbers and check them for correctness. We can do that in any way. 214B - HometaskNuber is divisible by 2,3,5 only if sum of the digits is divisible by 3 and last digit is 0, so if we havent 0 in our set answer is -1, otherwise solution exists(we can return 0 as solution). A further solution — analysis of the cases.Lets sort all didgits in nonincreasing order. If sum of all digits is divisible by 3 — answer is our set of digits(without spaces ofcourse :) ). If modulo equals 1 — we must delete minimum digit from out set with modulo after division by 3 equals 1, if we haven't such we must delete 2 minimal digits with modulo after division by 3 equals 2. If we have modulo equals 2 — we have identical case.Also we must remember that we cannot use leading zeros. In case when we have more then one 0 and no another digit we must print only one zero.213A - GameSolution — Greedy.Lets our computers settled on circle, and moves (1->2, 2->3, 3->1) will be steps \"forward\", and moves (1->3,3->2,2->1) will steps \"back\". Note that \"back\" moves is not optimal, as we can make two moves \"forward\" that is identical in time. We will look over all starts. Further, we will go by circle while we not complited all game. For every level we will remember number ne[i] — count of another level that \"direct\" need for it. We will complited levels with ne[i]=0 and update all ne[i] that we must. It can be implemented with O(n^3) time.213B - NumbersSolution — dynamic programming.Look over for length of the number that we will build. Further, we will use DP f(len,i) — how many numbers with length len we can make with digits i..9.Recount:- f(len,0) = sum(f(len-i,1)*C(len-1,i), i=a[0]..len);- f(len,j) = sum(f(len-i,j+1)*C(len,i), i=a[j]..len), 0<j<9;- f(len,9) = 1, если len>=a[9], 0 если len<a[9].C(n,k) — binomial coefficient.213C - Relay RaceSolution — dynamic programming.Note, that we can make 2 pathes form cell (1,1) to cell (n,n).Note, that after each move our cells will be located on the same diagonal.We will solve the problem with DP f(d,i1,i2), d — diagonal number, i1 — 1st coordinate 1st path, i2 — 1st coordinate 2nd path. It is clear that we can calculate 2nd coordinate when we know number of the diagonal and 1st coordinate. Recount — obvious, we make all 4 transition, and if pathes are intersected in temporary point, we add value of the cell only one, otherwise we add both values of the cells. We can imlement this solution with O(n^2) memory if we will rewrite array of DP after increasing of diagonal number. Also we must remember that answer can be lower then 0. 213D - StarsI present solution as few pictures:https://get.google.com/albumarchive/pwa/115317317397602031319/Solutions131Implementation.We have only one difficult moment — how to count coordinates? We can calculate them from regular pentagon, all that you need, you can read there.213E - Two PermutationsFor given two permutation we will make two another by next transformation: New_A[A[i]] = i, where New_A — news permutation, A — given permutation. Lets we get two permutation A and B. Now our problem is next: how many sub-arrays of length n are equals to firs permutation. Two arrays will be equal if after swaping every element with its number in sorted array obtained arrays will be element-wise equal.Further solution hashes, but we will use not only modulo 2^64, we will use some big modulos, but they must be smaller then 2^32-1.Lets step[i] = 1000003^i.Lets F(A) = num[1]*step[1] + num[2]*step[2] + ... + num[n]*step[n], where num[i] — number of the element A[i] in sorted array.If we will compare arrays, we can use this function. But it can be very big, so we will count it by modulos.So now our problem is to calculate F function to every subarray. Lets look what will change after adding/deleting some elent from set: some element from num array willnot change, and some will become grater after adding, and become lower after deleting. So we must use some interval-tree to recount our F function. We need to know sum of step[i] on some interval of added numbers and count of elements on some interval. Uses this information we can simply recount out function. Also we must remember that after adding element with coeficinet step[i], where i>n and deleting some previos element our function will become grater that we need. So we will multiple hash of first array by 1000003 to avoid this issue.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/4982",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 213\\s*E"
          },
          "content_length": 4543
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #131 - Codeforces - Code 1",
          "code": "int n = 300;\nfprintf(stdout, \"%d\\n\", n);\nfor (int i = 0; i < n; i++)\n    for (int c = 0; c < n; c++)\n        fprintf(stdout, \"%d%c\", ((i + c == 580) ? -1 : 0), c + 1 == n ? '\\n' : ' ');",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4965",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #131 - Codeforces - Code 2",
          "code": "int n = 300;\nfprintf(stdout, \"%d\\n\", n);\nfor (int i = 0; i < n; i++)\n    for (int c = 0; c < n; c++)\n        fprintf(stdout, \"%d%c\", ((i + c == 580) ? -1 : 0), c + 1 == n ? '\\n' : ' ');",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4965",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #131 - Codeforces - Code 3",
          "code": "Comb[len - 1][j]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4965",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #131 Tutorial - Codeforces - Code 1",
          "code": "(a-b)(a+b-1)=n-m",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4982",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 200000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(n, 200000, \"m\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, 1, n, \"a_i\");\n    inf.readEoln();\n\n    set<int> set_a(a.begin(), a.end());\n    ensuref((int)set_a.size() == n, \"Array 'a' must contain n distinct elements\");\n\n    vector<int> b = inf.readInts(m, 1, m, \"b_i\");\n    inf.readEoln();\n\n    set<int> set_b(b.begin(), b.end());\n    ensuref((int)set_b.size() == m, \"Array 'b' must contain m distinct elements\");\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 200000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(n, 200000, \"m\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, 1, n, \"a_i\");\n    inf.readEoln();\n\n    set<int> set_a(a.begin(), a.end());\n    ensuref((int)set_a.size() == n, \"Array 'a' must contain n distinct elements\");\n\n    vector<int> b = inf.readInts(m, 1, m, \"b_i\");\n    inf.readEoln();\n\n    set<int> set_b(b.begin(), b.end());\n    ensuref((int)set_b.size() == m, \"Array 'b' must contain m distinct elements\");\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 200000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(n, 200000, \"m\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, 1, n, \"a_i\");\n    inf.readEoln();\n\n    set<int> set_a(a.begin(), a.end());\n    ensuref((int)set_a.size() == n, \"Array 'a' must contain n distinct elements\");\n\n    vector<int> b = inf.readInts(m, 1, m, \"b_i\");\n    inf.readEoln();\n\n    set<int> set_b(b.begin(), b.end());\n    ensuref((int)set_b.size() == m, \"Array 'b' must contain m distinct elements\");\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    int type = opt<int>(\"type\", 1);\n\n    vector<int> a(n), b(m);\n\n    if (type == 1) {\n        // Both a and b are random permutations\n        for(int i=0; i<n; ++i) a[i] = i+1;\n        shuffle(a.begin(), a.end());\n\n        for(int i=0; i<m; ++i) b[i] = i+1;\n        shuffle(b.begin(), b.end());\n    }\n    else if (type == 2) {\n        // a and b are identical random permutations (n == m)\n        if (n != m) {\n            n = m = min(n, m);\n            a.resize(n);\n            b.resize(m);\n        }\n        for(int i = 0; i < n; ++i) a[i] = i + 1;\n        shuffle(a.begin(), a.end());\n        b = a;\n    }\n    else if (type == 3) {\n        // a is increasing, b is random permutation\n        for(int i=0; i<n; ++i) a[i] = i+1;\n        for(int i=0; i<m; ++i) b[i] = i+1;\n        shuffle(b.begin(), b.end());\n    }\n    else if (type == 4) {\n        // a is random permutation, b is increasing\n        for(int i=0; i<n; ++i) a[i] = i+1;\n        shuffle(a.begin(), a.end());\n        for(int i=0; i<m; ++i) b[i] = i+1;\n    }\n    else if (type == 5) {\n        // a is reverse of b\n        if (n != m) {\n            n = m = min(n, m);\n            a.resize(n);\n            b.resize(m);\n        }\n        for(int i=0; i<n; ++i) a[i] = i+1;\n        b = a;\n        reverse(b.begin(), b.end());\n    }\n    else if (type ==6) {\n        // a + d is a subsequence of b\n        int d = opt<int>(\"d\", 0);\n        // Generate random permutation for b\n        for(int i=0; i<m; ++i) b[i] = i+1;\n        shuffle(b.begin(), b.end());\n        // Select n positions in b to correspond to a + d\n        vector<int> positions(m);\n        for(int i=0; i<m; ++i) positions[i] = i;\n        shuffle(positions.begin(), positions.end());\n        sort(positions.begin(), positions.begin()+n);\n        set<int> used; // To ensure a is a permutation\n        for(int i=0; i<n; ++i) {\n            int bi = b[positions[i]];\n            int ai = bi - d;\n            if(ai < 1 || ai > n || used.count(ai)) {\n                // Generate a number not used yet\n                do {\n                    ai = rnd.next(1, n);\n                } while(used.count(ai));\n            }\n            a[i] = ai;\n            used.insert(ai);\n        }\n        // For the rest of a (if any), fill with unused numbers\n        for(int i=used.size(); i<n; ++i) {\n            int ai;\n            do {\n                ai = rnd.next(1, n);\n            } while(used.count(ai));\n            a[i] = ai;\n            used.insert(ai);\n        }\n        shuffle(a.begin(), a.end());\n    }\n    else {\n        // Default: Both a and b are random permutations\n        for(int i=0; i<n; ++i) a[i] = i+1;\n        shuffle(a.begin(), a.end());\n        for(int i=0; i<m; ++i) b[i] = i+1;\n        shuffle(b.begin(), b.end());\n    }\n\n    // Output n and m\n    printf(\"%d %d\\n\", n, m);\n    // Output permutation a\n    for(int i=0; i<n; ++i)\n        printf(\"%d%c\", a[i], i+1<n?' ':'\\n');\n    // Output permutation b\n    for(int i=0; i<m; ++i)\n        printf(\"%d%c\", b[i], i+1<m?' ':'\\n');\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    int type = opt<int>(\"type\", 1);\n\n    vector<int> a(n), b(m);\n\n    if (type == 1) {\n        // Both a and b are random permutations\n        for(int i=0; i<n; ++i) a[i] = i+1;\n        shuffle(a.begin(), a.end());\n\n        for(int i=0; i<m; ++i) b[i] = i+1;\n        shuffle(b.begin(), b.end());\n    }\n    else if (type == 2) {\n        // a and b are identical random permutations (n == m)\n        if (n != m) {\n            n = m = min(n, m);\n            a.resize(n);\n            b.resize(m);\n        }\n        for(int i = 0; i < n; ++i) a[i] = i + 1;\n        shuffle(a.begin(), a.end());\n        b = a;\n    }\n    else if (type == 3) {\n        // a is increasing, b is random permutation\n        for(int i=0; i<n; ++i) a[i] = i+1;\n        for(int i=0; i<m; ++i) b[i] = i+1;\n        shuffle(b.begin(), b.end());\n    }\n    else if (type == 4) {\n        // a is random permutation, b is increasing\n        for(int i=0; i<n; ++i) a[i] = i+1;\n        shuffle(a.begin(), a.end());\n        for(int i=0; i<m; ++i) b[i] = i+1;\n    }\n    else if (type == 5) {\n        // a is reverse of b\n        if (n != m) {\n            n = m = min(n, m);\n            a.resize(n);\n            b.resize(m);\n        }\n        for(int i=0; i<n; ++i) a[i] = i+1;\n        b = a;\n        reverse(b.begin(), b.end());\n    }\n    else if (type ==6) {\n        // a + d is a subsequence of b\n        int d = opt<int>(\"d\", 0);\n        // Generate random permutation for b\n        for(int i=0; i<m; ++i) b[i] = i+1;\n        shuffle(b.begin(), b.end());\n        // Select n positions in b to correspond to a + d\n        vector<int> positions(m);\n        for(int i=0; i<m; ++i) positions[i] = i;\n        shuffle(positions.begin(), positions.end());\n        sort(positions.begin(), positions.begin()+n);\n        set<int> used; // To ensure a is a permutation\n        for(int i=0; i<n; ++i) {\n            int bi = b[positions[i]];\n            int ai = bi - d;\n            if(ai < 1 || ai > n || used.count(ai)) {\n                // Generate a number not used yet\n                do {\n                    ai = rnd.next(1, n);\n                } while(used.count(ai));\n            }\n            a[i] = ai;\n            used.insert(ai);\n        }\n        // For the rest of a (if any), fill with unused numbers\n        for(int i=used.size(); i<n; ++i) {\n            int ai;\n            do {\n                ai = rnd.next(1, n);\n            } while(used.count(ai));\n            a[i] = ai;\n            used.insert(ai);\n        }\n        shuffle(a.begin(), a.end());\n    }\n    else {\n        // Default: Both a and b are random permutations\n        for(int i=0; i<n; ++i) a[i] = i+1;\n        shuffle(a.begin(), a.end());\n        for(int i=0; i<m; ++i) b[i] = i+1;\n        shuffle(b.begin(), b.end());\n    }\n\n    // Output n and m\n    printf(\"%d %d\\n\", n, m);\n    // Output permutation a\n    for(int i=0; i<n; ++i)\n        printf(\"%d%c\", a[i], i+1<n?' ':'\\n');\n    // Output permutation b\n    for(int i=0; i<m; ++i)\n        printf(\"%d%c\", b[i], i+1<m?' ':'\\n');\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -m 1 -type 1\n./gen -n 1 -m 1 -type 2\n./gen -n 2 -m 2 -type 2\n./gen -n 5 -m 5 -type 2\n./gen -n 5 -m 5 -type 5\n./gen -n 10 -m 10 -type 3\n./gen -n 10 -m 20 -type 4\n./gen -n 10 -m 10 -type 5\n./gen -n 50 -m 50 -type 1\n./gen -n 100 -m 200 -type 1\n./gen -n 1000 -m 1000 -type 2\n./gen -n 10000 -m 10000 -type 3\n./gen -n 50000 -m 100000 -type 4\n./gen -n 200000 -m 200000 -type 5\n./gen -n 200000 -m 200000 -type 1\n./gen -n 50000 -m 100000 -type 6 -d 10\n./gen -n 50000 -m 100000 -type 6 -d -100\n./gen -n 1 -m 200000 -type 3\n./gen -n 200000 -m 200000 -type 3\n./gen -n 2 -m 2 -type 5\n./gen -n 200000 -m 200000 -type 6 -d 0\n./gen -n 100 -m 100 -type 5\n./gen -n 150000 -m 200000 -type 1\n./gen -n 100 -m 200000 -type 6 -d 1\n./gen -n 200000 -m 200000 -type 6 -d -1\n./gen -n 1 -m 200000 -type 1\n./gen -n 199999 -m 200000 -type 2\n./gen -n 100000 -m 200000 -type 4\n./gen -n 200000 -m 200000 -type 2\n./gen -n 200000 -m 200000 -type 5\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T19:49:38.426887",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "214/A",
      "title": "A. System of Equations",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputA single line contains two integers n, m (1 ≤ n, m ≤ 1000) — the parameters of the system. The numbers on the line are separated by a space.",
      "output_spec": "OutputOn a single line print the answer to the problem.",
      "sample_tests": "ExamplesInputCopy9 3OutputCopy1InputCopy14 28OutputCopy1InputCopy4 20OutputCopy0",
      "description": "A. System of Equations\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputA single line contains two integers n, m (1 ≤ n, m ≤ 1000) — the parameters of the system. The numbers on the line are separated by a space.\n\nOutputOn a single line print the answer to the problem.\n\nInputCopy9 3OutputCopy1InputCopy14 28OutputCopy1InputCopy4 20OutputCopy0\n\nInputCopy9 3\n\nOutputCopy1\n\nInputCopy14 28\n\nOutputCopy1\n\nInputCopy4 20\n\nOutputCopy0\n\nNoteIn the first sample the suitable pair is integers (3, 0). In the second sample the suitable pair is integers (3, 5). In the third sample there is no suitable pair.",
      "solutions": [
        {
          "title": "Codeforces Round #131 - Codeforces",
          "content": "Hello everybody!Welcome all to Codeforces Round #131, which will be held on Monday, 30th of July at 19:30 MSK. I am (Sergey Nagin) an author of the problems. This will be my First Codeforces round and I hope it won't be the last one :).I would like to thank Mike Mirzayanov(MikeMirzayanov) who made this contest possible, Roman Furko(Furko) and Gerald Agapov(Gerald) for helping to prepare this round and Maria Belova(Delinur) for the translation of problem statements into English. I hope that problems will be interesting for you.Good luck!Problems’ point values in Division 1 are 1000-1000-1500-2000-2500. Problems’ point values in Division 2 are 500-1000-2000-2000-2500.I strongly recommend you to read ALL the problems.The contest is over! Congratulations' to winners!First division:1 place: Egor2 place: Petr3 place: touristSecond division:1 place: antimatter2 place: c1753533 place: takaramono I hope, that problems were interesting for you.You can view tutorial. Some personal information. This year I finished school and I will go to university. I study programming during almost five years. In addition to computer science, I like sports: powerlifting, arm wrestling and swimming.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/4965",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1190
        },
        {
          "title": "Codeforces Round #131 Tutorial - Codeforces",
          "content": "Sorry for my poor English, this blog will be corrected soon.214A - System of EquationsSolution for this problem — just go through the possible pairs of numbers and check them for correctness. We can do that in any way. 214B - HometaskNuber is divisible by 2,3,5 only if sum of the digits is divisible by 3 and last digit is 0, so if we havent 0 in our set answer is -1, otherwise solution exists(we can return 0 as solution). A further solution — analysis of the cases.Lets sort all didgits in nonincreasing order. If sum of all digits is divisible by 3 — answer is our set of digits(without spaces ofcourse :) ). If modulo equals 1 — we must delete minimum digit from out set with modulo after division by 3 equals 1, if we haven't such we must delete 2 minimal digits with modulo after division by 3 equals 2. If we have modulo equals 2 — we have identical case.Also we must remember that we cannot use leading zeros. In case when we have more then one 0 and no another digit we must print only one zero.213A - GameSolution — Greedy.Lets our computers settled on circle, and moves (1->2, 2->3, 3->1) will be steps \"forward\", and moves (1->3,3->2,2->1) will steps \"back\". Note that \"back\" moves is not optimal, as we can make two moves \"forward\" that is identical in time. We will look over all starts. Further, we will go by circle while we not complited all game. For every level we will remember number ne[i] — count of another level that \"direct\" need for it. We will complited levels with ne[i]=0 and update all ne[i] that we must. It can be implemented with O(n^3) time.213B - NumbersSolution — dynamic programming.Look over for length of the number that we will build. Further, we will use DP f(len,i) — how many numbers with length len we can make with digits i..9.Recount:- f(len,0) = sum(f(len-i,1)*C(len-1,i), i=a[0]..len);- f(len,j) = sum(f(len-i,j+1)*C(len,i), i=a[j]..len), 0<j<9;- f(len,9) = 1, если len>=a[9], 0 если len<a[9].C(n,k) — binomial coefficient.213C - Relay RaceSolution — dynamic programming.Note, that we can make 2 pathes form cell (1,1) to cell (n,n).Note, that after each move our cells will be located on the same diagonal.We will solve the problem with DP f(d,i1,i2), d — diagonal number, i1 — 1st coordinate 1st path, i2 — 1st coordinate 2nd path. It is clear that we can calculate 2nd coordinate when we know number of the diagonal and 1st coordinate. Recount — obvious, we make all 4 transition, and if pathes are intersected in temporary point, we add value of the cell only one, otherwise we add both values of the cells. We can imlement this solution with O(n^2) memory if we will rewrite array of DP after increasing of diagonal number. Also we must remember that answer can be lower then 0. 213D - StarsI present solution as few pictures:https://get.google.com/albumarchive/pwa/115317317397602031319/Solutions131Implementation.We have only one difficult moment — how to count coordinates? We can calculate them from regular pentagon, all that you need, you can read there.213E - Two PermutationsFor given two permutation we will make two another by next transformation: New_A[A[i]] = i, where New_A — news permutation, A — given permutation. Lets we get two permutation A and B. Now our problem is next: how many sub-arrays of length n are equals to firs permutation. Two arrays will be equal if after swaping every element with its number in sorted array obtained arrays will be element-wise equal.Further solution hashes, but we will use not only modulo 2^64, we will use some big modulos, but they must be smaller then 2^32-1.Lets step[i] = 1000003^i.Lets F(A) = num[1]*step[1] + num[2]*step[2] + ... + num[n]*step[n], where num[i] — number of the element A[i] in sorted array.If we will compare arrays, we can use this function. But it can be very big, so we will count it by modulos.So now our problem is to calculate F function to every subarray. Lets look what will change after adding/deleting some elent from set: some element from num array willnot change, and some will become grater after adding, and become lower after deleting. So we must use some interval-tree to recount our F function. We need to know sum of step[i] on some interval of added numbers and count of elements on some interval. Uses this information we can simply recount out function. Also we must remember that after adding element with coeficinet step[i], where i>n and deleting some previos element our function will become grater that we need. So we will multiple hash of first array by 1000003 to avoid this issue.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/4982",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 214\\s*A"
          },
          "content_length": 4543
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #131 - Codeforces - Code 1",
          "code": "int n = 300;\nfprintf(stdout, \"%d\\n\", n);\nfor (int i = 0; i < n; i++)\n    for (int c = 0; c < n; c++)\n        fprintf(stdout, \"%d%c\", ((i + c == 580) ? -1 : 0), c + 1 == n ? '\\n' : ' ');",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4965",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #131 - Codeforces - Code 2",
          "code": "int n = 300;\nfprintf(stdout, \"%d\\n\", n);\nfor (int i = 0; i < n; i++)\n    for (int c = 0; c < n; c++)\n        fprintf(stdout, \"%d%c\", ((i + c == 580) ? -1 : 0), c + 1 == n ? '\\n' : ' ');",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4965",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #131 - Codeforces - Code 3",
          "code": "Comb[len - 1][j]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4965",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #131 Tutorial - Codeforces - Code 1",
          "code": "(a-b)(a+b-1)=n-m",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4982",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 1000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 1000, \"m\");\n    inf.readEoln();\n\n    inf.readEof();\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 1000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 1000, \"m\");\n    inf.readEoln();\n\n    inf.readEof();\n\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 1000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 1000, \"m\");\n    inf.readEoln();\n\n    inf.readEof();\n\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAXN = 1000;\n\nint cnt[MAXN + 1][MAXN + 1];\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    string type = opt<string>(\"type\", \"random\");\n    int maxn = opt<int>(\"maxn\", 1000);\n\n    // Precompute counts of solutions for each (n, m)\n    memset(cnt, 0, sizeof(cnt));\n    for (int a = 0; a * a <= maxn; ++a) {\n        for (int b = 0; b <= maxn; ++b) {\n            int n = a * a + b;\n            int m = a + b * b;\n            if (1 <= n && n <= maxn && 1 <= m && m <= maxn) {\n                cnt[n][m]++;\n            }\n        }\n    }\n\n    int n = 0, m = 0;\n\n    if (type == \"random\") {\n        // Generate random n and m within [1, maxn]\n        n = rnd.next(1, maxn);\n        m = rnd.next(1, maxn);\n    } else if (type == \"no_solution\") {\n        // Randomly select n and m such that there is no solution\n        vector<pair<int, int>> nosol;\n        for (int tn = 1; tn <= maxn; ++tn) {\n            for (int tm = 1; tm <= maxn; ++tm) {\n                if (cnt[tn][tm] == 0) {\n                    nosol.push_back({tn, tm});\n                }\n            }\n        }\n        if (!nosol.empty()) {\n            int idx = rnd.next(0, (int)nosol.size() - 1);\n            n = nosol[idx].first;\n            m = nosol[idx].second;\n        } else {\n            // Should not happen with given constraints\n            n = maxn;\n            m = maxn;\n        }\n    } else if (type == \"one_solution\") {\n        // Randomly select n and m such that there is exactly one solution\n        vector<pair<int, int>> onesol;\n        for (int tn = 1; tn <= maxn; ++tn) {\n            for (int tm = 1; tm <= maxn; ++tm) {\n                if (cnt[tn][tm] == 1) {\n                    onesol.push_back({tn, tm});\n                }\n            }\n        }\n        if (!onesol.empty()) {\n            int idx = rnd.next(0, (int)onesol.size() - 1);\n            n = onesol[idx].first;\n            m = onesol[idx].second;\n        } else {\n            n = maxn;\n            m = maxn;\n        }\n    } else if (type == \"many_solutions\") {\n        // Find n and m with the maximum number of solutions\n        int max_cnt = 0;\n        vector<pair<int, int>> maxsol;\n        for (int tn = 1; tn <= maxn; ++tn) {\n            for (int tm = 1; tm <= maxn; ++tm) {\n                if (cnt[tn][tm] > max_cnt) {\n                    max_cnt = cnt[tn][tm];\n                }\n            }\n        }\n        for (int tn = 1; tn <= maxn; ++tn) {\n            for (int tm = 1; tm <= maxn; ++tm) {\n                if (cnt[tn][tm] == max_cnt) {\n                    maxsol.push_back({tn, tm});\n                }\n            }\n        }\n        int idx = rnd.next(0, (int)maxsol.size() - 1);\n        n = maxsol[idx].first;\n        m = maxsol[idx].second;\n    } else if (type == \"edge_zero\") {\n        // Generate n and m where a or b is zero\n        int a_or_b = rnd.next(0, 1); // 0 for a=0, 1 for b=0\n        if (a_or_b == 0) {\n            // a = 0\n            int b = rnd.next(0, min(31, maxn));\n            n = 0 + b;\n            m = 0 + b * b;\n        } else {\n            // b = 0\n            int a = rnd.next(0, min(31, maxn));\n            n = a * a + 0;\n            m = a + 0;\n        }\n        if (n < 1 || n > maxn || m < 1 || m > maxn) {\n            n = 1;\n            m = 1;\n        }\n    } else if (type == \"max_values\") {\n        // Set n and m to their maximum values\n        n = maxn;\n        m = maxn;\n    } else {\n        // Default to random\n        n = rnd.next(1, maxn);\n        m = rnd.next(1, maxn);\n    }\n\n    // Output n and m\n    printf(\"%d %d\\n\", n, m);\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAXN = 1000;\n\nint cnt[MAXN + 1][MAXN + 1];\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    string type = opt<string>(\"type\", \"random\");\n    int maxn = opt<int>(\"maxn\", 1000);\n\n    // Precompute counts of solutions for each (n, m)\n    memset(cnt, 0, sizeof(cnt));\n    for (int a = 0; a * a <= maxn; ++a) {\n        for (int b = 0; b <= maxn; ++b) {\n            int n = a * a + b;\n            int m = a + b * b;\n            if (1 <= n && n <= maxn && 1 <= m && m <= maxn) {\n                cnt[n][m]++;\n            }\n        }\n    }\n\n    int n = 0, m = 0;\n\n    if (type == \"random\") {\n        // Generate random n and m within [1, maxn]\n        n = rnd.next(1, maxn);\n        m = rnd.next(1, maxn);\n    } else if (type == \"no_solution\") {\n        // Randomly select n and m such that there is no solution\n        vector<pair<int, int>> nosol;\n        for (int tn = 1; tn <= maxn; ++tn) {\n            for (int tm = 1; tm <= maxn; ++tm) {\n                if (cnt[tn][tm] == 0) {\n                    nosol.push_back({tn, tm});\n                }\n            }\n        }\n        if (!nosol.empty()) {\n            int idx = rnd.next(0, (int)nosol.size() - 1);\n            n = nosol[idx].first;\n            m = nosol[idx].second;\n        } else {\n            // Should not happen with given constraints\n            n = maxn;\n            m = maxn;\n        }\n    } else if (type == \"one_solution\") {\n        // Randomly select n and m such that there is exactly one solution\n        vector<pair<int, int>> onesol;\n        for (int tn = 1; tn <= maxn; ++tn) {\n            for (int tm = 1; tm <= maxn; ++tm) {\n                if (cnt[tn][tm] == 1) {\n                    onesol.push_back({tn, tm});\n                }\n            }\n        }\n        if (!onesol.empty()) {\n            int idx = rnd.next(0, (int)onesol.size() - 1);\n            n = onesol[idx].first;\n            m = onesol[idx].second;\n        } else {\n            n = maxn;\n            m = maxn;\n        }\n    } else if (type == \"many_solutions\") {\n        // Find n and m with the maximum number of solutions\n        int max_cnt = 0;\n        vector<pair<int, int>> maxsol;\n        for (int tn = 1; tn <= maxn; ++tn) {\n            for (int tm = 1; tm <= maxn; ++tm) {\n                if (cnt[tn][tm] > max_cnt) {\n                    max_cnt = cnt[tn][tm];\n                }\n            }\n        }\n        for (int tn = 1; tn <= maxn; ++tn) {\n            for (int tm = 1; tm <= maxn; ++tm) {\n                if (cnt[tn][tm] == max_cnt) {\n                    maxsol.push_back({tn, tm});\n                }\n            }\n        }\n        int idx = rnd.next(0, (int)maxsol.size() - 1);\n        n = maxsol[idx].first;\n        m = maxsol[idx].second;\n    } else if (type == \"edge_zero\") {\n        // Generate n and m where a or b is zero\n        int a_or_b = rnd.next(0, 1); // 0 for a=0, 1 for b=0\n        if (a_or_b == 0) {\n            // a = 0\n            int b = rnd.next(0, min(31, maxn));\n            n = 0 + b;\n            m = 0 + b * b;\n        } else {\n            // b = 0\n            int a = rnd.next(0, min(31, maxn));\n            n = a * a + 0;\n            m = a + 0;\n        }\n        if (n < 1 || n > maxn || m < 1 || m > maxn) {\n            n = 1;\n            m = 1;\n        }\n    } else if (type == \"max_values\") {\n        // Set n and m to their maximum values\n        n = maxn;\n        m = maxn;\n    } else {\n        // Default to random\n        n = rnd.next(1, maxn);\n        m = rnd.next(1, maxn);\n    }\n\n    // Output n and m\n    printf(\"%d %d\\n\", n, m);\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -type random\n./gen -type random\n./gen -type random\n\n./gen -type random -maxn 10\n./gen -type random -maxn 100\n./gen -type random -maxn 500\n\n./gen -type max_values\n\n./gen -type one_solution\n./gen -type many_solutions\n./gen -type no_solution\n\n./gen -type one_solution -maxn 10\n./gen -type many_solutions -maxn 10\n./gen -type no_solution -maxn 10\n\n./gen -type one_solution -maxn 100\n./gen -type many_solutions -maxn 100\n./gen -type no_solution -maxn 100\n\n./gen -type edge_zero\n./gen -type edge_zero\n./gen -type edge_zero\n\n./gen -type random -maxn 1\n./gen -type random -maxn 2\n\n./gen -type no_solution -maxn 1\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T19:49:40.548921",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "214/B",
      "title": "B. Hometask",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputA single line contains a single integer n (1 ≤ n ≤ 100000) — the number of digits in the set. The second line contains n digits, the digits are separated by a single space.",
      "output_spec": "OutputOn a single line print the answer to the problem. If such number does not exist, then you should print -1.",
      "sample_tests": "ExamplesInputCopy10OutputCopy0InputCopy113 4 5 4 5 3 5 3 4 4 0OutputCopy5554443330InputCopy83 2 5 1 5 2 2 3OutputCopy-1",
      "description": "B. Hometask\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputA single line contains a single integer n (1 ≤ n ≤ 100000) — the number of digits in the set. The second line contains n digits, the digits are separated by a single space.\n\nOutputOn a single line print the answer to the problem. If such number does not exist, then you should print -1.\n\nInputCopy10OutputCopy0InputCopy113 4 5 4 5 3 5 3 4 4 0OutputCopy5554443330InputCopy83 2 5 1 5 2 2 3OutputCopy-1\n\nInputCopy10\n\nOutputCopy0\n\nInputCopy113 4 5 4 5 3 5 3 4 4 0\n\nOutputCopy5554443330\n\nInputCopy83 2 5 1 5 2 2 3\n\nOutputCopy-1\n\nNoteIn the first sample there is only one number you can make — 0. In the second sample the sought number is 5554443330. In the third sample it is impossible to make the required number.",
      "solutions": [
        {
          "title": "Codeforces Round #131 - Codeforces",
          "content": "Hello everybody!Welcome all to Codeforces Round #131, which will be held on Monday, 30th of July at 19:30 MSK. I am (Sergey Nagin) an author of the problems. This will be my First Codeforces round and I hope it won't be the last one :).I would like to thank Mike Mirzayanov(MikeMirzayanov) who made this contest possible, Roman Furko(Furko) and Gerald Agapov(Gerald) for helping to prepare this round and Maria Belova(Delinur) for the translation of problem statements into English. I hope that problems will be interesting for you.Good luck!Problems’ point values in Division 1 are 1000-1000-1500-2000-2500. Problems’ point values in Division 2 are 500-1000-2000-2000-2500.I strongly recommend you to read ALL the problems.The contest is over! Congratulations' to winners!First division:1 place: Egor2 place: Petr3 place: touristSecond division:1 place: antimatter2 place: c1753533 place: takaramono I hope, that problems were interesting for you.You can view tutorial. Some personal information. This year I finished school and I will go to university. I study programming during almost five years. In addition to computer science, I like sports: powerlifting, arm wrestling and swimming.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/4965",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1190
        },
        {
          "title": "Codeforces Round #131 Tutorial - Codeforces",
          "content": "Sorry for my poor English, this blog will be corrected soon.214A - System of EquationsSolution for this problem — just go through the possible pairs of numbers and check them for correctness. We can do that in any way. 214B - HometaskNuber is divisible by 2,3,5 only if sum of the digits is divisible by 3 and last digit is 0, so if we havent 0 in our set answer is -1, otherwise solution exists(we can return 0 as solution). A further solution — analysis of the cases.Lets sort all didgits in nonincreasing order. If sum of all digits is divisible by 3 — answer is our set of digits(without spaces ofcourse :) ). If modulo equals 1 — we must delete minimum digit from out set with modulo after division by 3 equals 1, if we haven't such we must delete 2 minimal digits with modulo after division by 3 equals 2. If we have modulo equals 2 — we have identical case.Also we must remember that we cannot use leading zeros. In case when we have more then one 0 and no another digit we must print only one zero.213A - GameSolution — Greedy.Lets our computers settled on circle, and moves (1->2, 2->3, 3->1) will be steps \"forward\", and moves (1->3,3->2,2->1) will steps \"back\". Note that \"back\" moves is not optimal, as we can make two moves \"forward\" that is identical in time. We will look over all starts. Further, we will go by circle while we not complited all game. For every level we will remember number ne[i] — count of another level that \"direct\" need for it. We will complited levels with ne[i]=0 and update all ne[i] that we must. It can be implemented with O(n^3) time.213B - NumbersSolution — dynamic programming.Look over for length of the number that we will build. Further, we will use DP f(len,i) — how many numbers with length len we can make with digits i..9.Recount:- f(len,0) = sum(f(len-i,1)*C(len-1,i), i=a[0]..len);- f(len,j) = sum(f(len-i,j+1)*C(len,i), i=a[j]..len), 0<j<9;- f(len,9) = 1, если len>=a[9], 0 если len<a[9].C(n,k) — binomial coefficient.213C - Relay RaceSolution — dynamic programming.Note, that we can make 2 pathes form cell (1,1) to cell (n,n).Note, that after each move our cells will be located on the same diagonal.We will solve the problem with DP f(d,i1,i2), d — diagonal number, i1 — 1st coordinate 1st path, i2 — 1st coordinate 2nd path. It is clear that we can calculate 2nd coordinate when we know number of the diagonal and 1st coordinate. Recount — obvious, we make all 4 transition, and if pathes are intersected in temporary point, we add value of the cell only one, otherwise we add both values of the cells. We can imlement this solution with O(n^2) memory if we will rewrite array of DP after increasing of diagonal number. Also we must remember that answer can be lower then 0. 213D - StarsI present solution as few pictures:https://get.google.com/albumarchive/pwa/115317317397602031319/Solutions131Implementation.We have only one difficult moment — how to count coordinates? We can calculate them from regular pentagon, all that you need, you can read there.213E - Two PermutationsFor given two permutation we will make two another by next transformation: New_A[A[i]] = i, where New_A — news permutation, A — given permutation. Lets we get two permutation A and B. Now our problem is next: how many sub-arrays of length n are equals to firs permutation. Two arrays will be equal if after swaping every element with its number in sorted array obtained arrays will be element-wise equal.Further solution hashes, but we will use not only modulo 2^64, we will use some big modulos, but they must be smaller then 2^32-1.Lets step[i] = 1000003^i.Lets F(A) = num[1]*step[1] + num[2]*step[2] + ... + num[n]*step[n], where num[i] — number of the element A[i] in sorted array.If we will compare arrays, we can use this function. But it can be very big, so we will count it by modulos.So now our problem is to calculate F function to every subarray. Lets look what will change after adding/deleting some elent from set: some element from num array willnot change, and some will become grater after adding, and become lower after deleting. So we must use some interval-tree to recount our F function. We need to know sum of step[i] on some interval of added numbers and count of elements on some interval. Uses this information we can simply recount out function. Also we must remember that after adding element with coeficinet step[i], where i>n and deleting some previos element our function will become grater that we need. So we will multiple hash of first array by 1000003 to avoid this issue.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/4982",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 214\\s*B"
          },
          "content_length": 4543
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #131 - Codeforces - Code 1",
          "code": "int n = 300;\nfprintf(stdout, \"%d\\n\", n);\nfor (int i = 0; i < n; i++)\n    for (int c = 0; c < n; c++)\n        fprintf(stdout, \"%d%c\", ((i + c == 580) ? -1 : 0), c + 1 == n ? '\\n' : ' ');",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4965",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #131 - Codeforces - Code 2",
          "code": "int n = 300;\nfprintf(stdout, \"%d\\n\", n);\nfor (int i = 0; i < n; i++)\n    for (int c = 0; c < n; c++)\n        fprintf(stdout, \"%d%c\", ((i + c == 580) ? -1 : 0), c + 1 == n ? '\\n' : ' ');",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4965",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #131 - Codeforces - Code 3",
          "code": "Comb[len - 1][j]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4965",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #131 Tutorial - Codeforces - Code 1",
          "code": "(a-b)(a+b-1)=n-m",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4982",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n\n    for (int i = 1; i <= n; ++i) {\n        int d = inf.readInt(0, 9, \"digit\");\n        if (i < n)\n            inf.readChar(' '); // Ensure single space between digits\n        else\n            inf.readEoln(); // End of line after last digit\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n\n    for (int i = 1; i <= n; ++i) {\n        int d = inf.readInt(0, 9, \"digit\");\n        if (i < n)\n            inf.readChar(' '); // Ensure single space between digits\n        else\n            inf.readEoln(); // End of line after last digit\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n\n    for (int i = 1; i <= n; ++i) {\n        int d = inf.readInt(0, 9, \"digit\");\n        if (i < n)\n            inf.readChar(' '); // Ensure single space between digits\n        else\n            inf.readEoln(); // End of line after last digit\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n#include <string>\r\n\r\nusing namespace std;\r\n\r\npattern pnum(\"0|-?[1-9][0-9]*\");\r\n\r\nbool isNumeric(const string &p) {\r\n    return pnum.matches(p);\r\n}\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare two signed huge integers\");\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    string ja = ans.readWord();\r\n    string pa = ouf.readWord();\r\n\r\n    if (!isNumeric(ja))\r\n        quitf(_fail, \"%s is not a valid integer\", compress(ja).c_str());\r\n\r\n    if (!ans.seekEof())\r\n        quitf(_fail, \"expected exactly one token in the answer file\");\r\n\r\n    if (!isNumeric(pa))\r\n        quitf(_pe, \"%s is not a valid integer\", compress(pa).c_str());\r\n\r\n    if (ja != pa)\r\n        quitf(_wa, \"expected '%s', found '%s'\", compress(ja).c_str(), compress(pa).c_str());\r\n\r\n    quitf(_ok, \"answer is '%s'\", compress(ja).c_str());\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> digits;\n\n    if (type == \"only0\") {\n        // Generate only zeros\n        digits.assign(n, 0);\n    } else if (type == \"only1\") {\n        // Generate only ones\n        digits.assign(n, 1);\n    } else if (type == \"impossible_no_zero\") {\n        // Generate digits without zero, so impossible to make number divisible by 10\n        for (int i = 0; i < n; ++i) {\n            digits.push_back(rnd.next(1, 9));\n        }\n    } else if (type == \"impossible_sum_not_div3\") {\n        // Generate digits such that sum is not divisible by 3\n        int sum_mod3 = 1; // We want sum modulo 3 to be 1\n        int digit = 4; // 4 mod 3 = 1\n        digits.assign(n, digit);\n    } else if (type == \"maxNumber\") {\n        // Generate the maximum possible number divisible by 30\n        if (n == 1) {\n            digits.push_back(0); // Only possible digit is 0\n        } else {\n            // Need at least one zero\n            digits.push_back(0);\n            // Fill the rest with 9s\n            for (int i = 1; i < n; ++i) {\n                digits.push_back(9);\n            }\n        }\n    } else if (type == \"random\") {\n        // Generate random digits between 0 and 9\n        for (int i = 0; i < n; ++i) {\n            digits.push_back(rnd.next(0, 9));\n        }\n    } else if (type == \"edgeZeros\") {\n        // Generate digits with random zeros\n        for (int i = 0; i < n; ++i) {\n            if (rnd.next(10) < 2) {\n                digits.push_back(0); // 20% chance to be zero\n            } else {\n                digits.push_back(rnd.next(1,9));\n            }\n        }\n    } else if (type == \"allDigits\") {\n        // Include all digits from 0 to 9 approximately equally\n        for (int i = 0; i < n; ++i) {\n            digits.push_back(i % 10);\n        }\n        shuffle(digits.begin(), digits.end());\n    } else if (type == \"singleDigit\") {\n        // All digits are the same\n        int digit = rnd.next(0,9);\n        digits.assign(n, digit);\n    } else if (type == \"maxNines\") {\n        // Maximize number of nines\n        digits.assign(n, 9);\n    } else if (type == \"minimal\") {\n        // Smallest number divisible by 30\n        digits = {0, 3, 6}; // Sum is 9\n        n = digits.size();\n    } else if (type == \"largePossible\") {\n        // Large number with digits making maximum possible number divisible by 30\n        int numZeros = max(1, n / 10); // At least one zero\n        int numDigits = n - numZeros;\n        // Start with 9s and adjust as needed\n        digits.resize(numDigits, 9);\n        digits.resize(n, 0); // Add zeros\n\n        // Adjust sum to be divisible by 3\n        int sumDigits = numDigits * 9;\n        int remainder = sumDigits % 3;\n        if (remainder != 0) {\n            for (int i = 0; i < numDigits; ++i) {\n                if ((digits[i] % 3) == remainder) {\n                    digits[i] -= 0; // Remove this digit or adjust if necessary\n                    break;\n                }\n            }\n        }\n        shuffle(digits.begin(), digits.end());\n    } else {\n        // Default to random digits\n        for (int i = 0; i < n; ++i) {\n            digits.push_back(rnd.next(0, 9));\n        }\n    }\n\n    // Output n and the digits\n    printf(\"%d\\n\", n);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d\", digits[i]);\n        if (i < n - 1) {\n            printf(\" \");\n        }\n    }\n    printf(\"\\n\");\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> digits;\n\n    if (type == \"only0\") {\n        // Generate only zeros\n        digits.assign(n, 0);\n    } else if (type == \"only1\") {\n        // Generate only ones\n        digits.assign(n, 1);\n    } else if (type == \"impossible_no_zero\") {\n        // Generate digits without zero, so impossible to make number divisible by 10\n        for (int i = 0; i < n; ++i) {\n            digits.push_back(rnd.next(1, 9));\n        }\n    } else if (type == \"impossible_sum_not_div3\") {\n        // Generate digits such that sum is not divisible by 3\n        int sum_mod3 = 1; // We want sum modulo 3 to be 1\n        int digit = 4; // 4 mod 3 = 1\n        digits.assign(n, digit);\n    } else if (type == \"maxNumber\") {\n        // Generate the maximum possible number divisible by 30\n        if (n == 1) {\n            digits.push_back(0); // Only possible digit is 0\n        } else {\n            // Need at least one zero\n            digits.push_back(0);\n            // Fill the rest with 9s\n            for (int i = 1; i < n; ++i) {\n                digits.push_back(9);\n            }\n        }\n    } else if (type == \"random\") {\n        // Generate random digits between 0 and 9\n        for (int i = 0; i < n; ++i) {\n            digits.push_back(rnd.next(0, 9));\n        }\n    } else if (type == \"edgeZeros\") {\n        // Generate digits with random zeros\n        for (int i = 0; i < n; ++i) {\n            if (rnd.next(10) < 2) {\n                digits.push_back(0); // 20% chance to be zero\n            } else {\n                digits.push_back(rnd.next(1,9));\n            }\n        }\n    } else if (type == \"allDigits\") {\n        // Include all digits from 0 to 9 approximately equally\n        for (int i = 0; i < n; ++i) {\n            digits.push_back(i % 10);\n        }\n        shuffle(digits.begin(), digits.end());\n    } else if (type == \"singleDigit\") {\n        // All digits are the same\n        int digit = rnd.next(0,9);\n        digits.assign(n, digit);\n    } else if (type == \"maxNines\") {\n        // Maximize number of nines\n        digits.assign(n, 9);\n    } else if (type == \"minimal\") {\n        // Smallest number divisible by 30\n        digits = {0, 3, 6}; // Sum is 9\n        n = digits.size();\n    } else if (type == \"largePossible\") {\n        // Large number with digits making maximum possible number divisible by 30\n        int numZeros = max(1, n / 10); // At least one zero\n        int numDigits = n - numZeros;\n        // Start with 9s and adjust as needed\n        digits.resize(numDigits, 9);\n        digits.resize(n, 0); // Add zeros\n\n        // Adjust sum to be divisible by 3\n        int sumDigits = numDigits * 9;\n        int remainder = sumDigits % 3;\n        if (remainder != 0) {\n            for (int i = 0; i < numDigits; ++i) {\n                if ((digits[i] % 3) == remainder) {\n                    digits[i] -= 0; // Remove this digit or adjust if necessary\n                    break;\n                }\n            }\n        }\n        shuffle(digits.begin(), digits.end());\n    } else {\n        // Default to random digits\n        for (int i = 0; i < n; ++i) {\n            digits.push_back(rnd.next(0, 9));\n        }\n    }\n\n    // Output n and the digits\n    printf(\"%d\\n\", n);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d\", digits[i]);\n        if (i < n - 1) {\n            printf(\" \");\n        }\n    }\n    printf(\"\\n\");\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -type only0\n./gen -n 1 -type only1\n./gen -n 2 -type impossible_no_zero\n./gen -n 3 -type impossible_sum_not_div3\n./gen -n 5 -type maxNumber\n./gen -n 10 -type maxNumber\n./gen -n 100000 -type maxNumber\n./gen -n 5 -type random\n./gen -n 100 -type random\n./gen -n 10000 -type random\n./gen -n 100000 -type random\n./gen -n 3 -type edgeZeros\n./gen -n 100000 -type edgeZeros\n./gen -n 10 -type allDigits\n./gen -n 1000 -type allDigits\n./gen -n 100000 -type singleDigit\n./gen -n 10000 -type maxNines\n./gen -n 3 -type minimal\n./gen -n 99999 -type largePossible\n./gen -n 1 -type impossible_no_zero\n./gen -n 100000 -type impossible_no_zero\n./gen -n 1 -type only0\n./gen -n 100000 -type only0\n./gen -n 1 -type only1\n./gen -n 100000 -type only1\n./gen -n 2 -type impossible_sum_not_div3\n./gen -n 99998 -type impossible_sum_not_div3\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T19:49:42.233016",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "214/C",
      "title": "C. Game",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains integer n (1 ≤ n ≤ 200) — the number of game parts. The next line contains n integers, the i-th integer — ci (1 ≤ ci ≤ 3) represents the number of the computer, on which you can complete the game part number i. Next n lines contain descriptions of game parts. The i-th line first contains integer ki (0 ≤ ki ≤ n - 1), then ki distinct integers ai, j (1 ≤ ai, j ≤ n; ai, j ≠ i) — the numbers of parts to complete before part i.Numbers on all lines are separated by single spaces. You can assume that the parts of the game are numbered from 1 to n in some way. It is guaranteed that there are no cyclic dependencies between the parts of the game.",
      "output_spec": "OutputOn a single line print the answer to the problem.",
      "sample_tests": "ExamplesInputCopy110OutputCopy1InputCopy52 2 1 1 31 52 5 12 5 41 50OutputCopy7",
      "description": "time limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains integer n (1 ≤ n ≤ 200) — the number of game parts. The next line contains n integers, the i-th integer — ci (1 ≤ ci ≤ 3) represents the number of the computer, on which you can complete the game part number i. Next n lines contain descriptions of game parts. The i-th line first contains integer ki (0 ≤ ki ≤ n - 1), then ki distinct integers ai, j (1 ≤ ai, j ≤ n; ai, j ≠ i) — the numbers of parts to complete before part i.Numbers on all lines are separated by single spaces. You can assume that the parts of the game are numbered from 1 to n in some way. It is guaranteed that there are no cyclic dependencies between the parts of the game.\n\nOutputOn a single line print the answer to the problem.\n\nInputCopy110OutputCopy1InputCopy52 2 1 1 31 52 5 12 5 41 50OutputCopy7\n\nInputCopy110\n\nOutputCopy1\n\nInputCopy52 2 1 1 31 52 5 12 5 41 50\n\nOutputCopy7\n\nNoteNote to the second sample: before the beginning of the game the best strategy is to stand by the third computer. First we complete part 5. Then we go to the 1-st computer and complete parts 3 and 4. Then we go to the 2-nd computer and complete parts 1 and 2. In total we get 1+1+2+1+2, which equals 7 hours.",
      "solutions": [
        {
          "title": "Codeforces Round #131 - Codeforces",
          "content": "Hello everybody!Welcome all to Codeforces Round #131, which will be held on Monday, 30th of July at 19:30 MSK. I am (Sergey Nagin) an author of the problems. This will be my First Codeforces round and I hope it won't be the last one :).I would like to thank Mike Mirzayanov(MikeMirzayanov) who made this contest possible, Roman Furko(Furko) and Gerald Agapov(Gerald) for helping to prepare this round and Maria Belova(Delinur) for the translation of problem statements into English. I hope that problems will be interesting for you.Good luck!Problems’ point values in Division 1 are 1000-1000-1500-2000-2500. Problems’ point values in Division 2 are 500-1000-2000-2000-2500.I strongly recommend you to read ALL the problems.The contest is over! Congratulations' to winners!First division:1 place: Egor2 place: Petr3 place: touristSecond division:1 place: antimatter2 place: c1753533 place: takaramono I hope, that problems were interesting for you.You can view tutorial. Some personal information. This year I finished school and I will go to university. I study programming during almost five years. In addition to computer science, I like sports: powerlifting, arm wrestling and swimming.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/4965",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1190
        },
        {
          "title": "Codeforces Round #131 Tutorial - Codeforces",
          "content": "Sorry for my poor English, this blog will be corrected soon.214A - System of EquationsSolution for this problem — just go through the possible pairs of numbers and check them for correctness. We can do that in any way. 214B - HometaskNuber is divisible by 2,3,5 only if sum of the digits is divisible by 3 and last digit is 0, so if we havent 0 in our set answer is -1, otherwise solution exists(we can return 0 as solution). A further solution — analysis of the cases.Lets sort all didgits in nonincreasing order. If sum of all digits is divisible by 3 — answer is our set of digits(without spaces ofcourse :) ). If modulo equals 1 — we must delete minimum digit from out set with modulo after division by 3 equals 1, if we haven't such we must delete 2 minimal digits with modulo after division by 3 equals 2. If we have modulo equals 2 — we have identical case.Also we must remember that we cannot use leading zeros. In case when we have more then one 0 and no another digit we must print only one zero.213A - GameSolution — Greedy.Lets our computers settled on circle, and moves (1->2, 2->3, 3->1) will be steps \"forward\", and moves (1->3,3->2,2->1) will steps \"back\". Note that \"back\" moves is not optimal, as we can make two moves \"forward\" that is identical in time. We will look over all starts. Further, we will go by circle while we not complited all game. For every level we will remember number ne[i] — count of another level that \"direct\" need for it. We will complited levels with ne[i]=0 and update all ne[i] that we must. It can be implemented with O(n^3) time.213B - NumbersSolution — dynamic programming.Look over for length of the number that we will build. Further, we will use DP f(len,i) — how many numbers with length len we can make with digits i..9.Recount:- f(len,0) = sum(f(len-i,1)*C(len-1,i), i=a[0]..len);- f(len,j) = sum(f(len-i,j+1)*C(len,i), i=a[j]..len), 0<j<9;- f(len,9) = 1, если len>=a[9], 0 если len<a[9].C(n,k) — binomial coefficient.213C - Relay RaceSolution — dynamic programming.Note, that we can make 2 pathes form cell (1,1) to cell (n,n).Note, that after each move our cells will be located on the same diagonal.We will solve the problem with DP f(d,i1,i2), d — diagonal number, i1 — 1st coordinate 1st path, i2 — 1st coordinate 2nd path. It is clear that we can calculate 2nd coordinate when we know number of the diagonal and 1st coordinate. Recount — obvious, we make all 4 transition, and if pathes are intersected in temporary point, we add value of the cell only one, otherwise we add both values of the cells. We can imlement this solution with O(n^2) memory if we will rewrite array of DP after increasing of diagonal number. Also we must remember that answer can be lower then 0. 213D - StarsI present solution as few pictures:https://get.google.com/albumarchive/pwa/115317317397602031319/Solutions131Implementation.We have only one difficult moment — how to count coordinates? We can calculate them from regular pentagon, all that you need, you can read there.213E - Two PermutationsFor given two permutation we will make two another by next transformation: New_A[A[i]] = i, where New_A — news permutation, A — given permutation. Lets we get two permutation A and B. Now our problem is next: how many sub-arrays of length n are equals to firs permutation. Two arrays will be equal if after swaping every element with its number in sorted array obtained arrays will be element-wise equal.Further solution hashes, but we will use not only modulo 2^64, we will use some big modulos, but they must be smaller then 2^32-1.Lets step[i] = 1000003^i.Lets F(A) = num[1]*step[1] + num[2]*step[2] + ... + num[n]*step[n], where num[i] — number of the element A[i] in sorted array.If we will compare arrays, we can use this function. But it can be very big, so we will count it by modulos.So now our problem is to calculate F function to every subarray. Lets look what will change after adding/deleting some elent from set: some element from num array willnot change, and some will become grater after adding, and become lower after deleting. So we must use some interval-tree to recount our F function. We need to know sum of step[i] on some interval of added numbers and count of elements on some interval. Uses this information we can simply recount out function. Also we must remember that after adding element with coeficinet step[i], where i>n and deleting some previos element our function will become grater that we need. So we will multiple hash of first array by 1000003 to avoid this issue.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/4982",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.6,
            "reason": "宽松匹配: 包含题目编号 214 和字母"
          },
          "content_length": 4543
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #131 - Codeforces - Code 1",
          "code": "int n = 300;\nfprintf(stdout, \"%d\\n\", n);\nfor (int i = 0; i < n; i++)\n    for (int c = 0; c < n; c++)\n        fprintf(stdout, \"%d%c\", ((i + c == 580) ? -1 : 0), c + 1 == n ? '\\n' : ' ');",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4965",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #131 - Codeforces - Code 2",
          "code": "int n = 300;\nfprintf(stdout, \"%d\\n\", n);\nfor (int i = 0; i < n; i++)\n    for (int c = 0; c < n; c++)\n        fprintf(stdout, \"%d%c\", ((i + c == 580) ? -1 : 0), c + 1 == n ? '\\n' : ' ');",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4965",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #131 - Codeforces - Code 3",
          "code": "Comb[len - 1][j]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4965",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #131 Tutorial - Codeforces - Code 1",
          "code": "(a-b)(a+b-1)=n-m",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4982",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 200, \"n\");\n    inf.readEoln();\n    vector<int> c = inf.readInts(n, 1, 3);\n    inf.readEoln();\n    vector<vector<int>> graph(n + 1);\n    for (int i = 0; i < n; i++) {\n        int k = inf.readInt(0, n - 1);\n        if (k == 0) {\n            inf.readEoln();\n        } else {\n            inf.readSpace();\n            vector<int> ai = inf.readInts(k, 1, n);\n            for (int aj : ai) {\n                ensuref(aj != i + 1, \"Dependency cannot include the part itself at line %d\", i + 3);\n            }\n            set<int> s(ai.begin(), ai.end());\n            ensuref((int)s.size() == k, \"Dependencies must be distinct at line %d\", i + 3);\n            inf.readEoln();\n            for (int aj : ai) {\n                // Since part i depends on parts ai_j, we add an edge from ai_j to i+1\n                graph[aj].push_back(i + 1);\n            }\n        }\n    }\n    // Check that the dependency graph is acyclic using Kahn's algorithm\n    vector<int> indegree(n + 1, 0);\n    for (int u = 1; u <= n; u++) {\n        for (int v : graph[u]) {\n            indegree[v]++;\n        }\n    }\n    queue<int> q;\n    for (int i = 1; i <= n; i++) {\n        if (indegree[i] == 0)\n            q.push(i);\n    }\n    int processed = 0;\n    while (!q.empty()) {\n        int u = q.front();\n        q.pop();\n        processed++;\n        for (int v : graph[u]) {\n            indegree[v]--;\n            if (indegree[v] == 0)\n                q.push(v);\n        }\n    }\n    ensuref(processed == n, \"The dependency graph contains a cycle\");\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 200, \"n\");\n    inf.readEoln();\n    vector<int> c = inf.readInts(n, 1, 3);\n    inf.readEoln();\n    vector<vector<int>> graph(n + 1);\n    for (int i = 0; i < n; i++) {\n        int k = inf.readInt(0, n - 1);\n        if (k == 0) {\n            inf.readEoln();\n        } else {\n            inf.readSpace();\n            vector<int> ai = inf.readInts(k, 1, n);\n            for (int aj : ai) {\n                ensuref(aj != i + 1, \"Dependency cannot include the part itself at line %d\", i + 3);\n            }\n            set<int> s(ai.begin(), ai.end());\n            ensuref((int)s.size() == k, \"Dependencies must be distinct at line %d\", i + 3);\n            inf.readEoln();\n            for (int aj : ai) {\n                // Since part i depends on parts ai_j, we add an edge from ai_j to i+1\n                graph[aj].push_back(i + 1);\n            }\n        }\n    }\n    // Check that the dependency graph is acyclic using Kahn's algorithm\n    vector<int> indegree(n + 1, 0);\n    for (int u = 1; u <= n; u++) {\n        for (int v : graph[u]) {\n            indegree[v]++;\n        }\n    }\n    queue<int> q;\n    for (int i = 1; i <= n; i++) {\n        if (indegree[i] == 0)\n            q.push(i);\n    }\n    int processed = 0;\n    while (!q.empty()) {\n        int u = q.front();\n        q.pop();\n        processed++;\n        for (int v : graph[u]) {\n            indegree[v]--;\n            if (indegree[v] == 0)\n                q.push(v);\n        }\n    }\n    ensuref(processed == n, \"The dependency graph contains a cycle\");\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 200, \"n\");\n    inf.readEoln();\n    vector<int> c = inf.readInts(n, 1, 3);\n    inf.readEoln();\n    vector<vector<int>> graph(n + 1);\n    for (int i = 0; i < n; i++) {\n        int k = inf.readInt(0, n - 1);\n        if (k == 0) {\n            inf.readEoln();\n        } else {\n            inf.readSpace();\n            vector<int> ai = inf.readInts(k, 1, n);\n            for (int aj : ai) {\n                ensuref(aj != i + 1, \"Dependency cannot include the part itself at line %d\", i + 3);\n            }\n            set<int> s(ai.begin(), ai.end());\n            ensuref((int)s.size() == k, \"Dependencies must be distinct at line %d\", i + 3);\n            inf.readEoln();\n            for (int aj : ai) {\n                // Since part i depends on parts ai_j, we add an edge from ai_j to i+1\n                graph[aj].push_back(i + 1);\n            }\n        }\n    }\n    // Check that the dependency graph is acyclic using Kahn's algorithm\n    vector<int> indegree(n + 1, 0);\n    for (int u = 1; u <= n; u++) {\n        for (int v : graph[u]) {\n            indegree[v]++;\n        }\n    }\n    queue<int> q;\n    for (int i = 1; i <= n; i++) {\n        if (indegree[i] == 0)\n            q.push(i);\n    }\n    int processed = 0;\n    while (!q.empty()) {\n        int u = q.front();\n        q.pop();\n        processed++;\n        for (int v : graph[u]) {\n            indegree[v]--;\n            if (indegree[v] == 0)\n                q.push(v);\n        }\n    }\n    ensuref(processed == n, \"The dependency graph contains a cycle\");\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n    string ci_type = opt<string>(\"ci_type\", \"random\");\n\n    // declare variables\n    vector<int> ci(n); // ci[i]: computer for part i (1-based indexing)\n    vector<vector<int>> dependencies(n); // dependencies[i]: list of parts that part i depends on\n\n    // Generate ci according to ci_type\n\n    if (ci_type == \"random\") {\n        for(int i = 0; i < n; ++i) {\n            ci[i] = rnd.next(1, 3);\n        }\n    } else if (ci_type == \"same\") {\n        int c = rnd.next(1, 3);\n        for(int i = 0; i < n; ++i) {\n            ci[i] = c;\n        }\n    } else if (ci_type == \"alternating\") {\n        for(int i = 0; i < n; ++i) {\n            ci[i] = (i % 3) + 1;\n        }\n    } else {\n        // default to random\n        for(int i = 0; i < n; ++i) {\n            ci[i] = rnd.next(1, 3);\n        }\n    }\n\n    // Generate dependencies according to type\n\n    if (type == \"chain\") {\n        // Linear chain: Part i depends on i-1\n        for(int i = 1; i < n; ++i) {\n            dependencies[i].push_back(i - 1);\n        }\n    } else if (type == \"reverse_chain\") {\n        // Reverse chain: Part i depends on i+1\n        for(int i = 0; i < n -1; ++i) {\n            dependencies[i].push_back(i + 1);\n        }\n    } else if (type == \"star\") {\n        // All parts depend on part 0\n        for(int i = 1; i < n; ++i) {\n            dependencies[i].push_back(0);\n        }\n    } else if (type == \"complete\") {\n        // Part i depends on all parts with index less than i\n        for(int i = 1; i < n; ++i) {\n            for(int j = 0; j < i; ++j) {\n                dependencies[i].push_back(j);\n            }\n        }\n    } else if (type == \"empty\") {\n        // No dependencies\n        // dependencies vector remains empty\n    } else if (type == \"random\") {\n        // Generate random acyclic dependencies\n        // Let's generate a random topological order\n        vector<int> order(n);\n        for(int i = 0; i < n; ++i) order[i] = i;\n        shuffle(order.begin(), order.end());\n\n        // For each node, we can choose dependencies from earlier nodes\n        for(int idx = 0; idx < n; ++idx) {\n            int u = order[idx];\n            int max_deg = idx; // Can only depend on earlier nodes in order\n            int deg = rnd.next(0, min(5, max_deg)); // Limit degree for randomness\n            set<int> deps;\n            for(int d = 0; d < deg; ++d) {\n                int dep_idx = rnd.next(0, idx - 1);\n                int v = order[dep_idx];\n                if (v != u) {\n                    deps.insert(v);\n                }\n            }\n            dependencies[u] = vector<int>(deps.begin(), deps.end());\n        }\n    } else {\n        // default to random\n        // same as \"random\" type above\n    }\n\n    // Now output the data in the required format\n\n    // First line: n\n    printf(\"%d\\n\", n);\n\n    // Second line: ci\n    for(int i = 0; i < n; ++i) {\n        if (i > 0) printf(\" \");\n        printf(\"%d\", ci[i]);\n    }\n    printf(\"\\n\");\n\n    // Next n lines: dependencies\n    for(int i = 0; i < n; ++i) {\n        // ki followed by ai_j\n        int ki = dependencies[i].size();\n        printf(\"%d\", ki);\n        for(int j = 0; j < ki; ++j) {\n            printf(\" %d\", dependencies[i][j]+1); // Output 1-based indexing\n        }\n        printf(\"\\n\");\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n    string ci_type = opt<string>(\"ci_type\", \"random\");\n\n    // declare variables\n    vector<int> ci(n); // ci[i]: computer for part i (1-based indexing)\n    vector<vector<int>> dependencies(n); // dependencies[i]: list of parts that part i depends on\n\n    // Generate ci according to ci_type\n\n    if (ci_type == \"random\") {\n        for(int i = 0; i < n; ++i) {\n            ci[i] = rnd.next(1, 3);\n        }\n    } else if (ci_type == \"same\") {\n        int c = rnd.next(1, 3);\n        for(int i = 0; i < n; ++i) {\n            ci[i] = c;\n        }\n    } else if (ci_type == \"alternating\") {\n        for(int i = 0; i < n; ++i) {\n            ci[i] = (i % 3) + 1;\n        }\n    } else {\n        // default to random\n        for(int i = 0; i < n; ++i) {\n            ci[i] = rnd.next(1, 3);\n        }\n    }\n\n    // Generate dependencies according to type\n\n    if (type == \"chain\") {\n        // Linear chain: Part i depends on i-1\n        for(int i = 1; i < n; ++i) {\n            dependencies[i].push_back(i - 1);\n        }\n    } else if (type == \"reverse_chain\") {\n        // Reverse chain: Part i depends on i+1\n        for(int i = 0; i < n -1; ++i) {\n            dependencies[i].push_back(i + 1);\n        }\n    } else if (type == \"star\") {\n        // All parts depend on part 0\n        for(int i = 1; i < n; ++i) {\n            dependencies[i].push_back(0);\n        }\n    } else if (type == \"complete\") {\n        // Part i depends on all parts with index less than i\n        for(int i = 1; i < n; ++i) {\n            for(int j = 0; j < i; ++j) {\n                dependencies[i].push_back(j);\n            }\n        }\n    } else if (type == \"empty\") {\n        // No dependencies\n        // dependencies vector remains empty\n    } else if (type == \"random\") {\n        // Generate random acyclic dependencies\n        // Let's generate a random topological order\n        vector<int> order(n);\n        for(int i = 0; i < n; ++i) order[i] = i;\n        shuffle(order.begin(), order.end());\n\n        // For each node, we can choose dependencies from earlier nodes\n        for(int idx = 0; idx < n; ++idx) {\n            int u = order[idx];\n            int max_deg = idx; // Can only depend on earlier nodes in order\n            int deg = rnd.next(0, min(5, max_deg)); // Limit degree for randomness\n            set<int> deps;\n            for(int d = 0; d < deg; ++d) {\n                int dep_idx = rnd.next(0, idx - 1);\n                int v = order[dep_idx];\n                if (v != u) {\n                    deps.insert(v);\n                }\n            }\n            dependencies[u] = vector<int>(deps.begin(), deps.end());\n        }\n    } else {\n        // default to random\n        // same as \"random\" type above\n    }\n\n    // Now output the data in the required format\n\n    // First line: n\n    printf(\"%d\\n\", n);\n\n    // Second line: ci\n    for(int i = 0; i < n; ++i) {\n        if (i > 0) printf(\" \");\n        printf(\"%d\", ci[i]);\n    }\n    printf(\"\\n\");\n\n    // Next n lines: dependencies\n    for(int i = 0; i < n; ++i) {\n        // ki followed by ai_j\n        int ki = dependencies[i].size();\n        printf(\"%d\", ki);\n        for(int j = 0; j < ki; ++j) {\n            printf(\" %d\", dependencies[i][j]+1); // Output 1-based indexing\n        }\n        printf(\"\\n\");\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -type chain\n./gen -n 1 -type random\n./gen -n 2 -type chain\n./gen -n 2 -type reverse_chain\n./gen -n 2 -type random -ci_type same\n./gen -n 5 -type star -ci_type alternating\n./gen -n 5 -type complete -ci_type random\n./gen -n 10 -type chain -ci_type random\n./gen -n 10 -type random -ci_type random\n./gen -n 10 -type random -ci_type same\n./gen -n 10 -type random -ci_type alternating\n./gen -n 50 -type chain\n./gen -n 50 -type star\n./gen -n 50 -type complete\n./gen -n 50 -type random\n./gen -n 50 -type random -ci_type same\n./gen -n 100 -type chain\n./gen -n 100 -type star\n./gen -n 100 -type complete\n./gen -n 100 -type random\n./gen -n 100 -type random -ci_type same\n./gen -n 200 -type chain\n./gen -n 200 -type star\n./gen -n 200 -type complete\n./gen -n 200 -type random\n./gen -n 200 -type random -ci_type same\n./gen -n 200 -type random -ci_type alternating\n./gen -n 200 -type reverse_chain\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T19:49:44.494218",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "214/D",
      "title": "D. Numbers",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains integer n (1 ≤ n ≤ 100). The next line contains 10 integers a[0], a[1], ..., a[9] (0 ≤ a[i] ≤ 100) — elements of array a. The numbers are separated by spaces.",
      "output_spec": "OutputOn a single line print the remainder of dividing the answer to the problem by 1000000007 (109 + 7).",
      "sample_tests": "ExamplesInputCopy10 0 0 0 0 0 0 0 0 1OutputCopy1InputCopy21 1 0 0 0 0 0 0 0 0OutputCopy1InputCopy31 1 0 0 0 0 0 0 0 0OutputCopy36",
      "description": "time limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains integer n (1 ≤ n ≤ 100). The next line contains 10 integers a[0], a[1], ..., a[9] (0 ≤ a[i] ≤ 100) — elements of array a. The numbers are separated by spaces.\n\nOutputOn a single line print the remainder of dividing the answer to the problem by 1000000007 (109 + 7).\n\nInputCopy10 0 0 0 0 0 0 0 0 1OutputCopy1InputCopy21 1 0 0 0 0 0 0 0 0OutputCopy1InputCopy31 1 0 0 0 0 0 0 0 0OutputCopy36\n\nInputCopy10 0 0 0 0 0 0 0 0 1\n\nOutputCopy1\n\nInputCopy21 1 0 0 0 0 0 0 0 0\n\nOutputCopy1\n\nInputCopy31 1 0 0 0 0 0 0 0 0\n\nOutputCopy36\n\nNoteIn the first sample number 9 meets the requirements.In the second sample number 10 meets the requirements.In the third sample numbers 10, 110, 210, 120, 103 meet the requirements. There are other suitable numbers, 36 in total.",
      "solutions": [
        {
          "title": "Codeforces Round #131 - Codeforces",
          "content": "Hello everybody!Welcome all to Codeforces Round #131, which will be held on Monday, 30th of July at 19:30 MSK. I am (Sergey Nagin) an author of the problems. This will be my First Codeforces round and I hope it won't be the last one :).I would like to thank Mike Mirzayanov(MikeMirzayanov) who made this contest possible, Roman Furko(Furko) and Gerald Agapov(Gerald) for helping to prepare this round and Maria Belova(Delinur) for the translation of problem statements into English. I hope that problems will be interesting for you.Good luck!Problems’ point values in Division 1 are 1000-1000-1500-2000-2500. Problems’ point values in Division 2 are 500-1000-2000-2000-2500.I strongly recommend you to read ALL the problems.The contest is over! Congratulations' to winners!First division:1 place: Egor2 place: Petr3 place: touristSecond division:1 place: antimatter2 place: c1753533 place: takaramono I hope, that problems were interesting for you.You can view tutorial. Some personal information. This year I finished school and I will go to university. I study programming during almost five years. In addition to computer science, I like sports: powerlifting, arm wrestling and swimming.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/4965",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1190
        },
        {
          "title": "Codeforces Round #131 Tutorial - Codeforces",
          "content": "Sorry for my poor English, this blog will be corrected soon.214A - System of EquationsSolution for this problem — just go through the possible pairs of numbers and check them for correctness. We can do that in any way. 214B - HometaskNuber is divisible by 2,3,5 only if sum of the digits is divisible by 3 and last digit is 0, so if we havent 0 in our set answer is -1, otherwise solution exists(we can return 0 as solution). A further solution — analysis of the cases.Lets sort all didgits in nonincreasing order. If sum of all digits is divisible by 3 — answer is our set of digits(without spaces ofcourse :) ). If modulo equals 1 — we must delete minimum digit from out set with modulo after division by 3 equals 1, if we haven't such we must delete 2 minimal digits with modulo after division by 3 equals 2. If we have modulo equals 2 — we have identical case.Also we must remember that we cannot use leading zeros. In case when we have more then one 0 and no another digit we must print only one zero.213A - GameSolution — Greedy.Lets our computers settled on circle, and moves (1->2, 2->3, 3->1) will be steps \"forward\", and moves (1->3,3->2,2->1) will steps \"back\". Note that \"back\" moves is not optimal, as we can make two moves \"forward\" that is identical in time. We will look over all starts. Further, we will go by circle while we not complited all game. For every level we will remember number ne[i] — count of another level that \"direct\" need for it. We will complited levels with ne[i]=0 and update all ne[i] that we must. It can be implemented with O(n^3) time.213B - NumbersSolution — dynamic programming.Look over for length of the number that we will build. Further, we will use DP f(len,i) — how many numbers with length len we can make with digits i..9.Recount:- f(len,0) = sum(f(len-i,1)*C(len-1,i), i=a[0]..len);- f(len,j) = sum(f(len-i,j+1)*C(len,i), i=a[j]..len), 0<j<9;- f(len,9) = 1, если len>=a[9], 0 если len<a[9].C(n,k) — binomial coefficient.213C - Relay RaceSolution — dynamic programming.Note, that we can make 2 pathes form cell (1,1) to cell (n,n).Note, that after each move our cells will be located on the same diagonal.We will solve the problem with DP f(d,i1,i2), d — diagonal number, i1 — 1st coordinate 1st path, i2 — 1st coordinate 2nd path. It is clear that we can calculate 2nd coordinate when we know number of the diagonal and 1st coordinate. Recount — obvious, we make all 4 transition, and if pathes are intersected in temporary point, we add value of the cell only one, otherwise we add both values of the cells. We can imlement this solution with O(n^2) memory if we will rewrite array of DP after increasing of diagonal number. Also we must remember that answer can be lower then 0. 213D - StarsI present solution as few pictures:https://get.google.com/albumarchive/pwa/115317317397602031319/Solutions131Implementation.We have only one difficult moment — how to count coordinates? We can calculate them from regular pentagon, all that you need, you can read there.213E - Two PermutationsFor given two permutation we will make two another by next transformation: New_A[A[i]] = i, where New_A — news permutation, A — given permutation. Lets we get two permutation A and B. Now our problem is next: how many sub-arrays of length n are equals to firs permutation. Two arrays will be equal if after swaping every element with its number in sorted array obtained arrays will be element-wise equal.Further solution hashes, but we will use not only modulo 2^64, we will use some big modulos, but they must be smaller then 2^32-1.Lets step[i] = 1000003^i.Lets F(A) = num[1]*step[1] + num[2]*step[2] + ... + num[n]*step[n], where num[i] — number of the element A[i] in sorted array.If we will compare arrays, we can use this function. But it can be very big, so we will count it by modulos.So now our problem is to calculate F function to every subarray. Lets look what will change after adding/deleting some elent from set: some element from num array willnot change, and some will become grater after adding, and become lower after deleting. So we must use some interval-tree to recount our F function. We need to know sum of step[i] on some interval of added numbers and count of elements on some interval. Uses this information we can simply recount out function. Also we must remember that after adding element with coeficinet step[i], where i>n and deleting some previos element our function will become grater that we need. So we will multiple hash of first array by 1000003 to avoid this issue.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/4982",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.6,
            "reason": "宽松匹配: 包含题目编号 214 和字母"
          },
          "content_length": 4543
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #131 - Codeforces - Code 1",
          "code": "int n = 300;\nfprintf(stdout, \"%d\\n\", n);\nfor (int i = 0; i < n; i++)\n    for (int c = 0; c < n; c++)\n        fprintf(stdout, \"%d%c\", ((i + c == 580) ? -1 : 0), c + 1 == n ? '\\n' : ' ');",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4965",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #131 - Codeforces - Code 2",
          "code": "int n = 300;\nfprintf(stdout, \"%d\\n\", n);\nfor (int i = 0; i < n; i++)\n    for (int c = 0; c < n; c++)\n        fprintf(stdout, \"%d%c\", ((i + c == 580) ? -1 : 0), c + 1 == n ? '\\n' : ' ');",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4965",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #131 - Codeforces - Code 3",
          "code": "Comb[len - 1][j]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4965",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #131 Tutorial - Codeforces - Code 1",
          "code": "(a-b)(a+b-1)=n-m",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4982",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(10, 0, 100, \"a\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(10, 0, 100, \"a\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(10, 0, 100, \"a\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> a(10);\n\n    if(type == \"all_zero\") {\n        // All digits have zero minimum occurrence\n        fill(a.begin(), a.end(), 0);\n    } else if(type == \"all_one\") {\n        // All digits must occur at least once\n        fill(a.begin(), a.end(), 1);\n    } else if(type == \"max\") {\n        // Set some digits to have maximum required occurrences\n        int k = rnd.next(1, 10); // Number of digits to set to max\n        vector<int> indices(10);\n        iota(indices.begin(), indices.end(), 0);\n        shuffle(indices.begin(), indices.end());\n        for(int i = 0; i < k; ++i)\n            a[indices[i]] = min(100, n);\n    } else if(type == \"sum_equals_n\") {\n        // Set a[i] such that the sum equals n\n        int sum = n;\n        vector<int> indices(10);\n        iota(indices.begin(), indices.end(), 0);\n        shuffle(indices.begin(), indices.end());\n        for(int i = 0; i < 10; ++i) {\n            if(i == 9)\n                a[indices[i]] = sum;\n            else {\n                a[indices[i]] = rnd.next(0, sum);\n                sum -= a[indices[i]];\n            }\n        }\n    } else if(type == \"single_digit\") {\n        // Only one digit has a positive minimum occurrence\n        int digit = rnd.next(1, 9); // Exclude 0 to avoid leading zero\n        a[digit] = rnd.next(1, min(n, 100));\n    } else if(type == \"leading_zero\") {\n        // Set a[0] > 0 to test leading zero constraints\n        a[0] = rnd.next(1, min(n, 100));\n        for(int i = 1; i < 10; ++i)\n            a[i] = rnd.next(0, 100);\n    } else if(type == \"impossible\") {\n        // Make it impossible to construct a valid number (sum of a[i] > n)\n        int sum_required = n + rnd.next(1, 10);\n        for(int i = 0; i < 10; ++i) {\n            a[i] = rnd.next(0, 100);\n        }\n        int sum_ai = accumulate(a.begin(), a.end(), 0);\n        if(sum_ai < sum_required) {\n            // Increase a random a[i] to make sum_ai >= sum_required\n            int idx = rnd.next(0, 9);\n            a[idx] += sum_required - sum_ai;\n            if(a[idx] > 100) a[idx] = 100; // Keep within constraints\n        }\n    } else {\n        // Random test case\n        for(int i = 0; i < 10; ++i)\n            a[i] = rnd.next(0, 100);\n    }\n\n    // Output n\n    printf(\"%d\\n\", n);\n\n    // Output a[0..9]\n    for(int i = 0; i < 10; ++i)\n        printf(\"%d%c\", a[i], i == 9 ? '\\n' : ' ');\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> a(10);\n\n    if(type == \"all_zero\") {\n        // All digits have zero minimum occurrence\n        fill(a.begin(), a.end(), 0);\n    } else if(type == \"all_one\") {\n        // All digits must occur at least once\n        fill(a.begin(), a.end(), 1);\n    } else if(type == \"max\") {\n        // Set some digits to have maximum required occurrences\n        int k = rnd.next(1, 10); // Number of digits to set to max\n        vector<int> indices(10);\n        iota(indices.begin(), indices.end(), 0);\n        shuffle(indices.begin(), indices.end());\n        for(int i = 0; i < k; ++i)\n            a[indices[i]] = min(100, n);\n    } else if(type == \"sum_equals_n\") {\n        // Set a[i] such that the sum equals n\n        int sum = n;\n        vector<int> indices(10);\n        iota(indices.begin(), indices.end(), 0);\n        shuffle(indices.begin(), indices.end());\n        for(int i = 0; i < 10; ++i) {\n            if(i == 9)\n                a[indices[i]] = sum;\n            else {\n                a[indices[i]] = rnd.next(0, sum);\n                sum -= a[indices[i]];\n            }\n        }\n    } else if(type == \"single_digit\") {\n        // Only one digit has a positive minimum occurrence\n        int digit = rnd.next(1, 9); // Exclude 0 to avoid leading zero\n        a[digit] = rnd.next(1, min(n, 100));\n    } else if(type == \"leading_zero\") {\n        // Set a[0] > 0 to test leading zero constraints\n        a[0] = rnd.next(1, min(n, 100));\n        for(int i = 1; i < 10; ++i)\n            a[i] = rnd.next(0, 100);\n    } else if(type == \"impossible\") {\n        // Make it impossible to construct a valid number (sum of a[i] > n)\n        int sum_required = n + rnd.next(1, 10);\n        for(int i = 0; i < 10; ++i) {\n            a[i] = rnd.next(0, 100);\n        }\n        int sum_ai = accumulate(a.begin(), a.end(), 0);\n        if(sum_ai < sum_required) {\n            // Increase a random a[i] to make sum_ai >= sum_required\n            int idx = rnd.next(0, 9);\n            a[idx] += sum_required - sum_ai;\n            if(a[idx] > 100) a[idx] = 100; // Keep within constraints\n        }\n    } else {\n        // Random test case\n        for(int i = 0; i < 10; ++i)\n            a[i] = rnd.next(0, 100);\n    }\n\n    // Output n\n    printf(\"%d\\n\", n);\n\n    // Output a[0..9]\n    for(int i = 0; i < 10; ++i)\n        printf(\"%d%c\", a[i], i == 9 ? '\\n' : ' ');\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -type all_zero\n./gen -n 100 -type all_zero\n\n./gen -n 1 -type all_one\n./gen -n 100 -type all_one\n\n./gen -n 1 -type max\n./gen -n 100 -type max\n\n./gen -n 1 -type sum_equals_n\n./gen -n 100 -type sum_equals_n\n\n./gen -n 1 -type single_digit\n./gen -n 100 -type single_digit\n\n./gen -n 1 -type leading_zero\n./gen -n 100 -type leading_zero\n\n./gen -n 1 -type impossible\n./gen -n 100 -type impossible\n\n./gen -n 1 -type random\n./gen -n 100 -type random\n\n./gen -n 50 -type all_zero\n./gen -n 50 -type all_one\n./gen -n 50 -type max\n./gen -n 50 -type sum_equals_n\n./gen -n 50 -type single_digit\n./gen -n 50 -type leading_zero\n./gen -n 50 -type impossible\n./gen -n 50 -type random\n\n# Additional random test cases\n./gen -n 99 -type random\n./gen -n 2 -type random\n./gen -n 75 -type max\n./gen -n 25 -type leading_zero\n./gen -n 1 -type impossible\n./gen -n 100 -type impossible\n./gen -n 100 -type sum_equals_n\n./gen -n 80 -type single_digit\n./gen -n 10 -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T19:49:46.291943",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "214/E",
      "title": "E. Relay Race",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test4 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains a single integer (1 ≤ n ≤ 300). The next n lines contain n integers each: the j-th number on the i-th line ai, j ( - 1000 ≤ ai, j ≤ 1000) is the number written in the cell with coordinates (i, j).",
      "output_spec": "OutputOn a single line print a single number — the answer to the problem.",
      "sample_tests": "ExamplesInputCopy15OutputCopy5InputCopy211 1416 12OutputCopy53InputCopy325 16 2512 18 1911 13 8OutputCopy136",
      "description": "E. Relay Race\n\ntime limit per test4 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains a single integer (1 ≤ n ≤ 300). The next n lines contain n integers each: the j-th number on the i-th line ai, j ( - 1000 ≤ ai, j ≤ 1000) is the number written in the cell with coordinates (i, j).\n\nOutputOn a single line print a single number — the answer to the problem.\n\nInputCopy15OutputCopy5InputCopy211 1416 12OutputCopy53InputCopy325 16 2512 18 1911 13 8OutputCopy136\n\nInputCopy15\n\nOutputCopy5\n\nInputCopy211 1416 12\n\nOutputCopy53\n\nInputCopy325 16 2512 18 1911 13 8\n\nOutputCopy136\n\nNoteComments to the second sample: The profitable path for Furik is: (1, 1), (1, 2), (2, 2), and for Rubik: (2, 2), (2, 1), (1, 1). Comments to the third sample: The optimal path for Furik is: (1, 1), (1, 2), (1, 3), (2, 3), (3, 3), and for Rubik: (3, 3), (3, 2), (2, 2), (2, 1), (1, 1). The figure to the sample:    Furik's path is marked with yellow, and Rubik's path is marked with pink.",
      "solutions": [
        {
          "title": "Codeforces Round #131 - Codeforces",
          "content": "Hello everybody!Welcome all to Codeforces Round #131, which will be held on Monday, 30th of July at 19:30 MSK. I am (Sergey Nagin) an author of the problems. This will be my First Codeforces round and I hope it won't be the last one :).I would like to thank Mike Mirzayanov(MikeMirzayanov) who made this contest possible, Roman Furko(Furko) and Gerald Agapov(Gerald) for helping to prepare this round and Maria Belova(Delinur) for the translation of problem statements into English. I hope that problems will be interesting for you.Good luck!Problems’ point values in Division 1 are 1000-1000-1500-2000-2500. Problems’ point values in Division 2 are 500-1000-2000-2000-2500.I strongly recommend you to read ALL the problems.The contest is over! Congratulations' to winners!First division:1 place: Egor2 place: Petr3 place: touristSecond division:1 place: antimatter2 place: c1753533 place: takaramono I hope, that problems were interesting for you.You can view tutorial. Some personal information. This year I finished school and I will go to university. I study programming during almost five years. In addition to computer science, I like sports: powerlifting, arm wrestling and swimming.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/4965",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1190
        },
        {
          "title": "Codeforces Round #131 Tutorial - Codeforces",
          "content": "Sorry for my poor English, this blog will be corrected soon.214A - System of EquationsSolution for this problem — just go through the possible pairs of numbers and check them for correctness. We can do that in any way. 214B - HometaskNuber is divisible by 2,3,5 only if sum of the digits is divisible by 3 and last digit is 0, so if we havent 0 in our set answer is -1, otherwise solution exists(we can return 0 as solution). A further solution — analysis of the cases.Lets sort all didgits in nonincreasing order. If sum of all digits is divisible by 3 — answer is our set of digits(without spaces ofcourse :) ). If modulo equals 1 — we must delete minimum digit from out set with modulo after division by 3 equals 1, if we haven't such we must delete 2 minimal digits with modulo after division by 3 equals 2. If we have modulo equals 2 — we have identical case.Also we must remember that we cannot use leading zeros. In case when we have more then one 0 and no another digit we must print only one zero.213A - GameSolution — Greedy.Lets our computers settled on circle, and moves (1->2, 2->3, 3->1) will be steps \"forward\", and moves (1->3,3->2,2->1) will steps \"back\". Note that \"back\" moves is not optimal, as we can make two moves \"forward\" that is identical in time. We will look over all starts. Further, we will go by circle while we not complited all game. For every level we will remember number ne[i] — count of another level that \"direct\" need for it. We will complited levels with ne[i]=0 and update all ne[i] that we must. It can be implemented with O(n^3) time.213B - NumbersSolution — dynamic programming.Look over for length of the number that we will build. Further, we will use DP f(len,i) — how many numbers with length len we can make with digits i..9.Recount:- f(len,0) = sum(f(len-i,1)*C(len-1,i), i=a[0]..len);- f(len,j) = sum(f(len-i,j+1)*C(len,i), i=a[j]..len), 0<j<9;- f(len,9) = 1, если len>=a[9], 0 если len<a[9].C(n,k) — binomial coefficient.213C - Relay RaceSolution — dynamic programming.Note, that we can make 2 pathes form cell (1,1) to cell (n,n).Note, that after each move our cells will be located on the same diagonal.We will solve the problem with DP f(d,i1,i2), d — diagonal number, i1 — 1st coordinate 1st path, i2 — 1st coordinate 2nd path. It is clear that we can calculate 2nd coordinate when we know number of the diagonal and 1st coordinate. Recount — obvious, we make all 4 transition, and if pathes are intersected in temporary point, we add value of the cell only one, otherwise we add both values of the cells. We can imlement this solution with O(n^2) memory if we will rewrite array of DP after increasing of diagonal number. Also we must remember that answer can be lower then 0. 213D - StarsI present solution as few pictures:https://get.google.com/albumarchive/pwa/115317317397602031319/Solutions131Implementation.We have only one difficult moment — how to count coordinates? We can calculate them from regular pentagon, all that you need, you can read there.213E - Two PermutationsFor given two permutation we will make two another by next transformation: New_A[A[i]] = i, where New_A — news permutation, A — given permutation. Lets we get two permutation A and B. Now our problem is next: how many sub-arrays of length n are equals to firs permutation. Two arrays will be equal if after swaping every element with its number in sorted array obtained arrays will be element-wise equal.Further solution hashes, but we will use not only modulo 2^64, we will use some big modulos, but they must be smaller then 2^32-1.Lets step[i] = 1000003^i.Lets F(A) = num[1]*step[1] + num[2]*step[2] + ... + num[n]*step[n], where num[i] — number of the element A[i] in sorted array.If we will compare arrays, we can use this function. But it can be very big, so we will count it by modulos.So now our problem is to calculate F function to every subarray. Lets look what will change after adding/deleting some elent from set: some element from num array willnot change, and some will become grater after adding, and become lower after deleting. So we must use some interval-tree to recount our F function. We need to know sum of step[i] on some interval of added numbers and count of elements on some interval. Uses this information we can simply recount out function. Also we must remember that after adding element with coeficinet step[i], where i>n and deleting some previos element our function will become grater that we need. So we will multiple hash of first array by 1000003 to avoid this issue.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/4982",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.6,
            "reason": "宽松匹配: 包含题目编号 214 和字母"
          },
          "content_length": 4543
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #131 - Codeforces - Code 1",
          "code": "int n = 300;\nfprintf(stdout, \"%d\\n\", n);\nfor (int i = 0; i < n; i++)\n    for (int c = 0; c < n; c++)\n        fprintf(stdout, \"%d%c\", ((i + c == 580) ? -1 : 0), c + 1 == n ? '\\n' : ' ');",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4965",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #131 - Codeforces - Code 2",
          "code": "int n = 300;\nfprintf(stdout, \"%d\\n\", n);\nfor (int i = 0; i < n; i++)\n    for (int c = 0; c < n; c++)\n        fprintf(stdout, \"%d%c\", ((i + c == 580) ? -1 : 0), c + 1 == n ? '\\n' : ' ');",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4965",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #131 - Codeforces - Code 3",
          "code": "Comb[len - 1][j]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4965",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #131 Tutorial - Codeforces - Code 1",
          "code": "(a-b)(a+b-1)=n-m",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4982",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 300, \"n\");\n    inf.readEoln();\n\n    for (int i = 0; i < n; i++) {\n        vector<int> row = inf.readInts(n, -1000, 1000, \"a_i_j\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 300, \"n\");\n    inf.readEoln();\n\n    for (int i = 0; i < n; i++) {\n        vector<int> row = inf.readInts(n, -1000, 1000, \"a_i_j\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 300, \"n\");\n    inf.readEoln();\n\n    for (int i = 0; i < n; i++) {\n        vector<int> row = inf.readInts(n, -1000, 1000, \"a_i_j\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n    int min_val = opt<int>(\"min_val\", -1000);\n    int max_val = opt<int>(\"max_val\", 1000);\n\n    vector<vector<int> > grid(n, vector<int>(n, 0));\n\n    if (type == \"random\") {\n        for (int i = 0; i < n; ++i)\n            for (int j = 0; j < n; ++j)\n                grid[i][j] = rnd.next(min_val, max_val);\n    }\n    else if (type == \"all_positive\") {\n        for (int i = 0; i < n; ++i)\n            for (int j = 0; j < n; ++j)\n                grid[i][j] = rnd.next(max(1, min_val), max_val);\n    }\n    else if (type == \"all_negative\") {\n        for (int i = 0; i < n; ++i)\n            for (int j = 0; j < n; ++j)\n                grid[i][j] = rnd.next(min_val, min(-1, max_val));\n    }\n    else if (type == \"diagonal_high\") {\n        int high_val = max_val;\n        for (int i = 0; i < n; ++i) {\n            grid[i][i] = high_val;\n        }\n        for (int i = 0; i < n; ++i)\n            for (int j = 0; j < n; ++j)\n                if (i != j)\n                    grid[i][j] = rnd.next(min_val, max_val);\n    }\n    else if (type == \"perimeter_high\") {\n        int high_val = max_val;\n        for (int i = 0; i < n; ++i) {\n            grid[0][i] = high_val;\n            grid[n-1][i] = high_val;\n            grid[i][0] = high_val;\n            grid[i][n-1] = high_val;\n        }\n        for (int i = 1; i < n - 1; ++i)\n            for (int j = 1; j < n -1; ++j)\n                grid[i][j] = rnd.next(min_val, max_val);\n    }\n    else if (type == \"single_max\") {\n        int x = rnd.next(0, n-1);\n        int y = rnd.next(0, n-1);\n        grid[x][y] = max_val;\n        for (int i = 0; i < n; ++i)\n            for (int j = 0; j < n; ++j)\n                if (!(i == x && j == y))\n                    grid[i][j] = rnd.next(min_val, max_val);\n    }\n    else if (type == \"sparse\") {\n        int non_zero_cells = min(n * n, 10); \n        vector<pair<int, int> > positions;\n        for (int i = 0; i < n; ++i)\n            for (int j = 0; j < n; ++j)\n                positions.push_back(make_pair(i, j));\n        shuffle(positions.begin(), positions.end());\n        for (int k = 0; k < non_zero_cells; ++k) {\n            int i = positions[k].first;\n            int j = positions[k].second;\n            int val = rnd.next(min_val, max_val);\n            if (val == 0) val = 1; // Ensure non-zero\n            grid[i][j] = val;\n        }\n    }\n    else if (type == \"zeros\") {\n        // All cells zero\n    }\n    else if (type == \"max_size\") {\n        n = 300;\n        grid.resize(n, vector<int>(n));\n        for (int i = 0; i < n; ++i)\n            for (int j = 0; j < n; ++j)\n                grid[i][j] = rnd.next(min_val, max_val);\n    }\n    else {\n        for (int i = 0; i < n; ++i)\n            for (int j = 0; j < n; ++j)\n                grid[i][j] = rnd.next(min_val, max_val);\n    }\n\n    printf(\"%d\\n\", n);\n\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < n; ++j) {\n            printf(\"%d\", grid[i][j]);\n            if (j < n - 1)\n                printf(\" \");\n        }\n        printf(\"\\n\");\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n    int min_val = opt<int>(\"min_val\", -1000);\n    int max_val = opt<int>(\"max_val\", 1000);\n\n    vector<vector<int> > grid(n, vector<int>(n, 0));\n\n    if (type == \"random\") {\n        for (int i = 0; i < n; ++i)\n            for (int j = 0; j < n; ++j)\n                grid[i][j] = rnd.next(min_val, max_val);\n    }\n    else if (type == \"all_positive\") {\n        for (int i = 0; i < n; ++i)\n            for (int j = 0; j < n; ++j)\n                grid[i][j] = rnd.next(max(1, min_val), max_val);\n    }\n    else if (type == \"all_negative\") {\n        for (int i = 0; i < n; ++i)\n            for (int j = 0; j < n; ++j)\n                grid[i][j] = rnd.next(min_val, min(-1, max_val));\n    }\n    else if (type == \"diagonal_high\") {\n        int high_val = max_val;\n        for (int i = 0; i < n; ++i) {\n            grid[i][i] = high_val;\n        }\n        for (int i = 0; i < n; ++i)\n            for (int j = 0; j < n; ++j)\n                if (i != j)\n                    grid[i][j] = rnd.next(min_val, max_val);\n    }\n    else if (type == \"perimeter_high\") {\n        int high_val = max_val;\n        for (int i = 0; i < n; ++i) {\n            grid[0][i] = high_val;\n            grid[n-1][i] = high_val;\n            grid[i][0] = high_val;\n            grid[i][n-1] = high_val;\n        }\n        for (int i = 1; i < n - 1; ++i)\n            for (int j = 1; j < n -1; ++j)\n                grid[i][j] = rnd.next(min_val, max_val);\n    }\n    else if (type == \"single_max\") {\n        int x = rnd.next(0, n-1);\n        int y = rnd.next(0, n-1);\n        grid[x][y] = max_val;\n        for (int i = 0; i < n; ++i)\n            for (int j = 0; j < n; ++j)\n                if (!(i == x && j == y))\n                    grid[i][j] = rnd.next(min_val, max_val);\n    }\n    else if (type == \"sparse\") {\n        int non_zero_cells = min(n * n, 10); \n        vector<pair<int, int> > positions;\n        for (int i = 0; i < n; ++i)\n            for (int j = 0; j < n; ++j)\n                positions.push_back(make_pair(i, j));\n        shuffle(positions.begin(), positions.end());\n        for (int k = 0; k < non_zero_cells; ++k) {\n            int i = positions[k].first;\n            int j = positions[k].second;\n            int val = rnd.next(min_val, max_val);\n            if (val == 0) val = 1; // Ensure non-zero\n            grid[i][j] = val;\n        }\n    }\n    else if (type == \"zeros\") {\n        // All cells zero\n    }\n    else if (type == \"max_size\") {\n        n = 300;\n        grid.resize(n, vector<int>(n));\n        for (int i = 0; i < n; ++i)\n            for (int j = 0; j < n; ++j)\n                grid[i][j] = rnd.next(min_val, max_val);\n    }\n    else {\n        for (int i = 0; i < n; ++i)\n            for (int j = 0; j < n; ++j)\n                grid[i][j] = rnd.next(min_val, max_val);\n    }\n\n    printf(\"%d\\n\", n);\n\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < n; ++j) {\n            printf(\"%d\", grid[i][j]);\n            if (j < n - 1)\n                printf(\" \");\n        }\n        printf(\"\\n\");\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -type random\n./gen -n 2 -type random\n./gen -n 300 -type random\n./gen -n 300 -type all_positive\n./gen -n 300 -type all_negative\n./gen -n 300 -type diagonal_high\n./gen -n 299 -type perimeter_high\n./gen -n 250 -type single_max -min_val -1000 -max_val 1000\n./gen -n 250 -type sparse\n./gen -n 250 -type zeros\n./gen -n 300 -type random -min_val 0 -max_val 1000\n./gen -n 300 -type random -min_val -1000 -max_val 0\n./gen -n 300 -type random -min_val -5 -max_val 5\n./gen -n 50 -type random\n./gen -n 300 -type max_size\n./gen -n 200 -type random\n./gen -n 100 -type random\n./gen -n 2 -type random -min_val -1000 -max_val 1000\n./gen -n 299 -type random -min_val 1000 -max_val 1000\n./gen -n 299 -type random -min_val -1000 -max_val -1000\n./gen -n 250 -type random -min_val 0 -max_val 0\n./gen -n 300 -type random -min_val -1000 -max_val 1000\n./gen -n 300 -type diagonal_high -min_val -1000 -max_val 1000\n./gen -n 300 -type perimeter_high -min_val -1000 -max_val 1000\n./gen -n 300 -type single_max -min_val -1000 -max_val 1000\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T19:49:48.457751",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "215/A",
      "title": "A. Цепная передача",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест2 секунды",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеВ первой строке входных данных записано целое число n (1 ≤ n ≤ 50) — количество звездочек на оси педалей велосипеда. Во второй строке записаны n целых чисел a1, a2, ..., an (1 ≤ ai ≤ 104) в порядке строгого возрастания.В третьей строке входных данных записано целое число m (1 ≤ m ≤ 50) — количество звездочек на оси заднего колеса. В четвертой строке записаны m целых чисел b1, b2, ..., bm (1 ≤ bi ≤ 104) в порядке строгого возрастания.Гарантируется, что существует хотя бы одна передача (i, j), что ее передаточное число — целое. Числа в строках разделяются пробелами.",
      "output_spec": "Выходные данныеВыведите количество «целочисленных» передач, которые имеют максимальное значение передаточного числа среди всех «целочисленных» передач.",
      "sample_tests": "ПримерыВходные данныеСкопировать24 5312 13 15Выходные данныеСкопировать2Входные данныеСкопировать41 2 3 4510 11 12 13 14Выходные данныеСкопировать1",
      "description": "A. Цепная передача\n\nограничение по времени на тест2 секунды\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвыводstdout\n\nВходные данныеВ первой строке входных данных записано целое число n (1 ≤ n ≤ 50) — количество звездочек на оси педалей велосипеда. Во второй строке записаны n целых чисел a1, a2, ..., an (1 ≤ ai ≤ 104) в порядке строгого возрастания.В третьей строке входных данных записано целое число m (1 ≤ m ≤ 50) — количество звездочек на оси заднего колеса. В четвертой строке записаны m целых чисел b1, b2, ..., bm (1 ≤ bi ≤ 104) в порядке строгого возрастания.Гарантируется, что существует хотя бы одна передача (i, j), что ее передаточное число — целое. Числа в строках разделяются пробелами.\n\nВходные данные\n\nВыходные данныеВыведите количество «целочисленных» передач, которые имеют максимальное значение передаточного числа среди всех «целочисленных» передач.\n\nВыходные данные\n\nВходные данныеСкопировать24 5312 13 15Выходные данныеСкопировать2Входные данныеСкопировать41 2 3 4510 11 12 13 14Выходные данныеСкопировать1\n\nВходные данныеСкопировать24 5312 13 15\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать2\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать41 2 3 4510 11 12 13 14\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать1\n\nВыходные данныеСкопировать\n\nСкопировать\n\nПримечаниеВ первом примере максимальное целое передаточное число равно 3. Существуют две передачи, которые имеют такое передаточное число. Для одной из них a1 = 4, b1 = 12, а для другой a2 = 5, b3 = 15.",
      "solutions": [
        {
          "title": "Codeforces Round #132 (Div. 2) - Codeforces",
          "content": "Доброе время суток!Через несколько часов начнется очередной Codeforces Round #132 для участников Div.2, но традиционно остальные могут поучаствовать вне конкурса. Он был подготовлен небольшой командой авторов: я (NALP), Эдвард Давтян (Edvard), Виталий Аксенов (Aksenov239), Геральд Агапов (Gerald), Мария Белова (Delinur) и Михаил Мирзаянов (MikeMirzayanov).Традиционно всем удачи, полных решений и удачных взломов!Отдельно хочется пожелать успеха и спортивной удачи всем, кто сейчас представляет свои страны на XXX Олимпийских играх в Лондоне! На раунде будет использована динамическая система оценки задач. Но, несмотря на это, задачи будут расположены в предположительном порядке возрастания сложности!UPD: Раунд завершен, спасибо всем за участие! Надеемся, что все участники получили удовольствие!UPD: Поздравляем победителей! yooo — единственный участник Div.2, кто решил все представленные задачи! zzy High_Rich_Handsome bookcity_clock capythm UPD: Разбор задач на русском языке уже опубликован!",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/5017",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 1001
        },
        {
          "title": "Codeforces Round #132 (Div. 2) - Codeforces",
          "content": "Доброе время суток!Через несколько часов начнется очередной Codeforces Round #132 для участников Div.2, но традиционно остальные могут поучаствовать вне конкурса. Он был подготовлен небольшой командой авторов: я (NALP), Эдвард Давтян (Edvard), Виталий Аксенов (Aksenov239), Геральд Агапов (Gerald), Мария Белова (Delinur) и Михаил Мирзаянов (MikeMirzayanov).Традиционно всем удачи, полных решений и удачных взломов!Отдельно хочется пожелать успеха и спортивной удачи всем, кто сейчас представляет свои страны на XXX Олимпийских играх в Лондоне! На раунде будет использована динамическая система оценки задач. Но, несмотря на это, задачи будут расположены в предположительном порядке возрастания сложности!UPD: Раунд завершен, спасибо всем за участие! Надеемся, что все участники получили удовольствие!UPD: Поздравляем победителей! yooo — единственный участник Div.2, кто решил все представленные задачи! zzy High_Rich_Handsome bookcity_clock capythm UPD: Разбор задач на русском языке уже опубликован!",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/5017",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 1001
        },
        {
          "title": "Разбор задачи E CF#132 - Codeforces",
          "content": "Привет всем! Дальше я постараюсь объяснить решение задачи E Codeforces Round #132.Давайте научимся решать немного другую задачу и будем искать число периодических чисел в полуинтервале (2k, x], где . Тогда видно, что x имеет длину len = k + 1.Теперь найдем блоки из единиц и двоек, которые, как раз, и являются общей частью периодического числа. У таких блоков, как следует из определения, длина является делителем длины всего числа len.Теперь посчитаем число таких блоков g[i], которые имеют длину i, i делитель len. Возьмем старшие i бит числа x и назовем соответствующее число t = x >> (len - i), например если взять x = 100110002, а i = 4, то тогда t = 10012, а если i = 2, то t = 102. Первым делом, проверим подходит ли этот блок t, это можно сделать, например, посчитав p = ttttt..., где t повторяется раз, p можно посчитать в цикле p = (p << i) + t. Понятно, что если p ≤ x, то посчитаем этот блок и сделаем g[i] = 1, иначе g[i] = 0. Все подходящие блоки должны быть меньше или равны t, и первая цифра у них обязательно 1, так как не может быть лидирующих нулей. Случай равенства мы уже учли, тогда осталось добавить к g[i] разницу между t и 2i - 1 = 10000...2, где i-1 нулей, g[i] = g[i] + t - (1 << (i - 1)). Может показаться, что все уже готово и можем сложить все g[i], где i делитель len, и не равно len, но нельзя. Покажем, что таким образом мы учли некоторые случаи по нескольку раз, например для x = 101011002, i = 4, g[4] = 1 + (10102 - 10002) = 3, мы посчитали блоки 1000, 1001, 1010, и если взять i = 2,g[2] = 1 + (102 - 102) = 1, мы учтем 10, но 1010 получается из 10 повторением два раза. Но эта проблема очень легко решается, для этого необходимо вычесть из g[i] все g[j], где j < i и j делитель i.То есть мы считаем, своего рода, динамику.g[i] начиная с i = 1 до самого большого делителя len не равного len, и обновляем значения, вычитая соответствующие g[j].Теперь мы научились считать количество таких чисел на полуинтервале (2k, x], перебирая все делители len и считая динамику g[i], и потом возвращаем сумму g[i], по всем делителям i < len . Заметим, что степень двойки не может быть периодическим числом. Теперь мы можем посчитать аналогичную величину для x = 2k - 1, дальше для 2k - 1 - 1 и так далее, пока не станет x = 1, теперь на этих непересекающихся полуинтервалах посчитаем сумму и вернем ответ. Это можно реализовать рекурсией. Вот мой код на C++, я дополнительно предпосчитал все делители для чисел до 60. Спасибо за внимание, надеюсь вам все понятно, а если не понятно задавайте вопросы)UPD: Еще один код, который немного асимптотически быстрее.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/5034",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 2583
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #132 (Div. 2) - Codeforces - Code 1",
          "code": "#define int unsigned long long",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5017",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #132 (Div. 2) - Codeforces - Code 2",
          "code": "value.ToString(CultureInfo.InvariantCulture)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5017",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #132 (Div. 2) - Codeforces - Code 3",
          "code": "value.ToString().Replace(',','.')",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5017",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #132 (Div. 2) - Codeforces - Code 1",
          "code": "#define int unsigned long long",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5017",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #132 (Div. 2) - Codeforces - Code 2",
          "code": "value.ToString(CultureInfo.InvariantCulture)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5017",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #132 (Div. 2) - Codeforces - Code 3",
          "code": "value.ToString().Replace(',','.')",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5017",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 50, \"n\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, 1, 10000, \"a\");\n    for (int i = 0; i + 1 < n; ++i) {\n        ensuref(a[i] < a[i+1], \"Array 'a' is not strictly increasing at position %d\", i+2);\n    }\n    inf.readEoln();\n\n    int m = inf.readInt(1, 50, \"m\");\n    inf.readEoln();\n\n    vector<int> b = inf.readInts(m, 1, 10000, \"b\");\n    for (int i = 0; i + 1 < m; ++i) {\n        ensuref(b[i] < b[i+1], \"Array 'b' is not strictly increasing at position %d\", i+2);\n    }\n    inf.readEoln();\n\n    bool ratio_exists = false;\n    for(int i = 0; i < n && !ratio_exists; ++i){\n        for(int j = 0; j < m && !ratio_exists; ++j){\n            if(b[j] % a[i] == 0){\n                ratio_exists = true;\n            }\n        }\n    }\n    ensuref(ratio_exists, \"There is no gear ratio that is an integer.\");\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 50, \"n\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, 1, 10000, \"a\");\n    for (int i = 0; i + 1 < n; ++i) {\n        ensuref(a[i] < a[i+1], \"Array 'a' is not strictly increasing at position %d\", i+2);\n    }\n    inf.readEoln();\n\n    int m = inf.readInt(1, 50, \"m\");\n    inf.readEoln();\n\n    vector<int> b = inf.readInts(m, 1, 10000, \"b\");\n    for (int i = 0; i + 1 < m; ++i) {\n        ensuref(b[i] < b[i+1], \"Array 'b' is not strictly increasing at position %d\", i+2);\n    }\n    inf.readEoln();\n\n    bool ratio_exists = false;\n    for(int i = 0; i < n && !ratio_exists; ++i){\n        for(int j = 0; j < m && !ratio_exists; ++j){\n            if(b[j] % a[i] == 0){\n                ratio_exists = true;\n            }\n        }\n    }\n    ensuref(ratio_exists, \"There is no gear ratio that is an integer.\");\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 50, \"n\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, 1, 10000, \"a\");\n    for (int i = 0; i + 1 < n; ++i) {\n        ensuref(a[i] < a[i+1], \"Array 'a' is not strictly increasing at position %d\", i+2);\n    }\n    inf.readEoln();\n\n    int m = inf.readInt(1, 50, \"m\");\n    inf.readEoln();\n\n    vector<int> b = inf.readInts(m, 1, 10000, \"b\");\n    for (int i = 0; i + 1 < m; ++i) {\n        ensuref(b[i] < b[i+1], \"Array 'b' is not strictly increasing at position %d\", i+2);\n    }\n    inf.readEoln();\n\n    bool ratio_exists = false;\n    for(int i = 0; i < n && !ratio_exists; ++i){\n        for(int j = 0; j < m && !ratio_exists; ++j){\n            if(b[j] % a[i] == 0){\n                ratio_exists = true;\n            }\n        }\n    }\n    ensuref(ratio_exists, \"There is no gear ratio that is an integer.\");\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\n/* Generate a strictly increasing sequence of size 'n', with elements ranging from 'minValue' to 'maxValue' */\nvector<int> generate_sequence(int n, int minValue, int maxValue) {\n    set<int> s;\n    while ((int)s.size() < n) {\n        int val = rnd.next(minValue, maxValue);\n        s.insert(val);\n    }\n    vector<int> seq(s.begin(), s.end());\n    return seq;\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string type = opt<string>(\"type\", \"rand\");\n\n    vector<int> a;\n    vector<int> b;\n\n    if (type == \"rand\") {\n        /* Generate random sequences a[] and b[], ensure at least one integer gear ratio exists */\n        a = generate_sequence(n, 1, 10000);\n        b = generate_sequence(m, 1, 10000);\n\n        /* Ensure at least one integer gear ratio exists */\n        int i = rnd.next(0, n - 1);\n        int a_i = a[i];\n        int maxK = 10000 / a_i;\n        if (maxK < 1) maxK = 1;\n        int k = rnd.next(1, maxK);\n        int b_j = a_i * k;\n\n        /* Ensure b_j is unique and within the range */\n        set<int> sb;\n        while ((int)sb.size() < m - 1) {\n            int val = rnd.next(1, 10000);\n            if (val != b_j) {\n                sb.insert(val);\n            }\n        }\n        sb.insert(b_j);\n        b.assign(sb.begin(), sb.end());\n    } else if (type == \"singleratio\") {\n        /* Generate sequences where only one gear has integer ratio, and it's the maximum */\n        a = generate_sequence(n, 1, 10000);\n        b = generate_sequence(m, 1, 10000);\n\n        /* Find the maximum possible integer gear ratio */\n        int max_ratio = 0;\n        int best_a = a.back(); // Largest a_i\n        int maxK = 10000 / best_a;\n        if (maxK > 0) {\n            max_ratio = maxK;\n        } else {\n            max_ratio = 1;\n        }\n        int b_j = best_a * max_ratio;\n\n        /* Ensure b_j is within limits */\n        if (b_j > 10000) {\n            b_j = 10000;\n            max_ratio = b_j / best_a;\n        }\n\n        /* Replace one element in b[] with b_j */\n        b[rnd.next(0, m - 1)] = b_j;\n\n        /* Ensure no other b_j / a_i is integer and equals max_ratio */\n        // Adjust a[] and b[] to ensure the above\n        for (int i = 0; i < n; ++i) {\n            if (a[i] != best_a) {\n                for (int j = 0; j < m; ++j) {\n                    if (b[j] % a[i] == 0 && b[j] / a[i] >= max_ratio) {\n                        // Adjust b[j] to break the integer ratio\n                        b[j] += 1;\n                        if (b[j] > 10000) b[j] -= 2;\n                    }\n                }\n            }\n        }\n    } else if (type == \"min\") {\n        /* Minimal n and m */\n        n = 1;\n        m = 1;\n        a.push_back(1);\n        b.push_back(1);\n    } else if (type == \"max\") {\n        /* Maximal n and m */\n        n = 50;\n        m = 50;\n        /* Generate sequences with maximum possible values */\n        a = generate_sequence(n, 10000 - n + 1, 10000);\n        b = generate_sequence(m, 10000 - m + 1, 10000);\n\n        /* Ensure at least one integer gear ratio exists */\n        int a_i = a.back();\n        int b_j = b.back();\n        if (b_j % a_i != 0) {\n            b.back() = a_i * (b_j / a_i);\n            if (b.back() > 10000) b.back() = a_i; // Adjust if necessary\n        }\n    } else {\n        /* Default random test case */\n        a = generate_sequence(n, 1, 10000);\n        b = generate_sequence(m, 1, 10000);\n    }\n\n    /* Output n and a[] */\n    printf(\"%d\\n\", n);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d%c\", a[i], (i == n - 1) ? '\\n' : ' ');\n    }\n\n    /* Output m and b[] */\n    printf(\"%d\\n\", m);\n    for (int i = 0; i < m; ++i) {\n        printf(\"%d%c\", b[i], (i == m - 1) ? '\\n' : ' ');\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\n/* Generate a strictly increasing sequence of size 'n', with elements ranging from 'minValue' to 'maxValue' */\nvector<int> generate_sequence(int n, int minValue, int maxValue) {\n    set<int> s;\n    while ((int)s.size() < n) {\n        int val = rnd.next(minValue, maxValue);\n        s.insert(val);\n    }\n    vector<int> seq(s.begin(), s.end());\n    return seq;\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string type = opt<string>(\"type\", \"rand\");\n\n    vector<int> a;\n    vector<int> b;\n\n    if (type == \"rand\") {\n        /* Generate random sequences a[] and b[], ensure at least one integer gear ratio exists */\n        a = generate_sequence(n, 1, 10000);\n        b = generate_sequence(m, 1, 10000);\n\n        /* Ensure at least one integer gear ratio exists */\n        int i = rnd.next(0, n - 1);\n        int a_i = a[i];\n        int maxK = 10000 / a_i;\n        if (maxK < 1) maxK = 1;\n        int k = rnd.next(1, maxK);\n        int b_j = a_i * k;\n\n        /* Ensure b_j is unique and within the range */\n        set<int> sb;\n        while ((int)sb.size() < m - 1) {\n            int val = rnd.next(1, 10000);\n            if (val != b_j) {\n                sb.insert(val);\n            }\n        }\n        sb.insert(b_j);\n        b.assign(sb.begin(), sb.end());\n    } else if (type == \"singleratio\") {\n        /* Generate sequences where only one gear has integer ratio, and it's the maximum */\n        a = generate_sequence(n, 1, 10000);\n        b = generate_sequence(m, 1, 10000);\n\n        /* Find the maximum possible integer gear ratio */\n        int max_ratio = 0;\n        int best_a = a.back(); // Largest a_i\n        int maxK = 10000 / best_a;\n        if (maxK > 0) {\n            max_ratio = maxK;\n        } else {\n            max_ratio = 1;\n        }\n        int b_j = best_a * max_ratio;\n\n        /* Ensure b_j is within limits */\n        if (b_j > 10000) {\n            b_j = 10000;\n            max_ratio = b_j / best_a;\n        }\n\n        /* Replace one element in b[] with b_j */\n        b[rnd.next(0, m - 1)] = b_j;\n\n        /* Ensure no other b_j / a_i is integer and equals max_ratio */\n        // Adjust a[] and b[] to ensure the above\n        for (int i = 0; i < n; ++i) {\n            if (a[i] != best_a) {\n                for (int j = 0; j < m; ++j) {\n                    if (b[j] % a[i] == 0 && b[j] / a[i] >= max_ratio) {\n                        // Adjust b[j] to break the integer ratio\n                        b[j] += 1;\n                        if (b[j] > 10000) b[j] -= 2;\n                    }\n                }\n            }\n        }\n    } else if (type == \"min\") {\n        /* Minimal n and m */\n        n = 1;\n        m = 1;\n        a.push_back(1);\n        b.push_back(1);\n    } else if (type == \"max\") {\n        /* Maximal n and m */\n        n = 50;\n        m = 50;\n        /* Generate sequences with maximum possible values */\n        a = generate_sequence(n, 10000 - n + 1, 10000);\n        b = generate_sequence(m, 10000 - m + 1, 10000);\n\n        /* Ensure at least one integer gear ratio exists */\n        int a_i = a.back();\n        int b_j = b.back();\n        if (b_j % a_i != 0) {\n            b.back() = a_i * (b_j / a_i);\n            if (b.back() > 10000) b.back() = a_i; // Adjust if necessary\n        }\n    } else {\n        /* Default random test case */\n        a = generate_sequence(n, 1, 10000);\n        b = generate_sequence(m, 1, 10000);\n    }\n\n    /* Output n and a[] */\n    printf(\"%d\\n\", n);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d%c\", a[i], (i == n - 1) ? '\\n' : ' ');\n    }\n\n    /* Output m and b[] */\n    printf(\"%d\\n\", m);\n    for (int i = 0; i < m; ++i) {\n        printf(\"%d%c\", b[i], (i == m - 1) ? '\\n' : ' ');\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Random test cases of various sizes\n./gen -n 10 -m 10 -type rand\n./gen -n 20 -m 15 -type rand\n./gen -n 30 -m 25 -type rand\n./gen -n 40 -m 30 -type rand\n./gen -n 50 -m 50 -type rand\n\n# Test cases where there is only one maximum integer gear ratio\n./gen -n 10 -m 10 -type singleratio\n./gen -n 20 -m 15 -type singleratio\n./gen -n 30 -m 25 -type singleratio\n./gen -n 40 -m 30 -type singleratio\n./gen -n 50 -m 50 -type singleratio\n\n# Minimal edge cases\n./gen -n 1 -m 1 -type min\n./gen -n 1 -m 50 -type min\n./gen -n 50 -m 1 -type min\n\n# Maximal edge cases\n./gen -n 50 -m 50 -type max\n\n# Additional random test cases\n./gen -n 5 -m 5 -type rand\n./gen -n 15 -m 10 -type rand\n./gen -n 25 -m 20 -type rand\n./gen -n 35 -m 30 -type rand\n./gen -n 45 -m 40 -type rand\n\n# Test cases with maximum values\n./gen -n 50 -m 50 -type rand\n./gen -n 50 -m 50 -type singleratio\n\n# Random test cases with small n and m\n./gen -n 2 -m 2 -type rand\n./gen -n 3 -m 3 -type rand\n\n# Random test cases with n = 50 and small m\n./gen -n 50 -m 2 -type rand\n./gen -n 50 -m 3 -type rand\n\n# Random test cases with m = 50 and small n\n./gen -n 2 -m 50 -type rand\n./gen -n 3 -m 50 -type rand\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T19:49:50.818817",
        "total_tutorials": 3,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "215/B",
      "title": "B. Олимпийская медаль",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест2 секунды",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеВ первой строке входных данных записано целое число n и последовательность целых чисел x1, x2, ..., xn. Во второй строке входных данных записано целое число m и последовательность целых чисел y1, y2, ..., ym. В третьей строке входных данных записано целое число k и последовательность целых чисел z1, z2, ..., zk. В последней строке записано два целых числа A и B.Все заданные во входных данных числа положительные и не превосходят 5000. Каждая из трех последовательностей содержит различные числа. Числа в строках разделяются пробелами.",
      "output_spec": "Выходные данныеВыведите одно вещественное число — искомую величину r2 с абсолютной или относительной погрешностью не более 10 - 6. Гарантируется, что существует решение, удовлетворяющее условиям задачи.",
      "sample_tests": "ПримерыВходные данныеСкопировать3 1 2 31 23 3 2 11 2Выходные данныеСкопировать2.683281573000Входные данныеСкопировать4 2 3 6 42 1 23 10 6 82 1Выходные данныеСкопировать2.267786838055",
      "description": "B. Олимпийская медаль\n\nограничение по времени на тест2 секунды\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвыводstdout\n\nВходные данныеВ первой строке входных данных записано целое число n и последовательность целых чисел x1, x2, ..., xn. Во второй строке входных данных записано целое число m и последовательность целых чисел y1, y2, ..., ym. В третьей строке входных данных записано целое число k и последовательность целых чисел z1, z2, ..., zk. В последней строке записано два целых числа A и B.Все заданные во входных данных числа положительные и не превосходят 5000. Каждая из трех последовательностей содержит различные числа. Числа в строках разделяются пробелами.\n\nВходные данные\n\nВыходные данныеВыведите одно вещественное число — искомую величину r2 с абсолютной или относительной погрешностью не более 10 - 6. Гарантируется, что существует решение, удовлетворяющее условиям задачи.\n\nВыходные данные\n\nВходные данныеСкопировать3 1 2 31 23 3 2 11 2Выходные данныеСкопировать2.683281573000Входные данныеСкопировать4 2 3 6 42 1 23 10 6 82 1Выходные данныеСкопировать2.267786838055\n\nВходные данныеСкопировать3 1 2 31 23 3 2 11 2\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать2.683281573000\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать4 2 3 6 42 1 23 10 6 82 1\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать2.267786838055\n\nВыходные данныеСкопировать\n\nСкопировать\n\nПримечаниеВ первом примере нужно выбрать следующие значения: r1 = 3, p1 = 2, p2 = 1.",
      "solutions": [
        {
          "title": "Codeforces Round #132 (Div. 2) - Codeforces",
          "content": "Доброе время суток!Через несколько часов начнется очередной Codeforces Round #132 для участников Div.2, но традиционно остальные могут поучаствовать вне конкурса. Он был подготовлен небольшой командой авторов: я (NALP), Эдвард Давтян (Edvard), Виталий Аксенов (Aksenov239), Геральд Агапов (Gerald), Мария Белова (Delinur) и Михаил Мирзаянов (MikeMirzayanov).Традиционно всем удачи, полных решений и удачных взломов!Отдельно хочется пожелать успеха и спортивной удачи всем, кто сейчас представляет свои страны на XXX Олимпийских играх в Лондоне! На раунде будет использована динамическая система оценки задач. Но, несмотря на это, задачи будут расположены в предположительном порядке возрастания сложности!UPD: Раунд завершен, спасибо всем за участие! Надеемся, что все участники получили удовольствие!UPD: Поздравляем победителей! yooo — единственный участник Div.2, кто решил все представленные задачи! zzy High_Rich_Handsome bookcity_clock capythm UPD: Разбор задач на русском языке уже опубликован!",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/5017",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 1001
        },
        {
          "title": "Codeforces Round #132 (Div. 2) - Codeforces",
          "content": "Доброе время суток!Через несколько часов начнется очередной Codeforces Round #132 для участников Div.2, но традиционно остальные могут поучаствовать вне конкурса. Он был подготовлен небольшой командой авторов: я (NALP), Эдвард Давтян (Edvard), Виталий Аксенов (Aksenov239), Геральд Агапов (Gerald), Мария Белова (Delinur) и Михаил Мирзаянов (MikeMirzayanov).Традиционно всем удачи, полных решений и удачных взломов!Отдельно хочется пожелать успеха и спортивной удачи всем, кто сейчас представляет свои страны на XXX Олимпийских играх в Лондоне! На раунде будет использована динамическая система оценки задач. Но, несмотря на это, задачи будут расположены в предположительном порядке возрастания сложности!UPD: Раунд завершен, спасибо всем за участие! Надеемся, что все участники получили удовольствие!UPD: Поздравляем победителей! yooo — единственный участник Div.2, кто решил все представленные задачи! zzy High_Rich_Handsome bookcity_clock capythm UPD: Разбор задач на русском языке уже опубликован!",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/5017",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 1001
        },
        {
          "title": "Разбор задачи E CF#132 - Codeforces",
          "content": "Привет всем! Дальше я постараюсь объяснить решение задачи E Codeforces Round #132.Давайте научимся решать немного другую задачу и будем искать число периодических чисел в полуинтервале (2k, x], где . Тогда видно, что x имеет длину len = k + 1.Теперь найдем блоки из единиц и двоек, которые, как раз, и являются общей частью периодического числа. У таких блоков, как следует из определения, длина является делителем длины всего числа len.Теперь посчитаем число таких блоков g[i], которые имеют длину i, i делитель len. Возьмем старшие i бит числа x и назовем соответствующее число t = x >> (len - i), например если взять x = 100110002, а i = 4, то тогда t = 10012, а если i = 2, то t = 102. Первым делом, проверим подходит ли этот блок t, это можно сделать, например, посчитав p = ttttt..., где t повторяется раз, p можно посчитать в цикле p = (p << i) + t. Понятно, что если p ≤ x, то посчитаем этот блок и сделаем g[i] = 1, иначе g[i] = 0. Все подходящие блоки должны быть меньше или равны t, и первая цифра у них обязательно 1, так как не может быть лидирующих нулей. Случай равенства мы уже учли, тогда осталось добавить к g[i] разницу между t и 2i - 1 = 10000...2, где i-1 нулей, g[i] = g[i] + t - (1 << (i - 1)). Может показаться, что все уже готово и можем сложить все g[i], где i делитель len, и не равно len, но нельзя. Покажем, что таким образом мы учли некоторые случаи по нескольку раз, например для x = 101011002, i = 4, g[4] = 1 + (10102 - 10002) = 3, мы посчитали блоки 1000, 1001, 1010, и если взять i = 2,g[2] = 1 + (102 - 102) = 1, мы учтем 10, но 1010 получается из 10 повторением два раза. Но эта проблема очень легко решается, для этого необходимо вычесть из g[i] все g[j], где j < i и j делитель i.То есть мы считаем, своего рода, динамику.g[i] начиная с i = 1 до самого большого делителя len не равного len, и обновляем значения, вычитая соответствующие g[j].Теперь мы научились считать количество таких чисел на полуинтервале (2k, x], перебирая все делители len и считая динамику g[i], и потом возвращаем сумму g[i], по всем делителям i < len . Заметим, что степень двойки не может быть периодическим числом. Теперь мы можем посчитать аналогичную величину для x = 2k - 1, дальше для 2k - 1 - 1 и так далее, пока не станет x = 1, теперь на этих непересекающихся полуинтервалах посчитаем сумму и вернем ответ. Это можно реализовать рекурсией. Вот мой код на C++, я дополнительно предпосчитал все делители для чисел до 60. Спасибо за внимание, надеюсь вам все понятно, а если не понятно задавайте вопросы)UPD: Еще один код, который немного асимптотически быстрее.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/5034",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 2583
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #132 (Div. 2) - Codeforces - Code 1",
          "code": "#define int unsigned long long",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5017",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #132 (Div. 2) - Codeforces - Code 2",
          "code": "value.ToString(CultureInfo.InvariantCulture)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5017",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #132 (Div. 2) - Codeforces - Code 3",
          "code": "value.ToString().Replace(',','.')",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5017",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #132 (Div. 2) - Codeforces - Code 1",
          "code": "#define int unsigned long long",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5017",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #132 (Div. 2) - Codeforces - Code 2",
          "code": "value.ToString(CultureInfo.InvariantCulture)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5017",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #132 (Div. 2) - Codeforces - Code 3",
          "code": "value.ToString().Replace(',','.')",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5017",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    // Line 1: n x1 x2 ... xn\n    int n = inf.readInt(1, 5000, \"n\");\n    inf.readSpace();\n\n    vector<int> x_values;\n    for (int i = 0; i < n; i++) {\n        int x_i = inf.readInt(1, 5000, \"x_i\");\n        x_values.push_back(x_i);\n        if (i != n - 1) {\n            inf.readSpace();\n        } else {\n            inf.readEoln();\n        }\n    }\n    ensuref(set<int>(x_values.begin(), x_values.end()).size() == n, \"x_i values must be distinct\");\n\n    // Line 2: m y1 y2 ... ym\n    int m = inf.readInt(1, 5000, \"m\");\n    inf.readSpace();\n\n    vector<int> y_values;\n    for (int i = 0; i < m; i++) {\n        int y_i = inf.readInt(1, 5000, \"y_i\");\n        y_values.push_back(y_i);\n        if (i != m - 1) {\n            inf.readSpace();\n        } else {\n            inf.readEoln();\n        }\n    }\n    ensuref(set<int>(y_values.begin(), y_values.end()).size() == m, \"y_i values must be distinct\");\n\n    // Line 3: k z1 z2 ... zk\n    int k = inf.readInt(1, 5000, \"k\");\n    inf.readSpace();\n\n    vector<int> z_values;\n    for (int i = 0; i < k; i++) {\n        int z_i = inf.readInt(1, 5000, \"z_i\");\n        z_values.push_back(z_i);\n        if (i != k - 1) {\n            inf.readSpace();\n        } else {\n            inf.readEoln();\n        }\n    }\n    ensuref(set<int>(z_values.begin(), z_values.end()).size() == k, \"z_i values must be distinct\");\n\n    // Line 4: A B\n    int A = inf.readInt(1, 5000, \"A\");\n    inf.readSpace();\n    int B = inf.readInt(1, 5000, \"B\");\n    inf.readEoln();\n\n    inf.readEof();\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    // Line 1: n x1 x2 ... xn\n    int n = inf.readInt(1, 5000, \"n\");\n    inf.readSpace();\n\n    vector<int> x_values;\n    for (int i = 0; i < n; i++) {\n        int x_i = inf.readInt(1, 5000, \"x_i\");\n        x_values.push_back(x_i);\n        if (i != n - 1) {\n            inf.readSpace();\n        } else {\n            inf.readEoln();\n        }\n    }\n    ensuref(set<int>(x_values.begin(), x_values.end()).size() == n, \"x_i values must be distinct\");\n\n    // Line 2: m y1 y2 ... ym\n    int m = inf.readInt(1, 5000, \"m\");\n    inf.readSpace();\n\n    vector<int> y_values;\n    for (int i = 0; i < m; i++) {\n        int y_i = inf.readInt(1, 5000, \"y_i\");\n        y_values.push_back(y_i);\n        if (i != m - 1) {\n            inf.readSpace();\n        } else {\n            inf.readEoln();\n        }\n    }\n    ensuref(set<int>(y_values.begin(), y_values.end()).size() == m, \"y_i values must be distinct\");\n\n    // Line 3: k z1 z2 ... zk\n    int k = inf.readInt(1, 5000, \"k\");\n    inf.readSpace();\n\n    vector<int> z_values;\n    for (int i = 0; i < k; i++) {\n        int z_i = inf.readInt(1, 5000, \"z_i\");\n        z_values.push_back(z_i);\n        if (i != k - 1) {\n            inf.readSpace();\n        } else {\n            inf.readEoln();\n        }\n    }\n    ensuref(set<int>(z_values.begin(), z_values.end()).size() == k, \"z_i values must be distinct\");\n\n    // Line 4: A B\n    int A = inf.readInt(1, 5000, \"A\");\n    inf.readSpace();\n    int B = inf.readInt(1, 5000, \"B\");\n    inf.readEoln();\n\n    inf.readEof();\n\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    // Line 1: n x1 x2 ... xn\n    int n = inf.readInt(1, 5000, \"n\");\n    inf.readSpace();\n\n    vector<int> x_values;\n    for (int i = 0; i < n; i++) {\n        int x_i = inf.readInt(1, 5000, \"x_i\");\n        x_values.push_back(x_i);\n        if (i != n - 1) {\n            inf.readSpace();\n        } else {\n            inf.readEoln();\n        }\n    }\n    ensuref(set<int>(x_values.begin(), x_values.end()).size() == n, \"x_i values must be distinct\");\n\n    // Line 2: m y1 y2 ... ym\n    int m = inf.readInt(1, 5000, \"m\");\n    inf.readSpace();\n\n    vector<int> y_values;\n    for (int i = 0; i < m; i++) {\n        int y_i = inf.readInt(1, 5000, \"y_i\");\n        y_values.push_back(y_i);\n        if (i != m - 1) {\n            inf.readSpace();\n        } else {\n            inf.readEoln();\n        }\n    }\n    ensuref(set<int>(y_values.begin(), y_values.end()).size() == m, \"y_i values must be distinct\");\n\n    // Line 3: k z1 z2 ... zk\n    int k = inf.readInt(1, 5000, \"k\");\n    inf.readSpace();\n\n    vector<int> z_values;\n    for (int i = 0; i < k; i++) {\n        int z_i = inf.readInt(1, 5000, \"z_i\");\n        z_values.push_back(z_i);\n        if (i != k - 1) {\n            inf.readSpace();\n        } else {\n            inf.readEoln();\n        }\n    }\n    ensuref(set<int>(z_values.begin(), z_values.end()).size() == k, \"z_i values must be distinct\");\n\n    // Line 4: A B\n    int A = inf.readInt(1, 5000, \"A\");\n    inf.readSpace();\n    int B = inf.readInt(1, 5000, \"B\");\n    inf.readEoln();\n\n    inf.readEof();\n\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nconst double EPS = 1E-6;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare two sequences of doubles, max absolute or relative  error = %.7f\", EPS);\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    double j = 0, p = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        n++;\r\n        j = ans.readDouble();\r\n        p = ouf.readDouble();\r\n        if (!doubleCompare(j, p, EPS)) {\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%.7f', found: '%.7f', error = '%.7f'\",\r\n                  n, englishEnding(n).c_str(), j, p, doubleDelta(j, p));\r\n        }\r\n    }\r\n\r\n    if (n == 1)\r\n        quitf(_ok, \"found '%.7f', expected '%.7f', error '%.7f'\", p, j, doubleDelta(j, p));\r\n\r\n    quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    int k = opt<int>(\"k\");\n    int A = opt<int>(\"A\", 0);\n    int B = opt<int>(\"B\", 0);\n    int value_max = opt<int>(\"value_max\", 5000);\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> x, y, z;\n\n    if (type == \"random\") {\n        // Generate random sequences x, y, z with distinct integers in [1, value_max]\n        set<int> sx;\n        while ((int)sx.size() < n) {\n            int num = rnd.next(1, value_max);\n            sx.insert(num);\n        }\n        x.assign(sx.begin(), sx.end());\n\n        set<int> sy;\n        while ((int)sy.size() < m) {\n            int num = rnd.next(1, value_max);\n            sy.insert(num);\n        }\n        y.assign(sy.begin(), sy.end());\n\n        set<int> sz;\n        while ((int)sz.size() < k) {\n            int num = rnd.next(1, value_max);\n            sz.insert(num);\n        }\n        z.assign(sz.begin(), sz.end());\n    } else if (type == \"min\") {\n        // Sequences with minimum values\n        x.resize(n);\n        for (int i = 0; i < n; ++i)\n            x[i] = i + 1;\n\n        y.resize(m);\n        for (int i = 0; i < m; ++i)\n            y[i] = i + 1;\n\n        z.resize(k);\n        for (int i = 0; i < k; ++i)\n            z[i] = i + 1;\n    } else if (type == \"max\") {\n        // Sequences with maximum values\n        x.resize(n);\n        for (int i = 0; i < n; ++i)\n            x[i] = value_max - i;\n        y.resize(m);\n        for (int i = 0; i < m; ++i)\n            y[i] = value_max - i;\n        z.resize(k);\n        for (int i = 0; i < k; ++i)\n            z[i] = value_max - i;\n    } else if (type == \"one\") {\n        // Sequences with one element\n        n = m = k = 1;\n        x.push_back(rnd.next(1, value_max));\n        y.push_back(rnd.next(1, value_max));\n        z.push_back(rnd.next(1, value_max));\n    } else if (type == \"AeqB\") {\n        // A equals B\n        A = B = rnd.next(1, value_max);\n        // Generate random sequences\n        n = min(n, value_max);\n        m = min(m, value_max);\n        k = min(k, value_max);\n\n        set<int> sx;\n        while ((int)sx.size() < n) {\n            int num = rnd.next(1, value_max);\n            sx.insert(num);\n        }\n        x.assign(sx.begin(), sx.end());\n\n        set<int> sy;\n        while ((int)sy.size() < m) {\n            int num = rnd.next(1, value_max);\n            sy.insert(num);\n        }\n        y.assign(sy.begin(), sy.end());\n\n        set<int> sz;\n        while ((int)sz.size() < k) {\n            int num = rnd.next(1, value_max);\n            sz.insert(num);\n        }\n        z.assign(sz.begin(), sz.end());\n    } else if (type == \"squareRatio\") {\n        // sqrt(A/B) is integer\n        int sqrtAB = rnd.next(1, 70);\n        B = rnd.next(1, value_max / (sqrtAB * sqrtAB));\n        A = sqrtAB * sqrtAB * B;\n        A = min(A, value_max);\n        B = min(B, value_max);\n\n        // Generate random sequences\n        n = min(n, value_max);\n        m = min(m, value_max);\n        k = min(k, value_max);\n\n        set<int> sx;\n        while ((int)sx.size() < n) {\n            int num = rnd.next(1, value_max);\n            sx.insert(num);\n        }\n        x.assign(sx.begin(), sx.end());\n\n        set<int> sy;\n        while ((int)sy.size() < m) {\n            int num = rnd.next(1, value_max);\n            sy.insert(num);\n        }\n        y.assign(sy.begin(), sy.end());\n\n        set<int> sz;\n        while ((int)sz.size() < k) {\n            int num = rnd.next(1, value_max);\n            sz.insert(num);\n        }\n        z.assign(sz.begin(), sz.end());\n    } else if (type == \"nonSquareRatio\") {\n        // sqrt(A/B) is not integer\n        do {\n            A = rnd.next(1, value_max);\n            B = rnd.next(1, value_max);\n            int s = sqrt((double)A / B);\n            if (s * s * B != A)\n                break;\n        } while (true);\n\n        // Generate random sequences\n        n = min(n, value_max);\n        m = min(m, value_max);\n        k = min(k, value_max);\n\n        set<int> sx;\n        while ((int)sx.size() < n) {\n            int num = rnd.next(1, value_max);\n            sx.insert(num);\n        }\n        x.assign(sx.begin(), sx.end());\n\n        set<int> sy;\n        while ((int)sy.size() < m) {\n            int num = rnd.next(1, value_max);\n            sy.insert(num);\n        }\n        y.assign(sy.begin(), sy.end());\n\n        set<int> sz;\n        while ((int)sz.size() < k) {\n            int num = rnd.next(1, value_max);\n            sz.insert(num);\n        }\n        z.assign(sz.begin(), sz.end());\n    } else {\n        // Default to random sequences\n        set<int> sx;\n        while ((int)sx.size() < n) {\n            int num = rnd.next(1, value_max);\n            sx.insert(num);\n        }\n        x.assign(sx.begin(), sx.end());\n\n        set<int> sy;\n        while ((int)sy.size() < m) {\n            int num = rnd.next(1, value_max);\n            sy.insert(num);\n        }\n        y.assign(sy.begin(), sy.end());\n\n        set<int> sz;\n        while ((int)sz.size() < k) {\n            int num = rnd.next(1, value_max);\n            sz.insert(num);\n        }\n        z.assign(sz.begin(), sz.end());\n    }\n\n    // If A or B haven't been set yet, set them to provided values or random values\n    if (A == 0) A = opt<int>(\"A\", rnd.next(1, value_max));\n    if (B == 0) B = opt<int>(\"B\", rnd.next(1, value_max));\n\n    // Output the sequences\n    printf(\"%d\", n);\n    for (int i = 0; i < n; ++i)\n        printf(\" %d\", x[i]);\n    printf(\"\\n\");\n\n    printf(\"%d\", m);\n    for (int i = 0; i < m; ++i)\n        printf(\" %d\", y[i]);\n    printf(\"\\n\");\n\n    printf(\"%d\", k);\n    for (int i = 0; i < k; ++i)\n        printf(\" %d\", z[i]);\n    printf(\"\\n\");\n\n    printf(\"%d %d\\n\", A, B);\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    int k = opt<int>(\"k\");\n    int A = opt<int>(\"A\", 0);\n    int B = opt<int>(\"B\", 0);\n    int value_max = opt<int>(\"value_max\", 5000);\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> x, y, z;\n\n    if (type == \"random\") {\n        // Generate random sequences x, y, z with distinct integers in [1, value_max]\n        set<int> sx;\n        while ((int)sx.size() < n) {\n            int num = rnd.next(1, value_max);\n            sx.insert(num);\n        }\n        x.assign(sx.begin(), sx.end());\n\n        set<int> sy;\n        while ((int)sy.size() < m) {\n            int num = rnd.next(1, value_max);\n            sy.insert(num);\n        }\n        y.assign(sy.begin(), sy.end());\n\n        set<int> sz;\n        while ((int)sz.size() < k) {\n            int num = rnd.next(1, value_max);\n            sz.insert(num);\n        }\n        z.assign(sz.begin(), sz.end());\n    } else if (type == \"min\") {\n        // Sequences with minimum values\n        x.resize(n);\n        for (int i = 0; i < n; ++i)\n            x[i] = i + 1;\n\n        y.resize(m);\n        for (int i = 0; i < m; ++i)\n            y[i] = i + 1;\n\n        z.resize(k);\n        for (int i = 0; i < k; ++i)\n            z[i] = i + 1;\n    } else if (type == \"max\") {\n        // Sequences with maximum values\n        x.resize(n);\n        for (int i = 0; i < n; ++i)\n            x[i] = value_max - i;\n        y.resize(m);\n        for (int i = 0; i < m; ++i)\n            y[i] = value_max - i;\n        z.resize(k);\n        for (int i = 0; i < k; ++i)\n            z[i] = value_max - i;\n    } else if (type == \"one\") {\n        // Sequences with one element\n        n = m = k = 1;\n        x.push_back(rnd.next(1, value_max));\n        y.push_back(rnd.next(1, value_max));\n        z.push_back(rnd.next(1, value_max));\n    } else if (type == \"AeqB\") {\n        // A equals B\n        A = B = rnd.next(1, value_max);\n        // Generate random sequences\n        n = min(n, value_max);\n        m = min(m, value_max);\n        k = min(k, value_max);\n\n        set<int> sx;\n        while ((int)sx.size() < n) {\n            int num = rnd.next(1, value_max);\n            sx.insert(num);\n        }\n        x.assign(sx.begin(), sx.end());\n\n        set<int> sy;\n        while ((int)sy.size() < m) {\n            int num = rnd.next(1, value_max);\n            sy.insert(num);\n        }\n        y.assign(sy.begin(), sy.end());\n\n        set<int> sz;\n        while ((int)sz.size() < k) {\n            int num = rnd.next(1, value_max);\n            sz.insert(num);\n        }\n        z.assign(sz.begin(), sz.end());\n    } else if (type == \"squareRatio\") {\n        // sqrt(A/B) is integer\n        int sqrtAB = rnd.next(1, 70);\n        B = rnd.next(1, value_max / (sqrtAB * sqrtAB));\n        A = sqrtAB * sqrtAB * B;\n        A = min(A, value_max);\n        B = min(B, value_max);\n\n        // Generate random sequences\n        n = min(n, value_max);\n        m = min(m, value_max);\n        k = min(k, value_max);\n\n        set<int> sx;\n        while ((int)sx.size() < n) {\n            int num = rnd.next(1, value_max);\n            sx.insert(num);\n        }\n        x.assign(sx.begin(), sx.end());\n\n        set<int> sy;\n        while ((int)sy.size() < m) {\n            int num = rnd.next(1, value_max);\n            sy.insert(num);\n        }\n        y.assign(sy.begin(), sy.end());\n\n        set<int> sz;\n        while ((int)sz.size() < k) {\n            int num = rnd.next(1, value_max);\n            sz.insert(num);\n        }\n        z.assign(sz.begin(), sz.end());\n    } else if (type == \"nonSquareRatio\") {\n        // sqrt(A/B) is not integer\n        do {\n            A = rnd.next(1, value_max);\n            B = rnd.next(1, value_max);\n            int s = sqrt((double)A / B);\n            if (s * s * B != A)\n                break;\n        } while (true);\n\n        // Generate random sequences\n        n = min(n, value_max);\n        m = min(m, value_max);\n        k = min(k, value_max);\n\n        set<int> sx;\n        while ((int)sx.size() < n) {\n            int num = rnd.next(1, value_max);\n            sx.insert(num);\n        }\n        x.assign(sx.begin(), sx.end());\n\n        set<int> sy;\n        while ((int)sy.size() < m) {\n            int num = rnd.next(1, value_max);\n            sy.insert(num);\n        }\n        y.assign(sy.begin(), sy.end());\n\n        set<int> sz;\n        while ((int)sz.size() < k) {\n            int num = rnd.next(1, value_max);\n            sz.insert(num);\n        }\n        z.assign(sz.begin(), sz.end());\n    } else {\n        // Default to random sequences\n        set<int> sx;\n        while ((int)sx.size() < n) {\n            int num = rnd.next(1, value_max);\n            sx.insert(num);\n        }\n        x.assign(sx.begin(), sx.end());\n\n        set<int> sy;\n        while ((int)sy.size() < m) {\n            int num = rnd.next(1, value_max);\n            sy.insert(num);\n        }\n        y.assign(sy.begin(), sy.end());\n\n        set<int> sz;\n        while ((int)sz.size() < k) {\n            int num = rnd.next(1, value_max);\n            sz.insert(num);\n        }\n        z.assign(sz.begin(), sz.end());\n    }\n\n    // If A or B haven't been set yet, set them to provided values or random values\n    if (A == 0) A = opt<int>(\"A\", rnd.next(1, value_max));\n    if (B == 0) B = opt<int>(\"B\", rnd.next(1, value_max));\n\n    // Output the sequences\n    printf(\"%d\", n);\n    for (int i = 0; i < n; ++i)\n        printf(\" %d\", x[i]);\n    printf(\"\\n\");\n\n    printf(\"%d\", m);\n    for (int i = 0; i < m; ++i)\n        printf(\" %d\", y[i]);\n    printf(\"\\n\");\n\n    printf(\"%d\", k);\n    for (int i = 0; i < k; ++i)\n        printf(\" %d\", z[i]);\n    printf(\"\\n\");\n\n    printf(\"%d %d\\n\", A, B);\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -m 1 -k 1 -A 1 -B 1 -type one\n./gen -n 5 -m 5 -k 5 -A 3 -B 2 -type random\n./gen -n 10 -m 10 -k 10 -A 1 -B 1 -type min\n./gen -n 10 -m 10 -k 10 -A 5000 -B 5000 -type max\n./gen -n 5000 -m 5000 -k 5000 -A 1234 -B 5678 -type random\n./gen -n 5000 -m 5000 -k 5000 -A 1 -B 1 -type min\n./gen -n 10 -m 10 -k 10 -type AeqB\n./gen -n 20 -m 20 -k 20 -type squareRatio\n./gen -n 20 -m 20 -k 20 -type nonSquareRatio\n./gen -n 5 -m 5 -k 5 -A 5000 -B 4999 -type random\n./gen -n 5 -m 5 -k 5 -A 1 -B 5000 -type random\n./gen -n 5000 -m 5000 -k 5000 -A 2500 -B 2499 -type max\n./gen -n 5000 -m 5000 -k 5000 -A 5000 -B 5000 -type max\n./gen -n 5000 -m 1 -k 1 -A 2 -B 3 -type random\n./gen -n 1 -m 5000 -k 5000 -A 3 -B 2 -type random\n./gen -n 1000 -m 1000 -k 1000 -A 1 -B 1 -value_max 5000 -type random\n./gen -n 1000 -m 1000 -k 1000 -A 123 -B 456 -value_max 1000 -type random\n./gen -n 1000 -m 1000 -k 1000 -A 999 -B 998 -value_max 1000 -type max\n./gen -n 2 -m 2 -k 2 -A 3 -B 4 -type random\n./gen -n 1000 -m 1000 -k 1000 -A 4999 -B 4993 -type random\n./gen -n 1000 -m 1000 -k 1000 -A 2 -B 3 -type random\n./gen -n 1000 -m 1000 -k 1000 -A 5000 -B 1 -type random\n./gen -n 1000 -m 1000 -k 1000 -A 1 -B 5000 -type random\n./gen -n 1000 -m 1000 -k 1000 -A 256 -B 16 -type random\n./gen -n 3000 -m 2000 -k 1000 -A 1000 -B 1 -type random\n./gen -n 1 -m 3000 -k 1 -A 2021 -B 4041 -type random\n./gen -n 1 -m 1 -k 5000 -A 1 -B 5000 -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T19:49:52.743206",
        "total_tutorials": 3,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "215/C",
      "title": "C. Crosses",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe input consists of a single line containing three integers n, m and s (1 ≤ n, m ≤ 500, 1 ≤ s ≤ n·m). The integers are separated by a space.",
      "output_spec": "OutputPrint a single integer — the number of distinct groups of six integers that denote crosses with area s and that are fully placed on the n × m grid.Please, do not use the %lld specifier to read or write 64-bit integers in С++. It is preferred to use the cin, cout streams or the %I64d specifier.",
      "sample_tests": "ExamplesInputCopy2 2 1OutputCopy4InputCopy3 4 5OutputCopy4",
      "description": "time limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe input consists of a single line containing three integers n, m and s (1 ≤ n, m ≤ 500, 1 ≤ s ≤ n·m). The integers are separated by a space.\n\nOutputPrint a single integer — the number of distinct groups of six integers that denote crosses with area s and that are fully placed on the n × m grid.Please, do not use the %lld specifier to read or write 64-bit integers in С++. It is preferred to use the cin, cout streams or the %I64d specifier.\n\nInputCopy2 2 1OutputCopy4InputCopy3 4 5OutputCopy4\n\nInputCopy2 2 1\n\nOutputCopy4\n\nInputCopy3 4 5\n\nOutputCopy4\n\nNoteIn the first sample the sought groups of six numbers are: (0, 0, 0, 0, 1, 1), (0, 0, 0, 0, 1, 2), (0, 0, 0, 0, 2, 1), (0, 0, 0, 0, 2, 2).In the second sample the sought groups of six numbers are: (0, 1, 1, 0, 2, 2), (0, 1, 1, 0, 2, 3), (1, 0, 0, 1, 2, 2), (1, 0, 0, 1, 2, 3).",
      "solutions": [
        {
          "title": "Codeforces Round #132 (Div. 2) - Codeforces",
          "content": "Hi!A few hours later you're lucky to participate in Codeforces Round #132 for Div.2 participants, but traditionally the others can take part out of the competition. It has been prepared by me (NALP), Edvard Davtyan (Edvard), Vitaly Aksenov (Aksenov239), Gerald Agapov (Gerald), Mary Belova (Delinur) и Mike Mirzayanov (MikeMirzayanov).Traditionally I wish good luck, accepted solutions and successful hacking attempts for you!Especially, we want to wish grand results and good luck to all sportsmens, who are representing their countries on XXX Olympic Games in London! Today it is decided to use dynamic scoring system. But the problems will be sorted from low difficulty to high by authors' opinion!UPD: The Round is finished, thanks to all for participation! We hope you have got fun!UPD: Congratulation to winners! yooo — solved all problems! zzy High_Rich_Handsome bookcity_clock capythm UPD: Tutorial in English is published!",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/5017",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 931
        },
        {
          "title": "Codeforces Round #132 (Div. 2) - Codeforces",
          "content": "Hi!A few hours later you're lucky to participate in Codeforces Round #132 for Div.2 participants, but traditionally the others can take part out of the competition. It has been prepared by me (NALP), Edvard Davtyan (Edvard), Vitaly Aksenov (Aksenov239), Gerald Agapov (Gerald), Mary Belova (Delinur) и Mike Mirzayanov (MikeMirzayanov).Traditionally I wish good luck, accepted solutions and successful hacking attempts for you!Especially, we want to wish grand results and good luck to all sportsmens, who are representing their countries on XXX Olympic Games in London! Today it is decided to use dynamic scoring system. But the problems will be sorted from low difficulty to high by authors' opinion!UPD: The Round is finished, thanks to all for participation! We hope you have got fun!UPD: Congratulation to winners! yooo — solved all problems! zzy High_Rich_Handsome bookcity_clock capythm UPD: Tutorial in English is published!",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/5017",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 931
        },
        {
          "title": "Some tutorial on problem E CF#132 - Codeforces",
          "content": "Hi! I'll try to explain solution of problem E on Codeforces Round #132.Ok, in the very beginning let's try solve some other task. We'll find the number of such integers in the interval (2k, x], where . And someone can see that x has length len = k + 1.Then we should try blocks of {0, 1} to be the same part of periodical number. These blocks have length, which is divisor of len.Let's calculate number g[i] of such blocks of length i, where i is some divisor of len. We get i of first(from the left side) bits of number x and name it as t = x >> (len - i), e.g. if x = 100110002, and i = 4 then t = 10012, if i = 2 then t = 102. Firstly, we should check block t, it needs for example to check number p = ttttt... repeated times, it can be calculated in a loop p = p << i + t. It's clear if p ≤ x, then we should take into account this block g[i] = 1. It's clear that every correct block less or equal than t, and it should begin from 1 (because of periodical number is without leading zeroes). Case of equality we took. And we should add to g[i] difference between t and 2i = 10000...2 i-1 zeroes, g[i] = g[i] + t - (1 << (i - 1)). It seems that all is ready and we can sum g[i] for every divisor of len and not equal len, but we cant. Because some cases we count more than once, e.g. x = 101011002, i = 4, g[4] = 1 + (10102 - 10002) = 3 we considered cases of blocks 1000, 1001, 1010, and when we count for i = 2,g[2] = 1 + (102 - 102) = 1, we considered one case 10, but 1010 is obtained from 10 repeated two times. But we can easily escape these problems, for this we should substract from g[i] all g[j] where j < i and j divides i.Some note. We get some DP problem, we calculate g[i] from i = 1 to the most divisor of len which is not equal to len, and update its value by substracting all g[j].Let us summarize some ideas, we can count number of periodical numbers in the interval (2k, x], by going through divisors of len and calculating g[i], and then we return sum of g[i] where i < len and i divides len. One can see that 2k cant be periodical. Given this fact we will calculate this value for x = 2k - 1, then 2k - 1 - 1 and so on.In the end we get x = 1, and we get set of non-intersecting intervals, counting on each of them and sum up it we get answer. It can be done recursively. My code in C++, when I also precalculated divisors of each number from 1 to 60. I'm waiting for your replies and some criticism.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/5034",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 2423
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #132 (Div. 2) - Codeforces - Code 1",
          "code": "value.ToString(CultureInfo.InvariantCulture)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5017",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #132 (Div. 2) - Codeforces - Code 2",
          "code": "value.ToString().Replace(',','.')",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5017",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #132 (Div. 2) - Codeforces - Code 1",
          "code": "value.ToString(CultureInfo.InvariantCulture)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5017",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #132 (Div. 2) - Codeforces - Code 2",
          "code": "value.ToString().Replace(',','.')",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5017",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 500, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 500, \"m\");\n    inf.readSpace();\n    int s = inf.readInt(1, n * m, \"s\");\n    inf.readEoln();\n    inf.readEof();\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 500, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 500, \"m\");\n    inf.readSpace();\n    int s = inf.readInt(1, n * m, \"s\");\n    inf.readEoln();\n    inf.readEof();\n\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 500, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 500, \"m\");\n    inf.readSpace();\n    int s = inf.readInt(1, n * m, \"s\");\n    inf.readEoln();\n    inf.readEof();\n\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\", -1);\n    int m = opt<int>(\"m\", -1);\n    int s = opt<int>(\"s\", -1);\n    string type = opt<string>(\"type\", \"random\");\n\n    if (type == \"minimal\") {\n        n = 1;\n        m = 1;\n        s = 1;\n    } else if (type == \"maximal\") {\n        n = 500;\n        m = 500;\n        s = n * m;\n    } else if (type == \"edge_narrow\") {\n        n = 1;\n        m = 500;\n        s = rnd.next(1, n * m);\n    } else if (type == \"edge_wide\") {\n        n = 500;\n        m = 1;\n        s = rnd.next(1, n * m);\n    } else if (type == \"zero_answer\") {\n        n = 1;\n        m = 1;\n        s = 10; // s larger than n * m, will be adjusted to n * m\n    } else if (type == \"large_s\") {\n        n = 500;\n        m = 500;\n        s = n * m;\n    } else if (type == \"small_s\") {\n        if (n == -1) n = rnd.next(1, 500);\n        if (m == -1) m = rnd.next(1, 500);\n        s = 1;\n    } else if (type == \"maximal_s\") {\n        if (n == -1) n = rnd.next(1, 500);\n        if (m == -1) m = rnd.next(1, 500);\n        s = n * m;\n    } else if (type == \"small\") {\n        n = rnd.next(1, 10);\n        m = rnd.next(1, 10);\n        s = rnd.next(1, min(100, n * m));\n    } else if (type == \"random\") {\n        if (n == -1)\n            n = rnd.next(1, 500);\n        if (m == -1)\n            m = rnd.next(1, 500);\n        if (s == -1)\n            s = rnd.next(1, n * m);\n    } else {\n        // Default to random\n        if (n == -1)\n            n = rnd.next(1, 500);\n        if (m == -1)\n            m = rnd.next(1, 500);\n        if (s == -1)\n            s = rnd.next(1, n * m);\n    }\n\n    // Ensure constraints\n    n = max(1, min(n, 500));\n    m = max(1, min(m, 500));\n    s = max(1, min(s, n * m));\n\n    // Output the test case\n    printf(\"%d %d %d\\n\", n, m, s);\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\", -1);\n    int m = opt<int>(\"m\", -1);\n    int s = opt<int>(\"s\", -1);\n    string type = opt<string>(\"type\", \"random\");\n\n    if (type == \"minimal\") {\n        n = 1;\n        m = 1;\n        s = 1;\n    } else if (type == \"maximal\") {\n        n = 500;\n        m = 500;\n        s = n * m;\n    } else if (type == \"edge_narrow\") {\n        n = 1;\n        m = 500;\n        s = rnd.next(1, n * m);\n    } else if (type == \"edge_wide\") {\n        n = 500;\n        m = 1;\n        s = rnd.next(1, n * m);\n    } else if (type == \"zero_answer\") {\n        n = 1;\n        m = 1;\n        s = 10; // s larger than n * m, will be adjusted to n * m\n    } else if (type == \"large_s\") {\n        n = 500;\n        m = 500;\n        s = n * m;\n    } else if (type == \"small_s\") {\n        if (n == -1) n = rnd.next(1, 500);\n        if (m == -1) m = rnd.next(1, 500);\n        s = 1;\n    } else if (type == \"maximal_s\") {\n        if (n == -1) n = rnd.next(1, 500);\n        if (m == -1) m = rnd.next(1, 500);\n        s = n * m;\n    } else if (type == \"small\") {\n        n = rnd.next(1, 10);\n        m = rnd.next(1, 10);\n        s = rnd.next(1, min(100, n * m));\n    } else if (type == \"random\") {\n        if (n == -1)\n            n = rnd.next(1, 500);\n        if (m == -1)\n            m = rnd.next(1, 500);\n        if (s == -1)\n            s = rnd.next(1, n * m);\n    } else {\n        // Default to random\n        if (n == -1)\n            n = rnd.next(1, 500);\n        if (m == -1)\n            m = rnd.next(1, 500);\n        if (s == -1)\n            s = rnd.next(1, n * m);\n    }\n\n    // Ensure constraints\n    n = max(1, min(n, 500));\n    m = max(1, min(m, 500));\n    s = max(1, min(s, n * m));\n\n    // Output the test case\n    printf(\"%d %d %d\\n\", n, m, s);\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -m 1 -s 1 -type minimal\n./gen -n 500 -m 500 -s 250000 -type maximal\n./gen -n 1 -m 500 -type edge_narrow\n./gen -n 500 -m 1 -type edge_wide\n./gen -n 100 -m 100 -s 5000 -type random\n./gen -n 10 -m 10 -s 50 -type random\n./gen -n 2 -m 2 -s 1 -type small\n./gen -n 2 -m 2 -s 4 -type small\n./gen -n 3 -m 3 -s 5 -type small\n./gen -n 300 -m 300 -s 1 -type small_s\n./gen -n 500 -m 500 -s 1 -type small_s\n./gen -n 500 -m 500 -s 250000 -type maximal_s\n./gen -type random\n./gen -type random\n./gen -type random\n./gen -type random\n./gen -type random\n./gen -type random\n./gen -n 499 -m 500 -s 1000 -type random\n./gen -n 500 -m 499 -s 1000 -type random\n./gen -n 1 -m 1 -s 1\n./gen -n 500 -m 500 -s 250000\n./gen -n 500 -m 1 -s 500\n./gen -n 1 -m 500 -s 500\n./gen -n 500 -m 500 -s 100\n./gen -n 500 -m 500 -s 50000\n./gen -n 100 -m 100 -s 100\n./gen -n 100 -m 100 -s 5000\n./gen -n 1 -m 1 -s 10 -type zero_answer\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T19:49:54.588072",
        "total_tutorials": 3,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "215/D",
      "title": "D. Hot Days",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first input line contains two integers n and m (1 ≤ n ≤ 105; 1 ≤ m ≤ 106) — the number of regions on the way and the number of schoolchildren in the group, correspondingly. Next n lines contain four integers each: the i-th line contains ti, Ti, xi and costi (1 ≤ ti, Ti, xi, costi ≤ 106). The numbers in the lines are separated by single spaces.",
      "output_spec": "OutputPrint the only integer — the minimum number of roubles the organizers will have to spend to transport all schoolchildren.Please, do not use the %lld specifier to read or write 64-bit integers in С++. It is preferred to use cin, cout streams or the %I64d specifier.",
      "sample_tests": "ExamplesInputCopy2 1030 35 1 10020 35 10 10OutputCopy120InputCopy3 10010 30 1000 15 10 1000 310 40 1000 100000OutputCopy200065",
      "description": "D. Hot Days\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first input line contains two integers n and m (1 ≤ n ≤ 105; 1 ≤ m ≤ 106) — the number of regions on the way and the number of schoolchildren in the group, correspondingly. Next n lines contain four integers each: the i-th line contains ti, Ti, xi and costi (1 ≤ ti, Ti, xi, costi ≤ 106). The numbers in the lines are separated by single spaces.\n\nOutputPrint the only integer — the minimum number of roubles the organizers will have to spend to transport all schoolchildren.Please, do not use the %lld specifier to read or write 64-bit integers in С++. It is preferred to use cin, cout streams or the %I64d specifier.\n\nInputCopy2 1030 35 1 10020 35 10 10OutputCopy120InputCopy3 10010 30 1000 15 10 1000 310 40 1000 100000OutputCopy200065\n\nInputCopy2 1030 35 1 10020 35 10 10\n\nOutputCopy120\n\nInputCopy3 10010 30 1000 15 10 1000 310 40 1000 100000\n\nOutputCopy200065\n\nNoteIn the first sample the organizers will use only one bus to travel through the first region. However, the temperature in the bus will equal 30 + 10 = 40 degrees and each of 10 schoolchildren will ask for compensation. Only one bus will transport the group through the second region too, but the temperature inside won't exceed the limit. Overall, the organizers will spend 100 + 10 + 10 = 120 rubles.",
      "solutions": [
        {
          "title": "Codeforces Round #132 (Div. 2) - Codeforces",
          "content": "Hi!A few hours later you're lucky to participate in Codeforces Round #132 for Div.2 participants, but traditionally the others can take part out of the competition. It has been prepared by me (NALP), Edvard Davtyan (Edvard), Vitaly Aksenov (Aksenov239), Gerald Agapov (Gerald), Mary Belova (Delinur) и Mike Mirzayanov (MikeMirzayanov).Traditionally I wish good luck, accepted solutions and successful hacking attempts for you!Especially, we want to wish grand results and good luck to all sportsmens, who are representing their countries on XXX Olympic Games in London! Today it is decided to use dynamic scoring system. But the problems will be sorted from low difficulty to high by authors' opinion!UPD: The Round is finished, thanks to all for participation! We hope you have got fun!UPD: Congratulation to winners! yooo — solved all problems! zzy High_Rich_Handsome bookcity_clock capythm UPD: Tutorial in English is published!",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/5017",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 931
        },
        {
          "title": "Codeforces Round #132 (Div. 2) - Codeforces",
          "content": "Hi!A few hours later you're lucky to participate in Codeforces Round #132 for Div.2 participants, but traditionally the others can take part out of the competition. It has been prepared by me (NALP), Edvard Davtyan (Edvard), Vitaly Aksenov (Aksenov239), Gerald Agapov (Gerald), Mary Belova (Delinur) и Mike Mirzayanov (MikeMirzayanov).Traditionally I wish good luck, accepted solutions and successful hacking attempts for you!Especially, we want to wish grand results and good luck to all sportsmens, who are representing their countries on XXX Olympic Games in London! Today it is decided to use dynamic scoring system. But the problems will be sorted from low difficulty to high by authors' opinion!UPD: The Round is finished, thanks to all for participation! We hope you have got fun!UPD: Congratulation to winners! yooo — solved all problems! zzy High_Rich_Handsome bookcity_clock capythm UPD: Tutorial in English is published!",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/5017",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 931
        },
        {
          "title": "Some tutorial on problem E CF#132 - Codeforces",
          "content": "Hi! I'll try to explain solution of problem E on Codeforces Round #132.Ok, in the very beginning let's try solve some other task. We'll find the number of such integers in the interval (2k, x], where . And someone can see that x has length len = k + 1.Then we should try blocks of {0, 1} to be the same part of periodical number. These blocks have length, which is divisor of len.Let's calculate number g[i] of such blocks of length i, where i is some divisor of len. We get i of first(from the left side) bits of number x and name it as t = x >> (len - i), e.g. if x = 100110002, and i = 4 then t = 10012, if i = 2 then t = 102. Firstly, we should check block t, it needs for example to check number p = ttttt... repeated times, it can be calculated in a loop p = p << i + t. It's clear if p ≤ x, then we should take into account this block g[i] = 1. It's clear that every correct block less or equal than t, and it should begin from 1 (because of periodical number is without leading zeroes). Case of equality we took. And we should add to g[i] difference between t and 2i = 10000...2 i-1 zeroes, g[i] = g[i] + t - (1 << (i - 1)). It seems that all is ready and we can sum g[i] for every divisor of len and not equal len, but we cant. Because some cases we count more than once, e.g. x = 101011002, i = 4, g[4] = 1 + (10102 - 10002) = 3 we considered cases of blocks 1000, 1001, 1010, and when we count for i = 2,g[2] = 1 + (102 - 102) = 1, we considered one case 10, but 1010 is obtained from 10 repeated two times. But we can easily escape these problems, for this we should substract from g[i] all g[j] where j < i and j divides i.Some note. We get some DP problem, we calculate g[i] from i = 1 to the most divisor of len which is not equal to len, and update its value by substracting all g[j].Let us summarize some ideas, we can count number of periodical numbers in the interval (2k, x], by going through divisors of len and calculating g[i], and then we return sum of g[i] where i < len and i divides len. One can see that 2k cant be periodical. Given this fact we will calculate this value for x = 2k - 1, then 2k - 1 - 1 and so on.In the end we get x = 1, and we get set of non-intersecting intervals, counting on each of them and sum up it we get answer. It can be done recursively. My code in C++, when I also precalculated divisors of each number from 1 to 60. I'm waiting for your replies and some criticism.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/5034",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 2423
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #132 (Div. 2) - Codeforces - Code 1",
          "code": "value.ToString(CultureInfo.InvariantCulture)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5017",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #132 (Div. 2) - Codeforces - Code 2",
          "code": "value.ToString().Replace(',','.')",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5017",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #132 (Div. 2) - Codeforces - Code 1",
          "code": "value.ToString(CultureInfo.InvariantCulture)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5017",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #132 (Div. 2) - Codeforces - Code 2",
          "code": "value.ToString().Replace(',','.')",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5017",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 1000000, \"m\");\n    inf.readEoln();\n\n    for (int i = 0; i < n; i++) {\n        int ti = inf.readInt(1, 1000000, \"ti\");\n        inf.readSpace();\n        int Ti = inf.readInt(1, 1000000, \"Ti\");\n        inf.readSpace();\n        int xi = inf.readInt(1, 1000000, \"xi\");\n        inf.readSpace();\n        int costi = inf.readInt(1, 1000000, \"costi\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 1000000, \"m\");\n    inf.readEoln();\n\n    for (int i = 0; i < n; i++) {\n        int ti = inf.readInt(1, 1000000, \"ti\");\n        inf.readSpace();\n        int Ti = inf.readInt(1, 1000000, \"Ti\");\n        inf.readSpace();\n        int xi = inf.readInt(1, 1000000, \"xi\");\n        inf.readSpace();\n        int costi = inf.readInt(1, 1000000, \"costi\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 1000000, \"m\");\n    inf.readEoln();\n\n    for (int i = 0; i < n; i++) {\n        int ti = inf.readInt(1, 1000000, \"ti\");\n        inf.readSpace();\n        int Ti = inf.readInt(1, 1000000, \"Ti\");\n        inf.readSpace();\n        int xi = inf.readInt(1, 1000000, \"xi\");\n        inf.readSpace();\n        int costi = inf.readInt(1, 1000000, \"costi\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string type = opt<string>(\"type\", \"random\");\n\n    // Variables to store ti, Ti, xi, costi\n    vector<int> t(n);\n    vector<int> T(n);\n    vector<int> x(n);\n    vector<int> cost(n);\n\n    if (type == \"random\") {\n        // Generate random data within constraints\n        for (int i = 0; i < n; ++i) {\n            t[i] = rnd.next(1, 1000000);\n            T[i] = rnd.next(1, 1000000);\n            x[i] = rnd.next(1, 1000000);\n            cost[i] = rnd.next(1, 1000000);\n        }\n    } else if (type == \"identical_regions\") {\n        // All regions have identical data\n        int ti = rnd.next(1, 1000000);\n        int Ti = rnd.next(1, 1000000);\n        int xi = rnd.next(1, 1000000);\n        int ci = rnd.next(1, 1000000);\n        for (int i = 0; i < n; ++i) {\n            t[i] = ti;\n            T[i] = Ti;\n            x[i] = xi;\n            cost[i] = ci;\n        }\n    } else if (type == \"low_Ti\") {\n        // Ti is minimal, set Ti = 1\n        for (int i = 0; i < n; ++i) {\n            t[i] = rnd.next(1, 1000000);\n            T[i] = 1;\n            x[i] = rnd.next(1, 1000000);\n            cost[i] = rnd.next(1, 1000000);\n        }\n    } else if (type == \"high_Ti\") {\n        // Ti is maximal, set Ti = 1e6\n        for (int i = 0; i < n; ++i) {\n            t[i] = rnd.next(1, 1000000);\n            T[i] = 1000000;\n            x[i] = rnd.next(1, 1000000);\n            cost[i] = rnd.next(1, 1000000);\n        }\n    } else if (type == \"low_ti\") {\n        // t_i = 1\n        for (int i = 0; i < n; ++i) {\n            t[i] = 1;\n            T[i] = rnd.next(1,1000000);\n            x[i] = rnd.next(1, 1000000);\n            cost[i] = rnd.next(1, 1000000);\n        }\n    } else if (type == \"high_ti\") {\n        // t_i = 1e6\n        for (int i = 0; i < n; ++i) {\n            t[i] = 1000000;\n            T[i] = rnd.next(1,1000000);\n            x[i] = rnd.next(1, 1000000);\n            cost[i] = rnd.next(1, 1000000);\n        }\n    } else if (type == \"max_compensation\") {\n        // xi = 1e6\n        for (int i = 0; i < n; ++i) {\n            t[i] = rnd.next(1, 1000000);\n            T[i] = rnd.next(1,1000000);\n            x[i] = 1000000;\n            cost[i] = rnd.next(1, 1000000);\n        }\n    } else if (type == \"max_bus_cost\") {\n        // costi = 1e6\n        for (int i = 0; i < n; ++i) {\n            t[i] = rnd.next(1, 1000000);\n            T[i] = rnd.next(1,1000000);\n            x[i] = rnd.next(1, 1000000);\n            cost[i] = 1000000;\n        }\n    } else if (type == \"single_bus_optimal\") {\n        // Optimal to use single bus (high bus cost, low compensation)\n        for (int i = 0; i < n; ++i) {\n            t[i] = rnd.next(1, 1000000);\n            T[i] = rnd.next(1,1000000);\n            x[i] = 1;\n            cost[i] = 1000000;\n        }\n    } else if (type == \"all_bus_optimal\") {\n        // Optimal to use maximum buses (low bus cost, high compensation)\n        for (int i = 0; i < n; ++i) {\n            t[i] = rnd.next(1, 1000000);\n            T[i] = rnd.next(1,1000000);\n            x[i] = 1000000;\n            cost[i] = 1;\n        }\n    } else if (type == \"low_ti_low_Ti\") {\n        for (int i = 0; i < n; ++i) {\n            t[i] = 1;\n            T[i] = 1;\n            x[i] = rnd.next(1, 1000000);\n            cost[i] = rnd.next(1, 1000000);\n        }   \n    } else if (type == \"high_ti_high_Ti\") {\n        for (int i = 0; i < n; ++i) {\n            t[i] = 1000000;\n            T[i] = 1000000;\n            x[i] = rnd.next(1, 1000000);\n            cost[i] = rnd.next(1, 1000000);\n        }   \n    } else {\n        // Default random data\n        for (int i = 0; i < n; ++i) {\n            t[i] = rnd.next(1, 1000000);\n            T[i] = rnd.next(1, 1000000);\n            x[i] = rnd.next(1, 1000000);\n            cost[i] = rnd.next(1, 1000000);\n        }\n    }\n\n    // Output the data\n    printf(\"%d %d\\n\", n, m);\n    for(int i = 0; i < n; ++i) {\n        printf(\"%d %d %d %d\\n\", t[i], T[i], x[i], cost[i]);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string type = opt<string>(\"type\", \"random\");\n\n    // Variables to store ti, Ti, xi, costi\n    vector<int> t(n);\n    vector<int> T(n);\n    vector<int> x(n);\n    vector<int> cost(n);\n\n    if (type == \"random\") {\n        // Generate random data within constraints\n        for (int i = 0; i < n; ++i) {\n            t[i] = rnd.next(1, 1000000);\n            T[i] = rnd.next(1, 1000000);\n            x[i] = rnd.next(1, 1000000);\n            cost[i] = rnd.next(1, 1000000);\n        }\n    } else if (type == \"identical_regions\") {\n        // All regions have identical data\n        int ti = rnd.next(1, 1000000);\n        int Ti = rnd.next(1, 1000000);\n        int xi = rnd.next(1, 1000000);\n        int ci = rnd.next(1, 1000000);\n        for (int i = 0; i < n; ++i) {\n            t[i] = ti;\n            T[i] = Ti;\n            x[i] = xi;\n            cost[i] = ci;\n        }\n    } else if (type == \"low_Ti\") {\n        // Ti is minimal, set Ti = 1\n        for (int i = 0; i < n; ++i) {\n            t[i] = rnd.next(1, 1000000);\n            T[i] = 1;\n            x[i] = rnd.next(1, 1000000);\n            cost[i] = rnd.next(1, 1000000);\n        }\n    } else if (type == \"high_Ti\") {\n        // Ti is maximal, set Ti = 1e6\n        for (int i = 0; i < n; ++i) {\n            t[i] = rnd.next(1, 1000000);\n            T[i] = 1000000;\n            x[i] = rnd.next(1, 1000000);\n            cost[i] = rnd.next(1, 1000000);\n        }\n    } else if (type == \"low_ti\") {\n        // t_i = 1\n        for (int i = 0; i < n; ++i) {\n            t[i] = 1;\n            T[i] = rnd.next(1,1000000);\n            x[i] = rnd.next(1, 1000000);\n            cost[i] = rnd.next(1, 1000000);\n        }\n    } else if (type == \"high_ti\") {\n        // t_i = 1e6\n        for (int i = 0; i < n; ++i) {\n            t[i] = 1000000;\n            T[i] = rnd.next(1,1000000);\n            x[i] = rnd.next(1, 1000000);\n            cost[i] = rnd.next(1, 1000000);\n        }\n    } else if (type == \"max_compensation\") {\n        // xi = 1e6\n        for (int i = 0; i < n; ++i) {\n            t[i] = rnd.next(1, 1000000);\n            T[i] = rnd.next(1,1000000);\n            x[i] = 1000000;\n            cost[i] = rnd.next(1, 1000000);\n        }\n    } else if (type == \"max_bus_cost\") {\n        // costi = 1e6\n        for (int i = 0; i < n; ++i) {\n            t[i] = rnd.next(1, 1000000);\n            T[i] = rnd.next(1,1000000);\n            x[i] = rnd.next(1, 1000000);\n            cost[i] = 1000000;\n        }\n    } else if (type == \"single_bus_optimal\") {\n        // Optimal to use single bus (high bus cost, low compensation)\n        for (int i = 0; i < n; ++i) {\n            t[i] = rnd.next(1, 1000000);\n            T[i] = rnd.next(1,1000000);\n            x[i] = 1;\n            cost[i] = 1000000;\n        }\n    } else if (type == \"all_bus_optimal\") {\n        // Optimal to use maximum buses (low bus cost, high compensation)\n        for (int i = 0; i < n; ++i) {\n            t[i] = rnd.next(1, 1000000);\n            T[i] = rnd.next(1,1000000);\n            x[i] = 1000000;\n            cost[i] = 1;\n        }\n    } else if (type == \"low_ti_low_Ti\") {\n        for (int i = 0; i < n; ++i) {\n            t[i] = 1;\n            T[i] = 1;\n            x[i] = rnd.next(1, 1000000);\n            cost[i] = rnd.next(1, 1000000);\n        }   \n    } else if (type == \"high_ti_high_Ti\") {\n        for (int i = 0; i < n; ++i) {\n            t[i] = 1000000;\n            T[i] = 1000000;\n            x[i] = rnd.next(1, 1000000);\n            cost[i] = rnd.next(1, 1000000);\n        }   \n    } else {\n        // Default random data\n        for (int i = 0; i < n; ++i) {\n            t[i] = rnd.next(1, 1000000);\n            T[i] = rnd.next(1, 1000000);\n            x[i] = rnd.next(1, 1000000);\n            cost[i] = rnd.next(1, 1000000);\n        }\n    }\n\n    // Output the data\n    printf(\"%d %d\\n\", n, m);\n    for(int i = 0; i < n; ++i) {\n        printf(\"%d %d %d %d\\n\", t[i], T[i], x[i], cost[i]);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -m 1 -type random\n./gen -n 1 -m 1000000 -type random\n./gen -n 100000 -m 1 -type random\n./gen -n 100000 -m 1000000 -type random\n\n./gen -n 100000 -m 1000000 -type identical_regions\n./gen -n 100000 -m 1000000 -type single_bus_optimal\n./gen -n 100000 -m 1000000 -type all_bus_optimal\n\n./gen -n 100000 -m 1000000 -type low_Ti\n./gen -n 100000 -m 1000000 -type high_Ti\n\n./gen -n 100000 -m 1000000 -type low_ti\n./gen -n 100000 -m 1000000 -type high_ti\n\n./gen -n 100000 -m 1000000 -type max_compensation\n./gen -n 100000 -m 1000000 -type max_bus_cost\n\n./gen -n 100000 -m 1000000 -type random\n\n./gen -n 1 -m 1 -type low_Ti\n./gen -n 1 -m 1 -type high_Ti\n./gen -n 1 -m 1 -type low_ti\n./gen -n 1 -m 1 -type high_ti\n\n./gen -n 1 -m 1000000 -type random\n./gen -n 10 -m 1000000 -type random\n\n./gen -n 100000 -m 1 -type random\n./gen -n 100000 -m 2 -type random\n\n./gen -n 100000 -m 1000000 -type single_bus_optimal\n./gen -n 100000 -m 1000000 -type all_bus_optimal\n\n./gen -n 10 -m 100 -type random\n./gen -n 1000 -m 1000 -type random\n\n./gen -n 50000 -m 500000 -type random\n\n./gen -n 99999 -m 888888 -type identical_regions\n\n./gen -n 100000 -m 1 -type random\n\n./gen -n 100000 -m 1000000 -type low_Ti\n\n./gen -n 100000 -m 1000000 -type high_Ti\n\n./gen -n 100000 -m 1000000 -type low_ti\n\n./gen -n 100000 -m 1000000 -type high_ti\n\n./gen -n 100000 -m 1000000 -type low_ti_low_Ti\n\n./gen -n 100000 -m 1000000 -type high_ti_high_Ti\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T19:49:56.403324",
        "total_tutorials": 3,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "215/E",
      "title": "E. Периодические числа",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест2 секунды",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеВ единственной строке входных данных записаны два целых числа l и r (1 ≤ l ≤ r ≤ 1018). Числа разделены пробелом.Пожалуйста, не используйте спецификатор %lld для чтения или записи 64-битных чисел на С++. Рекомендуется использовать потоки cin, cout или спецификатор %I64d.",
      "output_spec": "Выходные данныеВыведите единственное целое число — количество периодических чисел в отрезке от l до r (оба конца включены).",
      "sample_tests": "ПримерыВходные данныеСкопировать1 10Выходные данныеСкопировать3Входные данныеСкопировать25 38Выходные данныеСкопировать2",
      "description": "E. Периодические числа\n\nограничение по времени на тест2 секунды\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвыводstdout\n\nВходные данныеВ единственной строке входных данных записаны два целых числа l и r (1 ≤ l ≤ r ≤ 1018). Числа разделены пробелом.Пожалуйста, не используйте спецификатор %lld для чтения или записи 64-битных чисел на С++. Рекомендуется использовать потоки cin, cout или спецификатор %I64d.\n\nВходные данные\n\nВыходные данныеВыведите единственное целое число — количество периодических чисел в отрезке от l до r (оба конца включены).\n\nВыходные данные\n\nВходные данныеСкопировать1 10Выходные данныеСкопировать3Входные данныеСкопировать25 38Выходные данныеСкопировать2\n\nВходные данныеСкопировать1 10\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать3\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать25 38\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать2\n\nВыходные данныеСкопировать\n\nСкопировать\n\nПримечаниеВ первом примере периодическими числами являются 3, 7 и 10.Во втором примере периодическими числами являются 31 и 36.",
      "solutions": [
        {
          "title": "Codeforces Round #132 (Div. 2) - Codeforces",
          "content": "Доброе время суток!Через несколько часов начнется очередной Codeforces Round #132 для участников Div.2, но традиционно остальные могут поучаствовать вне конкурса. Он был подготовлен небольшой командой авторов: я (NALP), Эдвард Давтян (Edvard), Виталий Аксенов (Aksenov239), Геральд Агапов (Gerald), Мария Белова (Delinur) и Михаил Мирзаянов (MikeMirzayanov).Традиционно всем удачи, полных решений и удачных взломов!Отдельно хочется пожелать успеха и спортивной удачи всем, кто сейчас представляет свои страны на XXX Олимпийских играх в Лондоне! На раунде будет использована динамическая система оценки задач. Но, несмотря на это, задачи будут расположены в предположительном порядке возрастания сложности!UPD: Раунд завершен, спасибо всем за участие! Надеемся, что все участники получили удовольствие!UPD: Поздравляем победителей! yooo — единственный участник Div.2, кто решил все представленные задачи! zzy High_Rich_Handsome bookcity_clock capythm UPD: Разбор задач на русском языке уже опубликован!",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/5017",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 1001
        },
        {
          "title": "Codeforces Round #132 (Div. 2) - Codeforces",
          "content": "Доброе время суток!Через несколько часов начнется очередной Codeforces Round #132 для участников Div.2, но традиционно остальные могут поучаствовать вне конкурса. Он был подготовлен небольшой командой авторов: я (NALP), Эдвард Давтян (Edvard), Виталий Аксенов (Aksenov239), Геральд Агапов (Gerald), Мария Белова (Delinur) и Михаил Мирзаянов (MikeMirzayanov).Традиционно всем удачи, полных решений и удачных взломов!Отдельно хочется пожелать успеха и спортивной удачи всем, кто сейчас представляет свои страны на XXX Олимпийских играх в Лондоне! На раунде будет использована динамическая система оценки задач. Но, несмотря на это, задачи будут расположены в предположительном порядке возрастания сложности!UPD: Раунд завершен, спасибо всем за участие! Надеемся, что все участники получили удовольствие!UPD: Поздравляем победителей! yooo — единственный участник Div.2, кто решил все представленные задачи! zzy High_Rich_Handsome bookcity_clock capythm UPD: Разбор задач на русском языке уже опубликован!",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/5017",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 1001
        },
        {
          "title": "Разбор задачи E CF#132 - Codeforces",
          "content": "Привет всем! Дальше я постараюсь объяснить решение задачи E Codeforces Round #132.Давайте научимся решать немного другую задачу и будем искать число периодических чисел в полуинтервале (2k, x], где . Тогда видно, что x имеет длину len = k + 1.Теперь найдем блоки из единиц и двоек, которые, как раз, и являются общей частью периодического числа. У таких блоков, как следует из определения, длина является делителем длины всего числа len.Теперь посчитаем число таких блоков g[i], которые имеют длину i, i делитель len. Возьмем старшие i бит числа x и назовем соответствующее число t = x >> (len - i), например если взять x = 100110002, а i = 4, то тогда t = 10012, а если i = 2, то t = 102. Первым делом, проверим подходит ли этот блок t, это можно сделать, например, посчитав p = ttttt..., где t повторяется раз, p можно посчитать в цикле p = (p << i) + t. Понятно, что если p ≤ x, то посчитаем этот блок и сделаем g[i] = 1, иначе g[i] = 0. Все подходящие блоки должны быть меньше или равны t, и первая цифра у них обязательно 1, так как не может быть лидирующих нулей. Случай равенства мы уже учли, тогда осталось добавить к g[i] разницу между t и 2i - 1 = 10000...2, где i-1 нулей, g[i] = g[i] + t - (1 << (i - 1)). Может показаться, что все уже готово и можем сложить все g[i], где i делитель len, и не равно len, но нельзя. Покажем, что таким образом мы учли некоторые случаи по нескольку раз, например для x = 101011002, i = 4, g[4] = 1 + (10102 - 10002) = 3, мы посчитали блоки 1000, 1001, 1010, и если взять i = 2,g[2] = 1 + (102 - 102) = 1, мы учтем 10, но 1010 получается из 10 повторением два раза. Но эта проблема очень легко решается, для этого необходимо вычесть из g[i] все g[j], где j < i и j делитель i.То есть мы считаем, своего рода, динамику.g[i] начиная с i = 1 до самого большого делителя len не равного len, и обновляем значения, вычитая соответствующие g[j].Теперь мы научились считать количество таких чисел на полуинтервале (2k, x], перебирая все делители len и считая динамику g[i], и потом возвращаем сумму g[i], по всем делителям i < len . Заметим, что степень двойки не может быть периодическим числом. Теперь мы можем посчитать аналогичную величину для x = 2k - 1, дальше для 2k - 1 - 1 и так далее, пока не станет x = 1, теперь на этих непересекающихся полуинтервалах посчитаем сумму и вернем ответ. Это можно реализовать рекурсией. Вот мой код на C++, я дополнительно предпосчитал все делители для чисел до 60. Спасибо за внимание, надеюсь вам все понятно, а если не понятно задавайте вопросы)UPD: Еще один код, который немного асимптотически быстрее.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/5034",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 2583
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #132 (Div. 2) - Codeforces - Code 1",
          "code": "#define int unsigned long long",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5017",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #132 (Div. 2) - Codeforces - Code 2",
          "code": "value.ToString(CultureInfo.InvariantCulture)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5017",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #132 (Div. 2) - Codeforces - Code 3",
          "code": "value.ToString().Replace(',','.')",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5017",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #132 (Div. 2) - Codeforces - Code 1",
          "code": "#define int unsigned long long",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5017",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #132 (Div. 2) - Codeforces - Code 2",
          "code": "value.ToString(CultureInfo.InvariantCulture)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5017",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #132 (Div. 2) - Codeforces - Code 3",
          "code": "value.ToString().Replace(',','.')",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5017",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    long long l = inf.readLong(1LL, 1000000000000000000LL, \"l\");\n    inf.readSpace();\n    long long r = inf.readLong(l, 1000000000000000000LL, \"r\");\n    inf.readEoln();\n    \n    inf.readEof();\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    long long l = inf.readLong(1LL, 1000000000000000000LL, \"l\");\n    inf.readSpace();\n    long long r = inf.readLong(l, 1000000000000000000LL, \"r\");\n    inf.readEoln();\n    \n    inf.readEof();\n\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    long long l = inf.readLong(1LL, 1000000000000000000LL, \"l\");\n    inf.readSpace();\n    long long r = inf.readLong(l, 1000000000000000000LL, \"r\");\n    inf.readEoln();\n    \n    inf.readEof();\n\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst long long MAXN = 1000000000000000000LL; // 1e18\n\nint main(int argc, char *argv[]) {\n    registerGen(argc, argv, 1);\n\n    string type = opt<string>(\"type\", \"random\");\n    long long l = opt<long long>(\"l\", -1LL);\n    long long r = opt<long long>(\"r\", -1LL);\n\n    if (type == \"specific\") {\n        if (l == -1LL || r == -1LL) {\n            fprintf(stderr, \"Error: For type 'specific' you must provide 'l' and 'r'\\n\");\n            return 1;\n        }\n        // Use provided l and r\n    } else if (l != -1LL && r != -1LL) {\n        // Use provided l and r\n    } else if (type == \"max_range\") {\n        l = 1;\n        r = MAXN;\n    } else if (type == \"min_range\") {\n        l = 1;\n        r = 1;\n    } else if (type == \"single_number\") {\n        l = opt<long long>(\"l\", -1LL);\n        if (l == -1LL) {\n            l = rnd.next(1LL, MAXN);\n        }\n        r = l;\n    } else if (type == \"small_range\") {\n        l = rnd.next(1LL, 1000LL);\n        r = l + rnd.next(0LL, 1000LL);\n        if (r > MAXN) r = MAXN;\n    } else if (type == \"large_range\") {\n        l = rnd.next(1LL, MAXN / 2);\n        r = rnd.next(MAXN / 2, MAXN);\n        if (l > r) swap(l, r);\n    } else if (type == \"edge_case\") {\n        l = 1;\n        r = rnd.next(1LL, 100LL);\n    } else if (type == \"near_max\") {\n        l = MAXN - rnd.next(0LL, 1000LL);\n        r = MAXN;\n    } else if (type == \"no_periodic\") {\n        l = 1000000000000001LL;\n        r = 1000000000000010LL;\n    } else if (type == \"all_periodic\") {\n        l = 3;\n        r = 15; // binary 1111\n    } else {\n        // Random case\n        l = rnd.next(1LL, MAXN);\n        r = rnd.next(1LL, MAXN);\n        if (l > r) swap(l, r);\n    }\n\n    printf(\"%lld %lld\\n\", l, r);\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst long long MAXN = 1000000000000000000LL; // 1e18\n\nint main(int argc, char *argv[]) {\n    registerGen(argc, argv, 1);\n\n    string type = opt<string>(\"type\", \"random\");\n    long long l = opt<long long>(\"l\", -1LL);\n    long long r = opt<long long>(\"r\", -1LL);\n\n    if (type == \"specific\") {\n        if (l == -1LL || r == -1LL) {\n            fprintf(stderr, \"Error: For type 'specific' you must provide 'l' and 'r'\\n\");\n            return 1;\n        }\n        // Use provided l and r\n    } else if (l != -1LL && r != -1LL) {\n        // Use provided l and r\n    } else if (type == \"max_range\") {\n        l = 1;\n        r = MAXN;\n    } else if (type == \"min_range\") {\n        l = 1;\n        r = 1;\n    } else if (type == \"single_number\") {\n        l = opt<long long>(\"l\", -1LL);\n        if (l == -1LL) {\n            l = rnd.next(1LL, MAXN);\n        }\n        r = l;\n    } else if (type == \"small_range\") {\n        l = rnd.next(1LL, 1000LL);\n        r = l + rnd.next(0LL, 1000LL);\n        if (r > MAXN) r = MAXN;\n    } else if (type == \"large_range\") {\n        l = rnd.next(1LL, MAXN / 2);\n        r = rnd.next(MAXN / 2, MAXN);\n        if (l > r) swap(l, r);\n    } else if (type == \"edge_case\") {\n        l = 1;\n        r = rnd.next(1LL, 100LL);\n    } else if (type == \"near_max\") {\n        l = MAXN - rnd.next(0LL, 1000LL);\n        r = MAXN;\n    } else if (type == \"no_periodic\") {\n        l = 1000000000000001LL;\n        r = 1000000000000010LL;\n    } else if (type == \"all_periodic\") {\n        l = 3;\n        r = 15; // binary 1111\n    } else {\n        // Random case\n        l = rnd.next(1LL, MAXN);\n        r = rnd.next(1LL, MAXN);\n        if (l > r) swap(l, r);\n    }\n\n    printf(\"%lld %lld\\n\", l, r);\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -type max_range\n./gen -type min_range\n./gen -type single_number -l 1\n./gen -type single_number -l 2\n./gen -type single_number -l 100\n./gen -type single_number -l 1000000\n./gen -type single_number -l 1000000000\n./gen -type specific -l 1 -r 1\n./gen -type specific -l 2 -r 2\n./gen -type specific -l 3 -r 3\n./gen -type specific -l 4 -r 4\n./gen -type specific -l 1 -r 100\n./gen -type specific -l 500 -r 1000\n./gen -type specific -l 999999999999999999 -r 1000000000000000000\n./gen -type small_range\n./gen -type small_range\n./gen -type small_range\n./gen -type large_range\n./gen -type large_range\n./gen -type large_range\n./gen -type edge_case\n./gen -type near_max\n./gen -type no_periodic\n./gen -type all_periodic\n./gen -type random\n./gen -type random\n./gen -type random\n./gen -type random\n./gen -type random\n./gen -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T19:49:58.658746",
        "total_tutorials": 3,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "216/A",
      "title": "A. Tiling with Hexagons",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains three integers: a, b and c (2 ≤ a, b, c ≤ 1000).",
      "output_spec": "OutputPrint a single number — the total number of tiles on the hall floor.",
      "sample_tests": "ExamplesInputCopy2 3 4OutputCopy18",
      "description": "A. Tiling with Hexagons\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains three integers: a, b and c (2 ≤ a, b, c ≤ 1000).\n\nOutputPrint a single number — the total number of tiles on the hall floor.\n\nInputCopy2 3 4OutputCopy18\n\nInputCopy2 3 4\n\nOutputCopy18",
      "solutions": [
        {
          "title": "Codeforces Round #133 - Codeforces",
          "content": "Hello everyone.That is the 133th Codeforces round. Specially for the 2nd division. Contestants from the 1st division can solve the round out of competition.Round is prepared by Ripatti , Gerald , Aksenov239 , Delinur and MikeMirzayanov .The round will use dymanic scoring system. Problems will be ordered in random manner (see UPD1). If you want get more happiness from solving that round, please, read statements of all problems.Good luck!UPD1. Jury members discussed and have decided to rearrange problems in expected order of difficulty.UPD2. Contest ended. Winners:1. karensun5222. stostap3. sisterX4. BiliBilisolved all 5 problems. Congratulations!Editorial will be soon tommorow (I am very tired =_=, but now you can try to read russian editorial here).UPD3. Editorial in English.",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/5061",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 786
        },
        {
          "title": "Editorial for Codeforces Round #133 - Codeforces",
          "content": "A. For solving this problem you might find some formula likeres = abc - (a - 1)(b - 1)(c - 1), res = ab + bc + ca - a - b - c + 1, or something else.Also the problem can be solved in O(a + b + c) time — you can move from the top line to the bottom line of hexagon and sum number of tiles in every line.Author is Ripatti .B. You can build some graph where vertices are students and edges are enmities. You should drop some vertices and then paint them in two colors. Any edge should connect vertices of distinct colors and numbers of vertices of every color should be same.You can see that graph consists chians, cycles and sepatated vertices. Every of that component can be painted in 2 colors except one case: cycles of odd length. So, you should drop one vertex from every odd cycle. After that you can get odd number of vertices. Then you should drop one more vertex (you can chose any of them). The obtained graph can be easily painted in 2 colors in the required manner.Authors are Gerald , Ripatti .С. The first solution: analysis of the cases1. k = 1. For n ≤ m + 1 3 employees is enough (in most cases). For n > m + 1 answer is 2. Also, there are only one tricky corner case: for n = 2, m = 2, k = 1 answer is 4.2. k > 1. If n = m, answer is 2k + 1, otherwise answer is 2k.For any case it is easy to construct solution, and prove that this solution is optimal.The second solution: greedy.Let's create an array where we will store current number of employees for some number of the first days. Now you should iterate over all days from the first to the n + m-th and hire employees every time when it needed. You should hire workers if there are less than k people in the current day; also you should hire worker if there will be no people tomorrow (thet worker will bring the key to the workers that will work tomorrow).This solution works in O((n + m)k).This solution also works correctly for cases n < m, but then it has bigger complexity and requires more time.Authors are Gerald , Ripatti .D. For every sector you should sort bridges in order of increasing distance from the conter of the web. Now for every sector you should iterate over bridges of the current sector and two adjacent sectors using 3 pointers. During every pass you should carefully calculate number of bad cells. That is all solution.Solition in , where m is total number of bridges.Author is Ripatti .E. Digital root of number is equal to that number modulo k - 1 for most cases. It is lie only for digital roots 0 and k - 1 — in that cases number modulo k - 1 will be 0. But you can get digital root 0 only for numbers like 00...00. Total number of numbers that type you can find using any other way. So, now you can find number of substrings that have some digital root, if you know number of substrings that equals some number modulo k - 1.How to find number of substrings of some modulo? You should iterate over all digits of s from the left to the rigth and for every modulo store number of prefixes of that modulo in some array dp[] of size k. Let's current position is i. Then number of substrings modulo b that ends in position i equals to number of prefixes leftmost position i that have modulo (x - b)mod(k - 1), where x is modulo of s[1... i]. I.e. just dp[(x - b)mod(k - 1)].To fit into memory limit, you should replace array dp[] by some associative array. For example, std::map from С++ or some hashtable.So we have solution in O(nz), where z is complexety of access to dp[] ( for std::map and O(1) for hashtable). Author is Ripatti.",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/5066",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 3528
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #133 - Codeforces - Code 1",
          "code": "UPD: cout << (a+c-1)*(b+c-1)-c*(c-1) << endl;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5061",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #133 - Codeforces - Code 2",
          "code": "some tips about problem A\n\na=2 b=3 c=4 total=18\n\n    O O O O   \n   O O O O O\n  O O O O O\n   O O O O\n\na=1 b=4 c=5 total=20 X:2 O:18\n\n    O O O O X\n   O O O O O\n  O O O O O\n X O O O O\n\na=4 b=1 c=6 total=24 X:6 O:18\n\nX X O O O O   \n X O O O O O\n  O O O O O X\n   O O O O X X\n\t   \na=5 b=6 c=1 total=30 X:12 O:18\n\n       X\n      X X\n     X X X\n    O O O O   \n   O O O O O\n  O O O O O\n   O O O O\n    X X X\n     X X\n      X",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5061",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #133 - Codeforces - Code 3",
          "code": "some tips about problem A\n\na=2 b=3 c=4 total=18\n\n    O O O O   \n   O O O O O\n  O O O O O\n   O O O O\n\na=1 b=4 c=5 total=20 X:2 O:18\n\n    O O O O X\n   O O O O O\n  O O O O O\n X O O O O\n\na=4 b=1 c=6 total=24 X:6 O:18\n\nX X O O O O   \n X O O O O O\n  O O O O O X\n   O O O O X X\n\t   \na=5 b=6 c=1 total=30 X:12 O:18\n\n       X\n      X X\n     X X X\n    O O O O   \n   O O O O O\n  O O O O O\n   O O O O\n    X X X\n     X X\n      X",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5061",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #133 - Codeforces - Code 4",
          "code": "6 4\n\n1 2\n\n1 3\n\n4 5\n\n4 6",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5061",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #133 - Codeforces - Code 5",
          "code": "6 4\n\n1 2\n\n1 3\n\n4 5\n\n4 6",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5061",
          "author": "Qingyu"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int a = inf.readInt(2, 1000, \"a\");\n    inf.readSpace();\n    int b = inf.readInt(2, 1000, \"b\");\n    inf.readSpace();\n    int c = inf.readInt(2, 1000, \"c\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int a = inf.readInt(2, 1000, \"a\");\n    inf.readSpace();\n    int b = inf.readInt(2, 1000, \"b\");\n    inf.readSpace();\n    int c = inf.readInt(2, 1000, \"c\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int a = inf.readInt(2, 1000, \"a\");\n    inf.readSpace();\n    int b = inf.readInt(2, 1000, \"b\");\n    inf.readSpace();\n    int c = inf.readInt(2, 1000, \"c\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare sequences of tokens\");\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string j, p;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n\r\n        ans.readWordTo(j);\r\n        ouf.readWordTo(p);\r\n\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s words differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  compress(j).c_str(), compress(p).c_str());\r\n    }\r\n\r\n    if (ans.seekEof() && ouf.seekEof()) {\r\n        if (n == 1)\r\n            quitf(_ok, \"\\\"%s\\\"\", compress(j).c_str());\r\n        else\r\n            quitf(_ok, \"%d tokens\", n);\r\n    } else {\r\n        if (ans.seekEof())\r\n            quitf(_wa, \"Participant output contains extra tokens\");\r\n        else\r\n            quitf(_wa, \"Unexpected EOF in the participants output\");\r\n    }\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int min_val = 2;\n    int max_val = 1000;\n\n    // Read parameters\n    int a = opt<int>(\"a\", 0);\n    int b = opt<int>(\"b\", 0);\n    int c = opt<int>(\"c\", 0);\n\n    if (a == 0)\n        a = rnd.next(min_val, max_val);\n    if (b == 0)\n        b = rnd.next(min_val, max_val);\n    if (c == 0)\n        c = rnd.next(min_val, max_val);\n\n    printf(\"%d %d %d\\n\", a, b, c);\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int min_val = 2;\n    int max_val = 1000;\n\n    // Read parameters\n    int a = opt<int>(\"a\", 0);\n    int b = opt<int>(\"b\", 0);\n    int c = opt<int>(\"c\", 0);\n\n    if (a == 0)\n        a = rnd.next(min_val, max_val);\n    if (b == 0)\n        b = rnd.next(min_val, max_val);\n    if (c == 0)\n        c = rnd.next(min_val, max_val);\n\n    printf(\"%d %d %d\\n\", a, b, c);\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Minimal values\n./gen -a 2 -b 2 -c 2\n\n# Maximal values\n./gen -a 1000 -b 1000 -c 1000\n\n# One minimal, others maximal\n./gen -a 2 -b 1000 -c 1000\n./gen -a 1000 -b 2 -c 1000\n./gen -a 1000 -b 1000 -c 2\n\n# All equal, medium value\n./gen -a 500 -b 500 -c 500\n\n# All different random numbers\n./gen -a 2 -b 500 -c 1000\n\n# One value significantly larger\n./gen -a 1000 -b 2 -c 2\n./gen -a 2 -b 1000 -c 2\n./gen -a 2 -b 2 -c 1000\n\n# Random values\n./gen\n./gen\n./gen\n./gen\n./gen\n./gen\n./gen\n./gen\n./gen\n./gen\n\n# Consecutive numbers\n./gen -a 2 -b 3 -c 4\n\n# Decreasing values\n./gen -a 1000 -b 500 -c 2\n\n# Increasing values\n./gen -a 2 -b 500 -c 1000\n\n# Two values equal, one different\n./gen -a 1000 -b 1000 -c 500\n./gen -a 2 -b 2 -c 500\n./gen -a 500 -b 2 -c 2\n\n# Values close to maximum\n./gen -a 999 -b 998 -c 997\n\n# Prime numbers\n./gen -a 997 -b 991 -c 983\n\n# Even numbers\n./gen -a 1000 -b 998 -c 996\n\n# Odd numbers\n./gen -a 999 -b 997 -c 995\n\n# Large range between values\n./gen -a 2 -b 500 -c 999\n\n# Small values\n./gen -a 2 -b 3 -c 5\n\n# Medium values\n./gen -a 250 -b 500 -c 750\n\n# Values at boundaries\n./gen -a 2 -b 1000 -c 500\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T19:50:00.457248",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "216/B",
      "title": "B. Forming Teams",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains two integers n and m (2 ≤ n ≤ 100, 1 ≤ m ≤ 100) — the number of students and the number of pairs of archenemies correspondingly.Next m lines describe enmity between students. Each enmity is described as two numbers ai and bi (1 ≤ ai, bi ≤ n, ai ≠ bi) — the indexes of the students who are enemies to each other. Each enmity occurs in the list exactly once. It is guaranteed that each student has no more than two archenemies.You can consider the students indexed in some manner with distinct integers from 1 to n.",
      "output_spec": "OutputPrint a single integer — the minimum number of students you will have to send to the bench in order to start the game.",
      "sample_tests": "ExamplesInputCopy5 41 22 45 31 4OutputCopy1InputCopy6 21 43 4OutputCopy0InputCopy6 61 22 33 14 55 66 4OutputCopy2",
      "description": "B. Forming Teams\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains two integers n and m (2 ≤ n ≤ 100, 1 ≤ m ≤ 100) — the number of students and the number of pairs of archenemies correspondingly.Next m lines describe enmity between students. Each enmity is described as two numbers ai and bi (1 ≤ ai, bi ≤ n, ai ≠ bi) — the indexes of the students who are enemies to each other. Each enmity occurs in the list exactly once. It is guaranteed that each student has no more than two archenemies.You can consider the students indexed in some manner with distinct integers from 1 to n.\n\nOutputPrint a single integer — the minimum number of students you will have to send to the bench in order to start the game.\n\nInputCopy5 41 22 45 31 4OutputCopy1InputCopy6 21 43 4OutputCopy0InputCopy6 61 22 33 14 55 66 4OutputCopy2\n\nInputCopy5 41 22 45 31 4\n\nOutputCopy1\n\nInputCopy6 21 43 4\n\nOutputCopy0\n\nInputCopy6 61 22 33 14 55 66 4\n\nOutputCopy2",
      "solutions": [
        {
          "title": "Codeforces Round #133 - Codeforces",
          "content": "Hello everyone.That is the 133th Codeforces round. Specially for the 2nd division. Contestants from the 1st division can solve the round out of competition.Round is prepared by Ripatti , Gerald , Aksenov239 , Delinur and MikeMirzayanov .The round will use dymanic scoring system. Problems will be ordered in random manner (see UPD1). If you want get more happiness from solving that round, please, read statements of all problems.Good luck!UPD1. Jury members discussed and have decided to rearrange problems in expected order of difficulty.UPD2. Contest ended. Winners:1. karensun5222. stostap3. sisterX4. BiliBilisolved all 5 problems. Congratulations!Editorial will be soon tommorow (I am very tired =_=, but now you can try to read russian editorial here).UPD3. Editorial in English.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/5061",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 786
        },
        {
          "title": "Editorial for Codeforces Round #133 - Codeforces",
          "content": "A. For solving this problem you might find some formula likeres = abc - (a - 1)(b - 1)(c - 1), res = ab + bc + ca - a - b - c + 1, or something else.Also the problem can be solved in O(a + b + c) time — you can move from the top line to the bottom line of hexagon and sum number of tiles in every line.Author is Ripatti .B. You can build some graph where vertices are students and edges are enmities. You should drop some vertices and then paint them in two colors. Any edge should connect vertices of distinct colors and numbers of vertices of every color should be same.You can see that graph consists chians, cycles and sepatated vertices. Every of that component can be painted in 2 colors except one case: cycles of odd length. So, you should drop one vertex from every odd cycle. After that you can get odd number of vertices. Then you should drop one more vertex (you can chose any of them). The obtained graph can be easily painted in 2 colors in the required manner.Authors are Gerald , Ripatti .С. The first solution: analysis of the cases1. k = 1. For n ≤ m + 1 3 employees is enough (in most cases). For n > m + 1 answer is 2. Also, there are only one tricky corner case: for n = 2, m = 2, k = 1 answer is 4.2. k > 1. If n = m, answer is 2k + 1, otherwise answer is 2k.For any case it is easy to construct solution, and prove that this solution is optimal.The second solution: greedy.Let's create an array where we will store current number of employees for some number of the first days. Now you should iterate over all days from the first to the n + m-th and hire employees every time when it needed. You should hire workers if there are less than k people in the current day; also you should hire worker if there will be no people tomorrow (thet worker will bring the key to the workers that will work tomorrow).This solution works in O((n + m)k).This solution also works correctly for cases n < m, but then it has bigger complexity and requires more time.Authors are Gerald , Ripatti .D. For every sector you should sort bridges in order of increasing distance from the conter of the web. Now for every sector you should iterate over bridges of the current sector and two adjacent sectors using 3 pointers. During every pass you should carefully calculate number of bad cells. That is all solution.Solition in , where m is total number of bridges.Author is Ripatti .E. Digital root of number is equal to that number modulo k - 1 for most cases. It is lie only for digital roots 0 and k - 1 — in that cases number modulo k - 1 will be 0. But you can get digital root 0 only for numbers like 00...00. Total number of numbers that type you can find using any other way. So, now you can find number of substrings that have some digital root, if you know number of substrings that equals some number modulo k - 1.How to find number of substrings of some modulo? You should iterate over all digits of s from the left to the rigth and for every modulo store number of prefixes of that modulo in some array dp[] of size k. Let's current position is i. Then number of substrings modulo b that ends in position i equals to number of prefixes leftmost position i that have modulo (x - b)mod(k - 1), where x is modulo of s[1... i]. I.e. just dp[(x - b)mod(k - 1)].To fit into memory limit, you should replace array dp[] by some associative array. For example, std::map from С++ or some hashtable.So we have solution in O(nz), where z is complexety of access to dp[] ( for std::map and O(1) for hashtable). Author is Ripatti.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/5066",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 3528
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #133 - Codeforces - Code 1",
          "code": "UPD: cout << (a+c-1)*(b+c-1)-c*(c-1) << endl;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5061",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #133 - Codeforces - Code 2",
          "code": "some tips about problem A\n\na=2 b=3 c=4 total=18\n\n    O O O O   \n   O O O O O\n  O O O O O\n   O O O O\n\na=1 b=4 c=5 total=20 X:2 O:18\n\n    O O O O X\n   O O O O O\n  O O O O O\n X O O O O\n\na=4 b=1 c=6 total=24 X:6 O:18\n\nX X O O O O   \n X O O O O O\n  O O O O O X\n   O O O O X X\n\t   \na=5 b=6 c=1 total=30 X:12 O:18\n\n       X\n      X X\n     X X X\n    O O O O   \n   O O O O O\n  O O O O O\n   O O O O\n    X X X\n     X X\n      X",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5061",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #133 - Codeforces - Code 3",
          "code": "some tips about problem A\n\na=2 b=3 c=4 total=18\n\n    O O O O   \n   O O O O O\n  O O O O O\n   O O O O\n\na=1 b=4 c=5 total=20 X:2 O:18\n\n    O O O O X\n   O O O O O\n  O O O O O\n X O O O O\n\na=4 b=1 c=6 total=24 X:6 O:18\n\nX X O O O O   \n X O O O O O\n  O O O O O X\n   O O O O X X\n\t   \na=5 b=6 c=1 total=30 X:12 O:18\n\n       X\n      X X\n     X X X\n    O O O O   \n   O O O O O\n  O O O O O\n   O O O O\n    X X X\n     X X\n      X",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5061",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #133 - Codeforces - Code 4",
          "code": "6 4\n\n1 2\n\n1 3\n\n4 5\n\n4 6",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5061",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #133 - Codeforces - Code 5",
          "code": "6 4\n\n1 2\n\n1 3\n\n4 5\n\n4 6",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5061",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(2, 100, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 100, \"m\");\n    inf.readEoln();\n\n    set<pair<int,int>> edges; // to store unique pairs of archenemies\n    vector<int> degree(n+1, 0); // counts the number of archenemies for each student\n\n    for (int i = 0; i < m; ++i) {\n        int a = inf.readInt(1, n, \"ai\");\n        inf.readSpace();\n        int b = inf.readInt(1, n, \"bi\");\n        inf.readEoln();\n        ensuref(a != b, \"Student cannot be an archenemy to themselves (ai = bi = %d)\", a);\n\n        int u = min(a, b);\n        int v = max(a, b);\n        pair<int,int> p = make_pair(u, v);\n        ensuref(edges.count(p) == 0, \"Duplicate enmity between students %d and %d\", u, v);\n        edges.insert(p);\n\n        degree[a]++;\n        degree[b]++;\n        ensuref(degree[a] <= 2, \"Student %d has more than two archenemies\", a);\n        ensuref(degree[b] <= 2, \"Student %d has more than two archenemies\", b);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(2, 100, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 100, \"m\");\n    inf.readEoln();\n\n    set<pair<int,int>> edges; // to store unique pairs of archenemies\n    vector<int> degree(n+1, 0); // counts the number of archenemies for each student\n\n    for (int i = 0; i < m; ++i) {\n        int a = inf.readInt(1, n, \"ai\");\n        inf.readSpace();\n        int b = inf.readInt(1, n, \"bi\");\n        inf.readEoln();\n        ensuref(a != b, \"Student cannot be an archenemy to themselves (ai = bi = %d)\", a);\n\n        int u = min(a, b);\n        int v = max(a, b);\n        pair<int,int> p = make_pair(u, v);\n        ensuref(edges.count(p) == 0, \"Duplicate enmity between students %d and %d\", u, v);\n        edges.insert(p);\n\n        degree[a]++;\n        degree[b]++;\n        ensuref(degree[a] <= 2, \"Student %d has more than two archenemies\", a);\n        ensuref(degree[b] <= 2, \"Student %d has more than two archenemies\", b);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(2, 100, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 100, \"m\");\n    inf.readEoln();\n\n    set<pair<int,int>> edges; // to store unique pairs of archenemies\n    vector<int> degree(n+1, 0); // counts the number of archenemies for each student\n\n    for (int i = 0; i < m; ++i) {\n        int a = inf.readInt(1, n, \"ai\");\n        inf.readSpace();\n        int b = inf.readInt(1, n, \"bi\");\n        inf.readEoln();\n        ensuref(a != b, \"Student cannot be an archenemy to themselves (ai = bi = %d)\", a);\n\n        int u = min(a, b);\n        int v = max(a, b);\n        pair<int,int> p = make_pair(u, v);\n        ensuref(edges.count(p) == 0, \"Duplicate enmity between students %d and %d\", u, v);\n        edges.insert(p);\n\n        degree[a]++;\n        degree[b]++;\n        ensuref(degree[a] <= 2, \"Student %d has more than two archenemies\", a);\n        ensuref(degree[b] <= 2, \"Student %d has more than two archenemies\", b);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> students(n);\n    for (int i = 0; i < n; ++i) students[i] = i + 1;\n    shuffle(students.begin(), students.end());\n\n    vector<pair<int, int>> archenemy_pairs;\n\n    if (type == \"paths\") {\n        // Generate random paths\n        int num_paths = rnd.next(1, n - 1);\n        vector<int> path_lengths(num_paths, 1);\n        int remaining_students = n - num_paths;\n\n        for (int i = 0; i < remaining_students; ++i) {\n            int idx = rnd.next(0, num_paths - 1);\n            path_lengths[idx]++;\n        }\n\n        int idx = 0;\n        for (int i = 0; i < num_paths; ++i) {\n            int len = path_lengths[i];\n            for (int j = 0; j < len - 1; ++j) {\n                int u = students[idx + j];\n                int v = students[idx + j + 1];\n                archenemy_pairs.push_back({min(u, v), max(u, v)});\n            }\n            idx += len;\n        }\n    } else if (type == \"even_cycles\") {\n        // Generate cycles of even length\n        vector<int> cycle_lengths;\n        int remaining_students = n;\n\n        while (remaining_students >= 2) {\n            int max_len = remaining_students;\n            int len = 2 * rnd.next(1, remaining_students / 2);\n            if (len > remaining_students) len = remaining_students;\n            cycle_lengths.push_back(len);\n            remaining_students -= len;\n        }\n\n        int idx = 0;\n        for (int len : cycle_lengths) {\n            for (int j = 0; j < len; ++j) {\n                int u = students[idx + j];\n                int v = students[idx + (j + 1) % len];\n                archenemy_pairs.push_back({min(u, v), max(u, v)});\n            }\n            idx += len;\n        }\n    } else if (type == \"odd_cycles\") {\n        // Generate cycles of odd length\n        vector<int> cycle_lengths;\n        int remaining_students = n;\n\n        while (remaining_students >= 3) {\n            int max_len = remaining_students;\n            int len = 2 * rnd.next(1, (remaining_students - 1) / 2) + 1;\n            if (len > remaining_students) len = remaining_students;\n            cycle_lengths.push_back(len);\n            remaining_students -= len;\n        }\n\n        if (remaining_students > 0) {\n            // Add remaining students as single-node paths\n            for (int i = 0; i < remaining_students; ++i) {\n                cycle_lengths.push_back(1);\n            }\n            remaining_students = 0;\n        }\n\n        int idx = 0;\n        for (int len : cycle_lengths) {\n            if (len == 1) {\n                // No edges to add\n                idx += 1;\n                continue;\n            }\n            for (int j = 0; j < len; ++j) {\n                int u = students[idx + j];\n                int v = students[idx + (j + 1) % len];\n                archenemy_pairs.push_back({min(u, v), max(u, v)});\n            }\n            idx += len;\n        }\n    } else if (type == \"mixed\") {\n        // Generate a mixture of paths and cycles\n        int remaining_students = n;\n        int idx = 0;\n        while (remaining_students > 0) {\n            int choice = rnd.next(1, 3); // 1: path, 2: even cycle, 3: odd cycle\n            if (remaining_students == 1) choice = 1;\n            if (choice == 1) {\n                // Generate a path\n                int len = rnd.next(1, min(remaining_students, 10));\n                int path_start = idx;\n                for (int j = 0; j < len - 1; ++j) {\n                    int u = students[idx + j];\n                    int v = students[idx + j + 1];\n                    archenemy_pairs.push_back({min(u, v), max(u, v)});\n                }\n                idx += len;\n                remaining_students -= len;\n            } else if (choice == 2 && remaining_students >= 2) {\n                // Generate an even cycle\n                int len = 2 * rnd.next(1, remaining_students / 2);\n                if (len > remaining_students) len = remaining_students;\n                for (int j = 0; j < len; ++j) {\n                    int u = students[idx + j];\n                    int v = students[idx + (j + 1) % len];\n                    archenemy_pairs.push_back({min(u, v), max(u, v)});\n                }\n                idx += len;\n                remaining_students -= len;\n            } else if (choice == 3 && remaining_students >= 3) {\n                // Generate an odd cycle\n                int len = 2 * rnd.next(1, (remaining_students - 1) / 2) + 1;\n                if (len > remaining_students) len = remaining_students;\n                for (int j = 0; j < len; ++j) {\n                    int u = students[idx + j];\n                    int v = students[idx + (j + 1) % len];\n                    archenemy_pairs.push_back({min(u, v), max(u, v)});\n                }\n                idx += len;\n                remaining_students -= len;\n            }\n        }\n    } else if (type == \"max_bench\") {\n        // Generate a case where the minimal number of students to bench is maximal\n        // Create several odd-length cycles to maximize benches required\n        vector<int> cycle_lengths;\n        int remaining_students = n;\n\n        while (remaining_students >= 3) {\n            int len = 3; // Use smallest odd cycle\n            cycle_lengths.push_back(len);\n            remaining_students -= len;\n        }\n\n        if (remaining_students > 0) {\n            // Add remaining students as single-node paths\n            for (int i = 0; i < remaining_students; ++i) {\n                cycle_lengths.push_back(1);\n            }\n            remaining_students = 0;\n        }\n\n        int idx = 0;\n        for (int len : cycle_lengths) {\n            if (len == 1) {\n                idx += 1;\n                continue;\n            }\n            for (int j = 0; j < len; ++j) {\n                int u = students[idx + j];\n                int v = students[idx + (j + 1) % len];\n                archenemy_pairs.push_back({min(u, v), max(u, v)});\n            }\n            idx += len;\n        }\n    } else if (type == \"zero_bench\") {\n        // Generate a case where the minimal number of students to bench is zero\n        // Create even-length paths or cycles, ensuring bipartition is possible\n        vector<int> component_lengths;\n        int remaining_students = n;\n\n        while (remaining_students >= 2) {\n            int len = rnd.next(2, min(remaining_students, 10));\n            component_lengths.push_back(len);\n            remaining_students -= len;\n        }\n\n        if (remaining_students > 0) {\n            component_lengths.push_back(remaining_students);\n            remaining_students = 0;\n        }\n\n        int idx = 0;\n        for (int len : component_lengths) {\n            if (rnd.next(0, 1) == 0) {\n                // Generate a path\n                for (int j = 0; j < len - 1; ++j) {\n                    int u = students[idx + j];\n                    int v = students[idx + j + 1];\n                    archenemy_pairs.push_back({min(u, v), max(u, v)});\n                }\n            } else {\n                // Generate an even-length cycle\n                if (len < 2) {\n                    idx += len;\n                    continue;\n                }\n                for (int j = 0; j < len; ++j) {\n                    int u = students[idx + j];\n                    int v = students[idx + (j + 1) % len];\n                    archenemy_pairs.push_back({min(u, v), max(u, v)});\n                }\n            }\n            idx += len;\n        }\n    } else {\n        // Generate random archenemy pairs\n        int max_deg = 2;\n        vector<int> degree(n + 1, 0);\n        set<pair<int, int>> edges;\n        int m = rnd.next(1, min(100, n * (max_deg) / 2));\n\n        while ((int)edges.size() < m) {\n            int u = rnd.next(1, n);\n            int v = rnd.next(1, n);\n            if (u == v) continue;\n            if (degree[u] >= max_deg || degree[v] >= max_deg) continue;\n            if (u > v) swap(u, v);\n            if (edges.count({u, v})) continue;\n            edges.insert({u, v});\n            degree[u]++;\n            degree[v]++;\n        }\n\n        for (auto e : edges) {\n            archenemy_pairs.push_back(e);\n        }\n    }\n\n    // Output n and m\n    int m = archenemy_pairs.size();\n    printf(\"%d %d\\n\", n, m);\n\n    // Output the archenemy pairs\n    for (auto& p : archenemy_pairs) {\n        printf(\"%d %d\\n\", p.first, p.second);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> students(n);\n    for (int i = 0; i < n; ++i) students[i] = i + 1;\n    shuffle(students.begin(), students.end());\n\n    vector<pair<int, int>> archenemy_pairs;\n\n    if (type == \"paths\") {\n        // Generate random paths\n        int num_paths = rnd.next(1, n - 1);\n        vector<int> path_lengths(num_paths, 1);\n        int remaining_students = n - num_paths;\n\n        for (int i = 0; i < remaining_students; ++i) {\n            int idx = rnd.next(0, num_paths - 1);\n            path_lengths[idx]++;\n        }\n\n        int idx = 0;\n        for (int i = 0; i < num_paths; ++i) {\n            int len = path_lengths[i];\n            for (int j = 0; j < len - 1; ++j) {\n                int u = students[idx + j];\n                int v = students[idx + j + 1];\n                archenemy_pairs.push_back({min(u, v), max(u, v)});\n            }\n            idx += len;\n        }\n    } else if (type == \"even_cycles\") {\n        // Generate cycles of even length\n        vector<int> cycle_lengths;\n        int remaining_students = n;\n\n        while (remaining_students >= 2) {\n            int max_len = remaining_students;\n            int len = 2 * rnd.next(1, remaining_students / 2);\n            if (len > remaining_students) len = remaining_students;\n            cycle_lengths.push_back(len);\n            remaining_students -= len;\n        }\n\n        int idx = 0;\n        for (int len : cycle_lengths) {\n            for (int j = 0; j < len; ++j) {\n                int u = students[idx + j];\n                int v = students[idx + (j + 1) % len];\n                archenemy_pairs.push_back({min(u, v), max(u, v)});\n            }\n            idx += len;\n        }\n    } else if (type == \"odd_cycles\") {\n        // Generate cycles of odd length\n        vector<int> cycle_lengths;\n        int remaining_students = n;\n\n        while (remaining_students >= 3) {\n            int max_len = remaining_students;\n            int len = 2 * rnd.next(1, (remaining_students - 1) / 2) + 1;\n            if (len > remaining_students) len = remaining_students;\n            cycle_lengths.push_back(len);\n            remaining_students -= len;\n        }\n\n        if (remaining_students > 0) {\n            // Add remaining students as single-node paths\n            for (int i = 0; i < remaining_students; ++i) {\n                cycle_lengths.push_back(1);\n            }\n            remaining_students = 0;\n        }\n\n        int idx = 0;\n        for (int len : cycle_lengths) {\n            if (len == 1) {\n                // No edges to add\n                idx += 1;\n                continue;\n            }\n            for (int j = 0; j < len; ++j) {\n                int u = students[idx + j];\n                int v = students[idx + (j + 1) % len];\n                archenemy_pairs.push_back({min(u, v), max(u, v)});\n            }\n            idx += len;\n        }\n    } else if (type == \"mixed\") {\n        // Generate a mixture of paths and cycles\n        int remaining_students = n;\n        int idx = 0;\n        while (remaining_students > 0) {\n            int choice = rnd.next(1, 3); // 1: path, 2: even cycle, 3: odd cycle\n            if (remaining_students == 1) choice = 1;\n            if (choice == 1) {\n                // Generate a path\n                int len = rnd.next(1, min(remaining_students, 10));\n                int path_start = idx;\n                for (int j = 0; j < len - 1; ++j) {\n                    int u = students[idx + j];\n                    int v = students[idx + j + 1];\n                    archenemy_pairs.push_back({min(u, v), max(u, v)});\n                }\n                idx += len;\n                remaining_students -= len;\n            } else if (choice == 2 && remaining_students >= 2) {\n                // Generate an even cycle\n                int len = 2 * rnd.next(1, remaining_students / 2);\n                if (len > remaining_students) len = remaining_students;\n                for (int j = 0; j < len; ++j) {\n                    int u = students[idx + j];\n                    int v = students[idx + (j + 1) % len];\n                    archenemy_pairs.push_back({min(u, v), max(u, v)});\n                }\n                idx += len;\n                remaining_students -= len;\n            } else if (choice == 3 && remaining_students >= 3) {\n                // Generate an odd cycle\n                int len = 2 * rnd.next(1, (remaining_students - 1) / 2) + 1;\n                if (len > remaining_students) len = remaining_students;\n                for (int j = 0; j < len; ++j) {\n                    int u = students[idx + j];\n                    int v = students[idx + (j + 1) % len];\n                    archenemy_pairs.push_back({min(u, v), max(u, v)});\n                }\n                idx += len;\n                remaining_students -= len;\n            }\n        }\n    } else if (type == \"max_bench\") {\n        // Generate a case where the minimal number of students to bench is maximal\n        // Create several odd-length cycles to maximize benches required\n        vector<int> cycle_lengths;\n        int remaining_students = n;\n\n        while (remaining_students >= 3) {\n            int len = 3; // Use smallest odd cycle\n            cycle_lengths.push_back(len);\n            remaining_students -= len;\n        }\n\n        if (remaining_students > 0) {\n            // Add remaining students as single-node paths\n            for (int i = 0; i < remaining_students; ++i) {\n                cycle_lengths.push_back(1);\n            }\n            remaining_students = 0;\n        }\n\n        int idx = 0;\n        for (int len : cycle_lengths) {\n            if (len == 1) {\n                idx += 1;\n                continue;\n            }\n            for (int j = 0; j < len; ++j) {\n                int u = students[idx + j];\n                int v = students[idx + (j + 1) % len];\n                archenemy_pairs.push_back({min(u, v), max(u, v)});\n            }\n            idx += len;\n        }\n    } else if (type == \"zero_bench\") {\n        // Generate a case where the minimal number of students to bench is zero\n        // Create even-length paths or cycles, ensuring bipartition is possible\n        vector<int> component_lengths;\n        int remaining_students = n;\n\n        while (remaining_students >= 2) {\n            int len = rnd.next(2, min(remaining_students, 10));\n            component_lengths.push_back(len);\n            remaining_students -= len;\n        }\n\n        if (remaining_students > 0) {\n            component_lengths.push_back(remaining_students);\n            remaining_students = 0;\n        }\n\n        int idx = 0;\n        for (int len : component_lengths) {\n            if (rnd.next(0, 1) == 0) {\n                // Generate a path\n                for (int j = 0; j < len - 1; ++j) {\n                    int u = students[idx + j];\n                    int v = students[idx + j + 1];\n                    archenemy_pairs.push_back({min(u, v), max(u, v)});\n                }\n            } else {\n                // Generate an even-length cycle\n                if (len < 2) {\n                    idx += len;\n                    continue;\n                }\n                for (int j = 0; j < len; ++j) {\n                    int u = students[idx + j];\n                    int v = students[idx + (j + 1) % len];\n                    archenemy_pairs.push_back({min(u, v), max(u, v)});\n                }\n            }\n            idx += len;\n        }\n    } else {\n        // Generate random archenemy pairs\n        int max_deg = 2;\n        vector<int> degree(n + 1, 0);\n        set<pair<int, int>> edges;\n        int m = rnd.next(1, min(100, n * (max_deg) / 2));\n\n        while ((int)edges.size() < m) {\n            int u = rnd.next(1, n);\n            int v = rnd.next(1, n);\n            if (u == v) continue;\n            if (degree[u] >= max_deg || degree[v] >= max_deg) continue;\n            if (u > v) swap(u, v);\n            if (edges.count({u, v})) continue;\n            edges.insert({u, v});\n            degree[u]++;\n            degree[v]++;\n        }\n\n        for (auto e : edges) {\n            archenemy_pairs.push_back(e);\n        }\n    }\n\n    // Output n and m\n    int m = archenemy_pairs.size();\n    printf(\"%d %d\\n\", n, m);\n\n    // Output the archenemy pairs\n    for (auto& p : archenemy_pairs) {\n        printf(\"%d %d\\n\", p.first, p.second);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Small test cases\n./gen -n 2 -type zero_bench\n./gen -n 2 -type paths\n./gen -n 2 -type even_cycles\n./gen -n 3 -type odd_cycles\n./gen -n 4 -type mixed\n\n# Medium test cases\n./gen -n 10 -type zero_bench\n./gen -n 10 -type paths\n./gen -n 10 -type even_cycles\n./gen -n 11 -type odd_cycles\n./gen -n 12 -type mixed\n./gen -n 15 -type max_bench\n\n# Large test cases\n./gen -n 50 -type zero_bench\n./gen -n 50 -type paths\n./gen -n 50 -type even_cycles\n./gen -n 51 -type odd_cycles\n./gen -n 60 -type mixed\n./gen -n 70 -type max_bench\n\n# Boundary test cases\n./gen -n 100 -type zero_bench\n./gen -n 100 -type paths\n./gen -n 100 -type even_cycles\n./gen -n 99 -type odd_cycles\n./gen -n 100 -type mixed\n./gen -n 100 -type max_bench\n\n# Random test cases\n./gen -n 20 -type random\n./gen -n 30 -type random\n./gen -n 40 -type random\n./gen -n 50 -type random\n./gen -n 60 -type random\n./gen -n 70 -type random\n./gen -n 80 -type random\n./gen -n 90 -type random\n./gen -n 100 -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T19:50:02.609805",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "216/C",
      "title": "C. Hiring Staff",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains three integers n, m and k (1 ≤ m ≤ n ≤ 1000, n ≠ 1, 1 ≤ k ≤ 1000).",
      "output_spec": "OutputIn the first line print a single integer z — the minimum required number of employees.In the second line print z positive integers, separated by spaces: the i-th integer ai (1 ≤ ai ≤ 104) should represent the number of the day, on which Vitaly should hire the i-th employee.If there are multiple answers, print any of them.",
      "sample_tests": "ExamplesInputCopy4 3 2OutputCopy41 1 4 5InputCopy3 3 1OutputCopy31 3 5",
      "description": "C. Hiring Staff\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains three integers n, m and k (1 ≤ m ≤ n ≤ 1000, n ≠ 1, 1 ≤ k ≤ 1000).\n\nOutputIn the first line print a single integer z — the minimum required number of employees.In the second line print z positive integers, separated by spaces: the i-th integer ai (1 ≤ ai ≤ 104) should represent the number of the day, on which Vitaly should hire the i-th employee.If there are multiple answers, print any of them.\n\nInputCopy4 3 2OutputCopy41 1 4 5InputCopy3 3 1OutputCopy31 3 5\n\nInputCopy4 3 2\n\nOutputCopy41 1 4 5\n\nInputCopy3 3 1\n\nOutputCopy31 3 5",
      "solutions": [
        {
          "title": "Codeforces Round #133 - Codeforces",
          "content": "Hello everyone.That is the 133th Codeforces round. Specially for the 2nd division. Contestants from the 1st division can solve the round out of competition.Round is prepared by Ripatti , Gerald , Aksenov239 , Delinur and MikeMirzayanov .The round will use dymanic scoring system. Problems will be ordered in random manner (see UPD1). If you want get more happiness from solving that round, please, read statements of all problems.Good luck!UPD1. Jury members discussed and have decided to rearrange problems in expected order of difficulty.UPD2. Contest ended. Winners:1. karensun5222. stostap3. sisterX4. BiliBilisolved all 5 problems. Congratulations!Editorial will be soon tommorow (I am very tired =_=, but now you can try to read russian editorial here).UPD3. Editorial in English.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/5061",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 786
        },
        {
          "title": "Editorial for Codeforces Round #133 - Codeforces",
          "content": "A. For solving this problem you might find some formula likeres = abc - (a - 1)(b - 1)(c - 1), res = ab + bc + ca - a - b - c + 1, or something else.Also the problem can be solved in O(a + b + c) time — you can move from the top line to the bottom line of hexagon and sum number of tiles in every line.Author is Ripatti .B. You can build some graph where vertices are students and edges are enmities. You should drop some vertices and then paint them in two colors. Any edge should connect vertices of distinct colors and numbers of vertices of every color should be same.You can see that graph consists chians, cycles and sepatated vertices. Every of that component can be painted in 2 colors except one case: cycles of odd length. So, you should drop one vertex from every odd cycle. After that you can get odd number of vertices. Then you should drop one more vertex (you can chose any of them). The obtained graph can be easily painted in 2 colors in the required manner.Authors are Gerald , Ripatti .С. The first solution: analysis of the cases1. k = 1. For n ≤ m + 1 3 employees is enough (in most cases). For n > m + 1 answer is 2. Also, there are only one tricky corner case: for n = 2, m = 2, k = 1 answer is 4.2. k > 1. If n = m, answer is 2k + 1, otherwise answer is 2k.For any case it is easy to construct solution, and prove that this solution is optimal.The second solution: greedy.Let's create an array where we will store current number of employees for some number of the first days. Now you should iterate over all days from the first to the n + m-th and hire employees every time when it needed. You should hire workers if there are less than k people in the current day; also you should hire worker if there will be no people tomorrow (thet worker will bring the key to the workers that will work tomorrow).This solution works in O((n + m)k).This solution also works correctly for cases n < m, but then it has bigger complexity and requires more time.Authors are Gerald , Ripatti .D. For every sector you should sort bridges in order of increasing distance from the conter of the web. Now for every sector you should iterate over bridges of the current sector and two adjacent sectors using 3 pointers. During every pass you should carefully calculate number of bad cells. That is all solution.Solition in , where m is total number of bridges.Author is Ripatti .E. Digital root of number is equal to that number modulo k - 1 for most cases. It is lie only for digital roots 0 and k - 1 — in that cases number modulo k - 1 will be 0. But you can get digital root 0 only for numbers like 00...00. Total number of numbers that type you can find using any other way. So, now you can find number of substrings that have some digital root, if you know number of substrings that equals some number modulo k - 1.How to find number of substrings of some modulo? You should iterate over all digits of s from the left to the rigth and for every modulo store number of prefixes of that modulo in some array dp[] of size k. Let's current position is i. Then number of substrings modulo b that ends in position i equals to number of prefixes leftmost position i that have modulo (x - b)mod(k - 1), where x is modulo of s[1... i]. I.e. just dp[(x - b)mod(k - 1)].To fit into memory limit, you should replace array dp[] by some associative array. For example, std::map from С++ or some hashtable.So we have solution in O(nz), where z is complexety of access to dp[] ( for std::map and O(1) for hashtable). Author is Ripatti.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/5066",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 3528
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #133 - Codeforces - Code 1",
          "code": "UPD: cout << (a+c-1)*(b+c-1)-c*(c-1) << endl;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5061",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #133 - Codeforces - Code 2",
          "code": "some tips about problem A\n\na=2 b=3 c=4 total=18\n\n    O O O O   \n   O O O O O\n  O O O O O\n   O O O O\n\na=1 b=4 c=5 total=20 X:2 O:18\n\n    O O O O X\n   O O O O O\n  O O O O O\n X O O O O\n\na=4 b=1 c=6 total=24 X:6 O:18\n\nX X O O O O   \n X O O O O O\n  O O O O O X\n   O O O O X X\n\t   \na=5 b=6 c=1 total=30 X:12 O:18\n\n       X\n      X X\n     X X X\n    O O O O   \n   O O O O O\n  O O O O O\n   O O O O\n    X X X\n     X X\n      X",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5061",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #133 - Codeforces - Code 3",
          "code": "some tips about problem A\n\na=2 b=3 c=4 total=18\n\n    O O O O   \n   O O O O O\n  O O O O O\n   O O O O\n\na=1 b=4 c=5 total=20 X:2 O:18\n\n    O O O O X\n   O O O O O\n  O O O O O\n X O O O O\n\na=4 b=1 c=6 total=24 X:6 O:18\n\nX X O O O O   \n X O O O O O\n  O O O O O X\n   O O O O X X\n\t   \na=5 b=6 c=1 total=30 X:12 O:18\n\n       X\n      X X\n     X X X\n    O O O O   \n   O O O O O\n  O O O O O\n   O O O O\n    X X X\n     X X\n      X",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5061",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #133 - Codeforces - Code 4",
          "code": "6 4\n\n1 2\n\n1 3\n\n4 5\n\n4 6",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5061",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #133 - Codeforces - Code 5",
          "code": "6 4\n\n1 2\n\n1 3\n\n4 5\n\n4 6",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5061",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(2, 1000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, n, \"m\");\n    inf.readSpace();\n    int k = inf.readInt(1, 1000, \"k\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(2, 1000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, n, \"m\");\n    inf.readSpace();\n    int k = inf.readInt(1, 1000, \"k\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(2, 1000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, n, \"m\");\n    inf.readSpace();\n    int k = inf.readInt(1, 1000, \"k\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n\nint main(int argc, char* argv[]) {\n    registerTestlibCmd(argc, argv);\n\n    int n = inf.readInt();\n    int m = inf.readInt();\n    int k = inf.readInt();\n\n    int jury_z = ans.readInt();\n    int participant_z = ouf.readInt();\n\n    if (participant_z > jury_z)\n        quitf(_wa, \"Participant's z is not minimal: participant z = %d, jury z = %d\", participant_z, jury_z);\n    else if (participant_z == jury_z) {\n        for (int i = 0; i < participant_z; ++i) {\n            int ai = ouf.readInt(1, 10000, format(\"ai[%d]\", i + 1).c_str());\n        }\n        quitf(_ok, \"Accepted\");\n    } else {\n        quitf(_fail, \"Participant's z is smaller than jury's z: participant z = %d, jury z = %d\", participant_z, jury_z);\n    }\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\", -1);\n    int m = opt<int>(\"m\", -1);\n    int k = opt<int>(\"k\", -1);\n    string type = opt<string>(\"type\", \"random\");\n\n    // Initialize n, m, k if not specified\n    if (n == -1) n = rnd.next(2, 1000);\n    if (m == -1) m = rnd.next(1, n);\n    if (k == -1) k = rnd.next(1, 1000);\n\n    if (type == \"n_equals_m\") {\n        n = rnd.next(2, 1000);\n        m = n;\n    } else if (type == \"m_equals_1\") {\n        m = 1;\n    } else if (type == \"n_large_m_small\") {\n        n = 1000;\n        m = 1;\n    } else if (type == \"n_small_m_large\") {\n        n = 2;\n        m = 1000;\n    } else if (type == \"n_and_m_max\") {\n        n = 1000;\n        m = 1000;\n    } else if (type == \"k_max\") {\n        k = 1000;\n    } else if (type == \"k_1\") {\n        k = 1;\n    } else if (type == \"max_values\") {\n        n = 1000;\n        m = 1;\n        k = 1000;\n    }\n\n    // Adjust to ensure 1 <= m <= n <= 1000, n != 1, 1 <= k <= 1000, n != 1\n    n = max(2, min(n, 1000));\n    m = max(1, min(m, n));\n    k = max(1, min(k, 1000));\n\n    // Output\n    printf(\"%d %d %d\\n\", n, m, k);\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\", -1);\n    int m = opt<int>(\"m\", -1);\n    int k = opt<int>(\"k\", -1);\n    string type = opt<string>(\"type\", \"random\");\n\n    // Initialize n, m, k if not specified\n    if (n == -1) n = rnd.next(2, 1000);\n    if (m == -1) m = rnd.next(1, n);\n    if (k == -1) k = rnd.next(1, 1000);\n\n    if (type == \"n_equals_m\") {\n        n = rnd.next(2, 1000);\n        m = n;\n    } else if (type == \"m_equals_1\") {\n        m = 1;\n    } else if (type == \"n_large_m_small\") {\n        n = 1000;\n        m = 1;\n    } else if (type == \"n_small_m_large\") {\n        n = 2;\n        m = 1000;\n    } else if (type == \"n_and_m_max\") {\n        n = 1000;\n        m = 1000;\n    } else if (type == \"k_max\") {\n        k = 1000;\n    } else if (type == \"k_1\") {\n        k = 1;\n    } else if (type == \"max_values\") {\n        n = 1000;\n        m = 1;\n        k = 1000;\n    }\n\n    // Adjust to ensure 1 <= m <= n <= 1000, n != 1, 1 <= k <= 1000, n != 1\n    n = max(2, min(n, 1000));\n    m = max(1, min(m, n));\n    k = max(1, min(k, 1000));\n\n    // Output\n    printf(\"%d %d %d\\n\", n, m, k);\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Random test cases\n./gen\n./gen\n./gen\n\n# Test cases with n = m\n./gen -type n_equals_m\n./gen -type n_equals_m\n\n# Test cases with m = 1\n./gen -type m_equals_1\n./gen -type m_equals_1\n\n# Test cases with n large and m small\n./gen -type n_large_m_small\n./gen -type n_large_m_small\n\n# Test cases with n small and m large\n./gen -type n_small_m_large\n./gen -type n_small_m_large\n\n# Test cases with n and m at maximum values\n./gen -type n_and_m_max\n./gen -type n_and_m_max\n\n# Test cases with k = 1000\n./gen -type k_max\n./gen -type k_max\n\n# Test cases with k = 1\n./gen -type k_1\n./gen -type k_1\n\n# Test cases with maximum allowed values\n./gen -type max_values\n./gen -type max_values\n\n# Edge cases with specific n, m, k\n./gen -n 2 -m 1 -k 1000\n./gen -n 999 -m 998 -k 1000\n./gen -n 500 -m 500 -k 500\n./gen -n 1000 -m 1 -k 1\n./gen -n 2 -m 2 -k 1\n\n# Random test cases with large n and m\n./gen -n 1000 -m 999 -k 1000\n./gen -n 1000 -m 1000 -k 999\n\n# Special test cases\n./gen -n 999 -m 1 -k 2\n./gen -n 1000 -m 500 -k 500\n\n# Random small test cases\n./gen -n 10 -m 5 -k 5\n./gen -n 50 -m 25 -k 25\n./gen -n 100 -m 50 -k 50\n\n# Random test cases within smaller ranges\n./gen -n 100 -m 1 -k 50\n./gen -n 50 -m 25 -k 30\n./gen -n 500 -m 250 -k 100\n\n# Additional random test cases\n./gen\n./gen\n./gen\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T19:50:04.751856",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "216/D",
      "title": "D. Spider's Web",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains integer n (3 ≤ n ≤ 1000) — the number of main threads.The i-th of following n lines describe the bridges located in the i-th sector: first it contains integer ki (1 ≤ ki ≤ 105) equal to the number of bridges in the given sector. Then follow ki different integers pij (1 ≤ pij ≤ 105; 1 ≤ j ≤ ki). Number pij equals the distance from the attachment points of the j-th bridge of the i-th sector to the center of the web.It is guaranteed that any two bridges between adjacent sectors are attached at a different distance from the center of the web. It is guaranteed that the total number of the bridges doesn't exceed 105.",
      "output_spec": "OutputPrint a single integer — the number of unstable cells in Paw the Spider's web.",
      "sample_tests": "ExamplesInputCopy73 1 6 74 3 5 2 92 8 14 3 7 6 43 2 5 93 6 3 83 4 2 9OutputCopy6",
      "description": "D. Spider's Web\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains integer n (3 ≤ n ≤ 1000) — the number of main threads.The i-th of following n lines describe the bridges located in the i-th sector: first it contains integer ki (1 ≤ ki ≤ 105) equal to the number of bridges in the given sector. Then follow ki different integers pij (1 ≤ pij ≤ 105; 1 ≤ j ≤ ki). Number pij equals the distance from the attachment points of the j-th bridge of the i-th sector to the center of the web.It is guaranteed that any two bridges between adjacent sectors are attached at a different distance from the center of the web. It is guaranteed that the total number of the bridges doesn't exceed 105.\n\nOutputPrint a single integer — the number of unstable cells in Paw the Spider's web.\n\nInputCopy73 1 6 74 3 5 2 92 8 14 3 7 6 43 2 5 93 6 3 83 4 2 9OutputCopy6\n\nInputCopy73 1 6 74 3 5 2 92 8 14 3 7 6 43 2 5 93 6 3 83 4 2 9\n\nOutputCopy6",
      "solutions": [
        {
          "title": "Codeforces Round #133 - Codeforces",
          "content": "Hello everyone.That is the 133th Codeforces round. Specially for the 2nd division. Contestants from the 1st division can solve the round out of competition.Round is prepared by Ripatti , Gerald , Aksenov239 , Delinur and MikeMirzayanov .The round will use dymanic scoring system. Problems will be ordered in random manner (see UPD1). If you want get more happiness from solving that round, please, read statements of all problems.Good luck!UPD1. Jury members discussed and have decided to rearrange problems in expected order of difficulty.UPD2. Contest ended. Winners:1. karensun5222. stostap3. sisterX4. BiliBilisolved all 5 problems. Congratulations!Editorial will be soon tommorow (I am very tired =_=, but now you can try to read russian editorial here).UPD3. Editorial in English.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/5061",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 786
        },
        {
          "title": "Editorial for Codeforces Round #133 - Codeforces",
          "content": "A. For solving this problem you might find some formula likeres = abc - (a - 1)(b - 1)(c - 1), res = ab + bc + ca - a - b - c + 1, or something else.Also the problem can be solved in O(a + b + c) time — you can move from the top line to the bottom line of hexagon and sum number of tiles in every line.Author is Ripatti .B. You can build some graph where vertices are students and edges are enmities. You should drop some vertices and then paint them in two colors. Any edge should connect vertices of distinct colors and numbers of vertices of every color should be same.You can see that graph consists chians, cycles and sepatated vertices. Every of that component can be painted in 2 colors except one case: cycles of odd length. So, you should drop one vertex from every odd cycle. After that you can get odd number of vertices. Then you should drop one more vertex (you can chose any of them). The obtained graph can be easily painted in 2 colors in the required manner.Authors are Gerald , Ripatti .С. The first solution: analysis of the cases1. k = 1. For n ≤ m + 1 3 employees is enough (in most cases). For n > m + 1 answer is 2. Also, there are only one tricky corner case: for n = 2, m = 2, k = 1 answer is 4.2. k > 1. If n = m, answer is 2k + 1, otherwise answer is 2k.For any case it is easy to construct solution, and prove that this solution is optimal.The second solution: greedy.Let's create an array where we will store current number of employees for some number of the first days. Now you should iterate over all days from the first to the n + m-th and hire employees every time when it needed. You should hire workers if there are less than k people in the current day; also you should hire worker if there will be no people tomorrow (thet worker will bring the key to the workers that will work tomorrow).This solution works in O((n + m)k).This solution also works correctly for cases n < m, but then it has bigger complexity and requires more time.Authors are Gerald , Ripatti .D. For every sector you should sort bridges in order of increasing distance from the conter of the web. Now for every sector you should iterate over bridges of the current sector and two adjacent sectors using 3 pointers. During every pass you should carefully calculate number of bad cells. That is all solution.Solition in , where m is total number of bridges.Author is Ripatti .E. Digital root of number is equal to that number modulo k - 1 for most cases. It is lie only for digital roots 0 and k - 1 — in that cases number modulo k - 1 will be 0. But you can get digital root 0 only for numbers like 00...00. Total number of numbers that type you can find using any other way. So, now you can find number of substrings that have some digital root, if you know number of substrings that equals some number modulo k - 1.How to find number of substrings of some modulo? You should iterate over all digits of s from the left to the rigth and for every modulo store number of prefixes of that modulo in some array dp[] of size k. Let's current position is i. Then number of substrings modulo b that ends in position i equals to number of prefixes leftmost position i that have modulo (x - b)mod(k - 1), where x is modulo of s[1... i]. I.e. just dp[(x - b)mod(k - 1)].To fit into memory limit, you should replace array dp[] by some associative array. For example, std::map from С++ or some hashtable.So we have solution in O(nz), where z is complexety of access to dp[] ( for std::map and O(1) for hashtable). Author is Ripatti.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/5066",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 3528
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #133 - Codeforces - Code 1",
          "code": "UPD: cout << (a+c-1)*(b+c-1)-c*(c-1) << endl;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5061",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #133 - Codeforces - Code 2",
          "code": "some tips about problem A\n\na=2 b=3 c=4 total=18\n\n    O O O O   \n   O O O O O\n  O O O O O\n   O O O O\n\na=1 b=4 c=5 total=20 X:2 O:18\n\n    O O O O X\n   O O O O O\n  O O O O O\n X O O O O\n\na=4 b=1 c=6 total=24 X:6 O:18\n\nX X O O O O   \n X O O O O O\n  O O O O O X\n   O O O O X X\n\t   \na=5 b=6 c=1 total=30 X:12 O:18\n\n       X\n      X X\n     X X X\n    O O O O   \n   O O O O O\n  O O O O O\n   O O O O\n    X X X\n     X X\n      X",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5061",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #133 - Codeforces - Code 3",
          "code": "some tips about problem A\n\na=2 b=3 c=4 total=18\n\n    O O O O   \n   O O O O O\n  O O O O O\n   O O O O\n\na=1 b=4 c=5 total=20 X:2 O:18\n\n    O O O O X\n   O O O O O\n  O O O O O\n X O O O O\n\na=4 b=1 c=6 total=24 X:6 O:18\n\nX X O O O O   \n X O O O O O\n  O O O O O X\n   O O O O X X\n\t   \na=5 b=6 c=1 total=30 X:12 O:18\n\n       X\n      X X\n     X X X\n    O O O O   \n   O O O O O\n  O O O O O\n   O O O O\n    X X X\n     X X\n      X",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5061",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #133 - Codeforces - Code 4",
          "code": "6 4\n\n1 2\n\n1 3\n\n4 5\n\n4 6",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5061",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #133 - Codeforces - Code 5",
          "code": "6 4\n\n1 2\n\n1 3\n\n4 5\n\n4 6",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5061",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(3, 1000, \"n\");\n    inf.readEoln();\n\n    vector<set<int>> sectors(n);\n    int64_t totalBridges = 0;\n\n    for (int i = 0; i < n; ++i) {\n        int ki = inf.readInt(1, 100000, \"ki\");\n        totalBridges += ki;\n        ensuref(totalBridges <= 100000, \"Total number of bridges exceeds 1e5\");\n\n        inf.readSpace();\n\n        vector<int> pij = inf.readInts(ki, 1, 100000, \"pij\");\n        inf.readEoln();\n\n        set<int> pijSet(pij.begin(), pij.end());\n        ensuref(pijSet.size() == pij.size(), \"Duplicate pij in sector %d\", i + 1);\n\n        sectors[i] = pijSet;\n    }\n\n    for (int i = 0; i < n; ++i) {\n        int j = (i + 1) % n;\n        vector<int> intersection;\n        set_intersection(sectors[i].begin(), sectors[i].end(),\n                         sectors[j].begin(), sectors[j].end(),\n                         back_inserter(intersection));\n        ensuref(intersection.empty(), \"Sectors %d and %d have overlapping pij\", i + 1, j + 1);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(3, 1000, \"n\");\n    inf.readEoln();\n\n    vector<set<int>> sectors(n);\n    int64_t totalBridges = 0;\n\n    for (int i = 0; i < n; ++i) {\n        int ki = inf.readInt(1, 100000, \"ki\");\n        totalBridges += ki;\n        ensuref(totalBridges <= 100000, \"Total number of bridges exceeds 1e5\");\n\n        inf.readSpace();\n\n        vector<int> pij = inf.readInts(ki, 1, 100000, \"pij\");\n        inf.readEoln();\n\n        set<int> pijSet(pij.begin(), pij.end());\n        ensuref(pijSet.size() == pij.size(), \"Duplicate pij in sector %d\", i + 1);\n\n        sectors[i] = pijSet;\n    }\n\n    for (int i = 0; i < n; ++i) {\n        int j = (i + 1) % n;\n        vector<int> intersection;\n        set_intersection(sectors[i].begin(), sectors[i].end(),\n                         sectors[j].begin(), sectors[j].end(),\n                         back_inserter(intersection));\n        ensuref(intersection.empty(), \"Sectors %d and %d have overlapping pij\", i + 1, j + 1);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(3, 1000, \"n\");\n    inf.readEoln();\n\n    vector<set<int>> sectors(n);\n    int64_t totalBridges = 0;\n\n    for (int i = 0; i < n; ++i) {\n        int ki = inf.readInt(1, 100000, \"ki\");\n        totalBridges += ki;\n        ensuref(totalBridges <= 100000, \"Total number of bridges exceeds 1e5\");\n\n        inf.readSpace();\n\n        vector<int> pij = inf.readInts(ki, 1, 100000, \"pij\");\n        inf.readEoln();\n\n        set<int> pijSet(pij.begin(), pij.end());\n        ensuref(pijSet.size() == pij.size(), \"Duplicate pij in sector %d\", i + 1);\n\n        sectors[i] = pijSet;\n    }\n\n    for (int i = 0; i < n; ++i) {\n        int j = (i + 1) % n;\n        vector<int> intersection;\n        set_intersection(sectors[i].begin(), sectors[i].end(),\n                         sectors[j].begin(), sectors[j].end(),\n                         back_inserter(intersection));\n        ensuref(intersection.empty(), \"Sectors %d and %d have overlapping pij\", i + 1, j + 1);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int T = opt<int>(\"T\", 0);\n    string type = opt<string>(\"type\", \"random\");\n\n    const int MAX_T = 100000;\n    const int MAX_P = 100000;\n    const int MIN_KI = 1;\n\n    // Ensure T is set properly\n    if (T == 0) {\n        T = MAX_T;\n    }\n    T = min(T, MAX_T);\n\n    // Ensure that T >= n * MIN_KI\n    if (T < n * MIN_KI) {\n        fprintf(stderr, \"Total number of bridges T is too small for the number of sectors n.\\n\");\n        return 1;\n    }\n\n    vector<int> ki(n);\n    if (type == \"equal\") {\n        int base = T / n;\n        int rem = T % n;\n        for (int i = 0; i < n; ++i) {\n            ki[i] = base;\n            if (i < rem) {\n                ki[i]++;\n            }\n        }\n    } else if (type == \"increasing\") {\n        int total = 0;\n        for (int i = 0; i < n; ++i) {\n            ki[i] = i + 1;\n            total += ki[i];\n        }\n        // Adjust to fit T\n        if (total > T) {\n            int diff = total - T;\n            for (int i = n - 1; i >= 0 && diff > 0; --i) {\n                int reduce = min(diff, ki[i] - MIN_KI);\n                ki[i] -= reduce;\n                diff -= reduce;\n            }\n        } else if (total < T) {\n            int diff = T - total;\n            for (int i = 0; i < n && diff > 0; ++i) {\n                int increase = diff;\n                ki[i] += increase;\n                diff -= increase;\n            }\n        }\n    } else if (type == \"decreasing\") {\n        int total = 0;\n        for (int i = 0; i < n; ++i) {\n            ki[i] = n - i;\n            total += ki[i];\n        }\n        // Adjust to fit T\n        if (total > T) {\n            int diff = total - T;\n            for (int i = n - 1; i >= 0 && diff > 0; --i) {\n                int reduce = min(diff, ki[i] - MIN_KI);\n                ki[i] -= reduce;\n                diff -= reduce;\n            }\n        } else if (total < T) {\n            int diff = T - total;\n            for (int i = 0; i < n && diff > 0; ++i) {\n                int increase = diff;\n                ki[i] += increase;\n                diff -= increase;\n            }\n        }\n    } else if (type == \"maximal\") {\n        // Set all ki to their maximum possible values (up to MAX_P)\n        int remaining = T - n * MIN_KI;\n        for (int i = 0; i < n; ++i) {\n            ki[i] = MIN_KI;\n        }\n        for (int i = 0; i < n && remaining > 0; ++i) {\n            int add = min(remaining, MAX_P - ki[i]);\n            ki[i] += add;\n            remaining -= add;\n        }\n    } else if (type == \"unbalanced\") {\n        // Some sectors have ki = 1, some have ki as big as possible\n        int remaining = T - n * MIN_KI;\n        for (int i = 0; i < n; ++i) {\n            ki[i] = MIN_KI;\n        }\n        if (remaining > 0) {\n            ki[0] += remaining;\n        }\n    } else { // random\n        // Generate random ki >= 1, sum to T\n        int total_stars = T - n;\n        vector<int> positions;\n        positions.push_back(0);\n        positions.push_back(total_stars);\n        for (int i = 0; i < n - 1; ++i) {\n            positions.push_back(rnd.next(0, total_stars));\n        }\n        sort(positions.begin(), positions.end());\n        for (int i = 0; i < n; ++i) {\n            ki[i] = positions[i + 1] - positions[i] + 1;\n        }\n    }\n\n    // Generate distances\n    int curr_distance = 0;\n    vector<vector<int>> distances(n);\n    for (int i = 0; i < n; ++i) {\n        distances[i].resize(ki[i]);\n        for (int j = 0; j < ki[i]; ++j) {\n            curr_distance++;\n            distances[i][j] = curr_distance;\n        }\n    }\n\n    // Total number of bridges should not exceed MAX_T\n    if (curr_distance > MAX_T) {\n        fprintf(stderr, \"Total number of bridges exceeds MAX_T.\\n\");\n        return 1;\n    }\n\n    // Shuffle distances within each sector if desired\n    // For variety, you can shuffle or reverse the distances\n    /* Example:\n    for (int i = 0; i < n; ++i) {\n        shuffle(distances[i].begin(), distances[i].end());\n    }\n    */\n    // For this generator, we won't shuffle them.\n\n    // Output\n    printf(\"%d\\n\", n);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d\", ki[i]);\n        for (int j = 0; j < ki[i]; ++j) {\n            printf(\" %d\", distances[i][j]);\n        }\n        printf(\"\\n\");\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int T = opt<int>(\"T\", 0);\n    string type = opt<string>(\"type\", \"random\");\n\n    const int MAX_T = 100000;\n    const int MAX_P = 100000;\n    const int MIN_KI = 1;\n\n    // Ensure T is set properly\n    if (T == 0) {\n        T = MAX_T;\n    }\n    T = min(T, MAX_T);\n\n    // Ensure that T >= n * MIN_KI\n    if (T < n * MIN_KI) {\n        fprintf(stderr, \"Total number of bridges T is too small for the number of sectors n.\\n\");\n        return 1;\n    }\n\n    vector<int> ki(n);\n    if (type == \"equal\") {\n        int base = T / n;\n        int rem = T % n;\n        for (int i = 0; i < n; ++i) {\n            ki[i] = base;\n            if (i < rem) {\n                ki[i]++;\n            }\n        }\n    } else if (type == \"increasing\") {\n        int total = 0;\n        for (int i = 0; i < n; ++i) {\n            ki[i] = i + 1;\n            total += ki[i];\n        }\n        // Adjust to fit T\n        if (total > T) {\n            int diff = total - T;\n            for (int i = n - 1; i >= 0 && diff > 0; --i) {\n                int reduce = min(diff, ki[i] - MIN_KI);\n                ki[i] -= reduce;\n                diff -= reduce;\n            }\n        } else if (total < T) {\n            int diff = T - total;\n            for (int i = 0; i < n && diff > 0; ++i) {\n                int increase = diff;\n                ki[i] += increase;\n                diff -= increase;\n            }\n        }\n    } else if (type == \"decreasing\") {\n        int total = 0;\n        for (int i = 0; i < n; ++i) {\n            ki[i] = n - i;\n            total += ki[i];\n        }\n        // Adjust to fit T\n        if (total > T) {\n            int diff = total - T;\n            for (int i = n - 1; i >= 0 && diff > 0; --i) {\n                int reduce = min(diff, ki[i] - MIN_KI);\n                ki[i] -= reduce;\n                diff -= reduce;\n            }\n        } else if (total < T) {\n            int diff = T - total;\n            for (int i = 0; i < n && diff > 0; ++i) {\n                int increase = diff;\n                ki[i] += increase;\n                diff -= increase;\n            }\n        }\n    } else if (type == \"maximal\") {\n        // Set all ki to their maximum possible values (up to MAX_P)\n        int remaining = T - n * MIN_KI;\n        for (int i = 0; i < n; ++i) {\n            ki[i] = MIN_KI;\n        }\n        for (int i = 0; i < n && remaining > 0; ++i) {\n            int add = min(remaining, MAX_P - ki[i]);\n            ki[i] += add;\n            remaining -= add;\n        }\n    } else if (type == \"unbalanced\") {\n        // Some sectors have ki = 1, some have ki as big as possible\n        int remaining = T - n * MIN_KI;\n        for (int i = 0; i < n; ++i) {\n            ki[i] = MIN_KI;\n        }\n        if (remaining > 0) {\n            ki[0] += remaining;\n        }\n    } else { // random\n        // Generate random ki >= 1, sum to T\n        int total_stars = T - n;\n        vector<int> positions;\n        positions.push_back(0);\n        positions.push_back(total_stars);\n        for (int i = 0; i < n - 1; ++i) {\n            positions.push_back(rnd.next(0, total_stars));\n        }\n        sort(positions.begin(), positions.end());\n        for (int i = 0; i < n; ++i) {\n            ki[i] = positions[i + 1] - positions[i] + 1;\n        }\n    }\n\n    // Generate distances\n    int curr_distance = 0;\n    vector<vector<int>> distances(n);\n    for (int i = 0; i < n; ++i) {\n        distances[i].resize(ki[i]);\n        for (int j = 0; j < ki[i]; ++j) {\n            curr_distance++;\n            distances[i][j] = curr_distance;\n        }\n    }\n\n    // Total number of bridges should not exceed MAX_T\n    if (curr_distance > MAX_T) {\n        fprintf(stderr, \"Total number of bridges exceeds MAX_T.\\n\");\n        return 1;\n    }\n\n    // Shuffle distances within each sector if desired\n    // For variety, you can shuffle or reverse the distances\n    /* Example:\n    for (int i = 0; i < n; ++i) {\n        shuffle(distances[i].begin(), distances[i].end());\n    }\n    */\n    // For this generator, we won't shuffle them.\n\n    // Output\n    printf(\"%d\\n\", n);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d\", ki[i]);\n        for (int j = 0; j < ki[i]; ++j) {\n            printf(\" %d\", distances[i][j]);\n        }\n        printf(\"\\n\");\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 3 -T 3 -type minimal\n./gen -n 3 -T 10 -type random\n./gen -n 3 -T 10 -type increasing\n./gen -n 3 -T 10 -type decreasing\n\n./gen -n 10 -T 100 -type random\n./gen -n 10 -T 100 -type increasing\n./gen -n 10 -T 100 -type decreasing\n./gen -n 10 -T 100 -type maximal\n./gen -n 10 -T 100 -type unbalanced\n\n./gen -n 100 -T 1000 -type random\n./gen -n 100 -T 1000 -type increasing\n./gen -n 100 -T 1000 -type decreasing\n./gen -n 100 -T 1000 -type maximal\n./gen -n 100 -T 1000 -type unbalanced\n\n./gen -n 500 -T 50000 -type random\n./gen -n 500 -T 50000 -type increasing\n./gen -n 500 -T 50000 -type decreasing\n./gen -n 500 -T 50000 -type maximal\n./gen -n 500 -T 50000 -type unbalanced\n\n./gen -n 1000 -T 100000 -type random\n./gen -n 1000 -T 100000 -type increasing\n./gen -n 1000 -T 100000 -type decreasing\n./gen -n 1000 -T 100000 -type maximal\n./gen -n 1000 -T 100000 -type unbalanced\n\n# Edge cases\n./gen -n 3 -T 100000 -type random\n./gen -n 1000 -T 1000 -type random\n./gen -n 999 -T 99999 -type random\n./gen -n 500 -T 1e5 -type random\n\n# Small test cases\n./gen -n 5 -T 5 -type minimal\n./gen -n 5 -T 6 -type random\n./gen -n 5 -T 15 -type increasing\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T19:50:06.815545",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "216/E",
      "title": "E. Martian Luck",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains three integers k, b and n (2 ≤ k ≤ 109, 0 ≤ b < k, 1 ≤ n ≤ 105).The second line contains string s as a sequence of n integers, representing digits in the k-base notation: the i-th integer equals ai (0 ≤ ai < k) — the i-th digit of string s. The numbers in the lines are space-separated.",
      "output_spec": "OutputPrint a single integer — the number of substrings that are lucky numbers.Please, do not use the %lld specifier to read or write 64-bit integers in С++. It is preferred to use the cin, cout streams or the %I64d specifier.",
      "sample_tests": "ExamplesInputCopy10 5 63 2 0 5 6 1OutputCopy5InputCopy7 6 43 5 0 4OutputCopy1InputCopy257 0 30 0 256OutputCopy3",
      "description": "E. Martian Luck\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains three integers k, b and n (2 ≤ k ≤ 109, 0 ≤ b < k, 1 ≤ n ≤ 105).The second line contains string s as a sequence of n integers, representing digits in the k-base notation: the i-th integer equals ai (0 ≤ ai < k) — the i-th digit of string s. The numbers in the lines are space-separated.\n\nOutputPrint a single integer — the number of substrings that are lucky numbers.Please, do not use the %lld specifier to read or write 64-bit integers in С++. It is preferred to use the cin, cout streams or the %I64d specifier.\n\nInputCopy10 5 63 2 0 5 6 1OutputCopy5InputCopy7 6 43 5 0 4OutputCopy1InputCopy257 0 30 0 256OutputCopy3\n\nInputCopy10 5 63 2 0 5 6 1\n\nOutputCopy5\n\nInputCopy7 6 43 5 0 4\n\nOutputCopy1\n\nInputCopy257 0 30 0 256\n\nOutputCopy3\n\nNoteIn the first sample the following substrings have the sought digital root: s[1... 2] = \"3 2\", s[1... 3] = \"3 2 0\", s[3... 4] = \"0 5\", s[4... 4] = \"5\" and s[2... 6] = \"2 0 5 6 1\".",
      "solutions": [
        {
          "title": "Codeforces Round #133 - Codeforces",
          "content": "Hello everyone.That is the 133th Codeforces round. Specially for the 2nd division. Contestants from the 1st division can solve the round out of competition.Round is prepared by Ripatti , Gerald , Aksenov239 , Delinur and MikeMirzayanov .The round will use dymanic scoring system. Problems will be ordered in random manner (see UPD1). If you want get more happiness from solving that round, please, read statements of all problems.Good luck!UPD1. Jury members discussed and have decided to rearrange problems in expected order of difficulty.UPD2. Contest ended. Winners:1. karensun5222. stostap3. sisterX4. BiliBilisolved all 5 problems. Congratulations!Editorial will be soon tommorow (I am very tired =_=, but now you can try to read russian editorial here).UPD3. Editorial in English.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/5061",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 786
        },
        {
          "title": "Editorial for Codeforces Round #133 - Codeforces",
          "content": "A. For solving this problem you might find some formula likeres = abc - (a - 1)(b - 1)(c - 1), res = ab + bc + ca - a - b - c + 1, or something else.Also the problem can be solved in O(a + b + c) time — you can move from the top line to the bottom line of hexagon and sum number of tiles in every line.Author is Ripatti .B. You can build some graph where vertices are students and edges are enmities. You should drop some vertices and then paint them in two colors. Any edge should connect vertices of distinct colors and numbers of vertices of every color should be same.You can see that graph consists chians, cycles and sepatated vertices. Every of that component can be painted in 2 colors except one case: cycles of odd length. So, you should drop one vertex from every odd cycle. After that you can get odd number of vertices. Then you should drop one more vertex (you can chose any of them). The obtained graph can be easily painted in 2 colors in the required manner.Authors are Gerald , Ripatti .С. The first solution: analysis of the cases1. k = 1. For n ≤ m + 1 3 employees is enough (in most cases). For n > m + 1 answer is 2. Also, there are only one tricky corner case: for n = 2, m = 2, k = 1 answer is 4.2. k > 1. If n = m, answer is 2k + 1, otherwise answer is 2k.For any case it is easy to construct solution, and prove that this solution is optimal.The second solution: greedy.Let's create an array where we will store current number of employees for some number of the first days. Now you should iterate over all days from the first to the n + m-th and hire employees every time when it needed. You should hire workers if there are less than k people in the current day; also you should hire worker if there will be no people tomorrow (thet worker will bring the key to the workers that will work tomorrow).This solution works in O((n + m)k).This solution also works correctly for cases n < m, but then it has bigger complexity and requires more time.Authors are Gerald , Ripatti .D. For every sector you should sort bridges in order of increasing distance from the conter of the web. Now for every sector you should iterate over bridges of the current sector and two adjacent sectors using 3 pointers. During every pass you should carefully calculate number of bad cells. That is all solution.Solition in , where m is total number of bridges.Author is Ripatti .E. Digital root of number is equal to that number modulo k - 1 for most cases. It is lie only for digital roots 0 and k - 1 — in that cases number modulo k - 1 will be 0. But you can get digital root 0 only for numbers like 00...00. Total number of numbers that type you can find using any other way. So, now you can find number of substrings that have some digital root, if you know number of substrings that equals some number modulo k - 1.How to find number of substrings of some modulo? You should iterate over all digits of s from the left to the rigth and for every modulo store number of prefixes of that modulo in some array dp[] of size k. Let's current position is i. Then number of substrings modulo b that ends in position i equals to number of prefixes leftmost position i that have modulo (x - b)mod(k - 1), where x is modulo of s[1... i]. I.e. just dp[(x - b)mod(k - 1)].To fit into memory limit, you should replace array dp[] by some associative array. For example, std::map from С++ or some hashtable.So we have solution in O(nz), where z is complexety of access to dp[] ( for std::map and O(1) for hashtable). Author is Ripatti.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/5066",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 3528
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #133 - Codeforces - Code 1",
          "code": "UPD: cout << (a+c-1)*(b+c-1)-c*(c-1) << endl;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5061",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #133 - Codeforces - Code 2",
          "code": "some tips about problem A\n\na=2 b=3 c=4 total=18\n\n    O O O O   \n   O O O O O\n  O O O O O\n   O O O O\n\na=1 b=4 c=5 total=20 X:2 O:18\n\n    O O O O X\n   O O O O O\n  O O O O O\n X O O O O\n\na=4 b=1 c=6 total=24 X:6 O:18\n\nX X O O O O   \n X O O O O O\n  O O O O O X\n   O O O O X X\n\t   \na=5 b=6 c=1 total=30 X:12 O:18\n\n       X\n      X X\n     X X X\n    O O O O   \n   O O O O O\n  O O O O O\n   O O O O\n    X X X\n     X X\n      X",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5061",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #133 - Codeforces - Code 3",
          "code": "some tips about problem A\n\na=2 b=3 c=4 total=18\n\n    O O O O   \n   O O O O O\n  O O O O O\n   O O O O\n\na=1 b=4 c=5 total=20 X:2 O:18\n\n    O O O O X\n   O O O O O\n  O O O O O\n X O O O O\n\na=4 b=1 c=6 total=24 X:6 O:18\n\nX X O O O O   \n X O O O O O\n  O O O O O X\n   O O O O X X\n\t   \na=5 b=6 c=1 total=30 X:12 O:18\n\n       X\n      X X\n     X X X\n    O O O O   \n   O O O O O\n  O O O O O\n   O O O O\n    X X X\n     X X\n      X",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5061",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #133 - Codeforces - Code 4",
          "code": "6 4\n\n1 2\n\n1 3\n\n4 5\n\n4 6",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5061",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #133 - Codeforces - Code 5",
          "code": "6 4\n\n1 2\n\n1 3\n\n4 5\n\n4 6",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5061",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int k = inf.readInt(2, 1000000000, \"k\");\n    inf.readSpace();\n    int b = inf.readInt(0, k - 1, \"b\");\n    inf.readSpace();\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n    vector<int> a = inf.readInts(n, 0, k - 1);\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int k = inf.readInt(2, 1000000000, \"k\");\n    inf.readSpace();\n    int b = inf.readInt(0, k - 1, \"b\");\n    inf.readSpace();\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n    vector<int> a = inf.readInts(n, 0, k - 1);\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int k = inf.readInt(2, 1000000000, \"k\");\n    inf.readSpace();\n    int b = inf.readInt(0, k - 1, \"b\");\n    inf.readSpace();\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n    vector<int> a = inf.readInts(n, 0, k - 1);\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    long long k = opt<long long>(\"k\");\n    int b = opt<int>(\"b\");\n    string type = opt<string>(\"type\", \"random\");\n\n    // Validate input parameters\n    ensure(2 <= k && k <= (long long)1e9);\n    ensure(0 <= b && b < k);\n    ensure(1 <= n && n <= 100000);\n\n    vector<int> s(n);\n\n    if (type == \"all_b\") {\n        for(int i = 0; i < n; ++i) s[i] = b;\n    } else if (type == \"no_b\") {\n        for(int i = 0; i < n; ++i) {\n            int digit;\n            do {\n                digit = rnd.next(0, (int)k - 1);\n            } while (digit == b);\n            s[i] = digit;\n        }\n    } else if (type == \"zeros\") {\n        for(int i = 0; i < n; ++i) s[i] = 0;\n    } else if (type == \"max_digits\") {\n        for(int i = 0; i < n; ++i) s[i] = (int)k - 1;\n    } else if (type == \"alternating_b\") {\n        for(int i = 0; i < n; ++i) {\n            if (i % 2 == 0) {\n                s[i] = b;\n            } else {\n                int digit = rnd.next(0, (int)k - 1);\n                if (digit == b) digit = (digit + 1) % k;\n                s[i] = digit;\n            }\n        }\n    } else if (type == \"random\") {\n        for(int i = 0; i < n; ++i) s[i] = rnd.next(0, (int)k - 1);\n    } else {\n        // Default to random if type is unrecognized\n        for(int i = 0; i < n; ++i) s[i] = rnd.next(0, (int)k - 1);\n    }\n\n    // Output\n    printf(\"%lld %d %d\\n\", k, b, n);\n    for(int i = 0; i < n; ++i) {\n        printf(\"%d%c\", s[i], (i == n - 1) ? '\\n' : ' ');\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    long long k = opt<long long>(\"k\");\n    int b = opt<int>(\"b\");\n    string type = opt<string>(\"type\", \"random\");\n\n    // Validate input parameters\n    ensure(2 <= k && k <= (long long)1e9);\n    ensure(0 <= b && b < k);\n    ensure(1 <= n && n <= 100000);\n\n    vector<int> s(n);\n\n    if (type == \"all_b\") {\n        for(int i = 0; i < n; ++i) s[i] = b;\n    } else if (type == \"no_b\") {\n        for(int i = 0; i < n; ++i) {\n            int digit;\n            do {\n                digit = rnd.next(0, (int)k - 1);\n            } while (digit == b);\n            s[i] = digit;\n        }\n    } else if (type == \"zeros\") {\n        for(int i = 0; i < n; ++i) s[i] = 0;\n    } else if (type == \"max_digits\") {\n        for(int i = 0; i < n; ++i) s[i] = (int)k - 1;\n    } else if (type == \"alternating_b\") {\n        for(int i = 0; i < n; ++i) {\n            if (i % 2 == 0) {\n                s[i] = b;\n            } else {\n                int digit = rnd.next(0, (int)k - 1);\n                if (digit == b) digit = (digit + 1) % k;\n                s[i] = digit;\n            }\n        }\n    } else if (type == \"random\") {\n        for(int i = 0; i < n; ++i) s[i] = rnd.next(0, (int)k - 1);\n    } else {\n        // Default to random if type is unrecognized\n        for(int i = 0; i < n; ++i) s[i] = rnd.next(0, (int)k - 1);\n    }\n\n    // Output\n    printf(\"%lld %d %d\\n\", k, b, n);\n    for(int i = 0; i < n; ++i) {\n        printf(\"%d%c\", s[i], (i == n - 1) ? '\\n' : ' ');\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Small n, small k\n./gen -n 1 -k 2 -b 0 -type zeros\n./gen -n 1 -k 2 -b 1 -type max_digits\n./gen -n 10 -k 2 -b 1 -type random\n./gen -n 10 -k 10 -b 5 -type random\n\n# Max n, small k\n./gen -n 100000 -k 2 -b 1 -type random\n./gen -n 100000 -k 10 -b 5 -type random\n\n# Medium n, medium k\n./gen -n 50000 -k 1000 -b 0 -type zeros\n./gen -n 50000 -k 1000 -b 999 -type max_digits\n./gen -n 50000 -k 1000 -b 100 -type random\n\n# Max n, max k\n./gen -n 100000 -k 1000000000 -b 0 -type zeros\n./gen -n 100000 -k 1000000000 -b 999999999 -type max_digits\n./gen -n 100000 -k 1000000000 -b 123456789 -type random\n\n# Edge cases for b\n./gen -n 100000 -k 1000000000 -b 0 -type all_b\n./gen -n 100000 -k 1000000000 -b 999999999 -type all_b\n\n# Alternative types\n./gen -n 100000 -k 50 -b 25 -type alternating_b\n./gen -n 100000 -k 1000000000 -b 100000000 -type alternating_b\n\n# Leading zeros\n./gen -n 100000 -k 1000000000 -b 0 -type zeros\n\n# No b digit appears\n./gen -n 100000 -k 1000000 -b 123456 -type no_b\n\n# All digits are b\n./gen -n 100000 -k 1000 -b 999 -type all_b\n\n# Random digits\n./gen -n 100000 -k 1000000000 -b 0 -type random\n./gen -n 100000 -k 1000000000 -b 999999999 -type random\n\n# Mixed types\n./gen -n 100000 -k 2 -b 0 -type random\n./gen -n 100000 -k 2 -b 1 -type random\n./gen -n 100000 -k 3 -b 2 -type random\n./gen -n 100000 -k 4 -b 1 -type random\n./gen -n 100000 -k 1000000000 -b 0 -type random\n./gen -n 100000 -k 1000000000 -b 0 -type zeros\n./gen -n 100000 -k 1000000000 -b 999999999 -type max_digits\n./gen -n 100000 -k 1000000000 -b 500000000 -type random\n./gen -n 100000 -k 1000000000 -b 1 -type random\n\n# Some patterns\n./gen -n 100000 -k 10 -b 5 -type alternating_b\n./gen -n 100000 -k 7 -b 3 -type no_b\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T19:50:09.056530",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "217/A",
      "title": "A. Ice Skating",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line of input contains a single integer n (1 ≤ n ≤ 100) — the number of snow drifts. Each of the following n lines contains two integers xi and yi (1 ≤ xi, yi ≤ 1000) — the coordinates of the i-th snow drift.Note that the north direction coinсides with the direction of Oy axis, so the east direction coinсides with the direction of the Ox axis. All snow drift's locations are distinct.",
      "output_spec": "OutputOutput the minimal number of snow drifts that need to be created in order for Bajtek to be able to reach any snow drift from any other one.",
      "sample_tests": "ExamplesInputCopy22 11 2OutputCopy1InputCopy22 14 1OutputCopy0",
      "description": "A. Ice Skating\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line of input contains a single integer n (1 ≤ n ≤ 100) — the number of snow drifts. Each of the following n lines contains two integers xi and yi (1 ≤ xi, yi ≤ 1000) — the coordinates of the i-th snow drift.Note that the north direction coinсides with the direction of Oy axis, so the east direction coinсides with the direction of the Ox axis. All snow drift's locations are distinct.\n\nOutputOutput the minimal number of snow drifts that need to be created in order for Bajtek to be able to reach any snow drift from any other one.\n\nInputCopy22 11 2OutputCopy1InputCopy22 14 1OutputCopy0\n\nInputCopy22 11 2\n\nOutputCopy1\n\nInputCopy22 14 1\n\nOutputCopy0",
      "solutions": [
        {
          "title": "Codeforces Round #134 - Codeforces",
          "content": "Welcome to Codeforces Round #134!After over two years, it is again my great pleasure to be the main problemsetter of a contest on Codeforces. Thanks a lot to Gerald for helping me organize the round. I hope you will enjoy solving the problems as much as we enjoyed preparing them for you.Dynamic scoring will be used, but the problems will be ordered by their expected difficulty, from easiest to hardest. Are our predictions correct? I am eager to see. :-)Good luck!Update: The contest is over! Here are the results:First division: rng_58 panyuchaopieguy tourist Petr ACRush Zhukov_Dmitry All contestants from the top seven solved three problems. Note that there was a tie for second place. :-)Second division dsbuaa hqztrue Gullesnuffs In second division, seventeen contestants solved four problems. Nobody managed to crack E; it was also present in the first division as problem C, and proved tricky even for the experienced competitors.Congratulations to the winners!",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/5083",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 971
        },
        {
          "title": "Editorial for Codeforces Round #134 - Codeforces",
          "content": "A. Ice SkatingNotice that the existence of a snow drift at the point (x, y) implies that \"if I'm on the horizontal line at y then I am certainly able to get to the vertical line at x, and vice versa\". Thus, the snow drifts are the edges of a bipartite graph between x- and y- coordinates. The number of snow drifts that need to be added to make this (as well as the original) graph connected is the number of its connected components reduced by one.B. Blackboard FibonacciIf you look at the described process backwards, it resembles the Euclidean algorithm a lot. Indeed, if you rewinded a recording of Bajtek's actions, he always takes the larger out of two numbers (say Unable to parse markup [type=CF_TEX]) and replaces them by a - b, b. Since we know one of the final numbers (r) we can simply check all numbers between 1 and r and run a faster version of Euclid's algorithm (one that replaces a, b by ) for all possibilities for a total runtime of . This was one of the expected solutions.However, with some insight, it can be seen that this optimization is in fact not neccessary — we can simply simulate the reverse process as described (replacing a, b by a - b, b) for all candidates between 1 and r and the total runtime of our algorithm will remain . The proof of this fact is left to the reader.C. FormurosaOne of the major difficulties in this problem is finding an easily formulated condition for when Formurosa can be used to distinguish the bacteria. Let Formurosa's digestive process be a function F(s) that maps binary sequences of length m to elements of {0, 1}. It turns out that the condition we seek for can be stated as follows:We can distinguish all the bacteria if and only if there exists a sequence s of length m for which F(s) ≠ F( - s), where  - s is the negation of s.First, not that if no such sequence exists, then there is no way to distinguish between zero and one. If such a sequence exists, we can pick any two bacteria a and b and try both ways to substitute them for 0 and 1 in the expression. If the two expressions evaluate to different values, we will determine the exact types of both bacteria. Otherwise, we will be certain that the bacteria are of the same type. Repeating the process for all pairs of bacteria will let us identify all the types (since it is guaranteed that not all bacteria are of the same type).To determine whether such a sequence s exists, dynamic programming over the expression tree of Formurosa can be applied. The model solution keeps track for each subtree G of the expression which of the following sequences can be found: a sequence s such that G(s) = G( - s) = 0 a sequence s such that G(s) = G( - s) = 1 a sequence s such that G(s) ≠ G( - s) D. Bitonix' PatrolObservation 1.Fuel tanks for which capacity gives the same remainder are equivalent for Bitonix's purposes. Moreover, fuel tanks for which the capacities' remainders sum to D are also equivalent. Out of every group of equivalent tanks, the agency can only leave at most one.Observation 2.If more than six tanks remain, Bitonix can certainly complete his patrol. Indeed, let us assume that 7 tanks were left undestroyed by the agency. Out of the 128 possible subsets of those tanks, at least two distinct ones, say A and B, sum up to the same remainders modulo D. Thus, if Bitonix moves forward with tanks from A - B and backwards with tanks from B - A, he will finish at some station after an actual journey.Because of observations 1 and 2, it turns out that a simple recursive search suffices to solve the problem. However, because of the large constraints, it may prove necessary to use some optimizations, such as using bitmasks for keeping track of what distances Bitonix can cover.E. Alien DNANote that it is easy to determine, looking at only the last mutation, how many letters it adds to the final result. Indeed, if we need to print out the first k letters of the sequence, and the last mutation is [l, r], it suffices to find out the length of the overlap of segments [1, k] and [r + 1, 2r - l + 1]. Say that it is x. Then, after the next to last mutation, we are only interested in the first k - x letters of the result — the rest is irrelevant, as it will become \"pushed out\" by the elements added in the last mutation. Repeating this reasoning going backwards, we shall find out that we can spend linear time adding letters to the result after every mutation, which turns out to be the main idea needed to solve the problem.For a neat O(n2 + k) implementation of this idea you can check out ACRush's solution: 2029369.The only other contestant to solve the problem during the competition, panyuchao, used a slightly different approach, based in part on the same idea. Check out his ingenious, astonishingly short solution here: 2028007.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/5285",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 4782
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #134 - Codeforces - Code 1",
          "code": "Explain, please, D div 2) more than an hour spent on it (",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5083",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #134 - Codeforces - Code 2",
          "code": "eg.\n6 10\nsolve\n10 test 1 to 9\nwhen test 8 must be below:\n10 8\n2 8\n2 6\n2 4\n2 2\nassert not this.\nwhen test 7 must be below:\n10 7\n3 7\n3 4\n3 1\n2 1\n1 1\nhere have two possible, choice best one",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5083",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #134 - Codeforces - Code 3",
          "code": "eg.\n6 10\nsolve\n10 test 1 to 9\nwhen test 8 must be below:\n10 8\n2 8\n2 6\n2 4\n2 2\nassert not this.\nwhen test 7 must be below:\n10 7\n3 7\n3 4\n3 1\n2 1\n1 1\nhere have two possible, choice best one",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5083",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #134 - Codeforces - Code 4",
          "code": "999997 999997",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5083",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #134 - Codeforces - Code 5",
          "code": "www.Ideone.com",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5083",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #134 - Codeforces - Code 6",
          "code": "#pragma comment(linker, “/STACK: 268435456”)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5083",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readEoln();\n\n    set<pair<int, int>> snow_drifts;\n\n    for (int i = 0; i < n; i++) {\n        int x = inf.readInt(1, 1000, \"xi\");\n        inf.readSpace();\n        int y = inf.readInt(1, 1000, \"yi\");\n        inf.readEoln();\n\n        ensuref(snow_drifts.insert({x, y}).second, \"Snow drift at position (%d, %d) is duplicated\", x, y);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readEoln();\n\n    set<pair<int, int>> snow_drifts;\n\n    for (int i = 0; i < n; i++) {\n        int x = inf.readInt(1, 1000, \"xi\");\n        inf.readSpace();\n        int y = inf.readInt(1, 1000, \"yi\");\n        inf.readEoln();\n\n        ensuref(snow_drifts.insert({x, y}).second, \"Snow drift at position (%d, %d) is duplicated\", x, y);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readEoln();\n\n    set<pair<int, int>> snow_drifts;\n\n    for (int i = 0; i < n; i++) {\n        int x = inf.readInt(1, 1000, \"xi\");\n        inf.readSpace();\n        int y = inf.readInt(1, 1000, \"yi\");\n        inf.readEoln();\n\n        ensuref(snow_drifts.insert({x, y}).second, \"Snow drift at position (%d, %d) is duplicated\", x, y);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    if (type == \"random\") {\n        set<pair<int,int>> positions;\n        while ((int)positions.size() < n) {\n            int x = rnd.next(1, 1000);\n            int y = rnd.next(1, 1000);\n            positions.insert({x, y});\n        }\n\n        // Output n\n        printf(\"%d\\n\", n);\n        // Output positions\n        for (auto p : positions) {\n            printf(\"%d %d\\n\", p.first, p.second);\n        }\n\n    } else {\n        int components;\n        if (type == \"connected\") {\n            components = 1;\n        } else if (type == \"disconnected\") {\n            components = n;\n        } else if (type == \"components\") {\n            components = opt<int>(\"components\");\n            ensuref(components >= 1 && components <= n, \"Invalid number of components\");\n        } else {\n            // Default to components = 1\n            components = 1;\n        }\n\n        // Now, generate components\n        // Each component will have snow drifts\n        vector<int> componentSizes(components, n / components);\n        for (int i = 0; i < n % components; i++) {\n            componentSizes[i]++;\n        }\n\n        set<pair<int,int>> positions;\n        set<int> usedX;\n        set<int> usedY;\n\n        for (int c = 0; c < components; c++) {\n            int x0;\n            while (true) {\n                x0 = c * 10 + rnd.next(1,9); // x0 in [c*10+1, c*10+9]\n                if (x0 >=1 && x0 <= 1000 && usedX.count(x0) == 0) {\n                    usedX.insert(x0);\n                    break;\n                }\n                // If out of bounds or already used, try again\n            }\n\n            int numDrifts = componentSizes[c];\n            set<int> y_i_used_in_component;\n\n            for (int j = 0; j < numDrifts; j++) {\n                int y_i;\n                while (true) {\n                    y_i = rnd.next(1, 1000);\n                    if (usedY.count(y_i) == 0 && y_i_used_in_component.count(y_i) == 0) {\n                        // Ensure y_i not used globally or within component\n                        usedY.insert(y_i);\n                        y_i_used_in_component.insert(y_i);\n                        break;\n                    }\n                }\n                positions.insert({x0, y_i});\n            }\n        }\n\n        // Output n\n        printf(\"%d\\n\", n);\n        // Output positions\n        for (auto p : positions) {\n            printf(\"%d %d\\n\", p.first, p.second);\n        }\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    if (type == \"random\") {\n        set<pair<int,int>> positions;\n        while ((int)positions.size() < n) {\n            int x = rnd.next(1, 1000);\n            int y = rnd.next(1, 1000);\n            positions.insert({x, y});\n        }\n\n        // Output n\n        printf(\"%d\\n\", n);\n        // Output positions\n        for (auto p : positions) {\n            printf(\"%d %d\\n\", p.first, p.second);\n        }\n\n    } else {\n        int components;\n        if (type == \"connected\") {\n            components = 1;\n        } else if (type == \"disconnected\") {\n            components = n;\n        } else if (type == \"components\") {\n            components = opt<int>(\"components\");\n            ensuref(components >= 1 && components <= n, \"Invalid number of components\");\n        } else {\n            // Default to components = 1\n            components = 1;\n        }\n\n        // Now, generate components\n        // Each component will have snow drifts\n        vector<int> componentSizes(components, n / components);\n        for (int i = 0; i < n % components; i++) {\n            componentSizes[i]++;\n        }\n\n        set<pair<int,int>> positions;\n        set<int> usedX;\n        set<int> usedY;\n\n        for (int c = 0; c < components; c++) {\n            int x0;\n            while (true) {\n                x0 = c * 10 + rnd.next(1,9); // x0 in [c*10+1, c*10+9]\n                if (x0 >=1 && x0 <= 1000 && usedX.count(x0) == 0) {\n                    usedX.insert(x0);\n                    break;\n                }\n                // If out of bounds or already used, try again\n            }\n\n            int numDrifts = componentSizes[c];\n            set<int> y_i_used_in_component;\n\n            for (int j = 0; j < numDrifts; j++) {\n                int y_i;\n                while (true) {\n                    y_i = rnd.next(1, 1000);\n                    if (usedY.count(y_i) == 0 && y_i_used_in_component.count(y_i) == 0) {\n                        // Ensure y_i not used globally or within component\n                        usedY.insert(y_i);\n                        y_i_used_in_component.insert(y_i);\n                        break;\n                    }\n                }\n                positions.insert({x0, y_i});\n            }\n        }\n\n        // Output n\n        printf(\"%d\\n\", n);\n        // Output positions\n        for (auto p : positions) {\n            printf(\"%d %d\\n\", p.first, p.second);\n        }\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -type random\n\n./gen -n 1 -type connected\n\n./gen -n 1 -type disconnected\n\n./gen -n 2 -type random\n\n./gen -n 2 -type connected\n\n./gen -n 2 -type disconnected\n\n./gen -n 3 -type components -components 2\n\n./gen -n 3 -type components -components 3\n\n./gen -n 10 -type random\n\n./gen -n 10 -type connected\n\n./gen -n 10 -type disconnected\n\n./gen -n 10 -type components -components 2\n\n./gen -n 10 -type components -components 5\n\n./gen -n 10 -type components -components 10\n\n./gen -n 50 -type random\n\n./gen -n 50 -type connected\n\n./gen -n 50 -type disconnected\n\n./gen -n 50 -type components -components 5\n\n./gen -n 50 -type components -components 25\n\n./gen -n 50 -type components -components 50\n\n./gen -n 100 -type random\n\n./gen -n 100 -type connected\n\n./gen -n 100 -type disconnected\n\n./gen -n 100 -type components -components 10\n\n./gen -n 100 -type components -components 20\n\n./gen -n 100 -type components -components 50\n\n./gen -n 100 -type components -components 75\n\n./gen -n 100 -type components -components 99\n\n./gen -n 100 -type components -components 100\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T19:50:11.616763",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "217/B",
      "title": "B. Blackboard Fibonacci",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains the integers n and r (1 ≤ n, r ≤ 106).",
      "output_spec": "OutputThe first line of the output should contain one number — the minimum possible number of mistakes made by Bajtek. The second line should contain n characters, starting with \"T\", describing one possible sequence of operations with that number of mistakes. Each character must be either \"T\" or \"B\".If the required sequence doesn't exist, output \"IMPOSSIBLE\" (without quotes).",
      "sample_tests": "ExamplesInputCopy6 10OutputCopy2TBBTTBInputCopy4 5OutputCopy0TBTBInputCopy2 1OutputCopyIMPOSSIBLE",
      "description": "B. Blackboard Fibonacci\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains the integers n and r (1 ≤ n, r ≤ 106).\n\nOutputThe first line of the output should contain one number — the minimum possible number of mistakes made by Bajtek. The second line should contain n characters, starting with \"T\", describing one possible sequence of operations with that number of mistakes. Each character must be either \"T\" or \"B\".If the required sequence doesn't exist, output \"IMPOSSIBLE\" (without quotes).\n\nInputCopy6 10OutputCopy2TBBTTBInputCopy4 5OutputCopy0TBTBInputCopy2 1OutputCopyIMPOSSIBLE\n\nInputCopy6 10\n\nOutputCopy2TBBTTB\n\nInputCopy4 5\n\nOutputCopy0TBTB\n\nInputCopy2 1\n\nOutputCopyIMPOSSIBLE",
      "solutions": [
        {
          "title": "Codeforces Round #134 - Codeforces",
          "content": "Welcome to Codeforces Round #134!After over two years, it is again my great pleasure to be the main problemsetter of a contest on Codeforces. Thanks a lot to Gerald for helping me organize the round. I hope you will enjoy solving the problems as much as we enjoyed preparing them for you.Dynamic scoring will be used, but the problems will be ordered by their expected difficulty, from easiest to hardest. Are our predictions correct? I am eager to see. :-)Good luck!Update: The contest is over! Here are the results:First division: rng_58 panyuchaopieguy tourist Petr ACRush Zhukov_Dmitry All contestants from the top seven solved three problems. Note that there was a tie for second place. :-)Second division dsbuaa hqztrue Gullesnuffs In second division, seventeen contestants solved four problems. Nobody managed to crack E; it was also present in the first division as problem C, and proved tricky even for the experienced competitors.Congratulations to the winners!",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/5083",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 971
        },
        {
          "title": "Editorial for Codeforces Round #134 - Codeforces",
          "content": "A. Ice SkatingNotice that the existence of a snow drift at the point (x, y) implies that \"if I'm on the horizontal line at y then I am certainly able to get to the vertical line at x, and vice versa\". Thus, the snow drifts are the edges of a bipartite graph between x- and y- coordinates. The number of snow drifts that need to be added to make this (as well as the original) graph connected is the number of its connected components reduced by one.B. Blackboard FibonacciIf you look at the described process backwards, it resembles the Euclidean algorithm a lot. Indeed, if you rewinded a recording of Bajtek's actions, he always takes the larger out of two numbers (say Unable to parse markup [type=CF_TEX]) and replaces them by a - b, b. Since we know one of the final numbers (r) we can simply check all numbers between 1 and r and run a faster version of Euclid's algorithm (one that replaces a, b by ) for all possibilities for a total runtime of . This was one of the expected solutions.However, with some insight, it can be seen that this optimization is in fact not neccessary — we can simply simulate the reverse process as described (replacing a, b by a - b, b) for all candidates between 1 and r and the total runtime of our algorithm will remain . The proof of this fact is left to the reader.C. FormurosaOne of the major difficulties in this problem is finding an easily formulated condition for when Formurosa can be used to distinguish the bacteria. Let Formurosa's digestive process be a function F(s) that maps binary sequences of length m to elements of {0, 1}. It turns out that the condition we seek for can be stated as follows:We can distinguish all the bacteria if and only if there exists a sequence s of length m for which F(s) ≠ F( - s), where  - s is the negation of s.First, not that if no such sequence exists, then there is no way to distinguish between zero and one. If such a sequence exists, we can pick any two bacteria a and b and try both ways to substitute them for 0 and 1 in the expression. If the two expressions evaluate to different values, we will determine the exact types of both bacteria. Otherwise, we will be certain that the bacteria are of the same type. Repeating the process for all pairs of bacteria will let us identify all the types (since it is guaranteed that not all bacteria are of the same type).To determine whether such a sequence s exists, dynamic programming over the expression tree of Formurosa can be applied. The model solution keeps track for each subtree G of the expression which of the following sequences can be found: a sequence s such that G(s) = G( - s) = 0 a sequence s such that G(s) = G( - s) = 1 a sequence s such that G(s) ≠ G( - s) D. Bitonix' PatrolObservation 1.Fuel tanks for which capacity gives the same remainder are equivalent for Bitonix's purposes. Moreover, fuel tanks for which the capacities' remainders sum to D are also equivalent. Out of every group of equivalent tanks, the agency can only leave at most one.Observation 2.If more than six tanks remain, Bitonix can certainly complete his patrol. Indeed, let us assume that 7 tanks were left undestroyed by the agency. Out of the 128 possible subsets of those tanks, at least two distinct ones, say A and B, sum up to the same remainders modulo D. Thus, if Bitonix moves forward with tanks from A - B and backwards with tanks from B - A, he will finish at some station after an actual journey.Because of observations 1 and 2, it turns out that a simple recursive search suffices to solve the problem. However, because of the large constraints, it may prove necessary to use some optimizations, such as using bitmasks for keeping track of what distances Bitonix can cover.E. Alien DNANote that it is easy to determine, looking at only the last mutation, how many letters it adds to the final result. Indeed, if we need to print out the first k letters of the sequence, and the last mutation is [l, r], it suffices to find out the length of the overlap of segments [1, k] and [r + 1, 2r - l + 1]. Say that it is x. Then, after the next to last mutation, we are only interested in the first k - x letters of the result — the rest is irrelevant, as it will become \"pushed out\" by the elements added in the last mutation. Repeating this reasoning going backwards, we shall find out that we can spend linear time adding letters to the result after every mutation, which turns out to be the main idea needed to solve the problem.For a neat O(n2 + k) implementation of this idea you can check out ACRush's solution: 2029369.The only other contestant to solve the problem during the competition, panyuchao, used a slightly different approach, based in part on the same idea. Check out his ingenious, astonishingly short solution here: 2028007.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/5285",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 4782
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #134 - Codeforces - Code 1",
          "code": "Explain, please, D div 2) more than an hour spent on it (",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5083",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #134 - Codeforces - Code 2",
          "code": "eg.\n6 10\nsolve\n10 test 1 to 9\nwhen test 8 must be below:\n10 8\n2 8\n2 6\n2 4\n2 2\nassert not this.\nwhen test 7 must be below:\n10 7\n3 7\n3 4\n3 1\n2 1\n1 1\nhere have two possible, choice best one",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5083",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #134 - Codeforces - Code 3",
          "code": "eg.\n6 10\nsolve\n10 test 1 to 9\nwhen test 8 must be below:\n10 8\n2 8\n2 6\n2 4\n2 2\nassert not this.\nwhen test 7 must be below:\n10 7\n3 7\n3 4\n3 1\n2 1\n1 1\nhere have two possible, choice best one",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5083",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #134 - Codeforces - Code 4",
          "code": "999997 999997",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5083",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #134 - Codeforces - Code 5",
          "code": "www.Ideone.com",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5083",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #134 - Codeforces - Code 6",
          "code": "#pragma comment(linker, “/STACK: 268435456”)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5083",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 1000000, \"n\");\n    inf.readSpace();\n    int r = inf.readInt(1, 1000000, \"r\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 1000000, \"n\");\n    inf.readSpace();\n    int r = inf.readInt(1, 1000000, \"r\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 1000000, \"n\");\n    inf.readSpace();\n    int r = inf.readInt(1, 1000000, \"r\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char *argv[]) {\n    registerTestlibCmd(argc, argv);\n    // Read n and r from input file\n    int n = inf.readInt();\n    int r = inf.readInt();\n\n    // Read jury's answer\n    string jury_line1 = ans.readToken();\n    int juryMistakes = -1;\n    string jurySequence;\n    bool juryImpossible = false;\n    if (jury_line1 == \"IMPOSSIBLE\") {\n        juryImpossible = true;\n    } else {\n        juryMistakes = atoi(jury_line1.c_str());\n        jurySequence = ans.readToken();\n    }\n\n    // Read participant's answer\n    string participant_line1 = ouf.readToken();\n    int participantMistakes = -1;\n    string participantSequence;\n    bool participantImpossible = false;\n    if (participant_line1 == \"IMPOSSIBLE\") {\n        participantImpossible = true;\n    } else {\n        participantMistakes = atoi(participant_line1.c_str());\n        participantSequence = ouf.readToken();\n    }\n\n    // Check for format and correctness\n    if (participantImpossible) {\n        if (juryImpossible) {\n            quitf(_ok, \"Both contestant and jury output IMPOSSIBLE\");\n        } else {\n            quitf(_wa, \"Participant claims IMPOSSIBLE, but a solution exists\");\n        }\n    } else {\n        if (juryImpossible) {\n            quitf(_fail, \"Participant found a solution, but jury says IMPOSSIBLE\");\n        }\n    }\n    // Participant provided a solution\n    // Validate sequence length\n    if ((int)participantSequence.size() != n)\n        quitf(_wa, \"Participant's sequence length is not equal to n\");\n    // Check that sequence starts with 'T'\n    if (participantSequence[0] != 'T')\n        quitf(_wa, \"Participant's sequence does not start with 'T'\");\n\n    // Check that sequence contains only 'T' or 'B'\n    for (char c : participantSequence) {\n        if (c != 'T' && c != 'B')\n            quitf(_wa, \"Participant's sequence contains invalid character '%c'\", c);\n    }\n    // Count mistakes in participant's sequence\n    int mistakes = 0;\n    for (int i = 1; i < n; ++i) {\n        if (participantSequence[i] == participantSequence[i - 1])\n            mistakes++;\n    }\n    if (mistakes != participantMistakes)\n        quitf(_wa, \"Participant's number of mistakes (%d) does not match the sequence (%d)\",\n              participantMistakes, mistakes);\n\n    // Simulate the sequence to ensure it results in r\n    int top = 0;\n    int bottom = 1;\n    for (char op : participantSequence) {\n        int sum = top + bottom;\n        if (op == 'T') {\n            top = sum;\n        } else {\n            bottom = sum;\n        }\n    }\n    int result = (participantSequence.back() == 'T') ? top : bottom;\n    if (result != r)\n        quitf(_wa, \"Participant's sequence results in %d instead of %d\", result, r);\n\n    // Compare participant's mistakes with jury's minimal mistakes\n    if (participantMistakes > juryMistakes)\n        quitf(_wa, \"Participant's number of mistakes (%d) is greater than jury's minimal mistakes (%d)\",\n              participantMistakes, juryMistakes);\n    else if (participantMistakes == juryMistakes)\n        quitf(_ok, \"Correct answer with minimal mistakes %d\", participantMistakes);\n    else\n        quitf(_fail, \"Participant's number of mistakes (%d) is less than jury's minimal mistakes (%d)\",\n              participantMistakes, juryMistakes);\n\n    return 0;\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    const int MAX_R = 1000000;\n\n    int r = 0;\n\n    if (type == \"correct\") {\n        // Generate r = Fibonacci(n+1)\n        // Precompute Fibonacci numbers up to n+1\n        vector<int> fib(n + 2);\n        fib[0] = 0;\n        fib[1] = 1;\n        bool possible = true;\n        for (int i = 2; i <= n + 1; i++) {\n            fib[i] = fib[i - 1] + fib[i - 2];\n            if (fib[i] > MAX_R) {\n                possible = false;\n                break;\n            }\n        }\n        if (possible) {\n            r = fib[n + 1];\n        } else {\n            // IMPOSSIBLE to get r within constraints\n            r = rnd.next(1, MAX_R);\n        }\n    } else if (type == \"max_mistakes\") {\n        // Set r to minimum possible value\n        // For simplicity, set r = 1\n        r = 1;\n    } else if (type == \"random\") {\n        r = rnd.next(1, MAX_R);\n    } else if (type == \"impossible\") {\n        // Set r to a value that is likely impossible\n        r = MAX_R;\n    } else {\n        // Default: random r\n        r = rnd.next(1, MAX_R);\n    }\n\n    // Output n and r\n    printf(\"%d %d\\n\", n, r);\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    const int MAX_R = 1000000;\n\n    int r = 0;\n\n    if (type == \"correct\") {\n        // Generate r = Fibonacci(n+1)\n        // Precompute Fibonacci numbers up to n+1\n        vector<int> fib(n + 2);\n        fib[0] = 0;\n        fib[1] = 1;\n        bool possible = true;\n        for (int i = 2; i <= n + 1; i++) {\n            fib[i] = fib[i - 1] + fib[i - 2];\n            if (fib[i] > MAX_R) {\n                possible = false;\n                break;\n            }\n        }\n        if (possible) {\n            r = fib[n + 1];\n        } else {\n            // IMPOSSIBLE to get r within constraints\n            r = rnd.next(1, MAX_R);\n        }\n    } else if (type == \"max_mistakes\") {\n        // Set r to minimum possible value\n        // For simplicity, set r = 1\n        r = 1;\n    } else if (type == \"random\") {\n        r = rnd.next(1, MAX_R);\n    } else if (type == \"impossible\") {\n        // Set r to a value that is likely impossible\n        r = MAX_R;\n    } else {\n        // Default: random r\n        r = rnd.next(1, MAX_R);\n    }\n\n    // Output n and r\n    printf(\"%d %d\\n\", n, r);\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Correct sequences with minimal mistakes\n./gen -n 2 -type correct\n./gen -n 5 -type correct\n./gen -n 10 -type correct\n./gen -n 15 -type correct\n./gen -n 20 -type correct\n\n# Sequences with maximum mistakes\n./gen -n 1000 -type max_mistakes\n./gen -n 10000 -type max_mistakes\n./gen -n 50000 -type max_mistakes\n./gen -n 100000 -type max_mistakes\n./gen -n 1000000 -type max_mistakes\n\n# Random sequences\n./gen -n 2 -type random\n./gen -n 10 -type random\n./gen -n 50 -type random\n./gen -n 1000 -type random\n./gen -n 100000 -type random\n\n# Impossible cases\n./gen -n 1 -type impossible\n./gen -n 2 -type impossible\n./gen -n 10 -type impossible\n./gen -n 100 -type impossible\n./gen -n 1000 -type impossible\n\n# Edge cases with minimum n and maximum r\n./gen -n 1 -type correct\n./gen -n 1 -type max_mistakes\n./gen -n 1 -type random\n./gen -n 1 -type impossible\n\n# Edge cases with maximum n and random r\n./gen -n 1000000 -type correct\n./gen -n 1000000 -type random\n./gen -n 1000000 -type impossible\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T19:50:13.484666",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "217/C",
      "title": "C. Formurosa",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line of input contains a single integer n (2 ≤ n ≤ 106) — the number of colonies of bacteria.The second line contains the formula describing the nutrition process of Formurosa. This line contains only characters «0», «1», «?», «|», «&», «^», «(», «)» and complies with the following grammar:s → 0|1|?|(s|s)|(s&s)|(s^s)The formula consists of no more than 106 characters.",
      "output_spec": "OutputIf it is always possible to determine the species of each colony, output \"YES\" (without quotes). Otherwise, output \"NO\" (without quotes).",
      "sample_tests": "ExamplesInputCopy2(?^?)OutputCopyNOInputCopy10?OutputCopyYESInputCopy2((?^?)&?)OutputCopyYES",
      "description": "C. Formurosa\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line of input contains a single integer n (2 ≤ n ≤ 106) — the number of colonies of bacteria.The second line contains the formula describing the nutrition process of Formurosa. This line contains only characters «0», «1», «?», «|», «&», «^», «(», «)» and complies with the following grammar:s → 0|1|?|(s|s)|(s&s)|(s^s)The formula consists of no more than 106 characters.\n\nOutputIf it is always possible to determine the species of each colony, output \"YES\" (without quotes). Otherwise, output \"NO\" (without quotes).\n\nInputCopy2(?^?)OutputCopyNOInputCopy10?OutputCopyYESInputCopy2((?^?)&?)OutputCopyYES\n\nInputCopy2(?^?)\n\nOutputCopyNO\n\nInputCopy10?\n\nOutputCopyYES\n\nInputCopy2((?^?)&?)\n\nOutputCopyYES",
      "solutions": [
        {
          "title": "Codeforces Round #134 - Codeforces",
          "content": "Welcome to Codeforces Round #134!After over two years, it is again my great pleasure to be the main problemsetter of a contest on Codeforces. Thanks a lot to Gerald for helping me organize the round. I hope you will enjoy solving the problems as much as we enjoyed preparing them for you.Dynamic scoring will be used, but the problems will be ordered by their expected difficulty, from easiest to hardest. Are our predictions correct? I am eager to see. :-)Good luck!Update: The contest is over! Here are the results:First division: rng_58 panyuchaopieguy tourist Petr ACRush Zhukov_Dmitry All contestants from the top seven solved three problems. Note that there was a tie for second place. :-)Second division dsbuaa hqztrue Gullesnuffs In second division, seventeen contestants solved four problems. Nobody managed to crack E; it was also present in the first division as problem C, and proved tricky even for the experienced competitors.Congratulations to the winners!",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/5083",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 971
        },
        {
          "title": "Editorial for Codeforces Round #134 - Codeforces",
          "content": "A. Ice SkatingNotice that the existence of a snow drift at the point (x, y) implies that \"if I'm on the horizontal line at y then I am certainly able to get to the vertical line at x, and vice versa\". Thus, the snow drifts are the edges of a bipartite graph between x- and y- coordinates. The number of snow drifts that need to be added to make this (as well as the original) graph connected is the number of its connected components reduced by one.B. Blackboard FibonacciIf you look at the described process backwards, it resembles the Euclidean algorithm a lot. Indeed, if you rewinded a recording of Bajtek's actions, he always takes the larger out of two numbers (say Unable to parse markup [type=CF_TEX]) and replaces them by a - b, b. Since we know one of the final numbers (r) we can simply check all numbers between 1 and r and run a faster version of Euclid's algorithm (one that replaces a, b by ) for all possibilities for a total runtime of . This was one of the expected solutions.However, with some insight, it can be seen that this optimization is in fact not neccessary — we can simply simulate the reverse process as described (replacing a, b by a - b, b) for all candidates between 1 and r and the total runtime of our algorithm will remain . The proof of this fact is left to the reader.C. FormurosaOne of the major difficulties in this problem is finding an easily formulated condition for when Formurosa can be used to distinguish the bacteria. Let Formurosa's digestive process be a function F(s) that maps binary sequences of length m to elements of {0, 1}. It turns out that the condition we seek for can be stated as follows:We can distinguish all the bacteria if and only if there exists a sequence s of length m for which F(s) ≠ F( - s), where  - s is the negation of s.First, not that if no such sequence exists, then there is no way to distinguish between zero and one. If such a sequence exists, we can pick any two bacteria a and b and try both ways to substitute them for 0 and 1 in the expression. If the two expressions evaluate to different values, we will determine the exact types of both bacteria. Otherwise, we will be certain that the bacteria are of the same type. Repeating the process for all pairs of bacteria will let us identify all the types (since it is guaranteed that not all bacteria are of the same type).To determine whether such a sequence s exists, dynamic programming over the expression tree of Formurosa can be applied. The model solution keeps track for each subtree G of the expression which of the following sequences can be found: a sequence s such that G(s) = G( - s) = 0 a sequence s such that G(s) = G( - s) = 1 a sequence s such that G(s) ≠ G( - s) D. Bitonix' PatrolObservation 1.Fuel tanks for which capacity gives the same remainder are equivalent for Bitonix's purposes. Moreover, fuel tanks for which the capacities' remainders sum to D are also equivalent. Out of every group of equivalent tanks, the agency can only leave at most one.Observation 2.If more than six tanks remain, Bitonix can certainly complete his patrol. Indeed, let us assume that 7 tanks were left undestroyed by the agency. Out of the 128 possible subsets of those tanks, at least two distinct ones, say A and B, sum up to the same remainders modulo D. Thus, if Bitonix moves forward with tanks from A - B and backwards with tanks from B - A, he will finish at some station after an actual journey.Because of observations 1 and 2, it turns out that a simple recursive search suffices to solve the problem. However, because of the large constraints, it may prove necessary to use some optimizations, such as using bitmasks for keeping track of what distances Bitonix can cover.E. Alien DNANote that it is easy to determine, looking at only the last mutation, how many letters it adds to the final result. Indeed, if we need to print out the first k letters of the sequence, and the last mutation is [l, r], it suffices to find out the length of the overlap of segments [1, k] and [r + 1, 2r - l + 1]. Say that it is x. Then, after the next to last mutation, we are only interested in the first k - x letters of the result — the rest is irrelevant, as it will become \"pushed out\" by the elements added in the last mutation. Repeating this reasoning going backwards, we shall find out that we can spend linear time adding letters to the result after every mutation, which turns out to be the main idea needed to solve the problem.For a neat O(n2 + k) implementation of this idea you can check out ACRush's solution: 2029369.The only other contestant to solve the problem during the competition, panyuchao, used a slightly different approach, based in part on the same idea. Check out his ingenious, astonishingly short solution here: 2028007.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/5285",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 4782
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #134 - Codeforces - Code 1",
          "code": "Explain, please, D div 2) more than an hour spent on it (",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5083",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #134 - Codeforces - Code 2",
          "code": "eg.\n6 10\nsolve\n10 test 1 to 9\nwhen test 8 must be below:\n10 8\n2 8\n2 6\n2 4\n2 2\nassert not this.\nwhen test 7 must be below:\n10 7\n3 7\n3 4\n3 1\n2 1\n1 1\nhere have two possible, choice best one",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5083",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #134 - Codeforces - Code 3",
          "code": "eg.\n6 10\nsolve\n10 test 1 to 9\nwhen test 8 must be below:\n10 8\n2 8\n2 6\n2 4\n2 2\nassert not this.\nwhen test 7 must be below:\n10 7\n3 7\n3 4\n3 1\n2 1\n1 1\nhere have two possible, choice best one",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5083",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #134 - Codeforces - Code 4",
          "code": "999997 999997",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5083",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #134 - Codeforces - Code 5",
          "code": "www.Ideone.com",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5083",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #134 - Codeforces - Code 6",
          "code": "#pragma comment(linker, “/STACK: 268435456”)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5083",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nsize_t parse_s(const string& str, size_t pos)\n{\n    if (pos >= str.length())\n        quitf(_fail, \"Unexpected end of formula at position %zu\", pos);\n    char ch = str[pos];\n    if (ch == '0' || ch == '1' || ch == '?')\n    {\n        // Consume the character\n        return pos + 1;\n    }\n    else if (ch == '(')\n    {\n        pos++;\n        if (pos >= str.length())\n            quitf(_fail, \"Expected expression after '(' at position %zu\", pos);\n        pos = parse_s(str, pos);\n        if (pos >= str.length())\n            quitf(_fail, \"Expected operator after sub-expression at position %zu\", pos);\n        char op = str[pos];\n        if (op != '|' && op != '&' && op != '^')\n            quitf(_fail, \"Expected operator at position %zu, got '%c'\", pos, op);\n        pos++;\n        if (pos >= str.length())\n            quitf(_fail, \"Expected second sub-expression after operator at position %zu\", pos);\n        pos = parse_s(str, pos);\n        if (pos >= str.length())\n            quitf(_fail, \"Expected ')' after sub-expression at position %zu\", pos);\n        if (str[pos] != ')')\n            quitf(_fail, \"Expected ')' at position %zu, got '%c'\", pos, str[pos]);\n        return pos + 1;\n    }\n    else\n    {\n        quitf(_fail, \"Invalid character '%c' at position %zu\", ch, pos);\n    }\n}\n\nint main(int argc, char* argv[])\n{\n    registerValidation(argc, argv);\n    int n = inf.readInt(2, 1000000, \"n\");\n    inf.readEoln();\n    string formula = inf.readLine(\"[01\\\\?\\\\|\\\\&\\\\^\\\\(\\\\)]{1,1000000}\", \"formula\");\n    size_t pos = parse_s(formula, 0);\n    if (pos != formula.length())\n    {\n        quitf(_fail, \"Extra characters at end of formula starting from position %zu\", pos);\n    }\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nsize_t parse_s(const string& str, size_t pos)\n{\n    if (pos >= str.length())\n        quitf(_fail, \"Unexpected end of formula at position %zu\", pos);\n    char ch = str[pos];\n    if (ch == '0' || ch == '1' || ch == '?')\n    {\n        // Consume the character\n        return pos + 1;\n    }\n    else if (ch == '(')\n    {\n        pos++;\n        if (pos >= str.length())\n            quitf(_fail, \"Expected expression after '(' at position %zu\", pos);\n        pos = parse_s(str, pos);\n        if (pos >= str.length())\n            quitf(_fail, \"Expected operator after sub-expression at position %zu\", pos);\n        char op = str[pos];\n        if (op != '|' && op != '&' && op != '^')\n            quitf(_fail, \"Expected operator at position %zu, got '%c'\", pos, op);\n        pos++;\n        if (pos >= str.length())\n            quitf(_fail, \"Expected second sub-expression after operator at position %zu\", pos);\n        pos = parse_s(str, pos);\n        if (pos >= str.length())\n            quitf(_fail, \"Expected ')' after sub-expression at position %zu\", pos);\n        if (str[pos] != ')')\n            quitf(_fail, \"Expected ')' at position %zu, got '%c'\", pos, str[pos]);\n        return pos + 1;\n    }\n    else\n    {\n        quitf(_fail, \"Invalid character '%c' at position %zu\", ch, pos);\n    }\n}\n\nint main(int argc, char* argv[])\n{\n    registerValidation(argc, argv);\n    int n = inf.readInt(2, 1000000, \"n\");\n    inf.readEoln();\n    string formula = inf.readLine(\"[01\\\\?\\\\|\\\\&\\\\^\\\\(\\\\)]{1,1000000}\", \"formula\");\n    size_t pos = parse_s(formula, 0);\n    if (pos != formula.length())\n    {\n        quitf(_fail, \"Extra characters at end of formula starting from position %zu\", pos);\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nsize_t parse_s(const string& str, size_t pos)\n{\n    if (pos >= str.length())\n        quitf(_fail, \"Unexpected end of formula at position %zu\", pos);\n    char ch = str[pos];\n    if (ch == '0' || ch == '1' || ch == '?')\n    {\n        // Consume the character\n        return pos + 1;\n    }\n    else if (ch == '(')\n    {\n        pos++;\n        if (pos >= str.length())\n            quitf(_fail, \"Expected expression after '(' at position %zu\", pos);\n        pos = parse_s(str, pos);\n        if (pos >= str.length())\n            quitf(_fail, \"Expected operator after sub-expression at position %zu\", pos);\n        char op = str[pos];\n        if (op != '|' && op != '&' && op != '^')\n            quitf(_fail, \"Expected operator at position %zu, got '%c'\", pos, op);\n        pos++;\n        if (pos >= str.length())\n            quitf(_fail, \"Expected second sub-expression after operator at position %zu\", pos);\n        pos = parse_s(str, pos);\n        if (pos >= str.length())\n            quitf(_fail, \"Expected ')' after sub-expression at position %zu\", pos);\n        if (str[pos] != ')')\n            quitf(_fail, \"Expected ')' at position %zu, got '%c'\", pos, str[pos]);\n        return pos + 1;\n    }\n    else\n    {\n        quitf(_fail, \"Invalid character '%c' at position %zu\", ch, pos);\n    }\n}\n\nint main(int argc, char* argv[])\n{\n    registerValidation(argc, argv);\n    int n = inf.readInt(2, 1000000, \"n\");\n    inf.readEoln();\n    string formula = inf.readLine(\"[01\\\\?\\\\|\\\\&\\\\^\\\\(\\\\)]{1,1000000}\", \"formula\");\n    size_t pos = parse_s(formula, 0);\n    if (pos != formula.length())\n    {\n        quitf(_fail, \"Extra characters at end of formula starting from position %zu\", pos);\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n#include <string>\r\n\r\nusing namespace std;\r\n\r\nconst string YES = \"YES\";\r\nconst string NO = \"NO\";\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"%s\", (\"multiple \" + YES + \"/\" + NO + \" (case insensitive)\").c_str());\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int index = 0, yesCount = 0, noCount = 0;\r\n    string pa;\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        index++;\r\n        string ja = upperCase(ans.readToken());\r\n        pa = upperCase(ouf.readToken());\r\n\r\n        if (ja != YES && ja != NO)\r\n            quitf(_fail, \"%s or %s expected in answer, but %s found [%d%s token]\",\r\n                  YES.c_str(), NO.c_str(), compress(ja).c_str(), index, englishEnding(index).c_str());\r\n\r\n        if (pa == YES)\r\n            yesCount++;\r\n        else if (pa == NO)\r\n            noCount++;\r\n        else\r\n            quitf(_pe, \"%s or %s expected, but %s found [%d%s token]\",\r\n                  YES.c_str(), NO.c_str(), compress(pa).c_str(), index, englishEnding(index).c_str());\r\n\r\n        if (ja != pa)\r\n            quitf(_wa, \"expected %s, found %s [%d%s token]\",\r\n                  compress(ja).c_str(), compress(pa).c_str(), index, englishEnding(index).c_str());\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n    while (!ans.seekEof()) {\r\n        ans.readToken();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n    while (!ouf.seekEof()) {\r\n        ouf.readToken();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              index + extraInAnsCount, index);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              index + extraInOufCount, index);\r\n\r\n    if (index == 0)\r\n        quitf(_ok, \"Empty output\");\r\n    else if (index == 1)\r\n        quitf(_ok, \"%s\", pa.c_str());\r\n    else\r\n        quitf(_ok, \"%d token(s): yes count is %d, no count is %d\", index, yesCount, noCount);\r\n\r\n    quitf(_fail, \"Impossible case\");\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring generate_s(int &current_length, int max_length, int depth, int max_depth) {\n    if (current_length >= max_length) {\n        // Can't add more characters, return empty string\n        return \"\";\n    }\n    if (depth >= max_depth) {\n        // Return a terminal\n        int choice = rnd.next(3); // 0,1,2\n        string res;\n        if (choice == 0) res = \"?\";\n        else if (choice == 1) res = \"0\";\n        else res = \"1\";\n        current_length += res.size();\n        return res;\n    }\n    int choice = rnd.next(10);\n    if ((choice < 3 && depth > 0) || current_length + 1 >= max_length) {\n        // Return a terminal\n        int term_choice = rnd.next(3);\n        string res;\n        if (term_choice == 0) res = \"?\";\n        else if (term_choice == 1) res = \"0\";\n        else res = \"1\";\n        current_length += res.size();\n        return res;\n    } else {\n        // Generate an expression\n        string op;\n        int op_choice = rnd.next(3);\n        if (op_choice == 0) op = \"|\";\n        else if (op_choice == 1) op = \"&\";\n        else op = \"^\";\n        \n        current_length += 1; // '('\n        string left = generate_s(current_length, max_length, depth+1, max_depth);\n        current_length += op.size();\n        string right = generate_s(current_length, max_length, depth+1, max_depth);\n        current_length +=1; // ')'\n\n        string res = \"(\" + left + op + right + \")\";\n        return res;\n    }\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random_small\");\n\n    string formula;\n    if (type == \"single_leaf\") {\n        formula = \"?\";\n    } else if (type == \"simple_yes\") {\n        formula = \"((?^?)&?)\";\n    } else if (type == \"simple_no\") {\n        formula = \"(?^?)\";\n    } else if (type == \"constant_zero\") {\n        formula = \"0\";\n    } else if (type == \"constant_one\") {\n        formula = \"1\";\n    } else if (type == \"random_small\") {\n        int current_length = 0;\n        int max_length = 1000;\n        int max_depth = 20;\n        formula = generate_s(current_length, max_length, 0, max_depth);\n    } else if (type == \"random_large\") {\n        int current_length = 0;\n        int max_length = 1000000; // 1e6\n        int max_depth = 1000;\n        formula = generate_s(current_length, max_length, 0, max_depth);\n    } else {\n        // Default to random_small if unknown type\n        int current_length = 0;\n        int max_length = 1000;\n        int max_depth = 20;\n        formula = generate_s(current_length, max_length, 0, max_depth);\n    }\n\n    // Ensure n is within bounds\n    n = max(2, min(n, 1000000)); // Ensure n is between 2 and 1e6\n\n    // Output n and formula\n    printf(\"%d\\n\", n);\n    printf(\"%s\\n\", formula.c_str());\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring generate_s(int &current_length, int max_length, int depth, int max_depth) {\n    if (current_length >= max_length) {\n        // Can't add more characters, return empty string\n        return \"\";\n    }\n    if (depth >= max_depth) {\n        // Return a terminal\n        int choice = rnd.next(3); // 0,1,2\n        string res;\n        if (choice == 0) res = \"?\";\n        else if (choice == 1) res = \"0\";\n        else res = \"1\";\n        current_length += res.size();\n        return res;\n    }\n    int choice = rnd.next(10);\n    if ((choice < 3 && depth > 0) || current_length + 1 >= max_length) {\n        // Return a terminal\n        int term_choice = rnd.next(3);\n        string res;\n        if (term_choice == 0) res = \"?\";\n        else if (term_choice == 1) res = \"0\";\n        else res = \"1\";\n        current_length += res.size();\n        return res;\n    } else {\n        // Generate an expression\n        string op;\n        int op_choice = rnd.next(3);\n        if (op_choice == 0) op = \"|\";\n        else if (op_choice == 1) op = \"&\";\n        else op = \"^\";\n        \n        current_length += 1; // '('\n        string left = generate_s(current_length, max_length, depth+1, max_depth);\n        current_length += op.size();\n        string right = generate_s(current_length, max_length, depth+1, max_depth);\n        current_length +=1; // ')'\n\n        string res = \"(\" + left + op + right + \")\";\n        return res;\n    }\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random_small\");\n\n    string formula;\n    if (type == \"single_leaf\") {\n        formula = \"?\";\n    } else if (type == \"simple_yes\") {\n        formula = \"((?^?)&?)\";\n    } else if (type == \"simple_no\") {\n        formula = \"(?^?)\";\n    } else if (type == \"constant_zero\") {\n        formula = \"0\";\n    } else if (type == \"constant_one\") {\n        formula = \"1\";\n    } else if (type == \"random_small\") {\n        int current_length = 0;\n        int max_length = 1000;\n        int max_depth = 20;\n        formula = generate_s(current_length, max_length, 0, max_depth);\n    } else if (type == \"random_large\") {\n        int current_length = 0;\n        int max_length = 1000000; // 1e6\n        int max_depth = 1000;\n        formula = generate_s(current_length, max_length, 0, max_depth);\n    } else {\n        // Default to random_small if unknown type\n        int current_length = 0;\n        int max_length = 1000;\n        int max_depth = 20;\n        formula = generate_s(current_length, max_length, 0, max_depth);\n    }\n\n    // Ensure n is within bounds\n    n = max(2, min(n, 1000000)); // Ensure n is between 2 and 1e6\n\n    // Output n and formula\n    printf(\"%d\\n\", n);\n    printf(\"%s\\n\", formula.c_str());\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 2 -type single_leaf\n./gen -n 10 -type single_leaf\n./gen -n 100 -type single_leaf\n./gen -n 1000 -type single_leaf\n./gen -n 1000000 -type single_leaf\n\n./gen -n 2 -type simple_yes\n./gen -n 10 -type simple_yes\n./gen -n 100 -type simple_yes\n./gen -n 1000 -type simple_yes\n./gen -n 1000000 -type simple_yes\n\n./gen -n 2 -type simple_no\n./gen -n 10 -type simple_no\n./gen -n 100 -type simple_no\n./gen -n 1000 -type simple_no\n./gen -n 1000000 -type simple_no\n\n./gen -n 2 -type constant_zero\n./gen -n 10 -type constant_zero\n./gen -n 100 -type constant_zero\n./gen -n 1000 -type constant_zero\n./gen -n 1000000 -type constant_zero\n\n./gen -n 2 -type constant_one\n./gen -n 10 -type constant_one\n./gen -n 100 -type constant_one\n./gen -n 1000 -type constant_one\n./gen -n 1000000 -type constant_one\n\n./gen -n 2 -type random_small\n./gen -n 10 -type random_small\n./gen -n 100 -type random_small\n./gen -n 1000 -type random_small\n./gen -n 1000000 -type random_small\n\n./gen -n 2 -type random_large\n./gen -n 10 -type random_large\n./gen -n 100 -type random_large\n./gen -n 1000 -type random_large\n./gen -n 1000000 -type random_large\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T19:50:15.206744",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "217/D",
      "title": "D. Bitonix' Patrol",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line of the input contains three integers n (2 ≤ n ≤ 1000) — the number of stations, m (1 ≤ m ≤ 120) — the distance between adjacent stations, and t (1 ≤ t ≤ 10000) — the number of fuel tanks owned by Captain Bitonix.The second line of the input contains t space-separated integers between 1 and 109, inclusive — the volumes of Bitonix' fuel tanks.",
      "output_spec": "OutputOutput a single number — the number of distinct subsets of tanks that the Bytelandian space agency can destroy in order to prevent Captain Bitonix from completing a patrol, modulo 109 + 7.",
      "sample_tests": "ExamplesInputCopy7 6 55 4 12 6 5OutputCopy6InputCopy3 60 210 100OutputCopy4",
      "description": "D. Bitonix' Patrol\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line of the input contains three integers n (2 ≤ n ≤ 1000) — the number of stations, m (1 ≤ m ≤ 120) — the distance between adjacent stations, and t (1 ≤ t ≤ 10000) — the number of fuel tanks owned by Captain Bitonix.The second line of the input contains t space-separated integers between 1 and 109, inclusive — the volumes of Bitonix' fuel tanks.\n\nOutputOutput a single number — the number of distinct subsets of tanks that the Bytelandian space agency can destroy in order to prevent Captain Bitonix from completing a patrol, modulo 109 + 7.\n\nInputCopy7 6 55 4 12 6 5OutputCopy6InputCopy3 60 210 100OutputCopy4\n\nInputCopy7 6 55 4 12 6 5\n\nOutputCopy6\n\nInputCopy3 60 210 100\n\nOutputCopy4\n\nNoteAll the fuel tanks are distinct, even if some of them have the same capacity.",
      "solutions": [
        {
          "title": "Codeforces Round #134 - Codeforces",
          "content": "Welcome to Codeforces Round #134!After over two years, it is again my great pleasure to be the main problemsetter of a contest on Codeforces. Thanks a lot to Gerald for helping me organize the round. I hope you will enjoy solving the problems as much as we enjoyed preparing them for you.Dynamic scoring will be used, but the problems will be ordered by their expected difficulty, from easiest to hardest. Are our predictions correct? I am eager to see. :-)Good luck!Update: The contest is over! Here are the results:First division: rng_58 panyuchaopieguy tourist Petr ACRush Zhukov_Dmitry All contestants from the top seven solved three problems. Note that there was a tie for second place. :-)Second division dsbuaa hqztrue Gullesnuffs In second division, seventeen contestants solved four problems. Nobody managed to crack E; it was also present in the first division as problem C, and proved tricky even for the experienced competitors.Congratulations to the winners!",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/5083",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 971
        },
        {
          "title": "Editorial for Codeforces Round #134 - Codeforces",
          "content": "A. Ice SkatingNotice that the existence of a snow drift at the point (x, y) implies that \"if I'm on the horizontal line at y then I am certainly able to get to the vertical line at x, and vice versa\". Thus, the snow drifts are the edges of a bipartite graph between x- and y- coordinates. The number of snow drifts that need to be added to make this (as well as the original) graph connected is the number of its connected components reduced by one.B. Blackboard FibonacciIf you look at the described process backwards, it resembles the Euclidean algorithm a lot. Indeed, if you rewinded a recording of Bajtek's actions, he always takes the larger out of two numbers (say Unable to parse markup [type=CF_TEX]) and replaces them by a - b, b. Since we know one of the final numbers (r) we can simply check all numbers between 1 and r and run a faster version of Euclid's algorithm (one that replaces a, b by ) for all possibilities for a total runtime of . This was one of the expected solutions.However, with some insight, it can be seen that this optimization is in fact not neccessary — we can simply simulate the reverse process as described (replacing a, b by a - b, b) for all candidates between 1 and r and the total runtime of our algorithm will remain . The proof of this fact is left to the reader.C. FormurosaOne of the major difficulties in this problem is finding an easily formulated condition for when Formurosa can be used to distinguish the bacteria. Let Formurosa's digestive process be a function F(s) that maps binary sequences of length m to elements of {0, 1}. It turns out that the condition we seek for can be stated as follows:We can distinguish all the bacteria if and only if there exists a sequence s of length m for which F(s) ≠ F( - s), where  - s is the negation of s.First, not that if no such sequence exists, then there is no way to distinguish between zero and one. If such a sequence exists, we can pick any two bacteria a and b and try both ways to substitute them for 0 and 1 in the expression. If the two expressions evaluate to different values, we will determine the exact types of both bacteria. Otherwise, we will be certain that the bacteria are of the same type. Repeating the process for all pairs of bacteria will let us identify all the types (since it is guaranteed that not all bacteria are of the same type).To determine whether such a sequence s exists, dynamic programming over the expression tree of Formurosa can be applied. The model solution keeps track for each subtree G of the expression which of the following sequences can be found: a sequence s such that G(s) = G( - s) = 0 a sequence s such that G(s) = G( - s) = 1 a sequence s such that G(s) ≠ G( - s) D. Bitonix' PatrolObservation 1.Fuel tanks for which capacity gives the same remainder are equivalent for Bitonix's purposes. Moreover, fuel tanks for which the capacities' remainders sum to D are also equivalent. Out of every group of equivalent tanks, the agency can only leave at most one.Observation 2.If more than six tanks remain, Bitonix can certainly complete his patrol. Indeed, let us assume that 7 tanks were left undestroyed by the agency. Out of the 128 possible subsets of those tanks, at least two distinct ones, say A and B, sum up to the same remainders modulo D. Thus, if Bitonix moves forward with tanks from A - B and backwards with tanks from B - A, he will finish at some station after an actual journey.Because of observations 1 and 2, it turns out that a simple recursive search suffices to solve the problem. However, because of the large constraints, it may prove necessary to use some optimizations, such as using bitmasks for keeping track of what distances Bitonix can cover.E. Alien DNANote that it is easy to determine, looking at only the last mutation, how many letters it adds to the final result. Indeed, if we need to print out the first k letters of the sequence, and the last mutation is [l, r], it suffices to find out the length of the overlap of segments [1, k] and [r + 1, 2r - l + 1]. Say that it is x. Then, after the next to last mutation, we are only interested in the first k - x letters of the result — the rest is irrelevant, as it will become \"pushed out\" by the elements added in the last mutation. Repeating this reasoning going backwards, we shall find out that we can spend linear time adding letters to the result after every mutation, which turns out to be the main idea needed to solve the problem.For a neat O(n2 + k) implementation of this idea you can check out ACRush's solution: 2029369.The only other contestant to solve the problem during the competition, panyuchao, used a slightly different approach, based in part on the same idea. Check out his ingenious, astonishingly short solution here: 2028007.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/5285",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 4782
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #134 - Codeforces - Code 1",
          "code": "Explain, please, D div 2) more than an hour spent on it (",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5083",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #134 - Codeforces - Code 2",
          "code": "eg.\n6 10\nsolve\n10 test 1 to 9\nwhen test 8 must be below:\n10 8\n2 8\n2 6\n2 4\n2 2\nassert not this.\nwhen test 7 must be below:\n10 7\n3 7\n3 4\n3 1\n2 1\n1 1\nhere have two possible, choice best one",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5083",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #134 - Codeforces - Code 3",
          "code": "eg.\n6 10\nsolve\n10 test 1 to 9\nwhen test 8 must be below:\n10 8\n2 8\n2 6\n2 4\n2 2\nassert not this.\nwhen test 7 must be below:\n10 7\n3 7\n3 4\n3 1\n2 1\n1 1\nhere have two possible, choice best one",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5083",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #134 - Codeforces - Code 4",
          "code": "999997 999997",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5083",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #134 - Codeforces - Code 5",
          "code": "www.Ideone.com",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5083",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #134 - Codeforces - Code 6",
          "code": "#pragma comment(linker, “/STACK: 268435456”)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5083",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(2, 1000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 120, \"m\");\n    inf.readSpace();\n    int t = inf.readInt(1, 10000, \"t\");\n    inf.readEoln();\n\n    vector<int> tanks = inf.readInts(t, 1, 1000000000, \"tanks\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(2, 1000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 120, \"m\");\n    inf.readSpace();\n    int t = inf.readInt(1, 10000, \"t\");\n    inf.readEoln();\n\n    vector<int> tanks = inf.readInts(t, 1, 1000000000, \"tanks\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(2, 1000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 120, \"m\");\n    inf.readSpace();\n    int t = inf.readInt(1, 10000, \"t\");\n    inf.readEoln();\n\n    vector<int> tanks = inf.readInts(t, 1, 1000000000, \"tanks\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    int t = opt<int>(\"t\");\n    string xType = opt<string>(\"xType\", \"random\");\n\n    // Output n, m, t\n    printf(\"%d %d %d\\n\", n, m, t);\n\n    vector<int> fuel_tanks(t);\n\n    if (xType == \"random\") {\n        // Random capacities between 1 and 1e9\n        for(int i = 0; i < t; ++i) {\n            fuel_tanks[i] = rnd.next(1, 1000000000);\n        }\n    } else if (xType == \"multiples_of_m\") {\n        // All capacities are multiples of m\n        for(int i = 0; i < t; ++i) {\n            int k = rnd.next(1, max(1, 1000000000 / m));\n            fuel_tanks[i] = (long long)m * k;\n            if (fuel_tanks[i] > 1000000000) {\n                fuel_tanks[i] = m;\n            }\n        }\n    } else if (xType == \"not_multiples_of_m\") {\n        // All capacities are NOT multiples of m\n        for(int i = 0; i < t; ++i) {\n            int x;\n            do {\n                x = rnd.next(1, 1000000000);\n            } while (x % m == 0);\n            fuel_tanks[i] = x;\n        }\n    } else if (xType == \"same_capacity\") {\n        // All capacities are the same\n        int c = rnd.next(1, 1000000000);\n        for(int i = 0; i < t; ++i) {\n            fuel_tanks[i] = c;\n        }\n    } else if (xType == \"small_numbers\") {\n        // Capacities between 1 and 10\n        for(int i = 0; i < t; ++i) {\n            fuel_tanks[i] = rnd.next(1, 10);\n        }\n    } else if (xType == \"large_numbers\") {\n        // Capacities between 1e9 - 100 and 1e9\n        for(int i = 0; i < t; ++i) {\n            fuel_tanks[i] = rnd.next(1e9 - 100, 1e9);\n        }\n    } else if (xType == \"max_capacity\") {\n        // All capacities are 1e9\n        for(int i = 0; i < t; ++i) {\n            fuel_tanks[i] = 1000000000;\n        }\n    } else if (xType == \"edge_case_1\") {\n        // Edge case: Capacities equal to circumference if possible\n        long long circumference = (long long)n * m;\n        if (circumference <= 1000000000) {\n            for (int i = 0; i < t; ++i) {\n                fuel_tanks[i] = (int)circumference;\n            }\n        } else {\n            // If circumference > 1e9, use m\n            for (int i = 0; i < t; ++i) {\n                fuel_tanks[i] = m;\n            }\n        }\n    } else if (xType == \"edge_case_2\") {\n        // Edge case: All capacities are 1\n        for (int i = 0; i < t; ++i) {\n            fuel_tanks[i] = 1;\n        }\n    } else {\n        // Default to random capacities\n        for(int i = 0; i < t; ++i) {\n            fuel_tanks[i] = rnd.next(1, 1000000000);\n        }\n    }\n\n    // Print the fuel tank capacities\n    for(int i = 0; i < t; ++i) {\n        printf(\"%d%c\", fuel_tanks[i], i == t - 1 ? '\\n' : ' ');\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    int t = opt<int>(\"t\");\n    string xType = opt<string>(\"xType\", \"random\");\n\n    // Output n, m, t\n    printf(\"%d %d %d\\n\", n, m, t);\n\n    vector<int> fuel_tanks(t);\n\n    if (xType == \"random\") {\n        // Random capacities between 1 and 1e9\n        for(int i = 0; i < t; ++i) {\n            fuel_tanks[i] = rnd.next(1, 1000000000);\n        }\n    } else if (xType == \"multiples_of_m\") {\n        // All capacities are multiples of m\n        for(int i = 0; i < t; ++i) {\n            int k = rnd.next(1, max(1, 1000000000 / m));\n            fuel_tanks[i] = (long long)m * k;\n            if (fuel_tanks[i] > 1000000000) {\n                fuel_tanks[i] = m;\n            }\n        }\n    } else if (xType == \"not_multiples_of_m\") {\n        // All capacities are NOT multiples of m\n        for(int i = 0; i < t; ++i) {\n            int x;\n            do {\n                x = rnd.next(1, 1000000000);\n            } while (x % m == 0);\n            fuel_tanks[i] = x;\n        }\n    } else if (xType == \"same_capacity\") {\n        // All capacities are the same\n        int c = rnd.next(1, 1000000000);\n        for(int i = 0; i < t; ++i) {\n            fuel_tanks[i] = c;\n        }\n    } else if (xType == \"small_numbers\") {\n        // Capacities between 1 and 10\n        for(int i = 0; i < t; ++i) {\n            fuel_tanks[i] = rnd.next(1, 10);\n        }\n    } else if (xType == \"large_numbers\") {\n        // Capacities between 1e9 - 100 and 1e9\n        for(int i = 0; i < t; ++i) {\n            fuel_tanks[i] = rnd.next(1e9 - 100, 1e9);\n        }\n    } else if (xType == \"max_capacity\") {\n        // All capacities are 1e9\n        for(int i = 0; i < t; ++i) {\n            fuel_tanks[i] = 1000000000;\n        }\n    } else if (xType == \"edge_case_1\") {\n        // Edge case: Capacities equal to circumference if possible\n        long long circumference = (long long)n * m;\n        if (circumference <= 1000000000) {\n            for (int i = 0; i < t; ++i) {\n                fuel_tanks[i] = (int)circumference;\n            }\n        } else {\n            // If circumference > 1e9, use m\n            for (int i = 0; i < t; ++i) {\n                fuel_tanks[i] = m;\n            }\n        }\n    } else if (xType == \"edge_case_2\") {\n        // Edge case: All capacities are 1\n        for (int i = 0; i < t; ++i) {\n            fuel_tanks[i] = 1;\n        }\n    } else {\n        // Default to random capacities\n        for(int i = 0; i < t; ++i) {\n            fuel_tanks[i] = rnd.next(1, 1000000000);\n        }\n    }\n\n    // Print the fuel tank capacities\n    for(int i = 0; i < t; ++i) {\n        printf(\"%d%c\", fuel_tanks[i], i == t - 1 ? '\\n' : ' ');\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 2 -m 1 -t 1 -xType random\n./gen -n 2 -m 1 -t 1 -xType edge_case_2\n./gen -n 3 -m 60 -t 2 -xType same_capacity\n./gen -n 3 -m 60 -t 2 -xType random\n./gen -n 3 -m 60 -t 4 -xType random\n./gen -n 3 -m 60 -t 4 -xType small_numbers\n\n./gen -n 7 -m 6 -t 5 -xType small_numbers\n\n# Minimal values\n./gen -n 2 -m 1 -t 1 -xType small_numbers\n\n# Maximal values\n./gen -n 1000 -m 120 -t 10000 -xType random\n./gen -n 1000 -m 120 -t 10000 -xType large_numbers\n\n# All capacities are multiples of m\n./gen -n 1000 -m 120 -t 10000 -xType multiples_of_m\n\n# All capacities are not multiples of m\n./gen -n 1000 -m 120 -t 10000 -xType not_multiples_of_m\n\n# All capacities are small numbers\n./gen -n 1000 -m 120 -t 10000 -xType small_numbers\n\n# All capacities are large numbers\n./gen -n 500 -m 50 -t 5000 -xType large_numbers\n\n# All capacities are the same\n./gen -n 500 -m 100 -t 5000 -xType same_capacity\n\n# Edge case with capacities equal to circumference\n./gen -n 2 -m 1 -t 1 -xType edge_case_1\n./gen -n 1000 -m 120 -t 10000 -xType edge_case_1\n\n# Edge case with capacities equal to 1\n./gen -n 2 -m 1 -t 1 -xType edge_case_2\n./gen -n 1000 -m 120 -t 10000 -xType edge_case_2\n\n# Mix of random sizes\n./gen -n 100 -m 60 -t 1000 -xType random\n./gen -n 100 -m 60 -t 1000 -xType small_numbers\n\n# Maximum capacity\n./gen -n 1000 -m 1 -t 10000 -xType max_capacity\n\n# Various sizes\n./gen -n 10 -m 10 -t 20 -xType random\n./gen -n 10 -m 10 -t 20 -xType multiples_of_m\n\n./gen -n 500 -m 50 -t 5000 -xType max_capacity\n./gen -n 999 -m 2 -t 9999 -xType not_multiples_of_m\n\n# Cases with t at minimum\n./gen -n 2 -m 120 -t 1 -xType random\n./gen -n 3 -m 1 -t 1 -xType small_numbers\n\n# Cases with maximum n and minimum m\n./gen -n 1000 -m 1 -t 10000 -xType random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T19:50:17.033274",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "217/E",
      "title": "E. Инопланетная ДНК",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест2 seconds",
      "memory_limit": "ограничение по памяти на тест256 megabytes",
      "input_spec": "Входные данныеВ первой строке входного файла содержится исходная последовательность ДНК, состоящая из не более чем 3·106 символов «A», «C», «T» и «G». Во второй строке записано единственное целое число k (1 ≤ k ≤ 3·106). В третьей строке записано единственное целое число n (0 ≤ n ≤ 5000) — количество мутаций. Следующие n строк описывают мутации в хронологическом порядке — каждая мутация описывается двумя целыми числами li и ri (1 ≤ li ≤ ri ≤ 109), что означает, что непрерывная подпоследовательность ДНК [li, ri] активировалась и скопировалась, при этом ее копия исказилась и присоединилась. Гарантированно, что входные данные корректны, то есть, никакая мутация не происходит на несуществующей подпоследовательности ДНК, и что итоговая последовательность ДНК содержит не меньше k элементов.Считается, что элементы последовательности ДНК нумеруются, начиная с 1, и что запись [l, r] обозначает непрерывную подпоследовательности последовательности ДНК, состоящую из r - l + 1 элементов, начинающуюся в l-ом элементе последовательности ДНК и заканчивающуюся в r-ом элементе последовательности ДНК.",
      "output_spec": "Выходные данныеВыведите единственную строку, которая содержит первые k букв из мутировавшей последовательности ДНК.",
      "sample_tests": "ПримерыВходные данныеСкопироватьGAGA40Выходные данныеСкопироватьGAGAВходные данныеСкопироватьACGTACGT1621 22 8Выходные данныеСкопироватьACCAGTACCGACATCG",
      "description": "E. Инопланетная ДНК\n\nограничение по времени на тест2 seconds\n\nограничение по времени на тест\n\nограничение по памяти на тест256 megabytes\n\nограничение по памяти на тест\n\nвыводstdout\n\nВходные данныеВ первой строке входного файла содержится исходная последовательность ДНК, состоящая из не более чем 3·106 символов «A», «C», «T» и «G». Во второй строке записано единственное целое число k (1 ≤ k ≤ 3·106). В третьей строке записано единственное целое число n (0 ≤ n ≤ 5000) — количество мутаций. Следующие n строк описывают мутации в хронологическом порядке — каждая мутация описывается двумя целыми числами li и ri (1 ≤ li ≤ ri ≤ 109), что означает, что непрерывная подпоследовательность ДНК [li, ri] активировалась и скопировалась, при этом ее копия исказилась и присоединилась. Гарантированно, что входные данные корректны, то есть, никакая мутация не происходит на несуществующей подпоследовательности ДНК, и что итоговая последовательность ДНК содержит не меньше k элементов.Считается, что элементы последовательности ДНК нумеруются, начиная с 1, и что запись [l, r] обозначает непрерывную подпоследовательности последовательности ДНК, состоящую из r - l + 1 элементов, начинающуюся в l-ом элементе последовательности ДНК и заканчивающуюся в r-ом элементе последовательности ДНК.\n\nВходные данные\n\nВыходные данныеВыведите единственную строку, которая содержит первые k букв из мутировавшей последовательности ДНК.\n\nВыходные данные\n\nВходные данныеСкопироватьGAGA40Выходные данныеСкопироватьGAGAВходные данныеСкопироватьACGTACGT1621 22 8Выходные данныеСкопироватьACCAGTACCGACATCG\n\nВходные данныеСкопироватьGAGA40\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопироватьGAGA\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопироватьACGTACGT1621 22 8\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопироватьACCAGTACCGACATCG\n\nВыходные данныеСкопировать\n\nСкопировать\n\nПримечаниеВо втором примере после первой мутации последовательность превратилась в «ACCAGTACGT». После второй — в «ACCAGTACCGACATCGT».",
      "solutions": [
        {
          "title": "Codeforces Round #134 - Codeforces",
          "content": "Добро пожаловать на Codeforces Round #134!После более чем двух лет, я снова с большим удовольствием выступаю в качестве автора контеста на Codeforces. Большое спасибо Gerald за помощь по подготовке контеста. Я надеюсь, что вы получите удовольствие от решения задач ничуть не меньшее, чем получили мы, пока готовили эти задачи для Вас.В этом раунде будет использована динамическая система оценки задач, при этом задачи будут расположены в порядке их предполагаемой сложности. Верны ли наши предположения? Посмотрим. :-)Всем удачи!P.S. Данный пост является переводом оригинального поста на английском языке. Комментарии на английском приветствуются.Update: Контест закончился! Результаты:First division: rng_58 panyuchaopieguy tourist Petr ACRush Zhukov_Dmitry Все участники из top 7 решили по 3 задачи. Обратите внимание, два участника заняли 2е место.Second division: dsbuaa hqztrue Gullesnuffs Во втором дивизионе 17 участников решили по 4 задачи. Никто не смог сдать задачу E, которая так же была задачей C в первом дивизионе. Эта задача оказалась достаточно хитрой, даже для \"прокаченных\" участников из первого дивизиона.Поздравляем победителей!",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/5083",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 1148
        },
        {
          "title": "Editorial for Codeforces Round #134 - Codeforces",
          "content": "A. Ice SkatingNotice that the existence of a snow drift at the point (x, y) implies that \"if I'm on the horizontal line at y then I am certainly able to get to the vertical line at x, and vice versa\". Thus, the snow drifts are the edges of a bipartite graph between x- and y- coordinates. The number of snow drifts that need to be added to make this (as well as the original) graph connected is the number of its connected components reduced by one.B. Blackboard FibonacciIf you look at the described process backwards, it resembles the Euclidean algorithm a lot. Indeed, if you rewinded a recording of Bajtek's actions, he always takes the larger out of two numbers (say Unable to parse markup [type=CF_TEX]) and replaces them by a - b, b. Since we know one of the final numbers (r) we can simply check all numbers between 1 and r and run a faster version of Euclid's algorithm (one that replaces a, b by ) for all possibilities for a total runtime of . This was one of the expected solutions.However, with some insight, it can be seen that this optimization is in fact not neccessary — we can simply simulate the reverse process as described (replacing a, b by a - b, b) for all candidates between 1 and r and the total runtime of our algorithm will remain . The proof of this fact is left to the reader.C. FormurosaOne of the major difficulties in this problem is finding an easily formulated condition for when Formurosa can be used to distinguish the bacteria. Let Formurosa's digestive process be a function F(s) that maps binary sequences of length m to elements of {0, 1}. It turns out that the condition we seek for can be stated as follows:We can distinguish all the bacteria if and only if there exists a sequence s of length m for which F(s) ≠ F( - s), where  - s is the negation of s.First, not that if no such sequence exists, then there is no way to distinguish between zero and one. If such a sequence exists, we can pick any two bacteria a and b and try both ways to substitute them for 0 and 1 in the expression. If the two expressions evaluate to different values, we will determine the exact types of both bacteria. Otherwise, we will be certain that the bacteria are of the same type. Repeating the process for all pairs of bacteria will let us identify all the types (since it is guaranteed that not all bacteria are of the same type).To determine whether such a sequence s exists, dynamic programming over the expression tree of Formurosa can be applied. The model solution keeps track for each subtree G of the expression which of the following sequences can be found: a sequence s such that G(s) = G( - s) = 0 a sequence s such that G(s) = G( - s) = 1 a sequence s such that G(s) ≠ G( - s) D. Bitonix' PatrolObservation 1.Fuel tanks for which capacity gives the same remainder are equivalent for Bitonix's purposes. Moreover, fuel tanks for which the capacities' remainders sum to D are also equivalent. Out of every group of equivalent tanks, the agency can only leave at most one.Observation 2.If more than six tanks remain, Bitonix can certainly complete his patrol. Indeed, let us assume that 7 tanks were left undestroyed by the agency. Out of the 128 possible subsets of those tanks, at least two distinct ones, say A and B, sum up to the same remainders modulo D. Thus, if Bitonix moves forward with tanks from A - B and backwards with tanks from B - A, he will finish at some station after an actual journey.Because of observations 1 and 2, it turns out that a simple recursive search suffices to solve the problem. However, because of the large constraints, it may prove necessary to use some optimizations, such as using bitmasks for keeping track of what distances Bitonix can cover.E. Alien DNANote that it is easy to determine, looking at only the last mutation, how many letters it adds to the final result. Indeed, if we need to print out the first k letters of the sequence, and the last mutation is [l, r], it suffices to find out the length of the overlap of segments [1, k] and [r + 1, 2r - l + 1]. Say that it is x. Then, after the next to last mutation, we are only interested in the first k - x letters of the result — the rest is irrelevant, as it will become \"pushed out\" by the elements added in the last mutation. Repeating this reasoning going backwards, we shall find out that we can spend linear time adding letters to the result after every mutation, which turns out to be the main idea needed to solve the problem.For a neat O(n2 + k) implementation of this idea you can check out ACRush's solution: 2029369.The only other contestant to solve the problem during the competition, panyuchao, used a slightly different approach, based in part on the same idea. Check out his ingenious, astonishingly short solution here: 2028007.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/5285",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 4782
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #134 - Codeforces - Code 1",
          "code": "Explain, please, D div 2) more than an hour spent on it (",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5083",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #134 - Codeforces - Code 2",
          "code": "eg.\n6 10\nsolve\n10 test 1 to 9\nwhen test 8 must be below:\n10 8\n2 8\n2 6\n2 4\n2 2\nassert not this.\nwhen test 7 must be below:\n10 7\n3 7\n3 4\n3 1\n2 1\n1 1\nhere have two possible, choice best one",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5083",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #134 - Codeforces - Code 3",
          "code": "eg.\n6 10\nsolve\n10 test 1 to 9\nwhen test 8 must be below:\n10 8\n2 8\n2 6\n2 4\n2 2\nassert not this.\nwhen test 7 must be below:\n10 7\n3 7\n3 4\n3 1\n2 1\n1 1\nhere have two possible, choice best one",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5083",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #134 - Codeforces - Code 4",
          "code": "999997 999997",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5083",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #134 - Codeforces - Code 5",
          "code": "www.Ideone.com",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5083",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #134 - Codeforces - Code 6",
          "code": "#pragma comment(linker, “/STACK: 268435456”)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5083",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #134 - Codeforces - Code 7",
          "code": "ax[x]==false",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5083",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #134 - Codeforces - Code 8",
          "code": "ay[y]==false",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5083",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #134 - Codeforces - Code 9",
          "code": "ax[x]=true, ay[y]=true",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5083",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    // Read initial DNA sequence\n    string s = inf.readLine();\n    int slen = (int)s.length();\n    ensuref(1 <= slen && slen <= 3000000, \"Length of DNA sequence must be between 1 and 3e6, but is %d\", slen);\n    for (char c : s) {\n        ensuref(c == 'A' || c == 'C' || c == 'T' || c == 'G', \"DNA sequence contains invalid character '%c'\", c);\n    }\n\n    // Read k\n    int k = inf.readInt(1, 3000000, \"k\");\n    inf.readEoln();\n\n    // Read n\n    int n = inf.readInt(0, 5000, \"n\");\n    inf.readEoln();\n\n    // Initialize current DNA length\n    long long current_length = slen;\n\n    for (int i = 0; i < n; ++i) {\n        // Read li and ri\n        int li = inf.readInt(1, 1000000000, \"li\");\n        inf.readSpace();\n        int ri = inf.readInt(1, 1000000000, \"ri\");\n        inf.readEoln();\n\n        ensuref(li <= ri, \"At mutation %d, li (%d) > ri (%d)\", i+1, li, ri);\n\n        ensuref(li >= 1 && li <= current_length, \"At mutation %d, li (%d) is not in range [1, current length = %lld]\", i+1, li, current_length);\n        ensuref(ri >= 1 && ri <= current_length, \"At mutation %d, ri (%d) is not in range [1, current length = %lld]\", i+1, ri, current_length);\n\n        // Update current_length\n        current_length += (long long)(ri - li + 1);\n    }\n\n    // After all mutations, check that current_length >= k\n    ensuref(current_length >= k, \"Final DNA length %lld is less than k=%d\", current_length, k);\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    // Read initial DNA sequence\n    string s = inf.readLine();\n    int slen = (int)s.length();\n    ensuref(1 <= slen && slen <= 3000000, \"Length of DNA sequence must be between 1 and 3e6, but is %d\", slen);\n    for (char c : s) {\n        ensuref(c == 'A' || c == 'C' || c == 'T' || c == 'G', \"DNA sequence contains invalid character '%c'\", c);\n    }\n\n    // Read k\n    int k = inf.readInt(1, 3000000, \"k\");\n    inf.readEoln();\n\n    // Read n\n    int n = inf.readInt(0, 5000, \"n\");\n    inf.readEoln();\n\n    // Initialize current DNA length\n    long long current_length = slen;\n\n    for (int i = 0; i < n; ++i) {\n        // Read li and ri\n        int li = inf.readInt(1, 1000000000, \"li\");\n        inf.readSpace();\n        int ri = inf.readInt(1, 1000000000, \"ri\");\n        inf.readEoln();\n\n        ensuref(li <= ri, \"At mutation %d, li (%d) > ri (%d)\", i+1, li, ri);\n\n        ensuref(li >= 1 && li <= current_length, \"At mutation %d, li (%d) is not in range [1, current length = %lld]\", i+1, li, current_length);\n        ensuref(ri >= 1 && ri <= current_length, \"At mutation %d, ri (%d) is not in range [1, current length = %lld]\", i+1, ri, current_length);\n\n        // Update current_length\n        current_length += (long long)(ri - li + 1);\n    }\n\n    // After all mutations, check that current_length >= k\n    ensuref(current_length >= k, \"Final DNA length %lld is less than k=%d\", current_length, k);\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    // Read initial DNA sequence\n    string s = inf.readLine();\n    int slen = (int)s.length();\n    ensuref(1 <= slen && slen <= 3000000, \"Length of DNA sequence must be between 1 and 3e6, but is %d\", slen);\n    for (char c : s) {\n        ensuref(c == 'A' || c == 'C' || c == 'T' || c == 'G', \"DNA sequence contains invalid character '%c'\", c);\n    }\n\n    // Read k\n    int k = inf.readInt(1, 3000000, \"k\");\n    inf.readEoln();\n\n    // Read n\n    int n = inf.readInt(0, 5000, \"n\");\n    inf.readEoln();\n\n    // Initialize current DNA length\n    long long current_length = slen;\n\n    for (int i = 0; i < n; ++i) {\n        // Read li and ri\n        int li = inf.readInt(1, 1000000000, \"li\");\n        inf.readSpace();\n        int ri = inf.readInt(1, 1000000000, \"ri\");\n        inf.readEoln();\n\n        ensuref(li <= ri, \"At mutation %d, li (%d) > ri (%d)\", i+1, li, ri);\n\n        ensuref(li >= 1 && li <= current_length, \"At mutation %d, li (%d) is not in range [1, current length = %lld]\", i+1, li, current_length);\n        ensuref(ri >= 1 && ri <= current_length, \"At mutation %d, ri (%d) is not in range [1, current length = %lld]\", i+1, ri, current_length);\n\n        // Update current_length\n        current_length += (long long)(ri - li + 1);\n    }\n\n    // After all mutations, check that current_length >= k\n    ensuref(current_length >= k, \"Final DNA length %lld is less than k=%d\", current_length, k);\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n#include <string>\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare files as sequence of lines\");\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    std::string strAnswer;\r\n\r\n    int n = 0;\r\n    while (!ans.eof()) {\r\n        std::string j = ans.readString();\r\n\r\n        if (j.empty() && ans.eof())\r\n            break;\r\n\r\n        strAnswer = j;\r\n        std::string p = ouf.readString();\r\n\r\n        n++;\r\n\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s lines differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  compress(j).c_str(), compress(p).c_str());\r\n    }\r\n\r\n    if (n == 1)\r\n        quitf(_ok, \"single line: '%s'\", compress(strAnswer).c_str());\r\n\r\n    quitf(_ok, \"%d lines\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst long long MAX_POSITION = 1e9;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int initial_length = opt<int>(\"initial_length\", 1);\n    int n_mutations = opt<int>(\"n_mutations\", 0);\n    int k = opt<int>(\"k\", 1);\n    string type = opt<string>(\"type\", \"random\");\n\n    // Ensure initial_length >= 1 and within limits\n    initial_length = max(1, min(initial_length, 3000000));\n    n_mutations = max(0, min(n_mutations, 5000));\n    k = max(1, min(k, 300000000));\n\n    // Generate initial DNA sequence\n    string DNA;\n    if (type == \"random\" || type == \"max_length\" || type == \"edge_cases\") {\n        DNA.resize(initial_length);\n        for (int i = 0; i < initial_length; ++i) {\n            int r = rnd.next(4);\n            if (r == 0) DNA[i] = 'A';\n            else if (r == 1) DNA[i] = 'C';\n            else if (r == 2) DNA[i] = 'G';\n            else DNA[i] = 'T';\n        }\n    } else if (type == \"repeatedA\") {\n        DNA = string(initial_length, 'A');\n    } else if (type == \"repeatedAC\") {\n        DNA.resize(initial_length);\n        for (int i = 0; i < initial_length; ++i) {\n            DNA[i] = (i % 2 == 0) ? 'A' : 'C';\n        }\n    } else if (type == \"min\") {\n        DNA = string(initial_length, 'A');\n    } else {\n        // Default to random\n        DNA.resize(initial_length);\n        for (int i = 0; i < initial_length; ++i) {\n            int r = rnd.next(4);\n            if (r == 0) DNA[i] = 'A';\n            else if (r == 1) DNA[i] = 'C';\n            else if (r == 2) DNA[i] = 'G';\n            else DNA[i] = 'T';\n        }\n    }\n\n    long long L = initial_length;\n\n    vector<pair<long long, long long>> mutations;\n\n    if (type == \"single_mutation\") {\n        // One mutation activating the whole initial DNA\n        n_mutations = 1;\n        long long max_position = min(L, MAX_POSITION);\n        mutations.emplace_back(1, max_position);\n        L += (max_position); // len_i = max_position\n    } else if (type == \"max_length\") {\n        // Activate entire DNA sequence at each mutation until L >= k\n        for (int i = 0; i < n_mutations; ++i) {\n            long long max_position = min(L, MAX_POSITION);\n            long long l_i = 1;\n            long long r_i = max_position;\n            long long len_i = r_i - l_i + 1;\n            L += len_i;\n            mutations.emplace_back(l_i, r_i);\n            if (L >= k) {\n                ++i;\n                n_mutations = i;\n                break;\n            }\n            // Avoid exceeding maximum positions\n            if (max_position >= MAX_POSITION) break;\n        }\n        n_mutations = mutations.size();\n    } else if (type == \"edge_cases\") {\n        // Mutations with l_i = r_i\n        for (int i = 0; i < n_mutations; ++i) {\n            long long max_position = min(L, MAX_POSITION);\n            long long l_i = rnd.next(1LL, max_position);\n            long long r_i = l_i;\n            long long len_i = 1;\n            L += len_i;\n            mutations.emplace_back(l_i, r_i);\n        }\n    } else {\n        // Random mutations\n        for (int i = 0; i < n_mutations; ++i) {\n            long long max_position = min(L, MAX_POSITION);\n            long long l_i = rnd.next(1LL, max_position);\n            long long r_i = rnd.next(1LL, max_position);\n            if (l_i > r_i) swap(l_i, r_i);\n\n            long long len_i = r_i - l_i + 1;\n            L += len_i;\n            mutations.emplace_back(l_i, r_i);\n\n            // Avoid exceeding maximum total DNA length\n            if (L >= 1e9) {\n                ++i;\n                n_mutations = i;\n                break;\n            }\n        }\n    }\n\n    if (L < k) {\n        // Adjust k to match the total DNA length\n        k = L;\n    }\n\n    // Output the initial DNA sequence\n    printf(\"%s\\n\", DNA.c_str());\n\n    // Output k\n    printf(\"%d\\n\", k);\n\n    // Output n_mutations\n    printf(\"%d\\n\", n_mutations);\n\n    // Output mutations\n    for (const auto& p : mutations) {\n        printf(\"%lld %lld\\n\", p.first, p.second);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst long long MAX_POSITION = 1e9;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int initial_length = opt<int>(\"initial_length\", 1);\n    int n_mutations = opt<int>(\"n_mutations\", 0);\n    int k = opt<int>(\"k\", 1);\n    string type = opt<string>(\"type\", \"random\");\n\n    // Ensure initial_length >= 1 and within limits\n    initial_length = max(1, min(initial_length, 3000000));\n    n_mutations = max(0, min(n_mutations, 5000));\n    k = max(1, min(k, 300000000));\n\n    // Generate initial DNA sequence\n    string DNA;\n    if (type == \"random\" || type == \"max_length\" || type == \"edge_cases\") {\n        DNA.resize(initial_length);\n        for (int i = 0; i < initial_length; ++i) {\n            int r = rnd.next(4);\n            if (r == 0) DNA[i] = 'A';\n            else if (r == 1) DNA[i] = 'C';\n            else if (r == 2) DNA[i] = 'G';\n            else DNA[i] = 'T';\n        }\n    } else if (type == \"repeatedA\") {\n        DNA = string(initial_length, 'A');\n    } else if (type == \"repeatedAC\") {\n        DNA.resize(initial_length);\n        for (int i = 0; i < initial_length; ++i) {\n            DNA[i] = (i % 2 == 0) ? 'A' : 'C';\n        }\n    } else if (type == \"min\") {\n        DNA = string(initial_length, 'A');\n    } else {\n        // Default to random\n        DNA.resize(initial_length);\n        for (int i = 0; i < initial_length; ++i) {\n            int r = rnd.next(4);\n            if (r == 0) DNA[i] = 'A';\n            else if (r == 1) DNA[i] = 'C';\n            else if (r == 2) DNA[i] = 'G';\n            else DNA[i] = 'T';\n        }\n    }\n\n    long long L = initial_length;\n\n    vector<pair<long long, long long>> mutations;\n\n    if (type == \"single_mutation\") {\n        // One mutation activating the whole initial DNA\n        n_mutations = 1;\n        long long max_position = min(L, MAX_POSITION);\n        mutations.emplace_back(1, max_position);\n        L += (max_position); // len_i = max_position\n    } else if (type == \"max_length\") {\n        // Activate entire DNA sequence at each mutation until L >= k\n        for (int i = 0; i < n_mutations; ++i) {\n            long long max_position = min(L, MAX_POSITION);\n            long long l_i = 1;\n            long long r_i = max_position;\n            long long len_i = r_i - l_i + 1;\n            L += len_i;\n            mutations.emplace_back(l_i, r_i);\n            if (L >= k) {\n                ++i;\n                n_mutations = i;\n                break;\n            }\n            // Avoid exceeding maximum positions\n            if (max_position >= MAX_POSITION) break;\n        }\n        n_mutations = mutations.size();\n    } else if (type == \"edge_cases\") {\n        // Mutations with l_i = r_i\n        for (int i = 0; i < n_mutations; ++i) {\n            long long max_position = min(L, MAX_POSITION);\n            long long l_i = rnd.next(1LL, max_position);\n            long long r_i = l_i;\n            long long len_i = 1;\n            L += len_i;\n            mutations.emplace_back(l_i, r_i);\n        }\n    } else {\n        // Random mutations\n        for (int i = 0; i < n_mutations; ++i) {\n            long long max_position = min(L, MAX_POSITION);\n            long long l_i = rnd.next(1LL, max_position);\n            long long r_i = rnd.next(1LL, max_position);\n            if (l_i > r_i) swap(l_i, r_i);\n\n            long long len_i = r_i - l_i + 1;\n            L += len_i;\n            mutations.emplace_back(l_i, r_i);\n\n            // Avoid exceeding maximum total DNA length\n            if (L >= 1e9) {\n                ++i;\n                n_mutations = i;\n                break;\n            }\n        }\n    }\n\n    if (L < k) {\n        // Adjust k to match the total DNA length\n        k = L;\n    }\n\n    // Output the initial DNA sequence\n    printf(\"%s\\n\", DNA.c_str());\n\n    // Output k\n    printf(\"%d\\n\", k);\n\n    // Output n_mutations\n    printf(\"%d\\n\", n_mutations);\n\n    // Output mutations\n    for (const auto& p : mutations) {\n        printf(\"%lld %lld\\n\", p.first, p.second);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Minimal input\n./gen -initial_length 1 -n_mutations 0 -k 1 -type min\n./gen -initial_length 1 -n_mutations 0 -k 1 -type random\n\n# Small random test cases\n./gen -initial_length 10 -n_mutations 5 -k 15 -type random\n./gen -initial_length 20 -n_mutations 10 -k 25 -type random\n\n# Single mutation activating the whole DNA\n./gen -initial_length 100 -n_mutations 1 -k 200 -type single_mutation\n\n# Edge cases with mutations of length 1\n./gen -initial_length 100 -n_mutations 50 -k 150 -type edge_cases\n\n# Maximum initial DNA length without mutations\n./gen -initial_length 3000000 -n_mutations 0 -k 3000000 -type random\n\n# Maximum mutations with small DNA\n./gen -initial_length 10 -n_mutations 5000 -k 50000 -type random\n\n# Mutations that maximize DNA length\n./gen -initial_length 1000 -n_mutations 5000 -k 1000000000 -type max_length\n\n# Mutations activating entire DNA each time\n./gen -initial_length 100000 -n_mutations 100 -k 10000000 -type max_length\n\n# Repeated DNA sequences\n./gen -initial_length 1000 -n_mutations 500 -k 10000 -type repeatedA\n./gen -initial_length 1000 -n_mutations 500 -k 10000 -type repeatedAC\n\n# Random mutations with large k\n./gen -initial_length 100000 -n_mutations 5000 -k 100000000 -type random\n\n# Mutations with positions at maximum allowed value\n./gen -initial_length 3000000 -n_mutations 5000 -k 300000000 -type max_length\n\n# Edge case where DNA length reaches exactly k\n./gen -initial_length 1000 -n_mutations 5000 -k 1000000 -type random\n\n# Testing mutations with l_i = r_i\n./gen -initial_length 1000 -n_mutations 5000 -k 6000 -type edge_cases\n\n# Single mutation with maximum positions\n./gen -initial_length 3000000 -n_mutations 1 -k 6000000 -type single_mutation\n\n# Mutations that don't increase DNA length significantly\n./gen -initial_length 1000000 -n_mutations 5000 -k 1005000 -type edge_cases\n\n# Random small test cases with k larger than total DNA length\n./gen -initial_length 100 -n_mutations 5 -k 1000 -type random\n\n# Testing the limit of positions (positions up to 1e9)\n./gen -initial_length 100000 -n_mutations 5000 -k 100000000 -type random\n\n# Maximize DNA length to the limit\n./gen -initial_length 3000000 -n_mutations 5000 -k 1000000000 -type max_length\n\n# Small initial DNA with maximum mutations\n./gen -initial_length 1 -n_mutations 5000 -k 5000 -type random\n\n# Large initial DNA with no mutations\n./gen -initial_length 3000000 -n_mutations 0 -k 3000000 -type random\n\n# Testing with k equal to initial DNA length\n./gen -initial_length 10000 -n_mutations 0 -k 10000 -type random\n\n# Random mutations with k slightly less than total DNA length\n./gen -initial_length 50000 -n_mutations 2000 -k 100000 -type random\n\n# Mutations activating random positions\n./gen -initial_length 100000 -n_mutations 4000 -k 200000 -type random\n\n# Edge case with mutations after DNA length reaches limit\n./gen -initial_length 1000 -n_mutations 5000 -k 10000000 -type max_length\n\n# Mixing types of DNA sequences\n./gen -initial_length 1000 -n_mutations 1000 -k 5000 -type repeatedA\n./gen -initial_length 1000 -n_mutations 1000 -k 5000 -type repeatedAC\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T19:50:19.197704",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "218/A",
      "title": "A. Mountain Scenery",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains two space-separated integers n and k (1 ≤ k ≤ n ≤ 100). The next line contains 2n + 1 space-separated integers r1, r2, ..., r2n + 1 (0 ≤ ri ≤ 100) — the y coordinates of the polyline vertices on Bolek's picture.It is guaranteed that we can obtain the given picture after performing the described actions on some picture of mountain peaks.",
      "output_spec": "OutputPrint 2n + 1 integers y1, y2, ..., y2n + 1 — the y coordinates of the vertices of the polyline on the initial picture. If there are multiple answers, output any one of them.",
      "sample_tests": "ExamplesInputCopy3 20 5 3 5 1 5 2OutputCopy0 5 3 4 1 4 2 InputCopy1 10 2 0OutputCopy0 1 0",
      "description": "A. Mountain Scenery\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains two space-separated integers n and k (1 ≤ k ≤ n ≤ 100). The next line contains 2n + 1 space-separated integers r1, r2, ..., r2n + 1 (0 ≤ ri ≤ 100) — the y coordinates of the polyline vertices on Bolek's picture.It is guaranteed that we can obtain the given picture after performing the described actions on some picture of mountain peaks.\n\nOutputPrint 2n + 1 integers y1, y2, ..., y2n + 1 — the y coordinates of the vertices of the polyline on the initial picture. If there are multiple answers, output any one of them.\n\nInputCopy3 20 5 3 5 1 5 2OutputCopy0 5 3 4 1 4 2 InputCopy1 10 2 0OutputCopy0 1 0\n\nInputCopy3 20 5 3 5 1 5 2\n\nOutputCopy0 5 3 4 1 4 2\n\nInputCopy1 10 2 0\n\nOutputCopy0 1 0",
      "solutions": [
        {
          "title": "Codeforces Round #134 - Codeforces",
          "content": "Welcome to Codeforces Round #134!After over two years, it is again my great pleasure to be the main problemsetter of a contest on Codeforces. Thanks a lot to Gerald for helping me organize the round. I hope you will enjoy solving the problems as much as we enjoyed preparing them for you.Dynamic scoring will be used, but the problems will be ordered by their expected difficulty, from easiest to hardest. Are our predictions correct? I am eager to see. :-)Good luck!Update: The contest is over! Here are the results:First division: rng_58 panyuchaopieguy tourist Petr ACRush Zhukov_Dmitry All contestants from the top seven solved three problems. Note that there was a tie for second place. :-)Second division dsbuaa hqztrue Gullesnuffs In second division, seventeen contestants solved four problems. Nobody managed to crack E; it was also present in the first division as problem C, and proved tricky even for the experienced competitors.Congratulations to the winners!",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/5083",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 971
        },
        {
          "title": "Editorial for Codeforces Round #134 - Codeforces",
          "content": "A. Ice SkatingNotice that the existence of a snow drift at the point (x, y) implies that \"if I'm on the horizontal line at y then I am certainly able to get to the vertical line at x, and vice versa\". Thus, the snow drifts are the edges of a bipartite graph between x- and y- coordinates. The number of snow drifts that need to be added to make this (as well as the original) graph connected is the number of its connected components reduced by one.B. Blackboard FibonacciIf you look at the described process backwards, it resembles the Euclidean algorithm a lot. Indeed, if you rewinded a recording of Bajtek's actions, he always takes the larger out of two numbers (say Unable to parse markup [type=CF_TEX]) and replaces them by a - b, b. Since we know one of the final numbers (r) we can simply check all numbers between 1 and r and run a faster version of Euclid's algorithm (one that replaces a, b by ) for all possibilities for a total runtime of . This was one of the expected solutions.However, with some insight, it can be seen that this optimization is in fact not neccessary — we can simply simulate the reverse process as described (replacing a, b by a - b, b) for all candidates between 1 and r and the total runtime of our algorithm will remain . The proof of this fact is left to the reader.C. FormurosaOne of the major difficulties in this problem is finding an easily formulated condition for when Formurosa can be used to distinguish the bacteria. Let Formurosa's digestive process be a function F(s) that maps binary sequences of length m to elements of {0, 1}. It turns out that the condition we seek for can be stated as follows:We can distinguish all the bacteria if and only if there exists a sequence s of length m for which F(s) ≠ F( - s), where  - s is the negation of s.First, not that if no such sequence exists, then there is no way to distinguish between zero and one. If such a sequence exists, we can pick any two bacteria a and b and try both ways to substitute them for 0 and 1 in the expression. If the two expressions evaluate to different values, we will determine the exact types of both bacteria. Otherwise, we will be certain that the bacteria are of the same type. Repeating the process for all pairs of bacteria will let us identify all the types (since it is guaranteed that not all bacteria are of the same type).To determine whether such a sequence s exists, dynamic programming over the expression tree of Formurosa can be applied. The model solution keeps track for each subtree G of the expression which of the following sequences can be found: a sequence s such that G(s) = G( - s) = 0 a sequence s such that G(s) = G( - s) = 1 a sequence s such that G(s) ≠ G( - s) D. Bitonix' PatrolObservation 1.Fuel tanks for which capacity gives the same remainder are equivalent for Bitonix's purposes. Moreover, fuel tanks for which the capacities' remainders sum to D are also equivalent. Out of every group of equivalent tanks, the agency can only leave at most one.Observation 2.If more than six tanks remain, Bitonix can certainly complete his patrol. Indeed, let us assume that 7 tanks were left undestroyed by the agency. Out of the 128 possible subsets of those tanks, at least two distinct ones, say A and B, sum up to the same remainders modulo D. Thus, if Bitonix moves forward with tanks from A - B and backwards with tanks from B - A, he will finish at some station after an actual journey.Because of observations 1 and 2, it turns out that a simple recursive search suffices to solve the problem. However, because of the large constraints, it may prove necessary to use some optimizations, such as using bitmasks for keeping track of what distances Bitonix can cover.E. Alien DNANote that it is easy to determine, looking at only the last mutation, how many letters it adds to the final result. Indeed, if we need to print out the first k letters of the sequence, and the last mutation is [l, r], it suffices to find out the length of the overlap of segments [1, k] and [r + 1, 2r - l + 1]. Say that it is x. Then, after the next to last mutation, we are only interested in the first k - x letters of the result — the rest is irrelevant, as it will become \"pushed out\" by the elements added in the last mutation. Repeating this reasoning going backwards, we shall find out that we can spend linear time adding letters to the result after every mutation, which turns out to be the main idea needed to solve the problem.For a neat O(n2 + k) implementation of this idea you can check out ACRush's solution: 2029369.The only other contestant to solve the problem during the competition, panyuchao, used a slightly different approach, based in part on the same idea. Check out his ingenious, astonishingly short solution here: 2028007.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/5285",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 4782
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #134 - Codeforces - Code 1",
          "code": "Explain, please, D div 2) more than an hour spent on it (",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5083",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #134 - Codeforces - Code 2",
          "code": "eg.\n6 10\nsolve\n10 test 1 to 9\nwhen test 8 must be below:\n10 8\n2 8\n2 6\n2 4\n2 2\nassert not this.\nwhen test 7 must be below:\n10 7\n3 7\n3 4\n3 1\n2 1\n1 1\nhere have two possible, choice best one",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5083",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #134 - Codeforces - Code 3",
          "code": "eg.\n6 10\nsolve\n10 test 1 to 9\nwhen test 8 must be below:\n10 8\n2 8\n2 6\n2 4\n2 2\nassert not this.\nwhen test 7 must be below:\n10 7\n3 7\n3 4\n3 1\n2 1\n1 1\nhere have two possible, choice best one",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5083",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #134 - Codeforces - Code 4",
          "code": "999997 999997",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5083",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #134 - Codeforces - Code 5",
          "code": "www.Ideone.com",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5083",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #134 - Codeforces - Code 6",
          "code": "#pragma comment(linker, “/STACK: 268435456”)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5083",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(1, n, \"k\");\n    inf.readEoln();\n\n    vector<int> r = inf.readInts(2 * n + 1, 0, 100, \"r_i\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(1, n, \"k\");\n    inf.readEoln();\n\n    vector<int> r = inf.readInts(2 * n + 1, 0, 100, \"r_i\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(1, n, \"k\");\n    inf.readEoln();\n\n    vector<int> r = inf.readInts(2 * n + 1, 0, 100, \"r_i\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerTestlibCmd(argc, argv);\n\n    // Read n and k from the input file.\n    int n = inf.readInt(1, 100, \"n\");\n    int k = inf.readInt(1, n, \"k\");\n\n    // Read the final polyline r from the input file.\n    // Length is 2n+1, and each r_i is between 0 and 100.\n    vector<int> r = inf.readInts(2 * n + 1, 0, 100, \"r\");\n\n    // The contestant's output should also have 2n+1 integers.\n    // We'll read them all (each y_i between 0 and 100).\n    vector<int> y = ouf.readInts(2 * n + 1, 0, 100, \"y\");\n\n    // 1) Check the \"mountain\" condition for the original picture:\n    //    for each even i (2 <= i <= 2n), y_{i-1} < y_i and y_i > y_{i+1}.\n    for (int i = 2; i <= 2 * n; i += 2) {\n        if (!(y[i - 2] < y[i - 1] && y[i - 1] > y[i])) {\n            quitf(_wa, \"Not a valid mountain at i = %d: y[%d]=%d, y[%d]=%d, y[%d]=%d\",\n                  i, i-1, y[i-2], i, y[i-1], i+1, y[i]);\n        }\n    }\n\n    // 2) Check that exactly k peaks were \"raised by 1\".\n    //    For odd i, r[i-1] must match y[i-1].\n    //    For even i, r[i-1] must be either y[i-1] or y[i-1] + 1.\n    //    Count how many even i's have r[i-1] == y[i-1] + 1.\n    int changedCount = 0;\n    for (int i = 1; i <= 2 * n + 1; i++) {\n        if (i % 2 == 1) {\n            // Odd index: must match exactly\n            if (r[i - 1] != y[i - 1]) {\n                quitf(_wa,\n                      \"Mismatch at odd index i = %d: final r[%d]=%d != y[%d]=%d\",\n                      i, i-1, r[i-1], i-1, y[i-1]);\n            }\n        } else {\n            // Even index (a peak): either unchanged or raised by 1\n            if (r[i - 1] == y[i - 1] + 1) {\n                changedCount++;\n            } else if (r[i - 1] != y[i - 1]) {\n                quitf(_wa,\n                      \"Mismatch at even index i = %d: final r[%d]=%d not in {y[%d], y[%d]+1}\",\n                      i, i-1, r[i-1], i-1, i-1);\n            }\n        }\n    }\n    if (changedCount != k) {\n        quitf(_wa, \"Number of changed peaks = %d, but k = %d\", changedCount, k);\n    }\n\n    // If all checks passed, the output is correct.\n    quitf(_ok, \"Answer is correct\");\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int k = opt<int>(\"k\");\n    string type = opt<string>(\"type\", \"random\");\n\n    // Constraints\n    // 1 ≤ n ≤ 100\n    // 1 ≤ k ≤ n\n\n    if (n < 1 || n > 100) {\n        fprintf(stderr, \"Invalid n: %d\\n\", n);\n        exit(1);\n    }\n\n    if (k < 1 || k > n) {\n        fprintf(stderr, \"Invalid k: %d\\n\", k);\n        exit(1);\n    }\n\n    vector<int> y(2 * n + 1); // y[0..2n]\n\n    if (type == \"random\") {\n        for (int i = 0; i <= 2 * n; ++i) {\n            if (i % 2 == 0) {\n                // Peaks at even indices\n                int min_peak = 1; // Minimum peak height\n                int max_peak = 99; // Maximum peak height to leave room for increment\n                y[i] = rnd.next(min_peak, max_peak);\n            } else {\n                // Valleys at odd indices\n                int max_valley = y[i - 1] - 1; // Must be less than the previous peak\n                int min_valley = 0; // Minimum valley height\n                y[i] = rnd.next(min_valley, max(max_valley, min_valley));\n            }\n        }\n    } else if (type == \"max_height\") {\n        // All peaks have maximum height\n        for (int i = 0; i <= 2 * n; ++i) {\n            if (i % 2 == 0) {\n                y[i] = 99;\n            } else {\n                y[i] = 0;\n            }\n        }\n    } else if (type == \"min_height\") {\n        // All peaks have minimum height\n        for (int i = 0; i <= 2 * n; ++i) {\n            if (i % 2 == 0) {\n                y[i] = 1;\n            } else {\n                y[i] = 0;\n            }\n        }\n    } else if (type == \"equal_heights\") {\n        // All peaks have the same height\n        int peak_height = rnd.next(1, 99);\n        int valley_height = rnd.next(0, peak_height - 1);\n        for (int i = 0; i <= 2 * n; ++i) {\n            if (i % 2 == 0) {\n                y[i] = peak_height;\n            } else {\n                y[i] = valley_height;\n            }\n        }\n    } else if (type == \"uphill\") {\n        // Peaks increase in height\n        int peak_height = 1;\n        for (int i = 0; i <= 2 * n; ++i) {\n            if (i % 2 == 0) {\n                y[i] = min(99, peak_height);\n                peak_height += rnd.next(1, 3); // Increment peak height\n            } else {\n                y[i] = 0;\n            }\n        }\n    } else if (type == \"downhill\") {\n        // Peaks decrease in height\n        int peak_height = 99;\n        for (int i = 0; i <= 2 * n; ++i) {\n            if (i % 2 == 0) {\n                y[i] = max(1, peak_height);\n                peak_height -= rnd.next(1, 3); // Decrease peak height\n            } else {\n                y[i] = 0;\n            }\n        }\n    } else if (type == \"zigzag\") {\n        // Peaks alternate between high and low\n        for (int i = 0; i <= 2 * n; ++i) {\n            if (i % 2 == 0) {\n                y[i] = (i / 2) % 2 == 0 ? 99 : 1;\n            } else {\n                y[i] = 0;\n            }\n        }\n    } else if (type == \"flat\") {\n        // All points have the same height initially\n        int height = rnd.next(0, 99);\n        for (int i = 0; i <= 2 * n; ++i) {\n            y[i] = height;\n        }\n        // Adjust peaks to satisfy yi-1 < yi > yi+1\n        for (int i = 2; i <= 2 * n - 1; i += 2) {\n            if (y[i - 1] >= y[i]) y[i] = y[i - 1] + 1;\n            if (y[i] >= y[i + 1]) y[i + 1] = y[i] - 1;\n        }\n    } else {\n        fprintf(stderr, \"Unknown type: %s\\n\", type.c_str());\n        exit(1);\n    }\n\n    // Ensure y_i <= 99 for peaks to allow increment without exceeding 100\n    for (int i = 0; i <= 2 * n; ++i) {\n        if (i % 2 == 0 && y[i] > 99) {\n            y[i] = 99;\n        }\n    }\n\n    // Now pick k peaks to increase\n    vector<int> peaks;\n    for (int i = 2; i <= 2 * n; i += 2) {\n        peaks.push_back(i);\n    }\n    shuffle(peaks.begin(), peaks.end());\n    vector<int> increase_peaks(peaks.begin(), peaks.begin() + k);\n    set<int> increase_set(increase_peaks.begin(), increase_peaks.end());\n\n    // Create ri = y_i after increasing chosen peaks\n    vector<int> r = y;\n\n    for (int i : increase_peaks) {\n        if (y[i] + 1 <= 100) {\n            r[i] = y[i] + 1;\n        }\n    }\n\n    // Output n and k\n    printf(\"%d %d\\n\", n, k);\n\n    // Output r1, r2, ..., r2n+1\n    for (int i = 0; i <= 2 * n; ++i) {\n        printf(\"%d\", r[i]);\n        if (i < 2 * n) printf(\" \");\n        else printf(\"\\n\");\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int k = opt<int>(\"k\");\n    string type = opt<string>(\"type\", \"random\");\n\n    // Constraints\n    // 1 ≤ n ≤ 100\n    // 1 ≤ k ≤ n\n\n    if (n < 1 || n > 100) {\n        fprintf(stderr, \"Invalid n: %d\\n\", n);\n        exit(1);\n    }\n\n    if (k < 1 || k > n) {\n        fprintf(stderr, \"Invalid k: %d\\n\", k);\n        exit(1);\n    }\n\n    vector<int> y(2 * n + 1); // y[0..2n]\n\n    if (type == \"random\") {\n        for (int i = 0; i <= 2 * n; ++i) {\n            if (i % 2 == 0) {\n                // Peaks at even indices\n                int min_peak = 1; // Minimum peak height\n                int max_peak = 99; // Maximum peak height to leave room for increment\n                y[i] = rnd.next(min_peak, max_peak);\n            } else {\n                // Valleys at odd indices\n                int max_valley = y[i - 1] - 1; // Must be less than the previous peak\n                int min_valley = 0; // Minimum valley height\n                y[i] = rnd.next(min_valley, max(max_valley, min_valley));\n            }\n        }\n    } else if (type == \"max_height\") {\n        // All peaks have maximum height\n        for (int i = 0; i <= 2 * n; ++i) {\n            if (i % 2 == 0) {\n                y[i] = 99;\n            } else {\n                y[i] = 0;\n            }\n        }\n    } else if (type == \"min_height\") {\n        // All peaks have minimum height\n        for (int i = 0; i <= 2 * n; ++i) {\n            if (i % 2 == 0) {\n                y[i] = 1;\n            } else {\n                y[i] = 0;\n            }\n        }\n    } else if (type == \"equal_heights\") {\n        // All peaks have the same height\n        int peak_height = rnd.next(1, 99);\n        int valley_height = rnd.next(0, peak_height - 1);\n        for (int i = 0; i <= 2 * n; ++i) {\n            if (i % 2 == 0) {\n                y[i] = peak_height;\n            } else {\n                y[i] = valley_height;\n            }\n        }\n    } else if (type == \"uphill\") {\n        // Peaks increase in height\n        int peak_height = 1;\n        for (int i = 0; i <= 2 * n; ++i) {\n            if (i % 2 == 0) {\n                y[i] = min(99, peak_height);\n                peak_height += rnd.next(1, 3); // Increment peak height\n            } else {\n                y[i] = 0;\n            }\n        }\n    } else if (type == \"downhill\") {\n        // Peaks decrease in height\n        int peak_height = 99;\n        for (int i = 0; i <= 2 * n; ++i) {\n            if (i % 2 == 0) {\n                y[i] = max(1, peak_height);\n                peak_height -= rnd.next(1, 3); // Decrease peak height\n            } else {\n                y[i] = 0;\n            }\n        }\n    } else if (type == \"zigzag\") {\n        // Peaks alternate between high and low\n        for (int i = 0; i <= 2 * n; ++i) {\n            if (i % 2 == 0) {\n                y[i] = (i / 2) % 2 == 0 ? 99 : 1;\n            } else {\n                y[i] = 0;\n            }\n        }\n    } else if (type == \"flat\") {\n        // All points have the same height initially\n        int height = rnd.next(0, 99);\n        for (int i = 0; i <= 2 * n; ++i) {\n            y[i] = height;\n        }\n        // Adjust peaks to satisfy yi-1 < yi > yi+1\n        for (int i = 2; i <= 2 * n - 1; i += 2) {\n            if (y[i - 1] >= y[i]) y[i] = y[i - 1] + 1;\n            if (y[i] >= y[i + 1]) y[i + 1] = y[i] - 1;\n        }\n    } else {\n        fprintf(stderr, \"Unknown type: %s\\n\", type.c_str());\n        exit(1);\n    }\n\n    // Ensure y_i <= 99 for peaks to allow increment without exceeding 100\n    for (int i = 0; i <= 2 * n; ++i) {\n        if (i % 2 == 0 && y[i] > 99) {\n            y[i] = 99;\n        }\n    }\n\n    // Now pick k peaks to increase\n    vector<int> peaks;\n    for (int i = 2; i <= 2 * n; i += 2) {\n        peaks.push_back(i);\n    }\n    shuffle(peaks.begin(), peaks.end());\n    vector<int> increase_peaks(peaks.begin(), peaks.begin() + k);\n    set<int> increase_set(increase_peaks.begin(), increase_peaks.end());\n\n    // Create ri = y_i after increasing chosen peaks\n    vector<int> r = y;\n\n    for (int i : increase_peaks) {\n        if (y[i] + 1 <= 100) {\n            r[i] = y[i] + 1;\n        }\n    }\n\n    // Output n and k\n    printf(\"%d %d\\n\", n, k);\n\n    // Output r1, r2, ..., r2n+1\n    for (int i = 0; i <= 2 * n; ++i) {\n        printf(\"%d\", r[i]);\n        if (i < 2 * n) printf(\" \");\n        else printf(\"\\n\");\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -k 1 -type random\n./gen -n 1 -k 1 -type max_height\n./gen -n 1 -k 1 -type min_height\n./gen -n 1 -k 1 -type equal_heights\n./gen -n 1 -k 1 -type flat\n\n./gen -n 2 -k 1 -type random\n./gen -n 2 -k 2 -type random\n\n./gen -n 10 -k 1 -type random\n./gen -n 10 -k 5 -type random\n./gen -n 10 -k 10 -type random\n./gen -n 10 -k 10 -type max_height\n./gen -n 10 -k 1 -type min_height\n./gen -n 10 -k 5 -type equal_heights\n\n./gen -n 50 -k 25 -type random\n./gen -n 50 -k 50 -type random\n./gen -n 50 -k 1 -type max_height\n./gen -n 50 -k 1 -type min_height\n./gen -n 50 -k 10 -type uphill\n./gen -n 50 -k 10 -type downhill\n./gen -n 50 -k 10 -type zigzag\n\n./gen -n 70 -k 35 -type random\n./gen -n 70 -k 35 -type equal_heights\n./gen -n 70 -k 35 -type max_height\n./gen -n 70 -k 35 -type min_height\n./gen -n 70 -k 35 -type uphill\n./gen -n 70 -k 35 -type downhill\n./gen -n 70 -k 35 -type zigzag\n\n./gen -n 99 -k 50 -type random\n./gen -n 99 -k 99 -type zigzag\n\n./gen -n 100 -k 1 -type random\n./gen -n 100 -k 50 -type random\n./gen -n 100 -k 100 -type random\n./gen -n 100 -k 1 -type max_height\n./gen -n 100 -k 100 -type max_height\n./gen -n 100 -k 1 -type min_height\n./gen -n 100 -k 50 -type min_height\n\n./gen -n 100 -k 10 -type uphill\n./gen -n 100 -k 10 -type downhill\n./gen -n 100 -k 10 -type zigzag\n./gen -n 100 -k 100 -type equal_heights\n./gen -n 100 -k 100 -type flat\n./gen -n 100 -k 50 -type flat\n./gen -n 100 -k 100 -type uphill\n./gen -n 100 -k 100 -type downhill\n./gen -n 100 -k 100 -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T19:50:20.861310",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "218/B",
      "title": "B. Airport",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains two integers n and m (1 ≤ n, m ≤ 1000) — the number of passengers in the queue and the number of planes in the airport, correspondingly. The next line contains m integers a1, a2, ..., am (1 ≤ ai ≤ 1000) — ai stands for the number of empty seats in the i-th plane before the ticket office starts selling tickets.The numbers in the lines are separated by a space. It is guaranteed that there are at least n empty seats in total.",
      "output_spec": "OutputPrint two integers — the maximum and the minimum number of zlotys that the airport administration can earn, correspondingly.",
      "sample_tests": "ExamplesInputCopy4 32 1 1OutputCopy5 5InputCopy4 32 2 2OutputCopy7 6",
      "description": "time limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains two integers n and m (1 ≤ n, m ≤ 1000) — the number of passengers in the queue and the number of planes in the airport, correspondingly. The next line contains m integers a1, a2, ..., am (1 ≤ ai ≤ 1000) — ai stands for the number of empty seats in the i-th plane before the ticket office starts selling tickets.The numbers in the lines are separated by a space. It is guaranteed that there are at least n empty seats in total.\n\nOutputPrint two integers — the maximum and the minimum number of zlotys that the airport administration can earn, correspondingly.\n\nInputCopy4 32 1 1OutputCopy5 5InputCopy4 32 2 2OutputCopy7 6\n\nInputCopy4 32 1 1\n\nOutputCopy5 5\n\nInputCopy4 32 2 2\n\nOutputCopy7 6\n\nNoteIn the first test sample the number of passengers is equal to the number of empty seats, so regardless of the way the planes are chosen, the administration will earn the same sum.In the second sample the sum is maximized if the 1-st person in the queue buys a ticket to the 1-st plane, the 2-nd person — to the 2-nd plane, the 3-rd person — to the 3-rd plane, the 4-th person — to the 1-st plane. The sum is minimized if the 1-st person in the queue buys a ticket to the 1-st plane, the 2-nd person — to the 1-st plane, the 3-rd person — to the 2-nd plane, the 4-th person — to the 2-nd plane.",
      "solutions": [
        {
          "title": "Codeforces Round #134 - Codeforces",
          "content": "Welcome to Codeforces Round #134!After over two years, it is again my great pleasure to be the main problemsetter of a contest on Codeforces. Thanks a lot to Gerald for helping me organize the round. I hope you will enjoy solving the problems as much as we enjoyed preparing them for you.Dynamic scoring will be used, but the problems will be ordered by their expected difficulty, from easiest to hardest. Are our predictions correct? I am eager to see. :-)Good luck!Update: The contest is over! Here are the results:First division: rng_58 panyuchaopieguy tourist Petr ACRush Zhukov_Dmitry All contestants from the top seven solved three problems. Note that there was a tie for second place. :-)Second division dsbuaa hqztrue Gullesnuffs In second division, seventeen contestants solved four problems. Nobody managed to crack E; it was also present in the first division as problem C, and proved tricky even for the experienced competitors.Congratulations to the winners!",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/5083",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 971
        },
        {
          "title": "Editorial for Codeforces Round #134 - Codeforces",
          "content": "A. Ice SkatingNotice that the existence of a snow drift at the point (x, y) implies that \"if I'm on the horizontal line at y then I am certainly able to get to the vertical line at x, and vice versa\". Thus, the snow drifts are the edges of a bipartite graph between x- and y- coordinates. The number of snow drifts that need to be added to make this (as well as the original) graph connected is the number of its connected components reduced by one.B. Blackboard FibonacciIf you look at the described process backwards, it resembles the Euclidean algorithm a lot. Indeed, if you rewinded a recording of Bajtek's actions, he always takes the larger out of two numbers (say Unable to parse markup [type=CF_TEX]) and replaces them by a - b, b. Since we know one of the final numbers (r) we can simply check all numbers between 1 and r and run a faster version of Euclid's algorithm (one that replaces a, b by ) for all possibilities for a total runtime of . This was one of the expected solutions.However, with some insight, it can be seen that this optimization is in fact not neccessary — we can simply simulate the reverse process as described (replacing a, b by a - b, b) for all candidates between 1 and r and the total runtime of our algorithm will remain . The proof of this fact is left to the reader.C. FormurosaOne of the major difficulties in this problem is finding an easily formulated condition for when Formurosa can be used to distinguish the bacteria. Let Formurosa's digestive process be a function F(s) that maps binary sequences of length m to elements of {0, 1}. It turns out that the condition we seek for can be stated as follows:We can distinguish all the bacteria if and only if there exists a sequence s of length m for which F(s) ≠ F( - s), where  - s is the negation of s.First, not that if no such sequence exists, then there is no way to distinguish between zero and one. If such a sequence exists, we can pick any two bacteria a and b and try both ways to substitute them for 0 and 1 in the expression. If the two expressions evaluate to different values, we will determine the exact types of both bacteria. Otherwise, we will be certain that the bacteria are of the same type. Repeating the process for all pairs of bacteria will let us identify all the types (since it is guaranteed that not all bacteria are of the same type).To determine whether such a sequence s exists, dynamic programming over the expression tree of Formurosa can be applied. The model solution keeps track for each subtree G of the expression which of the following sequences can be found: a sequence s such that G(s) = G( - s) = 0 a sequence s such that G(s) = G( - s) = 1 a sequence s such that G(s) ≠ G( - s) D. Bitonix' PatrolObservation 1.Fuel tanks for which capacity gives the same remainder are equivalent for Bitonix's purposes. Moreover, fuel tanks for which the capacities' remainders sum to D are also equivalent. Out of every group of equivalent tanks, the agency can only leave at most one.Observation 2.If more than six tanks remain, Bitonix can certainly complete his patrol. Indeed, let us assume that 7 tanks were left undestroyed by the agency. Out of the 128 possible subsets of those tanks, at least two distinct ones, say A and B, sum up to the same remainders modulo D. Thus, if Bitonix moves forward with tanks from A - B and backwards with tanks from B - A, he will finish at some station after an actual journey.Because of observations 1 and 2, it turns out that a simple recursive search suffices to solve the problem. However, because of the large constraints, it may prove necessary to use some optimizations, such as using bitmasks for keeping track of what distances Bitonix can cover.E. Alien DNANote that it is easy to determine, looking at only the last mutation, how many letters it adds to the final result. Indeed, if we need to print out the first k letters of the sequence, and the last mutation is [l, r], it suffices to find out the length of the overlap of segments [1, k] and [r + 1, 2r - l + 1]. Say that it is x. Then, after the next to last mutation, we are only interested in the first k - x letters of the result — the rest is irrelevant, as it will become \"pushed out\" by the elements added in the last mutation. Repeating this reasoning going backwards, we shall find out that we can spend linear time adding letters to the result after every mutation, which turns out to be the main idea needed to solve the problem.For a neat O(n2 + k) implementation of this idea you can check out ACRush's solution: 2029369.The only other contestant to solve the problem during the competition, panyuchao, used a slightly different approach, based in part on the same idea. Check out his ingenious, astonishingly short solution here: 2028007.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/5285",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 4782
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #134 - Codeforces - Code 1",
          "code": "Explain, please, D div 2) more than an hour spent on it (",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5083",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #134 - Codeforces - Code 2",
          "code": "eg.\n6 10\nsolve\n10 test 1 to 9\nwhen test 8 must be below:\n10 8\n2 8\n2 6\n2 4\n2 2\nassert not this.\nwhen test 7 must be below:\n10 7\n3 7\n3 4\n3 1\n2 1\n1 1\nhere have two possible, choice best one",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5083",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #134 - Codeforces - Code 3",
          "code": "eg.\n6 10\nsolve\n10 test 1 to 9\nwhen test 8 must be below:\n10 8\n2 8\n2 6\n2 4\n2 2\nassert not this.\nwhen test 7 must be below:\n10 7\n3 7\n3 4\n3 1\n2 1\n1 1\nhere have two possible, choice best one",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5083",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #134 - Codeforces - Code 4",
          "code": "999997 999997",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5083",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #134 - Codeforces - Code 5",
          "code": "www.Ideone.com",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5083",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #134 - Codeforces - Code 6",
          "code": "#pragma comment(linker, “/STACK: 268435456”)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5083",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 1000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 1000, \"m\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(m, 1, 1000, \"a\");\n    inf.readEoln();\n\n    int sum = 0;\n    for (int i = 0; i < m; i++) {\n        sum += a[i];\n    }\n    ensuref(sum >= n, \"Total number of seats (%d) must be at least n (%d)\", sum, n);\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 1000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 1000, \"m\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(m, 1, 1000, \"a\");\n    inf.readEoln();\n\n    int sum = 0;\n    for (int i = 0; i < m; i++) {\n        sum += a[i];\n    }\n    ensuref(sum >= n, \"Total number of seats (%d) must be at least n (%d)\", sum, n);\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 1000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 1000, \"m\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(m, 1, 1000, \"a\");\n    inf.readEoln();\n\n    int sum = 0;\n    for (int i = 0; i < m; i++) {\n        sum += a[i];\n    }\n    ensuref(sum >= n, \"Total number of seats (%d) must be at least n (%d)\", sum, n);\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> ai(m, 1); // initialize capacities to 1\n\n    int total = m; // sum of ai's to start with (all 1's)\n\n    if (type == \"random\") {\n        // Generate random capacities between 1 and 1000\n        while (total < n) {\n            int i = rnd.next(0, m - 1);\n            if (ai[i] < 1000) {\n                ai[i]++;\n                total++;\n            }\n        }\n    } else if (type == \"max_capacity\") {\n        // Set planes with maximum possible capacities to accommodate n passengers\n        ai.assign(m, 0);\n        int n_remaining = n;\n        for (int i = 0; i < m && n_remaining > 0; ++i) {\n            int cap = min(1000, n_remaining);\n            ai[i] = cap;\n            n_remaining -= cap;\n            total += cap;\n        }\n        total = n;\n    } else if (type == \"min_capacity\") {\n        // All planes have capacity 1\n        if (m < n) {\n            fprintf(stderr, \"Cannot generate min_capacity with given n and m\\n\");\n            exit(1);\n        }\n        ai.assign(m, 1);\n        total = m;\n    } else if (type == \"equal_capacity\") {\n        int capacity = (n + m - 1) / m; // Ceil division\n        if (capacity > 1000) {\n            fprintf(stderr, \"Cannot generate equal_capacity with given n and m\\n\");\n            exit(1);\n        }\n        ai.assign(m, capacity);\n        total = capacity * m;\n\n        int extra = n - (capacity * m);\n        for (int i = 0; i < m && extra > 0; ++i) {\n            if (ai[i] < 1000) {\n                ai[i]++;\n                total++;\n                extra--;\n            }\n        }\n    } else if (type == \"increasing_capacity\") {\n        total = 0;\n        int cap = 1;\n        for (int i = 0; i < m; ++i) {\n            ai[i] = cap;\n            total += ai[i];\n            if (cap < 1000)\n                cap++;\n        }\n        while (total < n) {\n            if (ai[m - 1] < 1000) {\n                ai[m - 1]++;\n                total++;\n            } else {\n                fprintf(stderr, \"Cannot increase capacities to meet n\\n\");\n                exit(1);\n            }\n        }\n    } else if (type == \"decreasing_capacity\") {\n        total = 0;\n        int cap = min(1000, n);\n        for (int i = 0; i < m; ++i) {\n            ai[i] = cap;\n            total += ai[i];\n            if (cap > 1)\n                cap--;\n        }\n        while (total < n) {\n            if (ai[0] < 1000) {\n                ai[0]++;\n                total++;\n            } else {\n                fprintf(stderr, \"Cannot increase capacities to meet n\\n\");\n                exit(1);\n            }\n        }\n    } else if (type == \"one_big_rest_small\") {\n        int big_capacity = n - (m - 1);\n        if (big_capacity > 1000 || big_capacity < 1) {\n            fprintf(stderr, \"Cannot generate one_big_rest_small with given n and m\\n\");\n            exit(1);\n        }\n        ai[0] = big_capacity;\n        for (int i = 1; i < m; ++i) {\n            ai[i] = 1;\n        }\n        total = n;\n    } else {\n        fprintf(stderr, \"Unknown type: %s\\n\", type.c_str());\n        exit(1);\n    }\n\n    if (total < n) {\n        fprintf(stderr, \"Total capacity less than n after generation\\n\");\n        exit(1);\n    }\n\n    printf(\"%d %d\\n\", n, m);\n    for (int i = 0; i < m; ++i) {\n        printf(\"%d\", ai[i]);\n        if (i < m - 1) printf(\" \");\n    }\n    printf(\"\\n\");\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> ai(m, 1); // initialize capacities to 1\n\n    int total = m; // sum of ai's to start with (all 1's)\n\n    if (type == \"random\") {\n        // Generate random capacities between 1 and 1000\n        while (total < n) {\n            int i = rnd.next(0, m - 1);\n            if (ai[i] < 1000) {\n                ai[i]++;\n                total++;\n            }\n        }\n    } else if (type == \"max_capacity\") {\n        // Set planes with maximum possible capacities to accommodate n passengers\n        ai.assign(m, 0);\n        int n_remaining = n;\n        for (int i = 0; i < m && n_remaining > 0; ++i) {\n            int cap = min(1000, n_remaining);\n            ai[i] = cap;\n            n_remaining -= cap;\n            total += cap;\n        }\n        total = n;\n    } else if (type == \"min_capacity\") {\n        // All planes have capacity 1\n        if (m < n) {\n            fprintf(stderr, \"Cannot generate min_capacity with given n and m\\n\");\n            exit(1);\n        }\n        ai.assign(m, 1);\n        total = m;\n    } else if (type == \"equal_capacity\") {\n        int capacity = (n + m - 1) / m; // Ceil division\n        if (capacity > 1000) {\n            fprintf(stderr, \"Cannot generate equal_capacity with given n and m\\n\");\n            exit(1);\n        }\n        ai.assign(m, capacity);\n        total = capacity * m;\n\n        int extra = n - (capacity * m);\n        for (int i = 0; i < m && extra > 0; ++i) {\n            if (ai[i] < 1000) {\n                ai[i]++;\n                total++;\n                extra--;\n            }\n        }\n    } else if (type == \"increasing_capacity\") {\n        total = 0;\n        int cap = 1;\n        for (int i = 0; i < m; ++i) {\n            ai[i] = cap;\n            total += ai[i];\n            if (cap < 1000)\n                cap++;\n        }\n        while (total < n) {\n            if (ai[m - 1] < 1000) {\n                ai[m - 1]++;\n                total++;\n            } else {\n                fprintf(stderr, \"Cannot increase capacities to meet n\\n\");\n                exit(1);\n            }\n        }\n    } else if (type == \"decreasing_capacity\") {\n        total = 0;\n        int cap = min(1000, n);\n        for (int i = 0; i < m; ++i) {\n            ai[i] = cap;\n            total += ai[i];\n            if (cap > 1)\n                cap--;\n        }\n        while (total < n) {\n            if (ai[0] < 1000) {\n                ai[0]++;\n                total++;\n            } else {\n                fprintf(stderr, \"Cannot increase capacities to meet n\\n\");\n                exit(1);\n            }\n        }\n    } else if (type == \"one_big_rest_small\") {\n        int big_capacity = n - (m - 1);\n        if (big_capacity > 1000 || big_capacity < 1) {\n            fprintf(stderr, \"Cannot generate one_big_rest_small with given n and m\\n\");\n            exit(1);\n        }\n        ai[0] = big_capacity;\n        for (int i = 1; i < m; ++i) {\n            ai[i] = 1;\n        }\n        total = n;\n    } else {\n        fprintf(stderr, \"Unknown type: %s\\n\", type.c_str());\n        exit(1);\n    }\n\n    if (total < n) {\n        fprintf(stderr, \"Total capacity less than n after generation\\n\");\n        exit(1);\n    }\n\n    printf(\"%d %d\\n\", n, m);\n    for (int i = 0; i < m; ++i) {\n        printf(\"%d\", ai[i]);\n        if (i < m - 1) printf(\" \");\n    }\n    printf(\"\\n\");\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -m 1 -type random\n./gen -n 1 -m 1 -type min_capacity\n./gen -n 2 -m 2 -type max_capacity\n./gen -n 2 -m 5 -type equal_capacity\n./gen -n 2 -m 2 -type one_big_rest_small\n./gen -n 2 -m 2 -type increasing_capacity\n./gen -n 2 -m 2 -type decreasing_capacity\n\n./gen -n 10 -m 5 -type random\n./gen -n 10 -m 5 -type max_capacity\n./gen -n 10 -m 20 -type min_capacity\n./gen -n 10 -m 4 -type equal_capacity\n./gen -n 10 -m 5 -type increasing_capacity\n./gen -n 10 -m 5 -type decreasing_capacity\n./gen -n 10 -m 5 -type one_big_rest_small\n\n./gen -n 1000 -m 500 -type random\n./gen -n 1000 -m 1000 -type random\n./gen -n 1000 -m 1 -type max_capacity\n./gen -n 1000 -m 1000 -type min_capacity\n./gen -n 1000 -m 10 -type equal_capacity\n./gen -n 1000 -m 50 -type increasing_capacity\n./gen -n 1000 -m 50 -type decreasing_capacity\n./gen -n 1000 -m 100 -type one_big_rest_small\n\n./gen -n 1 -m 1 -type random\n./gen -n 1 -m 1 -type min_capacity\n./gen -n 1000 -m 1000 -type random\n./gen -n 1000 -m 1000 -type min_capacity\n\n./gen -n 1000 -m 500 -type random\n./gen -n 1000 -m 500 -type max_capacity\n./gen -n 25 -m 25 -type equal_capacity\n./gen -n 999 -m 1 -type one_big_rest_small\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T19:50:22.446273",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "218/C",
      "title": "C. Ice Skating",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line of input contains a single integer n (1 ≤ n ≤ 100) — the number of snow drifts. Each of the following n lines contains two integers xi and yi (1 ≤ xi, yi ≤ 1000) — the coordinates of the i-th snow drift.Note that the north direction coinсides with the direction of Oy axis, so the east direction coinсides with the direction of the Ox axis. All snow drift's locations are distinct.",
      "output_spec": "OutputOutput the minimal number of snow drifts that need to be created in order for Bajtek to be able to reach any snow drift from any other one.",
      "sample_tests": "ExamplesInputCopy22 11 2OutputCopy1InputCopy22 14 1OutputCopy0",
      "description": "C. Ice Skating\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line of input contains a single integer n (1 ≤ n ≤ 100) — the number of snow drifts. Each of the following n lines contains two integers xi and yi (1 ≤ xi, yi ≤ 1000) — the coordinates of the i-th snow drift.Note that the north direction coinсides with the direction of Oy axis, so the east direction coinсides with the direction of the Ox axis. All snow drift's locations are distinct.\n\nOutputOutput the minimal number of snow drifts that need to be created in order for Bajtek to be able to reach any snow drift from any other one.\n\nInputCopy22 11 2OutputCopy1InputCopy22 14 1OutputCopy0\n\nInputCopy22 11 2\n\nOutputCopy1\n\nInputCopy22 14 1\n\nOutputCopy0",
      "solutions": [
        {
          "title": "Codeforces Round #134 - Codeforces",
          "content": "Welcome to Codeforces Round #134!After over two years, it is again my great pleasure to be the main problemsetter of a contest on Codeforces. Thanks a lot to Gerald for helping me organize the round. I hope you will enjoy solving the problems as much as we enjoyed preparing them for you.Dynamic scoring will be used, but the problems will be ordered by their expected difficulty, from easiest to hardest. Are our predictions correct? I am eager to see. :-)Good luck!Update: The contest is over! Here are the results:First division: rng_58 panyuchaopieguy tourist Petr ACRush Zhukov_Dmitry All contestants from the top seven solved three problems. Note that there was a tie for second place. :-)Second division dsbuaa hqztrue Gullesnuffs In second division, seventeen contestants solved four problems. Nobody managed to crack E; it was also present in the first division as problem C, and proved tricky even for the experienced competitors.Congratulations to the winners!",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/5083",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 971
        },
        {
          "title": "Editorial for Codeforces Round #134 - Codeforces",
          "content": "A. Ice SkatingNotice that the existence of a snow drift at the point (x, y) implies that \"if I'm on the horizontal line at y then I am certainly able to get to the vertical line at x, and vice versa\". Thus, the snow drifts are the edges of a bipartite graph between x- and y- coordinates. The number of snow drifts that need to be added to make this (as well as the original) graph connected is the number of its connected components reduced by one.B. Blackboard FibonacciIf you look at the described process backwards, it resembles the Euclidean algorithm a lot. Indeed, if you rewinded a recording of Bajtek's actions, he always takes the larger out of two numbers (say Unable to parse markup [type=CF_TEX]) and replaces them by a - b, b. Since we know one of the final numbers (r) we can simply check all numbers between 1 and r and run a faster version of Euclid's algorithm (one that replaces a, b by ) for all possibilities for a total runtime of . This was one of the expected solutions.However, with some insight, it can be seen that this optimization is in fact not neccessary — we can simply simulate the reverse process as described (replacing a, b by a - b, b) for all candidates between 1 and r and the total runtime of our algorithm will remain . The proof of this fact is left to the reader.C. FormurosaOne of the major difficulties in this problem is finding an easily formulated condition for when Formurosa can be used to distinguish the bacteria. Let Formurosa's digestive process be a function F(s) that maps binary sequences of length m to elements of {0, 1}. It turns out that the condition we seek for can be stated as follows:We can distinguish all the bacteria if and only if there exists a sequence s of length m for which F(s) ≠ F( - s), where  - s is the negation of s.First, not that if no such sequence exists, then there is no way to distinguish between zero and one. If such a sequence exists, we can pick any two bacteria a and b and try both ways to substitute them for 0 and 1 in the expression. If the two expressions evaluate to different values, we will determine the exact types of both bacteria. Otherwise, we will be certain that the bacteria are of the same type. Repeating the process for all pairs of bacteria will let us identify all the types (since it is guaranteed that not all bacteria are of the same type).To determine whether such a sequence s exists, dynamic programming over the expression tree of Formurosa can be applied. The model solution keeps track for each subtree G of the expression which of the following sequences can be found: a sequence s such that G(s) = G( - s) = 0 a sequence s such that G(s) = G( - s) = 1 a sequence s such that G(s) ≠ G( - s) D. Bitonix' PatrolObservation 1.Fuel tanks for which capacity gives the same remainder are equivalent for Bitonix's purposes. Moreover, fuel tanks for which the capacities' remainders sum to D are also equivalent. Out of every group of equivalent tanks, the agency can only leave at most one.Observation 2.If more than six tanks remain, Bitonix can certainly complete his patrol. Indeed, let us assume that 7 tanks were left undestroyed by the agency. Out of the 128 possible subsets of those tanks, at least two distinct ones, say A and B, sum up to the same remainders modulo D. Thus, if Bitonix moves forward with tanks from A - B and backwards with tanks from B - A, he will finish at some station after an actual journey.Because of observations 1 and 2, it turns out that a simple recursive search suffices to solve the problem. However, because of the large constraints, it may prove necessary to use some optimizations, such as using bitmasks for keeping track of what distances Bitonix can cover.E. Alien DNANote that it is easy to determine, looking at only the last mutation, how many letters it adds to the final result. Indeed, if we need to print out the first k letters of the sequence, and the last mutation is [l, r], it suffices to find out the length of the overlap of segments [1, k] and [r + 1, 2r - l + 1]. Say that it is x. Then, after the next to last mutation, we are only interested in the first k - x letters of the result — the rest is irrelevant, as it will become \"pushed out\" by the elements added in the last mutation. Repeating this reasoning going backwards, we shall find out that we can spend linear time adding letters to the result after every mutation, which turns out to be the main idea needed to solve the problem.For a neat O(n2 + k) implementation of this idea you can check out ACRush's solution: 2029369.The only other contestant to solve the problem during the competition, panyuchao, used a slightly different approach, based in part on the same idea. Check out his ingenious, astonishingly short solution here: 2028007.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/5285",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 4782
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #134 - Codeforces - Code 1",
          "code": "Explain, please, D div 2) more than an hour spent on it (",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5083",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #134 - Codeforces - Code 2",
          "code": "eg.\n6 10\nsolve\n10 test 1 to 9\nwhen test 8 must be below:\n10 8\n2 8\n2 6\n2 4\n2 2\nassert not this.\nwhen test 7 must be below:\n10 7\n3 7\n3 4\n3 1\n2 1\n1 1\nhere have two possible, choice best one",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5083",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #134 - Codeforces - Code 3",
          "code": "eg.\n6 10\nsolve\n10 test 1 to 9\nwhen test 8 must be below:\n10 8\n2 8\n2 6\n2 4\n2 2\nassert not this.\nwhen test 7 must be below:\n10 7\n3 7\n3 4\n3 1\n2 1\n1 1\nhere have two possible, choice best one",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5083",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #134 - Codeforces - Code 4",
          "code": "999997 999997",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5083",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #134 - Codeforces - Code 5",
          "code": "www.Ideone.com",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5083",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #134 - Codeforces - Code 6",
          "code": "#pragma comment(linker, “/STACK: 268435456”)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5083",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readEoln();\n\n    set<pair<int, int>> coordinates;\n    for(int i = 0; i < n; i++) {\n        int xi = inf.readInt(1, 1000, \"xi\");\n        inf.readSpace();\n        int yi = inf.readInt(1, 1000, \"yi\");\n        inf.readEoln();\n\n        ensuref(coordinates.insert({xi, yi}).second, \"The position (%d, %d) occurs more than once\", xi, yi);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readEoln();\n\n    set<pair<int, int>> coordinates;\n    for(int i = 0; i < n; i++) {\n        int xi = inf.readInt(1, 1000, \"xi\");\n        inf.readSpace();\n        int yi = inf.readInt(1, 1000, \"yi\");\n        inf.readEoln();\n\n        ensuref(coordinates.insert({xi, yi}).second, \"The position (%d, %d) occurs more than once\", xi, yi);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readEoln();\n\n    set<pair<int, int>> coordinates;\n    for(int i = 0; i < n; i++) {\n        int xi = inf.readInt(1, 1000, \"xi\");\n        inf.readSpace();\n        int yi = inf.readInt(1, 1000, \"yi\");\n        inf.readEoln();\n\n        ensuref(coordinates.insert({xi, yi}).second, \"The position (%d, %d) occurs more than once\", xi, yi);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n    int clusters = opt<int>(\"clusters\", 2); // For clusters type\n\n    vector<pair<int,int>> drifts;\n\n    if (type == \"random\") {\n        // Generate n random positions\n        set<pair<int,int>> positions;\n        while ((int)positions.size() < n) {\n            int x = rnd.next(1, 1000);\n            int y = rnd.next(1, 1000);\n            positions.insert(make_pair(x, y));\n        }\n        drifts.assign(positions.begin(), positions.end());\n    } else if (type == \"line\") {\n        // All drifts are in a straight line\n        int x0 = rnd.next(1, 1000 - n);\n        int y0 = rnd.next(1, 1000 - n);\n        bool horizontal = rnd.next(0, 1);\n        for (int i = 0; i < n; ++i) {\n            if (horizontal)\n                drifts.push_back({x0 + i, y0});\n            else\n                drifts.push_back({x0, y0 + i});\n        }\n    } else if (type == \"grid\") {\n        // Create a grid\n        int gridSize = (int)sqrt(n);\n        if (gridSize * gridSize < n)\n            ++gridSize;\n        set<pair<int,int>> positions;\n        int x0 = rnd.next(1, 1000 - gridSize);\n        int y0 = rnd.next(1, 1000 - gridSize);\n        for (int i = 0; i < gridSize && (int)positions.size() < n; ++i) {\n            for (int j = 0; j < gridSize && (int)positions.size() < n; ++j) {\n                int x = x0 + i;\n                int y = y0 + j;\n                positions.insert({x, y});\n            }\n        }\n        drifts.assign(positions.begin(), positions.end());\n    } else if (type == \"clusters\") {\n        // Create several clusters\n        int total_clusters = min(clusters, n);\n        int drifts_per_cluster = n / total_clusters;\n        int remainder = n % total_clusters;\n        for (int c = 0; c < total_clusters; ++c) {\n            int cluster_size = drifts_per_cluster + (c < remainder ? 1 : 0);\n            int x_center = rnd.next(1, 1000);\n            int y_center = rnd.next(1, 1000);\n            set<pair<int,int>> positions;\n            while ((int)positions.size() < cluster_size) {\n                int x = rnd.next(max(x_center - 5, 1), min(x_center + 5, 1000));\n                int y = rnd.next(max(y_center - 5, 1), min(y_center + 5, 1000));\n                positions.insert({x, y});\n            }\n            drifts.insert(drifts.end(), positions.begin(), positions.end());\n        }\n        // Remove duplicates in case of overlapping clusters\n        sort(drifts.begin(), drifts.end());\n        drifts.erase(unique(drifts.begin(), drifts.end()), drifts.end());\n        // Ensure we have exactly n drifts\n        while ((int)drifts.size() < n) {\n            int x = rnd.next(1, 1000);\n            int y = rnd.next(1, 1000);\n            drifts.push_back({x, y});\n        }\n        if ((int)drifts.size() > n) {\n            drifts.resize(n);\n        }\n    } else if (type == \"max_components\") {\n        // Generate drifts so that each drift is in its own connected component\n        // i.e., no two drifts align vertically or horizontally\n        set<pair<int,int>> positions;\n        while ((int)positions.size() < n) {\n            int x = rnd.next(1, 1000);\n            int y = rnd.next(1, 1000);\n            // Ensure no other drift has the same x or y\n            bool conflict = false;\n            for (const auto& p : positions) {\n                if (p.first == x || p.second == y) {\n                    conflict = true;\n                    break;\n                }\n            }\n            if (!conflict) {\n                positions.insert({x, y});\n            }\n        }\n        drifts.assign(positions.begin(), positions.end());\n    } else {\n        // Default to random\n        // Generate n random positions\n        set<pair<int,int>> positions;\n        while ((int)positions.size() < n) {\n            int x = rnd.next(1, 1000);\n            int y = rnd.next(1, 1000);\n            positions.insert(make_pair(x, y));\n        }\n        drifts.assign(positions.begin(), positions.end());\n    }\n\n    // Output the drifts\n\n    printf(\"%d\\n\", (int)drifts.size());\n    for (const auto& p : drifts) {\n        printf(\"%d %d\\n\", p.first, p.second);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n    int clusters = opt<int>(\"clusters\", 2); // For clusters type\n\n    vector<pair<int,int>> drifts;\n\n    if (type == \"random\") {\n        // Generate n random positions\n        set<pair<int,int>> positions;\n        while ((int)positions.size() < n) {\n            int x = rnd.next(1, 1000);\n            int y = rnd.next(1, 1000);\n            positions.insert(make_pair(x, y));\n        }\n        drifts.assign(positions.begin(), positions.end());\n    } else if (type == \"line\") {\n        // All drifts are in a straight line\n        int x0 = rnd.next(1, 1000 - n);\n        int y0 = rnd.next(1, 1000 - n);\n        bool horizontal = rnd.next(0, 1);\n        for (int i = 0; i < n; ++i) {\n            if (horizontal)\n                drifts.push_back({x0 + i, y0});\n            else\n                drifts.push_back({x0, y0 + i});\n        }\n    } else if (type == \"grid\") {\n        // Create a grid\n        int gridSize = (int)sqrt(n);\n        if (gridSize * gridSize < n)\n            ++gridSize;\n        set<pair<int,int>> positions;\n        int x0 = rnd.next(1, 1000 - gridSize);\n        int y0 = rnd.next(1, 1000 - gridSize);\n        for (int i = 0; i < gridSize && (int)positions.size() < n; ++i) {\n            for (int j = 0; j < gridSize && (int)positions.size() < n; ++j) {\n                int x = x0 + i;\n                int y = y0 + j;\n                positions.insert({x, y});\n            }\n        }\n        drifts.assign(positions.begin(), positions.end());\n    } else if (type == \"clusters\") {\n        // Create several clusters\n        int total_clusters = min(clusters, n);\n        int drifts_per_cluster = n / total_clusters;\n        int remainder = n % total_clusters;\n        for (int c = 0; c < total_clusters; ++c) {\n            int cluster_size = drifts_per_cluster + (c < remainder ? 1 : 0);\n            int x_center = rnd.next(1, 1000);\n            int y_center = rnd.next(1, 1000);\n            set<pair<int,int>> positions;\n            while ((int)positions.size() < cluster_size) {\n                int x = rnd.next(max(x_center - 5, 1), min(x_center + 5, 1000));\n                int y = rnd.next(max(y_center - 5, 1), min(y_center + 5, 1000));\n                positions.insert({x, y});\n            }\n            drifts.insert(drifts.end(), positions.begin(), positions.end());\n        }\n        // Remove duplicates in case of overlapping clusters\n        sort(drifts.begin(), drifts.end());\n        drifts.erase(unique(drifts.begin(), drifts.end()), drifts.end());\n        // Ensure we have exactly n drifts\n        while ((int)drifts.size() < n) {\n            int x = rnd.next(1, 1000);\n            int y = rnd.next(1, 1000);\n            drifts.push_back({x, y});\n        }\n        if ((int)drifts.size() > n) {\n            drifts.resize(n);\n        }\n    } else if (type == \"max_components\") {\n        // Generate drifts so that each drift is in its own connected component\n        // i.e., no two drifts align vertically or horizontally\n        set<pair<int,int>> positions;\n        while ((int)positions.size() < n) {\n            int x = rnd.next(1, 1000);\n            int y = rnd.next(1, 1000);\n            // Ensure no other drift has the same x or y\n            bool conflict = false;\n            for (const auto& p : positions) {\n                if (p.first == x || p.second == y) {\n                    conflict = true;\n                    break;\n                }\n            }\n            if (!conflict) {\n                positions.insert({x, y});\n            }\n        }\n        drifts.assign(positions.begin(), positions.end());\n    } else {\n        // Default to random\n        // Generate n random positions\n        set<pair<int,int>> positions;\n        while ((int)positions.size() < n) {\n            int x = rnd.next(1, 1000);\n            int y = rnd.next(1, 1000);\n            positions.insert(make_pair(x, y));\n        }\n        drifts.assign(positions.begin(), positions.end());\n    }\n\n    // Output the drifts\n\n    printf(\"%d\\n\", (int)drifts.size());\n    for (const auto& p : drifts) {\n        printf(\"%d %d\\n\", p.first, p.second);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -type random\n./gen -n 2 -type random\n./gen -n 5 -type random\n./gen -n 10 -type random\n./gen -n 20 -type random\n./gen -n 50 -type random\n./gen -n 100 -type random\n\n./gen -n 1 -type line\n./gen -n 2 -type line\n./gen -n 5 -type line\n./gen -n 10 -type line\n./gen -n 20 -type line\n./gen -n 50 -type line\n./gen -n 100 -type line\n\n./gen -n 1 -type grid\n./gen -n 4 -type grid\n./gen -n 9 -type grid\n./gen -n 16 -type grid\n./gen -n 25 -type grid\n./gen -n 50 -type grid\n./gen -n 100 -type grid\n\n./gen -n 10 -type clusters -clusters 2\n./gen -n 20 -type clusters -clusters 4\n./gen -n 50 -type clusters -clusters 5\n./gen -n 100 -type clusters -clusters 10\n./gen -n 100 -type clusters -clusters 50\n./gen -n 100 -type clusters -clusters 1\n./gen -n 100 -type clusters -clusters 100\n\n./gen -n 1 -type max_components\n./gen -n 2 -type max_components\n./gen -n 5 -type max_components\n./gen -n 10 -type max_components\n./gen -n 20 -type max_components\n./gen -n 50 -type max_components\n./gen -n 100 -type max_components\n\n# Edge cases with overlapping clusters\n./gen -n 100 -type clusters -clusters 200\n\n# Random small test cases\n./gen -n 3 -type random\n./gen -n 7 -type random\n./gen -n 1 -type clusters -clusters 1\n\n# Maximize connected components for edge testing\n./gen -n 100 -type max_components\n\n# Mixed test cases\n./gen -n 30 -type grid\n./gen -n 30 -type clusters -clusters 3\n./gen -n 40 -type line\n./gen -n 40 -type clusters -clusters 8\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T19:50:24.716150",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "218/D",
      "title": "D. Фибоначчи на Доске",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест1 секунда",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеПервая строка содержит два целых числа n и r (1 ≤ n, r ≤ 106).",
      "output_spec": "Выходные данныеПервая строка выходного файла должна содержать единственное число — наименьшее возможное количество ошибок, допущенное Байтеком. Вторая строка должна содержать n символов, начинающихся с «T», описывающих одну из возможных последовательностей операций с таким количеством ошибок. Каждый символ должен быть либо «T», либо «B».Если искомой последовательности не существует, выведите «IMPOSSIBLE» (без кавычек).",
      "sample_tests": "ПримерыВходные данныеСкопировать6 10Выходные данныеСкопировать2TBBTTBВходные данныеСкопировать4 5Выходные данныеСкопировать0TBTBВходные данныеСкопировать2 1Выходные данныеСкопироватьIMPOSSIBLE",
      "description": "D. Фибоначчи на Доске\n\nограничение по времени на тест1 секунда\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвыводstdout\n\nВходные данныеПервая строка содержит два целых числа n и r (1 ≤ n, r ≤ 106).\n\nВходные данные\n\nВыходные данныеПервая строка выходного файла должна содержать единственное число — наименьшее возможное количество ошибок, допущенное Байтеком. Вторая строка должна содержать n символов, начинающихся с «T», описывающих одну из возможных последовательностей операций с таким количеством ошибок. Каждый символ должен быть либо «T», либо «B».Если искомой последовательности не существует, выведите «IMPOSSIBLE» (без кавычек).\n\nВыходные данные\n\nВходные данныеСкопировать6 10Выходные данныеСкопировать2TBBTTBВходные данныеСкопировать4 5Выходные данныеСкопировать0TBTBВходные данныеСкопировать2 1Выходные данныеСкопироватьIMPOSSIBLE\n\nВходные данныеСкопировать6 10\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать2TBBTTB\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать4 5\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать0TBTB\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать2 1\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопироватьIMPOSSIBLE\n\nВыходные данныеСкопировать\n\nСкопировать",
      "solutions": [
        {
          "title": "Codeforces Round #134 - Codeforces",
          "content": "Добро пожаловать на Codeforces Round #134!После более чем двух лет, я снова с большим удовольствием выступаю в качестве автора контеста на Codeforces. Большое спасибо Gerald за помощь по подготовке контеста. Я надеюсь, что вы получите удовольствие от решения задач ничуть не меньшее, чем получили мы, пока готовили эти задачи для Вас.В этом раунде будет использована динамическая система оценки задач, при этом задачи будут расположены в порядке их предполагаемой сложности. Верны ли наши предположения? Посмотрим. :-)Всем удачи!P.S. Данный пост является переводом оригинального поста на английском языке. Комментарии на английском приветствуются.Update: Контест закончился! Результаты:First division: rng_58 panyuchaopieguy tourist Petr ACRush Zhukov_Dmitry Все участники из top 7 решили по 3 задачи. Обратите внимание, два участника заняли 2е место.Second division: dsbuaa hqztrue Gullesnuffs Во втором дивизионе 17 участников решили по 4 задачи. Никто не смог сдать задачу E, которая так же была задачей C в первом дивизионе. Эта задача оказалась достаточно хитрой, даже для \"прокаченных\" участников из первого дивизиона.Поздравляем победителей!",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/5083",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 1148
        },
        {
          "title": "Editorial for Codeforces Round #134 - Codeforces",
          "content": "A. Ice SkatingNotice that the existence of a snow drift at the point (x, y) implies that \"if I'm on the horizontal line at y then I am certainly able to get to the vertical line at x, and vice versa\". Thus, the snow drifts are the edges of a bipartite graph between x- and y- coordinates. The number of snow drifts that need to be added to make this (as well as the original) graph connected is the number of its connected components reduced by one.B. Blackboard FibonacciIf you look at the described process backwards, it resembles the Euclidean algorithm a lot. Indeed, if you rewinded a recording of Bajtek's actions, he always takes the larger out of two numbers (say Unable to parse markup [type=CF_TEX]) and replaces them by a - b, b. Since we know one of the final numbers (r) we can simply check all numbers between 1 and r and run a faster version of Euclid's algorithm (one that replaces a, b by ) for all possibilities for a total runtime of . This was one of the expected solutions.However, with some insight, it can be seen that this optimization is in fact not neccessary — we can simply simulate the reverse process as described (replacing a, b by a - b, b) for all candidates between 1 and r and the total runtime of our algorithm will remain . The proof of this fact is left to the reader.C. FormurosaOne of the major difficulties in this problem is finding an easily formulated condition for when Formurosa can be used to distinguish the bacteria. Let Formurosa's digestive process be a function F(s) that maps binary sequences of length m to elements of {0, 1}. It turns out that the condition we seek for can be stated as follows:We can distinguish all the bacteria if and only if there exists a sequence s of length m for which F(s) ≠ F( - s), where  - s is the negation of s.First, not that if no such sequence exists, then there is no way to distinguish between zero and one. If such a sequence exists, we can pick any two bacteria a and b and try both ways to substitute them for 0 and 1 in the expression. If the two expressions evaluate to different values, we will determine the exact types of both bacteria. Otherwise, we will be certain that the bacteria are of the same type. Repeating the process for all pairs of bacteria will let us identify all the types (since it is guaranteed that not all bacteria are of the same type).To determine whether such a sequence s exists, dynamic programming over the expression tree of Formurosa can be applied. The model solution keeps track for each subtree G of the expression which of the following sequences can be found: a sequence s such that G(s) = G( - s) = 0 a sequence s such that G(s) = G( - s) = 1 a sequence s such that G(s) ≠ G( - s) D. Bitonix' PatrolObservation 1.Fuel tanks for which capacity gives the same remainder are equivalent for Bitonix's purposes. Moreover, fuel tanks for which the capacities' remainders sum to D are also equivalent. Out of every group of equivalent tanks, the agency can only leave at most one.Observation 2.If more than six tanks remain, Bitonix can certainly complete his patrol. Indeed, let us assume that 7 tanks were left undestroyed by the agency. Out of the 128 possible subsets of those tanks, at least two distinct ones, say A and B, sum up to the same remainders modulo D. Thus, if Bitonix moves forward with tanks from A - B and backwards with tanks from B - A, he will finish at some station after an actual journey.Because of observations 1 and 2, it turns out that a simple recursive search suffices to solve the problem. However, because of the large constraints, it may prove necessary to use some optimizations, such as using bitmasks for keeping track of what distances Bitonix can cover.E. Alien DNANote that it is easy to determine, looking at only the last mutation, how many letters it adds to the final result. Indeed, if we need to print out the first k letters of the sequence, and the last mutation is [l, r], it suffices to find out the length of the overlap of segments [1, k] and [r + 1, 2r - l + 1]. Say that it is x. Then, after the next to last mutation, we are only interested in the first k - x letters of the result — the rest is irrelevant, as it will become \"pushed out\" by the elements added in the last mutation. Repeating this reasoning going backwards, we shall find out that we can spend linear time adding letters to the result after every mutation, which turns out to be the main idea needed to solve the problem.For a neat O(n2 + k) implementation of this idea you can check out ACRush's solution: 2029369.The only other contestant to solve the problem during the competition, panyuchao, used a slightly different approach, based in part on the same idea. Check out his ingenious, astonishingly short solution here: 2028007.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/5285",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 4782
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #134 - Codeforces - Code 1",
          "code": "Explain, please, D div 2) more than an hour spent on it (",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5083",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #134 - Codeforces - Code 2",
          "code": "eg.\n6 10\nsolve\n10 test 1 to 9\nwhen test 8 must be below:\n10 8\n2 8\n2 6\n2 4\n2 2\nassert not this.\nwhen test 7 must be below:\n10 7\n3 7\n3 4\n3 1\n2 1\n1 1\nhere have two possible, choice best one",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5083",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #134 - Codeforces - Code 3",
          "code": "eg.\n6 10\nsolve\n10 test 1 to 9\nwhen test 8 must be below:\n10 8\n2 8\n2 6\n2 4\n2 2\nassert not this.\nwhen test 7 must be below:\n10 7\n3 7\n3 4\n3 1\n2 1\n1 1\nhere have two possible, choice best one",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5083",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #134 - Codeforces - Code 4",
          "code": "999997 999997",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5083",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #134 - Codeforces - Code 5",
          "code": "www.Ideone.com",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5083",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #134 - Codeforces - Code 6",
          "code": "#pragma comment(linker, “/STACK: 268435456”)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5083",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #134 - Codeforces - Code 7",
          "code": "ax[x]==false",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5083",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #134 - Codeforces - Code 8",
          "code": "ay[y]==false",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5083",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #134 - Codeforces - Code 9",
          "code": "ax[x]=true, ay[y]=true",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5083",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 1000000, \"n\");\n    inf.readSpace();\n    int r = inf.readInt(1, 1000000, \"r\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 1000000, \"n\");\n    inf.readSpace();\n    int r = inf.readInt(1, 1000000, \"r\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 1000000, \"n\");\n    inf.readSpace();\n    int r = inf.readInt(1, 1000000, \"r\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long int64;\n\nint main(int argc, char* argv[]) {\n    registerTestlibCmd(argc, argv);\n    // Read n and r from input file\n    int n = inf.readInt(1, 1000000, \"n\");\n    inf.readSpace();\n    int r = inf.readInt(1, 1000000, \"r\");\n    inf.readEoln();\n    inf.readEof();\n\n    // Read jury's answer\n    bool juryImpossible = false;\n    int juryMistakes = -1;\n    ans.seekEof();\n    ans.reset();\n    string juryFirstLine = ans.readLine();\n    if (juryFirstLine == \"IMPOSSIBLE\") {\n        juryImpossible = true;\n    } else {\n        InStream& a = ans;\n        a.reset();\n        juryMistakes = a.readInt(0, n - 1, \"jury's minimal mistakes\");\n        a.readEoln();\n        string jurySeq = a.readToken();\n        if ((int)jurySeq.size() != n) {\n            ans.quitf(_fail, \"Jury's sequence length invalid: expected %d, found %d\", n, (int)jurySeq.size());\n        }\n        a.readEoln();\n        a.readEof();\n    }\n\n    // Read participant's answer\n    bool participantImpossible = false;\n    int participantMistakes = -1;\n    ouf.seekEof();\n    ouf.reset();\n    string participantFirstLine = ouf.readLine();\n    if (participantFirstLine == \"IMPOSSIBLE\") {\n        participantImpossible = true;\n    } else {\n        InStream& o = ouf;\n        o.reset();\n        participantMistakes = o.readInt(0, n - 1, \"participant's minimal mistakes\");\n        o.readEoln();\n        string participantSeq = o.readToken();\n        if ((int)participantSeq.size() != n) {\n            ouf.quitf(_wa, \"Participant's sequence length invalid: expected %d, found %d\", n, (int)participantSeq.size());\n        }\n        o.readEoln();\n        o.readEof();\n\n        // Validate participant's sequence\n        if (participantSeq[0] != 'T') {\n            quitf(_wa, \"Participant's sequence does not start with 'T'\");\n        }\n        int mistakes = 0;\n        for (int i = 0; i < n; ++i) {\n            if (participantSeq[i] != 'T' && participantSeq[i] != 'B') {\n                quitf(_wa, \"Participant's sequence contains invalid character '%c' at position %d\", participantSeq[i], i + 1);\n            }\n            if (i > 0 && participantSeq[i] == participantSeq[i - 1]) {\n                mistakes++;\n            }\n        }\n        if (mistakes != participantMistakes) {\n            quitf(_wa, \"Participant's sequence has incorrect number of mistakes, expected %d, found %d\", participantMistakes, mistakes);\n        }\n        // Simulate the sequence\n        int64 top = 0, bottom = 1;\n        for (int i = 0; i < n; ++i) {\n            int64 sum = top + bottom;\n            if (participantSeq[i] == 'T') {\n                top = sum;\n            } else {\n                bottom = sum;\n            }\n            // Ensure values don't overflow\n            if (top < 0 || bottom < 0 || top > 1e18 || bottom > 1e18) {\n                quitf(_fail, \"Values overflow during simulation\");\n            }\n        }\n        int64 result = (participantSeq.back() == 'T') ? top : bottom;\n        if (result != r) {\n            quitf(_wa, \"Participant's sequence produces incorrect result, expected %d, found %lld\", r, result);\n        }\n    }\n\n    if (juryImpossible) {\n        if (participantImpossible) {\n            quitf(_ok, \"Correctly impossible\");\n        } else {\n            quitf(_wa, \"Participant found a solution, but jury says impossible\");\n        }\n    } else {\n        if (participantImpossible) {\n            quitf(_wa, \"Participant claimed impossible, but jury has a solution\");\n        } else {\n            if (participantMistakes != juryMistakes) {\n                quitf(_wa, \"Participant's minimal number of mistakes is incorrect, expected %d, found %d\", juryMistakes, participantMistakes);\n            }\n            // All checks passed\n            quitf(_ok, \"Correct output\");\n        }\n    }\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\");\n\n    // Define the maximum value of r allowed\n    const int MAX_R = 1e6;\n\n    if (n < 1 || n > 1000000) {\n        cerr << \"Error: n must be between 1 and 1,000,000.\" << endl;\n        return 1;\n    }\n\n    if (type == \"zero_mistakes\") {\n        // For zero mistakes, we need to ensure that r <= MAX_R\n        // Since Fibonacci numbers grow exponentially, we need to limit n\n        if (n > 29) {\n            cerr << \"Error: For zero_mistakes type, n must be <= 29 to ensure r <= 1e6.\" << endl;\n            return 1;\n        }\n\n        // Generate the operation sequence 'T', 'B', 'T', 'B', ...\n        string ops(n, 'T');\n        for (int i = 1; i < n; ++i) {\n            if (i % 2 == 1) ops[i] = 'B';\n        }\n\n        // Simulate the operations\n        int mistakes = 0; // Zero mistakes\n        long long t = 0, b = 1;\n        for (int i = 0; i < n; ++i) {\n            if (ops[i] == 'T') {\n                t = t + b;\n            } else {\n                b = t + b;\n            }\n        }\n        long long r = (ops[n - 1] == 'T') ? t : b;\n\n        // Check if r is within the allowed range\n        if (r < 1 || r > MAX_R) {\n            cerr << \"Error: Computed r is out of bounds.\" << endl;\n            return 1;\n        }\n\n        // Output n and r\n        printf(\"%d %lld\\n\", n, r);\n    } else if (type == \"max_mistakes\") {\n        // Generate a sequence with maximum mistakes (all 'T's)\n        string ops(n, 'T');\n\n        // Simulate the operations\n        int mistakes = n - 1; // Maximum mistakes\n        long long t = 0, b = 1;\n        for (int i = 0; i < n; ++i) {\n            if (ops[i] == 'T') {\n                t = t + b;\n            } else {\n                b = t + b;\n            }\n            // Check if t or b exceed MAX_R\n            if (t > MAX_R || b > MAX_R) {\n                cerr << \"Error: t or b exceeded MAX_R. Try with smaller n.\" << endl;\n                return 1;\n            }\n        }\n        long long r = (ops[n - 1] == 'T') ? t : b;\n\n        // Output n and r\n        printf(\"%d %lld\\n\", n, r);\n    } else if (type == \"impossible\") {\n        // Output a test case where it's known to be impossible\n        if (n < 1 || n > 1000000) {\n            cerr << \"Error: n must be between 1 and 1,000,000.\" << endl;\n            return 1;\n        }\n        int r = rnd.next(1, MAX_R);\n        // For example, we can use r = 1 for n = 2, which is impossible as per sample input\n        if (n == 2) r = 1;\n        else r = MAX_R; // Use a large r\n        printf(\"%d %d\\n\", n, r);\n    } else if (type == \"random\") {\n        // Generate a random sequence starting with 'T'\n        string ops(n, 'T');\n        int mistakes = 0;\n        for (int i = 1; i < n; ++i) {\n            if (rnd.next(0, 1) == 0) {\n                ops[i] = 'T';\n            } else {\n                ops[i] = 'B';\n            }\n            if (ops[i] == ops[i - 1]) ++mistakes;\n        }\n\n        // Simulate the operations\n        long long t = 0, b = 1;\n        bool valid = true;\n        for (int i = 0; i < n; ++i) {\n            if (ops[i] == 'T') {\n                t = t + b;\n            } else {\n                b = t + b;\n            }\n            if (t > MAX_R || b > MAX_R) {\n                valid = false;\n                break;\n            }\n        }\n\n        if (!valid) {\n            // If t or b exceed MAX_R, output IMPOSSIBLE test case\n            printf(\"%d %d\\n\", n, MAX_R + 1); // r > MAX_R, so IMPOSSIBLE\n        } else {\n            long long r = (ops[n - 1] == 'T') ? t : b;\n            // Output n and r\n            printf(\"%d %lld\\n\", n, r);\n        }\n    } else {\n        cerr << \"Error: Unknown type '\" << type << \"'. Available types are zero_mistakes, max_mistakes, impossible, random.\" << endl;\n        return 1;\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\");\n\n    // Define the maximum value of r allowed\n    const int MAX_R = 1e6;\n\n    if (n < 1 || n > 1000000) {\n        cerr << \"Error: n must be between 1 and 1,000,000.\" << endl;\n        return 1;\n    }\n\n    if (type == \"zero_mistakes\") {\n        // For zero mistakes, we need to ensure that r <= MAX_R\n        // Since Fibonacci numbers grow exponentially, we need to limit n\n        if (n > 29) {\n            cerr << \"Error: For zero_mistakes type, n must be <= 29 to ensure r <= 1e6.\" << endl;\n            return 1;\n        }\n\n        // Generate the operation sequence 'T', 'B', 'T', 'B', ...\n        string ops(n, 'T');\n        for (int i = 1; i < n; ++i) {\n            if (i % 2 == 1) ops[i] = 'B';\n        }\n\n        // Simulate the operations\n        int mistakes = 0; // Zero mistakes\n        long long t = 0, b = 1;\n        for (int i = 0; i < n; ++i) {\n            if (ops[i] == 'T') {\n                t = t + b;\n            } else {\n                b = t + b;\n            }\n        }\n        long long r = (ops[n - 1] == 'T') ? t : b;\n\n        // Check if r is within the allowed range\n        if (r < 1 || r > MAX_R) {\n            cerr << \"Error: Computed r is out of bounds.\" << endl;\n            return 1;\n        }\n\n        // Output n and r\n        printf(\"%d %lld\\n\", n, r);\n    } else if (type == \"max_mistakes\") {\n        // Generate a sequence with maximum mistakes (all 'T's)\n        string ops(n, 'T');\n\n        // Simulate the operations\n        int mistakes = n - 1; // Maximum mistakes\n        long long t = 0, b = 1;\n        for (int i = 0; i < n; ++i) {\n            if (ops[i] == 'T') {\n                t = t + b;\n            } else {\n                b = t + b;\n            }\n            // Check if t or b exceed MAX_R\n            if (t > MAX_R || b > MAX_R) {\n                cerr << \"Error: t or b exceeded MAX_R. Try with smaller n.\" << endl;\n                return 1;\n            }\n        }\n        long long r = (ops[n - 1] == 'T') ? t : b;\n\n        // Output n and r\n        printf(\"%d %lld\\n\", n, r);\n    } else if (type == \"impossible\") {\n        // Output a test case where it's known to be impossible\n        if (n < 1 || n > 1000000) {\n            cerr << \"Error: n must be between 1 and 1,000,000.\" << endl;\n            return 1;\n        }\n        int r = rnd.next(1, MAX_R);\n        // For example, we can use r = 1 for n = 2, which is impossible as per sample input\n        if (n == 2) r = 1;\n        else r = MAX_R; // Use a large r\n        printf(\"%d %d\\n\", n, r);\n    } else if (type == \"random\") {\n        // Generate a random sequence starting with 'T'\n        string ops(n, 'T');\n        int mistakes = 0;\n        for (int i = 1; i < n; ++i) {\n            if (rnd.next(0, 1) == 0) {\n                ops[i] = 'T';\n            } else {\n                ops[i] = 'B';\n            }\n            if (ops[i] == ops[i - 1]) ++mistakes;\n        }\n\n        // Simulate the operations\n        long long t = 0, b = 1;\n        bool valid = true;\n        for (int i = 0; i < n; ++i) {\n            if (ops[i] == 'T') {\n                t = t + b;\n            } else {\n                b = t + b;\n            }\n            if (t > MAX_R || b > MAX_R) {\n                valid = false;\n                break;\n            }\n        }\n\n        if (!valid) {\n            // If t or b exceed MAX_R, output IMPOSSIBLE test case\n            printf(\"%d %d\\n\", n, MAX_R + 1); // r > MAX_R, so IMPOSSIBLE\n        } else {\n            long long r = (ops[n - 1] == 'T') ? t : b;\n            // Output n and r\n            printf(\"%d %lld\\n\", n, r);\n        }\n    } else {\n        cerr << \"Error: Unknown type '\" << type << \"'. Available types are zero_mistakes, max_mistakes, impossible, random.\" << endl;\n        return 1;\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Test cases with zero mistakes\n./gen -n 1 -type zero_mistakes\n./gen -n 5 -type zero_mistakes\n./gen -n 10 -type zero_mistakes\n./gen -n 15 -type zero_mistakes\n./gen -n 20 -type zero_mistakes\n./gen -n 29 -type zero_mistakes\n\n# Test cases with maximum mistakes\n./gen -n 5 -type max_mistakes\n./gen -n 10 -type max_mistakes\n./gen -n 15 -type max_mistakes\n\n# Test cases where it is impossible to find a sequence\n./gen -n 2 -type impossible\n./gen -n 100 -type impossible\n./gen -n 1000 -type impossible\n\n# Random test cases with small n\n./gen -n 10 -type random\n./gen -n 20 -type random\n./gen -n 50 -type random\n./gen -n 100 -type random\n\n# Random test cases with larger n\n./gen -n 1000 -type random\n./gen -n 5000 -type random\n./gen -n 10000 -type random\n./gen -n 20000 -type random\n./gen -n 50000 -type random\n./gen -n 100000 -type random\n\n# Edge cases\n./gen -n 1 -type impossible\n./gen -n 1 -type zero_mistakes\n./gen -n 1 -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T19:50:26.778394",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "218/E",
      "title": "E. Formurosa",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line of input contains a single integer n (2 ≤ n ≤ 106) — the number of colonies of bacteria.The second line contains the formula describing the nutrition process of Formurosa. This line contains only characters «0», «1», «?», «|», «&», «^», «(», «)» and complies with the following grammar:s → 0|1|?|(s|s)|(s&s)|(s^s)The formula consists of no more than 106 characters.",
      "output_spec": "OutputIf it is always possible to determine the species of each colony, output \"YES\" (without quotes). Otherwise, output \"NO\" (without quotes).",
      "sample_tests": "ExamplesInputCopy2(?^?)OutputCopyNOInputCopy10?OutputCopyYESInputCopy2((?^?)&?)OutputCopyYES",
      "description": "E. Formurosa\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line of input contains a single integer n (2 ≤ n ≤ 106) — the number of colonies of bacteria.The second line contains the formula describing the nutrition process of Formurosa. This line contains only characters «0», «1», «?», «|», «&», «^», «(», «)» and complies with the following grammar:s → 0|1|?|(s|s)|(s&s)|(s^s)The formula consists of no more than 106 characters.\n\nOutputIf it is always possible to determine the species of each colony, output \"YES\" (without quotes). Otherwise, output \"NO\" (without quotes).\n\nInputCopy2(?^?)OutputCopyNOInputCopy10?OutputCopyYESInputCopy2((?^?)&?)OutputCopyYES\n\nInputCopy2(?^?)\n\nOutputCopyNO\n\nInputCopy10?\n\nOutputCopyYES\n\nInputCopy2((?^?)&?)\n\nOutputCopyYES",
      "solutions": [
        {
          "title": "Codeforces Round #134 - Codeforces",
          "content": "Welcome to Codeforces Round #134!After over two years, it is again my great pleasure to be the main problemsetter of a contest on Codeforces. Thanks a lot to Gerald for helping me organize the round. I hope you will enjoy solving the problems as much as we enjoyed preparing them for you.Dynamic scoring will be used, but the problems will be ordered by their expected difficulty, from easiest to hardest. Are our predictions correct? I am eager to see. :-)Good luck!Update: The contest is over! Here are the results:First division: rng_58 panyuchaopieguy tourist Petr ACRush Zhukov_Dmitry All contestants from the top seven solved three problems. Note that there was a tie for second place. :-)Second division dsbuaa hqztrue Gullesnuffs In second division, seventeen contestants solved four problems. Nobody managed to crack E; it was also present in the first division as problem C, and proved tricky even for the experienced competitors.Congratulations to the winners!",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/5083",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 971
        },
        {
          "title": "Editorial for Codeforces Round #134 - Codeforces",
          "content": "A. Ice SkatingNotice that the existence of a snow drift at the point (x, y) implies that \"if I'm on the horizontal line at y then I am certainly able to get to the vertical line at x, and vice versa\". Thus, the snow drifts are the edges of a bipartite graph between x- and y- coordinates. The number of snow drifts that need to be added to make this (as well as the original) graph connected is the number of its connected components reduced by one.B. Blackboard FibonacciIf you look at the described process backwards, it resembles the Euclidean algorithm a lot. Indeed, if you rewinded a recording of Bajtek's actions, he always takes the larger out of two numbers (say Unable to parse markup [type=CF_TEX]) and replaces them by a - b, b. Since we know one of the final numbers (r) we can simply check all numbers between 1 and r and run a faster version of Euclid's algorithm (one that replaces a, b by ) for all possibilities for a total runtime of . This was one of the expected solutions.However, with some insight, it can be seen that this optimization is in fact not neccessary — we can simply simulate the reverse process as described (replacing a, b by a - b, b) for all candidates between 1 and r and the total runtime of our algorithm will remain . The proof of this fact is left to the reader.C. FormurosaOne of the major difficulties in this problem is finding an easily formulated condition for when Formurosa can be used to distinguish the bacteria. Let Formurosa's digestive process be a function F(s) that maps binary sequences of length m to elements of {0, 1}. It turns out that the condition we seek for can be stated as follows:We can distinguish all the bacteria if and only if there exists a sequence s of length m for which F(s) ≠ F( - s), where  - s is the negation of s.First, not that if no such sequence exists, then there is no way to distinguish between zero and one. If such a sequence exists, we can pick any two bacteria a and b and try both ways to substitute them for 0 and 1 in the expression. If the two expressions evaluate to different values, we will determine the exact types of both bacteria. Otherwise, we will be certain that the bacteria are of the same type. Repeating the process for all pairs of bacteria will let us identify all the types (since it is guaranteed that not all bacteria are of the same type).To determine whether such a sequence s exists, dynamic programming over the expression tree of Formurosa can be applied. The model solution keeps track for each subtree G of the expression which of the following sequences can be found: a sequence s such that G(s) = G( - s) = 0 a sequence s such that G(s) = G( - s) = 1 a sequence s such that G(s) ≠ G( - s) D. Bitonix' PatrolObservation 1.Fuel tanks for which capacity gives the same remainder are equivalent for Bitonix's purposes. Moreover, fuel tanks for which the capacities' remainders sum to D are also equivalent. Out of every group of equivalent tanks, the agency can only leave at most one.Observation 2.If more than six tanks remain, Bitonix can certainly complete his patrol. Indeed, let us assume that 7 tanks were left undestroyed by the agency. Out of the 128 possible subsets of those tanks, at least two distinct ones, say A and B, sum up to the same remainders modulo D. Thus, if Bitonix moves forward with tanks from A - B and backwards with tanks from B - A, he will finish at some station after an actual journey.Because of observations 1 and 2, it turns out that a simple recursive search suffices to solve the problem. However, because of the large constraints, it may prove necessary to use some optimizations, such as using bitmasks for keeping track of what distances Bitonix can cover.E. Alien DNANote that it is easy to determine, looking at only the last mutation, how many letters it adds to the final result. Indeed, if we need to print out the first k letters of the sequence, and the last mutation is [l, r], it suffices to find out the length of the overlap of segments [1, k] and [r + 1, 2r - l + 1]. Say that it is x. Then, after the next to last mutation, we are only interested in the first k - x letters of the result — the rest is irrelevant, as it will become \"pushed out\" by the elements added in the last mutation. Repeating this reasoning going backwards, we shall find out that we can spend linear time adding letters to the result after every mutation, which turns out to be the main idea needed to solve the problem.For a neat O(n2 + k) implementation of this idea you can check out ACRush's solution: 2029369.The only other contestant to solve the problem during the competition, panyuchao, used a slightly different approach, based in part on the same idea. Check out his ingenious, astonishingly short solution here: 2028007.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/5285",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 4782
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #134 - Codeforces - Code 1",
          "code": "Explain, please, D div 2) more than an hour spent on it (",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5083",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #134 - Codeforces - Code 2",
          "code": "eg.\n6 10\nsolve\n10 test 1 to 9\nwhen test 8 must be below:\n10 8\n2 8\n2 6\n2 4\n2 2\nassert not this.\nwhen test 7 must be below:\n10 7\n3 7\n3 4\n3 1\n2 1\n1 1\nhere have two possible, choice best one",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5083",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #134 - Codeforces - Code 3",
          "code": "eg.\n6 10\nsolve\n10 test 1 to 9\nwhen test 8 must be below:\n10 8\n2 8\n2 6\n2 4\n2 2\nassert not this.\nwhen test 7 must be below:\n10 7\n3 7\n3 4\n3 1\n2 1\n1 1\nhere have two possible, choice best one",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5083",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #134 - Codeforces - Code 4",
          "code": "999997 999997",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5083",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #134 - Codeforces - Code 5",
          "code": "www.Ideone.com",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5083",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #134 - Codeforces - Code 6",
          "code": "#pragma comment(linker, “/STACK: 268435456”)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5083",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring formula;\n\nbool parse(int& pos) {\n    if (pos >= (int)formula.size())\n        return false;\n\n    char c = formula[pos];\n\n    if (c == '0' || c == '1' || c == '?') {\n        pos++;\n        return true;\n    } else if (c == '(') {\n        pos++;\n        if (!parse(pos)) return false;\n        if (pos >= (int)formula.size()) return false;\n\n        c = formula[pos];\n        if (c != '|' && c != '&' && c != '^')\n            return false;\n        pos++;\n        if (!parse(pos)) return false;\n        if (pos >= (int)formula.size()) return false;\n        if (formula[pos] != ')')\n            return false;\n        pos++;\n        return true;\n    } else {\n        return false;\n    }\n}\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(2, 1000000, \"n\");\n    inf.readEoln();\n\n    formula = inf.readLine();\n    ensuref(formula.length() <= 1000000, \"Formula length must be at most 1e6, but is %d\", (int)formula.length());\n\n    for (int i = 0; i < (int)formula.length(); i++) {\n        char c = formula[i];\n        ensuref(c == '0' || c == '1' || c == '?' || c == '|' || c == '&' || c == '^' || c == '(' || c == ')',\n                \"Invalid character '%c' in formula\", c);\n    }\n\n    int pos = 0;\n    ensuref(parse(pos), \"Formula is invalid\");\n    ensuref(pos == (int)formula.length(), \"Extra characters in formula after position %d\", pos);\n\n    inf.readEof();\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring formula;\n\nbool parse(int& pos) {\n    if (pos >= (int)formula.size())\n        return false;\n\n    char c = formula[pos];\n\n    if (c == '0' || c == '1' || c == '?') {\n        pos++;\n        return true;\n    } else if (c == '(') {\n        pos++;\n        if (!parse(pos)) return false;\n        if (pos >= (int)formula.size()) return false;\n\n        c = formula[pos];\n        if (c != '|' && c != '&' && c != '^')\n            return false;\n        pos++;\n        if (!parse(pos)) return false;\n        if (pos >= (int)formula.size()) return false;\n        if (formula[pos] != ')')\n            return false;\n        pos++;\n        return true;\n    } else {\n        return false;\n    }\n}\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(2, 1000000, \"n\");\n    inf.readEoln();\n\n    formula = inf.readLine();\n    ensuref(formula.length() <= 1000000, \"Formula length must be at most 1e6, but is %d\", (int)formula.length());\n\n    for (int i = 0; i < (int)formula.length(); i++) {\n        char c = formula[i];\n        ensuref(c == '0' || c == '1' || c == '?' || c == '|' || c == '&' || c == '^' || c == '(' || c == ')',\n                \"Invalid character '%c' in formula\", c);\n    }\n\n    int pos = 0;\n    ensuref(parse(pos), \"Formula is invalid\");\n    ensuref(pos == (int)formula.length(), \"Extra characters in formula after position %d\", pos);\n\n    inf.readEof();\n\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring formula;\n\nbool parse(int& pos) {\n    if (pos >= (int)formula.size())\n        return false;\n\n    char c = formula[pos];\n\n    if (c == '0' || c == '1' || c == '?') {\n        pos++;\n        return true;\n    } else if (c == '(') {\n        pos++;\n        if (!parse(pos)) return false;\n        if (pos >= (int)formula.size()) return false;\n\n        c = formula[pos];\n        if (c != '|' && c != '&' && c != '^')\n            return false;\n        pos++;\n        if (!parse(pos)) return false;\n        if (pos >= (int)formula.size()) return false;\n        if (formula[pos] != ')')\n            return false;\n        pos++;\n        return true;\n    } else {\n        return false;\n    }\n}\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(2, 1000000, \"n\");\n    inf.readEoln();\n\n    formula = inf.readLine();\n    ensuref(formula.length() <= 1000000, \"Formula length must be at most 1e6, but is %d\", (int)formula.length());\n\n    for (int i = 0; i < (int)formula.length(); i++) {\n        char c = formula[i];\n        ensuref(c == '0' || c == '1' || c == '?' || c == '|' || c == '&' || c == '^' || c == '(' || c == ')',\n                \"Invalid character '%c' in formula\", c);\n    }\n\n    int pos = 0;\n    ensuref(parse(pos), \"Formula is invalid\");\n    ensuref(pos == (int)formula.length(), \"Extra characters in formula after position %d\", pos);\n\n    inf.readEof();\n\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n#include <string>\r\n\r\nusing namespace std;\r\n\r\nconst string YES = \"YES\";\r\nconst string NO = \"NO\";\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"%s\", (\"multiple \" + YES + \"/\" + NO + \" (case insensitive)\").c_str());\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int index = 0, yesCount = 0, noCount = 0;\r\n    string pa;\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        index++;\r\n        string ja = upperCase(ans.readToken());\r\n        pa = upperCase(ouf.readToken());\r\n\r\n        if (ja != YES && ja != NO)\r\n            quitf(_fail, \"%s or %s expected in answer, but %s found [%d%s token]\",\r\n                  YES.c_str(), NO.c_str(), compress(ja).c_str(), index, englishEnding(index).c_str());\r\n\r\n        if (pa == YES)\r\n            yesCount++;\r\n        else if (pa == NO)\r\n            noCount++;\r\n        else\r\n            quitf(_pe, \"%s or %s expected, but %s found [%d%s token]\",\r\n                  YES.c_str(), NO.c_str(), compress(pa).c_str(), index, englishEnding(index).c_str());\r\n\r\n        if (ja != pa)\r\n            quitf(_wa, \"expected %s, found %s [%d%s token]\",\r\n                  compress(ja).c_str(), compress(pa).c_str(), index, englishEnding(index).c_str());\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n    while (!ans.seekEof()) {\r\n        ans.readToken();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n    while (!ouf.seekEof()) {\r\n        ouf.readToken();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              index + extraInAnsCount, index);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              index + extraInOufCount, index);\r\n\r\n    if (index == 0)\r\n        quitf(_ok, \"Empty output\");\r\n    else if (index == 1)\r\n        quitf(_ok, \"%s\", pa.c_str());\r\n    else\r\n        quitf(_ok, \"%d token(s): yes count is %d, no count is %d\", index, yesCount, noCount);\r\n\r\n    quitf(_fail, \"Impossible case\");\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring generateBalancedFormula(int leaves);\nstring generateRandomFormula(int depth = 0);\nstring generateRandomFormulaNoLeaves(int depth = 0);\nstring generateConstantFormula(char c);\nstring generateFormula(int leaves, string formulaType);\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string formulaType = opt<string>(\"type\", \"random\");\n    int leaves = opt<int>(\"leaves\", -1);\n\n    // Output n\n    printf(\"%d\\n\", n);\n    // Generate a formula according to the specified type\n    string formula = generateFormula(leaves, formulaType);\n    // Output formula\n    printf(\"%s\\n\", formula.c_str());\n\n    return 0;\n}\n\nstring generateFormula(int leaves, string formulaType) {\n    if (formulaType == \"constant0\") {\n        // Generate a formula that is just '0'\n        return \"0\";\n    } else if (formulaType == \"constant1\") {\n        // Generate a formula that is just '1'\n        return \"1\";\n    } else if (formulaType == \"single_leaf\") {\n        // Generate a formula with only one '?'\n        return \"?\";\n    } else if (formulaType == \"max_leaves\") {\n        // Generate a formula with maximum number of '?'\n        // Ensure the total formula size does not exceed 1e6 characters\n        int maxSize = 1000000;\n        // total_size = 4 * leaves - 3\n        int leaves = (maxSize + 3) / 4;\n        return generateBalancedFormula(leaves);\n    } else if (formulaType == \"all_zero\") {\n        // Generate a formula that always evaluates to 0\n        // For example, (0&?)\n        return \"(0&?)\";\n    } else if (formulaType == \"all_one\") {\n        // Generate a formula that always evaluates to 1\n        // For example, (1|?)\n        return \"(1|?)\";\n    } else if (formulaType == \"random_constant\") {\n        // Generate a random formula with '0' and '1' only\n        return generateRandomFormulaNoLeaves();\n    } else if (formulaType == \"random\") {\n        // Generate a random formula\n        return generateRandomFormula();\n    } else {\n        // Default: return '?'\n        return \"?\";\n    }\n}\n\nstring generateBalancedFormula(int leaves) {\n    deque<string> nodes;\n    for (int i = 0; i < leaves; ++i) {\n        nodes.push_back(\"?\");\n    }\n\n    string ops = \"|&^\";\n\n    while (nodes.size() > 1) {\n        string left = nodes.front(); nodes.pop_front();\n        string right = nodes.front(); nodes.pop_front();\n        char op = ops[rnd.next(3)]; // Randomly pick an operator\n        string new_node = \"(\" + left + op + right + \")\";\n        nodes.push_back(new_node);\n        // To avoid exceeding memory limits, we can process and remove old strings\n        // But since total formula size is within limits, we're fine\n    }\n\n    return nodes.front();\n}\n\nstring generateRandomFormula(int depth) {\n    // Limit depth to prevent stack overflow\n    if (depth > 20) {\n        // Return a leaf\n        int leafType = rnd.next(3);\n        if (leafType == 0) return \"0\";\n        else if (leafType == 1) return \"1\";\n        else return \"?\";\n    }\n\n    int nodeType = rnd.next(5); // Randomly choose a node type\n    if (nodeType == 0) {\n        // Return a constant '0'\n        return \"0\";\n    } else if (nodeType == 1) {\n        // Return a constant '1'\n        return \"1\";\n    } else if (nodeType == 2) {\n        // Return a leaf '?'\n        return \"?\";\n    } else {\n        // Return an expression with an operator\n        char op = \"|&^\"[rnd.next(3)];\n        string left = generateRandomFormula(depth + 1);\n        string right = generateRandomFormula(depth + 1);\n        return \"(\" + left + op + right + \")\";\n    }\n}\n\nstring generateRandomFormulaNoLeaves(int depth) {\n    // Limit depth to prevent stack overflow\n    if (depth > 20) {\n        // Return a constant\n        int leafType = rnd.next(2);\n        if (leafType == 0) return \"0\";\n        else return \"1\";\n    }\n\n    int nodeType = rnd.next(3); // Randomly choose a node type\n    if (nodeType == 0) {\n        // Return a constant '0'\n        return \"0\";\n    } else if (nodeType == 1) {\n        // Return a constant '1'\n        return \"1\";\n    } else {\n        // Return an expression with an operator\n        char op = \"|&^\"[rnd.next(3)];\n        string left = generateRandomFormulaNoLeaves(depth + 1);\n        string right = generateRandomFormulaNoLeaves(depth + 1);\n        return \"(\" + left + op + right + \")\";\n    }\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring generateBalancedFormula(int leaves);\nstring generateRandomFormula(int depth = 0);\nstring generateRandomFormulaNoLeaves(int depth = 0);\nstring generateConstantFormula(char c);\nstring generateFormula(int leaves, string formulaType);\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string formulaType = opt<string>(\"type\", \"random\");\n    int leaves = opt<int>(\"leaves\", -1);\n\n    // Output n\n    printf(\"%d\\n\", n);\n    // Generate a formula according to the specified type\n    string formula = generateFormula(leaves, formulaType);\n    // Output formula\n    printf(\"%s\\n\", formula.c_str());\n\n    return 0;\n}\n\nstring generateFormula(int leaves, string formulaType) {\n    if (formulaType == \"constant0\") {\n        // Generate a formula that is just '0'\n        return \"0\";\n    } else if (formulaType == \"constant1\") {\n        // Generate a formula that is just '1'\n        return \"1\";\n    } else if (formulaType == \"single_leaf\") {\n        // Generate a formula with only one '?'\n        return \"?\";\n    } else if (formulaType == \"max_leaves\") {\n        // Generate a formula with maximum number of '?'\n        // Ensure the total formula size does not exceed 1e6 characters\n        int maxSize = 1000000;\n        // total_size = 4 * leaves - 3\n        int leaves = (maxSize + 3) / 4;\n        return generateBalancedFormula(leaves);\n    } else if (formulaType == \"all_zero\") {\n        // Generate a formula that always evaluates to 0\n        // For example, (0&?)\n        return \"(0&?)\";\n    } else if (formulaType == \"all_one\") {\n        // Generate a formula that always evaluates to 1\n        // For example, (1|?)\n        return \"(1|?)\";\n    } else if (formulaType == \"random_constant\") {\n        // Generate a random formula with '0' and '1' only\n        return generateRandomFormulaNoLeaves();\n    } else if (formulaType == \"random\") {\n        // Generate a random formula\n        return generateRandomFormula();\n    } else {\n        // Default: return '?'\n        return \"?\";\n    }\n}\n\nstring generateBalancedFormula(int leaves) {\n    deque<string> nodes;\n    for (int i = 0; i < leaves; ++i) {\n        nodes.push_back(\"?\");\n    }\n\n    string ops = \"|&^\";\n\n    while (nodes.size() > 1) {\n        string left = nodes.front(); nodes.pop_front();\n        string right = nodes.front(); nodes.pop_front();\n        char op = ops[rnd.next(3)]; // Randomly pick an operator\n        string new_node = \"(\" + left + op + right + \")\";\n        nodes.push_back(new_node);\n        // To avoid exceeding memory limits, we can process and remove old strings\n        // But since total formula size is within limits, we're fine\n    }\n\n    return nodes.front();\n}\n\nstring generateRandomFormula(int depth) {\n    // Limit depth to prevent stack overflow\n    if (depth > 20) {\n        // Return a leaf\n        int leafType = rnd.next(3);\n        if (leafType == 0) return \"0\";\n        else if (leafType == 1) return \"1\";\n        else return \"?\";\n    }\n\n    int nodeType = rnd.next(5); // Randomly choose a node type\n    if (nodeType == 0) {\n        // Return a constant '0'\n        return \"0\";\n    } else if (nodeType == 1) {\n        // Return a constant '1'\n        return \"1\";\n    } else if (nodeType == 2) {\n        // Return a leaf '?'\n        return \"?\";\n    } else {\n        // Return an expression with an operator\n        char op = \"|&^\"[rnd.next(3)];\n        string left = generateRandomFormula(depth + 1);\n        string right = generateRandomFormula(depth + 1);\n        return \"(\" + left + op + right + \")\";\n    }\n}\n\nstring generateRandomFormulaNoLeaves(int depth) {\n    // Limit depth to prevent stack overflow\n    if (depth > 20) {\n        // Return a constant\n        int leafType = rnd.next(2);\n        if (leafType == 0) return \"0\";\n        else return \"1\";\n    }\n\n    int nodeType = rnd.next(3); // Randomly choose a node type\n    if (nodeType == 0) {\n        // Return a constant '0'\n        return \"0\";\n    } else if (nodeType == 1) {\n        // Return a constant '1'\n        return \"1\";\n    } else {\n        // Return an expression with an operator\n        char op = \"|&^\"[rnd.next(3)];\n        string left = generateRandomFormulaNoLeaves(depth + 1);\n        string right = generateRandomFormulaNoLeaves(depth + 1);\n        return \"(\" + left + op + right + \")\";\n    }\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Test with small n and different formula types\n./gen -n 2 -type constant0\n./gen -n 2 -type constant1\n./gen -n 2 -type single_leaf\n./gen -n 2 -type all_zero\n./gen -n 2 -type all_one\n./gen -n 2 -type random_constant\n./gen -n 2 -type random\n\n# Test with n = 2 and maximum number of leaves\n./gen -n 2 -type max_leaves\n\n# Test with medium n\n./gen -n 100 -type random\n./gen -n 100 -type max_leaves\n\n# Test with large n\n./gen -n 1000 -type random\n./gen -n 1000 -type random_constant\n./gen -n 1000 -type max_leaves\n\n# Test with maximum n\n./gen -n 1000000 -type random\n./gen -n 1000000 -type random_constant\n./gen -n 1000000 -type max_leaves\n\n# Test with edge cases\n./gen -n 2 -type single_leaf\n./gen -n 3 -type single_leaf\n./gen -n 4 -type all_zero\n./gen -n 5 -type all_one\n./gen -n 6 -type constant0\n./gen -n 7 -type constant1\n\n# Test with different random seeds by using different parameters (though seed is not set)\n./gen -n 500000 -type random\n./gen -n 500000 -type random_constant\n./gen -n 500000 -type max_leaves\n\n# Additional tests\n./gen -n 999999 -type random\n./gen -n 999999 -type max_leaves\n./gen -n 999999 -type random_constant\n\n# Test with minimal n\n./gen -n 2 -type random\n\n# Test with special formula types\n./gen -n 10 -type all_zero\n./gen -n 10 -type all_one\n\n# Test with single leaf and large n\n./gen -n 1000000 -type single_leaf\n\n# Test with constant formulas and large n\n./gen -n 1000000 -type constant0\n./gen -n 1000000 -type constant1\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T19:50:28.861876",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "219/A",
      "title": "A. k-String",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first input line contains integer k (1 ≤ k ≤ 1000). The second line contains s, all characters in s are lowercase English letters. The string length s satisfies the inequality 1 ≤ |s| ≤ 1000, where |s| is the length of string s.",
      "output_spec": "OutputRearrange the letters in string s in such a way that the result is a k-string. Print the result on a single output line. If there are multiple solutions, print any of them.If the solution doesn't exist, print \"-1\" (without quotes).",
      "sample_tests": "ExamplesInputCopy2aazzOutputCopyazazInputCopy3abcabcabzOutputCopy-1",
      "description": "A. k-String\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first input line contains integer k (1 ≤ k ≤ 1000). The second line contains s, all characters in s are lowercase English letters. The string length s satisfies the inequality 1 ≤ |s| ≤ 1000, where |s| is the length of string s.\n\nOutputRearrange the letters in string s in such a way that the result is a k-string. Print the result on a single output line. If there are multiple solutions, print any of them.If the solution doesn't exist, print \"-1\" (without quotes).\n\nInputCopy2aazzOutputCopyazazInputCopy3abcabcabzOutputCopy-1\n\nInputCopy2aazz\n\nOutputCopyazaz\n\nInputCopy3abcabcabz\n\nOutputCopy-1",
      "solutions": [
        {
          "title": "Codeforces Round #135 (Div. 2) - Codeforces",
          "content": "Hello!Only few hours left before Codeforces Round # 135 (Div. 2). We are preparing the round in Petrozavodsk where traditional training camp for ACM-ICPC is going now. Today is a day of rest here, many participants gone to a trip to Kizhi. The main contest authors are me and Gerald. Special thanks to Aksenov239 who tested the round. Thank Delinur for translation.The problems will be sorted by expected difficulty, the scores are dynamic.Wish you fun round!",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/5156",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 459
        },
        {
          "title": "Codeforces Round #135: Разбор - Codeforces",
          "content": "Итак, начнём разбор.219A - k-StringДавайте для каждой буквы l посчитаем, сколько раз она встретилась в строке --- массив c[l]. Подсчет осуществляется примерно так: c[s[i]]++. Если количество вхождений какой-то буквы не кратно k, то мы уже сразу понимаем, что составить нужную нам строку невозможно. Теперь построим строку p: добавим в неё букв 'a', букв 'b', и так далее. Выведем полученную строку k раз.219B - Special Offer! Super Price 999 Bourles!Переберем количество девяток на конце числа от 1 до 18. Пусть эта величина равна k. В таком случае максимальное число не превосходящее заданное p можно получить так: сотрем последние k цифр числа x:  = p / 10k добавим справа k девяток y:  = x·10k + 10k - 1 если значение y больше p, то уменьшим число x (то, что идет до k девяток) на 1 и к результату допишем k девяток y:  = (x - 1)·10k + 10k - 1 Если получившееся y >  = p - d, то обновим ответ значением k.219C - Color StripeРазберём 2 два случая: k равно 2. Тогда нам подходят только две строки — чередующиеся буквы 'A' и 'B'. Выбираем из них тот, который требует меньшего числа перекрасок. k больше 2. Возьмем самый левый блок из одинаковых букв. Пусть его длина равна k, тогда надо не менее k / 2 перекрашиваний, чтобы избавиться от соседних одинаковых клеток в этом блоке. Если k нечетно, то можно каждую вторую клетку в блоке перекрасить в любой из цветов, отличных от цвета блока. Если k четно, то можно делать тоже самое, но аккуратнее выбрать цвет: он должен отличаться не только от цвета блока, но и от цвета следующей клетки за блоком. Это всегда возможно сделать, так как количество цветов больше 2. 219D - Choosing Capital for TreelandДля того, чтобы решить эту задачу посчитаем для каждого города количество ребер, которые надо переориентировать, чтобы данный город стал столицей.В задаче были достаточно большие ограничения, поэтому нельзя было просто посчитать все эти значения n обходами в глубину. Авторское решение запускает только два обхода в глубину. Первым обходом в глубину посчитаем ответ для города номер 1. Заметим, что если посчитан ответ для вершины x, то ответ для вершины y, которая соединена с x, можно посчитать за O(1). А именно, ans(y) = ans(x) - direction(x, y) + (1 - direction(x, y)), где direction(x, y) — равно 1, если ребро (x, y) ориентировано не так как во входных данных, и равно 0, иначе. Пользуясь описанным фактом, можно посчитать все значения ans(v) одним обходом, зная ans(1).Итоговая ассимптотика решения O(n).219E - Parking LotБудем поддерживать две структуры: множество отрезков свободных парковочных мест, в котором отрезки отсортированы по их началу, и множество отрезков свободных парковочных мест отсортированных по размеру. Такие структуры должны поддерживать операцию быстрого поиска первого больше либо равного элемента, удаление элемента и его вставку, нахождениe максимума и следующего по величине элемента.В языке C++, авторское решение использовало set <pair<int,int>> и map <int, set<int>>. Set отрезков и Map из длины отрезка в набор отрезков с заданной длиной. Операция поиска больше либо равного элемента в этих структурах называется lower_bound.Научимся поддерживать эти структуры от операции к операции. Для того, чтобы определить автомобилиста на стоянку, нужно взять свободный отрезок с максимальной длиной или с (максимальной длиной минус один), который не упирается в начало или конец стоянки, и попробовать определить автомобилиста на свободное парковочное место в середину этого отрезка (если точной середины нет, то в ближайшую к ней клетеку). Среди всех таких позиций нужно выбрать наилучшую (в смысле условия задачи). После нахождения лучшей позиции надо разрезать соотвествующий отрезок свободных позиций на два и обновить обе структуры (удалить старый отрезок и вставить два новых).Чтобы удалить автомобилиста со стоянки нужно добавить новый отрезок свободных парковочных мест длины один в структуру. Предварительно нужно удалить смежные с этим отрезком отрезки в структуре. Соединить их с нашим отрезком и добавить один большой отрезок в структуру.Отдельные случаи возникает при рассмотрении крайних отрезков. Итоговая сложность решения O(m log n)",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/5158",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 219\\s*A"
          },
          "content_length": 4129
        },
        {
          "title": "User editorial for Codeforces Round #135 (Div. 2) - Codeforces",
          "content": "The contest was well balanced — scores for tasks were very close to standard scores. I hope you will find this editorial useful.A :: k-StringCount the occurrences of each character. If any character appears a number of times not divisible by K, obviously, there is no solution. Otherwise, form the solution by first making the string B. The string B can be any string with the following property: if some character ch appears q times in the string B, the same character appears q***K** times in the given string. Now, just print that string K times.B :: Special Offer! Super Price 999 Bourles!The following observation will help you code the solution:The largest number smaller than p ending with at least k nines is p - p MOD 10^k - 1 If the result turns out to be -1 , you can not reach a positive number with k or more nines. I will not explain the solution in detail — be careful when coding and have all the task statements in mind.C :: Color StripeThere are two cases to consider , when K=2 and when K>2. For K=2 there are only two possible solutions: the string \"ABABAB...\" and \"BABABA...\"For both strings, simply count the number of differences between it and the given string and print a string with fewer differences.For K>2 , decompose the string into contiguous single-colored sequences. Observe one such sequence. If it has an odd number of characters, say 2m+1, replace m characters with some other character in the following fashion:AAAAAbecomesABABAIt can be observed that by changing less than m characters doesn't remove all pairs of adjacent identical characters. Similarly, for sequences of even length, say 2m characters, observe a character in the original string right after the last character of the observed sequence, and choose a character different from both. Example:AAAAAABbecomesACACACBAgain, it is sufficient and necessary to change m characters.D :: Choosing Capital for TreelandArbitrarily root the tree at some vertex, say vertex 1. Now, all the edges are oriented either up (towards the root) or down (away from it). We will call upwards oriented edges red, and downwards oriented edges green. Now, with a single depth-first search, for each vertex, calculate its distance from the root (in number of edges) and the number of red edges along the path to the root. Also, count the number of red edges in the entire tree.Now comes the interesting part: Observe that all edges outside the path from the root to vert should turn green, and those on the path should turn red.The number of edges that need to be flipped if vert is chosen as a capital is given by:RedEntireTree - 2*RedOnPath[vert] + RootDistance[vert]E :: Parking LotUse a heap to maintain sequences of empty parking spaces as intervals. The comparison function for such intervals should return an interval which could store a car farthest from any other car, and if there is a tie, it should return the leftmost such interval. When inserting a car, pop the heap, look at the interval, place a car in the corresponding space and push two new intervals onto the heap. When removing a car, you should be able to find the two intervals which end at that car, remove them from the heap and push a new interval which forms when the two merge.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/5160",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 3232
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #135 (Div. 2) - Codeforces - Code 1",
          "code": "long long int a=10, t=1;\nwhile(t<3) {\n    long long int test=(long long int) (pow((long long int)10,t));\n    cout<<test<<endl ;\n    t++;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5156",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #135 (Div. 2) - Codeforces - Code 2",
          "code": "Print the required price — the maximum price that ends with the largest number of nines and that is less than p by no more than d.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5156",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #135 (Div. 2) - Codeforces - Code 3",
          "code": "Print the required price — the maximum price that ends with the largest number of nines and that is less than p by no more than d.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5156",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #135 (Div. 2) - Codeforces - Code 4",
          "code": "#pragma optimization_level 3 \n#pragma GCC optimize(\"Ofast,no-stack-protector,unroll-loops,fast-math,O3\") \n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx\")",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5156",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #135 (Div. 2) - Codeforces - Code 5",
          "code": "#pragma optimization_level 3 \n#pragma GCC optimize(\"Ofast,no-stack-protector,unroll-loops,fast-math,O3\") \n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx\")",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5156",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #135: Разбор - Codeforces - Code 1",
          "code": "<pair<int,int>>",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5158",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #135: Разбор - Codeforces - Code 2",
          "code": "<int, set<int>>",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5158",
          "author": "jiangly"
        },
        {
          "title": "User editorial for Codeforces Round #135 (Div. 2) - Codeforces - Code 1",
          "code": "p - p MOD 10^k - 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5160",
          "author": "jiangly"
        },
        {
          "title": "User editorial for Codeforces Round #135 (Div. 2) - Codeforces - Code 2",
          "code": "RedEntireTree - 2*RedOnPath[vert] + RootDistance[vert]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5160",
          "author": "jiangly"
        },
        {
          "title": "User editorial for Codeforces Round #135 (Div. 2) - Codeforces - Code 3",
          "code": "for (int i=1;i<n;i++){\n        cin>>a>>b;\n        temp = ar[a];\n        while(temp->next!=NULL){\n            temp = temp->next;\n        }\n        temp->next = new Node(b, 1, 0);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5160",
          "author": "jiangly"
        },
        {
          "title": "User editorial for Codeforces Round #135 (Div. 2) - Codeforces - Code 4",
          "code": "for (int i=1;i<n;i++){\n        cin>>a>>b;\n        temp = ar[a];\n        while(temp->next!=NULL){\n            temp = temp->next;\n        }\n        temp->next = new Node(b, 1, 0);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5160",
          "author": "jiangly"
        },
        {
          "title": "User editorial for Codeforces Round #135 (Div. 2) - Codeforces - Code 5",
          "code": "struct node\n{\n    vector<node*> edges;\n} nodes[big_number];\n\n...\n\nfor (int i = 0; i < number_of_edges; i++)\n{\n    int a, b;\n    scanf(\"%d%d\", &a, &b);\n    nodes[a].edges.push_back(nodes + b);\n    nodes[b].edges.push_back(nodes + a);\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5160",
          "author": "jiangly"
        },
        {
          "title": "User editorial for Codeforces Round #135 (Div. 2) - Codeforces - Code 6",
          "code": "struct node\n{\n    vector<node*> edges;\n} nodes[big_number];\n\n...\n\nfor (int i = 0; i < number_of_edges; i++)\n{\n    int a, b;\n    scanf(\"%d%d\", &a, &b);\n    nodes[a].edges.push_back(nodes + b);\n    nodes[b].edges.push_back(nodes + a);\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5160",
          "author": "jiangly"
        },
        {
          "title": "User editorial for Codeforces Round #135 (Div. 2) - Codeforces - Code 7",
          "code": "RedEntireTree — 2*RedOnPath[vert] + RootDistance[vert]\n= (RedEntireTree - RedOnPath[vert]) + (RootDistance[vert] - RedOnPath[vert])\n=           RedOutsidePath          +            GreenOnPath",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5160",
          "author": "jiangly"
        },
        {
          "title": "User editorial for Codeforces Round #135 (Div. 2) - Codeforces - Code 8",
          "code": "RedEntireTree — 2*RedOnPath[vert] + RootDistance[vert]\n= (RedEntireTree - RedOnPath[vert]) + (RootDistance[vert] - RedOnPath[vert])\n=           RedOutsidePath          +            GreenOnPath",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5160",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int k = inf.readInt(1, 1000, \"k\");\n    inf.readEoln();\n    string s = inf.readLine(\"[a-z]{1,1000}\", \"s\");\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int k = inf.readInt(1, 1000, \"k\");\n    inf.readEoln();\n    string s = inf.readLine(\"[a-z]{1,1000}\", \"s\");\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int k = inf.readInt(1, 1000, \"k\");\n    inf.readEoln();\n    string s = inf.readLine(\"[a-z]{1,1000}\", \"s\");\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerTestlibCmd(argc, argv);\n    \n    // Read k and s from the input (inf)\n    int k = inf.readInt();\n    string s = inf.readToken();\n\n    // Read the judge's answer (ans)\n    string jans = ans.readToken();\n\n    // Read the participant's output (ouf)\n    string pans = ouf.readToken();\n\n    if (jans == \"-1\") {\n        if (pans == \"-1\") {\n            quitf(_ok, \"Correctly reported impossible\");\n        } else {\n            quitf(_wa, \"Participant found a solution but jury says impossible\");\n        }\n    } else {\n        if (pans == \"-1\") {\n            quitf(_wa, \"Participant reported impossible but jury has a solution\");\n        } else {\n            // Check that pans uses the same letters as s\n            vector<int> freq_s(26, 0);\n            vector<int> freq_pans(26, 0);\n            for (char c : s)\n                freq_s[c - 'a']++;\n            for (char c : pans)\n                freq_pans[c - 'a']++;\n\n            if (freq_s != freq_pans)\n                quitf(_wa, \"The participant's output does not use the same letters as the input string\");\n\n            // Check that pans can be divided into k equal parts\n            int total_len = pans.length();\n            if (total_len % k != 0)\n                quitf(_wa, \"The length of the participant's output is not divisible by k\");\n\n            int part_len = total_len / k;\n            string base = pans.substr(0, part_len);\n            for (int i = 1; i < k; ++i) {\n                if (pans.substr(i * part_len, part_len) != base)\n                    quitf(_wa, \"The participant's output is not a k-string\");\n            }\n            quitf(_ok, \"Correct output\");\n        }\n    }\n\n    return 0;\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    // Parse command-line arguments\n    int n = opt<int>(\"n\");\n    int k = opt<int>(\"k\");\n    string type = opt<string>(\"type\", \"possible\");\n\n    // Ensure that k is within the problem constraints\n    ensure(1 <= k && k <= 1000);\n    ensure(1 <= n && n <= 1000);\n\n    if (type == \"possible\") {\n        // For possible cases, we need n to be divisible by k\n        if (n % k != 0) {\n            // Adjust n to the nearest lower multiple of k\n            n = (n / k) * k;\n        }\n\n        // Total units to distribute\n        int total = n / k;\n        // Number of different characters to use\n        int num_chars = rnd.next(1, min(26, total));\n        vector<char> chars;\n\n        // Collect lowercase English letters\n        for (char c = 'a'; c <= 'z'; c++)\n            chars.push_back(c);\n\n        // Shuffle the characters\n        shuffle(chars.begin(), chars.end());\n\n        // Use the first num_chars letters\n        vector<int> mult(num_chars, 0);\n\n        // Distribute total units randomly among num_chars characters\n        for (int i = 0; i < total; i++) {\n            int idx = rnd.next(0, num_chars - 1);\n            mult[idx]++;\n        }\n\n        // Calculate frequencies for each character (must be multiples of k)\n        vector<int> freq(26, 0);\n        for (int i = 0; i < num_chars; i++) {\n            char c = chars[i];\n            freq[c - 'a'] = mult[i] * k;\n        }\n\n        // Construct the string s\n        string s;\n        for (int i = 0; i < 26; i++) {\n            s += string(freq[i], 'a' + i);\n        }\n\n        // Shuffle the string s\n        shuffle(s.begin(), s.end());\n\n        // Output k and s\n        printf(\"%d\\n\", k);\n        printf(\"%s\\n\", s.c_str());\n\n    } else if (type == \"impossible\") {\n        // For impossible cases, we ensure at least one character frequency is not divisible by k\n        if (n % k != 0) {\n            // Adjust n to the nearest higher multiple of k\n            n = (n / k + 1) * k;\n        }\n\n        // Total units to distribute\n        int total = n / k;\n        // Number of different characters to use\n        int num_chars = rnd.next(1, min(26, total));\n        vector<char> chars;\n\n        // Collect lowercase English letters\n        for (char c = 'a'; c <= 'z'; c++)\n            chars.push_back(c);\n\n        // Shuffle the characters\n        shuffle(chars.begin(), chars.end());\n\n        // Use the first num_chars letters\n        vector<int> mult(num_chars, 0);\n\n        // Distribute total units randomly among num_chars characters\n        for (int i = 0; i < total; i++) {\n            int idx = rnd.next(0, num_chars - 1);\n            mult[idx]++;\n        }\n\n        // Calculate frequencies for each character (must be multiples of k)\n        vector<int> freq(26, 0);\n        for (int i = 0; i < num_chars; i++) {\n            char c = chars[i];\n            freq[c - 'a'] = mult[i] * k;\n        }\n\n        // Introduce inconsistency by adjusting one character's frequency\n        int idx1 = rnd.next(0, num_chars - 1);\n        int c_idx1 = chars[idx1] - 'a';\n        freq[c_idx1] += 1; // Now freq[c_idx1] is not divisible by k\n        n += 1;\n\n        // Adjust another character's frequency to maintain total length n\n        int idx2 = (idx1 + 1) % num_chars;\n        int c_idx2 = chars[idx2] - 'a';\n        if (freq[c_idx2] > 0) {\n            freq[c_idx2] -= 1;\n            n -= 1;\n        } else {\n            // Find another character with frequency > 0\n            bool adjusted = false;\n            for (int i = 0; i < num_chars; i++) {\n                if (i != idx1 && freq[chars[i] - 'a'] > 0) {\n                    freq[chars[i] - 'a'] -= 1;\n                    n -= 1;\n                    adjusted = true;\n                    break;\n                }\n            }\n            if (!adjusted) {\n                // If no character can be adjusted, decrease the adjusted character back\n                freq[c_idx1] -= 1;\n                n -= 1;\n            }\n        }\n\n        // Construct the string s\n        string s;\n        for (int i = 0; i < 26; i++) {\n            s += string(freq[i], 'a' + i);\n        }\n\n        // Shuffle the string s\n        shuffle(s.begin(), s.end());\n\n        // Output k and s\n        printf(\"%d\\n\", k);\n        printf(\"%s\\n\", s.c_str());\n\n    } else if (type == \"special\") {\n        // Generate special cases to cover edge conditions\n        // For example, k = 1, n = 1, or maximum sizes\n\n        // Here is an example of k = 1\n        k = 1;\n        n = rnd.next(1, 1000); // Maximum length\n\n        // Generate a random string of length n\n        string s;\n        for (int i = 0; i < n; i++) {\n            s += (char)('a' + rnd.next(0, 25));\n        }\n\n        // Output k and s\n        printf(\"%d\\n\", k);\n        printf(\"%s\\n\", s.c_str());\n\n    } else {\n        // Unsupported type\n        fprintf(stderr, \"Unsupported type: %s\\n\", type.c_str());\n        return 1;\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    // Parse command-line arguments\n    int n = opt<int>(\"n\");\n    int k = opt<int>(\"k\");\n    string type = opt<string>(\"type\", \"possible\");\n\n    // Ensure that k is within the problem constraints\n    ensure(1 <= k && k <= 1000);\n    ensure(1 <= n && n <= 1000);\n\n    if (type == \"possible\") {\n        // For possible cases, we need n to be divisible by k\n        if (n % k != 0) {\n            // Adjust n to the nearest lower multiple of k\n            n = (n / k) * k;\n        }\n\n        // Total units to distribute\n        int total = n / k;\n        // Number of different characters to use\n        int num_chars = rnd.next(1, min(26, total));\n        vector<char> chars;\n\n        // Collect lowercase English letters\n        for (char c = 'a'; c <= 'z'; c++)\n            chars.push_back(c);\n\n        // Shuffle the characters\n        shuffle(chars.begin(), chars.end());\n\n        // Use the first num_chars letters\n        vector<int> mult(num_chars, 0);\n\n        // Distribute total units randomly among num_chars characters\n        for (int i = 0; i < total; i++) {\n            int idx = rnd.next(0, num_chars - 1);\n            mult[idx]++;\n        }\n\n        // Calculate frequencies for each character (must be multiples of k)\n        vector<int> freq(26, 0);\n        for (int i = 0; i < num_chars; i++) {\n            char c = chars[i];\n            freq[c - 'a'] = mult[i] * k;\n        }\n\n        // Construct the string s\n        string s;\n        for (int i = 0; i < 26; i++) {\n            s += string(freq[i], 'a' + i);\n        }\n\n        // Shuffle the string s\n        shuffle(s.begin(), s.end());\n\n        // Output k and s\n        printf(\"%d\\n\", k);\n        printf(\"%s\\n\", s.c_str());\n\n    } else if (type == \"impossible\") {\n        // For impossible cases, we ensure at least one character frequency is not divisible by k\n        if (n % k != 0) {\n            // Adjust n to the nearest higher multiple of k\n            n = (n / k + 1) * k;\n        }\n\n        // Total units to distribute\n        int total = n / k;\n        // Number of different characters to use\n        int num_chars = rnd.next(1, min(26, total));\n        vector<char> chars;\n\n        // Collect lowercase English letters\n        for (char c = 'a'; c <= 'z'; c++)\n            chars.push_back(c);\n\n        // Shuffle the characters\n        shuffle(chars.begin(), chars.end());\n\n        // Use the first num_chars letters\n        vector<int> mult(num_chars, 0);\n\n        // Distribute total units randomly among num_chars characters\n        for (int i = 0; i < total; i++) {\n            int idx = rnd.next(0, num_chars - 1);\n            mult[idx]++;\n        }\n\n        // Calculate frequencies for each character (must be multiples of k)\n        vector<int> freq(26, 0);\n        for (int i = 0; i < num_chars; i++) {\n            char c = chars[i];\n            freq[c - 'a'] = mult[i] * k;\n        }\n\n        // Introduce inconsistency by adjusting one character's frequency\n        int idx1 = rnd.next(0, num_chars - 1);\n        int c_idx1 = chars[idx1] - 'a';\n        freq[c_idx1] += 1; // Now freq[c_idx1] is not divisible by k\n        n += 1;\n\n        // Adjust another character's frequency to maintain total length n\n        int idx2 = (idx1 + 1) % num_chars;\n        int c_idx2 = chars[idx2] - 'a';\n        if (freq[c_idx2] > 0) {\n            freq[c_idx2] -= 1;\n            n -= 1;\n        } else {\n            // Find another character with frequency > 0\n            bool adjusted = false;\n            for (int i = 0; i < num_chars; i++) {\n                if (i != idx1 && freq[chars[i] - 'a'] > 0) {\n                    freq[chars[i] - 'a'] -= 1;\n                    n -= 1;\n                    adjusted = true;\n                    break;\n                }\n            }\n            if (!adjusted) {\n                // If no character can be adjusted, decrease the adjusted character back\n                freq[c_idx1] -= 1;\n                n -= 1;\n            }\n        }\n\n        // Construct the string s\n        string s;\n        for (int i = 0; i < 26; i++) {\n            s += string(freq[i], 'a' + i);\n        }\n\n        // Shuffle the string s\n        shuffle(s.begin(), s.end());\n\n        // Output k and s\n        printf(\"%d\\n\", k);\n        printf(\"%s\\n\", s.c_str());\n\n    } else if (type == \"special\") {\n        // Generate special cases to cover edge conditions\n        // For example, k = 1, n = 1, or maximum sizes\n\n        // Here is an example of k = 1\n        k = 1;\n        n = rnd.next(1, 1000); // Maximum length\n\n        // Generate a random string of length n\n        string s;\n        for (int i = 0; i < n; i++) {\n            s += (char)('a' + rnd.next(0, 25));\n        }\n\n        // Output k and s\n        printf(\"%d\\n\", k);\n        printf(\"%s\\n\", s.c_str());\n\n    } else {\n        // Unsupported type\n        fprintf(stderr, \"Unsupported type: %s\\n\", type.c_str());\n        return 1;\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Possible cases with small n and k\n./gen -n 6 -k 2 -type possible\n./gen -n 9 -k 3 -type possible\n\n# Impossible cases with small n and k\n./gen -n 7 -k 2 -type impossible\n./gen -n 10 -k 3 -type impossible\n\n# Possible cases with maximum n and varying k\n./gen -n 1000 -k 1 -type possible\n./gen -n 1000 -k 2 -type possible\n./gen -n 1000 -k 5 -type possible\n\n# Impossible cases with maximum n and varying k\n./gen -n 1000 -k 4 -type impossible\n./gen -n 1000 -k 7 -type impossible\n\n# Edge cases where n is a multiple of k\n./gen -n 100 -k 10 -type possible\n./gen -n 999 -k 3 -type possible\n\n# Edge cases where n is not a multiple of k\n./gen -n 100 -k 9 -type impossible\n./gen -n 999 -k 8 -type impossible\n\n# Special cases (k = 1)\n./gen -n 1 -k 1 -type special\n./gen -n 500 -k 1 -type special\n\n# Special cases with minimum and maximum lengths\n./gen -n 1 -k 1 -type possible\n./gen -n 2 -k 2 -type possible\n./gen -n 1000 -k 1000 -type possible\n\n# Random possible cases\n./gen -n 250 -k 5 -type possible\n./gen -n 800 -k 8 -type possible\n./gen -n 700 -k 14 -type possible\n\n# Random impossible cases\n./gen -n 251 -k 5 -type impossible\n./gen -n 801 -k 8 -type impossible\n./gen -n 701 -k 14 -type impossible\n\n# Possible cases with maximum number of different characters\n./gen -n 1000 -k 10 -type possible\n\n# Impossible case where one character has frequency not divisible by k\n./gen -n 1000 -k 10 -type impossible\n\n# Special case where all characters are the same\n./gen -n 1000 -k 1 -type special\n\n# Special case with k equal to the length of s\n./gen -n 26 -k 26 -type possible\n\n# Special cases to test k equals 1 and maximum n\n./gen -n 1000 -k 1 -type special\n\n# Possible cases with n and k being prime numbers\n./gen -n 997 -k 13 -type possible\n\n# Impossible cases with n and k being prime numbers\n./gen -n 997 -k 17 -type impossible\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T19:50:30.986969",
        "total_tutorials": 3,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "219/B",
      "title": "B. Только сегодня! Супер цена 999 бурлей!",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест1 секунда",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеВ первой строке записаны два целых числа p и d (1 ≤ p ≤ 1018; 0 ≤ d < p) — начальная цена ножниц и максимальное возможное падение в цене.Пожалуйста, не используйте спецификатор %lld для чтения или записи 64-битных чисел на С++. Рекомендуется использовать потоки cin, cout или спецификатор %I64d.",
      "output_spec": "Выходные данныеВыведите искомую цену — максимальную из цен, которые заканчиваются на наибольшее количество девяток и не более чем на d меньше p.Выводимое значение не должно содержать лидирующих нулей.",
      "sample_tests": "ПримерыВходные данныеСкопировать1029 102Выходные данныеСкопировать999Входные данныеСкопировать27191 17Выходные данныеСкопировать27189",
      "description": "B. Только сегодня! Супер цена 999 бурлей!\n\nограничение по времени на тест1 секунда\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвыводstdout\n\nВходные данныеВ первой строке записаны два целых числа p и d (1 ≤ p ≤ 1018; 0 ≤ d < p) — начальная цена ножниц и максимальное возможное падение в цене.Пожалуйста, не используйте спецификатор %lld для чтения или записи 64-битных чисел на С++. Рекомендуется использовать потоки cin, cout или спецификатор %I64d.\n\nВходные данные\n\nВыходные данныеВыведите искомую цену — максимальную из цен, которые заканчиваются на наибольшее количество девяток и не более чем на d меньше p.Выводимое значение не должно содержать лидирующих нулей.\n\nВыходные данные\n\nВходные данныеСкопировать1029 102Выходные данныеСкопировать999Входные данныеСкопировать27191 17Выходные данныеСкопировать27189\n\nВходные данныеСкопировать1029 102\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать999\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать27191 17\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать27189\n\nВыходные данныеСкопировать\n\nСкопировать",
      "solutions": [
        {
          "title": "Codeforces Round #135 (Div. 2) - Codeforces",
          "content": "Всем привет!До Codeforces Round #135 (Div. 2) осталось всего несколько часов. Вся подготовка раунда сосредоточена в городе Петрозаводске, где проходят традиционные сборы по подготовке к ACM-ICPC. Сегодня здесь выходной, многие поехали на экскурсию в Кижи, а я с Gerald-ом готовим для вас контест. Виталик Aksenov239 Аксенов не остался равнодушен и предложил свою помощь, за что ему большое спасибо. Спасибо Маше Delinur Беловой за перевод условий.Задачи будут отсортированы по предполагаемой сложности, стоимость задач — динамическая.Всем удачи и удовольствия от раунда!",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/5156",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 570
        },
        {
          "title": "Codeforces Round #135: Разбор - Codeforces",
          "content": "Итак, начнём разбор.219A - k-StringДавайте для каждой буквы l посчитаем, сколько раз она встретилась в строке --- массив c[l]. Подсчет осуществляется примерно так: c[s[i]]++. Если количество вхождений какой-то буквы не кратно k, то мы уже сразу понимаем, что составить нужную нам строку невозможно. Теперь построим строку p: добавим в неё букв 'a', букв 'b', и так далее. Выведем полученную строку k раз.219B - Special Offer! Super Price 999 Bourles!Переберем количество девяток на конце числа от 1 до 18. Пусть эта величина равна k. В таком случае максимальное число не превосходящее заданное p можно получить так: сотрем последние k цифр числа x:  = p / 10k добавим справа k девяток y:  = x·10k + 10k - 1 если значение y больше p, то уменьшим число x (то, что идет до k девяток) на 1 и к результату допишем k девяток y:  = (x - 1)·10k + 10k - 1 Если получившееся y >  = p - d, то обновим ответ значением k.219C - Color StripeРазберём 2 два случая: k равно 2. Тогда нам подходят только две строки — чередующиеся буквы 'A' и 'B'. Выбираем из них тот, который требует меньшего числа перекрасок. k больше 2. Возьмем самый левый блок из одинаковых букв. Пусть его длина равна k, тогда надо не менее k / 2 перекрашиваний, чтобы избавиться от соседних одинаковых клеток в этом блоке. Если k нечетно, то можно каждую вторую клетку в блоке перекрасить в любой из цветов, отличных от цвета блока. Если k четно, то можно делать тоже самое, но аккуратнее выбрать цвет: он должен отличаться не только от цвета блока, но и от цвета следующей клетки за блоком. Это всегда возможно сделать, так как количество цветов больше 2. 219D - Choosing Capital for TreelandДля того, чтобы решить эту задачу посчитаем для каждого города количество ребер, которые надо переориентировать, чтобы данный город стал столицей.В задаче были достаточно большие ограничения, поэтому нельзя было просто посчитать все эти значения n обходами в глубину. Авторское решение запускает только два обхода в глубину. Первым обходом в глубину посчитаем ответ для города номер 1. Заметим, что если посчитан ответ для вершины x, то ответ для вершины y, которая соединена с x, можно посчитать за O(1). А именно, ans(y) = ans(x) - direction(x, y) + (1 - direction(x, y)), где direction(x, y) — равно 1, если ребро (x, y) ориентировано не так как во входных данных, и равно 0, иначе. Пользуясь описанным фактом, можно посчитать все значения ans(v) одним обходом, зная ans(1).Итоговая ассимптотика решения O(n).219E - Parking LotБудем поддерживать две структуры: множество отрезков свободных парковочных мест, в котором отрезки отсортированы по их началу, и множество отрезков свободных парковочных мест отсортированных по размеру. Такие структуры должны поддерживать операцию быстрого поиска первого больше либо равного элемента, удаление элемента и его вставку, нахождениe максимума и следующего по величине элемента.В языке C++, авторское решение использовало set <pair<int,int>> и map <int, set<int>>. Set отрезков и Map из длины отрезка в набор отрезков с заданной длиной. Операция поиска больше либо равного элемента в этих структурах называется lower_bound.Научимся поддерживать эти структуры от операции к операции. Для того, чтобы определить автомобилиста на стоянку, нужно взять свободный отрезок с максимальной длиной или с (максимальной длиной минус один), который не упирается в начало или конец стоянки, и попробовать определить автомобилиста на свободное парковочное место в середину этого отрезка (если точной середины нет, то в ближайшую к ней клетеку). Среди всех таких позиций нужно выбрать наилучшую (в смысле условия задачи). После нахождения лучшей позиции надо разрезать соотвествующий отрезок свободных позиций на два и обновить обе структуры (удалить старый отрезок и вставить два новых).Чтобы удалить автомобилиста со стоянки нужно добавить новый отрезок свободных парковочных мест длины один в структуру. Предварительно нужно удалить смежные с этим отрезком отрезки в структуре. Соединить их с нашим отрезком и добавить один большой отрезок в структуру.Отдельные случаи возникает при рассмотрении крайних отрезков. Итоговая сложность решения O(m log n)",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/5158",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 219\\s*B"
          },
          "content_length": 4129
        },
        {
          "title": "User editorial for Codeforces Round #135 (Div. 2) - Codeforces",
          "content": "The contest was well balanced — scores for tasks were very close to standard scores. I hope you will find this editorial useful.A :: k-StringCount the occurrences of each character. If any character appears a number of times not divisible by K, obviously, there is no solution. Otherwise, form the solution by first making the string B. The string B can be any string with the following property: if some character ch appears q times in the string B, the same character appears q***K** times in the given string. Now, just print that string K times.B :: Special Offer! Super Price 999 Bourles!The following observation will help you code the solution:The largest number smaller than p ending with at least k nines is p - p MOD 10^k - 1 If the result turns out to be -1 , you can not reach a positive number with k or more nines. I will not explain the solution in detail — be careful when coding and have all the task statements in mind.C :: Color StripeThere are two cases to consider , when K=2 and when K>2. For K=2 there are only two possible solutions: the string \"ABABAB...\" and \"BABABA...\"For both strings, simply count the number of differences between it and the given string and print a string with fewer differences.For K>2 , decompose the string into contiguous single-colored sequences. Observe one such sequence. If it has an odd number of characters, say 2m+1, replace m characters with some other character in the following fashion:AAAAAbecomesABABAIt can be observed that by changing less than m characters doesn't remove all pairs of adjacent identical characters. Similarly, for sequences of even length, say 2m characters, observe a character in the original string right after the last character of the observed sequence, and choose a character different from both. Example:AAAAAABbecomesACACACBAgain, it is sufficient and necessary to change m characters.D :: Choosing Capital for TreelandArbitrarily root the tree at some vertex, say vertex 1. Now, all the edges are oriented either up (towards the root) or down (away from it). We will call upwards oriented edges red, and downwards oriented edges green. Now, with a single depth-first search, for each vertex, calculate its distance from the root (in number of edges) and the number of red edges along the path to the root. Also, count the number of red edges in the entire tree.Now comes the interesting part: Observe that all edges outside the path from the root to vert should turn green, and those on the path should turn red.The number of edges that need to be flipped if vert is chosen as a capital is given by:RedEntireTree - 2*RedOnPath[vert] + RootDistance[vert]E :: Parking LotUse a heap to maintain sequences of empty parking spaces as intervals. The comparison function for such intervals should return an interval which could store a car farthest from any other car, and if there is a tie, it should return the leftmost such interval. When inserting a car, pop the heap, look at the interval, place a car in the corresponding space and push two new intervals onto the heap. When removing a car, you should be able to find the two intervals which end at that car, remove them from the heap and push a new interval which forms when the two merge.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/5160",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 3232
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #135 (Div. 2) - Codeforces - Code 1",
          "code": "1. первый из пары стоит правильно \n2. вторый из пары стоит правильно",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5156",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #135 (Div. 2) - Codeforces - Code 2",
          "code": "1. первый из пары стоит правильно \n2. вторый из пары стоит правильно",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5156",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #135 (Div. 2) - Codeforces - Code 3",
          "code": "long long int a=10, t=1;\nwhile(t<3) {\n    long long int test=(long long int) (pow((long long int)10,t));\n    cout<<test<<endl ;\n    t++;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5156",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #135 (Div. 2) - Codeforces - Code 4",
          "code": "Print the required price — the maximum price that ends with the largest number of nines and that is less than p by no more than d.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5156",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #135 (Div. 2) - Codeforces - Code 5",
          "code": "Print the required price — the maximum price that ends with the largest number of nines and that is less than p by no more than d.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5156",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #135 (Div. 2) - Codeforces - Code 6",
          "code": "#pragma optimization_level 3 \n#pragma GCC optimize(\"Ofast,no-stack-protector,unroll-loops,fast-math,O3\") \n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx\")",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5156",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #135 (Div. 2) - Codeforces - Code 7",
          "code": "#pragma optimization_level 3 \n#pragma GCC optimize(\"Ofast,no-stack-protector,unroll-loops,fast-math,O3\") \n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx\")",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5156",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #135: Разбор - Codeforces - Code 1",
          "code": "<pair<int,int>>",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5158",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #135: Разбор - Codeforces - Code 2",
          "code": "<int, set<int>>",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5158",
          "author": "jiangly"
        },
        {
          "title": "User editorial for Codeforces Round #135 (Div. 2) - Codeforces - Code 1",
          "code": "p - p MOD 10^k - 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5160",
          "author": "jiangly"
        },
        {
          "title": "User editorial for Codeforces Round #135 (Div. 2) - Codeforces - Code 2",
          "code": "RedEntireTree - 2*RedOnPath[vert] + RootDistance[vert]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5160",
          "author": "jiangly"
        },
        {
          "title": "User editorial for Codeforces Round #135 (Div. 2) - Codeforces - Code 3",
          "code": "for (int i=1;i<n;i++){\n        cin>>a>>b;\n        temp = ar[a];\n        while(temp->next!=NULL){\n            temp = temp->next;\n        }\n        temp->next = new Node(b, 1, 0);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5160",
          "author": "jiangly"
        },
        {
          "title": "User editorial for Codeforces Round #135 (Div. 2) - Codeforces - Code 4",
          "code": "for (int i=1;i<n;i++){\n        cin>>a>>b;\n        temp = ar[a];\n        while(temp->next!=NULL){\n            temp = temp->next;\n        }\n        temp->next = new Node(b, 1, 0);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5160",
          "author": "jiangly"
        },
        {
          "title": "User editorial for Codeforces Round #135 (Div. 2) - Codeforces - Code 5",
          "code": "struct node\n{\n    vector<node*> edges;\n} nodes[big_number];\n\n...\n\nfor (int i = 0; i < number_of_edges; i++)\n{\n    int a, b;\n    scanf(\"%d%d\", &a, &b);\n    nodes[a].edges.push_back(nodes + b);\n    nodes[b].edges.push_back(nodes + a);\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5160",
          "author": "jiangly"
        },
        {
          "title": "User editorial for Codeforces Round #135 (Div. 2) - Codeforces - Code 6",
          "code": "struct node\n{\n    vector<node*> edges;\n} nodes[big_number];\n\n...\n\nfor (int i = 0; i < number_of_edges; i++)\n{\n    int a, b;\n    scanf(\"%d%d\", &a, &b);\n    nodes[a].edges.push_back(nodes + b);\n    nodes[b].edges.push_back(nodes + a);\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5160",
          "author": "jiangly"
        },
        {
          "title": "User editorial for Codeforces Round #135 (Div. 2) - Codeforces - Code 7",
          "code": "RedEntireTree — 2*RedOnPath[vert] + RootDistance[vert]\n= (RedEntireTree - RedOnPath[vert]) + (RootDistance[vert] - RedOnPath[vert])\n=           RedOutsidePath          +            GreenOnPath",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5160",
          "author": "jiangly"
        },
        {
          "title": "User editorial for Codeforces Round #135 (Div. 2) - Codeforces - Code 8",
          "code": "RedEntireTree — 2*RedOnPath[vert] + RootDistance[vert]\n= (RedEntireTree - RedOnPath[vert]) + (RootDistance[vert] - RedOnPath[vert])\n=           RedOutsidePath          +            GreenOnPath",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5160",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    const long long MAX_P = 1000000000000000000LL; // 1e18\n\n    long long p = inf.readLong(1LL, MAX_P, \"p\");\n    inf.readSpace();\n    long long d = inf.readLong(0LL, p - 1LL, \"d\");\n    inf.readEoln();\n    inf.readEof();\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    const long long MAX_P = 1000000000000000000LL; // 1e18\n\n    long long p = inf.readLong(1LL, MAX_P, \"p\");\n    inf.readSpace();\n    long long d = inf.readLong(0LL, p - 1LL, \"d\");\n    inf.readEoln();\n    inf.readEof();\n\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    const long long MAX_P = 1000000000000000000LL; // 1e18\n\n    long long p = inf.readLong(1LL, MAX_P, \"p\");\n    inf.readSpace();\n    long long d = inf.readLong(0LL, p - 1LL, \"d\");\n    inf.readEoln();\n    inf.readEof();\n\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    string type = opt<string>(\"type\", \"random\");\n    long long min_p = opt<long long>(\"min_p\", 1);\n    long long max_p = opt<long long>(\"max_p\", 1000000000000000000LL); // 1e18\n\n    long long p = 0, d = 0;\n\n    // Precompute powers of 10\n    long long pow10[19];\n    pow10[0] = 1;\n    for (int i = 1; i <= 18; ++i) {\n        pow10[i] = pow10[i - 1] * 10;\n    }\n\n    if (type == \"random\") {\n        p = rnd.next(min_p, max_p);\n        d = rnd.next(0LL, p - 1);\n    }\n    else if (type == \"max_p\") {\n        p = max_p;\n        d = rnd.next(0LL, p - 1);\n    }\n    else if (type == \"p_ends_with_nines\") {\n        int t = rnd.next(1, 18); // Number of trailing nines\n        long long min_leading = max(1LL, min_p / pow10[t]);\n        long long max_leading = max_p / pow10[t];\n        if (min_leading > max_leading) min_leading = max_leading;\n        long long leading = rnd.next(min_leading, max_leading);\n        p = leading * pow10[t] + pow10[t] - 1;\n        if (p > max_p) p = max_p;\n        d = rnd.next(0LL, p - 1);\n    }\n    else if (type == \"p_ends_with_zeros\") {\n        int t = rnd.next(1, 18); // Number of trailing zeros\n        long long min_leading = max(1LL, min_p / pow10[t]);\n        long long max_leading = max_p / pow10[t];\n        if (min_leading > max_leading) min_leading = max_leading;\n        long long leading = rnd.next(min_leading, max_leading);\n        p = leading * pow10[t];\n        if (p < min_p) p = min_p;\n        if (p > max_p) p = max_p;\n        d = rnd.next(0LL, p - 1);\n    }\n    else if (type == \"d_zero\") {\n        p = rnd.next(min_p, max_p);\n        d = 0;\n    }\n    else if (type == \"d_max\") {\n        p = rnd.next(min_p, max_p);\n        d = p - 1;\n    }\n    else if (type == \"p_eq_d_plus_one\") {\n        d = rnd.next(min_p, max_p - 1);\n        p = d + 1;\n        if (p < min_p) p = min_p;\n        if (p > max_p) p = max_p;\n    }\n    else if (type == \"p_minus_d_is_one\") {\n        p = rnd.next(max(min_p + 1, 2LL), max_p); // p must be at least 2\n        d = p - 1;\n    }\n    else if (type == \"p_is_one\") {\n        p = 1;\n        d = 0;\n    }\n    else if (type == \"p_minus_d_ends_with_nines\") {\n        int t = rnd.next(1, 17); // Number of trailing nines (can't be too big)\n        long long nines = pow10[t] - 1;\n        long long min_p_candidate = min_p + nines;\n        long long max_p_candidate = max_p;\n        if (min_p_candidate > max_p_candidate) min_p_candidate = max_p_candidate;\n        p = rnd.next(min_p_candidate, max_p_candidate);\n        d = p - nines;\n        if (d < 0) d = 0;\n        if (d >= p) d = p - 1;\n    }\n    else {\n        // Default to random\n        p = rnd.next(min_p, max_p);\n        d = rnd.next(0LL, p - 1);\n    }\n\n    // Ensure 1 ≤ p ≤ 1e18, 0 ≤ d < p\n    if (p < 1) p = 1;\n    if (p > 1000000000000000000LL) p = 1000000000000000000LL;\n    if (d < 0) d = 0;\n    if (d >= p) d = p - 1;\n\n    // Output p and d\n    printf(\"%lld %lld\\n\", p, d);\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    string type = opt<string>(\"type\", \"random\");\n    long long min_p = opt<long long>(\"min_p\", 1);\n    long long max_p = opt<long long>(\"max_p\", 1000000000000000000LL); // 1e18\n\n    long long p = 0, d = 0;\n\n    // Precompute powers of 10\n    long long pow10[19];\n    pow10[0] = 1;\n    for (int i = 1; i <= 18; ++i) {\n        pow10[i] = pow10[i - 1] * 10;\n    }\n\n    if (type == \"random\") {\n        p = rnd.next(min_p, max_p);\n        d = rnd.next(0LL, p - 1);\n    }\n    else if (type == \"max_p\") {\n        p = max_p;\n        d = rnd.next(0LL, p - 1);\n    }\n    else if (type == \"p_ends_with_nines\") {\n        int t = rnd.next(1, 18); // Number of trailing nines\n        long long min_leading = max(1LL, min_p / pow10[t]);\n        long long max_leading = max_p / pow10[t];\n        if (min_leading > max_leading) min_leading = max_leading;\n        long long leading = rnd.next(min_leading, max_leading);\n        p = leading * pow10[t] + pow10[t] - 1;\n        if (p > max_p) p = max_p;\n        d = rnd.next(0LL, p - 1);\n    }\n    else if (type == \"p_ends_with_zeros\") {\n        int t = rnd.next(1, 18); // Number of trailing zeros\n        long long min_leading = max(1LL, min_p / pow10[t]);\n        long long max_leading = max_p / pow10[t];\n        if (min_leading > max_leading) min_leading = max_leading;\n        long long leading = rnd.next(min_leading, max_leading);\n        p = leading * pow10[t];\n        if (p < min_p) p = min_p;\n        if (p > max_p) p = max_p;\n        d = rnd.next(0LL, p - 1);\n    }\n    else if (type == \"d_zero\") {\n        p = rnd.next(min_p, max_p);\n        d = 0;\n    }\n    else if (type == \"d_max\") {\n        p = rnd.next(min_p, max_p);\n        d = p - 1;\n    }\n    else if (type == \"p_eq_d_plus_one\") {\n        d = rnd.next(min_p, max_p - 1);\n        p = d + 1;\n        if (p < min_p) p = min_p;\n        if (p > max_p) p = max_p;\n    }\n    else if (type == \"p_minus_d_is_one\") {\n        p = rnd.next(max(min_p + 1, 2LL), max_p); // p must be at least 2\n        d = p - 1;\n    }\n    else if (type == \"p_is_one\") {\n        p = 1;\n        d = 0;\n    }\n    else if (type == \"p_minus_d_ends_with_nines\") {\n        int t = rnd.next(1, 17); // Number of trailing nines (can't be too big)\n        long long nines = pow10[t] - 1;\n        long long min_p_candidate = min_p + nines;\n        long long max_p_candidate = max_p;\n        if (min_p_candidate > max_p_candidate) min_p_candidate = max_p_candidate;\n        p = rnd.next(min_p_candidate, max_p_candidate);\n        d = p - nines;\n        if (d < 0) d = 0;\n        if (d >= p) d = p - 1;\n    }\n    else {\n        // Default to random\n        p = rnd.next(min_p, max_p);\n        d = rnd.next(0LL, p - 1);\n    }\n\n    // Ensure 1 ≤ p ≤ 1e18, 0 ≤ d < p\n    if (p < 1) p = 1;\n    if (p > 1000000000000000000LL) p = 1000000000000000000LL;\n    if (d < 0) d = 0;\n    if (d >= p) d = p - 1;\n\n    // Output p and d\n    printf(\"%lld %lld\\n\", p, d);\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -type random\n./gen -type random -min_p 1 -max_p 100\n./gen -type random -min_p 1 -max_p 1000\n./gen -type random -min_p 1e6 -max_p 1e9\n./gen -type random -min_p 1e12 -max_p 1e15\n\n./gen -type max_p\n\n./gen -type p_ends_with_nines -max_p 1000\n./gen -type p_ends_with_nines -max_p 1000000\n./gen -type p_ends_with_nines -max_p 1000000000\n./gen -type p_ends_with_nines\n\n./gen -type p_ends_with_zeros -max_p 1000\n./gen -type p_ends_with_zeros -max_p 1000000\n./gen -type p_ends_with_zeros -max_p 1000000000\n./gen -type p_ends_with_zeros\n\n./gen -type d_zero -max_p 1000\n./gen -type d_zero -max_p 1000000\n./gen -type d_zero\n\n./gen -type d_max -max_p 1000\n./gen -type d_max -max_p 1000000\n./gen -type d_max\n\n./gen -type p_eq_d_plus_one -max_p 1000\n./gen -type p_eq_d_plus_one -max_p 1000000\n./gen -type p_eq_d_plus_one\n\n./gen -type p_minus_d_is_one -max_p 1000\n./gen -type p_minus_d_is_one -max_p 1000000\n./gen -type p_minus_d_is_one\n\n./gen -type p_is_one\n\n./gen -type p_minus_d_ends_with_nines -max_p 1000\n./gen -type p_minus_d_ends_with_nines -max_p 1000000\n./gen -type p_minus_d_ends_with_nines\n\n# Generate multiple random test cases for more coverage\n./gen -type random -min_p 1 -max_p 1e18\n./gen -type random -min_p 1 -max_p 1e18\n./gen -type random -min_p 1 -max_p 1e18\n\n# Additional test cases with specific min_p and max_p\n./gen -type random -min_p 1e17 -max_p 1e18\n./gen -type random -min_p 1e3 -max_p 1e4\n./gen -type random -min_p 1e5 -max_p 1e6\n\n# Test with minimum possible p\n./gen -type random -min_p 1 -max_p 1\n\n# Test with p near d\n./gen -type random -min_p 2 -max_p 100 -type p_eq_d_plus_one\n\n# Test with maximum possible p and maximum d\n./gen -type d_max -max_p 1000000000000000000\n\n# Test with p having many trailing nines\n./gen -type p_ends_with_nines\n\n# Test with p - d resulting in many trailing nines\n./gen -type p_minus_d_ends_with_nines\n\n# Test with p being large and d being small\n./gen -type random -min_p 1e17 -max_p 1e18\n\n# Test with p being small and d being zero\n./gen -type d_zero -max_p 100\n\n# Test with p being maximum and d being zero\n./gen -type d_zero -max_p 1000000000000000000\n\n# Test with p being maximum and d being maximum\n./gen -type d_max -max_p 1000000000000000000\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T19:50:32.675775",
        "total_tutorials": 3,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "219/C",
      "title": "C. Цветная полоска",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест2 секунды",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеВ первой строке входных данных записано два целых числа n и k (1 ≤ n ≤ 5·105; 2 ≤ k ≤ 26). Вторая строка состоит из n прописных букв латинского алфавита. Буква «A» обозначает первый цвет, «B» — второй и так далее. В строке используются только первые k букв латинского алфавита. Каждая буква обозначает цвет соответствующей клетки полоски.",
      "output_spec": "Выходные данныеВыведите единственное число — искомое минимальное количество перекрашиваний. Во вторую строку выведите любой из возможных вариантов полоски после перекрашиваний.",
      "sample_tests": "ПримерыВходные данныеСкопировать6 3ABBACCВыходные данныеСкопировать2ABCACAВходные данныеСкопировать3 2BBBВыходные данныеСкопировать1BAB",
      "description": "C. Цветная полоска\n\nограничение по времени на тест2 секунды\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвыводstdout\n\nВходные данныеВ первой строке входных данных записано два целых числа n и k (1 ≤ n ≤ 5·105; 2 ≤ k ≤ 26). Вторая строка состоит из n прописных букв латинского алфавита. Буква «A» обозначает первый цвет, «B» — второй и так далее. В строке используются только первые k букв латинского алфавита. Каждая буква обозначает цвет соответствующей клетки полоски.\n\nВходные данные\n\nВыходные данныеВыведите единственное число — искомое минимальное количество перекрашиваний. Во вторую строку выведите любой из возможных вариантов полоски после перекрашиваний.\n\nВыходные данные\n\nВходные данныеСкопировать6 3ABBACCВыходные данныеСкопировать2ABCACAВходные данныеСкопировать3 2BBBВыходные данныеСкопировать1BAB\n\nВходные данныеСкопировать6 3ABBACC\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать2ABCACA\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать3 2BBB\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать1BAB\n\nВыходные данныеСкопировать\n\nСкопировать",
      "solutions": [
        {
          "title": "Codeforces Round #135 (Div. 2) - Codeforces",
          "content": "Всем привет!До Codeforces Round #135 (Div. 2) осталось всего несколько часов. Вся подготовка раунда сосредоточена в городе Петрозаводске, где проходят традиционные сборы по подготовке к ACM-ICPC. Сегодня здесь выходной, многие поехали на экскурсию в Кижи, а я с Gerald-ом готовим для вас контест. Виталик Aksenov239 Аксенов не остался равнодушен и предложил свою помощь, за что ему большое спасибо. Спасибо Маше Delinur Беловой за перевод условий.Задачи будут отсортированы по предполагаемой сложности, стоимость задач — динамическая.Всем удачи и удовольствия от раунда!",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/5156",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 570
        },
        {
          "title": "Codeforces Round #135: Разбор - Codeforces",
          "content": "Итак, начнём разбор.219A - k-StringДавайте для каждой буквы l посчитаем, сколько раз она встретилась в строке --- массив c[l]. Подсчет осуществляется примерно так: c[s[i]]++. Если количество вхождений какой-то буквы не кратно k, то мы уже сразу понимаем, что составить нужную нам строку невозможно. Теперь построим строку p: добавим в неё букв 'a', букв 'b', и так далее. Выведем полученную строку k раз.219B - Special Offer! Super Price 999 Bourles!Переберем количество девяток на конце числа от 1 до 18. Пусть эта величина равна k. В таком случае максимальное число не превосходящее заданное p можно получить так: сотрем последние k цифр числа x:  = p / 10k добавим справа k девяток y:  = x·10k + 10k - 1 если значение y больше p, то уменьшим число x (то, что идет до k девяток) на 1 и к результату допишем k девяток y:  = (x - 1)·10k + 10k - 1 Если получившееся y >  = p - d, то обновим ответ значением k.219C - Color StripeРазберём 2 два случая: k равно 2. Тогда нам подходят только две строки — чередующиеся буквы 'A' и 'B'. Выбираем из них тот, который требует меньшего числа перекрасок. k больше 2. Возьмем самый левый блок из одинаковых букв. Пусть его длина равна k, тогда надо не менее k / 2 перекрашиваний, чтобы избавиться от соседних одинаковых клеток в этом блоке. Если k нечетно, то можно каждую вторую клетку в блоке перекрасить в любой из цветов, отличных от цвета блока. Если k четно, то можно делать тоже самое, но аккуратнее выбрать цвет: он должен отличаться не только от цвета блока, но и от цвета следующей клетки за блоком. Это всегда возможно сделать, так как количество цветов больше 2. 219D - Choosing Capital for TreelandДля того, чтобы решить эту задачу посчитаем для каждого города количество ребер, которые надо переориентировать, чтобы данный город стал столицей.В задаче были достаточно большие ограничения, поэтому нельзя было просто посчитать все эти значения n обходами в глубину. Авторское решение запускает только два обхода в глубину. Первым обходом в глубину посчитаем ответ для города номер 1. Заметим, что если посчитан ответ для вершины x, то ответ для вершины y, которая соединена с x, можно посчитать за O(1). А именно, ans(y) = ans(x) - direction(x, y) + (1 - direction(x, y)), где direction(x, y) — равно 1, если ребро (x, y) ориентировано не так как во входных данных, и равно 0, иначе. Пользуясь описанным фактом, можно посчитать все значения ans(v) одним обходом, зная ans(1).Итоговая ассимптотика решения O(n).219E - Parking LotБудем поддерживать две структуры: множество отрезков свободных парковочных мест, в котором отрезки отсортированы по их началу, и множество отрезков свободных парковочных мест отсортированных по размеру. Такие структуры должны поддерживать операцию быстрого поиска первого больше либо равного элемента, удаление элемента и его вставку, нахождениe максимума и следующего по величине элемента.В языке C++, авторское решение использовало set <pair<int,int>> и map <int, set<int>>. Set отрезков и Map из длины отрезка в набор отрезков с заданной длиной. Операция поиска больше либо равного элемента в этих структурах называется lower_bound.Научимся поддерживать эти структуры от операции к операции. Для того, чтобы определить автомобилиста на стоянку, нужно взять свободный отрезок с максимальной длиной или с (максимальной длиной минус один), который не упирается в начало или конец стоянки, и попробовать определить автомобилиста на свободное парковочное место в середину этого отрезка (если точной середины нет, то в ближайшую к ней клетеку). Среди всех таких позиций нужно выбрать наилучшую (в смысле условия задачи). После нахождения лучшей позиции надо разрезать соотвествующий отрезок свободных позиций на два и обновить обе структуры (удалить старый отрезок и вставить два новых).Чтобы удалить автомобилиста со стоянки нужно добавить новый отрезок свободных парковочных мест длины один в структуру. Предварительно нужно удалить смежные с этим отрезком отрезки в структуре. Соединить их с нашим отрезком и добавить один большой отрезок в структуру.Отдельные случаи возникает при рассмотрении крайних отрезков. Итоговая сложность решения O(m log n)",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/5158",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 219\\s*C"
          },
          "content_length": 4129
        },
        {
          "title": "User editorial for Codeforces Round #135 (Div. 2) - Codeforces",
          "content": "The contest was well balanced — scores for tasks were very close to standard scores. I hope you will find this editorial useful.A :: k-StringCount the occurrences of each character. If any character appears a number of times not divisible by K, obviously, there is no solution. Otherwise, form the solution by first making the string B. The string B can be any string with the following property: if some character ch appears q times in the string B, the same character appears q***K** times in the given string. Now, just print that string K times.B :: Special Offer! Super Price 999 Bourles!The following observation will help you code the solution:The largest number smaller than p ending with at least k nines is p - p MOD 10^k - 1 If the result turns out to be -1 , you can not reach a positive number with k or more nines. I will not explain the solution in detail — be careful when coding and have all the task statements in mind.C :: Color StripeThere are two cases to consider , when K=2 and when K>2. For K=2 there are only two possible solutions: the string \"ABABAB...\" and \"BABABA...\"For both strings, simply count the number of differences between it and the given string and print a string with fewer differences.For K>2 , decompose the string into contiguous single-colored sequences. Observe one such sequence. If it has an odd number of characters, say 2m+1, replace m characters with some other character in the following fashion:AAAAAbecomesABABAIt can be observed that by changing less than m characters doesn't remove all pairs of adjacent identical characters. Similarly, for sequences of even length, say 2m characters, observe a character in the original string right after the last character of the observed sequence, and choose a character different from both. Example:AAAAAABbecomesACACACBAgain, it is sufficient and necessary to change m characters.D :: Choosing Capital for TreelandArbitrarily root the tree at some vertex, say vertex 1. Now, all the edges are oriented either up (towards the root) or down (away from it). We will call upwards oriented edges red, and downwards oriented edges green. Now, with a single depth-first search, for each vertex, calculate its distance from the root (in number of edges) and the number of red edges along the path to the root. Also, count the number of red edges in the entire tree.Now comes the interesting part: Observe that all edges outside the path from the root to vert should turn green, and those on the path should turn red.The number of edges that need to be flipped if vert is chosen as a capital is given by:RedEntireTree - 2*RedOnPath[vert] + RootDistance[vert]E :: Parking LotUse a heap to maintain sequences of empty parking spaces as intervals. The comparison function for such intervals should return an interval which could store a car farthest from any other car, and if there is a tie, it should return the leftmost such interval. When inserting a car, pop the heap, look at the interval, place a car in the corresponding space and push two new intervals onto the heap. When removing a car, you should be able to find the two intervals which end at that car, remove them from the heap and push a new interval which forms when the two merge.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/5160",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 3232
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #135 (Div. 2) - Codeforces - Code 1",
          "code": "1. первый из пары стоит правильно \n2. вторый из пары стоит правильно",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5156",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #135 (Div. 2) - Codeforces - Code 2",
          "code": "1. первый из пары стоит правильно \n2. вторый из пары стоит правильно",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5156",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #135 (Div. 2) - Codeforces - Code 3",
          "code": "long long int a=10, t=1;\nwhile(t<3) {\n    long long int test=(long long int) (pow((long long int)10,t));\n    cout<<test<<endl ;\n    t++;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5156",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #135 (Div. 2) - Codeforces - Code 4",
          "code": "Print the required price — the maximum price that ends with the largest number of nines and that is less than p by no more than d.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5156",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #135 (Div. 2) - Codeforces - Code 5",
          "code": "Print the required price — the maximum price that ends with the largest number of nines and that is less than p by no more than d.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5156",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #135 (Div. 2) - Codeforces - Code 6",
          "code": "#pragma optimization_level 3 \n#pragma GCC optimize(\"Ofast,no-stack-protector,unroll-loops,fast-math,O3\") \n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx\")",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5156",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #135 (Div. 2) - Codeforces - Code 7",
          "code": "#pragma optimization_level 3 \n#pragma GCC optimize(\"Ofast,no-stack-protector,unroll-loops,fast-math,O3\") \n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx\")",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5156",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #135: Разбор - Codeforces - Code 1",
          "code": "<pair<int,int>>",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5158",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #135: Разбор - Codeforces - Code 2",
          "code": "<int, set<int>>",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5158",
          "author": "jiangly"
        },
        {
          "title": "User editorial for Codeforces Round #135 (Div. 2) - Codeforces - Code 1",
          "code": "p - p MOD 10^k - 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5160",
          "author": "jiangly"
        },
        {
          "title": "User editorial for Codeforces Round #135 (Div. 2) - Codeforces - Code 2",
          "code": "RedEntireTree - 2*RedOnPath[vert] + RootDistance[vert]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5160",
          "author": "jiangly"
        },
        {
          "title": "User editorial for Codeforces Round #135 (Div. 2) - Codeforces - Code 3",
          "code": "for (int i=1;i<n;i++){\n        cin>>a>>b;\n        temp = ar[a];\n        while(temp->next!=NULL){\n            temp = temp->next;\n        }\n        temp->next = new Node(b, 1, 0);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5160",
          "author": "jiangly"
        },
        {
          "title": "User editorial for Codeforces Round #135 (Div. 2) - Codeforces - Code 4",
          "code": "for (int i=1;i<n;i++){\n        cin>>a>>b;\n        temp = ar[a];\n        while(temp->next!=NULL){\n            temp = temp->next;\n        }\n        temp->next = new Node(b, 1, 0);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5160",
          "author": "jiangly"
        },
        {
          "title": "User editorial for Codeforces Round #135 (Div. 2) - Codeforces - Code 5",
          "code": "struct node\n{\n    vector<node*> edges;\n} nodes[big_number];\n\n...\n\nfor (int i = 0; i < number_of_edges; i++)\n{\n    int a, b;\n    scanf(\"%d%d\", &a, &b);\n    nodes[a].edges.push_back(nodes + b);\n    nodes[b].edges.push_back(nodes + a);\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5160",
          "author": "jiangly"
        },
        {
          "title": "User editorial for Codeforces Round #135 (Div. 2) - Codeforces - Code 6",
          "code": "struct node\n{\n    vector<node*> edges;\n} nodes[big_number];\n\n...\n\nfor (int i = 0; i < number_of_edges; i++)\n{\n    int a, b;\n    scanf(\"%d%d\", &a, &b);\n    nodes[a].edges.push_back(nodes + b);\n    nodes[b].edges.push_back(nodes + a);\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5160",
          "author": "jiangly"
        },
        {
          "title": "User editorial for Codeforces Round #135 (Div. 2) - Codeforces - Code 7",
          "code": "RedEntireTree — 2*RedOnPath[vert] + RootDistance[vert]\n= (RedEntireTree - RedOnPath[vert]) + (RootDistance[vert] - RedOnPath[vert])\n=           RedOutsidePath          +            GreenOnPath",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5160",
          "author": "jiangly"
        },
        {
          "title": "User editorial for Codeforces Round #135 (Div. 2) - Codeforces - Code 8",
          "code": "RedEntireTree — 2*RedOnPath[vert] + RootDistance[vert]\n= (RedEntireTree - RedOnPath[vert]) + (RootDistance[vert] - RedOnPath[vert])\n=           RedOutsidePath          +            GreenOnPath",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5160",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 500000, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(2, 26, \"k\");\n    inf.readEoln();\n\n    string s = inf.readToken();\n    inf.readEoln();\n\n    ensuref((int)s.length() == n, \"The length of the string must be %d, but is %d\", n, (int)s.length());\n\n    char max_allowed_char = 'A' + k - 1;\n\n    for(int i = 0; i < n; ++i) {\n        char c = s[i];\n        ensuref(c >= 'A' && c <= max_allowed_char, \"Character '%c' at position %d is invalid (should be between 'A' and '%c')\", c, i + 1, max_allowed_char);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 500000, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(2, 26, \"k\");\n    inf.readEoln();\n\n    string s = inf.readToken();\n    inf.readEoln();\n\n    ensuref((int)s.length() == n, \"The length of the string must be %d, but is %d\", n, (int)s.length());\n\n    char max_allowed_char = 'A' + k - 1;\n\n    for(int i = 0; i < n; ++i) {\n        char c = s[i];\n        ensuref(c >= 'A' && c <= max_allowed_char, \"Character '%c' at position %d is invalid (should be between 'A' and '%c')\", c, i + 1, max_allowed_char);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 500000, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(2, 26, \"k\");\n    inf.readEoln();\n\n    string s = inf.readToken();\n    inf.readEoln();\n\n    ensuref((int)s.length() == n, \"The length of the string must be %d, but is %d\", n, (int)s.length());\n\n    char max_allowed_char = 'A' + k - 1;\n\n    for(int i = 0; i < n; ++i) {\n        char c = s[i];\n        ensuref(c >= 'A' && c <= max_allowed_char, \"Character '%c' at position %d is invalid (should be between 'A' and '%c')\", c, i + 1, max_allowed_char);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint n, k;\nstring S;\n\nint compute_min_repaintings(string S, int n, int k) {\n    int minimal_repaintings = 0;\n    if (k == 2) {\n        // Try both patterns\n        string pattern1 = \"\";\n        string pattern2 = \"\";\n        char colors[2] = {'A', 'B'};\n        for (int i = 0; i < n; ++i) {\n            pattern1 += colors[i % 2];\n            pattern2 += colors[(i + 1) % 2];\n        }\n        int repaintings1 = 0, repaintings2 = 0;\n        for (int i = 0; i < n; ++i) {\n            if (S[i] != pattern1[i]) repaintings1++;\n            if (S[i] != pattern2[i]) repaintings2++;\n        }\n        minimal_repaintings = min(repaintings1, repaintings2);\n    } else {\n        // For k >= 3, greedy approach\n        int repaintings = 0;\n        string tmp = S;\n        for (int i = 0; i < n; ++i) {\n            if (i > 0 && tmp[i] == tmp[i - 1]) {\n                repaintings++;\n                // Repaint tmp[i] to a different color\n                for (char c = 'A'; c < 'A' + k; ++c) {\n                    if (c != tmp[i - 1] && (i + 1 >= n || c != tmp[i + 1])) {\n                        tmp[i] = c;\n                        break;\n                    }\n                }\n            }\n        }\n        minimal_repaintings = repaintings;\n    }\n    return minimal_repaintings;\n}\n\nint main(int argc, char * argv[]) {\n    registerTestlibCmd(argc, argv);\n\n    n = inf.readInt();\n    k = inf.readInt();\n    S = inf.readToken();\n    if (S.length() != n)\n        quitf(_fail, \"Input string length (%d) does not match n (%d)\", (int)S.length(), n);\n\n    int minimal_repaintings = compute_min_repaintings(S, n, k);\n\n    int p_repaintings = ouf.readInt(0, n, \"number of repaintings\");\n    string T = ouf.readToken();\n    if (T.length() != n)\n        quitf(_wa, \"Repainted stripe length (%d) is incorrect (expected %d)\", (int)T.length(), n);\n\n    // Check that T only contains allowed colors\n    for (int i = 0; i < n; ++i) {\n        if (T[i] < 'A' || T[i] >= 'A' + k)\n            quitf(_wa, \"Invalid color '%c' at position %d\", T[i], i + 1);\n    }\n\n    // Check that T has no two adjacent same characters\n    for (int i = 0; i < n - 1; ++i) {\n        if (T[i] == T[i + 1])\n            quitf(_wa, \"Two adjacent cells have the same color '%c' at positions %d and %d\", T[i], i + 1, i + 2);\n    }\n\n    // Verify that the number of repaintings is correct\n    int actual_repaintings = 0;\n    for (int i = 0; i < n; ++i) {\n        if (S[i] != T[i]) actual_repaintings++;\n    }\n    if (actual_repaintings != p_repaintings)\n        quitf(_wa, \"Claimed number of repaintings (%d) does not match actual repaintings (%d)\", p_repaintings, actual_repaintings);\n\n    // Verify that the claimed number is minimal\n    if (p_repaintings != minimal_repaintings)\n        quitf(_wa, \"Claimed minimal number of repaintings (%d) is not minimal (expected %d)\", p_repaintings, minimal_repaintings);\n\n    // All checks passed\n    quitf(_ok, \"Correct answer with %d repaintings\", minimal_repaintings);\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int k = opt<int>(\"k\");\n    string type = opt<string>(\"type\", \"random\");\n\n    ensure(1 <= n && n <= 500000);\n    ensure(2 <= k && k <= 26);\n\n    string s(n, 'A');\n\n    if (type == \"random\") {\n        // Generate a random string of length n using k colors.\n        for (int i = 0; i < n; ++i) {\n            s[i] = 'A' + rnd.next(0, k - 1);\n        }\n    } else if (type == \"same\") {\n        // All cells are the same color.\n        char c = 'A' + rnd.next(0, k - 1);\n        s.assign(n, c);\n    } else if (type == \"alternating\") {\n        // Alternating between two colors.\n        if (k < 2) {\n            fprintf(stderr, \"Error: k must be at least 2 for 'alternating' type.\\n\");\n            exit(1);\n        }\n        int idx1 = rnd.next(0, k - 1);\n        int idx2 = rnd.next(0, k - 2);\n        if (idx2 >= idx1)\n            idx2++;\n        char c1 = 'A' + idx1;\n        char c2 = 'A' + idx2;\n        for (int i = 0; i < n; ++i) {\n            s[i] = (i % 2 == 0) ? c1 : c2;\n        }\n    } else if (type == \"minimal_changes\") {\n        // The stripe is already properly colored (no two neighboring cells are the same).\n        int prev = -1;\n        for (int i = 0; i < n; ++i) {\n            int c = rnd.next(0, k - 1);\n            if (c == prev)\n                c = (c + 1) % k;\n            s[i] = 'A' + c;\n            prev = c;\n        }\n    } else if (type == \"maximal_changes\") {\n        // Generate a string that requires maximal number of repaintings.\n        int i = 0;\n        while (i < n) {\n            int len = rnd.next(1, 100);\n            char c = 'A' + rnd.next(0, k - 1);\n            for (int j = 0; j < len && i < n; ++j, ++i) {\n                s[i] = c;\n            }\n        }\n    } else if (type == \"worst_case_k2\") {\n        // Generate a worst-case string for k=2.\n        if (k != 2) {\n            fprintf(stderr, \"Error: k must be 2 for 'worst_case_k2' type.\\n\");\n            exit(1);\n        }\n        int i = 0;\n        while (i < n) {\n            int len = rnd.next(1, 100);\n            char c = 'A' + rnd.next(0, 1);\n            for (int j = 0; j < len && i < n; ++j, ++i) {\n                s[i] = c;\n            }\n        }\n    } else {\n        fprintf(stderr, \"Error: Unknown type '%s'.\\n\", type.c_str());\n        exit(1);\n    }\n\n    // Output the generated test case.\n    printf(\"%d %d\\n\", n, k);\n    printf(\"%s\\n\", s.c_str());\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int k = opt<int>(\"k\");\n    string type = opt<string>(\"type\", \"random\");\n\n    ensure(1 <= n && n <= 500000);\n    ensure(2 <= k && k <= 26);\n\n    string s(n, 'A');\n\n    if (type == \"random\") {\n        // Generate a random string of length n using k colors.\n        for (int i = 0; i < n; ++i) {\n            s[i] = 'A' + rnd.next(0, k - 1);\n        }\n    } else if (type == \"same\") {\n        // All cells are the same color.\n        char c = 'A' + rnd.next(0, k - 1);\n        s.assign(n, c);\n    } else if (type == \"alternating\") {\n        // Alternating between two colors.\n        if (k < 2) {\n            fprintf(stderr, \"Error: k must be at least 2 for 'alternating' type.\\n\");\n            exit(1);\n        }\n        int idx1 = rnd.next(0, k - 1);\n        int idx2 = rnd.next(0, k - 2);\n        if (idx2 >= idx1)\n            idx2++;\n        char c1 = 'A' + idx1;\n        char c2 = 'A' + idx2;\n        for (int i = 0; i < n; ++i) {\n            s[i] = (i % 2 == 0) ? c1 : c2;\n        }\n    } else if (type == \"minimal_changes\") {\n        // The stripe is already properly colored (no two neighboring cells are the same).\n        int prev = -1;\n        for (int i = 0; i < n; ++i) {\n            int c = rnd.next(0, k - 1);\n            if (c == prev)\n                c = (c + 1) % k;\n            s[i] = 'A' + c;\n            prev = c;\n        }\n    } else if (type == \"maximal_changes\") {\n        // Generate a string that requires maximal number of repaintings.\n        int i = 0;\n        while (i < n) {\n            int len = rnd.next(1, 100);\n            char c = 'A' + rnd.next(0, k - 1);\n            for (int j = 0; j < len && i < n; ++j, ++i) {\n                s[i] = c;\n            }\n        }\n    } else if (type == \"worst_case_k2\") {\n        // Generate a worst-case string for k=2.\n        if (k != 2) {\n            fprintf(stderr, \"Error: k must be 2 for 'worst_case_k2' type.\\n\");\n            exit(1);\n        }\n        int i = 0;\n        while (i < n) {\n            int len = rnd.next(1, 100);\n            char c = 'A' + rnd.next(0, 1);\n            for (int j = 0; j < len && i < n; ++j, ++i) {\n                s[i] = c;\n            }\n        }\n    } else {\n        fprintf(stderr, \"Error: Unknown type '%s'.\\n\", type.c_str());\n        exit(1);\n    }\n\n    // Output the generated test case.\n    printf(\"%d %d\\n\", n, k);\n    printf(\"%s\\n\", s.c_str());\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -k 2 -type random\n./gen -n 1 -k 2 -type same\n./gen -n 1 -k 2 -type minimal_changes\n./gen -n 1 -k 2 -type maximal_changes\n\n./gen -n 10 -k 2 -type random\n./gen -n 10 -k 2 -type alternating\n./gen -n 10 -k 2 -type worst_case_k2\n\n./gen -n 100 -k 2 -type random\n./gen -n 100 -k 2 -type same\n./gen -n 100 -k 2 -type maximal_changes\n./gen -n 100 -k 2 -type worst_case_k2\n\n./gen -n 1000 -k 2 -type random\n./gen -n 1000 -k 2 -type alternating\n./gen -n 1000 -k 2 -type worst_case_k2\n\n./gen -n 500000 -k 2 -type random\n./gen -n 500000 -k 2 -type worst_case_k2\n\n./gen -n 500000 -k 26 -type random\n./gen -n 500000 -k 26 -type minimal_changes\n./gen -n 500000 -k 26 -type maximal_changes\n\n./gen -n 500000 -k 2 -type same\n\n./gen -n 500000 -k 2 -type alternating\n\n./gen -n 10 -k 3 -type random\n./gen -n 10 -k 3 -type alternating\n\n./gen -n 100 -k 3 -type minimal_changes\n./gen -n 100 -k 3 -type maximal_changes\n\n./gen -n 10000 -k 26 -type random\n\n./gen -n 100000 -k 26 -type minimal_changes\n\n./gen -n 500000 -k 26 -type same\n\n./gen -n 500000 -k 3 -type maximal_changes\n\n./gen -n 500000 -k 2 -type maximal_changes\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T19:50:35.140872",
        "total_tutorials": 3,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "219/D",
      "title": "D. Choosing Capital for Treeland",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test3 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first input line contains integer n (2 ≤ n ≤ 2·105) — the number of cities in Treeland. Next n - 1 lines contain the descriptions of the roads, one road per line. A road is described by a pair of integers si, ti (1 ≤ si, ti ≤ n; si ≠ ti) — the numbers of cities, connected by that road. The i-th road is oriented from city si to city ti. You can consider cities in Treeland indexed from 1 to n.",
      "output_spec": "OutputIn the first line print the minimum number of roads to be inversed if the capital is chosen optimally. In the second line print all possible ways to choose the capital — a sequence of indexes of cities in the increasing order.",
      "sample_tests": "ExamplesInputCopy32 12 3OutputCopy02 InputCopy41 42 43 4OutputCopy21 2 3",
      "description": "D. Choosing Capital for Treeland\n\ntime limit per test3 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first input line contains integer n (2 ≤ n ≤ 2·105) — the number of cities in Treeland. Next n - 1 lines contain the descriptions of the roads, one road per line. A road is described by a pair of integers si, ti (1 ≤ si, ti ≤ n; si ≠ ti) — the numbers of cities, connected by that road. The i-th road is oriented from city si to city ti. You can consider cities in Treeland indexed from 1 to n.\n\nOutputIn the first line print the minimum number of roads to be inversed if the capital is chosen optimally. In the second line print all possible ways to choose the capital — a sequence of indexes of cities in the increasing order.\n\nInputCopy32 12 3OutputCopy02 InputCopy41 42 43 4OutputCopy21 2 3\n\nInputCopy32 12 3\n\nOutputCopy02\n\nInputCopy41 42 43 4\n\nOutputCopy21 2 3",
      "solutions": [
        {
          "title": "Codeforces Round #135 (Div. 2) - Codeforces",
          "content": "Hello!Only few hours left before Codeforces Round # 135 (Div. 2). We are preparing the round in Petrozavodsk where traditional training camp for ACM-ICPC is going now. Today is a day of rest here, many participants gone to a trip to Kizhi. The main contest authors are me and Gerald. Special thanks to Aksenov239 who tested the round. Thank Delinur for translation.The problems will be sorted by expected difficulty, the scores are dynamic.Wish you fun round!",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/5156",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 459
        },
        {
          "title": "Codeforces Round #135: Разбор - Codeforces",
          "content": "Итак, начнём разбор.219A - k-StringДавайте для каждой буквы l посчитаем, сколько раз она встретилась в строке --- массив c[l]. Подсчет осуществляется примерно так: c[s[i]]++. Если количество вхождений какой-то буквы не кратно k, то мы уже сразу понимаем, что составить нужную нам строку невозможно. Теперь построим строку p: добавим в неё букв 'a', букв 'b', и так далее. Выведем полученную строку k раз.219B - Special Offer! Super Price 999 Bourles!Переберем количество девяток на конце числа от 1 до 18. Пусть эта величина равна k. В таком случае максимальное число не превосходящее заданное p можно получить так: сотрем последние k цифр числа x:  = p / 10k добавим справа k девяток y:  = x·10k + 10k - 1 если значение y больше p, то уменьшим число x (то, что идет до k девяток) на 1 и к результату допишем k девяток y:  = (x - 1)·10k + 10k - 1 Если получившееся y >  = p - d, то обновим ответ значением k.219C - Color StripeРазберём 2 два случая: k равно 2. Тогда нам подходят только две строки — чередующиеся буквы 'A' и 'B'. Выбираем из них тот, который требует меньшего числа перекрасок. k больше 2. Возьмем самый левый блок из одинаковых букв. Пусть его длина равна k, тогда надо не менее k / 2 перекрашиваний, чтобы избавиться от соседних одинаковых клеток в этом блоке. Если k нечетно, то можно каждую вторую клетку в блоке перекрасить в любой из цветов, отличных от цвета блока. Если k четно, то можно делать тоже самое, но аккуратнее выбрать цвет: он должен отличаться не только от цвета блока, но и от цвета следующей клетки за блоком. Это всегда возможно сделать, так как количество цветов больше 2. 219D - Choosing Capital for TreelandДля того, чтобы решить эту задачу посчитаем для каждого города количество ребер, которые надо переориентировать, чтобы данный город стал столицей.В задаче были достаточно большие ограничения, поэтому нельзя было просто посчитать все эти значения n обходами в глубину. Авторское решение запускает только два обхода в глубину. Первым обходом в глубину посчитаем ответ для города номер 1. Заметим, что если посчитан ответ для вершины x, то ответ для вершины y, которая соединена с x, можно посчитать за O(1). А именно, ans(y) = ans(x) - direction(x, y) + (1 - direction(x, y)), где direction(x, y) — равно 1, если ребро (x, y) ориентировано не так как во входных данных, и равно 0, иначе. Пользуясь описанным фактом, можно посчитать все значения ans(v) одним обходом, зная ans(1).Итоговая ассимптотика решения O(n).219E - Parking LotБудем поддерживать две структуры: множество отрезков свободных парковочных мест, в котором отрезки отсортированы по их началу, и множество отрезков свободных парковочных мест отсортированных по размеру. Такие структуры должны поддерживать операцию быстрого поиска первого больше либо равного элемента, удаление элемента и его вставку, нахождениe максимума и следующего по величине элемента.В языке C++, авторское решение использовало set <pair<int,int>> и map <int, set<int>>. Set отрезков и Map из длины отрезка в набор отрезков с заданной длиной. Операция поиска больше либо равного элемента в этих структурах называется lower_bound.Научимся поддерживать эти структуры от операции к операции. Для того, чтобы определить автомобилиста на стоянку, нужно взять свободный отрезок с максимальной длиной или с (максимальной длиной минус один), который не упирается в начало или конец стоянки, и попробовать определить автомобилиста на свободное парковочное место в середину этого отрезка (если точной середины нет, то в ближайшую к ней клетеку). Среди всех таких позиций нужно выбрать наилучшую (в смысле условия задачи). После нахождения лучшей позиции надо разрезать соотвествующий отрезок свободных позиций на два и обновить обе структуры (удалить старый отрезок и вставить два новых).Чтобы удалить автомобилиста со стоянки нужно добавить новый отрезок свободных парковочных мест длины один в структуру. Предварительно нужно удалить смежные с этим отрезком отрезки в структуре. Соединить их с нашим отрезком и добавить один большой отрезок в структуру.Отдельные случаи возникает при рассмотрении крайних отрезков. Итоговая сложность решения O(m log n)",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/5158",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 219\\s*D"
          },
          "content_length": 4129
        },
        {
          "title": "User editorial for Codeforces Round #135 (Div. 2) - Codeforces",
          "content": "The contest was well balanced — scores for tasks were very close to standard scores. I hope you will find this editorial useful.A :: k-StringCount the occurrences of each character. If any character appears a number of times not divisible by K, obviously, there is no solution. Otherwise, form the solution by first making the string B. The string B can be any string with the following property: if some character ch appears q times in the string B, the same character appears q***K** times in the given string. Now, just print that string K times.B :: Special Offer! Super Price 999 Bourles!The following observation will help you code the solution:The largest number smaller than p ending with at least k nines is p - p MOD 10^k - 1 If the result turns out to be -1 , you can not reach a positive number with k or more nines. I will not explain the solution in detail — be careful when coding and have all the task statements in mind.C :: Color StripeThere are two cases to consider , when K=2 and when K>2. For K=2 there are only two possible solutions: the string \"ABABAB...\" and \"BABABA...\"For both strings, simply count the number of differences between it and the given string and print a string with fewer differences.For K>2 , decompose the string into contiguous single-colored sequences. Observe one such sequence. If it has an odd number of characters, say 2m+1, replace m characters with some other character in the following fashion:AAAAAbecomesABABAIt can be observed that by changing less than m characters doesn't remove all pairs of adjacent identical characters. Similarly, for sequences of even length, say 2m characters, observe a character in the original string right after the last character of the observed sequence, and choose a character different from both. Example:AAAAAABbecomesACACACBAgain, it is sufficient and necessary to change m characters.D :: Choosing Capital for TreelandArbitrarily root the tree at some vertex, say vertex 1. Now, all the edges are oriented either up (towards the root) or down (away from it). We will call upwards oriented edges red, and downwards oriented edges green. Now, with a single depth-first search, for each vertex, calculate its distance from the root (in number of edges) and the number of red edges along the path to the root. Also, count the number of red edges in the entire tree.Now comes the interesting part: Observe that all edges outside the path from the root to vert should turn green, and those on the path should turn red.The number of edges that need to be flipped if vert is chosen as a capital is given by:RedEntireTree - 2*RedOnPath[vert] + RootDistance[vert]E :: Parking LotUse a heap to maintain sequences of empty parking spaces as intervals. The comparison function for such intervals should return an interval which could store a car farthest from any other car, and if there is a tie, it should return the leftmost such interval. When inserting a car, pop the heap, look at the interval, place a car in the corresponding space and push two new intervals onto the heap. When removing a car, you should be able to find the two intervals which end at that car, remove them from the heap and push a new interval which forms when the two merge.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/5160",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 3232
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #135 (Div. 2) - Codeforces - Code 1",
          "code": "long long int a=10, t=1;\nwhile(t<3) {\n    long long int test=(long long int) (pow((long long int)10,t));\n    cout<<test<<endl ;\n    t++;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5156",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #135 (Div. 2) - Codeforces - Code 2",
          "code": "Print the required price — the maximum price that ends with the largest number of nines and that is less than p by no more than d.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5156",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #135 (Div. 2) - Codeforces - Code 3",
          "code": "Print the required price — the maximum price that ends with the largest number of nines and that is less than p by no more than d.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5156",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #135 (Div. 2) - Codeforces - Code 4",
          "code": "#pragma optimization_level 3 \n#pragma GCC optimize(\"Ofast,no-stack-protector,unroll-loops,fast-math,O3\") \n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx\")",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5156",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #135 (Div. 2) - Codeforces - Code 5",
          "code": "#pragma optimization_level 3 \n#pragma GCC optimize(\"Ofast,no-stack-protector,unroll-loops,fast-math,O3\") \n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx\")",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5156",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #135: Разбор - Codeforces - Code 1",
          "code": "<pair<int,int>>",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5158",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #135: Разбор - Codeforces - Code 2",
          "code": "<int, set<int>>",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5158",
          "author": "jiangly"
        },
        {
          "title": "User editorial for Codeforces Round #135 (Div. 2) - Codeforces - Code 1",
          "code": "p - p MOD 10^k - 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5160",
          "author": "jiangly"
        },
        {
          "title": "User editorial for Codeforces Round #135 (Div. 2) - Codeforces - Code 2",
          "code": "RedEntireTree - 2*RedOnPath[vert] + RootDistance[vert]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5160",
          "author": "jiangly"
        },
        {
          "title": "User editorial for Codeforces Round #135 (Div. 2) - Codeforces - Code 3",
          "code": "for (int i=1;i<n;i++){\n        cin>>a>>b;\n        temp = ar[a];\n        while(temp->next!=NULL){\n            temp = temp->next;\n        }\n        temp->next = new Node(b, 1, 0);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5160",
          "author": "jiangly"
        },
        {
          "title": "User editorial for Codeforces Round #135 (Div. 2) - Codeforces - Code 4",
          "code": "for (int i=1;i<n;i++){\n        cin>>a>>b;\n        temp = ar[a];\n        while(temp->next!=NULL){\n            temp = temp->next;\n        }\n        temp->next = new Node(b, 1, 0);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5160",
          "author": "jiangly"
        },
        {
          "title": "User editorial for Codeforces Round #135 (Div. 2) - Codeforces - Code 5",
          "code": "struct node\n{\n    vector<node*> edges;\n} nodes[big_number];\n\n...\n\nfor (int i = 0; i < number_of_edges; i++)\n{\n    int a, b;\n    scanf(\"%d%d\", &a, &b);\n    nodes[a].edges.push_back(nodes + b);\n    nodes[b].edges.push_back(nodes + a);\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5160",
          "author": "jiangly"
        },
        {
          "title": "User editorial for Codeforces Round #135 (Div. 2) - Codeforces - Code 6",
          "code": "struct node\n{\n    vector<node*> edges;\n} nodes[big_number];\n\n...\n\nfor (int i = 0; i < number_of_edges; i++)\n{\n    int a, b;\n    scanf(\"%d%d\", &a, &b);\n    nodes[a].edges.push_back(nodes + b);\n    nodes[b].edges.push_back(nodes + a);\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5160",
          "author": "jiangly"
        },
        {
          "title": "User editorial for Codeforces Round #135 (Div. 2) - Codeforces - Code 7",
          "code": "RedEntireTree — 2*RedOnPath[vert] + RootDistance[vert]\n= (RedEntireTree - RedOnPath[vert]) + (RootDistance[vert] - RedOnPath[vert])\n=           RedOutsidePath          +            GreenOnPath",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5160",
          "author": "jiangly"
        },
        {
          "title": "User editorial for Codeforces Round #135 (Div. 2) - Codeforces - Code 8",
          "code": "RedEntireTree — 2*RedOnPath[vert] + RootDistance[vert]\n= (RedEntireTree - RedOnPath[vert]) + (RootDistance[vert] - RedOnPath[vert])\n=           RedOutsidePath          +            GreenOnPath",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5160",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(2, 200000, \"n\");\n    inf.readEoln();\n\n    vector<vector<int>> adj(n + 1);\n    set<pair<int, int>> edges;\n\n    for (int i = 0; i < n - 1; ++i) {\n        int si = inf.readInt(1, n, \"si\");\n        inf.readSpace();\n        int ti = inf.readInt(1, n, \"ti\");\n        inf.readEoln();\n        ensuref(si != ti, \"Edge cannot be between a node and itself: %d\", si);\n\n        int u = si;\n        int v = ti;\n        if (u > v) swap(u, v);\n        pair<int, int> edge = make_pair(u, v);\n        ensuref(edges.count(edge) == 0, \"Multiple edges between nodes %d and %d\", u, v);\n        edges.insert(edge);\n\n        adj[si].push_back(ti);\n        adj[ti].push_back(si);\n    }\n\n    vector<bool> visited(n + 1, false);\n    function<void(int)> dfs = [&](int u) {\n        visited[u] = true;\n        for (int v : adj[u]) {\n            if (!visited[v]) {\n                dfs(v);\n            }\n        }\n    };\n\n    dfs(1);\n\n    for (int i = 1; i <= n; ++i) {\n        ensuref(visited[i], \"Node %d is not connected to the graph\", i);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(2, 200000, \"n\");\n    inf.readEoln();\n\n    vector<vector<int>> adj(n + 1);\n    set<pair<int, int>> edges;\n\n    for (int i = 0; i < n - 1; ++i) {\n        int si = inf.readInt(1, n, \"si\");\n        inf.readSpace();\n        int ti = inf.readInt(1, n, \"ti\");\n        inf.readEoln();\n        ensuref(si != ti, \"Edge cannot be between a node and itself: %d\", si);\n\n        int u = si;\n        int v = ti;\n        if (u > v) swap(u, v);\n        pair<int, int> edge = make_pair(u, v);\n        ensuref(edges.count(edge) == 0, \"Multiple edges between nodes %d and %d\", u, v);\n        edges.insert(edge);\n\n        adj[si].push_back(ti);\n        adj[ti].push_back(si);\n    }\n\n    vector<bool> visited(n + 1, false);\n    function<void(int)> dfs = [&](int u) {\n        visited[u] = true;\n        for (int v : adj[u]) {\n            if (!visited[v]) {\n                dfs(v);\n            }\n        }\n    };\n\n    dfs(1);\n\n    for (int i = 1; i <= n; ++i) {\n        ensuref(visited[i], \"Node %d is not connected to the graph\", i);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(2, 200000, \"n\");\n    inf.readEoln();\n\n    vector<vector<int>> adj(n + 1);\n    set<pair<int, int>> edges;\n\n    for (int i = 0; i < n - 1; ++i) {\n        int si = inf.readInt(1, n, \"si\");\n        inf.readSpace();\n        int ti = inf.readInt(1, n, \"ti\");\n        inf.readEoln();\n        ensuref(si != ti, \"Edge cannot be between a node and itself: %d\", si);\n\n        int u = si;\n        int v = ti;\n        if (u > v) swap(u, v);\n        pair<int, int> edge = make_pair(u, v);\n        ensuref(edges.count(edge) == 0, \"Multiple edges between nodes %d and %d\", u, v);\n        edges.insert(edge);\n\n        adj[si].push_back(ti);\n        adj[ti].push_back(si);\n    }\n\n    vector<bool> visited(n + 1, false);\n    function<void(int)> dfs = [&](int u) {\n        visited[u] = true;\n        for (int v : adj[u]) {\n            if (!visited[v]) {\n                dfs(v);\n            }\n        }\n    };\n\n    dfs(1);\n\n    for (int i = 1; i <= n; ++i) {\n        ensuref(visited[i], \"Node %d is not connected to the graph\", i);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n    string orient = opt<string>(\"orient\", \"parent_to_child\");\n\n    vector<int> parent(n, -1); // parent[i]: parent of node i\n\n    if (type == \"chain\") {\n        // A tree that has degenerated into a chain\n        for(int i = 1; i < n; ++i)\n            parent[i] = i - 1;\n    } else if (type == \"star\") {\n        // A star-shaped tree\n        for(int i = 1; i < n; ++i)\n            parent[i] = 0;\n    } else if (type == \"binary\") {\n        // A complete binary tree\n        for(int i = 1; i < n; ++i)\n            parent[i] = (i - 1) / 2;\n    } else if (type == \"skewed\") {\n        // A skewed tree (left heavy)\n        for(int i = 1; i < n; ++i)\n            parent[i] = i - rnd.next(1, min(i, 3)); // Random parent within last 3 nodes\n    } else {\n        // Random tree\n        for(int i = 1; i < n; ++i)\n            parent[i] = rnd.next(i);\n    }\n\n    // Shuffle node labels\n    vector<int> nodes(n);\n    for(int i = 0; i < n; ++i)\n        nodes[i] = i;\n    shuffle(nodes.begin(), nodes.end());\n\n    // Prepare edges\n    vector<pair<int,int>> edges;\n    for (int i = 1; i < n; ++i) {\n        int u = parent[i];\n        int v = i;\n\n        u = nodes[u];\n        v = nodes[v];\n\n        if (orient == \"parent_to_child\") {\n            edges.push_back(make_pair(u, v)); // Edge from parent to child\n        } else if (orient == \"child_to_parent\") {\n            edges.push_back(make_pair(v, u)); // Edge from child to parent\n        } else if (orient == \"random\") {\n            if (rnd.next(2))\n                edges.push_back(make_pair(u, v));\n            else\n                edges.push_back(make_pair(v, u));\n        } else {\n            // Default to parent_to_child\n            edges.push_back(make_pair(u, v));\n        }\n    }\n\n    // Shuffle edges\n    shuffle(edges.begin(), edges.end());\n\n    // Output n\n    printf(\"%d\\n\", n);\n\n    // Output edges\n    for (auto e : edges)\n        printf(\"%d %d\\n\", e.first + 1, e.second + 1);\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n    string orient = opt<string>(\"orient\", \"parent_to_child\");\n\n    vector<int> parent(n, -1); // parent[i]: parent of node i\n\n    if (type == \"chain\") {\n        // A tree that has degenerated into a chain\n        for(int i = 1; i < n; ++i)\n            parent[i] = i - 1;\n    } else if (type == \"star\") {\n        // A star-shaped tree\n        for(int i = 1; i < n; ++i)\n            parent[i] = 0;\n    } else if (type == \"binary\") {\n        // A complete binary tree\n        for(int i = 1; i < n; ++i)\n            parent[i] = (i - 1) / 2;\n    } else if (type == \"skewed\") {\n        // A skewed tree (left heavy)\n        for(int i = 1; i < n; ++i)\n            parent[i] = i - rnd.next(1, min(i, 3)); // Random parent within last 3 nodes\n    } else {\n        // Random tree\n        for(int i = 1; i < n; ++i)\n            parent[i] = rnd.next(i);\n    }\n\n    // Shuffle node labels\n    vector<int> nodes(n);\n    for(int i = 0; i < n; ++i)\n        nodes[i] = i;\n    shuffle(nodes.begin(), nodes.end());\n\n    // Prepare edges\n    vector<pair<int,int>> edges;\n    for (int i = 1; i < n; ++i) {\n        int u = parent[i];\n        int v = i;\n\n        u = nodes[u];\n        v = nodes[v];\n\n        if (orient == \"parent_to_child\") {\n            edges.push_back(make_pair(u, v)); // Edge from parent to child\n        } else if (orient == \"child_to_parent\") {\n            edges.push_back(make_pair(v, u)); // Edge from child to parent\n        } else if (orient == \"random\") {\n            if (rnd.next(2))\n                edges.push_back(make_pair(u, v));\n            else\n                edges.push_back(make_pair(v, u));\n        } else {\n            // Default to parent_to_child\n            edges.push_back(make_pair(u, v));\n        }\n    }\n\n    // Shuffle edges\n    shuffle(edges.begin(), edges.end());\n\n    // Output n\n    printf(\"%d\\n\", n);\n\n    // Output edges\n    for (auto e : edges)\n        printf(\"%d %d\\n\", e.first + 1, e.second + 1);\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 2 -type chain -orient parent_to_child\n./gen -n 2 -type chain -orient child_to_parent\n./gen -n 2 -type chain -orient random\n\n./gen -n 5 -type star -orient parent_to_child\n./gen -n 5 -type star -orient child_to_parent\n./gen -n 5 -type star -orient random\n\n./gen -n 10 -type binary -orient parent_to_child\n./gen -n 10 -type binary -orient child_to_parent\n./gen -n 10 -type binary -orient random\n\n./gen -n 100 -type random -orient parent_to_child\n./gen -n 100 -type random -orient child_to_parent\n./gen -n 100 -type random -orient random\n\n./gen -n 1000 -type chain -orient parent_to_child\n./gen -n 1000 -type chain -orient child_to_parent\n./gen -n 1000 -type chain -orient random\n\n./gen -n 10000 -type star -orient parent_to_child\n./gen -n 10000 -type star -orient child_to_parent\n./gen -n 10000 -type star -orient random\n\n./gen -n 200000 -type random -orient parent_to_child\n./gen -n 200000 -type random -orient child_to_parent\n./gen -n 200000 -type random -orient random\n\n./gen -n 199999 -type binary -orient parent_to_child\n./gen -n 199999 -type binary -orient child_to_parent\n./gen -n 199999 -type binary -orient random\n\n./gen -n 200000 -type skewed -orient parent_to_child\n./gen -n 200000 -type skewed -orient child_to_parent\n./gen -n 200000 -type skewed -orient random\n\n./gen -n 200000 -type chain -orient parent_to_child\n./gen -n 200000 -type chain -orient child_to_parent\n./gen -n 200000 -type chain -orient random\n\n./gen -n 200000 -type star -orient parent_to_child\n./gen -n 200000 -type star -orient child_to_parent\n./gen -n 200000 -type star -orient random\n\n./gen -n 200000 -type binary -orient parent_to_child\n./gen -n 200000 -type binary -orient child_to_parent\n./gen -n 200000 -type binary -orient random\n\n./gen -n 200000 -type random -orient random\n./gen -n 200000 -type random -orient parent_to_child\n./gen -n 200000 -type random -orient child_to_parent\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T19:50:37.463015",
        "total_tutorials": 3,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "219/E",
      "title": "E. Parking Lot",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains two space-separated integers n and m (1 ≤ n, m ≤ 2·105) — the number of parking places and the number of records correspondingly. Next m lines contain the descriptions of the records, one per line. The i-th line contains numbers ti, idi (1 ≤ ti ≤ 2; 1 ≤ idi ≤ 106). If ti equals 1, then the corresponding record says that the car number idi arrived at the parking lot. If ti equals 2, then the corresponding record says that the car number idi departed from the parking lot. Records about arriving to the parking lot and departing from the parking lot are given chronologically. All events occurred consecutively, no two events occurred simultaneously.It is guaranteed that all entries are correct:   each car arrived at the parking lot at most once and departed from the parking lot at most once,  there is no record of a departing car if it didn't arrive at the parking lot earlier,  there are no more than n cars on the parking lot at any moment.  You can consider the cars arbitrarily numbered from 1 to 106, all numbers are distinct. Initially all places in the parking lot are empty.",
      "output_spec": "OutputFor each entry of an arriving car print the number of its parking space. Print the numbers of the spaces in the order, in which the cars arrive to the parking lot.",
      "sample_tests": "ExamplesInputCopy7 111 151 1231231 31 52 1231232 151 212 31 61 71 8OutputCopy17427413",
      "description": "E. Parking Lot\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains two space-separated integers n and m (1 ≤ n, m ≤ 2·105) — the number of parking places and the number of records correspondingly. Next m lines contain the descriptions of the records, one per line. The i-th line contains numbers ti, idi (1 ≤ ti ≤ 2; 1 ≤ idi ≤ 106). If ti equals 1, then the corresponding record says that the car number idi arrived at the parking lot. If ti equals 2, then the corresponding record says that the car number idi departed from the parking lot. Records about arriving to the parking lot and departing from the parking lot are given chronologically. All events occurred consecutively, no two events occurred simultaneously.It is guaranteed that all entries are correct:   each car arrived at the parking lot at most once and departed from the parking lot at most once,  there is no record of a departing car if it didn't arrive at the parking lot earlier,  there are no more than n cars on the parking lot at any moment.  You can consider the cars arbitrarily numbered from 1 to 106, all numbers are distinct. Initially all places in the parking lot are empty.\n\nOutputFor each entry of an arriving car print the number of its parking space. Print the numbers of the spaces in the order, in which the cars arrive to the parking lot.\n\nInputCopy7 111 151 1231231 31 52 1231232 151 212 31 61 71 8OutputCopy17427413\n\nInputCopy7 111 151 1231231 31 52 1231232 151 212 31 61 71 8\n\nOutputCopy17427413",
      "solutions": [
        {
          "title": "Codeforces Round #135 (Div. 2) - Codeforces",
          "content": "Hello!Only few hours left before Codeforces Round # 135 (Div. 2). We are preparing the round in Petrozavodsk where traditional training camp for ACM-ICPC is going now. Today is a day of rest here, many participants gone to a trip to Kizhi. The main contest authors are me and Gerald. Special thanks to Aksenov239 who tested the round. Thank Delinur for translation.The problems will be sorted by expected difficulty, the scores are dynamic.Wish you fun round!",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/5156",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 459
        },
        {
          "title": "Codeforces Round #135: Разбор - Codeforces",
          "content": "Итак, начнём разбор.219A - k-StringДавайте для каждой буквы l посчитаем, сколько раз она встретилась в строке --- массив c[l]. Подсчет осуществляется примерно так: c[s[i]]++. Если количество вхождений какой-то буквы не кратно k, то мы уже сразу понимаем, что составить нужную нам строку невозможно. Теперь построим строку p: добавим в неё букв 'a', букв 'b', и так далее. Выведем полученную строку k раз.219B - Special Offer! Super Price 999 Bourles!Переберем количество девяток на конце числа от 1 до 18. Пусть эта величина равна k. В таком случае максимальное число не превосходящее заданное p можно получить так: сотрем последние k цифр числа x:  = p / 10k добавим справа k девяток y:  = x·10k + 10k - 1 если значение y больше p, то уменьшим число x (то, что идет до k девяток) на 1 и к результату допишем k девяток y:  = (x - 1)·10k + 10k - 1 Если получившееся y >  = p - d, то обновим ответ значением k.219C - Color StripeРазберём 2 два случая: k равно 2. Тогда нам подходят только две строки — чередующиеся буквы 'A' и 'B'. Выбираем из них тот, который требует меньшего числа перекрасок. k больше 2. Возьмем самый левый блок из одинаковых букв. Пусть его длина равна k, тогда надо не менее k / 2 перекрашиваний, чтобы избавиться от соседних одинаковых клеток в этом блоке. Если k нечетно, то можно каждую вторую клетку в блоке перекрасить в любой из цветов, отличных от цвета блока. Если k четно, то можно делать тоже самое, но аккуратнее выбрать цвет: он должен отличаться не только от цвета блока, но и от цвета следующей клетки за блоком. Это всегда возможно сделать, так как количество цветов больше 2. 219D - Choosing Capital for TreelandДля того, чтобы решить эту задачу посчитаем для каждого города количество ребер, которые надо переориентировать, чтобы данный город стал столицей.В задаче были достаточно большие ограничения, поэтому нельзя было просто посчитать все эти значения n обходами в глубину. Авторское решение запускает только два обхода в глубину. Первым обходом в глубину посчитаем ответ для города номер 1. Заметим, что если посчитан ответ для вершины x, то ответ для вершины y, которая соединена с x, можно посчитать за O(1). А именно, ans(y) = ans(x) - direction(x, y) + (1 - direction(x, y)), где direction(x, y) — равно 1, если ребро (x, y) ориентировано не так как во входных данных, и равно 0, иначе. Пользуясь описанным фактом, можно посчитать все значения ans(v) одним обходом, зная ans(1).Итоговая ассимптотика решения O(n).219E - Parking LotБудем поддерживать две структуры: множество отрезков свободных парковочных мест, в котором отрезки отсортированы по их началу, и множество отрезков свободных парковочных мест отсортированных по размеру. Такие структуры должны поддерживать операцию быстрого поиска первого больше либо равного элемента, удаление элемента и его вставку, нахождениe максимума и следующего по величине элемента.В языке C++, авторское решение использовало set <pair<int,int>> и map <int, set<int>>. Set отрезков и Map из длины отрезка в набор отрезков с заданной длиной. Операция поиска больше либо равного элемента в этих структурах называется lower_bound.Научимся поддерживать эти структуры от операции к операции. Для того, чтобы определить автомобилиста на стоянку, нужно взять свободный отрезок с максимальной длиной или с (максимальной длиной минус один), который не упирается в начало или конец стоянки, и попробовать определить автомобилиста на свободное парковочное место в середину этого отрезка (если точной середины нет, то в ближайшую к ней клетеку). Среди всех таких позиций нужно выбрать наилучшую (в смысле условия задачи). После нахождения лучшей позиции надо разрезать соотвествующий отрезок свободных позиций на два и обновить обе структуры (удалить старый отрезок и вставить два новых).Чтобы удалить автомобилиста со стоянки нужно добавить новый отрезок свободных парковочных мест длины один в структуру. Предварительно нужно удалить смежные с этим отрезком отрезки в структуре. Соединить их с нашим отрезком и добавить один большой отрезок в структуру.Отдельные случаи возникает при рассмотрении крайних отрезков. Итоговая сложность решения O(m log n)",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/5158",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 219\\s*E"
          },
          "content_length": 4129
        },
        {
          "title": "User editorial for Codeforces Round #135 (Div. 2) - Codeforces",
          "content": "The contest was well balanced — scores for tasks were very close to standard scores. I hope you will find this editorial useful.A :: k-StringCount the occurrences of each character. If any character appears a number of times not divisible by K, obviously, there is no solution. Otherwise, form the solution by first making the string B. The string B can be any string with the following property: if some character ch appears q times in the string B, the same character appears q***K** times in the given string. Now, just print that string K times.B :: Special Offer! Super Price 999 Bourles!The following observation will help you code the solution:The largest number smaller than p ending with at least k nines is p - p MOD 10^k - 1 If the result turns out to be -1 , you can not reach a positive number with k or more nines. I will not explain the solution in detail — be careful when coding and have all the task statements in mind.C :: Color StripeThere are two cases to consider , when K=2 and when K>2. For K=2 there are only two possible solutions: the string \"ABABAB...\" and \"BABABA...\"For both strings, simply count the number of differences between it and the given string and print a string with fewer differences.For K>2 , decompose the string into contiguous single-colored sequences. Observe one such sequence. If it has an odd number of characters, say 2m+1, replace m characters with some other character in the following fashion:AAAAAbecomesABABAIt can be observed that by changing less than m characters doesn't remove all pairs of adjacent identical characters. Similarly, for sequences of even length, say 2m characters, observe a character in the original string right after the last character of the observed sequence, and choose a character different from both. Example:AAAAAABbecomesACACACBAgain, it is sufficient and necessary to change m characters.D :: Choosing Capital for TreelandArbitrarily root the tree at some vertex, say vertex 1. Now, all the edges are oriented either up (towards the root) or down (away from it). We will call upwards oriented edges red, and downwards oriented edges green. Now, with a single depth-first search, for each vertex, calculate its distance from the root (in number of edges) and the number of red edges along the path to the root. Also, count the number of red edges in the entire tree.Now comes the interesting part: Observe that all edges outside the path from the root to vert should turn green, and those on the path should turn red.The number of edges that need to be flipped if vert is chosen as a capital is given by:RedEntireTree - 2*RedOnPath[vert] + RootDistance[vert]E :: Parking LotUse a heap to maintain sequences of empty parking spaces as intervals. The comparison function for such intervals should return an interval which could store a car farthest from any other car, and if there is a tie, it should return the leftmost such interval. When inserting a car, pop the heap, look at the interval, place a car in the corresponding space and push two new intervals onto the heap. When removing a car, you should be able to find the two intervals which end at that car, remove them from the heap and push a new interval which forms when the two merge.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/5160",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 3232
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #135 (Div. 2) - Codeforces - Code 1",
          "code": "long long int a=10, t=1;\nwhile(t<3) {\n    long long int test=(long long int) (pow((long long int)10,t));\n    cout<<test<<endl ;\n    t++;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5156",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #135 (Div. 2) - Codeforces - Code 2",
          "code": "Print the required price — the maximum price that ends with the largest number of nines and that is less than p by no more than d.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5156",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #135 (Div. 2) - Codeforces - Code 3",
          "code": "Print the required price — the maximum price that ends with the largest number of nines and that is less than p by no more than d.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5156",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #135 (Div. 2) - Codeforces - Code 4",
          "code": "#pragma optimization_level 3 \n#pragma GCC optimize(\"Ofast,no-stack-protector,unroll-loops,fast-math,O3\") \n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx\")",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5156",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #135 (Div. 2) - Codeforces - Code 5",
          "code": "#pragma optimization_level 3 \n#pragma GCC optimize(\"Ofast,no-stack-protector,unroll-loops,fast-math,O3\") \n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx\")",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5156",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #135: Разбор - Codeforces - Code 1",
          "code": "<pair<int,int>>",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5158",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #135: Разбор - Codeforces - Code 2",
          "code": "<int, set<int>>",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5158",
          "author": "jiangly"
        },
        {
          "title": "User editorial for Codeforces Round #135 (Div. 2) - Codeforces - Code 1",
          "code": "p - p MOD 10^k - 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5160",
          "author": "jiangly"
        },
        {
          "title": "User editorial for Codeforces Round #135 (Div. 2) - Codeforces - Code 2",
          "code": "RedEntireTree - 2*RedOnPath[vert] + RootDistance[vert]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5160",
          "author": "jiangly"
        },
        {
          "title": "User editorial for Codeforces Round #135 (Div. 2) - Codeforces - Code 3",
          "code": "for (int i=1;i<n;i++){\n        cin>>a>>b;\n        temp = ar[a];\n        while(temp->next!=NULL){\n            temp = temp->next;\n        }\n        temp->next = new Node(b, 1, 0);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5160",
          "author": "jiangly"
        },
        {
          "title": "User editorial for Codeforces Round #135 (Div. 2) - Codeforces - Code 4",
          "code": "for (int i=1;i<n;i++){\n        cin>>a>>b;\n        temp = ar[a];\n        while(temp->next!=NULL){\n            temp = temp->next;\n        }\n        temp->next = new Node(b, 1, 0);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5160",
          "author": "jiangly"
        },
        {
          "title": "User editorial for Codeforces Round #135 (Div. 2) - Codeforces - Code 5",
          "code": "struct node\n{\n    vector<node*> edges;\n} nodes[big_number];\n\n...\n\nfor (int i = 0; i < number_of_edges; i++)\n{\n    int a, b;\n    scanf(\"%d%d\", &a, &b);\n    nodes[a].edges.push_back(nodes + b);\n    nodes[b].edges.push_back(nodes + a);\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5160",
          "author": "jiangly"
        },
        {
          "title": "User editorial for Codeforces Round #135 (Div. 2) - Codeforces - Code 6",
          "code": "struct node\n{\n    vector<node*> edges;\n} nodes[big_number];\n\n...\n\nfor (int i = 0; i < number_of_edges; i++)\n{\n    int a, b;\n    scanf(\"%d%d\", &a, &b);\n    nodes[a].edges.push_back(nodes + b);\n    nodes[b].edges.push_back(nodes + a);\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5160",
          "author": "jiangly"
        },
        {
          "title": "User editorial for Codeforces Round #135 (Div. 2) - Codeforces - Code 7",
          "code": "RedEntireTree — 2*RedOnPath[vert] + RootDistance[vert]\n= (RedEntireTree - RedOnPath[vert]) + (RootDistance[vert] - RedOnPath[vert])\n=           RedOutsidePath          +            GreenOnPath",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5160",
          "author": "jiangly"
        },
        {
          "title": "User editorial for Codeforces Round #135 (Div. 2) - Codeforces - Code 8",
          "code": "RedEntireTree — 2*RedOnPath[vert] + RootDistance[vert]\n= (RedEntireTree - RedOnPath[vert]) + (RootDistance[vert] - RedOnPath[vert])\n=           RedOutsidePath          +            GreenOnPath",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5160",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 200000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 200000, \"m\");\n    inf.readEoln();\n\n    set<int> arrived_cars;  // Set of cars that have arrived\n    set<int> parked_cars;   // Set of cars that are currently parked\n\n    for(int i = 0; i < m; i++){\n        int ti = inf.readInt(1, 2, \"ti\");\n        inf.readSpace();\n        int idi = inf.readInt(1, 1000000, \"idi\");\n        inf.readEoln();\n\n        if (ti == 1) {\n            // Car arrives\n            ensuref(!arrived_cars.count(idi), \"Car %d arrived more than once\", idi);\n            arrived_cars.insert(idi);\n            parked_cars.insert(idi);\n            ensuref((int)parked_cars.size() <= n, \"Parking lot is full, number of parked cars is %zu, n=%d\", parked_cars.size(), n);\n        } else if (ti == 2) {\n            // Car departs\n            ensuref(arrived_cars.count(idi), \"Car %d departed before arriving\", idi);\n            ensuref(parked_cars.count(idi), \"Car %d departed more than once\", idi);\n            parked_cars.erase(idi);\n        } else {\n            ensuref(false, \"ti=%d is invalid, should be 1 or 2\", ti);\n        }\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 200000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 200000, \"m\");\n    inf.readEoln();\n\n    set<int> arrived_cars;  // Set of cars that have arrived\n    set<int> parked_cars;   // Set of cars that are currently parked\n\n    for(int i = 0; i < m; i++){\n        int ti = inf.readInt(1, 2, \"ti\");\n        inf.readSpace();\n        int idi = inf.readInt(1, 1000000, \"idi\");\n        inf.readEoln();\n\n        if (ti == 1) {\n            // Car arrives\n            ensuref(!arrived_cars.count(idi), \"Car %d arrived more than once\", idi);\n            arrived_cars.insert(idi);\n            parked_cars.insert(idi);\n            ensuref((int)parked_cars.size() <= n, \"Parking lot is full, number of parked cars is %zu, n=%d\", parked_cars.size(), n);\n        } else if (ti == 2) {\n            // Car departs\n            ensuref(arrived_cars.count(idi), \"Car %d departed before arriving\", idi);\n            ensuref(parked_cars.count(idi), \"Car %d departed more than once\", idi);\n            parked_cars.erase(idi);\n        } else {\n            ensuref(false, \"ti=%d is invalid, should be 1 or 2\", ti);\n        }\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 200000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 200000, \"m\");\n    inf.readEoln();\n\n    set<int> arrived_cars;  // Set of cars that have arrived\n    set<int> parked_cars;   // Set of cars that are currently parked\n\n    for(int i = 0; i < m; i++){\n        int ti = inf.readInt(1, 2, \"ti\");\n        inf.readSpace();\n        int idi = inf.readInt(1, 1000000, \"idi\");\n        inf.readEoln();\n\n        if (ti == 1) {\n            // Car arrives\n            ensuref(!arrived_cars.count(idi), \"Car %d arrived more than once\", idi);\n            arrived_cars.insert(idi);\n            parked_cars.insert(idi);\n            ensuref((int)parked_cars.size() <= n, \"Parking lot is full, number of parked cars is %zu, n=%d\", parked_cars.size(), n);\n        } else if (ti == 2) {\n            // Car departs\n            ensuref(arrived_cars.count(idi), \"Car %d departed before arriving\", idi);\n            ensuref(parked_cars.count(idi), \"Car %d departed more than once\", idi);\n            parked_cars.erase(idi);\n        } else {\n            ensuref(false, \"ti=%d is invalid, should be 1 or 2\", ti);\n        }\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string type = opt<string>(\"type\", \"random\");\n\n    printf(\"%d %d\\n\", n, m);\n\n    set<int> active_cars;\n    set<int> used_car_ids;\n    int max_car_id = 1000000;\n\n    if (type == \"random\") {\n        for (int i = 0; i < m; ++i) {\n            if ((int)active_cars.size() == 0) {\n                // Generate an arrival\n                int car_id;\n                do {\n                    car_id = rnd.next(1, max_car_id);\n                } while (used_car_ids.count(car_id));\n                used_car_ids.insert(car_id);\n                active_cars.insert(car_id);\n                printf(\"1 %d\\n\", car_id);\n            } else if ((int)active_cars.size() == n) {\n                // Parking lot is full, generate a departure\n                int index = rnd.next(0, (int)active_cars.size() - 1);\n                auto it = active_cars.begin();\n                std::advance(it, index);\n                int car_id = *it;\n                active_cars.erase(it);\n                printf(\"2 %d\\n\", car_id);\n            } else {\n                // Randomly choose an arrival or departure\n                int p = rnd.next(0, 1);\n                if (p == 0) {\n                    // Arrival\n                    int car_id;\n                    do {\n                        car_id = rnd.next(1, max_car_id);\n                    } while (used_car_ids.count(car_id));\n                    used_car_ids.insert(car_id);\n                    active_cars.insert(car_id);\n                    printf(\"1 %d\\n\", car_id);\n                } else {\n                    // Departure\n                    int index = rnd.next(0, (int)active_cars.size() - 1);\n                    auto it = active_cars.begin();\n                    std::advance(it, index);\n                    int car_id = *it;\n                    active_cars.erase(it);\n                    printf(\"2 %d\\n\", car_id);\n                }\n            }\n        }\n    } else if (type == \"arrivals_only\") {\n        if (m > n) {\n            m = n;\n        }\n        for (int i = 0; i < m; ++i) {\n            int car_id;\n            do {\n                car_id = rnd.next(1, max_car_id);\n            } while (used_car_ids.count(car_id));\n            used_car_ids.insert(car_id);\n            active_cars.insert(car_id);\n            printf(\"1 %d\\n\", car_id);\n        }\n    } else if (type == \"arrivals_then_departures\") {\n        int total_arrivals = min(n, m / 2);\n        vector<int> arrivals;\n        for (int i = 0; i < total_arrivals; ++i) {\n            int car_id;\n            do {\n                car_id = rnd.next(1, max_car_id);\n            } while (used_car_ids.count(car_id));\n            used_car_ids.insert(car_id);\n            arrivals.push_back(car_id);\n            active_cars.insert(car_id);\n            printf(\"1 %d\\n\", car_id);\n        }\n        for (int i = 0; i < total_arrivals; ++i) {\n            int car_id = arrivals[i];\n            active_cars.erase(car_id);\n            printf(\"2 %d\\n\", car_id);\n        }\n        int events_done = 2 * total_arrivals;\n        while (events_done < m) {\n            if (!active_cars.empty()) {\n                int index = rnd.next(0, (int)active_cars.size() - 1);\n                auto it = active_cars.begin();\n                std::advance(it, index);\n                int car_id = *it;\n                active_cars.erase(it);\n                printf(\"2 %d\\n\", car_id);\n                events_done++;\n            } else {\n                if ((int)used_car_ids.size() < n) {\n                    int car_id;\n                    do {\n                        car_id = rnd.next(1, max_car_id);\n                    } while (used_car_ids.count(car_id));\n                    used_car_ids.insert(car_id);\n                    active_cars.insert(car_id);\n                    printf(\"1 %d\\n\", car_id);\n                    events_done++;\n                } else {\n                    break;\n                }\n            }\n        }\n    } else if (type == \"alternate\") {\n        int total_events = m;\n        if (m % 2 != 0) {\n            total_events--;\n        }\n        int total_arrivals = total_events / 2;\n        vector<int> arrivals;\n        int idx = 0;\n        for (int i = 0; i < total_events; ++i) {\n            if (i % 2 == 0) {\n                int car_id;\n                do {\n                    car_id = rnd.next(1, max_car_id);\n                } while (used_car_ids.count(car_id));\n                used_car_ids.insert(car_id);\n                arrivals.push_back(car_id);\n                active_cars.insert(car_id);\n                printf(\"1 %d\\n\", car_id);\n            } else {\n                int car_id = arrivals[idx++];\n                active_cars.erase(car_id);\n                printf(\"2 %d\\n\", car_id);\n            }\n        }\n        if (total_events < m) {\n            int car_id;\n            do {\n                car_id = rnd.next(1, max_car_id);\n            } while (used_car_ids.count(car_id));\n            used_car_ids.insert(car_id);\n            active_cars.insert(car_id);\n            printf(\"1 %d\\n\", car_id);\n        }\n    } else {\n        // Default to random\n        for (int i = 0; i < m; ++i) {\n            if ((int)active_cars.size() == 0) {\n                int car_id;\n                do {\n                    car_id = rnd.next(1, max_car_id);\n                } while (used_car_ids.count(car_id));\n                used_car_ids.insert(car_id);\n                active_cars.insert(car_id);\n                printf(\"1 %d\\n\", car_id);\n            } else if ((int)active_cars.size() == n) {\n                int index = rnd.next(0, (int)active_cars.size() - 1);\n                auto it = active_cars.begin();\n                std::advance(it, index);\n                int car_id = *it;\n                active_cars.erase(it);\n                printf(\"2 %d\\n\", car_id);\n            } else {\n                int p = rnd.next(0, 1);\n                if (p == 0) {\n                    int car_id;\n                    do {\n                        car_id = rnd.next(1, max_car_id);\n                    } while (used_car_ids.count(car_id));\n                    used_car_ids.insert(car_id);\n                    active_cars.insert(car_id);\n                    printf(\"1 %d\\n\", car_id);\n                } else {\n                    int index = rnd.next(0, (int)active_cars.size() - 1);\n                    auto it = active_cars.begin();\n                    std::advance(it, index);\n                    int car_id = *it;\n                    active_cars.erase(it);\n                    printf(\"2 %d\\n\", car_id);\n                }\n            }\n        }\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string type = opt<string>(\"type\", \"random\");\n\n    printf(\"%d %d\\n\", n, m);\n\n    set<int> active_cars;\n    set<int> used_car_ids;\n    int max_car_id = 1000000;\n\n    if (type == \"random\") {\n        for (int i = 0; i < m; ++i) {\n            if ((int)active_cars.size() == 0) {\n                // Generate an arrival\n                int car_id;\n                do {\n                    car_id = rnd.next(1, max_car_id);\n                } while (used_car_ids.count(car_id));\n                used_car_ids.insert(car_id);\n                active_cars.insert(car_id);\n                printf(\"1 %d\\n\", car_id);\n            } else if ((int)active_cars.size() == n) {\n                // Parking lot is full, generate a departure\n                int index = rnd.next(0, (int)active_cars.size() - 1);\n                auto it = active_cars.begin();\n                std::advance(it, index);\n                int car_id = *it;\n                active_cars.erase(it);\n                printf(\"2 %d\\n\", car_id);\n            } else {\n                // Randomly choose an arrival or departure\n                int p = rnd.next(0, 1);\n                if (p == 0) {\n                    // Arrival\n                    int car_id;\n                    do {\n                        car_id = rnd.next(1, max_car_id);\n                    } while (used_car_ids.count(car_id));\n                    used_car_ids.insert(car_id);\n                    active_cars.insert(car_id);\n                    printf(\"1 %d\\n\", car_id);\n                } else {\n                    // Departure\n                    int index = rnd.next(0, (int)active_cars.size() - 1);\n                    auto it = active_cars.begin();\n                    std::advance(it, index);\n                    int car_id = *it;\n                    active_cars.erase(it);\n                    printf(\"2 %d\\n\", car_id);\n                }\n            }\n        }\n    } else if (type == \"arrivals_only\") {\n        if (m > n) {\n            m = n;\n        }\n        for (int i = 0; i < m; ++i) {\n            int car_id;\n            do {\n                car_id = rnd.next(1, max_car_id);\n            } while (used_car_ids.count(car_id));\n            used_car_ids.insert(car_id);\n            active_cars.insert(car_id);\n            printf(\"1 %d\\n\", car_id);\n        }\n    } else if (type == \"arrivals_then_departures\") {\n        int total_arrivals = min(n, m / 2);\n        vector<int> arrivals;\n        for (int i = 0; i < total_arrivals; ++i) {\n            int car_id;\n            do {\n                car_id = rnd.next(1, max_car_id);\n            } while (used_car_ids.count(car_id));\n            used_car_ids.insert(car_id);\n            arrivals.push_back(car_id);\n            active_cars.insert(car_id);\n            printf(\"1 %d\\n\", car_id);\n        }\n        for (int i = 0; i < total_arrivals; ++i) {\n            int car_id = arrivals[i];\n            active_cars.erase(car_id);\n            printf(\"2 %d\\n\", car_id);\n        }\n        int events_done = 2 * total_arrivals;\n        while (events_done < m) {\n            if (!active_cars.empty()) {\n                int index = rnd.next(0, (int)active_cars.size() - 1);\n                auto it = active_cars.begin();\n                std::advance(it, index);\n                int car_id = *it;\n                active_cars.erase(it);\n                printf(\"2 %d\\n\", car_id);\n                events_done++;\n            } else {\n                if ((int)used_car_ids.size() < n) {\n                    int car_id;\n                    do {\n                        car_id = rnd.next(1, max_car_id);\n                    } while (used_car_ids.count(car_id));\n                    used_car_ids.insert(car_id);\n                    active_cars.insert(car_id);\n                    printf(\"1 %d\\n\", car_id);\n                    events_done++;\n                } else {\n                    break;\n                }\n            }\n        }\n    } else if (type == \"alternate\") {\n        int total_events = m;\n        if (m % 2 != 0) {\n            total_events--;\n        }\n        int total_arrivals = total_events / 2;\n        vector<int> arrivals;\n        int idx = 0;\n        for (int i = 0; i < total_events; ++i) {\n            if (i % 2 == 0) {\n                int car_id;\n                do {\n                    car_id = rnd.next(1, max_car_id);\n                } while (used_car_ids.count(car_id));\n                used_car_ids.insert(car_id);\n                arrivals.push_back(car_id);\n                active_cars.insert(car_id);\n                printf(\"1 %d\\n\", car_id);\n            } else {\n                int car_id = arrivals[idx++];\n                active_cars.erase(car_id);\n                printf(\"2 %d\\n\", car_id);\n            }\n        }\n        if (total_events < m) {\n            int car_id;\n            do {\n                car_id = rnd.next(1, max_car_id);\n            } while (used_car_ids.count(car_id));\n            used_car_ids.insert(car_id);\n            active_cars.insert(car_id);\n            printf(\"1 %d\\n\", car_id);\n        }\n    } else {\n        // Default to random\n        for (int i = 0; i < m; ++i) {\n            if ((int)active_cars.size() == 0) {\n                int car_id;\n                do {\n                    car_id = rnd.next(1, max_car_id);\n                } while (used_car_ids.count(car_id));\n                used_car_ids.insert(car_id);\n                active_cars.insert(car_id);\n                printf(\"1 %d\\n\", car_id);\n            } else if ((int)active_cars.size() == n) {\n                int index = rnd.next(0, (int)active_cars.size() - 1);\n                auto it = active_cars.begin();\n                std::advance(it, index);\n                int car_id = *it;\n                active_cars.erase(it);\n                printf(\"2 %d\\n\", car_id);\n            } else {\n                int p = rnd.next(0, 1);\n                if (p == 0) {\n                    int car_id;\n                    do {\n                        car_id = rnd.next(1, max_car_id);\n                    } while (used_car_ids.count(car_id));\n                    used_car_ids.insert(car_id);\n                    active_cars.insert(car_id);\n                    printf(\"1 %d\\n\", car_id);\n                } else {\n                    int index = rnd.next(0, (int)active_cars.size() - 1);\n                    auto it = active_cars.begin();\n                    std::advance(it, index);\n                    int car_id = *it;\n                    active_cars.erase(it);\n                    printf(\"2 %d\\n\", car_id);\n                }\n            }\n        }\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Small n and m\n./gen -n 5 -m 10 -type random\n./gen -n 5 -m 5 -type arrivals_only\n./gen -n 5 -m 10 -type arrivals_then_departures\n./gen -n 5 -m 10 -type alternate\n\n# Medium n and m\n./gen -n 50 -m 100 -type random\n./gen -n 50 -m 50 -type arrivals_only\n./gen -n 50 -m 100 -type arrivals_then_departures\n./gen -n 50 -m 100 -type alternate\n\n# Large n and m\n./gen -n 1000 -m 2000 -type random\n./gen -n 1000 -m 1000 -type arrivals_only\n./gen -n 1000 -m 2000 -type arrivals_then_departures\n./gen -n 1000 -m 2000 -type alternate\n\n# Maximum n and m\n./gen -n 200000 -m 200000 -type random\n./gen -n 200000 -m 200000 -type arrivals_only\n./gen -n 200000 -m 200000 -type arrivals_then_departures\n./gen -n 200000 -m 200000 -type alternate\n\n# Edge cases\n./gen -n 1 -m 2 -type random\n./gen -n 1 -m 1 -type arrivals_only\n./gen -n 1 -m 2 -type arrivals_then_departures\n./gen -n 1 -m 2 -type alternate\n\n# Additional cases with varying m\n./gen -n 100000 -m 50000 -type random\n./gen -n 100000 -m 150000 -type random\n./gen -n 150000 -m 300000 -type arrivals_then_departures\n./gen -n 200000 -m 100000 -type arrivals_then_departures\n./gen -n 200000 -m 199999 -type arrivals_then_departures\n\n# Cases with m not divisible by 2\n./gen -n 50000 -m 99999 -type random\n./gen -n 50000 -m 99999 -type alternate\n\n# Additional random cases\n./gen -n 70000 -m 150000 -type random\n./gen -n 70000 -m 70000 -type arrivals_only\n./gen -n 70000 -m 70000 -type arrivals_then_departures\n\n# Case with m less than n\n./gen -n 100000 -m 50000 -type arrivals_only\n\n# Case with n at max and m at min\n./gen -n 200000 -m 1 -type arrivals_only\n./gen -n 200000 -m 2 -type random\n\n# Case with minimal n and maximal m\n./gen -n 2 -m 200000 -type random\n./gen -n 2 -m 200000 -type alternate\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T19:50:39.134114",
        "total_tutorials": 3,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "22/A",
      "title": "A. Second Order Statistics",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first input line contains integer n (1 ≤ n ≤ 100) — amount of numbers in the sequence. The second line contains n space-separated integer numbers — elements of the sequence. These numbers don't exceed 100 in absolute value.",
      "output_spec": "OutputIf the given sequence has the second order statistics, output this order statistics, otherwise output NO.",
      "sample_tests": "ExamplesInputCopy41 2 2 -4OutputCopy1InputCopy51 2 3 1 1OutputCopy2",
      "description": "A. Second Order Statistics\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first input line contains integer n (1 ≤ n ≤ 100) — amount of numbers in the sequence. The second line contains n space-separated integer numbers — elements of the sequence. These numbers don't exceed 100 in absolute value.\n\nOutputIf the given sequence has the second order statistics, output this order statistics, otherwise output NO.\n\nInputCopy41 2 2 -4OutputCopy1InputCopy51 2 3 1 1OutputCopy2\n\nInputCopy41 2 2 -4\n\nOutputCopy1\n\nInputCopy51 2 3 1 1\n\nOutputCopy2",
      "solutions": [
        {
          "title": "Codeforces Beta Round #22 (Div. 2) - Codeforces",
          "content": "Welcome all to Codeforces Beta Round #22 Note that at this time registration is possible during the round. The contest will begin at 19:00 MSK. Today I am an author of the problems. I would like to thank Mike Mirzayanov for help in contest preparations, Edvard Davtyan and Nickolay Kuznetsov for writing the verification solutions, and Julia Satushina for translating statements into English. Good luck on the contest! UPD: The contest is over. Thank you all for participating! Problems Results Winner Kasparyanm_Mihail gains +203 to rating after the contest!",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/505",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.6,
            "reason": "宽松匹配: 包含题目编号 22 和字母"
          },
          "content_length": 559
        },
        {
          "title": "Codeforces Beta Round #22 Tutorial - Codeforces",
          "content": "Contest discussionProblem А. Second Order StatisticsSortingIn this problem one should find a minimal element from all elements, that are strictly greater, then the minimal one or report that it doesn't exist. Of course, there can be a lot of different solutions, but one of the simplest - to sort the given sequence and print the first element, that's not equal to the previous. If all elements are equal, then the required element doesn't exist. Problem B. Bargaining TableSimulation, dynamic programmingIn this problem one should find the maximal perimeter of a rectangle that contains no '1'. Define these rectangles \"correct\". To solve a problem you are to check each possible rectangle for correctness and calculate its perimeter. The easiest way to check all rectangles is using 6 nested cycles. Using 4 of them you fix the coordinates while other 2 will look for '1'. So the complexity is O((n*m)3). It seems slow, but those, who wrote such a solution, says that it hasn't any problems with TL.One may interest in much faster solution. Using simple DP solution one can get a solution with an O((n*m)2) complexity. It's clear, that rectangle with coordinates (x1, y1, x2, y2) is correct if and only if rectangles (x1, y1, x2-1, y2) and (x1, y1, x2, y2-1) are correct, and board[x2][y2] = '0'. So each of rectangles can be checked in O(1) and totally there will be O((n*m)2) operations.Problem C. System AdministratorSimulationIn this problem you are to construct a connected graph, which contains n vertexes and m edges, and if we delete vertex with number v, our graph stops being connected or to report that such a graph doesn't exist. Moreover, each pair of vertexes can have no more than one edge connecting them. Obviously, a connected graph doesn't exist if the number of edges is less than n-1. It's easy to notice, that the maximal possible number of edges reaches when there is a vertex connected to v and doesn't connected to any other vertex, those can form up to complete graph. So the maximal number of edges is (n-1)*(n-2)/2+1. If m is in that range then required graph always exists. Then you should place one vertex on the one side of v (let it be 1), and other vertexes - on the other side. First, you should connect all this vertexes to v and then connect them between each other (except 1).Problem D. SegmentsScanning lineIn this problem one should place minimal number of points on the line such that any given segment touches at least one of these points. Let's call the coordinate of ending of any segment as event. There will be events of two types: beginning of a segment and its ending. Let's sort this events by coordinates. In the case of equality of some events consider that the event of the beginning will be less than the event of ending. Look at our events from left to right: if there is a beginning event, then push the number of this segment to the special queue. Once we take an ending of some segment, place the point here and clear the special queue (because each of segment in this queue will touch this point).Problem E. SchemeGraph theoryGiven an oriented graph, find the minimal number of edges one should add to this graph to make it strongly connected. Looking at statement we can get the fact that each vertex has exactly one outcoming edge. It means that starting at some point we'll get stuck in some cycle. So each connected (not strongly) component is a set of simple paths, ending in some cycle or just a simple cycle. First consider vertexes, which has no incoming edges. When passing through some vertex we'll paint it until the current vertex will be already painted. Then we call the starting vertex as \"beginning\" and the finishing one as \"ending\" of a component.After that consider other vertexes - they belong to cycles. Beginning and ending of a cycle - is any vertexes (possible coinciding) belonging to it. So we got a number of components which we have to connect. Let's connect them cyclically: the edge will pass from the ending of i-th component to the beginning of ((i+1)%k)-th, where k is the number of such components. The answer will be k. There is an exception: if we have only one component which is a simple cycle, the answer will be equal to 0.So we'll consider each edge exactly once and the total complexity will be O(n).",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/507",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 4301
        }
      ],
      "code_examples": [],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readEoln();\n    vector<int> a = inf.readInts(n, -100, 100, \"a_i\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readEoln();\n    vector<int> a = inf.readInts(n, -100, 100, \"a_i\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readEoln();\n    vector<int> a = inf.readInts(n, -100, 100, \"a_i\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare sequences of tokens\");\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string j, p;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n\r\n        ans.readWordTo(j);\r\n        ouf.readWordTo(p);\r\n\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s words differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  compress(j).c_str(), compress(p).c_str());\r\n    }\r\n\r\n    if (ans.seekEof() && ouf.seekEof()) {\r\n        if (n == 1)\r\n            quitf(_ok, \"\\\"%s\\\"\", compress(j).c_str());\r\n        else\r\n            quitf(_ok, \"%d tokens\", n);\r\n    } else {\r\n        if (ans.seekEof())\r\n            quitf(_wa, \"Participant output contains extra tokens\");\r\n        else\r\n            quitf(_wa, \"Unexpected EOF in the participants output\");\r\n    }\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> a(n);\n\n    if (type == \"all_same\" || type == \"no_second_order\") {\n        // All elements are the same value, no second-order statistic\n        int val = rnd.next(-100, 100);\n        for (int i = 0; i < n; ++i)\n            a[i] = val;\n    } else if (type == \"two_values\") {\n        // Only two distinct values\n        int val1 = rnd.next(-100, 100);\n        int val2;\n        do {\n            val2 = rnd.next(-100, 100);\n        } while (val2 == val1);\n        for (int i = 0; i < n; ++i)\n            a[i] = rnd.next(2) ? val1 : val2;\n    } else if (type == \"ascending\") {\n        // Numbers are in ascending order\n        a[0] = rnd.next(-100, 100);\n        for (int i = 1; i < n; ++i) {\n            a[i] = a[i-1] + rnd.next(1, 5);\n            if (a[i] > 100)\n                a[i] = 100;\n        }\n    } else if (type == \"descending\") {\n        // Numbers are in descending order\n        a[0] = rnd.next(-100, 100);\n        for (int i = 1; i < n; ++i) {\n            a[i] = a[i-1] - rnd.next(1, 5);\n            if (a[i] < -100)\n                a[i] = -100;\n        }\n    } else if (type == \"positive\") {\n        // All positive numbers\n        for (int i = 0; i < n; ++i)\n            a[i] = rnd.next(1, 100);\n    } else if (type == \"negative\") {\n        // All negative numbers\n        for (int i = 0; i < n; ++i)\n            a[i] = -rnd.next(1, 100);\n    } else if (type == \"mixed\") {\n        // Mix of negative and positive numbers\n        for (int i = 0; i < n; ++i)\n            a[i] = rnd.next(-100, 100);\n    } else if (type == \"random\") {\n        // Random numbers\n        for (int i = 0; i < n; ++i)\n            a[i] = rnd.next(-100, 100);\n    } else if (type == \"single_min\") {\n        // All elements equal except one minimal value\n        int val = rnd.next(-99, 100);\n        int min_val = -100;\n        for (int i = 0; i < n; ++i)\n            a[i] = val;\n        int idx = rnd.next(n);\n        a[idx] = min_val;\n    } else if (type == \"single_max\") {\n        // All elements equal except one maximal value\n        int val = rnd.next(-100, 99);\n        int max_val = 100;\n        for (int i = 0; i < n; ++i)\n            a[i] = val;\n        int idx = rnd.next(n);\n        a[idx] = max_val;\n    } else if (type == \"small_range\") {\n        // Values in small range [-1, 1]\n        for (int i = 0; i < n; ++i)\n            a[i] = rnd.next(-1, 1);\n    } else if (type == \"large_gaps\") {\n        // Values are from [-100, 0, 100]\n        int vals[] = {-100, 0, 100};\n        for (int i = 0; i < n; ++i)\n            a[i] = vals[rnd.next(3)];\n    } else {\n        // Default to random\n        for (int i = 0; i < n; ++i)\n            a[i] = rnd.next(-100, 100);\n    }\n\n    // Output n\n    printf(\"%d\\n\", n);\n    // Output the sequence\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d\", a[i]);\n        if (i + 1 < n)\n            printf(\" \");\n    }\n    printf(\"\\n\");\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> a(n);\n\n    if (type == \"all_same\" || type == \"no_second_order\") {\n        // All elements are the same value, no second-order statistic\n        int val = rnd.next(-100, 100);\n        for (int i = 0; i < n; ++i)\n            a[i] = val;\n    } else if (type == \"two_values\") {\n        // Only two distinct values\n        int val1 = rnd.next(-100, 100);\n        int val2;\n        do {\n            val2 = rnd.next(-100, 100);\n        } while (val2 == val1);\n        for (int i = 0; i < n; ++i)\n            a[i] = rnd.next(2) ? val1 : val2;\n    } else if (type == \"ascending\") {\n        // Numbers are in ascending order\n        a[0] = rnd.next(-100, 100);\n        for (int i = 1; i < n; ++i) {\n            a[i] = a[i-1] + rnd.next(1, 5);\n            if (a[i] > 100)\n                a[i] = 100;\n        }\n    } else if (type == \"descending\") {\n        // Numbers are in descending order\n        a[0] = rnd.next(-100, 100);\n        for (int i = 1; i < n; ++i) {\n            a[i] = a[i-1] - rnd.next(1, 5);\n            if (a[i] < -100)\n                a[i] = -100;\n        }\n    } else if (type == \"positive\") {\n        // All positive numbers\n        for (int i = 0; i < n; ++i)\n            a[i] = rnd.next(1, 100);\n    } else if (type == \"negative\") {\n        // All negative numbers\n        for (int i = 0; i < n; ++i)\n            a[i] = -rnd.next(1, 100);\n    } else if (type == \"mixed\") {\n        // Mix of negative and positive numbers\n        for (int i = 0; i < n; ++i)\n            a[i] = rnd.next(-100, 100);\n    } else if (type == \"random\") {\n        // Random numbers\n        for (int i = 0; i < n; ++i)\n            a[i] = rnd.next(-100, 100);\n    } else if (type == \"single_min\") {\n        // All elements equal except one minimal value\n        int val = rnd.next(-99, 100);\n        int min_val = -100;\n        for (int i = 0; i < n; ++i)\n            a[i] = val;\n        int idx = rnd.next(n);\n        a[idx] = min_val;\n    } else if (type == \"single_max\") {\n        // All elements equal except one maximal value\n        int val = rnd.next(-100, 99);\n        int max_val = 100;\n        for (int i = 0; i < n; ++i)\n            a[i] = val;\n        int idx = rnd.next(n);\n        a[idx] = max_val;\n    } else if (type == \"small_range\") {\n        // Values in small range [-1, 1]\n        for (int i = 0; i < n; ++i)\n            a[i] = rnd.next(-1, 1);\n    } else if (type == \"large_gaps\") {\n        // Values are from [-100, 0, 100]\n        int vals[] = {-100, 0, 100};\n        for (int i = 0; i < n; ++i)\n            a[i] = vals[rnd.next(3)];\n    } else {\n        // Default to random\n        for (int i = 0; i < n; ++i)\n            a[i] = rnd.next(-100, 100);\n    }\n\n    // Output n\n    printf(\"%d\\n\", n);\n    // Output the sequence\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d\", a[i]);\n        if (i + 1 < n)\n            printf(\" \");\n    }\n    printf(\"\\n\");\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -type all_same\n./gen -n 1 -type random\n\n./gen -n 2 -type all_same\n./gen -n 2 -type two_values\n\n./gen -n 3 -type ascending\n./gen -n 3 -type descending\n\n./gen -n 10 -type positive\n./gen -n 10 -type negative\n./gen -n 10 -type mixed\n\n./gen -n 15 -type single_min\n./gen -n 15 -type single_max\n\n./gen -n 20 -type no_second_order\n./gen -n 20 -type small_range\n\n./gen -n 25 -type large_gaps\n\n./gen -n 50 -type all_same\n./gen -n 50 -type two_values\n./gen -n 50 -type ascending\n./gen -n 50 -type descending\n\n./gen -n 75 -type positive\n./gen -n 75 -type negative\n./gen -n 75 -type mixed\n\n./gen -n 100 -type random\n./gen -n 100 -type single_min\n./gen -n 100 -type single_max\n./gen -n 100 -type no_second_order\n./gen -n 100 -type small_range\n./gen -n 100 -type large_gaps\n\n./gen -n 100 -type ascending\n./gen -n 100 -type descending\n./gen -n 100 -type two_values\n./gen -n 100 -type all_same\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T19:50:41.304430",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "22/B",
      "title": "B. Стол для переговоров",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест2 seconds",
      "memory_limit": "ограничение по памяти на тест256 megabytes",
      "input_spec": "Входные данныеВ первой строке через пробел записано 2 целых числа n и m (1 ≤ n, m ≤ 25) — размеры офиса. Далее следует n строк по m символов 0 или 1. 0 обозначает, что соответствующий квадратный метр офиса свободен. 1 обозначает, что соответствующий квадратный метр офиса чем-то занят. Гарантируется, что хотя бы один квадратный метр Васиного офиса свободен.",
      "output_spec": "Выходные данныеВыведите одно число — наибольший возможный периметр стола, помещающегося в Васином офисе.",
      "sample_tests": "ПримерыВходные данныеСкопировать3 3000010000Выходные данныеСкопировать8Входные данныеСкопировать5 411000000000000000000Выходные данныеСкопировать16",
      "description": "B. Стол для переговоров\n\nограничение по времени на тест2 seconds\n\nограничение по времени на тест\n\nограничение по памяти на тест256 megabytes\n\nограничение по памяти на тест\n\nвыводstdout\n\nВходные данныеВ первой строке через пробел записано 2 целых числа n и m (1 ≤ n, m ≤ 25) — размеры офиса. Далее следует n строк по m символов 0 или 1. 0 обозначает, что соответствующий квадратный метр офиса свободен. 1 обозначает, что соответствующий квадратный метр офиса чем-то занят. Гарантируется, что хотя бы один квадратный метр Васиного офиса свободен.\n\nВходные данные\n\nВыходные данныеВыведите одно число — наибольший возможный периметр стола, помещающегося в Васином офисе.\n\nВыходные данные\n\nВходные данныеСкопировать3 3000010000Выходные данныеСкопировать8Входные данныеСкопировать5 411000000000000000000Выходные данныеСкопировать16\n\nВходные данныеСкопировать3 3000010000\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать8\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать5 411000000000000000000\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать16\n\nВыходные данныеСкопировать\n\nСкопировать",
      "solutions": [
        {
          "title": "Codeforces Beta Round #22 (Див. 2) - Codeforces",
          "content": "Приветствую всех на Codeforces Beta Round #22 Обратите внимание, что на этот раз регистрация возможна в течение всего раунда. Сам раунд начнется в 19:00 по Москве. Автором задач этого контеста буду я. Большое спасибо Михаилу Мирзаянову за помощь в подготовке контеста, Эдварду Давтяну и Николаю Кузнецову за написание проверочных решений, и Юлии Сатушиной за перевод условий на английский. Удачи на раунде! UPD: Контест окончен. Всем спасибо за участие! Задачи Результаты Победитель Kasparyanm_Mihail получает за контест +203 к рейтингу!",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/505",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.5,
            "reason": "宽松匹配: 包含题目编号 22"
          },
          "content_length": 537
        },
        {
          "title": "Разбор задач Codeforces Beta Round #22 - Codeforces",
          "content": "Обсуждение контестаЗадача А. Вторая порядковая статистикаТематика: СортировкаВ задаче требовалось найти минимальный из всех элементов заданной последовательности, которые строго больше минимального во всей последовательности или сообщить, что его не существует. Разумеется, решений может быть очень много, но один из самых простых способов - считать всю последовательность в массив, отсортировать его и вывести первый элемент, не совпадающий с предыдущим. Если все элементы одинаковы, значит второго по величине не существует. Задача B. Стол для переговоровТематика: Симуляция, динамическое программированиеВ этой задаче требовалось определить максимальный периметр прямогульника, который не содержит внутри себя единиц. Назовем прямоугольники, не содержащие единиц, допустимыми. Для решения надо было просмотреть все допустимые прямоугольники и выбрать максимальный периметр. Вопрос в том, как перебирать все допустимые прямоугольники. Говорят, что решение \"в лоб\" с помощью 6 вложенных циклов за 256 проходит по времени. Очевидно, четыремя циклами мы фиксируем углы прямоугольника, а еще двумя проверяем его допустимость. Не совсем очевидно, что такое решение уложится по времени.Можно было написать более аккуратное решение с помощью динамического программирования за O((n*m)2). Заметим, что прямоугольник с координатами (x1, y1, x2, y2) является допустимым тогда и только тогда, когда допустимыми явлюятся прямоугольники (x1, y1, x2-1, y2), (x1, y1, x2, y2-1) и в клетке (x2, y2) стоит '0'. Таким образом, пересчет допустимости производится за O(1), что суммарно будет происходить за время O((n*m)2), т.е. линейное от количества прямоугольников. Задача C. Системный администраторТематика: СимуляцияВ этой задаче требовалось составить связный граф из n вершин, содержащего m ребер, такой, что при удалении вершины v граф перестанет быть связным или сообщить, что такой граф не существует. При этом не должно быть кратных ребер. Очевидно, что связный граф не может существовать, если число ребер меньше, чем n-1. Кроме того, нетрудно видеть, что максимальное число ребер достигается, когда по одну стороны от v находится одна вершина, а по другую - полный граф из оставшихся вершин. Это число равно (n-1)*(n-2)/2+1. Если число ребер лежит в допустимом диапазоне - граф всегда существует. Дальше нужно было аккуратно разместить одну вершину по одну сторону от v (пусть это вершина 1), а с другой стороны построить связный граф с m-1 ребром. Лучше всего это было сделать проведя сначала ребра из v во все остальные, кроме 1, а затем между всеми остальными (кроме 1).Задача D. ОтрезкиТематика: Метод сканирующей прямойВ этой задаче требовалось вбить наименьшее число гвоздиков в отрезки так, чтобы каждый отрезок касался хотя бы одного гвоздика. Назовем координату конца отрезка событием. Наши события будут двух типов: начало отрезка и конец отрезка. Отсортируем события в порядке возрастания координат. В случае равенства координат раньше будут идти события начала отрезка. Теперь будем смотреть события в соответствии с заданным порядком: если встретили начало отрезка, добавим его номер в список необработанных отрезков. Как только встретили событие конца отрезка, который еще не обработан, вбиваем туда гвоздь и очищаем список (т.е. считаем, что все отрезки из списка обработаны, т.е. прибиты).Задача E. СхемаТематика: Теория графовВ задаче E дан ориентированный граф, требовалось сделать его сильно связным, т.е. чтобы каждая вершина была достижима из любой другой, добавив минимальное число ребер. Из формата входных данных неявно следует очень важное условие: у любой вершины есть не более одного исходящего ребра. Значит, начав путь из некоторой вершины мы либо зациклимся, либо нам некуда будет идти. Отсюда следует, что любая компонента связности (обычной) имеет вид либо замкнутого цикла, либо несколько простых путей, входящих в вершину или цикл. Сначала рассмотрим все пути, выходящие из вершин, у которых нет входящих ребер. Проходя, будем красить вершины, пока либо нам некуда будет идти, либо придем в покрашенную вершину. Тогда вершина, из которой мы пошли, будет называться началом, а в которую пришли - концом компоненты. После этого рассмотрим еще непокрашенные вершины - они точно принадлежат циклам. Началом и концом цикла назовем некоторую вершину, ему принадлежащую. Получили набор компонент, которые надо соединить. Будем соединять циклически: из конца i-й компоненты пустим ребро в начало ((i+1)%k)-й, где k - число компонент. Ответом будет k. Здесь есть исключение: если у нас только одна компонента, формирующая цикл, то ответ 0.Таким образом каждое ребро мы просмотрим один раз и время работы составит O(n).Upd: В задаче E у любой вершины есть исходящее ребро, поэтому нам всегда есть, куда идти, и любая компонента заканчивается циклом.Говорят, что в задаче B решение с шестью вложенными циклами работает за 30 мс, т.е. с ним нет никаких проблем.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/507",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 4876
        }
      ],
      "code_examples": [
        {
          "title": "Разбор задач Codeforces Beta Round #22 - Codeforces - Code 1",
          "code": "if (--m <= 0) return;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/507",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 25, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 25, \"m\");\n    inf.readEoln();\n\n    bool hasAtLeastOneZero = false;\n\n    for (int i = 0; i < n; ++i) {\n        string s = inf.readLine();\n        ensuref(int(s.length()) == m, \"Line %d must have exactly %d characters, but has %d\", i+1, m, int(s.length()));\n        for (int j = 0; j < m; ++j) {\n            ensuref(s[j] == '0' || s[j] == '1', \"Character %d in line %d must be '0' or '1'\", j+1, i+1);\n            if (s[j] == '0')\n                hasAtLeastOneZero = true;\n        }\n    }\n\n    ensuref(hasAtLeastOneZero, \"At least one free square is required (one '0' in the grid)\");\n\n    inf.readEof();\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 25, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 25, \"m\");\n    inf.readEoln();\n\n    bool hasAtLeastOneZero = false;\n\n    for (int i = 0; i < n; ++i) {\n        string s = inf.readLine();\n        ensuref(int(s.length()) == m, \"Line %d must have exactly %d characters, but has %d\", i+1, m, int(s.length()));\n        for (int j = 0; j < m; ++j) {\n            ensuref(s[j] == '0' || s[j] == '1', \"Character %d in line %d must be '0' or '1'\", j+1, i+1);\n            if (s[j] == '0')\n                hasAtLeastOneZero = true;\n        }\n    }\n\n    ensuref(hasAtLeastOneZero, \"At least one free square is required (one '0' in the grid)\");\n\n    inf.readEof();\n\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 25, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 25, \"m\");\n    inf.readEoln();\n\n    bool hasAtLeastOneZero = false;\n\n    for (int i = 0; i < n; ++i) {\n        string s = inf.readLine();\n        ensuref(int(s.length()) == m, \"Line %d must have exactly %d characters, but has %d\", i+1, m, int(s.length()));\n        for (int j = 0; j < m; ++j) {\n            ensuref(s[j] == '0' || s[j] == '1', \"Character %d in line %d must be '0' or '1'\", j+1, i+1);\n            if (s[j] == '0')\n                hasAtLeastOneZero = true;\n        }\n    }\n\n    ensuref(hasAtLeastOneZero, \"At least one free square is required (one '0' in the grid)\");\n\n    inf.readEof();\n\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<string> grid(n, string(m, '0'));\n\n    if (type == \"random\") {\n        // randomly fill the grid with '0's and '1's\n        for (int i = 0; i < n; ++i)\n            for (int j = 0; j < m; ++j)\n                grid[i][j] = rnd.next(2) ? '1' : '0';\n\n        // Ensure at least one '0' is present\n        int x = rnd.next(n);\n        int y = rnd.next(m);\n        grid[x][y] = '0';\n\n    } else if (type == \"full-zero\") {\n        // All cells are '0' (free)\n        for (int i = 0; i < n; ++i)\n            grid[i] = string(m, '0');\n    } else if (type == \"full-one-except-one\") {\n        // All cells are '1' except one '0'\n        for (int i = 0; i < n; ++i)\n            grid[i] = string(m, '1');\n        int x = rnd.next(n);\n        int y = rnd.next(m);\n        grid[x][y] = '0';\n    } else if (type == \"staircase-zero\") {\n        // Form a staircase pattern with '0's\n        for (int i = 0; i < n; ++i) {\n            grid[i] = string(m, '1');\n            for (int j = 0; j <= min(i, m-1); ++j) {\n                grid[i][j] = '0';\n            }\n        }\n    } else if (type == \"border-zero\") {\n        // Only the border cells are '0's, rest are '1's.\n        for (int i = 0; i < n; ++i) {\n            grid[i] = string(m, '1');\n            grid[i][0] = '0';\n            grid[i][m-1] = '0';\n        }\n        for (int j = 0; j < m; ++j) {\n            grid[0][j] = '0';\n            grid[n-1][j] = '0';\n        }\n    } else if (type == \"central-zero\") {\n        // All '1's except a central rectangle of '0's\n        int h = n / 2;\n        int w = m / 2;\n        int start_row = (n - h) / 2;\n        int start_col = (m - w) / 2;\n        for (int i = 0; i < n; ++i)\n            grid[i] = string(m, '1');\n        for (int i = start_row; i < start_row + h; ++i)\n            for (int j = start_col; j < start_col + w; ++j)\n                grid[i][j] = '0';\n        // Ensure at least one '0' is present\n        if (h == 0 || w == 0) {\n            int x = rnd.next(n);\n            int y = rnd.next(m);\n            grid[x][y] = '0';\n        }\n    } else if (type == \"single-zero\") {\n        // All '1's except one '0' at (0,0)\n        for (int i = 0; i < n; ++i)\n            grid[i] = string(m, '1');\n        grid[0][0] = '0';\n    } else if (type == \"thin-vertical\") {\n        // A vertical line of '0's in a sea of '1's\n        if (m == 0) m = 1;\n        int x = rnd.next(m);\n        for (int i = 0; i < n; ++i)\n            grid[i] = string(m, '1');\n        for (int i = 0; i < n; ++i)\n            grid[i][x] = '0';\n    } else if (type == \"thin-horizontal\") {\n        // A horizontal line of '0's in a sea of '1's\n        if (n == 0) n = 1;\n        int y = rnd.next(n);\n        for (int i = 0; i < n; ++i)\n            grid[i] = string(m, '1');\n        for (int j = 0; j < m; ++j)\n            grid[y][j] = '0';\n    } else if (type == \"checkerboard\") {\n        // Checkerboard pattern of '0's and '1's\n        for (int i = 0; i < n; ++i) {\n            grid[i].resize(m);\n            for (int j = 0; j < m; ++j)\n                grid[i][j] = ((i + j) % 2 == 0 ? '0' : '1');\n        }\n    } else if (type == \"diagonal-zero\") {\n        // Diagonal line of '0's\n        for (int i = 0; i < n; ++i) {\n            grid[i] = string(m, '1');\n            if (i < m)\n                grid[i][i] = '0';\n        }\n        // Ensure at least one '0' is present\n        if (m == 0 || n == 0) {\n            grid[0][0] = '0';\n        }\n    } else {\n        // default to random\n        // randomly fill the grid with '0's and '1's\n        for (int i = 0; i < n; ++i)\n            for (int j = 0; j < m; ++j)\n                grid[i][j] = rnd.next(2) ? '1' : '0';\n        // Ensure at least one '0' is present\n        int x = rnd.next(n);\n        int y = rnd.next(m);\n        grid[x][y] = '0';\n    }\n\n    // Output the grid\n    printf(\"%d %d\\n\", n, m);\n    for (int i = 0; i < n; ++i)\n        printf(\"%s\\n\", grid[i].c_str());\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<string> grid(n, string(m, '0'));\n\n    if (type == \"random\") {\n        // randomly fill the grid with '0's and '1's\n        for (int i = 0; i < n; ++i)\n            for (int j = 0; j < m; ++j)\n                grid[i][j] = rnd.next(2) ? '1' : '0';\n\n        // Ensure at least one '0' is present\n        int x = rnd.next(n);\n        int y = rnd.next(m);\n        grid[x][y] = '0';\n\n    } else if (type == \"full-zero\") {\n        // All cells are '0' (free)\n        for (int i = 0; i < n; ++i)\n            grid[i] = string(m, '0');\n    } else if (type == \"full-one-except-one\") {\n        // All cells are '1' except one '0'\n        for (int i = 0; i < n; ++i)\n            grid[i] = string(m, '1');\n        int x = rnd.next(n);\n        int y = rnd.next(m);\n        grid[x][y] = '0';\n    } else if (type == \"staircase-zero\") {\n        // Form a staircase pattern with '0's\n        for (int i = 0; i < n; ++i) {\n            grid[i] = string(m, '1');\n            for (int j = 0; j <= min(i, m-1); ++j) {\n                grid[i][j] = '0';\n            }\n        }\n    } else if (type == \"border-zero\") {\n        // Only the border cells are '0's, rest are '1's.\n        for (int i = 0; i < n; ++i) {\n            grid[i] = string(m, '1');\n            grid[i][0] = '0';\n            grid[i][m-1] = '0';\n        }\n        for (int j = 0; j < m; ++j) {\n            grid[0][j] = '0';\n            grid[n-1][j] = '0';\n        }\n    } else if (type == \"central-zero\") {\n        // All '1's except a central rectangle of '0's\n        int h = n / 2;\n        int w = m / 2;\n        int start_row = (n - h) / 2;\n        int start_col = (m - w) / 2;\n        for (int i = 0; i < n; ++i)\n            grid[i] = string(m, '1');\n        for (int i = start_row; i < start_row + h; ++i)\n            for (int j = start_col; j < start_col + w; ++j)\n                grid[i][j] = '0';\n        // Ensure at least one '0' is present\n        if (h == 0 || w == 0) {\n            int x = rnd.next(n);\n            int y = rnd.next(m);\n            grid[x][y] = '0';\n        }\n    } else if (type == \"single-zero\") {\n        // All '1's except one '0' at (0,0)\n        for (int i = 0; i < n; ++i)\n            grid[i] = string(m, '1');\n        grid[0][0] = '0';\n    } else if (type == \"thin-vertical\") {\n        // A vertical line of '0's in a sea of '1's\n        if (m == 0) m = 1;\n        int x = rnd.next(m);\n        for (int i = 0; i < n; ++i)\n            grid[i] = string(m, '1');\n        for (int i = 0; i < n; ++i)\n            grid[i][x] = '0';\n    } else if (type == \"thin-horizontal\") {\n        // A horizontal line of '0's in a sea of '1's\n        if (n == 0) n = 1;\n        int y = rnd.next(n);\n        for (int i = 0; i < n; ++i)\n            grid[i] = string(m, '1');\n        for (int j = 0; j < m; ++j)\n            grid[y][j] = '0';\n    } else if (type == \"checkerboard\") {\n        // Checkerboard pattern of '0's and '1's\n        for (int i = 0; i < n; ++i) {\n            grid[i].resize(m);\n            for (int j = 0; j < m; ++j)\n                grid[i][j] = ((i + j) % 2 == 0 ? '0' : '1');\n        }\n    } else if (type == \"diagonal-zero\") {\n        // Diagonal line of '0's\n        for (int i = 0; i < n; ++i) {\n            grid[i] = string(m, '1');\n            if (i < m)\n                grid[i][i] = '0';\n        }\n        // Ensure at least one '0' is present\n        if (m == 0 || n == 0) {\n            grid[0][0] = '0';\n        }\n    } else {\n        // default to random\n        // randomly fill the grid with '0's and '1's\n        for (int i = 0; i < n; ++i)\n            for (int j = 0; j < m; ++j)\n                grid[i][j] = rnd.next(2) ? '1' : '0';\n        // Ensure at least one '0' is present\n        int x = rnd.next(n);\n        int y = rnd.next(m);\n        grid[x][y] = '0';\n    }\n\n    // Output the grid\n    printf(\"%d %d\\n\", n, m);\n    for (int i = 0; i < n; ++i)\n        printf(\"%s\\n\", grid[i].c_str());\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Minimal input\n./gen -n 1 -m 1 -type single-zero\n\n# Maximal input, full '0's\n./gen -n 25 -m 25 -type full-zero\n\n# Maximal input, random\n./gen -n 25 -m 25 -type random\n\n# Maximal input, all '1's except one '0'\n./gen -n 25 -m 25 -type full-one-except-one\n\n# Narrow grid, vertical line\n./gen -n 25 -m 1 -type thin-vertical\n\n# Narrow grid, horizontal line\n./gen -n 1 -m 25 -type thin-horizontal\n\n# Staircase pattern\n./gen -n 25 -m 25 -type staircase-zero\n\n# Border zeros\n./gen -n 25 -m 25 -type border-zero\n\n# Central zeros\n./gen -n 25 -m 25 -type central-zero\n\n# Checkerboard pattern\n./gen -n 25 -m 25 -type checkerboard\n\n# Random grids of various sizes\n./gen -n 10 -m 10 -type random\n./gen -n 15 -m 20 -type random\n./gen -n 20 -m 5 -type random\n\n# Diagonal zeros\n./gen -n 25 -m 25 -type diagonal-zero\n\n# Some small grids\n./gen -n 5 -m 5 -type random\n./gen -n 7 -m 7 -type checkerboard\n\n# Grids with only one '0'\n./gen -n 5 -m 5 -type full-one-except-one\n\n# Thin views\n./gen -n 1 -m 10 -type random\n./gen -n 10 -m 1 -type random\n\n# Test with thin vertical and horizontal zeros\n./gen -n 12 -m 12 -type thin-vertical\n./gen -n 12 -m 12 -type thin-horizontal\n\n# Edge case with maximum area\n./gen -n 25 -m 25 -type full-zero\n\n# Edge case with minimal '0's\n./gen -n 25 -m 25 -type full-one-except-one\n\n# Random grids with varying densities\n./gen -n 20 -m 20 -type random\n./gen -n 20 -m 20 -type random\n./gen -n 20 -m 20 -type random\n\n# Small grids with central zeros\n./gen -n 6 -m 6 -type central-zero\n./gen -n 8 -m 8 -type central-zero\n\n# Very asymmetrical grids\n./gen -n 18 -m 2 -type random\n./gen -n 2 -m 18 -type random\n\n# More cases with staircase\n./gen -n 15 -m 15 -type staircase-zero\n\n# Random grids with one '0' in random position\n./gen -n 16 -m 16 -type single-zero\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T19:50:43.118506",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "22/C",
      "title": "C. System Administrator",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first input line contains 3 space-separated integer numbers n, m, v (3 ≤ n ≤ 105, 0 ≤ m ≤ 105, 1 ≤ v ≤ n), n — amount of servers, m — amount of direct connections, v — index of the server that fails and leads to the failure of the whole system.",
      "output_spec": "OutputIf it is impossible to connect the servers in the required way, output -1. Otherwise output m lines with 2 numbers each — description of all the direct connections in the system. Each direct connection is described by two numbers — indexes of two servers, linked by this direct connection. The servers are numbered from 1. If the answer is not unique, output any.",
      "sample_tests": "ExamplesInputCopy5 6 3OutputCopy1 22 33 44 51 33 5InputCopy6 100 1OutputCopy-1",
      "description": "C. System Administrator\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first input line contains 3 space-separated integer numbers n, m, v (3 ≤ n ≤ 105, 0 ≤ m ≤ 105, 1 ≤ v ≤ n), n — amount of servers, m — amount of direct connections, v — index of the server that fails and leads to the failure of the whole system.\n\nOutputIf it is impossible to connect the servers in the required way, output -1. Otherwise output m lines with 2 numbers each — description of all the direct connections in the system. Each direct connection is described by two numbers — indexes of two servers, linked by this direct connection. The servers are numbered from 1. If the answer is not unique, output any.\n\nInputCopy5 6 3OutputCopy1 22 33 44 51 33 5InputCopy6 100 1OutputCopy-1\n\nInputCopy5 6 3\n\nOutputCopy1 22 33 44 51 33 5\n\nInputCopy6 100 1\n\nOutputCopy-1",
      "solutions": [
        {
          "title": "Codeforces Beta Round #22 (Div. 2) - Codeforces",
          "content": "Welcome all to Codeforces Beta Round #22 Note that at this time registration is possible during the round. The contest will begin at 19:00 MSK. Today I am an author of the problems. I would like to thank Mike Mirzayanov for help in contest preparations, Edvard Davtyan and Nickolay Kuznetsov for writing the verification solutions, and Julia Satushina for translating statements into English. Good luck on the contest! UPD: The contest is over. Thank you all for participating! Problems Results Winner Kasparyanm_Mihail gains +203 to rating after the contest!",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/505",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.6,
            "reason": "宽松匹配: 包含题目编号 22 和字母"
          },
          "content_length": 559
        },
        {
          "title": "Codeforces Beta Round #22 Tutorial - Codeforces",
          "content": "Contest discussionProblem А. Second Order StatisticsSortingIn this problem one should find a minimal element from all elements, that are strictly greater, then the minimal one or report that it doesn't exist. Of course, there can be a lot of different solutions, but one of the simplest - to sort the given sequence and print the first element, that's not equal to the previous. If all elements are equal, then the required element doesn't exist. Problem B. Bargaining TableSimulation, dynamic programmingIn this problem one should find the maximal perimeter of a rectangle that contains no '1'. Define these rectangles \"correct\". To solve a problem you are to check each possible rectangle for correctness and calculate its perimeter. The easiest way to check all rectangles is using 6 nested cycles. Using 4 of them you fix the coordinates while other 2 will look for '1'. So the complexity is O((n*m)3). It seems slow, but those, who wrote such a solution, says that it hasn't any problems with TL.One may interest in much faster solution. Using simple DP solution one can get a solution with an O((n*m)2) complexity. It's clear, that rectangle with coordinates (x1, y1, x2, y2) is correct if and only if rectangles (x1, y1, x2-1, y2) and (x1, y1, x2, y2-1) are correct, and board[x2][y2] = '0'. So each of rectangles can be checked in O(1) and totally there will be O((n*m)2) operations.Problem C. System AdministratorSimulationIn this problem you are to construct a connected graph, which contains n vertexes and m edges, and if we delete vertex with number v, our graph stops being connected or to report that such a graph doesn't exist. Moreover, each pair of vertexes can have no more than one edge connecting them. Obviously, a connected graph doesn't exist if the number of edges is less than n-1. It's easy to notice, that the maximal possible number of edges reaches when there is a vertex connected to v and doesn't connected to any other vertex, those can form up to complete graph. So the maximal number of edges is (n-1)*(n-2)/2+1. If m is in that range then required graph always exists. Then you should place one vertex on the one side of v (let it be 1), and other vertexes - on the other side. First, you should connect all this vertexes to v and then connect them between each other (except 1).Problem D. SegmentsScanning lineIn this problem one should place minimal number of points on the line such that any given segment touches at least one of these points. Let's call the coordinate of ending of any segment as event. There will be events of two types: beginning of a segment and its ending. Let's sort this events by coordinates. In the case of equality of some events consider that the event of the beginning will be less than the event of ending. Look at our events from left to right: if there is a beginning event, then push the number of this segment to the special queue. Once we take an ending of some segment, place the point here and clear the special queue (because each of segment in this queue will touch this point).Problem E. SchemeGraph theoryGiven an oriented graph, find the minimal number of edges one should add to this graph to make it strongly connected. Looking at statement we can get the fact that each vertex has exactly one outcoming edge. It means that starting at some point we'll get stuck in some cycle. So each connected (not strongly) component is a set of simple paths, ending in some cycle or just a simple cycle. First consider vertexes, which has no incoming edges. When passing through some vertex we'll paint it until the current vertex will be already painted. Then we call the starting vertex as \"beginning\" and the finishing one as \"ending\" of a component.After that consider other vertexes - they belong to cycles. Beginning and ending of a cycle - is any vertexes (possible coinciding) belonging to it. So we got a number of components which we have to connect. Let's connect them cyclically: the edge will pass from the ending of i-th component to the beginning of ((i+1)%k)-th, where k is the number of such components. The answer will be k. There is an exception: if we have only one component which is a simple cycle, the answer will be equal to 0.So we'll consider each edge exactly once and the total complexity will be O(n).",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/507",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 4301
        }
      ],
      "code_examples": [],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(3, 100000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(0, 100000, \"m\");\n    inf.readSpace();\n    int v = inf.readInt(1, n, \"v\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(3, 100000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(0, 100000, \"m\");\n    inf.readSpace();\n    int v = inf.readInt(1, n, \"v\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(3, 100000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(0, 100000, \"m\");\n    inf.readSpace();\n    int v = inf.readInt(1, n, \"v\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\n/*\n    This checker verifies a construction of an undirected graph of n vertices\n    connected by m edges such that:\n      1) The graph is connected (any server can reach any other).\n      2) Removing the specific vertex v makes the graph disconnected.\n    Alternatively, a solution can output \"-1\" meaning no valid construction.\n\n    We compare the jury's solution (ans) and the participant's solution (ouf):\n      - If both have valid solutions, verdict is _ok.\n      - If jury has a valid solution but participant does not, verdict is _wa.\n      - If jury has no solution but participant has a valid solution, verdict is _fail.\n      - If both say no solution, verdict is _ok.\n*/\n\nstatic const string NO_SOLUTION_TOKEN = \"-1\";\n\nint n, m, v;\n\n// Check if the given adjacency list represents a connected graph (all n servers involved).\nbool isConnected(const vector<vector<int>>& adj)\n{\n    // We'll do a BFS from node 1. If we can reach all n servers, it's connected.\n    vector<bool> visited(n + 1, false);\n    visited[1] = true;\n\n    queue<int> q;\n    q.push(1);\n\n    int countVisited = 1;\n    while (!q.empty()) {\n        int cur = q.front();\n        q.pop();\n        for(int nxt : adj[cur]) {\n            if (!visited[nxt]) {\n                visited[nxt] = true;\n                countVisited++;\n                q.push(nxt);\n            }\n        }\n    }\n    return (countVisited == n);\n}\n\n// Check if removing vertex v from the adjacency list disconnects the graph.\nbool isDisconnectedWithoutV(const vector<vector<int>>& adj)\n{\n    // We will do a BFS from a node that isn't v. If we still can visit (n-1) nodes,\n    // it means removing v didn't break connectivity, which fails the condition.\n    // We want to see that removing v actually breaks connectivity\n    // => BFS visits fewer than (n - 1).\n    int start = -1;\n    for(int i = 1; i <= n; i++) {\n        if (i != v) {\n            start = i;\n            break;\n        }\n    }\n    // If for some reason we never find a start, n must be < 2, but problem constraints say n >= 3.\n    if (start == -1) return true; \n\n    vector<bool> visited(n + 1, false);\n    visited[start] = true;\n    queue<int> q;\n    q.push(start);\n\n    int countVisited = 1;\n    while(!q.empty()) {\n        int cur = q.front();\n        q.pop();\n        for(int nxt : adj[cur]) {\n            if (nxt == v) continue;  // skip the removed vertex\n            if (!visited[nxt]) {\n                visited[nxt] = true;\n                countVisited++;\n                q.push(nxt);\n            }\n        }\n    }\n    // If fewer than (n-1) are reached, then removing v made the graph disconnected.\n    return (countVisited < (n - 1));\n}\n\n// Reads and checks a solution from the given stream. Returns:\n//    true  if it represents a valid solution (m edges that meets the conditions),\n//    false if the solution is just \"-1\" (meaning no solution).\n// If the stream has any invalidity, we call stream.quitf(...) with _wa or _fail.\nbool readAndCheckSolution(InStream &stream)\n{\n    // If the stream is empty, there's no output => invalid.\n    if (stream.seekEof()) {\n        stream.quitf(_wa, \"No output provided\");\n    }\n\n    // Read the first token\n    string firstToken = stream.readToken();\n\n    // If this token is \"-1\", that means \"no solution\". We then expect no more tokens.\n    if (firstToken == NO_SOLUTION_TOKEN) {\n        if (!stream.seekEof()) {\n            // Something (non-whitespace) remains, so it's invalid.\n            stream.quitf(_wa, \"Unexpected tokens after -1\");\n        }\n        return false; // meaning \"no solution\"\n    }\n\n    // Otherwise, this token should be the first integer of the first edge's endpoints.\n    long long parsed = atoll(firstToken.c_str());\n    if (parsed < 1 || parsed > n) {\n        stream.quitf(_wa, \"Edge endpoint %lld is out of range [1..%d]\", parsed, n);\n    }\n    int a1 = (int)parsed;\n\n    // Read the second endpoint for the first edge\n    int b1 = stream.readInt(1, n, \"edge endpoint\");\n    if (a1 == b1) {\n        stream.quitf(_wa, \"Self-loop detected: %d %d\", a1, b1);\n    }\n\n    // Collect all edges\n    vector<pair<int, int>> edges;\n    edges.reserve(m);\n    edges.push_back({a1, b1});\n\n    // Read remaining m-1 edges\n    for (int i = 1; i < m; i++) {\n        int a = stream.readInt(1, n, \"edge endpoint\");\n        int b = stream.readInt(1, n, \"edge endpoint\");\n        if (a == b) {\n            stream.quitf(_wa, \"Self-loop detected: %d %d\", a, b);\n        }\n        edges.push_back({a, b});\n    }\n\n    // After reading m edges, we must not have extra tokens besides whitespace.\n    if (!stream.seekEof()) {\n        stream.quitf(_wa, \"Too many tokens. Exactly %d edges expected.\", m);\n    }\n\n    // Build adjacency list & check for duplicates\n    vector<vector<int>> adj(n + 1);\n    unordered_set<long long> used;\n    used.reserve(m);\n\n    for (auto &e : edges) {\n        int x = e.first, y = e.second;\n        int mn = min(x, y), mx = max(x, y);\n        long long key = (static_cast<long long>(mn) << 32) ^ (static_cast<long long>(mx));\n        if (used.find(key) != used.end()) {\n            stream.quitf(_wa, \"Duplicate edge found: %d %d\", x, y);\n        }\n        used.insert(key);\n\n        adj[x].push_back(y);\n        adj[y].push_back(x);\n    }\n\n    // 1) Check connectivity\n    if(!isConnected(adj)) {\n        stream.quitf(_wa, \"The graph is not connected\");\n    }\n    // 2) Check that removing v breaks the connectivity\n    if(!isDisconnectedWithoutV(adj)) {\n        stream.quitf(_wa, \"Removing server %d does not disconnect the graph\", v);\n    }\n\n    // If all checks passed, we have a valid construction\n    return true;\n}\n\nint main(int argc, char* argv[])\n{\n    registerTestlibCmd(argc, argv);\n\n    // Read the problem input from inf\n    n = inf.readInt(3, 100000);\n    m = inf.readInt(0, 100000);\n    v = inf.readInt(1, n);\n\n    // Read the jury's solution (ans)\n    bool juryValid = readAndCheckSolution(ans);\n\n    // Read the participant's solution (ouf)\n    bool partValid = readAndCheckSolution(ouf);\n\n    // Compare the results\n    if (juryValid && partValid) {\n        // Both have valid solutions\n        quitf(_ok, \"Both solutions are valid\");\n    } \n    else if (juryValid && !partValid) {\n        // Jury is valid, participant is not\n        quitf(_wa, \"Jury has a valid solution, participant does not\");\n    } \n    else if (!juryValid && partValid) {\n        // Jury says no solution, participant found one\n        quitf(_fail, \"Jury says no solution, but participant found one\");\n    } \n    else {\n        // Both say no solution\n        quitf(_ok, \"Both solutions say no solution is possible\");\n    }\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\n/*\n  This generator will produce exactly ONE test case each time it is run.\n  It prints a single line containing three integers (n, m, v) — which is the\n  entire input for the \"Bob got a job...\" problem. The contestants' solutions\n  will read these three integers and then either print m edges or -1.\n\n  Usage examples:\n    ./gen -type small1\n    ./gen -type small2\n    ./gen -type random_valid\n    ./gen -type random_invalid\n    ./gen -n 10 -m 15 -v 2 -type random_valid\n  \n  Notes:\n    1) We do NOT set the random seed.\n    2) If the user does not provide parameters, the generator will pick them\n       automatically depending on the test \"type\".\n    3) The constraints for the problem are:\n         3 <= n <= 100000\n         0 <= m <= 100000\n         1 <= v <= n\n       A valid test requires that:\n         n - 1 <= m <= 1 + (n - 1) * (n - 2) / 2\n       If (n, m, v) is outside this range, the correct solution would print -1.\n*/\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    // Parameters to be read from command line (if provided).\n    int n = opt<int>(\"n\", -1);\n    int m = opt<int>(\"m\", -1);\n    int v = opt<int>(\"v\", -1);\n\n    // We allow a \"type\" parameter to control the kind of test we produce.\n    // The default is \"none\", which means we simply print whatever n/m/v\n    // the user passed (with some minimal defaults if nothing is passed).\n    string type = opt<string>(\"type\", \"none\");\n\n    // A small helper function to safely compute the maximum feasible m (T).\n    // The formula is: T = 1 + (n - 1)*(n - 2)/2\n    // which can grow large, but we only cap it at 100000 due to the problem constraints.\n    auto maxEdges = [&](long long nn) {\n        long long T = 1 + (long long)(nn - 1) * (nn - 2) / 2LL;\n        return min(T, 100000LL);\n    };\n\n    if (type == \"small1\") {\n        // A small valid case (minimum n=3). This should be valid:\n        // n=3, m=2 => (n-1) <= m <= T => 2 <= 2 <= 2, v=2 => feasible.\n        n = 3;\n        m = 2;\n        v = 2;\n\n    } else if (type == \"small2\") {\n        // A small invalid case:\n        // For n=3, T=2, but here m=3, so m > T -> invalid => -1.\n        n = 3;\n        m = 3;\n        v = 1;\n\n    } else if (type == \"random_valid\") {\n        // Produce a random feasible (n, m, v).\n        // If user didn't supply n, pick random in [3..1000].\n        if (n < 3) {\n            n = rnd.next(3, 1000);\n        }\n        long long T = maxEdges(n);\n        // If T < n-1, it means there's no feasible way in that small range, so reset n.\n        if (T < (n - 1)) {\n            // fallback\n            n = 10;\n            T = maxEdges(n);\n        }\n        // If user didn't supply m, pick it in [n-1..T].\n        if (m < 0) {\n            m = rnd.next((int)(n - 1), (int)T);\n        } else {\n            // If user-supplied m is not feasible, clamp it into the feasible range.\n            if (m < (n - 1)) m = (n - 1);\n            if (m > T) m = (int)T;\n        }\n        // If user didn't supply v or gave an invalid v, pick random.\n        if (v < 1 || v > n) {\n            v = rnd.next(1, n);\n        }\n\n    } else if (type == \"random_invalid\") {\n        // Produce a random scenario that is guaranteed to be invalid:\n        // i.e., m < n-1 or m > T.\n        if (n < 3) {\n            n = rnd.next(3, 1000);\n        }\n        long long T = maxEdges(n);\n\n        // We choose to violate the constraints by picking m < n-1 OR m > T.\n        bool pickLower = (rnd.next(2) == 0);\n        if (pickLower) {\n            // pick m strictly less than n-1\n            // but keep it within [0..(n-2)] so it doesn't go negative\n            m = rnd.next(0, n - 2);\n        } else {\n            // pick m strictly greater than T, but not exceeding 100000\n            // T <= 100000, so we do T+1..100000\n            // safe cast\n            long long lower = T + 1;\n            if (lower > 100000) lower = 100000; // extremely corner case\n            m = rnd.next((int)lower, 100000);\n        }\n        // If user v is invalid or not given\n        if (v < 1 || v > n) {\n            v = rnd.next(1, n);\n        }\n\n    } else {\n        // type == \"none\" or anything else:\n        // If user didn't supply anything, produce a minimal fallback.\n        if (n < 3) {\n            n = 3;\n        }\n        if (v < 1 || v > n) {\n            v = 1;\n        }\n        if (m < 0) {\n            m = 0;\n        }\n    }\n\n    // Print the single line \"n m v\".\n    cout << n << \" \" << m << \" \" << v << \"\\n\";\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\n/*\n  This generator will produce exactly ONE test case each time it is run.\n  It prints a single line containing three integers (n, m, v) — which is the\n  entire input for the \"Bob got a job...\" problem. The contestants' solutions\n  will read these three integers and then either print m edges or -1.\n\n  Usage examples:\n    ./gen -type small1\n    ./gen -type small2\n    ./gen -type random_valid\n    ./gen -type random_invalid\n    ./gen -n 10 -m 15 -v 2 -type random_valid\n  \n  Notes:\n    1) We do NOT set the random seed.\n    2) If the user does not provide parameters, the generator will pick them\n       automatically depending on the test \"type\".\n    3) The constraints for the problem are:\n         3 <= n <= 100000\n         0 <= m <= 100000\n         1 <= v <= n\n       A valid test requires that:\n         n - 1 <= m <= 1 + (n - 1) * (n - 2) / 2\n       If (n, m, v) is outside this range, the correct solution would print -1.\n*/\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    // Parameters to be read from command line (if provided).\n    int n = opt<int>(\"n\", -1);\n    int m = opt<int>(\"m\", -1);\n    int v = opt<int>(\"v\", -1);\n\n    // We allow a \"type\" parameter to control the kind of test we produce.\n    // The default is \"none\", which means we simply print whatever n/m/v\n    // the user passed (with some minimal defaults if nothing is passed).\n    string type = opt<string>(\"type\", \"none\");\n\n    // A small helper function to safely compute the maximum feasible m (T).\n    // The formula is: T = 1 + (n - 1)*(n - 2)/2\n    // which can grow large, but we only cap it at 100000 due to the problem constraints.\n    auto maxEdges = [&](long long nn) {\n        long long T = 1 + (long long)(nn - 1) * (nn - 2) / 2LL;\n        return min(T, 100000LL);\n    };\n\n    if (type == \"small1\") {\n        // A small valid case (minimum n=3). This should be valid:\n        // n=3, m=2 => (n-1) <= m <= T => 2 <= 2 <= 2, v=2 => feasible.\n        n = 3;\n        m = 2;\n        v = 2;\n\n    } else if (type == \"small2\") {\n        // A small invalid case:\n        // For n=3, T=2, but here m=3, so m > T -> invalid => -1.\n        n = 3;\n        m = 3;\n        v = 1;\n\n    } else if (type == \"random_valid\") {\n        // Produce a random feasible (n, m, v).\n        // If user didn't supply n, pick random in [3..1000].\n        if (n < 3) {\n            n = rnd.next(3, 1000);\n        }\n        long long T = maxEdges(n);\n        // If T < n-1, it means there's no feasible way in that small range, so reset n.\n        if (T < (n - 1)) {\n            // fallback\n            n = 10;\n            T = maxEdges(n);\n        }\n        // If user didn't supply m, pick it in [n-1..T].\n        if (m < 0) {\n            m = rnd.next((int)(n - 1), (int)T);\n        } else {\n            // If user-supplied m is not feasible, clamp it into the feasible range.\n            if (m < (n - 1)) m = (n - 1);\n            if (m > T) m = (int)T;\n        }\n        // If user didn't supply v or gave an invalid v, pick random.\n        if (v < 1 || v > n) {\n            v = rnd.next(1, n);\n        }\n\n    } else if (type == \"random_invalid\") {\n        // Produce a random scenario that is guaranteed to be invalid:\n        // i.e., m < n-1 or m > T.\n        if (n < 3) {\n            n = rnd.next(3, 1000);\n        }\n        long long T = maxEdges(n);\n\n        // We choose to violate the constraints by picking m < n-1 OR m > T.\n        bool pickLower = (rnd.next(2) == 0);\n        if (pickLower) {\n            // pick m strictly less than n-1\n            // but keep it within [0..(n-2)] so it doesn't go negative\n            m = rnd.next(0, n - 2);\n        } else {\n            // pick m strictly greater than T, but not exceeding 100000\n            // T <= 100000, so we do T+1..100000\n            // safe cast\n            long long lower = T + 1;\n            if (lower > 100000) lower = 100000; // extremely corner case\n            m = rnd.next((int)lower, 100000);\n        }\n        // If user v is invalid or not given\n        if (v < 1 || v > n) {\n            v = rnd.next(1, n);\n        }\n\n    } else {\n        // type == \"none\" or anything else:\n        // If user didn't supply anything, produce a minimal fallback.\n        if (n < 3) {\n            n = 3;\n        }\n        if (v < 1 || v > n) {\n            v = 1;\n        }\n        if (m < 0) {\n            m = 0;\n        }\n    }\n\n    // Print the single line \"n m v\".\n    cout << n << \" \" << m << \" \" << v << \"\\n\";\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Small corner cases\n./gen -type small1\n./gen -type small2\n\n# Random valid cases with no user-supplied n, m, v\n./gen -type random_valid\n./gen -type random_valid\n./gen -type random_valid\n\n# Random invalid cases\n./gen -type random_invalid\n./gen -type random_invalid\n./gen -type random_invalid\n\n# Mixed usage: manually specify n but random m, v\n./gen -type random_valid -n 5\n./gen -type random_invalid -n 5\n./gen -type random_valid -n 10\n./gen -type random_invalid -n 10\n\n# Manually specify m and let n, v be random (may adjust to be valid or clamp)\n./gen -type random_valid -m 20\n./gen -type random_valid -m 99999\n./gen -type random_invalid -m 0\n./gen -type random_invalid -m 100000\n\n# Manually specify v, random n, m\n./gen -type random_valid -v 1\n./gen -type random_valid -v 2\n./gen -type random_invalid -v 1\n./gen -type random_invalid -v 10\n\n# Larger n, force random_valid with possible large values\n./gen -type random_valid -n 999\n./gen -type random_valid -n 1000\n./gen -type random_valid -n 500 -m 499  # borderline (n-1)\n./gen -type random_invalid -n 500 -m 501  # forcibly too big or too small\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T19:50:44.971364",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "22/D",
      "title": "D. Segments",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line of the input contains single integer number n (1 ≤ n ≤ 1000) — amount of segments. Following n lines contain descriptions of the segments. Each description is a pair of integer numbers — endpoints coordinates. All the coordinates don't exceed 10000 by absolute value. Segments can degenarate to points.",
      "output_spec": "OutputThe first line should contain one integer number — the smallest number of nails needed to nail all the segments down. The second line should contain coordinates of driven nails separated by space in any order. If the answer is not unique, output any.",
      "sample_tests": "ExamplesInputCopy20 22 5OutputCopy12 InputCopy50 34 24 88 107 7OutputCopy37 10 3",
      "description": "D. Segments\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line of the input contains single integer number n (1 ≤ n ≤ 1000) — amount of segments. Following n lines contain descriptions of the segments. Each description is a pair of integer numbers — endpoints coordinates. All the coordinates don't exceed 10000 by absolute value. Segments can degenarate to points.\n\nOutputThe first line should contain one integer number — the smallest number of nails needed to nail all the segments down. The second line should contain coordinates of driven nails separated by space in any order. If the answer is not unique, output any.\n\nInputCopy20 22 5OutputCopy12 InputCopy50 34 24 88 107 7OutputCopy37 10 3\n\nInputCopy20 22 5\n\nOutputCopy12\n\nInputCopy50 34 24 88 107 7\n\nOutputCopy37 10 3",
      "solutions": [
        {
          "title": "Codeforces Beta Round #22 (Div. 2) - Codeforces",
          "content": "Welcome all to Codeforces Beta Round #22 Note that at this time registration is possible during the round. The contest will begin at 19:00 MSK. Today I am an author of the problems. I would like to thank Mike Mirzayanov for help in contest preparations, Edvard Davtyan and Nickolay Kuznetsov for writing the verification solutions, and Julia Satushina for translating statements into English. Good luck on the contest! UPD: The contest is over. Thank you all for participating! Problems Results Winner Kasparyanm_Mihail gains +203 to rating after the contest!",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/505",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.6,
            "reason": "宽松匹配: 包含题目编号 22 和字母"
          },
          "content_length": 559
        },
        {
          "title": "Codeforces Beta Round #22 Tutorial - Codeforces",
          "content": "Contest discussionProblem А. Second Order StatisticsSortingIn this problem one should find a minimal element from all elements, that are strictly greater, then the minimal one or report that it doesn't exist. Of course, there can be a lot of different solutions, but one of the simplest - to sort the given sequence and print the first element, that's not equal to the previous. If all elements are equal, then the required element doesn't exist. Problem B. Bargaining TableSimulation, dynamic programmingIn this problem one should find the maximal perimeter of a rectangle that contains no '1'. Define these rectangles \"correct\". To solve a problem you are to check each possible rectangle for correctness and calculate its perimeter. The easiest way to check all rectangles is using 6 nested cycles. Using 4 of them you fix the coordinates while other 2 will look for '1'. So the complexity is O((n*m)3). It seems slow, but those, who wrote such a solution, says that it hasn't any problems with TL.One may interest in much faster solution. Using simple DP solution one can get a solution with an O((n*m)2) complexity. It's clear, that rectangle with coordinates (x1, y1, x2, y2) is correct if and only if rectangles (x1, y1, x2-1, y2) and (x1, y1, x2, y2-1) are correct, and board[x2][y2] = '0'. So each of rectangles can be checked in O(1) and totally there will be O((n*m)2) operations.Problem C. System AdministratorSimulationIn this problem you are to construct a connected graph, which contains n vertexes and m edges, and if we delete vertex with number v, our graph stops being connected or to report that such a graph doesn't exist. Moreover, each pair of vertexes can have no more than one edge connecting them. Obviously, a connected graph doesn't exist if the number of edges is less than n-1. It's easy to notice, that the maximal possible number of edges reaches when there is a vertex connected to v and doesn't connected to any other vertex, those can form up to complete graph. So the maximal number of edges is (n-1)*(n-2)/2+1. If m is in that range then required graph always exists. Then you should place one vertex on the one side of v (let it be 1), and other vertexes - on the other side. First, you should connect all this vertexes to v and then connect them between each other (except 1).Problem D. SegmentsScanning lineIn this problem one should place minimal number of points on the line such that any given segment touches at least one of these points. Let's call the coordinate of ending of any segment as event. There will be events of two types: beginning of a segment and its ending. Let's sort this events by coordinates. In the case of equality of some events consider that the event of the beginning will be less than the event of ending. Look at our events from left to right: if there is a beginning event, then push the number of this segment to the special queue. Once we take an ending of some segment, place the point here and clear the special queue (because each of segment in this queue will touch this point).Problem E. SchemeGraph theoryGiven an oriented graph, find the minimal number of edges one should add to this graph to make it strongly connected. Looking at statement we can get the fact that each vertex has exactly one outcoming edge. It means that starting at some point we'll get stuck in some cycle. So each connected (not strongly) component is a set of simple paths, ending in some cycle or just a simple cycle. First consider vertexes, which has no incoming edges. When passing through some vertex we'll paint it until the current vertex will be already painted. Then we call the starting vertex as \"beginning\" and the finishing one as \"ending\" of a component.After that consider other vertexes - they belong to cycles. Beginning and ending of a cycle - is any vertexes (possible coinciding) belonging to it. So we got a number of components which we have to connect. Let's connect them cyclically: the edge will pass from the ending of i-th component to the beginning of ((i+1)%k)-th, where k is the number of such components. The answer will be k. There is an exception: if we have only one component which is a simple cycle, the answer will be equal to 0.So we'll consider each edge exactly once and the total complexity will be O(n).",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/507",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 4301
        }
      ],
      "code_examples": [],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 1000, \"n\");\n    inf.readEoln();\n\n    for (int i = 0; i < n; ++i) {\n        string xi_name = \"x_\" + to_string(i+1);\n        string yi_name = \"y_\" + to_string(i+1);\n        int x_i = inf.readInt(-10000, 10000, xi_name.c_str());\n        inf.readSpace();\n        int y_i = inf.readInt(-10000, 10000, yi_name.c_str());\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 1000, \"n\");\n    inf.readEoln();\n\n    for (int i = 0; i < n; ++i) {\n        string xi_name = \"x_\" + to_string(i+1);\n        string yi_name = \"y_\" + to_string(i+1);\n        int x_i = inf.readInt(-10000, 10000, xi_name.c_str());\n        inf.readSpace();\n        int y_i = inf.readInt(-10000, 10000, yi_name.c_str());\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 1000, \"n\");\n    inf.readEoln();\n\n    for (int i = 0; i < n; ++i) {\n        string xi_name = \"x_\" + to_string(i+1);\n        string yi_name = \"y_\" + to_string(i+1);\n        int x_i = inf.readInt(-10000, 10000, xi_name.c_str());\n        inf.readSpace();\n        int y_i = inf.readInt(-10000, 10000, yi_name.c_str());\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerTestlibCmd(argc, argv);\n\n    // Read the input segments from inf\n    int n = inf.readInt(1, 1000);\n    vector<pair<int, int>> segments(n);\n    for (int i = 0; i < n; ++i) {\n        int a = inf.readInt(-10000, 10000);\n        int b = inf.readInt(-10000, 10000);\n        segments[i] = make_pair(min(a, b), max(a, b));\n    }\n\n    // Read the minimal number of nails from the jury's answer (ans)\n    int jury_k = ans.readInt(1, n);\n\n    // Read the participant's answer\n    int participant_k = ouf.readInt(1, n, \"number of nails\");\n\n    // Compare the participant's k with the jury's k\n    if (participant_k < jury_k)\n        quitf(_fail, \"Participant has a better answer than the jury: participant_k = %d, jury_k = %d\", participant_k, jury_k);\n    else if (participant_k > jury_k)\n        quitf(_wa, \"Participant's answer is worse than optimal: participant_k = %d, jury_k = %d\", participant_k, jury_k);\n\n    // Read the participant's nails\n    vector<int> nails = ouf.readInts(participant_k, -10000, 10000, \"nail positions\");\n\n    // Check that all segments are nailed\n    for (int i = 0; i < n; ++i) {\n        int l = segments[i].first;\n        int r = segments[i].second;\n        bool is_nailed = false;\n        for (int nail : nails) {\n            if (nail >= l && nail <= r) {\n                is_nailed = true;\n                break;\n            }\n        }\n        if (!is_nailed) {\n            quitf(_wa, \"Segment [%d, %d] is not nailed\", l, r);\n        }\n    }\n\n    // If all segments are nailed and the number of nails is minimal\n    quitf(_ok, \"Correct answer with %d nails\", participant_k);\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    printf(\"%d\\n\", n);\n\n    if (type == \"random\") {\n        // Generate n random segments\n        for (int i = 0; i < n; ++i) {\n            int L = rnd.next(-10000, 10000);\n            int R = rnd.next(-10000, 10000);\n            printf(\"%d %d\\n\", L, R);\n        }\n    } else if (type == \"overlap\") {\n        // Generate n segments that all overlap at a point x0\n        int x0 = rnd.next(-10000, 10000);\n        for (int i = 0; i < n; ++i) {\n            int L = rnd.next(x0 - 10000, x0);\n            int R = rnd.next(x0, x0 + 10000);\n            // Optionally randomize order of L and R\n            if (rnd.next(2)) swap(L, R);\n            printf(\"%d %d\\n\", L, R);\n        }\n    } else if (type == \"nonoverlap\") {\n        // Generate n segments that do not overlap\n        int start = -10000;\n        int segment_length = 1;\n        int increment = 20;\n        for (int i = 0; i < n; ++i) {\n            int L = start;\n            int R = start + segment_length - 1;\n            start += increment;\n            if (rnd.next(2)) swap(L, R);\n            printf(\"%d %d\\n\", L, R);\n        }\n    } else if (type == \"points\") {\n        // Generate n segments that are points (L_i == R_i)\n        for (int i = 0; i < n; ++i) {\n            int x = rnd.next(-10000, 10000);\n            printf(\"%d %d\\n\", x, x);\n        }\n    } else if (type == \"reverse\") {\n        // Generate segments where L_i > R_i\n        for (int i = 0; i < n; ++i) {\n            int L = rnd.next(-10000, 10000);\n            int R = rnd.next(-10000, 10000);\n            if (L <= R) swap(L, R); // Ensure L > R\n            printf(\"%d %d\\n\", L, R);\n        }\n    } else if (type == \"maxcoords\") {\n        // Generate segments with endpoints near the maximum coordinate\n        for (int i = 0; i < n; ++i) {\n            int L = rnd.next(9990, 10000);\n            int R = rnd.next(9990, 10000);\n            if (rnd.next(2)) swap(L, R);\n            printf(\"%d %d\\n\", L, R);\n        }\n    } else if (type == \"mincoords\") {\n        // Generate segments with endpoints near the minimum coordinate\n        for (int i = 0; i < n; ++i) {\n            int L = rnd.next(-10000, -9990);\n            int R = rnd.next(-10000, -9990);\n            if (rnd.next(2)) swap(L, R);\n            printf(\"%d %d\\n\", L, R);\n        }\n    } else if (type == \"mixed\") {\n        // Generate a mixture of different types\n        for (int i = 0; i < n; ++i) {\n            int t = rnd.next(1, 6);\n            if (t == 1) {\n                // random segment\n                int L = rnd.next(-10000, 10000);\n                int R = rnd.next(-10000, 10000);\n                printf(\"%d %d\\n\", L, R);\n            } else if (t == 2) {\n                // overlap at x0\n                int x0 = rnd.next(-10000, 10000);\n                int L = rnd.next(x0 - 10, x0);\n                int R = rnd.next(x0, x0 + 10);\n                printf(\"%d %d\\n\", L, R);\n            } else if (t == 3) {\n                // nonoverlap\n                int L = i * 20 - 10000;\n                int R = L + rnd.next(1);\n                printf(\"%d %d\\n\", L, R);\n            } else if (t == 4) {\n                // point segment\n                int x = rnd.next(-10000, 10000);\n                printf(\"%d %d\\n\", x, x);\n            } else if (t == 5) {\n                // reverse segment\n                int L = rnd.next(-10000, 10000);\n                int R = rnd.next(-10000, 10000);\n                if (L < R) swap(L, R);\n                printf(\"%d %d\\n\", L, R);\n            } else {\n                // maxcoords\n                int L = rnd.next(9990, 10000);\n                int R = rnd.next(9990, 10000);\n                printf(\"%d %d\\n\", L, R);\n            }\n        }\n    } else {\n        // Default to random if unknown type\n        for (int i = 0; i < n; ++i) {\n            int L = rnd.next(-10000, 10000);\n            int R = rnd.next(-10000, 10000);\n            printf(\"%d %d\\n\", L, R);\n        }\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    printf(\"%d\\n\", n);\n\n    if (type == \"random\") {\n        // Generate n random segments\n        for (int i = 0; i < n; ++i) {\n            int L = rnd.next(-10000, 10000);\n            int R = rnd.next(-10000, 10000);\n            printf(\"%d %d\\n\", L, R);\n        }\n    } else if (type == \"overlap\") {\n        // Generate n segments that all overlap at a point x0\n        int x0 = rnd.next(-10000, 10000);\n        for (int i = 0; i < n; ++i) {\n            int L = rnd.next(x0 - 10000, x0);\n            int R = rnd.next(x0, x0 + 10000);\n            // Optionally randomize order of L and R\n            if (rnd.next(2)) swap(L, R);\n            printf(\"%d %d\\n\", L, R);\n        }\n    } else if (type == \"nonoverlap\") {\n        // Generate n segments that do not overlap\n        int start = -10000;\n        int segment_length = 1;\n        int increment = 20;\n        for (int i = 0; i < n; ++i) {\n            int L = start;\n            int R = start + segment_length - 1;\n            start += increment;\n            if (rnd.next(2)) swap(L, R);\n            printf(\"%d %d\\n\", L, R);\n        }\n    } else if (type == \"points\") {\n        // Generate n segments that are points (L_i == R_i)\n        for (int i = 0; i < n; ++i) {\n            int x = rnd.next(-10000, 10000);\n            printf(\"%d %d\\n\", x, x);\n        }\n    } else if (type == \"reverse\") {\n        // Generate segments where L_i > R_i\n        for (int i = 0; i < n; ++i) {\n            int L = rnd.next(-10000, 10000);\n            int R = rnd.next(-10000, 10000);\n            if (L <= R) swap(L, R); // Ensure L > R\n            printf(\"%d %d\\n\", L, R);\n        }\n    } else if (type == \"maxcoords\") {\n        // Generate segments with endpoints near the maximum coordinate\n        for (int i = 0; i < n; ++i) {\n            int L = rnd.next(9990, 10000);\n            int R = rnd.next(9990, 10000);\n            if (rnd.next(2)) swap(L, R);\n            printf(\"%d %d\\n\", L, R);\n        }\n    } else if (type == \"mincoords\") {\n        // Generate segments with endpoints near the minimum coordinate\n        for (int i = 0; i < n; ++i) {\n            int L = rnd.next(-10000, -9990);\n            int R = rnd.next(-10000, -9990);\n            if (rnd.next(2)) swap(L, R);\n            printf(\"%d %d\\n\", L, R);\n        }\n    } else if (type == \"mixed\") {\n        // Generate a mixture of different types\n        for (int i = 0; i < n; ++i) {\n            int t = rnd.next(1, 6);\n            if (t == 1) {\n                // random segment\n                int L = rnd.next(-10000, 10000);\n                int R = rnd.next(-10000, 10000);\n                printf(\"%d %d\\n\", L, R);\n            } else if (t == 2) {\n                // overlap at x0\n                int x0 = rnd.next(-10000, 10000);\n                int L = rnd.next(x0 - 10, x0);\n                int R = rnd.next(x0, x0 + 10);\n                printf(\"%d %d\\n\", L, R);\n            } else if (t == 3) {\n                // nonoverlap\n                int L = i * 20 - 10000;\n                int R = L + rnd.next(1);\n                printf(\"%d %d\\n\", L, R);\n            } else if (t == 4) {\n                // point segment\n                int x = rnd.next(-10000, 10000);\n                printf(\"%d %d\\n\", x, x);\n            } else if (t == 5) {\n                // reverse segment\n                int L = rnd.next(-10000, 10000);\n                int R = rnd.next(-10000, 10000);\n                if (L < R) swap(L, R);\n                printf(\"%d %d\\n\", L, R);\n            } else {\n                // maxcoords\n                int L = rnd.next(9990, 10000);\n                int R = rnd.next(9990, 10000);\n                printf(\"%d %d\\n\", L, R);\n            }\n        }\n    } else {\n        // Default to random if unknown type\n        for (int i = 0; i < n; ++i) {\n            int L = rnd.next(-10000, 10000);\n            int R = rnd.next(-10000, 10000);\n            printf(\"%d %d\\n\", L, R);\n        }\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -type random\n./gen -n 1 -type overlap\n./gen -n 1 -type nonoverlap\n./gen -n 1 -type points\n./gen -n 1 -type reverse\n./gen -n 1 -type maxcoords\n./gen -n 1 -type mincoords\n./gen -n 1 -type mixed\n\n./gen -n 10 -type random\n./gen -n 10 -type overlap\n./gen -n 10 -type nonoverlap\n./gen -n 10 -type points\n./gen -n 10 -type reverse\n./gen -n 10 -type maxcoords\n./gen -n 10 -type mincoords\n./gen -n 10 -type mixed\n\n./gen -n 100 -type random\n./gen -n 100 -type overlap\n./gen -n 100 -type nonoverlap\n./gen -n 100 -type points\n./gen -n 100 -type reverse\n./gen -n 100 -type maxcoords\n./gen -n 100 -type mincoords\n./gen -n 100 -type mixed\n\n./gen -n 1000 -type random\n./gen -n 1000 -type overlap\n./gen -n 1000 -type nonoverlap\n./gen -n 1000 -type points\n./gen -n 1000 -type reverse\n./gen -n 1000 -type maxcoords\n./gen -n 1000 -type mincoords\n./gen -n 1000 -type mixed\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T19:50:47.315340",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "22/E",
      "title": "E. Схема",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест2 seconds",
      "memory_limit": "ограничение по памяти на тест256 megabytes",
      "input_spec": "Входные данныеВ первой строке входных данных записано число n (2 ≤ n ≤ 105) — количество участников BolgenOS community Нижнего Тагила. Во второй строке через пробел записано n целых чисел fi (1 ≤ fi ≤ n, i ≠ fi) — номер человека, которому звонит человек с номером i.",
      "output_spec": "Выходные данныеВ первую строку выходных данных выведите одно число — какое наименьшее число указаний нужно добавить. Далее выведите один из возможных вариантов добавления этих указаний в схему, по одному указанию в строке. Если решений несколько, выведите любое.",
      "sample_tests": "ПримерыВходные данныеСкопировать33 3 2Выходные данныеСкопировать13 1Входные данныеСкопировать72 3 1 3 4 4 1Выходные данныеСкопировать32 52 63 7",
      "description": "ограничение по времени на тест2 seconds\n\nограничение по времени на тест\n\nограничение по памяти на тест256 megabytes\n\nограничение по памяти на тест\n\nвыводstdout\n\nВходные данныеВ первой строке входных данных записано число n (2 ≤ n ≤ 105) — количество участников BolgenOS community Нижнего Тагила. Во второй строке через пробел записано n целых чисел fi (1 ≤ fi ≤ n, i ≠ fi) — номер человека, которому звонит человек с номером i.\n\nВходные данные\n\nВыходные данныеВ первую строку выходных данных выведите одно число — какое наименьшее число указаний нужно добавить. Далее выведите один из возможных вариантов добавления этих указаний в схему, по одному указанию в строке. Если решений несколько, выведите любое.\n\nВыходные данные\n\nВходные данныеСкопировать33 3 2Выходные данныеСкопировать13 1Входные данныеСкопировать72 3 1 3 4 4 1Выходные данныеСкопировать32 52 63 7\n\nВходные данныеСкопировать33 3 2\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать13 1\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать72 3 1 3 4 4 1\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать32 52 63 7\n\nВыходные данныеСкопировать\n\nСкопировать",
      "solutions": [
        {
          "title": "Codeforces Beta Round #22 (Див. 2) - Codeforces",
          "content": "Приветствую всех на Codeforces Beta Round #22 Обратите внимание, что на этот раз регистрация возможна в течение всего раунда. Сам раунд начнется в 19:00 по Москве. Автором задач этого контеста буду я. Большое спасибо Михаилу Мирзаянову за помощь в подготовке контеста, Эдварду Давтяну и Николаю Кузнецову за написание проверочных решений, и Юлии Сатушиной за перевод условий на английский. Удачи на раунде! UPD: Контест окончен. Всем спасибо за участие! Задачи Результаты Победитель Kasparyanm_Mihail получает за контест +203 к рейтингу!",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/505",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.5,
            "reason": "宽松匹配: 包含题目编号 22"
          },
          "content_length": 537
        },
        {
          "title": "Разбор задач Codeforces Beta Round #22 - Codeforces",
          "content": "Обсуждение контестаЗадача А. Вторая порядковая статистикаТематика: СортировкаВ задаче требовалось найти минимальный из всех элементов заданной последовательности, которые строго больше минимального во всей последовательности или сообщить, что его не существует. Разумеется, решений может быть очень много, но один из самых простых способов - считать всю последовательность в массив, отсортировать его и вывести первый элемент, не совпадающий с предыдущим. Если все элементы одинаковы, значит второго по величине не существует. Задача B. Стол для переговоровТематика: Симуляция, динамическое программированиеВ этой задаче требовалось определить максимальный периметр прямогульника, который не содержит внутри себя единиц. Назовем прямоугольники, не содержащие единиц, допустимыми. Для решения надо было просмотреть все допустимые прямоугольники и выбрать максимальный периметр. Вопрос в том, как перебирать все допустимые прямоугольники. Говорят, что решение \"в лоб\" с помощью 6 вложенных циклов за 256 проходит по времени. Очевидно, четыремя циклами мы фиксируем углы прямоугольника, а еще двумя проверяем его допустимость. Не совсем очевидно, что такое решение уложится по времени.Можно было написать более аккуратное решение с помощью динамического программирования за O((n*m)2). Заметим, что прямоугольник с координатами (x1, y1, x2, y2) является допустимым тогда и только тогда, когда допустимыми явлюятся прямоугольники (x1, y1, x2-1, y2), (x1, y1, x2, y2-1) и в клетке (x2, y2) стоит '0'. Таким образом, пересчет допустимости производится за O(1), что суммарно будет происходить за время O((n*m)2), т.е. линейное от количества прямоугольников. Задача C. Системный администраторТематика: СимуляцияВ этой задаче требовалось составить связный граф из n вершин, содержащего m ребер, такой, что при удалении вершины v граф перестанет быть связным или сообщить, что такой граф не существует. При этом не должно быть кратных ребер. Очевидно, что связный граф не может существовать, если число ребер меньше, чем n-1. Кроме того, нетрудно видеть, что максимальное число ребер достигается, когда по одну стороны от v находится одна вершина, а по другую - полный граф из оставшихся вершин. Это число равно (n-1)*(n-2)/2+1. Если число ребер лежит в допустимом диапазоне - граф всегда существует. Дальше нужно было аккуратно разместить одну вершину по одну сторону от v (пусть это вершина 1), а с другой стороны построить связный граф с m-1 ребром. Лучше всего это было сделать проведя сначала ребра из v во все остальные, кроме 1, а затем между всеми остальными (кроме 1).Задача D. ОтрезкиТематика: Метод сканирующей прямойВ этой задаче требовалось вбить наименьшее число гвоздиков в отрезки так, чтобы каждый отрезок касался хотя бы одного гвоздика. Назовем координату конца отрезка событием. Наши события будут двух типов: начало отрезка и конец отрезка. Отсортируем события в порядке возрастания координат. В случае равенства координат раньше будут идти события начала отрезка. Теперь будем смотреть события в соответствии с заданным порядком: если встретили начало отрезка, добавим его номер в список необработанных отрезков. Как только встретили событие конца отрезка, который еще не обработан, вбиваем туда гвоздь и очищаем список (т.е. считаем, что все отрезки из списка обработаны, т.е. прибиты).Задача E. СхемаТематика: Теория графовВ задаче E дан ориентированный граф, требовалось сделать его сильно связным, т.е. чтобы каждая вершина была достижима из любой другой, добавив минимальное число ребер. Из формата входных данных неявно следует очень важное условие: у любой вершины есть не более одного исходящего ребра. Значит, начав путь из некоторой вершины мы либо зациклимся, либо нам некуда будет идти. Отсюда следует, что любая компонента связности (обычной) имеет вид либо замкнутого цикла, либо несколько простых путей, входящих в вершину или цикл. Сначала рассмотрим все пути, выходящие из вершин, у которых нет входящих ребер. Проходя, будем красить вершины, пока либо нам некуда будет идти, либо придем в покрашенную вершину. Тогда вершина, из которой мы пошли, будет называться началом, а в которую пришли - концом компоненты. После этого рассмотрим еще непокрашенные вершины - они точно принадлежат циклам. Началом и концом цикла назовем некоторую вершину, ему принадлежащую. Получили набор компонент, которые надо соединить. Будем соединять циклически: из конца i-й компоненты пустим ребро в начало ((i+1)%k)-й, где k - число компонент. Ответом будет k. Здесь есть исключение: если у нас только одна компонента, формирующая цикл, то ответ 0.Таким образом каждое ребро мы просмотрим один раз и время работы составит O(n).Upd: В задаче E у любой вершины есть исходящее ребро, поэтому нам всегда есть, куда идти, и любая компонента заканчивается циклом.Говорят, что в задаче B решение с шестью вложенными циклами работает за 30 мс, т.е. с ним нет никаких проблем.",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/507",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 4876
        }
      ],
      "code_examples": [
        {
          "title": "Разбор задач Codeforces Beta Round #22 - Codeforces - Code 1",
          "code": "if (--m <= 0) return;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/507",
          "author": "Qingyu"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(2, 100000, \"n\");\n    inf.readEoln();\n\n    vector<int> f = inf.readInts(n, 1, n, \"f_i\");\n    inf.readEoln();\n\n    for (int i = 0; i < n; i++) {\n        ensuref(f[i] != i + 1, \"f[%d] should not be equal to %d\", i + 1, i + 1);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(2, 100000, \"n\");\n    inf.readEoln();\n\n    vector<int> f = inf.readInts(n, 1, n, \"f_i\");\n    inf.readEoln();\n\n    for (int i = 0; i < n; i++) {\n        ensuref(f[i] != i + 1, \"f[%d] should not be equal to %d\", i + 1, i + 1);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(2, 100000, \"n\");\n    inf.readEoln();\n\n    vector<int> f = inf.readInts(n, 1, n, \"f_i\");\n    inf.readEoln();\n\n    for (int i = 0; i < n; i++) {\n        ensuref(f[i] != i + 1, \"f[%d] should not be equal to %d\", i + 1, i + 1);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint n, jMin;\nvector<int> fi;\n\nint main(int argc, char* argv[]) {\n    registerTestlibCmd(argc, argv);\n\n    // Read input from inf\n    n = inf.readInt(2, 100000, \"n\");\n    fi.resize(n + 1); // 1-indexed\n    for (int i = 1; i <= n; ++i) {\n        fi[i] = inf.readInt(1, n, format(\"fi[%d]\", i).c_str());\n        if (fi[i] == i) {\n            inf.quitf(_fail, \"Invalid value: fi[%d] == %d, but should be different\", i, fi[i]);\n        }\n    }\n\n    // Read judge's answer (ans)\n    jMin = ans.readInt(0, n, \"judge's minimal number of instructions\");\n    ans.readEoln();\n\n    // Read participant's answer (ouf)\n    int pMin = ouf.readInt(0, n, \"participant's number of instructions\");\n    ouf.readEoln();\n\n    if (pMin < jMin)\n        quitf(_fail, \"Participant's solution uses fewer instructions (%d) than the minimal number (%d) provided by the judge\", pMin, jMin);\n    else if (pMin > jMin)\n        quitf(_wa, \"Participant's solution uses more instructions (%d) than the minimal number (%d)\", pMin, jMin);\n\n    // Read participant's added instructions\n    set<pair<int, int>> addedEdges;\n    for (int i = 0; i < pMin; ++i) {\n        int xi = ouf.readInt(1, n, format(\"xi at line %d\", i + 2).c_str());\n        int yi = ouf.readInt(1, n, format(\"yi at line %d\", i + 2).c_str());\n        ouf.readEoln();\n        if (xi == yi) {\n            ouf.quitf(_wa, \"Instruction at line %d is invalid because xi == yi (%d)\", i + 2, xi);\n        }\n        if (addedEdges.count({xi, yi})) {\n            ouf.quitf(_wa, \"Duplicate instruction (%d, %d) at line %d\", xi, yi, i + 2);\n        }\n        addedEdges.insert({xi, yi});\n    }\n\n    // Build the communication graph\n    vector<vector<int>> adj(n + 1);\n    for (int i = 1; i <= n; ++i) {\n        adj[i].push_back(fi[i]);\n    }\n    for (const auto& edge : addedEdges) {\n        adj[edge.first].push_back(edge.second);\n    }\n\n    // Check if the graph is strongly connected using Kosaraju's algorithm\n    vector<bool> visited(n + 1, false);\n    vector<int> order;\n\n    // First DFS to compute finishing times\n    function<void(int)> dfs1 = [&](int v) {\n        visited[v] = true;\n        for (int u : adj[v]) {\n            if (!visited[u]) {\n                dfs1(u);\n            }\n        }\n        order.push_back(v);\n    };\n\n    for (int v = 1; v <= n; ++v) {\n        if (!visited[v]) {\n            dfs1(v);\n        }\n    }\n\n    // Build reverse graph\n    vector<vector<int>> radj(n + 1);\n    for (int v = 1; v <= n; ++v) {\n        for (int u : adj[v]) {\n            radj[u].push_back(v);\n        }\n    }\n\n    // Second DFS on reverse graph in order of decreasing finishing times\n    fill(visited.begin(), visited.end(), false);\n    int sccCount = 0;\n\n    function<void(int)> dfs2 = [&](int v) {\n        visited[v] = true;\n        for (int u : radj[v]) {\n            if (!visited[u]) {\n                dfs2(u);\n            }\n        }\n    };\n\n    reverse(order.begin(), order.end());\n    for (int v : order) {\n        if (!visited[v]) {\n            ++sccCount;\n            dfs2(v);\n        }\n    }\n\n    if (sccCount == 1) {\n        quitf(_ok, \"Correct solution with minimal number of instructions %d\", pMin);\n    } else {\n        quitf(_wa, \"Graph is not strongly connected after adding instructions, number of strongly connected components is %d\", sccCount);\n    }\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n    int m = opt<int>(\"m\", 2);\n\n    vector<int> fi(n);\n\n    if (type == \"sc\") {\n        // Strongly connected (cycle)\n        for (int i = 0; i < n; ++i)\n            fi[i] = (i+1)%n;\n    } else if (type == \"chain\") {\n        // Chain\n        for (int i = 0; i < n; ++i)\n        {\n            if (i < n -1)\n                fi[i] = i+1;\n            else\n                fi[i] = 0;\n        }\n    } else if (type == \"star\") {\n        // Star topology\n        int c = 0; // central node\n        for (int i = 0; i < n; ++i)\n        {\n            if (i != c)\n                fi[i] = c;\n            else\n                fi[i] = (c+1)%n;\n        }\n    } else if (type == \"dc\") {\n        // Disconnected components\n        m = min(m, n);\n        vector<int> comp_sizes(m, n / m);\n        for (int i = 0; i < n % m; ++i)\n            comp_sizes[i]++;\n        int idx = 0;\n        for (int c = 0; c < m; ++c)\n        {\n            int sz = comp_sizes[c];\n            for (int i = 0; i < sz; ++i)\n            {\n                int u = idx + i;\n                int v = idx + (i+1)%sz;\n                fi[u] = v;\n                if (fi[u] == u)\n                    fi[u] = idx + (i+2)%sz;\n            }\n            idx += sz;\n        }\n    } else if (type == \"random\") {\n        // Random fi[i] ≠ i\n        for (int i = 0; i < n; ++i)\n            fi[i] = i;\n        for (int i = 0; i < n; ++i)\n        {\n            int x = rnd.next(0, n -1);\n            swap(fi[i], fi[x]);\n        }\n        for (int i = 0; i < n; ++i)\n            if (fi[i] == i)\n            {\n                int j = (i+1)%n;\n                swap(fi[i], fi[j]);\n            }\n    } else {\n        // Default to \"random\" if unknown type\n        for (int i = 0; i < n; ++i)\n            fi[i] = i;\n        for (int i = 0; i < n; ++i)\n        {\n            int x = rnd.next(0, n -1);\n            swap(fi[i], fi[x]);\n        }\n        for (int i = 0; i < n; ++i)\n            if (fi[i] == i)\n            {\n                int j = (i+1)%n;\n                swap(fi[i], fi[j]);\n            }\n    }\n\n    // Output n\n    printf(\"%d\\n\", n);\n    // Output fi[0..n-1], adjusted to 1-based indices\n    for (int i = 0; i < n; ++i)\n        printf(\"%d%c\", fi[i]+1, \" \\n\"[i == n-1]);\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n    int m = opt<int>(\"m\", 2);\n\n    vector<int> fi(n);\n\n    if (type == \"sc\") {\n        // Strongly connected (cycle)\n        for (int i = 0; i < n; ++i)\n            fi[i] = (i+1)%n;\n    } else if (type == \"chain\") {\n        // Chain\n        for (int i = 0; i < n; ++i)\n        {\n            if (i < n -1)\n                fi[i] = i+1;\n            else\n                fi[i] = 0;\n        }\n    } else if (type == \"star\") {\n        // Star topology\n        int c = 0; // central node\n        for (int i = 0; i < n; ++i)\n        {\n            if (i != c)\n                fi[i] = c;\n            else\n                fi[i] = (c+1)%n;\n        }\n    } else if (type == \"dc\") {\n        // Disconnected components\n        m = min(m, n);\n        vector<int> comp_sizes(m, n / m);\n        for (int i = 0; i < n % m; ++i)\n            comp_sizes[i]++;\n        int idx = 0;\n        for (int c = 0; c < m; ++c)\n        {\n            int sz = comp_sizes[c];\n            for (int i = 0; i < sz; ++i)\n            {\n                int u = idx + i;\n                int v = idx + (i+1)%sz;\n                fi[u] = v;\n                if (fi[u] == u)\n                    fi[u] = idx + (i+2)%sz;\n            }\n            idx += sz;\n        }\n    } else if (type == \"random\") {\n        // Random fi[i] ≠ i\n        for (int i = 0; i < n; ++i)\n            fi[i] = i;\n        for (int i = 0; i < n; ++i)\n        {\n            int x = rnd.next(0, n -1);\n            swap(fi[i], fi[x]);\n        }\n        for (int i = 0; i < n; ++i)\n            if (fi[i] == i)\n            {\n                int j = (i+1)%n;\n                swap(fi[i], fi[j]);\n            }\n    } else {\n        // Default to \"random\" if unknown type\n        for (int i = 0; i < n; ++i)\n            fi[i] = i;\n        for (int i = 0; i < n; ++i)\n        {\n            int x = rnd.next(0, n -1);\n            swap(fi[i], fi[x]);\n        }\n        for (int i = 0; i < n; ++i)\n            if (fi[i] == i)\n            {\n                int j = (i+1)%n;\n                swap(fi[i], fi[j]);\n            }\n    }\n\n    // Output n\n    printf(\"%d\\n\", n);\n    // Output fi[0..n-1], adjusted to 1-based indices\n    for (int i = 0; i < n; ++i)\n        printf(\"%d%c\", fi[i]+1, \" \\n\"[i == n-1]);\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 3 -type sc\n./gen -n 3 -type chain\n./gen -n 3 -type star\n./gen -n 3 -type dc -m 2\n./gen -n 3 -type random\n\n./gen -n 10 -type sc\n./gen -n 10 -type chain\n./gen -n 10 -type star\n./gen -n 10 -type dc -m 2\n./gen -n 10 -type dc -m 3\n./gen -n 10 -type random\n\n./gen -n 100 -type sc\n./gen -n 100 -type chain\n./gen -n 100 -type star\n./gen -n 100 -type dc -m 5\n./gen -n 100 -type dc -m 10\n./gen -n 100 -type random\n\n./gen -n 1000 -type sc\n./gen -n 1000 -type chain\n./gen -n 1000 -type star\n./gen -n 1000 -type dc -m 20\n./gen -n 1000 -type dc -m 50\n./gen -n 1000 -type random\n\n./gen -n 100000 -type sc\n./gen -n 100000 -type chain\n./gen -n 100000 -type star\n./gen -n 100000 -type dc -m 100\n./gen -n 100000 -type dc -m 1000\n./gen -n 100000 -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T19:50:49.543551",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "220/A",
      "title": "A. Маленький Слоник и проблема",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест2 секунды",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеВ первой строке задано единственное целое число n (2 ≤ n ≤ 105) — размер массива a. В следующей строке заданы n целых положительных чисел, разделенных единичными пробелами и не превосходящих 109, — массив a.Обратите внимание, что элементы массива не обязательно различные числа.",
      "output_spec": "Выходные данныеВ единственной строке выведите «YES» (без кавычек), если Маленький Слоник мог сам случайно изменить массив, и «NO» (без кавычек) в противоположном случае.",
      "sample_tests": "ПримерыВходные данныеСкопировать21 2Выходные данныеСкопироватьYESВходные данныеСкопировать33 2 1Выходные данныеСкопироватьYESВходные данныеСкопировать44 3 2 1Выходные данныеСкопироватьNO",
      "description": "A. Маленький Слоник и проблема\n\nограничение по времени на тест2 секунды\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвыводstdout\n\nВходные данныеВ первой строке задано единственное целое число n (2 ≤ n ≤ 105) — размер массива a. В следующей строке заданы n целых положительных чисел, разделенных единичными пробелами и не превосходящих 109, — массив a.Обратите внимание, что элементы массива не обязательно различные числа.\n\nВходные данные\n\nВыходные данныеВ единственной строке выведите «YES» (без кавычек), если Маленький Слоник мог сам случайно изменить массив, и «NO» (без кавычек) в противоположном случае.\n\nВыходные данные\n\nВходные данныеСкопировать21 2Выходные данныеСкопироватьYESВходные данныеСкопировать33 2 1Выходные данныеСкопироватьYESВходные данныеСкопировать44 3 2 1Выходные данныеСкопироватьNO\n\nВходные данныеСкопировать21 2\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопироватьYES\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать33 2 1\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопироватьYES\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать44 3 2 1\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопироватьNO\n\nВыходные данныеСкопировать\n\nСкопировать\n\nПримечаниеВ первом примере массив уже отсортирован, поэтому для его сортировки требуется 0 операций обмена, что не больше чем 1. Таким образом ответ «YES».Во втором примере массив можно отсортировать, поменяв элементы 1 и 3 местами, поэтому для его сортировки требуется 1 операция обмена. Таким образом ответ «YES».В третьем примере массив нельзя отсортировать за не более чем одну операцию обмена, поэтому ответ «NO».",
      "solutions": [
        {
          "title": "Codeforces Round #136 - Codeforces",
          "content": "Завтра, 31-го августа, за 4 с половиной часа до конца лета (по Москве) будет проходить Codeforces Round #136. Автором этого контеста буду я, это уже мой 6-й контест на CF.Помогает строить раунд мне Геральд Агапов (Gerald), задачи переведет, как я предполагаю, Мария Белова (Delinur). Спасибо всем.Надеюсь, вам понравится раунд. Разбалловка стандартная.Спасибо за участие. К сожалению, большинство моих контестов не пользуются особым интересом, судя по системе \"Вклад\", но надеюсь все-таки нашлись те, кому он понравился :)В первом дивизионе ровно 7 участников решили все задачи, они и попадут на главную: peter50216 yeputons winger rng_58 RAD al13n KADR В то время Топ-4 во втором дивизионе выглядит следующим образом: blue.boy de_troit lxyxynt ilona На данный момент есть только разбор на английском.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/5167",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 801
        },
        {
          "title": "Codeforces Round #136 — Разбор - Codeforces",
          "content": "221A - Маленький Слоник и функцияВ этой задаче все что нужно заметить это то, что ответ всегда имеет следующею форму: n, 1, 2, 3, ..., n-1. При такой перестановке не трудно заметить, что после полого выполнения алгоритма перестановка будет отсортирована.221B - Маленький Слоник и числаНужно найти все делители числа n. Это можно сделать простым перебором от 1 до sqrt(n). После этого нужно написать функцию, которая умеет определять, существуют ли две одинаковые цифры в паре чисел. Это тоже можно сделать простым перебором по цифрам.220A - Маленький Слоник и проблемаСуществует несколько решений этой задачи. Например, можно найти максимальное x такое, что существует y (минимальное возможное) такое, что (y < x) и Ax < Ay. После этого остается проверить ровно два варианты — либо менять местами x-е и y-е числа, либо не делать ничего.220B - Маленький Слоник и массивЗадачу можно решить за O(NsqrtN), но я опишу решение за O(NlogN).Будем решать задачу в оффлайне, тоесть сначала считаем все запросы, а потом будем давать ответы. Для каждого x (0 ≤ x n) мы должны держать все запросы, концами которых есть x. Будем перебирать x от 0 до n - 1. Также нам нужно поддерживать массив чисел D такой, что для текущего x ответом на запрос [l;x] будет число Dl + Dl + 1 + ... + Dr. Для правильной поддержки массива, перед тем как обрабатывать запросы для текущего x, нудно обновить D. Пусть t — текущее число, тоесть Ax, а вектор P — список индексов всех вхождений числа t (до позиции x), нумерация с 0. Тогда, если |P| ≥ t, нам нужно добавить 1 до DP[|P| - t], так как эта позиция теперь переломной — после нее будет не меньше чем t вхождений числа t. Потом, если |P| > t, нужно отнять 2 от DP[|P| - t - 1], для того что-бы закрыть текущий интервал (после этой позиции количество вхождений t будет превосходить t), а также отменить предыдущий. И наконец, если |P| > t + 1, нужно еще добавить 1 к DP[|P| - t - 2] для того что-бы отменить закрытие предыдущего интервала.220C - Маленький Слоник и сдвигиEach of the shifts can be divided into two parts — the right (the one that starts from occurrence 1) and the left (the rest of the elements). If we could keep minimal distance for each part, the minimal of these numbers will be the answers for the corresponding shift. Lets solve the problems of the right part, the left will be almost the same.Let we have some shift, for example 34567[12] and the permutation A is 4312765 and B is 2145673, then shifted B is 4567321. Let we keep two sets (S1 and S2). The first will keep all the distances from integers in current left part to the corresponding positions in A (for the example above, it is [2, 4]). When you come to the next shift, all integers in S1 should be decreased by 1 (that is because all distances are also decreased by 1). But now some integers in set may be negative, when any negative integer occures (it always will be -1) you need to delete it from S1 and put 1 to the S2. Also after shifting to the next shifts, all integers in S2 must be increase by 1. After that, for any shift, the answer will be minimum from the smallest numbers in S1 and S2.It was very useful to use standart \"set\" in C++.220D - Маленький Слоник и треугольникДавайте переберем все возможные точки нашей плоскости и предположим что это первая точка тройки. Пусть это будет точка (x;y). Пусть вторая и третья точки это (x1;y1) и (x2;y2). Тогда удвоенная площадь равна |(x1 - x)(y2 - y) - (x2 - x)(y1 - y)|. Нам нужно что-бы это число было четным, а также ненулевым. Для начала найдем количество троек, которые образуют четную площадь, а потом отнимем количество точек с нулевой площадью. Первая подзадача. Так как мы знаем x и y и нам нужно проверить четность, давайте еще переберем все возможные 24 варианты четности x1, y1, x2 и y2 (пусть это d0, d1, d2 и d3, соответственно). Потом проверим будет ли такая тройка чисел формировать 0 после подстановки в формулу площади и взятии по модулю 2. Если это так, тогда нужно добавит к ответу число cxd0cyd1cxd2cyd3, где cxd равно количеству целых чисел в промежутке [0..n] таких, что они по модулю 2 равны d. Аналогично для cyd, только в промежутке [0..m].Теперь нужно отнять плохие тройки — такие, что треугольник, который они создают, имеет нулевую площадь. Это значит, что тройка точек формирует отрезок (или точку). Так как это отрезок, давайте переберем dx = |x1 - x2| и dy = |y1 - y2|, вместо перебора всех 4 координат. Количество таких отрезков на плоскости равно (n - dx + 1)(m - dy + 1). Также для подсчета количества троек, что формируют такой отрезок, нужно искать количество точек с целыми координатами на плоскости, которые лежат на этом отрезке. Это известная задача — это количество равно gcd(dx, dy) + 1.Это дает нам, с еще некоторыми оптимизациями, решение за O(nm).220E - Маленький Слоник, а также инверсииВ этой задачи нужно использовать метод двух указателей. Также нужно использовать RMQ. Если вы не знакомы со структурой данных RMQ, почитать о нем можно здесь.Для начала, уменьшим все числа, не меняя их относительное значения, тогда все числа будут в переделе от 0 до n - 1. Нужно поддерживать два RMQ, каждое размером n. Пусть первое RMQ это Q1, а второе — Q2. Q1i будет содержать количество чисел i в текущему левом подмассиве, а Q2i — в правом. Для начала нужно добавить все n чисел в левое RMQ. После этого будем идти указателем r от n - 1 до 1, при этом поддерживая l — максимальный индекс такой, что пара (l;r) содержит не более чем k инверсий (в начале l равно n - 1). Количество инверсий, очевидно, нужно поддерживать, используя RMQ (используя операцию \"сумма на отрезке\"). В такой реализации время выполнения алгоритма равно O(NlogN).",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/5177",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 220\\s*A"
          },
          "content_length": 5641
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #136 - Codeforces - Code 1",
          "code": "1)how to solve C help me please",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5167",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #136 - Codeforces - Code 2",
          "code": "2)it won't do harm for your rating. just + for me....",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5167",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #136 - Codeforces - Code 3",
          "code": "1)it won't be your really rating.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5167",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #136 - Codeforces - Code 4",
          "code": "2)it will affect to others rating.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5167",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #136 - Codeforces - Code 5",
          "code": "3)do you really want to practice ComputerProgramming?",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5167",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #136 - Codeforces - Code 6",
          "code": "100000 100000\n413 212 432 39 177 169 ...",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5167",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #136 - Codeforces - Code 7",
          "code": "100000 100000\n362 328 428 153 323 415 ...",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5167",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #136 - Codeforces - Code 8",
          "code": "362 328 428 153 ...",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5167",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #136 - Codeforces - Code 9",
          "code": "250 302 154 91 381 407 ...",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5167",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(2, 100000, \"n\");\n    inf.readEoln();\n    vector<int> a = inf.readInts(n, 1, 1000000000, \"a_i\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(2, 100000, \"n\");\n    inf.readEoln();\n    vector<int> a = inf.readInts(n, 1, 1000000000, \"a_i\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(2, 100000, \"n\");\n    inf.readEoln();\n    vector<int> a = inf.readInts(n, 1, 1000000000, \"a_i\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n#include <string>\r\n\r\nusing namespace std;\r\n\r\nconst string YES = \"YES\";\r\nconst string NO = \"NO\";\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"%s\", (\"multiple \" + YES + \"/\" + NO + \" (case insensitive)\").c_str());\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int index = 0, yesCount = 0, noCount = 0;\r\n    string pa;\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        index++;\r\n        string ja = upperCase(ans.readToken());\r\n        pa = upperCase(ouf.readToken());\r\n\r\n        if (ja != YES && ja != NO)\r\n            quitf(_fail, \"%s or %s expected in answer, but %s found [%d%s token]\",\r\n                  YES.c_str(), NO.c_str(), compress(ja).c_str(), index, englishEnding(index).c_str());\r\n\r\n        if (pa == YES)\r\n            yesCount++;\r\n        else if (pa == NO)\r\n            noCount++;\r\n        else\r\n            quitf(_pe, \"%s or %s expected, but %s found [%d%s token]\",\r\n                  YES.c_str(), NO.c_str(), compress(pa).c_str(), index, englishEnding(index).c_str());\r\n\r\n        if (ja != pa)\r\n            quitf(_wa, \"expected %s, found %s [%d%s token]\",\r\n                  compress(ja).c_str(), compress(pa).c_str(), index, englishEnding(index).c_str());\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n    while (!ans.seekEof()) {\r\n        ans.readToken();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n    while (!ouf.seekEof()) {\r\n        ouf.readToken();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              index + extraInAnsCount, index);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              index + extraInOufCount, index);\r\n\r\n    if (index == 0)\r\n        quitf(_ok, \"Empty output\");\r\n    else if (index == 1)\r\n        quitf(_ok, \"%s\", pa.c_str());\r\n    else\r\n        quitf(_ok, \"%d token(s): yes count is %d, no count is %d\", index, yesCount, noCount);\r\n\r\n    quitf(_fail, \"Impossible case\");\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> a(n);\n\n    if (type == \"sorted\") {\n        // Generate a sorted array\n        int start = rnd.next(1, 10000);\n        int step = rnd.next(0, 10);\n        for(int i = 0; i < n; ++i) {\n            a[i] = start + i * step;\n        }\n    } else if (type == \"single_swap\") {\n        // Generate an array that can be sorted by a single swap\n        int start = rnd.next(1, 10000);\n        int step = rnd.next(1, 10);\n        for(int i = 0; i < n; ++i) {\n            a[i] = start + i * step;\n        }\n        // Swap two elements\n        int pos1 = rnd.next(0, n - 1);\n        int pos2 = rnd.next(0, n - 1);\n        while(pos1 == pos2) pos2 = rnd.next(0, n - 1);\n        swap(a[pos1], a[pos2]);\n\n        // Ensure swapped elements are different\n        while(a[pos1] == a[pos2]) {\n            swap(a[pos1], a[pos2]);\n            pos1 = rnd.next(0, n - 1);\n            pos2 = rnd.next(0, n - 1);\n            while(pos1 == pos2) pos2 = rnd.next(0, n - 1);\n            swap(a[pos1], a[pos2]);\n        }\n\n    } else if (type == \"cannot_sort\") {\n        // Generate an array that cannot be sorted with a single swap\n        int start = rnd.next(1, 10000);\n        int step = rnd.next(1, 10);\n        for(int i = 0; i < n; ++i) {\n            a[i] = start + i * step;\n        }\n        // Create multiple inversions\n        for(int i = 0; i < n / 3; ++i) {\n            if(i + 1 < n) swap(a[i], a[i + 1]);\n            if(i + 2 < n) swap(a[i], a[i + 2]);\n        }\n    } else if (type == \"descending\") {\n        // Generate an array in descending order\n        int start = n * rnd.next(1, 10000);\n        int step = rnd.next(1, 10);\n        for(int i = 0; i < n; ++i) {\n            a[i] = start - i * step;\n        }\n    } else if (type == \"all_equal\") {\n        // Generate an array with all elements equal\n        int value = rnd.next(1, 1000000000);\n        for(int i = 0; i < n; ++i) {\n            a[i] = value;\n        }\n    } else if (type == \"random\") {\n        // Generate a random array\n        for(int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, 1000000000);\n        }\n    }\n\n    // Output n\n    printf(\"%d\\n\", n);\n    // Output the array\n    for(int i = 0; i < n; ++i) {\n        printf(\"%d\", a[i]);\n        if (i + 1 < n) printf(\" \");\n    }\n    printf(\"\\n\");\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> a(n);\n\n    if (type == \"sorted\") {\n        // Generate a sorted array\n        int start = rnd.next(1, 10000);\n        int step = rnd.next(0, 10);\n        for(int i = 0; i < n; ++i) {\n            a[i] = start + i * step;\n        }\n    } else if (type == \"single_swap\") {\n        // Generate an array that can be sorted by a single swap\n        int start = rnd.next(1, 10000);\n        int step = rnd.next(1, 10);\n        for(int i = 0; i < n; ++i) {\n            a[i] = start + i * step;\n        }\n        // Swap two elements\n        int pos1 = rnd.next(0, n - 1);\n        int pos2 = rnd.next(0, n - 1);\n        while(pos1 == pos2) pos2 = rnd.next(0, n - 1);\n        swap(a[pos1], a[pos2]);\n\n        // Ensure swapped elements are different\n        while(a[pos1] == a[pos2]) {\n            swap(a[pos1], a[pos2]);\n            pos1 = rnd.next(0, n - 1);\n            pos2 = rnd.next(0, n - 1);\n            while(pos1 == pos2) pos2 = rnd.next(0, n - 1);\n            swap(a[pos1], a[pos2]);\n        }\n\n    } else if (type == \"cannot_sort\") {\n        // Generate an array that cannot be sorted with a single swap\n        int start = rnd.next(1, 10000);\n        int step = rnd.next(1, 10);\n        for(int i = 0; i < n; ++i) {\n            a[i] = start + i * step;\n        }\n        // Create multiple inversions\n        for(int i = 0; i < n / 3; ++i) {\n            if(i + 1 < n) swap(a[i], a[i + 1]);\n            if(i + 2 < n) swap(a[i], a[i + 2]);\n        }\n    } else if (type == \"descending\") {\n        // Generate an array in descending order\n        int start = n * rnd.next(1, 10000);\n        int step = rnd.next(1, 10);\n        for(int i = 0; i < n; ++i) {\n            a[i] = start - i * step;\n        }\n    } else if (type == \"all_equal\") {\n        // Generate an array with all elements equal\n        int value = rnd.next(1, 1000000000);\n        for(int i = 0; i < n; ++i) {\n            a[i] = value;\n        }\n    } else if (type == \"random\") {\n        // Generate a random array\n        for(int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, 1000000000);\n        }\n    }\n\n    // Output n\n    printf(\"%d\\n\", n);\n    // Output the array\n    for(int i = 0; i < n; ++i) {\n        printf(\"%d\", a[i]);\n        if (i + 1 < n) printf(\" \");\n    }\n    printf(\"\\n\");\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 2 -type sorted\n./gen -n 2 -type cannot_sort\n./gen -n 2 -type random\n./gen -n 2 -type single_swap\n./gen -n 2 -type all_equal\n\n./gen -n 5 -type sorted\n./gen -n 5 -type descending\n./gen -n 5 -type single_swap\n\n./gen -n 10 -type all_equal\n./gen -n 10 -type random\n./gen -n 10 -type cannot_sort\n\n./gen -n 100 -type sorted\n./gen -n 100 -type descending\n./gen -n 100 -type single_swap\n\n./gen -n 1000 -type all_equal\n./gen -n 1000 -type random\n./gen -n 1000 -type cannot_sort\n\n./gen -n 50000 -type sorted\n./gen -n 50000 -type descending\n./gen -n 50000 -type single_swap\n\n./gen -n 100000 -type all_equal\n./gen -n 100000 -type random\n./gen -n 100000 -type cannot_sort\n./gen -n 100000 -type descending\n./gen -n 100000 -type single_swap\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T19:50:51.649640",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "220/B",
      "title": "B. Little Elephant and Array",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test4 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains two space-separated integers n and m (1 ≤ n, m ≤ 105) — the size of array a and the number of queries to it. The next line contains n space-separated positive integers a1, a2, ..., an (1 ≤ ai ≤ 109). Next m lines contain descriptions of queries, one per line. The j-th of these lines contains the description of the j-th query as two space-separated integers lj and rj (1 ≤ lj ≤ rj ≤ n).",
      "output_spec": "OutputIn m lines print m integers — the answers to the queries. The j-th line should contain the answer to the j-th query.",
      "sample_tests": "ExamplesInputCopy7 23 1 2 2 3 3 71 73 4OutputCopy31",
      "description": "B. Little Elephant and Array\n\ntime limit per test4 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains two space-separated integers n and m (1 ≤ n, m ≤ 105) — the size of array a and the number of queries to it. The next line contains n space-separated positive integers a1, a2, ..., an (1 ≤ ai ≤ 109). Next m lines contain descriptions of queries, one per line. The j-th of these lines contains the description of the j-th query as two space-separated integers lj and rj (1 ≤ lj ≤ rj ≤ n).\n\nOutputIn m lines print m integers — the answers to the queries. The j-th line should contain the answer to the j-th query.\n\nInputCopy7 23 1 2 2 3 3 71 73 4OutputCopy31\n\nInputCopy7 23 1 2 2 3 3 71 73 4\n\nOutputCopy31",
      "solutions": [
        {
          "title": "Codeforces Round #136 - Codeforces",
          "content": "Tomorrow, in 4 and half hours before the end of the summer (check your zone), Codeforces Round #136 will take place. I am the author of this round, it's my 6th contest on CF.Gerlad Agapov (Gerald) is helping me in preparing the problems. Translations will be done by Maria Belova (Delinur). Thanks to them.I hope you will like this round. The points distribution will be standart.Thanks!7 user in the first division solved all 5 problems, here they are: peter50216 yeputons winger rng_58 RAD al13n KADR Meanwhile, in second division, Top-4 looks like this: blue.boy de_troit lxyxynt ilona You can find the editorial of the contest here.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/5167",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 636
        },
        {
          "title": "Codeforces Round #136 — Editorial - Codeforces",
          "content": "221A - Little Elephant and FunctionIn this problems you should notice that the answer for the problem is always of the following form: n, 1, 2, 3, ..., n-1. In such case array will be always sorted after the end of the algorithm.221B - Little Elephant and NumbersHere you just need to find all divisors of n. This can be done using standart algorithm with iterating from 1 to sqrt(n). After that you need to write some function that checks whether two numbers has same digits. This also can be done using simple loops.220A - Little Elephant and ProblemThere are multiple possible solutions for this problem. For example, the following. Find the last index x such that there exists some y (y < x) (minimal possible) that Ax < Ay. Then you just need to try two possibilities — either swap Ax and Ay, or don't change anything.220B - Little Elephant and ArrayThis problem can be solve in simpler O(NsqrtN) solution, but I will describe O(NlogN) one.We will solve this problem in offline. For each x (0 ≤ x < n) we should keep all the queries that end in x. Iterate that x from 0 to n - 1. Also we need to keep some array D such that for current x Dl + Dl + 1 + ... + Dx will be the answer for query [l;x]. To keep D correct, before the processing all queries that end in x, we need to update D. Let t be the current integer in A, i. e. Ax, and vector P be the list of indices of previous occurences of t (0-based numeration of vector). Then, if |P| ≥ t, you need to add 1 to DP[|P| - t], because this position is now the first (from right) that contains exactly t occurences of t. After that, if |P| > t, you need to subtract 2 from DP[|P| - t - 1], in order to close current interval and cancel previous. Finally, if |P| > t + 1, then you need additionally add 1 to DP[|P| - t - 2] to cancel previous close of the interval.220C - Little Elephant and ShiftsEach of the shifts can be divided into two parts — the right (the one that starts from occurrence 1) and the left (the rest of the elements). If we could keep minimal distance for each part, the minimal of these numbers will be the answers for the corresponding shift. Lets solve the problems of the right part, the left will be almost the same.Let we have some shift, for example 34567[12] and the permutation A is 4312765 and B is 2145673, then shifted B is 4567321. Let we keep two sets (S1 and S2). The first will keep all the distances from integers in current left part to the corresponding positions in A (for the example above, it is \\texttt{2, 4}). When you come to the next shift, all integers in S1 should be decreased by 1 (that is because all distances are also decreased by 1). But now some integers in set may be negative, when any negative integer occures (it always will be -1) you need to delete it from S1 and put 1 to the S2. Also after shifting to the next shifts, all integers in S2 must be increase by 1. After that, for any shift, the answer will be minimum from the smallest numbers in S1 and S2.It was very useful to use standart \"set\" in C++.220D - Little Elephant and TriangleLet iterate all possible points that, as we consider, must be the first point. Let it be (x;y). Let the second and the third points be (x1;y1) and (x2;y2). Then the doubled area is |(x1 - x)(y2 - y) - (x2 - x)(y1 - y)|. We need this number to be even and nonzero. For first we will find the number of groups of points that are even, after that just subtract the number of groups with area equal to zero.For the first subproblem, we need to rewrite our formula. It is equal to |x(y1 - y2) + y(x2 - x1)|. Since we know x and y and we just need to check parity, we can try all possible 24 values of parity of x1, y1, x2 and y2 (let it be d0, d1, d2 and d3, respectively). And check whether they will form a 0 after multiplications and taking modulo 2. If it froms a 0, then add to the answer value cxd0cyd1cxd2cyd3, where cxd is equal to the number of integers between 0 and n, inclusve, that modulo 2 are equal d. cyd is the same but in range [0..m].Now we need to subtract bad groups — the ones that has the area equal to zero. This means that they will either form a dot or a segment. If it is segment, we can just iterate dx = |x1 - x2| and dy = |y1 - y2| instead of all 4 coordinates. Then the number of such segments on the plane will be (n - dx + 1)(m - dy + 1). Also for counting the number of triples of points on the segment you need to find the number of integer coordinates on the segment. It is well-know problem, and the answer is gcd(dx, dy) + 1.This gives us, with some simple optimizations, and O(nm) solution.220E - Little Elephant and InversionsIn this problems you can use a method of two pointers. Also some RMQ are required. If you do not know about RMQ, please, read about it in the Internet before solving this problem.Firstly, map all the elements in the input array. After that all of them will be in range [0..n - 1]. We need to keep two RMQs, both of size n. Let the first RMQ be Q1 and the second Q2. Q1i will contain the number of numbers i in current left subarray. Q2i will contain the number of numbers i in the left subarray. Firstly, add all n number to the Q2. After that iterate some pointer r from n - 1 downto 1, by the way keeping point l (which, at the beggining, is equal to n - 1) Using RMQs, you can keep the number of inversions when you decrease r or l (using \"sum on the range\" operation). While the current number of inversions is more then k and l ≥ 0, decrease l. Then for each r the answer of correct l will be l + 1 (considering 0-based numeration).This makes the algorithm working in O(NlogN) time with correct realisation.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/5177",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 220\\s*B"
          },
          "content_length": 5630
        }
      ],
      "code_examples": [],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    // Read n and m\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 100000, \"m\");\n    inf.readEoln();\n\n    // Read n integers a_i\n    vector<int> a = inf.readInts(n, 1, 1000000000, \"a_i\");\n    inf.readEoln();\n\n    for(int i = 0; i < m; ++i) {\n        // Read lj and rj\n        int l = inf.readInt(1, n, \"l_j\");\n        inf.readSpace();\n        int r = inf.readInt(l, n, \"r_j\"); // Ensure that l ≤ r ≤ n\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    // Read n and m\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 100000, \"m\");\n    inf.readEoln();\n\n    // Read n integers a_i\n    vector<int> a = inf.readInts(n, 1, 1000000000, \"a_i\");\n    inf.readEoln();\n\n    for(int i = 0; i < m; ++i) {\n        // Read lj and rj\n        int l = inf.readInt(1, n, \"l_j\");\n        inf.readSpace();\n        int r = inf.readInt(l, n, \"r_j\"); // Ensure that l ≤ r ≤ n\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    // Read n and m\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 100000, \"m\");\n    inf.readEoln();\n\n    // Read n integers a_i\n    vector<int> a = inf.readInts(n, 1, 1000000000, \"a_i\");\n    inf.readEoln();\n\n    for(int i = 0; i < m; ++i) {\n        // Read lj and rj\n        int l = inf.readInt(1, n, \"l_j\");\n        inf.readSpace();\n        int r = inf.readInt(l, n, \"r_j\"); // Ensure that l ≤ r ≤ n\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    \n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string type = opt<string>(\"type\", \"random\");\n    int min_ai = opt<int>(\"min_ai\", 1);\n    int max_ai = opt<int>(\"max_ai\", 1000000000);\n    string query_type = opt<string>(\"query_type\", \"random\");\n\n    // Generate the array 'a' according to 'type'\n    vector<int> a;\n    if (type == \"random\") {\n        a.resize(n);\n        for(int i = 0; i < n; ++i)\n            a[i] = rnd.next(min_ai, max_ai);\n    } else if (type == \"same_element\") {\n        int val = rnd.next(min_ai, max_ai);\n        a.assign(n, val);\n    } else if (type == \"sequential\") {\n        a.resize(n);\n        for(int i = 0; i < n; ++i)\n            a[i] = min_ai + i % (max_ai - min_ai +1);\n    } else if (type == \"few_distinct\") {\n        int k = min(rnd.next(1, 10), (max_ai - min_ai + 1));\n        set<int> values_set;\n        while(values_set.size() < k) {\n            values_set.insert(rnd.next(min_ai, max_ai));\n        }\n        vector<int> values(values_set.begin(), values_set.end());\n        for(int i=0;i<n;++i)\n            a.push_back(values[rnd.next(0, k-1)]);\n    } else if (type == \"max_value\") {\n        a.assign(n, max_ai);\n    } else if (type == \"min_value\") {\n        a.assign(n, min_ai);\n    } else if (type == \"frequency_equal_value\") {\n        // Build a sequence where number x occurs x times\n        int k = (-1 + sqrt(1 + 8.0 * n)) / 2;\n        int total = k*(k+1)/2;\n        vector<int> temp_a;\n        for(int x=1; x<=k; ++x) {\n            for(int cnt=0; cnt < x; ++cnt) {\n                temp_a.push_back(x);\n            }\n        }\n        // If temp_a.size() < n, fill the rest with random numbers\n        while(temp_a.size() < n) {\n            temp_a.push_back(rnd.next(min_ai, max_ai));\n        }\n        // If temp_a.size() > n, truncate\n        if(temp_a.size() > n) {\n            temp_a.resize(n);\n        }\n        // Shuffle the array\n        shuffle(temp_a.begin(), temp_a.end());\n        a = temp_a;\n    } else {\n        // Default to random\n        a.resize(n);\n        for(int i = 0; i < n; ++i)\n            a[i] = rnd.next(min_ai, max_ai);\n    }\n\n    // Output n and m\n    printf(\"%d %d\\n\", n, m);\n\n    // Output the array a\n    for(int i =0; i < n; ++i) {\n        if (i > 0) printf(\" \");\n        printf(\"%d\", a[i]);\n    }\n    printf(\"\\n\");\n\n    // Generate queries\n    vector<pair<int,int>> queries;\n    if (query_type == \"random\") {\n        for(int i=0;i<m;++i) {\n            int l = rnd.next(1,n);\n            int r = rnd.next(l,n);\n            queries.push_back(make_pair(l,r));\n        }\n    } else if (query_type == \"full_array\") {\n        for(int i=0;i<m;++i) {\n            queries.push_back(make_pair(1,n));\n        }\n    } else if (query_type == \"single_element\") {\n        for(int i=0;i<m;++i) {\n            int idx = rnd.next(1,n);\n            queries.push_back(make_pair(idx, idx));\n        }\n    } else if (query_type == \"prefix\") {\n        for(int i=0; i<m; ++i) {\n            int r = rnd.next(1,n);\n            queries.push_back(make_pair(1,r));\n        }\n    } else if (query_type == \"suffix\") {\n        for(int i=0; i<m; ++i) {\n            int l = rnd.next(1,n);\n            queries.push_back(make_pair(l,n));\n        }\n    } else {\n        // Default to random\n        for(int i=0;i<m;++i) {\n            int l = rnd.next(1,n);\n            int r = rnd.next(l,n);\n            queries.push_back(make_pair(l,r));\n        }\n    }\n\n    // Output the queries\n    for(auto &q : queries) {\n        printf(\"%d %d\\n\", q.first, q.second);\n    }\n    \n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    \n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string type = opt<string>(\"type\", \"random\");\n    int min_ai = opt<int>(\"min_ai\", 1);\n    int max_ai = opt<int>(\"max_ai\", 1000000000);\n    string query_type = opt<string>(\"query_type\", \"random\");\n\n    // Generate the array 'a' according to 'type'\n    vector<int> a;\n    if (type == \"random\") {\n        a.resize(n);\n        for(int i = 0; i < n; ++i)\n            a[i] = rnd.next(min_ai, max_ai);\n    } else if (type == \"same_element\") {\n        int val = rnd.next(min_ai, max_ai);\n        a.assign(n, val);\n    } else if (type == \"sequential\") {\n        a.resize(n);\n        for(int i = 0; i < n; ++i)\n            a[i] = min_ai + i % (max_ai - min_ai +1);\n    } else if (type == \"few_distinct\") {\n        int k = min(rnd.next(1, 10), (max_ai - min_ai + 1));\n        set<int> values_set;\n        while(values_set.size() < k) {\n            values_set.insert(rnd.next(min_ai, max_ai));\n        }\n        vector<int> values(values_set.begin(), values_set.end());\n        for(int i=0;i<n;++i)\n            a.push_back(values[rnd.next(0, k-1)]);\n    } else if (type == \"max_value\") {\n        a.assign(n, max_ai);\n    } else if (type == \"min_value\") {\n        a.assign(n, min_ai);\n    } else if (type == \"frequency_equal_value\") {\n        // Build a sequence where number x occurs x times\n        int k = (-1 + sqrt(1 + 8.0 * n)) / 2;\n        int total = k*(k+1)/2;\n        vector<int> temp_a;\n        for(int x=1; x<=k; ++x) {\n            for(int cnt=0; cnt < x; ++cnt) {\n                temp_a.push_back(x);\n            }\n        }\n        // If temp_a.size() < n, fill the rest with random numbers\n        while(temp_a.size() < n) {\n            temp_a.push_back(rnd.next(min_ai, max_ai));\n        }\n        // If temp_a.size() > n, truncate\n        if(temp_a.size() > n) {\n            temp_a.resize(n);\n        }\n        // Shuffle the array\n        shuffle(temp_a.begin(), temp_a.end());\n        a = temp_a;\n    } else {\n        // Default to random\n        a.resize(n);\n        for(int i = 0; i < n; ++i)\n            a[i] = rnd.next(min_ai, max_ai);\n    }\n\n    // Output n and m\n    printf(\"%d %d\\n\", n, m);\n\n    // Output the array a\n    for(int i =0; i < n; ++i) {\n        if (i > 0) printf(\" \");\n        printf(\"%d\", a[i]);\n    }\n    printf(\"\\n\");\n\n    // Generate queries\n    vector<pair<int,int>> queries;\n    if (query_type == \"random\") {\n        for(int i=0;i<m;++i) {\n            int l = rnd.next(1,n);\n            int r = rnd.next(l,n);\n            queries.push_back(make_pair(l,r));\n        }\n    } else if (query_type == \"full_array\") {\n        for(int i=0;i<m;++i) {\n            queries.push_back(make_pair(1,n));\n        }\n    } else if (query_type == \"single_element\") {\n        for(int i=0;i<m;++i) {\n            int idx = rnd.next(1,n);\n            queries.push_back(make_pair(idx, idx));\n        }\n    } else if (query_type == \"prefix\") {\n        for(int i=0; i<m; ++i) {\n            int r = rnd.next(1,n);\n            queries.push_back(make_pair(1,r));\n        }\n    } else if (query_type == \"suffix\") {\n        for(int i=0; i<m; ++i) {\n            int l = rnd.next(1,n);\n            queries.push_back(make_pair(l,n));\n        }\n    } else {\n        // Default to random\n        for(int i=0;i<m;++i) {\n            int l = rnd.next(1,n);\n            int r = rnd.next(l,n);\n            queries.push_back(make_pair(l,r));\n        }\n    }\n\n    // Output the queries\n    for(auto &q : queries) {\n        printf(\"%d %d\\n\", q.first, q.second);\n    }\n    \n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 10 -m 5 -type random -query_type random\n./gen -n 10 -m 5 -type same_element -query_type full_array\n./gen -n 10 -m 5 -type sequential -query_type single_element\n./gen -n 20 -m 10 -type frequency_equal_value -query_type random\n./gen -n 50 -m 25 -type few_distinct -query_type prefix\n./gen -n 100 -m 50 -type random -query_type random\n./gen -n 500 -m 200 -type same_element -query_type suffix\n./gen -n 1000 -m 500 -type sequential -query_type random\n./gen -n 2000 -m 1000 -type frequency_equal_value -query_type random\n./gen -n 5000 -m 2500 -type few_distinct -query_type random\n./gen -n 10000 -m 5000 -type random -query_type random\n./gen -n 20000 -m 10000 -type same_element -query_type random\n./gen -n 50000 -m 25000 -type frequency_equal_value -query_type random\n./gen -n 70000 -m 35000 -type random -query_type random\n./gen -n 90000 -m 45000 -type sequential -query_type random\n./gen -n 100000 -m 100000 -type random -query_type random\n./gen -n 100000 -m 100000 -type same_element -query_type random\n./gen -n 100000 -m 100000 -type few_distinct -query_type random\n./gen -n 100000 -m 100000 -type frequency_equal_value -query_type random\n./gen -n 100000 -m 100000 -type random -query_type single_element\n./gen -n 100000 -m 100000 -type random -query_type prefix\n./gen -n 100000 -m 100000 -type random -query_type suffix\n./gen -n 100000 -m 100000 -type min_value -min_ai 1 -max_ai 1 -query_type random\n./gen -n 100000 -m 100000 -type max_value -min_ai 1000000000 -max_ai 1000000000 -query_type random\n./gen -n 99999 -m 99999 -type random -query_type random\n./gen -n 100000 -m 1 -type random -query_type full_array\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T19:50:53.433263",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "220/C",
      "title": "C. Маленький Слоник и сдвиги",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест2 секунды",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеВ первой строке записано единственное целое число n (1 ≤ n ≤ 105) — размер перестановок. Во второй строке записана перестановка a — n различных чисел от 1 до n, включительно. Числа разделены единичными пробелами. В третьей строке записана перестановка b в аналогичном формате.",
      "output_spec": "Выходные данныеВ n строках выведите n целых чисел — ответы для каждого циклического сдвига. Ответы для сдвигов выводите в порядке нумерации циклических сдвигов перестановки b, то есть сначала для 1-го циклического сдвига, потом для 2-го, и так далее.",
      "sample_tests": "ПримерыВходные данныеСкопировать21 22 1Выходные данныеСкопировать10Входные данныеСкопировать42 1 3 43 4 2 1Выходные данныеСкопировать2101",
      "description": "C. Маленький Слоник и сдвиги\n\nограничение по времени на тест2 секунды\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвыводstdout\n\nВходные данныеВ первой строке записано единственное целое число n (1 ≤ n ≤ 105) — размер перестановок. Во второй строке записана перестановка a — n различных чисел от 1 до n, включительно. Числа разделены единичными пробелами. В третьей строке записана перестановка b в аналогичном формате.\n\nВходные данные\n\nВыходные данныеВ n строках выведите n целых чисел — ответы для каждого циклического сдвига. Ответы для сдвигов выводите в порядке нумерации циклических сдвигов перестановки b, то есть сначала для 1-го циклического сдвига, потом для 2-го, и так далее.\n\nВыходные данные\n\nВходные данныеСкопировать21 22 1Выходные данныеСкопировать10Входные данныеСкопировать42 1 3 43 4 2 1Выходные данныеСкопировать2101\n\nВходные данныеСкопировать21 22 1\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать10\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать42 1 3 43 4 2 1\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать2101\n\nВыходные данныеСкопировать\n\nСкопировать",
      "solutions": [
        {
          "title": "Codeforces Round #136 - Codeforces",
          "content": "Завтра, 31-го августа, за 4 с половиной часа до конца лета (по Москве) будет проходить Codeforces Round #136. Автором этого контеста буду я, это уже мой 6-й контест на CF.Помогает строить раунд мне Геральд Агапов (Gerald), задачи переведет, как я предполагаю, Мария Белова (Delinur). Спасибо всем.Надеюсь, вам понравится раунд. Разбалловка стандартная.Спасибо за участие. К сожалению, большинство моих контестов не пользуются особым интересом, судя по системе \"Вклад\", но надеюсь все-таки нашлись те, кому он понравился :)В первом дивизионе ровно 7 участников решили все задачи, они и попадут на главную: peter50216 yeputons winger rng_58 RAD al13n KADR В то время Топ-4 во втором дивизионе выглядит следующим образом: blue.boy de_troit lxyxynt ilona На данный момент есть только разбор на английском.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/5167",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 801
        },
        {
          "title": "Codeforces Round #136 — Разбор - Codeforces",
          "content": "221A - Маленький Слоник и функцияВ этой задаче все что нужно заметить это то, что ответ всегда имеет следующею форму: n, 1, 2, 3, ..., n-1. При такой перестановке не трудно заметить, что после полого выполнения алгоритма перестановка будет отсортирована.221B - Маленький Слоник и числаНужно найти все делители числа n. Это можно сделать простым перебором от 1 до sqrt(n). После этого нужно написать функцию, которая умеет определять, существуют ли две одинаковые цифры в паре чисел. Это тоже можно сделать простым перебором по цифрам.220A - Маленький Слоник и проблемаСуществует несколько решений этой задачи. Например, можно найти максимальное x такое, что существует y (минимальное возможное) такое, что (y < x) и Ax < Ay. После этого остается проверить ровно два варианты — либо менять местами x-е и y-е числа, либо не делать ничего.220B - Маленький Слоник и массивЗадачу можно решить за O(NsqrtN), но я опишу решение за O(NlogN).Будем решать задачу в оффлайне, тоесть сначала считаем все запросы, а потом будем давать ответы. Для каждого x (0 ≤ x n) мы должны держать все запросы, концами которых есть x. Будем перебирать x от 0 до n - 1. Также нам нужно поддерживать массив чисел D такой, что для текущего x ответом на запрос [l;x] будет число Dl + Dl + 1 + ... + Dr. Для правильной поддержки массива, перед тем как обрабатывать запросы для текущего x, нудно обновить D. Пусть t — текущее число, тоесть Ax, а вектор P — список индексов всех вхождений числа t (до позиции x), нумерация с 0. Тогда, если |P| ≥ t, нам нужно добавить 1 до DP[|P| - t], так как эта позиция теперь переломной — после нее будет не меньше чем t вхождений числа t. Потом, если |P| > t, нужно отнять 2 от DP[|P| - t - 1], для того что-бы закрыть текущий интервал (после этой позиции количество вхождений t будет превосходить t), а также отменить предыдущий. И наконец, если |P| > t + 1, нужно еще добавить 1 к DP[|P| - t - 2] для того что-бы отменить закрытие предыдущего интервала.220C - Маленький Слоник и сдвигиEach of the shifts can be divided into two parts — the right (the one that starts from occurrence 1) and the left (the rest of the elements). If we could keep minimal distance for each part, the minimal of these numbers will be the answers for the corresponding shift. Lets solve the problems of the right part, the left will be almost the same.Let we have some shift, for example 34567[12] and the permutation A is 4312765 and B is 2145673, then shifted B is 4567321. Let we keep two sets (S1 and S2). The first will keep all the distances from integers in current left part to the corresponding positions in A (for the example above, it is [2, 4]). When you come to the next shift, all integers in S1 should be decreased by 1 (that is because all distances are also decreased by 1). But now some integers in set may be negative, when any negative integer occures (it always will be -1) you need to delete it from S1 and put 1 to the S2. Also after shifting to the next shifts, all integers in S2 must be increase by 1. After that, for any shift, the answer will be minimum from the smallest numbers in S1 and S2.It was very useful to use standart \"set\" in C++.220D - Маленький Слоник и треугольникДавайте переберем все возможные точки нашей плоскости и предположим что это первая точка тройки. Пусть это будет точка (x;y). Пусть вторая и третья точки это (x1;y1) и (x2;y2). Тогда удвоенная площадь равна |(x1 - x)(y2 - y) - (x2 - x)(y1 - y)|. Нам нужно что-бы это число было четным, а также ненулевым. Для начала найдем количество троек, которые образуют четную площадь, а потом отнимем количество точек с нулевой площадью. Первая подзадача. Так как мы знаем x и y и нам нужно проверить четность, давайте еще переберем все возможные 24 варианты четности x1, y1, x2 и y2 (пусть это d0, d1, d2 и d3, соответственно). Потом проверим будет ли такая тройка чисел формировать 0 после подстановки в формулу площади и взятии по модулю 2. Если это так, тогда нужно добавит к ответу число cxd0cyd1cxd2cyd3, где cxd равно количеству целых чисел в промежутке [0..n] таких, что они по модулю 2 равны d. Аналогично для cyd, только в промежутке [0..m].Теперь нужно отнять плохие тройки — такие, что треугольник, который они создают, имеет нулевую площадь. Это значит, что тройка точек формирует отрезок (или точку). Так как это отрезок, давайте переберем dx = |x1 - x2| и dy = |y1 - y2|, вместо перебора всех 4 координат. Количество таких отрезков на плоскости равно (n - dx + 1)(m - dy + 1). Также для подсчета количества троек, что формируют такой отрезок, нужно искать количество точек с целыми координатами на плоскости, которые лежат на этом отрезке. Это известная задача — это количество равно gcd(dx, dy) + 1.Это дает нам, с еще некоторыми оптимизациями, решение за O(nm).220E - Маленький Слоник, а также инверсииВ этой задачи нужно использовать метод двух указателей. Также нужно использовать RMQ. Если вы не знакомы со структурой данных RMQ, почитать о нем можно здесь.Для начала, уменьшим все числа, не меняя их относительное значения, тогда все числа будут в переделе от 0 до n - 1. Нужно поддерживать два RMQ, каждое размером n. Пусть первое RMQ это Q1, а второе — Q2. Q1i будет содержать количество чисел i в текущему левом подмассиве, а Q2i — в правом. Для начала нужно добавить все n чисел в левое RMQ. После этого будем идти указателем r от n - 1 до 1, при этом поддерживая l — максимальный индекс такой, что пара (l;r) содержит не более чем k инверсий (в начале l равно n - 1). Количество инверсий, очевидно, нужно поддерживать, используя RMQ (используя операцию \"сумма на отрезке\"). В такой реализации время выполнения алгоритма равно O(NlogN).",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/5177",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 220\\s*C"
          },
          "content_length": 5641
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #136 - Codeforces - Code 1",
          "code": "1)how to solve C help me please",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5167",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #136 - Codeforces - Code 2",
          "code": "2)it won't do harm for your rating. just + for me....",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5167",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #136 - Codeforces - Code 3",
          "code": "1)it won't be your really rating.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5167",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #136 - Codeforces - Code 4",
          "code": "2)it will affect to others rating.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5167",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #136 - Codeforces - Code 5",
          "code": "3)do you really want to practice ComputerProgramming?",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5167",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #136 - Codeforces - Code 6",
          "code": "100000 100000\n413 212 432 39 177 169 ...",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5167",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #136 - Codeforces - Code 7",
          "code": "100000 100000\n362 328 428 153 323 415 ...",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5167",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #136 - Codeforces - Code 8",
          "code": "362 328 428 153 ...",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5167",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #136 - Codeforces - Code 9",
          "code": "250 302 154 91 381 407 ...",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/5167",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, 1, n, \"a\");\n    inf.readEoln();\n\n    vector<bool> seen(n + 1, false);\n    for (int i = 0; i < n; ++i) {\n        int x = a[i];\n        ensuref(!seen[x], \"Element %d appears multiple times in permutation a\", x);\n        seen[x] = true;\n    }\n\n    vector<int> b = inf.readInts(n, 1, n, \"b\");\n    inf.readEoln();\n\n    fill(seen.begin(), seen.end(), false);\n    for (int i = 0; i < n; ++i) {\n        int x = b[i];\n        ensuref(!seen[x], \"Element %d appears multiple times in permutation b\", x);\n        seen[x] = true;\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, 1, n, \"a\");\n    inf.readEoln();\n\n    vector<bool> seen(n + 1, false);\n    for (int i = 0; i < n; ++i) {\n        int x = a[i];\n        ensuref(!seen[x], \"Element %d appears multiple times in permutation a\", x);\n        seen[x] = true;\n    }\n\n    vector<int> b = inf.readInts(n, 1, n, \"b\");\n    inf.readEoln();\n\n    fill(seen.begin(), seen.end(), false);\n    for (int i = 0; i < n; ++i) {\n        int x = b[i];\n        ensuref(!seen[x], \"Element %d appears multiple times in permutation b\", x);\n        seen[x] = true;\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, 1, n, \"a\");\n    inf.readEoln();\n\n    vector<bool> seen(n + 1, false);\n    for (int i = 0; i < n; ++i) {\n        int x = a[i];\n        ensuref(!seen[x], \"Element %d appears multiple times in permutation a\", x);\n        seen[x] = true;\n    }\n\n    vector<int> b = inf.readInts(n, 1, n, \"b\");\n    inf.readEoln();\n\n    fill(seen.begin(), seen.end(), false);\n    for (int i = 0; i < n; ++i) {\n        int x = b[i];\n        ensuref(!seen[x], \"Element %d appears multiple times in permutation b\", x);\n        seen[x] = true;\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> a(n);\n    vector<int> b(n);\n\n    if (type == \"random\") {\n        // Random permutations for a and b\n        for (int i = 0; i < n; ++i) a[i] = i + 1, b[i] = i + 1;\n        shuffle(a.begin(), a.end());\n        shuffle(b.begin(), b.end());\n    } else if (type == \"sorted\") {\n        // Both a and b are sorted\n        for (int i = 0; i < n; ++i) a[i] = b[i] = i + 1;\n    } else if (type == \"reverse\") {\n        // a is sorted, b is reverse of a\n        for (int i = 0; i < n; ++i) a[i] = i + 1;\n        for (int i = 0; i < n; ++i) b[i] = n - i;\n    } else if (type == \"same\") {\n        // a and b are the same random permutation\n        for (int i = 0; i < n; ++i) a[i] = i + 1;\n        shuffle(a.begin(), a.end());\n        b = a;\n    } else if (type == \"shifted\") {\n        // b is a cyclic shift of a by s positions\n        int s = opt<int>(\"s\", rnd.next(1, n));\n        for (int i = 0; i < n; ++i) a[i] = i + 1;\n        bool shuffleA = opt<bool>(\"shuffleA\", false);\n        if (shuffleA) shuffle(a.begin(), a.end());\n        for (int i = 0; i < n; ++i) b[i] = a[(i + s) % n];\n    } else if (type == \"min_dist\") {\n        // Minimal distance between positions of same elements is minimal\n        for (int i = 0; i < n; ++i) a[i] = b[i] = i + 1;\n        int swaps = opt<int>(\"swaps\", n/10);\n        for (int i = 0; i < swaps; ++i) {\n            int pos1 = rnd.next(0, n - 1);\n            int pos2 = rnd.next(0, n - 1);\n            swap(b[pos1], b[pos2]);\n        }\n    } else if (type == \"max_dist\") {\n        // Maximize minimal |i - j| where ai = bj\n        for (int i = 0; i < n; ++i) a[i] = i + 1;\n        for (int i = 0; i < n; ++i) b[i] = n - i;\n        int swaps = opt<int>(\"swaps\", 0);\n        for (int i = 0; i < swaps; ++i) {\n            int pos1 = rnd.next(0, n - 1);\n            int pos2 = rnd.next(0, n - 1);\n            swap(b[pos1], b[pos2]);\n        }\n    } else {\n        fprintf(stderr, \"Unknown type: %s\\n\", type.c_str());\n        exit(1);\n    }\n\n    // Output\n    printf(\"%d\\n\", n);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d\", a[i]);\n        if (i + 1 < n) printf(\" \");\n    }\n    printf(\"\\n\");\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d\", b[i]);\n        if (i + 1 < n) printf(\" \");\n    }\n    printf(\"\\n\");\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> a(n);\n    vector<int> b(n);\n\n    if (type == \"random\") {\n        // Random permutations for a and b\n        for (int i = 0; i < n; ++i) a[i] = i + 1, b[i] = i + 1;\n        shuffle(a.begin(), a.end());\n        shuffle(b.begin(), b.end());\n    } else if (type == \"sorted\") {\n        // Both a and b are sorted\n        for (int i = 0; i < n; ++i) a[i] = b[i] = i + 1;\n    } else if (type == \"reverse\") {\n        // a is sorted, b is reverse of a\n        for (int i = 0; i < n; ++i) a[i] = i + 1;\n        for (int i = 0; i < n; ++i) b[i] = n - i;\n    } else if (type == \"same\") {\n        // a and b are the same random permutation\n        for (int i = 0; i < n; ++i) a[i] = i + 1;\n        shuffle(a.begin(), a.end());\n        b = a;\n    } else if (type == \"shifted\") {\n        // b is a cyclic shift of a by s positions\n        int s = opt<int>(\"s\", rnd.next(1, n));\n        for (int i = 0; i < n; ++i) a[i] = i + 1;\n        bool shuffleA = opt<bool>(\"shuffleA\", false);\n        if (shuffleA) shuffle(a.begin(), a.end());\n        for (int i = 0; i < n; ++i) b[i] = a[(i + s) % n];\n    } else if (type == \"min_dist\") {\n        // Minimal distance between positions of same elements is minimal\n        for (int i = 0; i < n; ++i) a[i] = b[i] = i + 1;\n        int swaps = opt<int>(\"swaps\", n/10);\n        for (int i = 0; i < swaps; ++i) {\n            int pos1 = rnd.next(0, n - 1);\n            int pos2 = rnd.next(0, n - 1);\n            swap(b[pos1], b[pos2]);\n        }\n    } else if (type == \"max_dist\") {\n        // Maximize minimal |i - j| where ai = bj\n        for (int i = 0; i < n; ++i) a[i] = i + 1;\n        for (int i = 0; i < n; ++i) b[i] = n - i;\n        int swaps = opt<int>(\"swaps\", 0);\n        for (int i = 0; i < swaps; ++i) {\n            int pos1 = rnd.next(0, n - 1);\n            int pos2 = rnd.next(0, n - 1);\n            swap(b[pos1], b[pos2]);\n        }\n    } else {\n        fprintf(stderr, \"Unknown type: %s\\n\", type.c_str());\n        exit(1);\n    }\n\n    // Output\n    printf(\"%d\\n\", n);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d\", a[i]);\n        if (i + 1 < n) printf(\" \");\n    }\n    printf(\"\\n\");\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d\", b[i]);\n        if (i + 1 < n) printf(\" \");\n    }\n    printf(\"\\n\");\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -type random\n./gen -n 2 -type sorted\n./gen -n 2 -type reverse\n./gen -n 3 -type shifted -s 1\n./gen -n 3 -type shifted -s 2\n./gen -n 5 -type same\n./gen -n 5 -type min_dist -swaps 1\n./gen -n 5 -type max_dist\n./gen -n 10 -type random\n./gen -n 10 -type shifted -s 5\n./gen -n 100 -type sorted\n./gen -n 100 -type reverse\n./gen -n 1000 -type random\n./gen -n 1000 -type min_dist -swaps 10\n./gen -n 1000 -type max_dist -swaps 10\n./gen -n 10000 -type random\n./gen -n 10000 -type min_dist -swaps 1000\n./gen -n 10000 -type max_dist -swaps 1000\n./gen -n 100000 -type random\n./gen -n 100000 -type min_dist -swaps 10000\n./gen -n 100000 -type max_dist -swaps 0\n./gen -n 100000 -type shifted -s 1\n./gen -n 100000 -type shifted -s 99999\n./gen -n 100000 -type same\n./gen -n 100000 -type reverse\n./gen -n 100 -type shifted -s 0\n./gen -n 50000 -type random\n./gen -n 50000 -type min_dist -swaps 5000\n./gen -n 50000 -type shifted -s 25000\n./gen -n 50000 -type same\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T19:50:55.032726",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    }
  ]
}