{
  "metadata": {
    "batch_number": 37,
    "total_batches": 73,
    "problems_in_batch": 100,
    "total_problems": 7261,
    "created_at": "2025-08-28T22:04:41.320574",
    "format": "wenjiajia_v1.0"
  },
  "problems": [
    {
      "problem_id": "298/B",
      "title": "B. Sail",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains five integers t, sx, sy, ex, ey (1 ≤ t ≤ 105,  - 109 ≤ sx, sy, ex, ey ≤ 109). The starting location and the ending location will be different.The second line contains t characters, the i-th character is the wind blowing direction at the i-th second. It will be one of the four possibilities: \"E\" (east), \"S\" (south), \"W\" (west) and \"N\" (north).",
      "output_spec": "OutputIf they can reach (ex, ey) within t seconds, print the earliest time they can achieve it. Otherwise, print \"-1\" (without quotes).",
      "sample_tests": "ExamplesInputCopy5 0 0 1 1SESNWOutputCopy4InputCopy10 5 3 3 6NENSWESNEEOutputCopy-1",
      "description": "time limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains five integers t, sx, sy, ex, ey (1 ≤ t ≤ 105,  - 109 ≤ sx, sy, ex, ey ≤ 109). The starting location and the ending location will be different.The second line contains t characters, the i-th character is the wind blowing direction at the i-th second. It will be one of the four possibilities: \"E\" (east), \"S\" (south), \"W\" (west) and \"N\" (north).\n\nOutputIf they can reach (ex, ey) within t seconds, print the earliest time they can achieve it. Otherwise, print \"-1\" (without quotes).\n\nInputCopy5 0 0 1 1SESNWOutputCopy4InputCopy10 5 3 3 6NENSWESNEEOutputCopy-1\n\nInputCopy5 0 0 1 1SESNW\n\nOutputCopy4\n\nInputCopy10 5 3 3 6NENSWESNEE\n\nOutputCopy-1\n\nNoteIn the first sample, they can stay at seconds 1, 3, and move at seconds 2, 4.In the second sample, they cannot sail to the destination.",
      "solutions": [
        {
          "title": "Codeforces Round #180 - Codeforces",
          "content": "Hi all!CodeForces 180 will take place at 19/4 17:30 (CEST). I (SteamTurbine), and Ivan Li (AEtheReal) are the authors of the round.This time you will need to help some polar bears to solve their problems. You know, life in the arctic is hard, they may face difficulties about catching fish, keeping warm etc.Thanks Gerald for helping us to prepare the round, MikeMirzayanov for the great platform and Delinur for translation.We hope that the polar bears are not going to eat you. Good Luck.UPD: Scoring will be dynamic. Problems are sorted by increasing order of difficulty.Editorial is here(All except Div 1 E) and here(Div 1 E).Result (div1): tourist (Solved all!) wjmsbmr tckwok0 msg555 Erop Result (div2): Parsa.pordel a88027180 Raoul Some fun facts:In 297E - Mystic Carvings (written by AEtheReal), the figure in the problem looks like the facial expression \"XD\" and \"囧\", which is done intentionally.Moreover, three lines can intersect in the following 5 ways:While discussing the problem, we refer those as \"川\", \"囧\", \"XD\", \"卄\" and \"△\". Chinese characters are interesting :)",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/7390",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1079
        },
        {
          "title": "Codeforces Round #180 Editorial - Codeforces",
          "content": "298A - Snow FootprintsThe starting position can be anywhere with a footprint. The footprints can be categorized into 3 types. only L s only R s R s followed by L s In case 1, we end in the left of all footprints. In case 2, we end in the right of all footprints. In case 3, we either end in the rightmost R or the leftmost L298B - SailWe can simply move by greedy method — only moves when it takes the boat closer to the destination.297A - Parity GameObv 1: If a has odd parity, we can apply operation 1 to increase its number of 1s by 1.Obv 2: If a has even parity, its number of 1s cannot increase anymore.Claim: If the number of 1s in a is not fewer than those in b, we can always turn a to bThe idea is to make a copy of b at the right of a. Lets assume a starts with even parity. If we need a 0, simply apply operation 1. If we need a 1, keep remove from the head until we removed an 1. Notice that we never remove digits from 'new part' of a. Now the parity of a will be odd and we can apply operation 1. After that, the parity of a becomes even again, the number of 1 in the 'old part' of a decrease by 1 and we handle a 1 in b. Finally, remove the remaining old part of a and we get b.Combine all those facts, we can conclude that we can turn a into b if and only if countOnes(a) + parity(countOnes(a)) ≥ countOnes(b)297B - Fish WeightFirst we sort a and b in non-increasing order. We claim that the answer is YES if and only if exists a is lexicographically larger than b. If a is not lexicographcally larger than b, that means for every i, ai ≤ bi. That implies for every fish Alice has, there is a corresponding fish Bob has and is as heavy as Alice's. Let i be the smallest index such that ai > bi. We can amplify the gap between wai and wbi as large as we want to make Alice wins.297C - Splitting the UniquenessAn equivalent definition for almost unique, is an array with at least ⌊ 2n / 3⌋ different elements. The idea is to split s into three parts: In the first part, we give uniqueness to a. In the second part, we give uniqueness to b. In the third part, we give uniqueness to both.Lets assume s is sorted. Since s is an unique array, we know si ≥ i for all i (0-based). The image below will give some intuition on how we are going to split it. a is red, b is blue, the length of the bar represent the magnitude of the number. In the first and second part, we do not care about the array that we are not giving uniqueness to.For exampmle, if n = 30:i = 0... 9:  assign ai = i (do not care values of b)i = 10... 19:  assign bi = i (do not care values of a)i = 20... 29:  assign bi = 29 - i and set ai = si - bi. From i = 20, a will have strictly increasing values starting from at least 11.297D - Color the CarpetFor k = 1 there is only one coloring so we just need to check the number of  =  constraints. When k ≥ 2, it turns out that using only 2 colors is always sufficient to satisfy at least 3 / 4 of the constraints.Lets assume w ≥ h (rotate if not). We will call the constraints that involves cells in different row \"vertical constraints\", and similar for \"horizontal constraints\".First we color the first row such that all horizontal constraints in row 1 are satisfied. We will color the remaining rows one by one.To color row i, first we color it such that all horizontal constraints in row i are satisfied. Then consider the vertical constraints between row i and row i - 1. Count the number of satisfied and unsatisfied vertical constraints. If there are more unsatisfied constraints than satisfied constraints, flip the coloring of row i. Flipping a row means turning 2211212 → 1122121, for example.If we flip the coloring of row i, all horizontal constraints in row i are still satisfied, but for the vertical constraints between row i and row i - 1, satisfied will turn to unsatisfied, unsatisfied will turn to satisfied. Therefore, we can always satisfy at least half the vertical constraints between row i and row i - 1.The number of unsatisfied constraints is at most (h - 1) × ⌊ w / 2⌋, which is at most 1 / 4 of the total number of constraints (recall w ≥ h).297E - Mystic CarvingsProblem and editorial written by AEtheReal. Link to editorial.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/7437",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 298\\s*B"
          },
          "content_length": 4179
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #180 - Codeforces - Code 1",
          "code": "Those bears were a real pain in the brain....",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7390",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #180 - Codeforces - Code 2",
          "code": "pivot = a[(left+right)/2]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7390",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #180 - Codeforces - Code 3",
          "code": "ai>= 0 && bi >= 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7390",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int t = inf.readInt(1, 100000, \"t\");\n    inf.readSpace();\n    int sx = inf.readInt(-1000000000, 1000000000, \"sx\");\n    inf.readSpace();\n    int sy = inf.readInt(-1000000000, 1000000000, \"sy\");\n    inf.readSpace();\n    int ex = inf.readInt(-1000000000, 1000000000, \"ex\");\n    inf.readSpace();\n    int ey = inf.readInt(-1000000000, 1000000000, \"ey\");\n    inf.readEoln();\n\n    // Ensure starting and ending points are different\n    ensuref(sx != ex || sy != ey, \"Starting point and ending point must be different\");\n\n    string s = inf.readLine();\n\n    ensuref(int(s.length()) == t, \"Length of 'wind directions' string must be exactly t=%d, but was %d\", t, int(s.length()));\n\n    for (int i = 0; i < t; ++i) {\n        char c = s[i];\n        ensuref(c == 'E' || c == 'S' || c == 'W' || c == 'N',\n            \"Invalid character '%c' in 'wind directions' at position %d (should be 'E', 'S', 'W', or 'N')\", c, i+1);\n    }\n\n    inf.readEof();\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int t = inf.readInt(1, 100000, \"t\");\n    inf.readSpace();\n    int sx = inf.readInt(-1000000000, 1000000000, \"sx\");\n    inf.readSpace();\n    int sy = inf.readInt(-1000000000, 1000000000, \"sy\");\n    inf.readSpace();\n    int ex = inf.readInt(-1000000000, 1000000000, \"ex\");\n    inf.readSpace();\n    int ey = inf.readInt(-1000000000, 1000000000, \"ey\");\n    inf.readEoln();\n\n    // Ensure starting and ending points are different\n    ensuref(sx != ex || sy != ey, \"Starting point and ending point must be different\");\n\n    string s = inf.readLine();\n\n    ensuref(int(s.length()) == t, \"Length of 'wind directions' string must be exactly t=%d, but was %d\", t, int(s.length()));\n\n    for (int i = 0; i < t; ++i) {\n        char c = s[i];\n        ensuref(c == 'E' || c == 'S' || c == 'W' || c == 'N',\n            \"Invalid character '%c' in 'wind directions' at position %d (should be 'E', 'S', 'W', or 'N')\", c, i+1);\n    }\n\n    inf.readEof();\n\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int t = inf.readInt(1, 100000, \"t\");\n    inf.readSpace();\n    int sx = inf.readInt(-1000000000, 1000000000, \"sx\");\n    inf.readSpace();\n    int sy = inf.readInt(-1000000000, 1000000000, \"sy\");\n    inf.readSpace();\n    int ex = inf.readInt(-1000000000, 1000000000, \"ex\");\n    inf.readSpace();\n    int ey = inf.readInt(-1000000000, 1000000000, \"ey\");\n    inf.readEoln();\n\n    // Ensure starting and ending points are different\n    ensuref(sx != ex || sy != ey, \"Starting point and ending point must be different\");\n\n    string s = inf.readLine();\n\n    ensuref(int(s.length()) == t, \"Length of 'wind directions' string must be exactly t=%d, but was %d\", t, int(s.length()));\n\n    for (int i = 0; i < t; ++i) {\n        char c = s[i];\n        ensuref(c == 'E' || c == 'S' || c == 'W' || c == 'N',\n            \"Invalid character '%c' in 'wind directions' at position %d (should be 'E', 'S', 'W', or 'N')\", c, i+1);\n    }\n\n    inf.readEof();\n\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int t = opt<int>(\"t\");\n    string type = opt<string>(\"type\", \"random\");\n\n    int sx, sy, ex, ey;\n    string wind;\n\n    if (type == \"reach_at_t\") {\n        sx = rnd.next(-1000, 1000);\n        sy = rnd.next(-1000, 1000);\n\n        int dx_steps = rnd.next(0, t);\n        int dy_steps = t - dx_steps;\n\n        int dir_x = rnd.next(0,1) ? 1 : -1;\n        int dir_y = rnd.next(0,1) ? 1 : -1;\n\n        ex = sx + dx_steps * dir_x;\n        ey = sy + dy_steps * dir_y;\n\n        char dir_x_char = (dir_x == 1) ? 'E' : 'W';\n        char dir_y_char = (dir_y == 1) ? 'N' : 'S';\n\n        vector<char> wind_directions;\n        for (int i = 0; i < dx_steps; i++)\n            wind_directions.push_back(dir_x_char);\n        for (int i = 0; i < dy_steps; i++)\n            wind_directions.push_back(dir_y_char);\n        int remaining = t - (dx_steps + dy_steps);\n        for (int i = 0; i < remaining; i++)\n            wind_directions.push_back(\"NESW\"[rnd.next(0,3)]);\n        shuffle(wind_directions.begin(), wind_directions.end());\n        wind = string(wind_directions.begin(), wind_directions.end());\n\n    } else if (type == \"reach_before_t\") {\n        sx = rnd.next(-1000, 1000);\n        sy = rnd.next(-1000, 1000);\n\n        int min_steps = rnd.next(1, t - 1);\n        int dx_steps = rnd.next(0, min_steps);\n        int dy_steps = min_steps - dx_steps;\n\n        int dir_x = rnd.next(0,1) ? 1 : -1;\n        int dir_y = rnd.next(0,1) ? 1 : -1;\n\n        ex = sx + dx_steps * dir_x;\n        ey = sy + dy_steps * dir_y;\n\n        char dir_x_char = (dir_x == 1) ? 'E' : 'W';\n        char dir_y_char = (dir_y == 1) ? 'N' : 'S';\n\n        wind = \"\";\n        for (int i = 0; i < dx_steps; i++) wind.push_back(dir_x_char);\n        for (int i = 0; i < dy_steps; i++) wind.push_back(dir_y_char);\n        for (int i = dx_steps + dy_steps; i < t; i++)\n            wind.push_back(\"NESW\"[rnd.next(0,3)]);\n\n    } else if (type == \"cannot_reach\") {\n        sx = rnd.next(-1e9 + 1000, 1e9 - 1000);\n        sy = rnd.next(-1e9 + 1000, 1e9 - 1000);\n\n        int min_steps = t + rnd.next(1, 1000);\n        int dx_steps = rnd.next(1, min_steps - 1);\n        int dy_steps = min_steps - dx_steps;\n\n        int dir_x = rnd.next(0,1) ? 1 : -1;\n        int dir_y = rnd.next(0,1) ? 1 : -1;\n\n        ex = sx + dx_steps * dir_x;\n        ey = sy + dy_steps * dir_y;\n\n        wind = \"\";\n        for (int i = 0; i < t; i++)\n            wind.push_back(\"NESW\"[rnd.next(0,3)]);\n\n    } else if (type == \"need_to_wait\") {\n        sx = rnd.next(-1000, 1000);\n        sy = rnd.next(-1000, 1000);\n\n        int dx_steps = rnd.next(1, t/2);\n        int dy_steps = rnd.next(1, t/2);\n\n        int min_steps = dx_steps + dy_steps;\n\n        int dir_x = rnd.next(0,1) ? 1 : -1;\n        int dir_y = rnd.next(0,1) ? 1 : -1;\n\n        ex = sx + dx_steps * dir_x;\n        ey = sy + dy_steps * dir_y;\n\n        char dir_x_char = (dir_x == 1) ? 'E' : 'W';\n        char dir_y_char = (dir_y == 1) ? 'N' : 'S';\n        char opp_dir_x_char = (dir_x == 1) ? 'W' : 'E';\n        char opp_dir_y_char = (dir_y == 1) ? 'S' : 'N';\n\n        vector<char> wind_directions;\n        for (int i = 0; i < dx_steps; i++) wind_directions.push_back(dir_x_char);\n        for (int i = 0; i < dy_steps; i++) wind_directions.push_back(dir_y_char);\n\n        int total_opposing_winds = t - min_steps;\n        for (int i = 0; i < total_opposing_winds; i++)\n            wind_directions.push_back(rnd.next(0,1)? opp_dir_x_char : opp_dir_y_char);\n        shuffle(wind_directions.begin(), wind_directions.end());\n        wind = string(wind_directions.begin(), wind_directions.end());\n\n    } else if (type == \"opposite_wind\") {\n        sx = rnd.next(-1000, 1000);\n        sy = rnd.next(-1000, 1000);\n\n        int dx_steps = rnd.next(1, t/2);\n        int dy_steps = rnd.next(1, t/2);\n\n        int min_steps = dx_steps + dy_steps;\n\n        int dir_x = rnd.next(0,1) ? 1 : -1;\n        int dir_y = rnd.next(0,1) ? 1 : -1;\n\n        ex = sx + dx_steps * dir_x;\n        ey = sy + dy_steps * dir_y;\n\n        char dir_x_char = (dir_x == 1) ? 'E' : 'W';\n        char dir_y_char = (dir_y == 1) ? 'N' : 'S';\n        char opp_dir_x_char = (dir_x == 1) ? 'W' : 'E';\n        char opp_dir_y_char = (dir_y == 1) ? 'S' : 'N';\n\n        wind = \"\";\n        for (int i = 0; i < t - min_steps; i++) {\n            wind.push_back(rnd.next(0,1) ? opp_dir_x_char : opp_dir_y_char);\n        }\n        for (int i = 0; i < dx_steps; i++) wind.push_back(dir_x_char);\n        for (int i = 0; i < dy_steps; i++) wind.push_back(dir_y_char);\n\n        vector<char> wind_directions(wind.begin(), wind.end());\n        shuffle(wind_directions.begin(), wind_directions.end());\n        wind = string(wind_directions.begin(), wind_directions.end());\n\n    } else if (type == \"max_coordinates\") {\n        sx = rnd.next(-1e9, 1e9);\n        sy = rnd.next(-1e9, 1e9);\n        do {\n            ex = rnd.next(-1e9, 1e9);\n            ey = rnd.next(-1e9, 1e9);\n        } while (sx == ex && sy == ey);\n        wind = \"\";\n        for (int i = 0; i < t; i++) {\n            wind.push_back(\"NESW\"[rnd.next(0,3)]);\n        }\n\n    } else { // \"random\" or any other type\n        sx = rnd.next(-1e9, 1e9);\n        sy = rnd.next(-1e9, 1e9);\n        do {\n            ex = rnd.next(-1e9, 1e9);\n            ey = rnd.next(-1e9, 1e9);\n        } while (sx == ex && sy == ey);\n        wind = \"\";\n        for (int i = 0; i < t; i++) {\n            wind.push_back(\"NESW\"[rnd.next(0,3)]);\n        }\n    }\n\n    printf(\"%d %d %d %d %d\\n\", t, sx, sy, ex, ey);\n    printf(\"%s\\n\", wind.c_str());\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int t = opt<int>(\"t\");\n    string type = opt<string>(\"type\", \"random\");\n\n    int sx, sy, ex, ey;\n    string wind;\n\n    if (type == \"reach_at_t\") {\n        sx = rnd.next(-1000, 1000);\n        sy = rnd.next(-1000, 1000);\n\n        int dx_steps = rnd.next(0, t);\n        int dy_steps = t - dx_steps;\n\n        int dir_x = rnd.next(0,1) ? 1 : -1;\n        int dir_y = rnd.next(0,1) ? 1 : -1;\n\n        ex = sx + dx_steps * dir_x;\n        ey = sy + dy_steps * dir_y;\n\n        char dir_x_char = (dir_x == 1) ? 'E' : 'W';\n        char dir_y_char = (dir_y == 1) ? 'N' : 'S';\n\n        vector<char> wind_directions;\n        for (int i = 0; i < dx_steps; i++)\n            wind_directions.push_back(dir_x_char);\n        for (int i = 0; i < dy_steps; i++)\n            wind_directions.push_back(dir_y_char);\n        int remaining = t - (dx_steps + dy_steps);\n        for (int i = 0; i < remaining; i++)\n            wind_directions.push_back(\"NESW\"[rnd.next(0,3)]);\n        shuffle(wind_directions.begin(), wind_directions.end());\n        wind = string(wind_directions.begin(), wind_directions.end());\n\n    } else if (type == \"reach_before_t\") {\n        sx = rnd.next(-1000, 1000);\n        sy = rnd.next(-1000, 1000);\n\n        int min_steps = rnd.next(1, t - 1);\n        int dx_steps = rnd.next(0, min_steps);\n        int dy_steps = min_steps - dx_steps;\n\n        int dir_x = rnd.next(0,1) ? 1 : -1;\n        int dir_y = rnd.next(0,1) ? 1 : -1;\n\n        ex = sx + dx_steps * dir_x;\n        ey = sy + dy_steps * dir_y;\n\n        char dir_x_char = (dir_x == 1) ? 'E' : 'W';\n        char dir_y_char = (dir_y == 1) ? 'N' : 'S';\n\n        wind = \"\";\n        for (int i = 0; i < dx_steps; i++) wind.push_back(dir_x_char);\n        for (int i = 0; i < dy_steps; i++) wind.push_back(dir_y_char);\n        for (int i = dx_steps + dy_steps; i < t; i++)\n            wind.push_back(\"NESW\"[rnd.next(0,3)]);\n\n    } else if (type == \"cannot_reach\") {\n        sx = rnd.next(-1e9 + 1000, 1e9 - 1000);\n        sy = rnd.next(-1e9 + 1000, 1e9 - 1000);\n\n        int min_steps = t + rnd.next(1, 1000);\n        int dx_steps = rnd.next(1, min_steps - 1);\n        int dy_steps = min_steps - dx_steps;\n\n        int dir_x = rnd.next(0,1) ? 1 : -1;\n        int dir_y = rnd.next(0,1) ? 1 : -1;\n\n        ex = sx + dx_steps * dir_x;\n        ey = sy + dy_steps * dir_y;\n\n        wind = \"\";\n        for (int i = 0; i < t; i++)\n            wind.push_back(\"NESW\"[rnd.next(0,3)]);\n\n    } else if (type == \"need_to_wait\") {\n        sx = rnd.next(-1000, 1000);\n        sy = rnd.next(-1000, 1000);\n\n        int dx_steps = rnd.next(1, t/2);\n        int dy_steps = rnd.next(1, t/2);\n\n        int min_steps = dx_steps + dy_steps;\n\n        int dir_x = rnd.next(0,1) ? 1 : -1;\n        int dir_y = rnd.next(0,1) ? 1 : -1;\n\n        ex = sx + dx_steps * dir_x;\n        ey = sy + dy_steps * dir_y;\n\n        char dir_x_char = (dir_x == 1) ? 'E' : 'W';\n        char dir_y_char = (dir_y == 1) ? 'N' : 'S';\n        char opp_dir_x_char = (dir_x == 1) ? 'W' : 'E';\n        char opp_dir_y_char = (dir_y == 1) ? 'S' : 'N';\n\n        vector<char> wind_directions;\n        for (int i = 0; i < dx_steps; i++) wind_directions.push_back(dir_x_char);\n        for (int i = 0; i < dy_steps; i++) wind_directions.push_back(dir_y_char);\n\n        int total_opposing_winds = t - min_steps;\n        for (int i = 0; i < total_opposing_winds; i++)\n            wind_directions.push_back(rnd.next(0,1)? opp_dir_x_char : opp_dir_y_char);\n        shuffle(wind_directions.begin(), wind_directions.end());\n        wind = string(wind_directions.begin(), wind_directions.end());\n\n    } else if (type == \"opposite_wind\") {\n        sx = rnd.next(-1000, 1000);\n        sy = rnd.next(-1000, 1000);\n\n        int dx_steps = rnd.next(1, t/2);\n        int dy_steps = rnd.next(1, t/2);\n\n        int min_steps = dx_steps + dy_steps;\n\n        int dir_x = rnd.next(0,1) ? 1 : -1;\n        int dir_y = rnd.next(0,1) ? 1 : -1;\n\n        ex = sx + dx_steps * dir_x;\n        ey = sy + dy_steps * dir_y;\n\n        char dir_x_char = (dir_x == 1) ? 'E' : 'W';\n        char dir_y_char = (dir_y == 1) ? 'N' : 'S';\n        char opp_dir_x_char = (dir_x == 1) ? 'W' : 'E';\n        char opp_dir_y_char = (dir_y == 1) ? 'S' : 'N';\n\n        wind = \"\";\n        for (int i = 0; i < t - min_steps; i++) {\n            wind.push_back(rnd.next(0,1) ? opp_dir_x_char : opp_dir_y_char);\n        }\n        for (int i = 0; i < dx_steps; i++) wind.push_back(dir_x_char);\n        for (int i = 0; i < dy_steps; i++) wind.push_back(dir_y_char);\n\n        vector<char> wind_directions(wind.begin(), wind.end());\n        shuffle(wind_directions.begin(), wind_directions.end());\n        wind = string(wind_directions.begin(), wind_directions.end());\n\n    } else if (type == \"max_coordinates\") {\n        sx = rnd.next(-1e9, 1e9);\n        sy = rnd.next(-1e9, 1e9);\n        do {\n            ex = rnd.next(-1e9, 1e9);\n            ey = rnd.next(-1e9, 1e9);\n        } while (sx == ex && sy == ey);\n        wind = \"\";\n        for (int i = 0; i < t; i++) {\n            wind.push_back(\"NESW\"[rnd.next(0,3)]);\n        }\n\n    } else { // \"random\" or any other type\n        sx = rnd.next(-1e9, 1e9);\n        sy = rnd.next(-1e9, 1e9);\n        do {\n            ex = rnd.next(-1e9, 1e9);\n            ey = rnd.next(-1e9, 1e9);\n        } while (sx == ex && sy == ey);\n        wind = \"\";\n        for (int i = 0; i < t; i++) {\n            wind.push_back(\"NESW\"[rnd.next(0,3)]);\n        }\n    }\n\n    printf(\"%d %d %d %d %d\\n\", t, sx, sy, ex, ey);\n    printf(\"%s\\n\", wind.c_str());\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# t = 1\n./gen -t 1 -type reach_at_t\n./gen -t 1 -type cannot_reach\n./gen -t 1 -type max_coordinates\n\n# t = 2\n./gen -t 2 -type reach_at_t\n./gen -t 2 -type cannot_reach\n./gen -t 2 -type reach_before_t\n./gen -t 2 -type need_to_wait\n\n# t = 10\n./gen -t 10 -type reach_at_t\n./gen -t 10 -type need_to_wait\n\n# t = 100\n./gen -t 100 -type reach_before_t\n./gen -t 100 -type opposite_wind\n\n# t = 1000\n./gen -t 1000 -type reach_at_t\n./gen -t 1000 -type reach_before_t\n./gen -t 1000 -type need_to_wait\n./gen -t 1000 -type opposite_wind\n./gen -t 1000 -type cannot_reach\n./gen -t 1000 -type max_coordinates\n./gen -t 1000 -type random\n\n# t = 10000\n./gen -t 10000 -type reach_before_t\n./gen -t 10000 -type max_coordinates\n\n# t = 50000\n./gen -t 50000 -type reach_at_t\n./gen -t 50000 -type reach_before_t\n./gen -t 50000 -type cannot_reach\n./gen -t 50000 -type need_to_wait\n./gen -t 50000 -type opposite_wind\n./gen -t 50000 -type max_coordinates\n./gen -t 50000 -type random\n\n# t = 99999\n./gen -t 99999 -type random\n./gen -t 99999 -type cannot_reach\n./gen -t 99999 -type reach_before_t\n\n# t = 100000\n./gen -t 100000 -type reach_at_t\n./gen -t 100000 -type need_to_wait\n./gen -t 100000 -type opposite_wind\n./gen -t 100000 -type random\n./gen -t 100000 -type cannot_reach\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:04:18.955221",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "298/C",
      "title": "C. Игра на четность",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест1 секунда",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеПервая строка содержит строку a, а вторая строка содержит строку b (1 ≤ |a|, |b| ≤ 1000). Обе строки содержат только символы «0» и «1». Здесь |x| обозначает длину строки x.",
      "output_spec": "Выходные данныеВыведите «YES» (без кавычек), если возможно трансформировать a в b, и «NO» (без кавычек) в противном случае.",
      "sample_tests": "ПримерыВходные данныеСкопировать010110110Выходные данныеСкопироватьYESВходные данныеСкопировать00111110Выходные данныеСкопироватьNO",
      "description": "C. Игра на четность\n\nограничение по времени на тест1 секунда\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвыводstdout\n\nВходные данныеПервая строка содержит строку a, а вторая строка содержит строку b (1 ≤ |a|, |b| ≤ 1000). Обе строки содержат только символы «0» и «1». Здесь |x| обозначает длину строки x.\n\nВходные данные\n\nВыходные данныеВыведите «YES» (без кавычек), если возможно трансформировать a в b, и «NO» (без кавычек) в противном случае.\n\nВыходные данные\n\nВходные данныеСкопировать010110110Выходные данныеСкопироватьYESВходные данныеСкопировать00111110Выходные данныеСкопироватьNO\n\nВходные данныеСкопировать010110110\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопироватьYES\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать00111110\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопироватьNO\n\nВыходные данныеСкопировать\n\nСкопировать\n\nПримечаниеВ первом примере действия следующие: 01011 → 1011 → 011 → 0110",
      "solutions": [
        {
          "title": "Codeforces Round #180 - Codeforces",
          "content": "Всем привет,CodeForces 180 начнется 19.04.2013 19:30 (MSK). Я (SteamTurbine), и Ivan Li (AEtheReal) являемся авторами сегодняшнего раунда.В этот раз вы будете помогать полярным медведям решать их проблемы. Вы знаете, жизнь в Арктике не проста, поэтому они могут столкнуться с совершенно разными проблемами, например: ловля рыбы, сохранение тепла и тому подобное.Спасибо Gerald за помощь в подготовке раунда и MikeMirzayanov за его великолепную систему, а также Delinur за перевод.Мы надеемся, что полярные медведи вдруг не решат съесть вас. Удачи.UPD: Разбалловка будет динамической. Задачи расположены в соответствии с предполагаемой сложностью.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/7390",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 646
        },
        {
          "title": "Codeforces Round #180 Editorial - Codeforces",
          "content": "298A - Snow FootprintsThe starting position can be anywhere with a footprint. The footprints can be categorized into 3 types. only L s only R s R s followed by L s In case 1, we end in the left of all footprints. In case 2, we end in the right of all footprints. In case 3, we either end in the rightmost R or the leftmost L298B - SailWe can simply move by greedy method — only moves when it takes the boat closer to the destination.297A - Parity GameObv 1: If a has odd parity, we can apply operation 1 to increase its number of 1s by 1.Obv 2: If a has even parity, its number of 1s cannot increase anymore.Claim: If the number of 1s in a is not fewer than those in b, we can always turn a to bThe idea is to make a copy of b at the right of a. Lets assume a starts with even parity. If we need a 0, simply apply operation 1. If we need a 1, keep remove from the head until we removed an 1. Notice that we never remove digits from 'new part' of a. Now the parity of a will be odd and we can apply operation 1. After that, the parity of a becomes even again, the number of 1 in the 'old part' of a decrease by 1 and we handle a 1 in b. Finally, remove the remaining old part of a and we get b.Combine all those facts, we can conclude that we can turn a into b if and only if countOnes(a) + parity(countOnes(a)) ≥ countOnes(b)297B - Fish WeightFirst we sort a and b in non-increasing order. We claim that the answer is YES if and only if exists a is lexicographically larger than b. If a is not lexicographcally larger than b, that means for every i, ai ≤ bi. That implies for every fish Alice has, there is a corresponding fish Bob has and is as heavy as Alice's. Let i be the smallest index such that ai > bi. We can amplify the gap between wai and wbi as large as we want to make Alice wins.297C - Splitting the UniquenessAn equivalent definition for almost unique, is an array with at least ⌊ 2n / 3⌋ different elements. The idea is to split s into three parts: In the first part, we give uniqueness to a. In the second part, we give uniqueness to b. In the third part, we give uniqueness to both.Lets assume s is sorted. Since s is an unique array, we know si ≥ i for all i (0-based). The image below will give some intuition on how we are going to split it. a is red, b is blue, the length of the bar represent the magnitude of the number. In the first and second part, we do not care about the array that we are not giving uniqueness to.For exampmle, if n = 30:i = 0... 9:  assign ai = i (do not care values of b)i = 10... 19:  assign bi = i (do not care values of a)i = 20... 29:  assign bi = 29 - i and set ai = si - bi. From i = 20, a will have strictly increasing values starting from at least 11.297D - Color the CarpetFor k = 1 there is only one coloring so we just need to check the number of  =  constraints. When k ≥ 2, it turns out that using only 2 colors is always sufficient to satisfy at least 3 / 4 of the constraints.Lets assume w ≥ h (rotate if not). We will call the constraints that involves cells in different row \"vertical constraints\", and similar for \"horizontal constraints\".First we color the first row such that all horizontal constraints in row 1 are satisfied. We will color the remaining rows one by one.To color row i, first we color it such that all horizontal constraints in row i are satisfied. Then consider the vertical constraints between row i and row i - 1. Count the number of satisfied and unsatisfied vertical constraints. If there are more unsatisfied constraints than satisfied constraints, flip the coloring of row i. Flipping a row means turning 2211212 → 1122121, for example.If we flip the coloring of row i, all horizontal constraints in row i are still satisfied, but for the vertical constraints between row i and row i - 1, satisfied will turn to unsatisfied, unsatisfied will turn to satisfied. Therefore, we can always satisfy at least half the vertical constraints between row i and row i - 1.The number of unsatisfied constraints is at most (h - 1) × ⌊ w / 2⌋, which is at most 1 / 4 of the total number of constraints (recall w ≥ h).297E - Mystic CarvingsProblem and editorial written by AEtheReal. Link to editorial.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/7437",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.6,
            "reason": "宽松匹配: 包含题目编号 298 和字母"
          },
          "content_length": 4179
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #180 - Codeforces - Code 1",
          "code": "0 # 0 # ... # 0 # 1 # 2 # ... #   k-1 #   k\n# 0 # 0 ... 0 # 0 # 1 # 2 ... k-2 #   k-1 #",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7390",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #180 - Codeforces - Code 2",
          "code": "k = (n+2)/3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7390",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #180 - Codeforces - Code 3",
          "code": "s[i] = a[i] + b[i]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7390",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #180 - Codeforces - Code 4",
          "code": "x x x  x x x  x x x",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7390",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #180 - Codeforces - Code 5",
          "code": "0 1 2  3 4 5  6 7 8",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7390",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #180 - Codeforces - Code 6",
          "code": "x x x  0 0 0  x x x",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7390",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #180 - Codeforces - Code 7",
          "code": "0 1 2  0 0 0  4 6 8",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7390",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #180 - Codeforces - Code 8",
          "code": "0 0 0  x x x  2 1 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7390",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #180 - Codeforces - Code 9",
          "code": "0 0 0  3 4 5  2 1 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7390",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #180 - Codeforces - Code 10",
          "code": "for (long i=a1-1;i--;i>=0)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7390",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #180 - Codeforces - Code 11",
          "code": "for (long i=a1-1;i>=0;i--)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7390",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #180 - Codeforces - Code 12",
          "code": "Those bears were a real pain in the brain....",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7390",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #180 - Codeforces - Code 13",
          "code": "pivot = a[(left+right)/2]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7390",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #180 - Codeforces - Code 14",
          "code": "ai>= 0 && bi >= 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7390",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    string a = inf.readLine(\"[01]{1,1000}\", \"a\");\n    string b = inf.readLine(\"[01]{1,1000}\", \"b\");\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    string a = inf.readLine(\"[01]{1,1000}\", \"a\");\n    string b = inf.readLine(\"[01]{1,1000}\", \"b\");\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    string a = inf.readLine(\"[01]{1,1000}\", \"a\");\n    string b = inf.readLine(\"[01]{1,1000}\", \"b\");\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n#include <string>\r\n\r\nusing namespace std;\r\n\r\nconst string YES = \"YES\";\r\nconst string NO = \"NO\";\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"%s\", (\"multiple \" + YES + \"/\" + NO + \" (case insensitive)\").c_str());\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int index = 0, yesCount = 0, noCount = 0;\r\n    string pa;\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        index++;\r\n        string ja = upperCase(ans.readToken());\r\n        pa = upperCase(ouf.readToken());\r\n\r\n        if (ja != YES && ja != NO)\r\n            quitf(_fail, \"%s or %s expected in answer, but %s found [%d%s token]\",\r\n                  YES.c_str(), NO.c_str(), compress(ja).c_str(), index, englishEnding(index).c_str());\r\n\r\n        if (pa == YES)\r\n            yesCount++;\r\n        else if (pa == NO)\r\n            noCount++;\r\n        else\r\n            quitf(_pe, \"%s or %s expected, but %s found [%d%s token]\",\r\n                  YES.c_str(), NO.c_str(), compress(pa).c_str(), index, englishEnding(index).c_str());\r\n\r\n        if (ja != pa)\r\n            quitf(_wa, \"expected %s, found %s [%d%s token]\",\r\n                  compress(ja).c_str(), compress(pa).c_str(), index, englishEnding(index).c_str());\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n    while (!ans.seekEof()) {\r\n        ans.readToken();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n    while (!ouf.seekEof()) {\r\n        ouf.readToken();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              index + extraInAnsCount, index);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              index + extraInOufCount, index);\r\n\r\n    if (index == 0)\r\n        quitf(_ok, \"Empty output\");\r\n    else if (index == 1)\r\n        quitf(_ok, \"%s\", pa.c_str());\r\n    else\r\n        quitf(_ok, \"%d token(s): yes count is %d, no count is %d\", index, yesCount, noCount);\r\n\r\n    quitf(_fail, \"Impossible case\");\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\", n);\n    string type = opt<string>(\"type\", \"random\");\n\n    string a, b;\n\n    if (type == \"yes\") {\n        // Generate a random a of length n\n        a = \"\";\n        for (int i = 0; i < n; ++i) {\n            a += rnd.next(2) ? '1' : '0';\n        }\n        // Simulate removing the first k characters\n        int k = rnd.next(0, n);\n        string s = a.substr(k);\n        // Append parity(s) until length >= m\n        while ((int)s.length() < m) {\n            int ones = count(s.begin(), s.end(), '1');\n            char parity = (ones % 2 == 0) ? '0' : '1';\n            s += parity;\n        }\n        b = s.substr(0, m);\n    } else if (type == \"no\") {\n        a = \"\";\n        for (int i = 0; i < n; ++i)\n            a += rnd.next(2) ? '1' : '0';\n        \n        // Generate b that cannot be obtained from any suffix of a\n        bool found = false;\n        int trials = 0;\n        while (!found && trials < 100) {\n            b = \"\";\n            for (int i = 0; i < m; ++i)\n                b += rnd.next(2) ? '1' : '0';\n            \n            bool possible = false;\n            for (int k = 0; k <= n; ++k) {\n                string s = a.substr(k);\n                string tmp = s;\n                int index = 0;\n                while (index < (int)b.length()) {\n                    if (index >= (int)tmp.length()) {\n                        int ones = count(tmp.begin(), tmp.end(), '1');\n                        char parity = (ones % 2 == 0) ? '0' : '1';\n                        tmp += parity;\n                    }\n                    if (tmp[index] != b[index]) {\n                        break;\n                    }\n                    index++;\n                }\n                if (index == (int)b.length()) {\n                    possible = true;\n                    break;\n                }\n            }\n            if (!possible)\n                found = true;\n            else\n                ++trials;\n        }\n        if (!found) {\n            // If failed to generate a 'no' case, modify a and b\n            a = \"0\" + a.substr(1);\n            b = \"1\" + b.substr(1);\n        }\n    } else if (type == \"random\") {\n        // Generate random strings a and b of length n and m\n        a = \"\";\n        b = \"\";\n        for (int i = 0; i < n; ++i) {\n            a += rnd.next(2) ? '1' : '0';\n        }\n        for (int i = 0; i < m; ++i) {\n            b += rnd.next(2) ? '1' : '0';\n        }\n    } else if (type == \"same\") {\n        a = \"\";\n        for (int i = 0; i < n; ++i) {\n            a += rnd.next(2) ? '1' : '0';\n        }\n        b = a;\n    } else {\n        cerr << \"Unknown type: \" << type << endl;\n        return 1;\n    }\n\n    // Output a and b\n    printf(\"%s\\n\", a.c_str());\n    printf(\"%s\\n\", b.c_str());\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\", n);\n    string type = opt<string>(\"type\", \"random\");\n\n    string a, b;\n\n    if (type == \"yes\") {\n        // Generate a random a of length n\n        a = \"\";\n        for (int i = 0; i < n; ++i) {\n            a += rnd.next(2) ? '1' : '0';\n        }\n        // Simulate removing the first k characters\n        int k = rnd.next(0, n);\n        string s = a.substr(k);\n        // Append parity(s) until length >= m\n        while ((int)s.length() < m) {\n            int ones = count(s.begin(), s.end(), '1');\n            char parity = (ones % 2 == 0) ? '0' : '1';\n            s += parity;\n        }\n        b = s.substr(0, m);\n    } else if (type == \"no\") {\n        a = \"\";\n        for (int i = 0; i < n; ++i)\n            a += rnd.next(2) ? '1' : '0';\n        \n        // Generate b that cannot be obtained from any suffix of a\n        bool found = false;\n        int trials = 0;\n        while (!found && trials < 100) {\n            b = \"\";\n            for (int i = 0; i < m; ++i)\n                b += rnd.next(2) ? '1' : '0';\n            \n            bool possible = false;\n            for (int k = 0; k <= n; ++k) {\n                string s = a.substr(k);\n                string tmp = s;\n                int index = 0;\n                while (index < (int)b.length()) {\n                    if (index >= (int)tmp.length()) {\n                        int ones = count(tmp.begin(), tmp.end(), '1');\n                        char parity = (ones % 2 == 0) ? '0' : '1';\n                        tmp += parity;\n                    }\n                    if (tmp[index] != b[index]) {\n                        break;\n                    }\n                    index++;\n                }\n                if (index == (int)b.length()) {\n                    possible = true;\n                    break;\n                }\n            }\n            if (!possible)\n                found = true;\n            else\n                ++trials;\n        }\n        if (!found) {\n            // If failed to generate a 'no' case, modify a and b\n            a = \"0\" + a.substr(1);\n            b = \"1\" + b.substr(1);\n        }\n    } else if (type == \"random\") {\n        // Generate random strings a and b of length n and m\n        a = \"\";\n        b = \"\";\n        for (int i = 0; i < n; ++i) {\n            a += rnd.next(2) ? '1' : '0';\n        }\n        for (int i = 0; i < m; ++i) {\n            b += rnd.next(2) ? '1' : '0';\n        }\n    } else if (type == \"same\") {\n        a = \"\";\n        for (int i = 0; i < n; ++i) {\n            a += rnd.next(2) ? '1' : '0';\n        }\n        b = a;\n    } else {\n        cerr << \"Unknown type: \" << type << endl;\n        return 1;\n    }\n\n    // Output a and b\n    printf(\"%s\\n\", a.c_str());\n    printf(\"%s\\n\", b.c_str());\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -m 1 -type random\n./gen -n 1 -m 1 -type yes\n./gen -n 1 -m 1 -type no\n\n./gen -n 2 -m 2 -type random\n./gen -n 2 -m 2 -type yes\n./gen -n 2 -m 2 -type no\n\n./gen -n 10 -m 10 -type random\n./gen -n 10 -m 15 -type yes\n./gen -n 10 -m 5 -type yes\n./gen -n 10 -m 15 -type no\n./gen -n 10 -m 5 -type no\n\n./gen -n 100 -m 100 -type random\n./gen -n 100 -m 200 -type yes\n./gen -n 100 -m 50 -type yes\n./gen -n 100 -m 200 -type no\n./gen -n 100 -m 50 -type no\n\n./gen -n 500 -m 500 -type random\n./gen -n 500 -m 1000 -type yes\n./gen -n 500 -m 1000 -type no\n\n./gen -n 1000 -m 1000 -type random\n./gen -n 1000 -m 1000 -type same\n\n./gen -n 1000 -m 1500 -type yes\n./gen -n 1000 -m 1500 -type no\n\n./gen -n 1000 -m 1000 -type yes\n./gen -n 1000 -m 1000 -type no\n\n./gen -n 1000 -m 10 -type yes\n./gen -n 1000 -m 10 -type no\n\n./gen -n 1 -m 1000 -type yes\n./gen -n 1 -m 1000 -type no\n\n./gen -n 999 -m 1000 -type random\n\n./gen -n 1000 -type random\n\n./gen -n 1000 -type yes\n\n./gen -n 1000 -type no\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:04:21.060645",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "298/D",
      "title": "D. Fish Weight",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains three integers n, m, k (1 ≤ n, m ≤ 105, 1 ≤ k ≤ 109) — the number of fish caught by Alice and Bob respectively, and the number of fish species.The second line contains n integers each from 1 to k, the list of fish type caught by Alice. The third line contains m integers each from 1 to k, the list of fish type caught by Bob.Note that one may have caught more than one fish for a same species.",
      "output_spec": "OutputOutput \"YES\" (without quotes) if it is possible, and \"NO\" (without quotes) otherwise.",
      "sample_tests": "ExamplesInputCopy3 3 32 2 21 1 3OutputCopyYESInputCopy4 7 95 2 7 33 5 2 7 3 8 7OutputCopyNO",
      "description": "D. Fish Weight\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains three integers n, m, k (1 ≤ n, m ≤ 105, 1 ≤ k ≤ 109) — the number of fish caught by Alice and Bob respectively, and the number of fish species.The second line contains n integers each from 1 to k, the list of fish type caught by Alice. The third line contains m integers each from 1 to k, the list of fish type caught by Bob.Note that one may have caught more than one fish for a same species.\n\nOutputOutput \"YES\" (without quotes) if it is possible, and \"NO\" (without quotes) otherwise.\n\nInputCopy3 3 32 2 21 1 3OutputCopyYESInputCopy4 7 95 2 7 33 5 2 7 3 8 7OutputCopyNO\n\nInputCopy3 3 32 2 21 1 3\n\nOutputCopyYES\n\nInputCopy4 7 95 2 7 33 5 2 7 3 8 7\n\nOutputCopyNO\n\nNoteIn the first sample, if w1 = 1, w2 = 2, w3 = 2.5,  then Alice has a total of 2 + 2 + 2 = 6 weight units, while Bob only has 1 + 1 + 2.5 = 4.5.In the second sample, the fish that Alice caught is a subset of Bob's. Therefore, the total weight of Bob’s fish is always not less than the total weight of Alice’s fish.",
      "solutions": [
        {
          "title": "Codeforces Round #180 - Codeforces",
          "content": "Hi all!CodeForces 180 will take place at 19/4 17:30 (CEST). I (SteamTurbine), and Ivan Li (AEtheReal) are the authors of the round.This time you will need to help some polar bears to solve their problems. You know, life in the arctic is hard, they may face difficulties about catching fish, keeping warm etc.Thanks Gerald for helping us to prepare the round, MikeMirzayanov for the great platform and Delinur for translation.We hope that the polar bears are not going to eat you. Good Luck.UPD: Scoring will be dynamic. Problems are sorted by increasing order of difficulty.Editorial is here(All except Div 1 E) and here(Div 1 E).Result (div1): tourist (Solved all!) wjmsbmr tckwok0 msg555 Erop Result (div2): Parsa.pordel a88027180 Raoul Some fun facts:In 297E - Mystic Carvings (written by AEtheReal), the figure in the problem looks like the facial expression \"XD\" and \"囧\", which is done intentionally.Moreover, three lines can intersect in the following 5 ways:While discussing the problem, we refer those as \"川\", \"囧\", \"XD\", \"卄\" and \"△\". Chinese characters are interesting :)",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/7390",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1079
        },
        {
          "title": "Codeforces Round #180 Editorial - Codeforces",
          "content": "298A - Snow FootprintsThe starting position can be anywhere with a footprint. The footprints can be categorized into 3 types. only L s only R s R s followed by L s In case 1, we end in the left of all footprints. In case 2, we end in the right of all footprints. In case 3, we either end in the rightmost R or the leftmost L298B - SailWe can simply move by greedy method — only moves when it takes the boat closer to the destination.297A - Parity GameObv 1: If a has odd parity, we can apply operation 1 to increase its number of 1s by 1.Obv 2: If a has even parity, its number of 1s cannot increase anymore.Claim: If the number of 1s in a is not fewer than those in b, we can always turn a to bThe idea is to make a copy of b at the right of a. Lets assume a starts with even parity. If we need a 0, simply apply operation 1. If we need a 1, keep remove from the head until we removed an 1. Notice that we never remove digits from 'new part' of a. Now the parity of a will be odd and we can apply operation 1. After that, the parity of a becomes even again, the number of 1 in the 'old part' of a decrease by 1 and we handle a 1 in b. Finally, remove the remaining old part of a and we get b.Combine all those facts, we can conclude that we can turn a into b if and only if countOnes(a) + parity(countOnes(a)) ≥ countOnes(b)297B - Fish WeightFirst we sort a and b in non-increasing order. We claim that the answer is YES if and only if exists a is lexicographically larger than b. If a is not lexicographcally larger than b, that means for every i, ai ≤ bi. That implies for every fish Alice has, there is a corresponding fish Bob has and is as heavy as Alice's. Let i be the smallest index such that ai > bi. We can amplify the gap between wai and wbi as large as we want to make Alice wins.297C - Splitting the UniquenessAn equivalent definition for almost unique, is an array with at least ⌊ 2n / 3⌋ different elements. The idea is to split s into three parts: In the first part, we give uniqueness to a. In the second part, we give uniqueness to b. In the third part, we give uniqueness to both.Lets assume s is sorted. Since s is an unique array, we know si ≥ i for all i (0-based). The image below will give some intuition on how we are going to split it. a is red, b is blue, the length of the bar represent the magnitude of the number. In the first and second part, we do not care about the array that we are not giving uniqueness to.For exampmle, if n = 30:i = 0... 9:  assign ai = i (do not care values of b)i = 10... 19:  assign bi = i (do not care values of a)i = 20... 29:  assign bi = 29 - i and set ai = si - bi. From i = 20, a will have strictly increasing values starting from at least 11.297D - Color the CarpetFor k = 1 there is only one coloring so we just need to check the number of  =  constraints. When k ≥ 2, it turns out that using only 2 colors is always sufficient to satisfy at least 3 / 4 of the constraints.Lets assume w ≥ h (rotate if not). We will call the constraints that involves cells in different row \"vertical constraints\", and similar for \"horizontal constraints\".First we color the first row such that all horizontal constraints in row 1 are satisfied. We will color the remaining rows one by one.To color row i, first we color it such that all horizontal constraints in row i are satisfied. Then consider the vertical constraints between row i and row i - 1. Count the number of satisfied and unsatisfied vertical constraints. If there are more unsatisfied constraints than satisfied constraints, flip the coloring of row i. Flipping a row means turning 2211212 → 1122121, for example.If we flip the coloring of row i, all horizontal constraints in row i are still satisfied, but for the vertical constraints between row i and row i - 1, satisfied will turn to unsatisfied, unsatisfied will turn to satisfied. Therefore, we can always satisfy at least half the vertical constraints between row i and row i - 1.The number of unsatisfied constraints is at most (h - 1) × ⌊ w / 2⌋, which is at most 1 / 4 of the total number of constraints (recall w ≥ h).297E - Mystic CarvingsProblem and editorial written by AEtheReal. Link to editorial.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/7437",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.6,
            "reason": "宽松匹配: 包含题目编号 298 和字母"
          },
          "content_length": 4179
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #180 - Codeforces - Code 1",
          "code": "Those bears were a real pain in the brain....",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7390",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #180 - Codeforces - Code 2",
          "code": "pivot = a[(left+right)/2]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7390",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #180 - Codeforces - Code 3",
          "code": "ai>= 0 && bi >= 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7390",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 100000, \"m\");\n    inf.readSpace();\n    int k = inf.readInt(1, 1000000000, \"k\");\n    inf.readEoln();\n\n    vector<int> aliceFish = inf.readInts(n, 1, k, \"aliceFish\");\n    inf.readEoln();\n\n    vector<int> bobFish = inf.readInts(m, 1, k, \"bobFish\");\n    inf.readEoln();\n\n    inf.readEof();\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 100000, \"m\");\n    inf.readSpace();\n    int k = inf.readInt(1, 1000000000, \"k\");\n    inf.readEoln();\n\n    vector<int> aliceFish = inf.readInts(n, 1, k, \"aliceFish\");\n    inf.readEoln();\n\n    vector<int> bobFish = inf.readInts(m, 1, k, \"bobFish\");\n    inf.readEoln();\n\n    inf.readEof();\n\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 100000, \"m\");\n    inf.readSpace();\n    int k = inf.readInt(1, 1000000000, \"k\");\n    inf.readEoln();\n\n    vector<int> aliceFish = inf.readInts(n, 1, k, \"aliceFish\");\n    inf.readEoln();\n\n    vector<int> bobFish = inf.readInts(m, 1, k, \"bobFish\");\n    inf.readEoln();\n\n    inf.readEof();\n\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n#include <string>\r\n\r\nusing namespace std;\r\n\r\nconst string YES = \"YES\";\r\nconst string NO = \"NO\";\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"%s\", (\"multiple \" + YES + \"/\" + NO + \" (case insensitive)\").c_str());\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int index = 0, yesCount = 0, noCount = 0;\r\n    string pa;\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        index++;\r\n        string ja = upperCase(ans.readToken());\r\n        pa = upperCase(ouf.readToken());\r\n\r\n        if (ja != YES && ja != NO)\r\n            quitf(_fail, \"%s or %s expected in answer, but %s found [%d%s token]\",\r\n                  YES.c_str(), NO.c_str(), compress(ja).c_str(), index, englishEnding(index).c_str());\r\n\r\n        if (pa == YES)\r\n            yesCount++;\r\n        else if (pa == NO)\r\n            noCount++;\r\n        else\r\n            quitf(_pe, \"%s or %s expected, but %s found [%d%s token]\",\r\n                  YES.c_str(), NO.c_str(), compress(pa).c_str(), index, englishEnding(index).c_str());\r\n\r\n        if (ja != pa)\r\n            quitf(_wa, \"expected %s, found %s [%d%s token]\",\r\n                  compress(ja).c_str(), compress(pa).c_str(), index, englishEnding(index).c_str());\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n    while (!ans.seekEof()) {\r\n        ans.readToken();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n    while (!ouf.seekEof()) {\r\n        ouf.readToken();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              index + extraInAnsCount, index);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              index + extraInOufCount, index);\r\n\r\n    if (index == 0)\r\n        quitf(_ok, \"Empty output\");\r\n    else if (index == 1)\r\n        quitf(_ok, \"%s\", pa.c_str());\r\n    else\r\n        quitf(_ok, \"%d token(s): yes count is %d, no count is %d\", index, yesCount, noCount);\r\n\r\n    quitf(_fail, \"Impossible case\");\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    int k = opt<int>(\"k\");\n    string type = opt<string>(\"type\", \"random\");\n\n    // Ensure that n, m, k are within the constraints\n    ensure(1 <= n && n <= 100000);\n    ensure(1 <= m && m <= 100000);\n    ensure(1 <= k && k <= 1000000000);\n\n    vector<int> a(n), b(m);\n\n    if (type == \"random\") {\n        // Generate random fish types for Alice and Bob\n        for (int i = 0; i < n; ++i)\n            a[i] = rnd.next(1, k);\n        for (int i = 0; i < m; ++i)\n            b[i] = rnd.next(1, k);\n    } else if (type == \"AliceSubsetBob\") {\n        // Generate fish types such that Alice's fish types are a subset of Bob's fish types\n        set<int> bob_fish_types;\n        for (int i = 0; i < m; ++i) {\n            b[i] = rnd.next(1, k);\n            bob_fish_types.insert(b[i]);\n        }\n        vector<int> bob_fish_vec(bob_fish_types.begin(), bob_fish_types.end());\n        for (int i = 0; i < n; ++i) {\n            a[i] = bob_fish_vec[rnd.next(0, (int)bob_fish_vec.size() - 1)];\n        }\n    } else if (type == \"BobSubsetAlice\") {\n        // Generate fish types such that Bob's fish types are a subset of Alice's fish types\n        set<int> alice_fish_types;\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, k);\n            alice_fish_types.insert(a[i]);\n        }\n        vector<int> alice_fish_vec(alice_fish_types.begin(), alice_fish_types.end());\n        for (int i = 0; i < m; ++i) {\n            b[i] = alice_fish_vec[rnd.next(0, (int)alice_fish_vec.size() - 1)];\n        }\n    } else if (type == \"SameFish\") {\n        // Generate the same fish types for Alice and Bob\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, k);\n        }\n        b = a;\n        for (int i = n; i < m; ++i) {\n            b.push_back(rnd.next(1, k));\n        }\n        shuffle(b.begin(), b.end());\n    } else if (type == \"AliceHighBobLow\") {\n        // Alice's fish types have higher numbers, Bob's have lower numbers\n        int mid = k / 2;\n        if (k == 1) mid = 1;\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(mid + 1, k);\n        }\n        for (int i = 0; i < m; ++i) {\n            b[i] = rnd.next(1, mid);\n        }\n    } else if (type == \"AliceLowBobHigh\") {\n        // Alice's fish types have lower numbers, Bob's have higher numbers\n        int mid = k / 2;\n        if (k == 1) mid = 1;\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, mid);\n        }\n        for (int i = 0; i < m; ++i) {\n            b[i] = rnd.next(mid + 1, k);\n        }\n    } else if (type == \"MaxValues\") {\n        // n, m, k at maximum limits\n        for (int i = 0; i < n; ++i)\n            a[i] = rnd.next(1, k);\n        for (int i = 0; i < m; ++i)\n            b[i] = rnd.next(1, k);\n    } else if (type == \"MinValues\") {\n        // n, m, k at minimum values\n        a[0] = 1;\n        b[0] = 1;\n    } else if (type == \"AliceEqualsBob\") {\n        // Alice and Bob have exactly the same fish types\n        for (int i = 0; i < n; ++i)\n            a[i] = rnd.next(1, k);\n        b = a;\n        for (int i = n; i < m; ++i)\n            b.push_back(rnd.next(1, k));\n    } else {\n        // Default to random\n        for (int i = 0; i < n; ++i)\n            a[i] = rnd.next(1, k);\n        for (int i = 0; i < m; ++i)\n            b[i] = rnd.next(1, k);\n    }\n\n    // Output the test case\n    printf(\"%d %d %d\\n\", n, m, k);\n    for (int i = 0; i < n; ++i)\n        printf(\"%d%c\", a[i], i == n - 1 ? '\\n' : ' ');\n    for (int i = 0; i < m; ++i)\n        printf(\"%d%c\", b[i], i == m - 1 ? '\\n' : ' ');\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    int k = opt<int>(\"k\");\n    string type = opt<string>(\"type\", \"random\");\n\n    // Ensure that n, m, k are within the constraints\n    ensure(1 <= n && n <= 100000);\n    ensure(1 <= m && m <= 100000);\n    ensure(1 <= k && k <= 1000000000);\n\n    vector<int> a(n), b(m);\n\n    if (type == \"random\") {\n        // Generate random fish types for Alice and Bob\n        for (int i = 0; i < n; ++i)\n            a[i] = rnd.next(1, k);\n        for (int i = 0; i < m; ++i)\n            b[i] = rnd.next(1, k);\n    } else if (type == \"AliceSubsetBob\") {\n        // Generate fish types such that Alice's fish types are a subset of Bob's fish types\n        set<int> bob_fish_types;\n        for (int i = 0; i < m; ++i) {\n            b[i] = rnd.next(1, k);\n            bob_fish_types.insert(b[i]);\n        }\n        vector<int> bob_fish_vec(bob_fish_types.begin(), bob_fish_types.end());\n        for (int i = 0; i < n; ++i) {\n            a[i] = bob_fish_vec[rnd.next(0, (int)bob_fish_vec.size() - 1)];\n        }\n    } else if (type == \"BobSubsetAlice\") {\n        // Generate fish types such that Bob's fish types are a subset of Alice's fish types\n        set<int> alice_fish_types;\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, k);\n            alice_fish_types.insert(a[i]);\n        }\n        vector<int> alice_fish_vec(alice_fish_types.begin(), alice_fish_types.end());\n        for (int i = 0; i < m; ++i) {\n            b[i] = alice_fish_vec[rnd.next(0, (int)alice_fish_vec.size() - 1)];\n        }\n    } else if (type == \"SameFish\") {\n        // Generate the same fish types for Alice and Bob\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, k);\n        }\n        b = a;\n        for (int i = n; i < m; ++i) {\n            b.push_back(rnd.next(1, k));\n        }\n        shuffle(b.begin(), b.end());\n    } else if (type == \"AliceHighBobLow\") {\n        // Alice's fish types have higher numbers, Bob's have lower numbers\n        int mid = k / 2;\n        if (k == 1) mid = 1;\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(mid + 1, k);\n        }\n        for (int i = 0; i < m; ++i) {\n            b[i] = rnd.next(1, mid);\n        }\n    } else if (type == \"AliceLowBobHigh\") {\n        // Alice's fish types have lower numbers, Bob's have higher numbers\n        int mid = k / 2;\n        if (k == 1) mid = 1;\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, mid);\n        }\n        for (int i = 0; i < m; ++i) {\n            b[i] = rnd.next(mid + 1, k);\n        }\n    } else if (type == \"MaxValues\") {\n        // n, m, k at maximum limits\n        for (int i = 0; i < n; ++i)\n            a[i] = rnd.next(1, k);\n        for (int i = 0; i < m; ++i)\n            b[i] = rnd.next(1, k);\n    } else if (type == \"MinValues\") {\n        // n, m, k at minimum values\n        a[0] = 1;\n        b[0] = 1;\n    } else if (type == \"AliceEqualsBob\") {\n        // Alice and Bob have exactly the same fish types\n        for (int i = 0; i < n; ++i)\n            a[i] = rnd.next(1, k);\n        b = a;\n        for (int i = n; i < m; ++i)\n            b.push_back(rnd.next(1, k));\n    } else {\n        // Default to random\n        for (int i = 0; i < n; ++i)\n            a[i] = rnd.next(1, k);\n        for (int i = 0; i < m; ++i)\n            b[i] = rnd.next(1, k);\n    }\n\n    // Output the test case\n    printf(\"%d %d %d\\n\", n, m, k);\n    for (int i = 0; i < n; ++i)\n        printf(\"%d%c\", a[i], i == n - 1 ? '\\n' : ' ');\n    for (int i = 0; i < m; ++i)\n        printf(\"%d%c\", b[i], i == m - 1 ? '\\n' : ' ');\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -m 1 -k 1 -type MinValues\n./gen -n 1 -m 1 -k 1 -type random\n\n./gen -n 1 -m 1 -k 1000000000 -type random\n./gen -n 100000 -m 100000 -k 1000000000 -type MaxValues\n\n./gen -n 1000 -m 1000 -k 100000 -type random\n./gen -n 100000 -m 100000 -k 1000000000 -type random\n\n./gen -n 50000 -m 50000 -k 1000000 -type SameFish\n./gen -n 50000 -m 50000 -k 1000000 -type AliceSubsetBob\n./gen -n 50000 -m 50000 -k 1000000 -type BobSubsetAlice\n\n./gen -n 100000 -m 100000 -k 1000000000 -type AliceHighBobLow\n./gen -n 100000 -m 100000 -k 1000000000 -type AliceLowBobHigh\n\n./gen -n 100000 -m 100000 -k 1 -type random\n\n./gen -n 1 -m 100000 -k 1000000000 -type AliceHighBobLow\n./gen -n 100000 -m 1 -k 1000000000 -type AliceLowBobHigh\n\n./gen -n 50000 -m 50000 -k 1000000 -type AliceEqualsBob\n\n./gen -n 100000 -m 100000 -k 2 -type AliceHighBobLow\n./gen -n 100000 -m 100000 -k 2 -type AliceLowBobHigh\n\n./gen -n 100000 -m 100000 -k 2 -type AliceSubsetBob\n\n./gen -n 100000 -m 100000 -k 2 -type BobSubsetAlice\n\n./gen -n 10 -m 10 -k 100 -type random\n\n./gen -n 12345 -m 67890 -k 10000000 -type random\n\n./gen -n 99999 -m 99999 -k 500000000 -type random\n\n./gen -n 100000 -m 50000 -k 1000000 -type AliceSubsetBob\n\n./gen -n 50000 -m 100000 -k 1000000 -type BobSubsetAlice\n\n./gen -n 100000 -m 100000 -k 1000000000 -type random\n\n./gen -n 100000 -m 100000 -k 1000000000 -type AliceSubsetBob\n\n./gen -n 100000 -m 100000 -k 1000000000 -type BobSubsetAlice\n\n./gen -n 2 -m 2 -k 2 -type AliceEqualsBob\n\n./gen -n 100000 -m 100000 -k 1 -type AliceEqualsBob\n\n./gen -n 100000 -m 1 -k 500000000 -type AliceHighBobLow\n./gen -n 1 -m 100000 -k 500000000 -type AliceLowBobHigh\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:04:22.655930",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "298/E",
      "title": "E. Splitting the Uniqueness",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line of the input contains integer n (1 ≤ n ≤ 105).The second line contains n distinct integers s1, s2, ... sn (0 ≤ si ≤ 109).",
      "output_spec": "OutputIf it is possible to make Alice and Bob happy (if you can split the given array), print \"YES\" (without quotes) in the first line. In the second line, print the array a. In the third line, print the array b. There may be more than one solution. Any of them will be accepted.If it is impossible to split s into almost unique arrays a and b, print \"NO\" (without quotes) in the first line.",
      "sample_tests": "ExamplesInputCopy612 5 8 3 11 9OutputCopyYES6 2 6 0 2 46 3 2 3 9 5",
      "description": "E. Splitting the Uniqueness\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line of the input contains integer n (1 ≤ n ≤ 105).The second line contains n distinct integers s1, s2, ... sn (0 ≤ si ≤ 109).\n\nOutputIf it is possible to make Alice and Bob happy (if you can split the given array), print \"YES\" (without quotes) in the first line. In the second line, print the array a. In the third line, print the array b. There may be more than one solution. Any of them will be accepted.If it is impossible to split s into almost unique arrays a and b, print \"NO\" (without quotes) in the first line.\n\nInputCopy612 5 8 3 11 9OutputCopyYES6 2 6 0 2 46 3 2 3 9 5\n\nInputCopy612 5 8 3 11 9\n\nOutputCopyYES6 2 6 0 2 46 3 2 3 9 5\n\nNoteIn the sample, we can remove the first two entries from a and the second entry from b to make them both unique.",
      "solutions": [
        {
          "title": "Codeforces Round #180 - Codeforces",
          "content": "Hi all!CodeForces 180 will take place at 19/4 17:30 (CEST). I (SteamTurbine), and Ivan Li (AEtheReal) are the authors of the round.This time you will need to help some polar bears to solve their problems. You know, life in the arctic is hard, they may face difficulties about catching fish, keeping warm etc.Thanks Gerald for helping us to prepare the round, MikeMirzayanov for the great platform and Delinur for translation.We hope that the polar bears are not going to eat you. Good Luck.UPD: Scoring will be dynamic. Problems are sorted by increasing order of difficulty.Editorial is here(All except Div 1 E) and here(Div 1 E).Result (div1): tourist (Solved all!) wjmsbmr tckwok0 msg555 Erop Result (div2): Parsa.pordel a88027180 Raoul Some fun facts:In 297E - Mystic Carvings (written by AEtheReal), the figure in the problem looks like the facial expression \"XD\" and \"囧\", which is done intentionally.Moreover, three lines can intersect in the following 5 ways:While discussing the problem, we refer those as \"川\", \"囧\", \"XD\", \"卄\" and \"△\". Chinese characters are interesting :)",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/7390",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1079
        },
        {
          "title": "Codeforces Round #180 Editorial - Codeforces",
          "content": "298A - Snow FootprintsThe starting position can be anywhere with a footprint. The footprints can be categorized into 3 types. only L s only R s R s followed by L s In case 1, we end in the left of all footprints. In case 2, we end in the right of all footprints. In case 3, we either end in the rightmost R or the leftmost L298B - SailWe can simply move by greedy method — only moves when it takes the boat closer to the destination.297A - Parity GameObv 1: If a has odd parity, we can apply operation 1 to increase its number of 1s by 1.Obv 2: If a has even parity, its number of 1s cannot increase anymore.Claim: If the number of 1s in a is not fewer than those in b, we can always turn a to bThe idea is to make a copy of b at the right of a. Lets assume a starts with even parity. If we need a 0, simply apply operation 1. If we need a 1, keep remove from the head until we removed an 1. Notice that we never remove digits from 'new part' of a. Now the parity of a will be odd and we can apply operation 1. After that, the parity of a becomes even again, the number of 1 in the 'old part' of a decrease by 1 and we handle a 1 in b. Finally, remove the remaining old part of a and we get b.Combine all those facts, we can conclude that we can turn a into b if and only if countOnes(a) + parity(countOnes(a)) ≥ countOnes(b)297B - Fish WeightFirst we sort a and b in non-increasing order. We claim that the answer is YES if and only if exists a is lexicographically larger than b. If a is not lexicographcally larger than b, that means for every i, ai ≤ bi. That implies for every fish Alice has, there is a corresponding fish Bob has and is as heavy as Alice's. Let i be the smallest index such that ai > bi. We can amplify the gap between wai and wbi as large as we want to make Alice wins.297C - Splitting the UniquenessAn equivalent definition for almost unique, is an array with at least ⌊ 2n / 3⌋ different elements. The idea is to split s into three parts: In the first part, we give uniqueness to a. In the second part, we give uniqueness to b. In the third part, we give uniqueness to both.Lets assume s is sorted. Since s is an unique array, we know si ≥ i for all i (0-based). The image below will give some intuition on how we are going to split it. a is red, b is blue, the length of the bar represent the magnitude of the number. In the first and second part, we do not care about the array that we are not giving uniqueness to.For exampmle, if n = 30:i = 0... 9:  assign ai = i (do not care values of b)i = 10... 19:  assign bi = i (do not care values of a)i = 20... 29:  assign bi = 29 - i and set ai = si - bi. From i = 20, a will have strictly increasing values starting from at least 11.297D - Color the CarpetFor k = 1 there is only one coloring so we just need to check the number of  =  constraints. When k ≥ 2, it turns out that using only 2 colors is always sufficient to satisfy at least 3 / 4 of the constraints.Lets assume w ≥ h (rotate if not). We will call the constraints that involves cells in different row \"vertical constraints\", and similar for \"horizontal constraints\".First we color the first row such that all horizontal constraints in row 1 are satisfied. We will color the remaining rows one by one.To color row i, first we color it such that all horizontal constraints in row i are satisfied. Then consider the vertical constraints between row i and row i - 1. Count the number of satisfied and unsatisfied vertical constraints. If there are more unsatisfied constraints than satisfied constraints, flip the coloring of row i. Flipping a row means turning 2211212 → 1122121, for example.If we flip the coloring of row i, all horizontal constraints in row i are still satisfied, but for the vertical constraints between row i and row i - 1, satisfied will turn to unsatisfied, unsatisfied will turn to satisfied. Therefore, we can always satisfy at least half the vertical constraints between row i and row i - 1.The number of unsatisfied constraints is at most (h - 1) × ⌊ w / 2⌋, which is at most 1 / 4 of the total number of constraints (recall w ≥ h).297E - Mystic CarvingsProblem and editorial written by AEtheReal. Link to editorial.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/7437",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.6,
            "reason": "宽松匹配: 包含题目编号 298 和字母"
          },
          "content_length": 4179
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #180 - Codeforces - Code 1",
          "code": "Those bears were a real pain in the brain....",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7390",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #180 - Codeforces - Code 2",
          "code": "pivot = a[(left+right)/2]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7390",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #180 - Codeforces - Code 3",
          "code": "ai>= 0 && bi >= 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7390",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n\n    vector<int> s = inf.readInts(n, 0, 1000000000, \"s_i\");\n    inf.readEoln();\n\n    // Check that s_i are distinct\n    set<int> s_set(s.begin(), s.end());\n    ensuref((int)s_set.size() == n, \"s_i are not unique\");\n\n    inf.readEof();\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n\n    vector<int> s = inf.readInts(n, 0, 1000000000, \"s_i\");\n    inf.readEoln();\n\n    // Check that s_i are distinct\n    set<int> s_set(s.begin(), s.end());\n    ensuref((int)s_set.size() == n, \"s_i are not unique\");\n\n    inf.readEof();\n\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n\n    vector<int> s = inf.readInts(n, 0, 1000000000, \"s_i\");\n    inf.readEoln();\n\n    // Check that s_i are distinct\n    set<int> s_set(s.begin(), s.end());\n    ensuref((int)s_set.size() == n, \"s_i are not unique\");\n\n    inf.readEof();\n\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n\nint n;\nvector<ll> s;\n\nstruct Answer {\n    bool isYes;\n    vector<ll> a, b;\n};\n\nvoid readAnswer(InStream& in, Answer& answ) {\n    string res = in.readToken();\n    if (res == \"NO\") {\n        answ.isYes = false;\n    } else if (res == \"YES\") {\n        answ.isYes = true;\n        answ.a = in.readLongs(n, 0LL, LLONG_MAX);\n        answ.b = in.readLongs(n, 0LL, LLONG_MAX);\n        if ((int)answ.a.size() != n)\n            in.quitf(_wa, \"Length of array a is not %d\", n);\n        if ((int)answ.b.size() != n)\n            in.quitf(_wa, \"Length of array b is not %d\", n);\n        for (int i = 0; i < n; ++i) {\n            if (answ.a[i] < 0 || answ.b[i] < 0)\n                in.quitf(_wa, \"Negative value at position %d\", i + 1);\n            if (answ.a[i] + answ.b[i] != s[i])\n                in.quitf(_wa, \"At position %d, a_i + b_i != s_i\", i + 1);\n        }\n        // Check if a and b are almost unique\n        set<ll> set_a(answ.a.begin(), answ.a.end());\n        set<ll> set_b(answ.b.begin(), answ.b.end());\n        int unique_a = set_a.size();\n        int unique_b = set_b.size();\n        if (n - unique_a > n / 2)\n            in.quitf(_wa, \"Array a is not almost unique\");\n        if (n - unique_b > n / 2)\n            in.quitf(_wa, \"Array b is not almost unique\");\n    } else {\n        in.quitf(_wa, \"Expected YES or NO, but found '%s'\", res.c_str());\n    }\n}\n\nint main(int argc, char* argv[]) {\n    registerTestlibCmd(argc, argv);\n    n = inf.readInt();\n    s = inf.readLongs(n, 0LL, LLONG_MAX);\n    \n    Answer jury_ans;\n    readAnswer(ans, jury_ans);\n    \n    Answer cont_ans;\n    readAnswer(ouf, cont_ans);\n\n    if (jury_ans.isYes == false) {\n        // Jury says NO\n        if (cont_ans.isYes == false) {\n            // Both say NO\n            quitf(_ok, \"Both outputs are NO\");\n        } else {\n            // Contestant found a solution when jury says impossible\n            quitf(_fail, \"Contestant found a solution but jury says NO\");\n        }\n    } else {\n        // Jury says YES\n        if (cont_ans.isYes == false) {\n            // Contestant failed to find a solution\n            quitf(_wa, \"Contestant outputs NO but solution exists\");\n        } else {\n            // Both outputs are YES and contestant's solution is valid\n            quitf(_ok, \"Solution is correct\");\n        }\n    }\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int max_s = opt<int>(\"max_s\", 1000000000); // Default maximum value for s_i\n    string type = opt<string>(\"type\", \"RandomUnique\");\n\n    set<int> used_s;\n    vector<int> s(n);\n\n    if (type == \"RandomUnique\") {\n        int maxPossibleValues = max_s + 1;\n        ensuref(maxPossibleValues >= n, \"max_s is too small to generate n unique s_i.\");\n\n        // Generate n unique random integers in [0, max_s]\n        for (int i = 0; i < n; i++) {\n            int val;\n            do {\n                val = rnd.next(0, max_s);\n            } while (used_s.count(val));\n            used_s.insert(val);\n            s[i] = val;\n        }\n    } else if (type == \"Sequential\") {\n        // s_i = i\n        for (int i = 0; i < n; i++) {\n            s[i] = i;\n        }\n        // Optionally shuffle\n        shuffle(s.begin(), s.end());\n    } else if (type == \"LargeGaps\") {\n        // s_i are unique numbers with large gaps\n        int gap = max(1, max_s / n);\n        for (int i = 0; i < n; i++) {\n            s[i] = i * gap;\n        }\n        // Optionally shuffle\n        shuffle(s.begin(), s.end());\n    } else if (type == \"MaxValues\") {\n        // s_i are in range [max_s - n + 1, max_s]\n        ensuref(max_s >= n - 1, \"max_s is too small for MaxValues type with n elements.\");\n        for (int i = 0; i < n; i++) {\n            s[i] = max_s - n + 1 + i;\n        }\n        shuffle(s.begin(), s.end());\n    } else if (type == \"MinValues\") {\n        // s_i are in range [0, n - 1]\n        for (int i = 0; i < n; i++) {\n            s[i] = i;\n        }\n        shuffle(s.begin(), s.end());\n    } else {\n        // Default: RandomUnique\n        int maxPossibleValues = max_s + 1;\n        ensuref(maxPossibleValues >= n, \"max_s is too small to generate n unique s_i.\");\n\n        for (int i = 0; i < n; i++) {\n            int val;\n            do {\n                val = rnd.next(0, max_s);\n            } while (used_s.count(val));\n            used_s.insert(val);\n            s[i] = val;\n        }\n    }\n\n    // Output\n    printf(\"%d\\n\", n);\n    for (int i = 0; i < n; i++) {\n        printf(\"%d\", s[i]);\n        if (i + 1 < n) printf(\" \");\n    }\n    printf(\"\\n\");\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int max_s = opt<int>(\"max_s\", 1000000000); // Default maximum value for s_i\n    string type = opt<string>(\"type\", \"RandomUnique\");\n\n    set<int> used_s;\n    vector<int> s(n);\n\n    if (type == \"RandomUnique\") {\n        int maxPossibleValues = max_s + 1;\n        ensuref(maxPossibleValues >= n, \"max_s is too small to generate n unique s_i.\");\n\n        // Generate n unique random integers in [0, max_s]\n        for (int i = 0; i < n; i++) {\n            int val;\n            do {\n                val = rnd.next(0, max_s);\n            } while (used_s.count(val));\n            used_s.insert(val);\n            s[i] = val;\n        }\n    } else if (type == \"Sequential\") {\n        // s_i = i\n        for (int i = 0; i < n; i++) {\n            s[i] = i;\n        }\n        // Optionally shuffle\n        shuffle(s.begin(), s.end());\n    } else if (type == \"LargeGaps\") {\n        // s_i are unique numbers with large gaps\n        int gap = max(1, max_s / n);\n        for (int i = 0; i < n; i++) {\n            s[i] = i * gap;\n        }\n        // Optionally shuffle\n        shuffle(s.begin(), s.end());\n    } else if (type == \"MaxValues\") {\n        // s_i are in range [max_s - n + 1, max_s]\n        ensuref(max_s >= n - 1, \"max_s is too small for MaxValues type with n elements.\");\n        for (int i = 0; i < n; i++) {\n            s[i] = max_s - n + 1 + i;\n        }\n        shuffle(s.begin(), s.end());\n    } else if (type == \"MinValues\") {\n        // s_i are in range [0, n - 1]\n        for (int i = 0; i < n; i++) {\n            s[i] = i;\n        }\n        shuffle(s.begin(), s.end());\n    } else {\n        // Default: RandomUnique\n        int maxPossibleValues = max_s + 1;\n        ensuref(maxPossibleValues >= n, \"max_s is too small to generate n unique s_i.\");\n\n        for (int i = 0; i < n; i++) {\n            int val;\n            do {\n                val = rnd.next(0, max_s);\n            } while (used_s.count(val));\n            used_s.insert(val);\n            s[i] = val;\n        }\n    }\n\n    // Output\n    printf(\"%d\\n\", n);\n    for (int i = 0; i < n; i++) {\n        printf(\"%d\", s[i]);\n        if (i + 1 < n) printf(\" \");\n    }\n    printf(\"\\n\");\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -type MinValues\n\n./gen -n 1 -type MaxValues\n\n./gen -n 2 -type Sequential\n\n./gen -n 5 -max_s 10 -type RandomUnique\n\n./gen -n 10 -type RandomUnique\n\n./gen -n 10 -type Sequential\n\n./gen -n 10 -type LargeGaps\n\n./gen -n 100 -type RandomUnique\n\n./gen -n 100 -type Sequential\n\n./gen -n 100 -type LargeGaps\n\n./gen -n 500 -type RandomUnique\n\n./gen -n 500 -type MaxValues\n\n./gen -n 1000 -type RandomUnique\n\n./gen -n 1000 -type Sequential\n\n./gen -n 5000 -type RandomUnique\n\n./gen -n 5000 -type LargeGaps\n\n./gen -n 10000 -type RandomUnique\n\n./gen -n 10000 -type MaxValues\n\n./gen -n 50000 -type RandomUnique\n\n./gen -n 50000 -type Sequential\n\n./gen -n 100000 -type RandomUnique\n\n./gen -n 100000 -type MaxValues\n\n./gen -n 100000 -type LargeGaps\n\n./gen -n 100000 -type RandomUnique -max_s 1000000000\n\n./gen -n 100000 -type Sequential -max_s 1000000000\n\n./gen -n 99999 -type RandomUnique -max_s 100000\n\n./gen -n 100000 -type MinValues\n\n./gen -n 100000 -type RandomUnique -max_s 100000\n\n./gen -n 100 -type RandomUnique -max_s 100\n\n./gen -n 1000 -type RandomUnique -max_s 1000\n\n./gen -n 50000 -type RandomUnique -max_s 1000000000\n\n./gen -n 100000 -type MaxValues -max_s 1000000000\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:04:24.610432",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "299/A",
      "title": "A. Ксюша и массив",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест2 секунды",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеВ первой строке записано целое число n (1 ≤ n ≤ 105) — количество чисел в массиве. В следующей строке записаны целые числа a1, a2, ..., an (1 ≤ ai ≤ 109) — элементы массива.",
      "output_spec": "Выходные данныеВыведите единственное целое число — число из массива, на которое делятся все числа из массива. Если такого числа нет, выведите -1.Если существует несколько ответов, разрешается вывести любой.",
      "sample_tests": "ПримерыВходные данныеСкопировать32 2 4Выходные данныеСкопировать2Входные данныеСкопировать52 1 3 1 6Выходные данныеСкопировать1Входные данныеСкопировать32 3 5Выходные данныеСкопировать-1",
      "description": "A. Ксюша и массив\n\nограничение по времени на тест2 секунды\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвыводstdout\n\nВходные данныеВ первой строке записано целое число n (1 ≤ n ≤ 105) — количество чисел в массиве. В следующей строке записаны целые числа a1, a2, ..., an (1 ≤ ai ≤ 109) — элементы массива.\n\nВходные данные\n\nВыходные данныеВыведите единственное целое число — число из массива, на которое делятся все числа из массива. Если такого числа нет, выведите -1.Если существует несколько ответов, разрешается вывести любой.\n\nВыходные данные\n\nВходные данныеСкопировать32 2 4Выходные данныеСкопировать2Входные данныеСкопировать52 1 3 1 6Выходные данныеСкопировать1Входные данныеСкопировать32 3 5Выходные данныеСкопировать-1\n\nВходные данныеСкопировать32 2 4\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать2\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать52 1 3 1 6\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать1\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать32 3 5\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать-1\n\nВыходные данныеСкопировать\n\nСкопировать",
      "solutions": [
        {
          "title": "Чемпионат КРОК 2013 — Раунд 2 - Codeforces",
          "content": "Всем привет!Сегодня состоится второй раунд Всероссийского Открытого Чемпионата по программированию \"КРОК-2013\". Раунд для вас готовили: sdya, Seyaua, Gerald и, как обычно, задачи на английский переводила Delinur.Приятная новость для тех, кто не попал в лучшие 400 участников в предыдущем раунде — сегодня каждый может поучаствовать вне конкурса. При этом, раунд будет рейтинговым как для официальных участников чемпионата, так и для внеконкурсных.Официальным участникам напоминаем, что: Все участники чемпионата должны быть не моложе 18 лет на момент регистрации Финал чемпионата состоится 16 и 17 мая в Москве в офисе компании КРОК (50 участников) Проживание во время финала будет оплачено компанией КРОК Для граждан Российской Федерации: организаторы покроют транспортные расходы по территории РФ, транспортные расходы не по территории РФ — по согласованию (возможно, частично) Финалисты должны подтвердить свое участие до 2 мая И небольшой бонус: лучшие 200 официальных участников чемпионата получат футболки!Желаем всем получить удовольствие от решения задач ну и, конечно, удачи!UPD: Разбалловка по задачам сегодня будет немножко отличаться от стандартной: 500-1500-1500-2000-2500 для первого дивизиона и 500-1000-1500-2500-2500 для второго.UPD2: Мы приносим свои извинения за технические неполадки во время раунда. Посовещавшись, мы решили, что соревнование должно быть рейтинговым. А результаты соревнования будут учитываться в отборе на финал чемпионата КРОК.",
          "author": "Seyaua",
          "url": "https://codeforces.com/blog/entry/7460",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 1467
        },
        {
          "title": "Чемпионат КРОК 2013 — Раунд 2 — Разбор - Codeforces",
          "content": "A Div 2Если aj делится на ai, то тогда ai ≤ aj. Тогда число, на которое будут делиться все остальные числа будет не более чем любое выбранное число. То есть единственный возможный кандидат — это минимум в массиве. Поэтому просто проверим, что все элементы массива делятся на минимальный элемент.B Div 2Легко видеть, что Ксюша не сможет закончить ее путешествие, если существует последовательность подряд идущих # длиное более чем k.C Div 2 / A Div 1Первое наблюдение: мы не будем волноваться о том, как выглядят строки на самом деле, вся информация, которая нам нужна — это количество пар-символов вида: {0, 0}, {0, 1}, {1, 0}, {1, 1}. Посчитаем эти количества и будем следовать следующему жадному алгоритму:Для первого игрока: будем брать сначала {1, 1}, если их нет, то {1,0}. Если их нет, то {0, 1} и, в последнюю очередь, будем брать {0, 0}.Для второго игрока похожая стратегия: сначала {1, 1}, потом {0, 1}, потом {1, 0} и, в последнюю очередь, {0, 0}.После этого сравним у кого получилось больше единичек.D Div 2 / B Div 1Любой путь из верхней левой клетки в правую нижнюю состоит ровно из n + m - 1 клеток. И все они должны быть покрашены в разные цвета. Значит n + m - 1 ≤ k. Исходя из маленьких ограничений на k можно предположить, что брут-форс будет работать. Единственная оптимизация для получения действительно правильного решения — это некоторая канонизация раскрасок. Будем идти по всем клеткам в некотором порядке и красить их согласно следующим условиям. Если i > j, тогда цвет i встречается позже цвета j. После такого перебора мы получим примерно миллион различных шаблонов для максимального теста.Далее, просто будем сопоставлять уже покрашенные клетки с каждым шаблоном и считать, сколько различных перестановок цветов подходят к данному шаблону.E Div 2 / C Div 1После прочтения условия, можно понять, что все, что нам нужно — это посчитать количество решений уравнения (a + b + c)3 - a3 - b3 - c3 = n в положительных целых числах.Ключевое наблюдение это: 3(a + b)(a + c)(b + c) = (a + b + c)3 - a3 - b3 - c3, после чего мы можем просто вычислять все делители числа и идти по всем делителям x = a + b, таким что ? далее будем идти по делителям y = (a + c) ≥ x, где и в конце будем вычислять z = (b + c), такое что .После этого, решим систему a + b = x, a + c = y, b + c = z и добавим количество подходящих решений к ответу.D Div 1Можно заметить, что в этой задаче просят посчитать для всех целых точек внутри многоугольника (или на его границе). Можно заметить, что мы можем обрабатывать иксы и игреки независимо.Для каждого x определим yleft, yright таким образом, что все точки (x, y), где yleft ≤ y ≤ yright лежат внутри многоугольника и отрезок [yleft, yright] максимально возможный.Теперь будем считать, что мы имеем a1, a2, ..., ak различных точек для каждого фиксированного x (a1 соответствует x =  - 106, a2 соответствует x =  - 106 + 1 и так далее).Теперь требуемый ответ это a2a1 + a3(a2 + 22a1) + a4(a3 + 22a2 + 32a1) + ... Можно заметить, что (a2 + 22a1) - a1 = a2 + 3a1,(a3 + 22a2 + 32a1) - (a2 + 22a1) = a3 + 3a2 + 5a1,и так далее.Поэтому достаточно предпросчитать частичные суммы вида a2 + 3a1, a3 + 3a2 + 5a1, a4 + 3a3 + 5a2 + 7a1 (разность между двумя соседними суммами составляет 2(ai + ... + a1), поэтому мы можем делать это за O(k)).После предпросчета достаточно сложить полученные результаты.E Div 1Будем считать что у нас есть структура данных, которая позволяет осуществлять следующие операции: добавить точку (x, y) в структуру; сдвинуть все точки структуры на вектор (dx, dy); узнать как много точек (x,y), удовлетворяющих x ≤ xbound, y ≤ ybound; получить все элементы, которые на данный момент находятся в структуре; Для каждой вершины дерева мы будем хранить указатель на структуру такого вида.ОБъясним, как нужно обновлять структуры. Мы будем обрабатывать все вершины в порядке обхода в глубине, и если мы находимся в листе, то мы будем создавать структуру с единственным элементом (0, 0).В противном же случае, мы будем сортировать структуры сыновей по их размеру в убывающем порядке и будем присваивать указатель наибольшей структуры указателю на текущую вершину (здесь нужно не забыть сдвигать структуру на (1, вес ребра)).После этого будем идти по всем сыновьям вершины и делать следующее: Сдвинем структуру на (1, вес ребра); Возьмем все элементы структуры; Для каждого элемента (x, y) ответим на запрос xbound = L - x, ybound = W - y (используем родительскую структуру); Добавим элементы по одному в структуру; После этого ответим на запрос xbound = L, ybound = W и добавим элемент (0, 0).Сумма полученных результатов по всем запросам и будет ответом. Легко видеть, что мы совершим не более чем запросов и операций добавления.Осталось только объяснить, как создать нужную нам структуру данных.Существует несколько способов сделать это, один из них: Будем иметь маленькие подструктуры у которых размеры являются степенями двойки; Каждая структура — это двумерное дерево отрезков; Мы можем добавлять элемент следующим образом: если нет подструктуры размера 1, тогда создадим ее, иначе же возьмем все структуры размерами 1, 2, 4, ..., 2k и перестроим в структуру размера 2k + 1. Сдвиг: достаточно помнить вектор сдвига для каждой подструктуры; Ответ на запрос: идем по подструктурам и суммируем результаты. Разбор задач был подготовлен sdya и Seyaua",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/7516",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 5301
        },
        {
          "title": "Чемпионат КРОК 2013 — Раунд 2 — Разбор - Codeforces",
          "content": "A Div 2Если aj делится на ai, то тогда ai ≤ aj. Тогда число, на которое будут делиться все остальные числа будет не более чем любое выбранное число. То есть единственный возможный кандидат — это минимум в массиве. Поэтому просто проверим, что все элементы массива делятся на минимальный элемент.B Div 2Легко видеть, что Ксюша не сможет закончить ее путешествие, если существует последовательность подряд идущих # длиное более чем k.C Div 2 / A Div 1Первое наблюдение: мы не будем волноваться о том, как выглядят строки на самом деле, вся информация, которая нам нужна — это количество пар-символов вида: {0, 0}, {0, 1}, {1, 0}, {1, 1}. Посчитаем эти количества и будем следовать следующему жадному алгоритму:Для первого игрока: будем брать сначала {1, 1}, если их нет, то {1,0}. Если их нет, то {0, 1} и, в последнюю очередь, будем брать {0, 0}.Для второго игрока похожая стратегия: сначала {1, 1}, потом {0, 1}, потом {1, 0} и, в последнюю очередь, {0, 0}.После этого сравним у кого получилось больше единичек.D Div 2 / B Div 1Любой путь из верхней левой клетки в правую нижнюю состоит ровно из n + m - 1 клеток. И все они должны быть покрашены в разные цвета. Значит n + m - 1 ≤ k. Исходя из маленьких ограничений на k можно предположить, что брут-форс будет работать. Единственная оптимизация для получения действительно правильного решения — это некоторая канонизация раскрасок. Будем идти по всем клеткам в некотором порядке и красить их согласно следующим условиям. Если i > j, тогда цвет i встречается позже цвета j. После такого перебора мы получим примерно миллион различных шаблонов для максимального теста.Далее, просто будем сопоставлять уже покрашенные клетки с каждым шаблоном и считать, сколько различных перестановок цветов подходят к данному шаблону.E Div 2 / C Div 1После прочтения условия, можно понять, что все, что нам нужно — это посчитать количество решений уравнения (a + b + c)3 - a3 - b3 - c3 = n в положительных целых числах.Ключевое наблюдение это: 3(a + b)(a + c)(b + c) = (a + b + c)3 - a3 - b3 - c3, после чего мы можем просто вычислять все делители числа и идти по всем делителям x = a + b, таким что ? далее будем идти по делителям y = (a + c) ≥ x, где и в конце будем вычислять z = (b + c), такое что .После этого, решим систему a + b = x, a + c = y, b + c = z и добавим количество подходящих решений к ответу.D Div 1Можно заметить, что в этой задаче просят посчитать для всех целых точек внутри многоугольника (или на его границе). Можно заметить, что мы можем обрабатывать иксы и игреки независимо.Для каждого x определим yleft, yright таким образом, что все точки (x, y), где yleft ≤ y ≤ yright лежат внутри многоугольника и отрезок [yleft, yright] максимально возможный.Теперь будем считать, что мы имеем a1, a2, ..., ak различных точек для каждого фиксированного x (a1 соответствует x =  - 106, a2 соответствует x =  - 106 + 1 и так далее).Теперь требуемый ответ это a2a1 + a3(a2 + 22a1) + a4(a3 + 22a2 + 32a1) + ... Можно заметить, что (a2 + 22a1) - a1 = a2 + 3a1,(a3 + 22a2 + 32a1) - (a2 + 22a1) = a3 + 3a2 + 5a1,и так далее.Поэтому достаточно предпросчитать частичные суммы вида a2 + 3a1, a3 + 3a2 + 5a1, a4 + 3a3 + 5a2 + 7a1 (разность между двумя соседними суммами составляет 2(ai + ... + a1), поэтому мы можем делать это за O(k)).После предпросчета достаточно сложить полученные результаты.E Div 1Будем считать что у нас есть структура данных, которая позволяет осуществлять следующие операции: добавить точку (x, y) в структуру; сдвинуть все точки структуры на вектор (dx, dy); узнать как много точек (x,y), удовлетворяющих x ≤ xbound, y ≤ ybound; получить все элементы, которые на данный момент находятся в структуре; Для каждой вершины дерева мы будем хранить указатель на структуру такого вида.ОБъясним, как нужно обновлять структуры. Мы будем обрабатывать все вершины в порядке обхода в глубине, и если мы находимся в листе, то мы будем создавать структуру с единственным элементом (0, 0).В противном же случае, мы будем сортировать структуры сыновей по их размеру в убывающем порядке и будем присваивать указатель наибольшей структуры указателю на текущую вершину (здесь нужно не забыть сдвигать структуру на (1, вес ребра)).После этого будем идти по всем сыновьям вершины и делать следующее: Сдвинем структуру на (1, вес ребра); Возьмем все элементы структуры; Для каждого элемента (x, y) ответим на запрос xbound = L - x, ybound = W - y (используем родительскую структуру); Добавим элементы по одному в структуру; После этого ответим на запрос xbound = L, ybound = W и добавим элемент (0, 0).Сумма полученных результатов по всем запросам и будет ответом. Легко видеть, что мы совершим не более чем запросов и операций добавления.Осталось только объяснить, как создать нужную нам структуру данных.Существует несколько способов сделать это, один из них: Будем иметь маленькие подструктуры у которых размеры являются степенями двойки; Каждая структура — это двумерное дерево отрезков; Мы можем добавлять элемент следующим образом: если нет подструктуры размера 1, тогда создадим ее, иначе же возьмем все структуры размерами 1, 2, 4, ..., 2k и перестроим в структуру размера 2k + 1. Сдвиг: достаточно помнить вектор сдвига для каждой подструктуры; Ответ на запрос: идем по подструктурам и суммируем результаты. Разбор задач был подготовлен sdya и Seyaua",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/7516",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 5301
        }
      ],
      "code_examples": [
        {
          "title": "Чемпионат КРОК 2013 — Раунд 2 - Codeforces - Code 1",
          "code": "2 2 3\n1 2\n0 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7460",
          "author": "Seyaua"
        },
        {
          "title": "Чемпионат КРОК 2013 — Раунд 2 - Codeforces - Code 2",
          "code": "2 2 3\n1 2\n0 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7460",
          "author": "Seyaua"
        },
        {
          "title": "Чемпионат КРОК 2013 — Раунд 2 - Codeforces - Code 3",
          "code": "dp[0][1][{1,2}] == 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7460",
          "author": "Seyaua"
        },
        {
          "title": "Чемпионат КРОК 2013 — Раунд 2 - Codeforces - Code 4",
          "code": "dp[1][0][{1,2}] == 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7460",
          "author": "Seyaua"
        },
        {
          "title": "Чемпионат КРОК 2013 — Раунд 2 - Codeforces - Code 5",
          "code": "dp[1][1][{1,2,3}]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7460",
          "author": "Seyaua"
        },
        {
          "title": "Чемпионат КРОК 2013 — Раунд 2 - Codeforces - Code 6",
          "code": "5 6 10\n0 0 0 0 0 0\n0 0 0 0 0 0\n0 0 0 0 0 0\n0 0 0 0 0 0\n1 2 3 0 0 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7460",
          "author": "Seyaua"
        },
        {
          "title": "Чемпионат КРОК 2013 — Раунд 2 - Codeforces - Code 7",
          "code": "5 6 10\n0 0 0 0 0 0\n0 0 0 0 0 0\n0 0 0 0 0 0\n0 0 0 0 0 0\n1 2 3 0 0 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7460",
          "author": "Seyaua"
        },
        {
          "title": "Чемпионат КРОК 2013 — Раунд 2 - Codeforces - Code 8",
          "code": "5 6 10\n0 0 0 0 0 0\n0 0 0 0 0 0\n0 0 0 0 0 0\n4 0 0 0 0 0\n1 2 3 0 0 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7460",
          "author": "Seyaua"
        },
        {
          "title": "Чемпионат КРОК 2013 — Раунд 2 - Codeforces - Code 9",
          "code": "5 6 10\n0 0 0 0 0 0\n0 0 0 0 0 0\n0 0 0 0 0 0\n4 0 0 0 0 0\n1 2 3 0 0 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7460",
          "author": "Seyaua"
        },
        {
          "title": "Чемпионат КРОК 2013 — Раунд 2 - Codeforces - Code 10",
          "code": "if(F > S) cout << \"First\";\nif(F + 1 < S) cout << \"Second\";\nif(F == S) cout << \"Draw\";",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7460",
          "author": "Seyaua"
        },
        {
          "title": "Чемпионат КРОК 2013 — Раунд 2 - Codeforces - Code 11",
          "code": "if(F > S) cout << \"First\";\nif(F + 1 < S) cout << \"Second\";\nif(F == S) cout << \"Draw\";",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7460",
          "author": "Seyaua"
        },
        {
          "title": "Чемпионат КРОК 2013 — Раунд 2 - Codeforces - Code 12",
          "code": "При этом, раунд будет рейтинговым как для официальных участников чемпионата, так и для внеконкурсных.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7460",
          "author": "Seyaua"
        },
        {
          "title": "Чемпионат КРОК 2013 — Раунд 2 - Codeforces - Code 13",
          "code": "3\n-1000000 1000000\n-1000000 999999\n-999999 1000000",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7460",
          "author": "Seyaua"
        },
        {
          "title": "Чемпионат КРОК 2013 — Раунд 2 - Codeforces - Code 14",
          "code": "3\n-1000000 1000000\n-1000000 999999\n-999999 1000000",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7460",
          "author": "Seyaua"
        },
        {
          "title": "Чемпионат КРОК 2013 — Раунд 2 - Codeforces - Code 15",
          "code": "(a+b+c)^3 - a^3 - b^3 - c^3 = 3*(a+b)*(b+c)*(c+a)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7460",
          "author": "Seyaua"
        },
        {
          "title": "Чемпионат КРОК 2013 — Раунд 2 - Codeforces - Code 16",
          "code": "(a+b+c)^3 - a^3 - b^3 - c^3 = 3*(a+b)*(b+c)*(c+a)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7460",
          "author": "Seyaua"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    // Read n\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n\n    // Read the n integers a_i\n    vector<int> a = inf.readInts(n, 1, 1000000000);\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    // Read n\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n\n    // Read the n integers a_i\n    vector<int> a = inf.readInts(n, 1, 1000000000);\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    // Read n\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n\n    // Read the n integers a_i\n    vector<int> a = inf.readInts(n, 1, 1000000000);\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerTestlibCmd(argc, argv);\n    \n    // Read from inf: n and a[]\n    int n = inf.readInt(1, 100000, \"n\");\n    vector<long long> a(n);\n    for (int i = 0; i < n; ++i) {\n        a[i] = inf.readLong(1, 1000000000LL, format(\"a[%d]\", i+1).c_str());\n    }\n\n    // Read from ouf: k\n    long long k = ouf.readLong(-1, 1000000000LL, \"k\");\n\n    // Handle special case: k == -1\n    if (k == -1) {\n        // Compute the GCD of the array elements\n        long long gcd = a[0];\n        for (int i = 1; i < n; ++i) {\n            gcd = __gcd(gcd, a[i]);\n        }\n        // Check if gcd is present in the array\n        if (find(a.begin(), a.end(), gcd) != a.end()) {\n            // The contestant's answer is incorrect\n            quitf(_wa, \"Contestant claimed no such number exists, but %lld divides all elements and is in the array\", gcd);\n        } else {\n            // The contestant's answer is correct\n            quitf(_ok, \"Correctly reported no such number exists\");\n        }\n    } else {\n        // The contestant provided a number\n        // Check if k is in the array\n        if (find(a.begin(), a.end(), k) == a.end()) {\n            quitf(_wa, \"The number %lld is not in the array\", k);\n        }\n        // Check if k divides all elements\n        for (int i = 0; i < n; ++i) {\n            if (a[i] % k != 0) {\n                quitf(_wa, \"%lld does not divide a[%d] = %lld\", k, i + 1, a[i]);\n            }\n        }\n        // The contestant's answer is correct\n        quitf(_ok, \"%lld divides all elements\", k);\n    }\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random_gcd_in_array\");\n\n    vector<int> a(n);\n\n    if (type == \"random_gcd_in_array\") {\n        int x = rnd.next(1, (int)1e9);\n        int max_factor = (int)(1e9 / x);\n        if (max_factor == 0) max_factor = 1;\n        int idx = rnd.next(0, n-1);\n        a[idx] = x;\n        for (int i = 0; i < n; ++i) {\n            if (i == idx) continue;\n            int factor = rnd.next(1, max_factor);\n            a[i] = x * factor;\n        }\n    } else if (type == \"random_gcd_not_in_array\") {\n        int x = rnd.next(1, (int)(1e9 / 2));\n        int max_factor = (int)(1e9 / x);\n        if (max_factor < 2) max_factor = 2;\n        for (int i = 0; i < n; ++i) {\n            int factor = rnd.next(2, max_factor);\n            a[i] = x * factor;\n        }\n    } else if (type == \"gcd_is_one_with_one\") {\n        int idx = rnd.next(0, n-1);\n        a[idx] = 1;\n        for (int i = 0; i < n; ++i) {\n            if (i == idx) continue;\n            a[i] = rnd.next(2, (int)1e9);\n        }\n    } else if (type == \"gcd_is_one_without_one\") {\n        if (n == 1) {\n            // If n is 1, we cannot have GCD 1 without including 1\n            a[0] = rnd.next(2, (int)1e9);\n        } else {\n            int x = rnd.next(2, (int)1e9);\n            int y = rnd.next(2, (int)1e9);\n            while (__gcd(x, y) != 1) {\n                y = rnd.next(2, (int)1e9);\n            }\n            for (int i = 0; i < n; ++i) {\n                a[i] = (i % 2 == 0) ? x : y;\n            }\n        }\n    } else if (type == \"same_numbers\") {\n        int x = rnd.next(1, (int)1e9);\n        for (int i = 0; i < n; ++i) {\n            a[i] = x;\n        }\n    } else if (type == \"primes\") {\n        vector<int> small_primes = {2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47,\n            53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139,\n            149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233,\n            239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337,\n            347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439,\n            443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557,\n            563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653,\n            659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769,\n            773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883,\n            887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997};\n        for (int i = 0; i < n; ++i) {\n            int idx = rnd.next(0, (int)small_primes.size() - 1);\n            a[i] = small_primes[idx];\n        }\n    } else {\n        // Random data\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, (int)1e9);\n        }\n    }\n\n    // Output n and array a\n    printf(\"%d\\n\", n);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d\", a[i]);\n        if (i < n - 1) printf(\" \");\n    }\n    printf(\"\\n\");\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random_gcd_in_array\");\n\n    vector<int> a(n);\n\n    if (type == \"random_gcd_in_array\") {\n        int x = rnd.next(1, (int)1e9);\n        int max_factor = (int)(1e9 / x);\n        if (max_factor == 0) max_factor = 1;\n        int idx = rnd.next(0, n-1);\n        a[idx] = x;\n        for (int i = 0; i < n; ++i) {\n            if (i == idx) continue;\n            int factor = rnd.next(1, max_factor);\n            a[i] = x * factor;\n        }\n    } else if (type == \"random_gcd_not_in_array\") {\n        int x = rnd.next(1, (int)(1e9 / 2));\n        int max_factor = (int)(1e9 / x);\n        if (max_factor < 2) max_factor = 2;\n        for (int i = 0; i < n; ++i) {\n            int factor = rnd.next(2, max_factor);\n            a[i] = x * factor;\n        }\n    } else if (type == \"gcd_is_one_with_one\") {\n        int idx = rnd.next(0, n-1);\n        a[idx] = 1;\n        for (int i = 0; i < n; ++i) {\n            if (i == idx) continue;\n            a[i] = rnd.next(2, (int)1e9);\n        }\n    } else if (type == \"gcd_is_one_without_one\") {\n        if (n == 1) {\n            // If n is 1, we cannot have GCD 1 without including 1\n            a[0] = rnd.next(2, (int)1e9);\n        } else {\n            int x = rnd.next(2, (int)1e9);\n            int y = rnd.next(2, (int)1e9);\n            while (__gcd(x, y) != 1) {\n                y = rnd.next(2, (int)1e9);\n            }\n            for (int i = 0; i < n; ++i) {\n                a[i] = (i % 2 == 0) ? x : y;\n            }\n        }\n    } else if (type == \"same_numbers\") {\n        int x = rnd.next(1, (int)1e9);\n        for (int i = 0; i < n; ++i) {\n            a[i] = x;\n        }\n    } else if (type == \"primes\") {\n        vector<int> small_primes = {2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47,\n            53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139,\n            149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233,\n            239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337,\n            347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439,\n            443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557,\n            563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653,\n            659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769,\n            773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883,\n            887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997};\n        for (int i = 0; i < n; ++i) {\n            int idx = rnd.next(0, (int)small_primes.size() - 1);\n            a[i] = small_primes[idx];\n        }\n    } else {\n        // Random data\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, (int)1e9);\n        }\n    }\n\n    // Output n and array a\n    printf(\"%d\\n\", n);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d\", a[i]);\n        if (i < n - 1) printf(\" \");\n    }\n    printf(\"\\n\");\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -type random_gcd_in_array\n./gen -n 1 -type random_gcd_not_in_array\n./gen -n 1 -type gcd_is_one_with_one\n./gen -n 1 -type gcd_is_one_without_one\n./gen -n 1 -type same_numbers\n./gen -n 1 -type primes\n\n./gen -n 2 -type random_gcd_in_array\n./gen -n 2 -type random_gcd_not_in_array\n./gen -n 2 -type gcd_is_one_with_one\n./gen -n 2 -type gcd_is_one_without_one\n./gen -n 2 -type same_numbers\n./gen -n 2 -type primes\n\n./gen -n 10 -type random_gcd_in_array\n./gen -n 10 -type random_gcd_not_in_array\n./gen -n 10 -type gcd_is_one_with_one\n./gen -n 10 -type gcd_is_one_without_one\n./gen -n 10 -type same_numbers\n./gen -n 10 -type primes\n\n./gen -n 1000 -type random_gcd_in_array\n./gen -n 1000 -type random_gcd_not_in_array\n./gen -n 1000 -type gcd_is_one_with_one\n./gen -n 1000 -type gcd_is_one_without_one\n./gen -n 1000 -type same_numbers\n./gen -n 1000 -type primes\n\n./gen -n 100000 -type random_gcd_in_array\n./gen -n 100000 -type random_gcd_not_in_array\n./gen -n 100000 -type gcd_is_one_with_one\n./gen -n 100000 -type gcd_is_one_without_one\n./gen -n 100000 -type same_numbers\n./gen -n 100000 -type primes\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:04:26.507594",
        "total_tutorials": 3,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "299/B",
      "title": "B. Ksusha the Squirrel",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains two integers n and k (2 ≤ n ≤ 3·105, 1 ≤ k ≤ 3·105). The next line contains n characters — the description of the road: the i-th character equals \".\", if the i-th sector contains no rocks. Otherwise, it equals \"#\".It is guaranteed that the first and the last characters equal \".\".",
      "output_spec": "OutputPrint \"YES\" (without the quotes) if Ksusha can reach the end of the road, otherwise print \"NO\" (without the quotes).",
      "sample_tests": "ExamplesInputCopy2 1..OutputCopyYESInputCopy5 2.#.#.OutputCopyYESInputCopy7 3.#.###.OutputCopyNO",
      "description": "B. Ksusha the Squirrel\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains two integers n and k (2 ≤ n ≤ 3·105, 1 ≤ k ≤ 3·105). The next line contains n characters — the description of the road: the i-th character equals \".\", if the i-th sector contains no rocks. Otherwise, it equals \"#\".It is guaranteed that the first and the last characters equal \".\".\n\nOutputPrint \"YES\" (without the quotes) if Ksusha can reach the end of the road, otherwise print \"NO\" (without the quotes).\n\nInputCopy2 1..OutputCopyYESInputCopy5 2.#.#.OutputCopyYESInputCopy7 3.#.###.OutputCopyNO\n\nInputCopy2 1..\n\nOutputCopyYES\n\nInputCopy5 2.#.#.\n\nOutputCopyYES\n\nInputCopy7 3.#.###.\n\nOutputCopyNO",
      "solutions": [
        {
          "title": "CROC Champ 2013 — Round 2 - Codeforces",
          "content": "Hello everyone!Round 2 of All-Russian Programming Championship CROC-2013 will take place today. Round was prepared by sdya, Seyaua, Gerald and traditionally, problem statements were translated to English by Delinur.Good news for people, who didn't qualify to this round — today everyone can participate out the competition. Additionally, round will be rated for both official participants and out of competition participants.Remind some facts about the official participants: All the participants should be 18+ years old The championship finals are going to take place on May, 16-17 in Moscow in the CROC office (50 participants) The CROC company pays for the accomodation in Moscow during the finals For Russian citizens: the travel expenses around Russia will be covered, the transport expenses outside Russia can be covered possibly partially but you need to contact CROC and clarify it for each particular case All finalists should confirm invitation and their participation in finals until May 2 A little bonus: top 200 official Championship contestants will receive t-shirts!Enjoy problems and good luck!UPD: Point values for problems will be unusual today. 500-1500-1500-2000-2500 for first division and 500-1000-1500-2500-2500 for second.UPD2: We are really sorry for technical problems. After some discussion we have decided that this round should be rated. The list of the finalists will be based on today's results.",
          "author": "Seyaua",
          "url": "https://codeforces.com/blog/entry/7460",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1426
        },
        {
          "title": "Croc Champ 2013 — Round 2 — Editorial - Codeforces",
          "content": "Here you can find the solutions for the problems from the past round. You can ask questions in the comments below.A Div 2If ai divide aj than ai ≤ aj. So the number which will divide every other number should be less than or equal to every other number, so the only possible candidate — it's the minimum in the array. So just check whether all elements are divisible by the minimal one.B Div 2Easy to see, that Ksusha is unable to complete her journey if there is a sequence of consecutive # with length more than k.C Div 2 / A Div 1The first observation — we don't care about the actual strings, all information we need — number of pairs {0,0}, {0,1}, {1,0}, {1,1}. Count that and then just follow the greedy algorithm, for the first player: try to get a index with {1,1} if there are some, than {1,0}, than {0,1} and than {0,0}.For the second player similar strategy: first {1,1}, than {0,1}, than {1,0}, than {0,0}.After that just compare who has more 1.D Div 2 / B Div 1Every path from the topleft cell to the bottomright cell contain exactly n + m - 1 cells. And all of the should be of different color. So n + m - 1 ≤ k. Due to the small constraints for k we may assume that bruteforce might work. The only optimization to get the correct solution is some canonization of the colors. So let's go over all of the cells in some order and color them but with following condition. If i > j, than color i appeared later than color j. If we bruteforce in such way we will have about 1 million different patterns for max case. Than just match them with already painted cells and calculate for each pattern how many different permutations of color we can apply to it.E Div 2 / C Div 1After reading the problem statement one can understand that all we need is to calculate the number of positive integer solutions of equation: (a + b + c)3 - a3 - b3 - c3 = n.The key observation is: 3(a + b)(a + c)(b + c) = (a + b + c)3 - a3 - b3 - c3, after that simply calculate all divisors of and then first go over all x = a + b, such that then go over all y = (a + c) ≥ x, such that and then determine z = (b + c), such that . After that we need to solve the system a + b = x, a + c = y, b + c = z and find out how many solutions it adds.D Div 1We can see that we asked to calculate for all integer points inside the polygon or on its border. We can see that we can process Xs and Ys independently.For each x determine yleft, yright, such that all points (x, y) where yleft ≤ y ≤ yright are inside the polygon and the range [yleft, yright] is as maximal as possible. Now let's assume that we have a1, a2, ..., ak different points with fixed x coordinate (a1 stands for x =  - 106, a2 for x =  - 106 + 1 and so on).Now the required answer is a2a1 + a3(a2 + 22a1) + a4(a3 + 22a2 + 32a1) + ... We can see that: (a2 + 22a1) - a1 = a2 + 3a1,(a3 + 22a2 + 32a1) - (a2 + 22a1) = a3 + 3a2 + 5a1,and so on.So we can precalculate partial sums like a2 + 3a1, a3 + 3a2 + 5a1, a4 + 3a3 + 5a2 + 7a1 (the difference between two consecutive sums is 2(ai + ... + a1), so we can do that in O(k) time).After this precomputation we just need to sum the results.E Div 1Let's assume that we have a data structure which can perform such operations as: — add point (x,y) to the structure; shift all points in the structure by vector (dx,dy); answer how many point (x,y) are in the structure where x ≤ xbound, y ≤ ybound; get all elements which are now in the structure; For every vertex of the tree we will store the pointer to such structure.How we update the structures. We will proceed all the vertices in dfs order, if we are in a leaf node, than we create structure which contains only one element (0,0).Otherwise we will sort the children structures by it's size in decreasing order and assign the pointer of the biggest structure to the pointer of the current vertex (Don't forget to shift the structure by (1, weight of edge)).After that we will go over all other children one by one and do the following thing: Shift the structure by (1, weight of edge); Get all elements from the structure; For every element (x,y) answer the query xbound = L - x, ybound = W - y (we use parent's structure); Add elements one by one into the structure; After that answer the query xbound = L, ybound = W and add element (0,0).The sum of the results of all the queries is our answer. It's easy to see that there will be no more than queries and add operations.The remaining part is designing the structure.It can be done in many ways. One of the ways: We have small structures with sizes equals to powers of two; Each structure — it's two-dimensional segments tree; We can add one element in a following way: if there is no substructure with size 1, than add it; else get structures with sizes 1, 2, 4, ..., 2k and all its' elements and rebuild the structure with size 2k + 1; Shifting — just remember shifting vector for every substructure; Answering the query — go over all substructures and add the results. Editorial was prepared by sdya and Seyaua",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/7516",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 5006
        },
        {
          "title": "Croc Champ 2013 — Round 2 — Editorial - Codeforces",
          "content": "Here you can find the solutions for the problems from the past round. You can ask questions in the comments below.A Div 2If ai divide aj than ai ≤ aj. So the number which will divide every other number should be less than or equal to every other number, so the only possible candidate — it's the minimum in the array. So just check whether all elements are divisible by the minimal one.B Div 2Easy to see, that Ksusha is unable to complete her journey if there is a sequence of consecutive # with length more than k.C Div 2 / A Div 1The first observation — we don't care about the actual strings, all information we need — number of pairs {0,0}, {0,1}, {1,0}, {1,1}. Count that and then just follow the greedy algorithm, for the first player: try to get a index with {1,1} if there are some, than {1,0}, than {0,1} and than {0,0}.For the second player similar strategy: first {1,1}, than {0,1}, than {1,0}, than {0,0}.After that just compare who has more 1.D Div 2 / B Div 1Every path from the topleft cell to the bottomright cell contain exactly n + m - 1 cells. And all of the should be of different color. So n + m - 1 ≤ k. Due to the small constraints for k we may assume that bruteforce might work. The only optimization to get the correct solution is some canonization of the colors. So let's go over all of the cells in some order and color them but with following condition. If i > j, than color i appeared later than color j. If we bruteforce in such way we will have about 1 million different patterns for max case. Than just match them with already painted cells and calculate for each pattern how many different permutations of color we can apply to it.E Div 2 / C Div 1After reading the problem statement one can understand that all we need is to calculate the number of positive integer solutions of equation: (a + b + c)3 - a3 - b3 - c3 = n.The key observation is: 3(a + b)(a + c)(b + c) = (a + b + c)3 - a3 - b3 - c3, after that simply calculate all divisors of and then first go over all x = a + b, such that then go over all y = (a + c) ≥ x, such that and then determine z = (b + c), such that . After that we need to solve the system a + b = x, a + c = y, b + c = z and find out how many solutions it adds.D Div 1We can see that we asked to calculate for all integer points inside the polygon or on its border. We can see that we can process Xs and Ys independently.For each x determine yleft, yright, such that all points (x, y) where yleft ≤ y ≤ yright are inside the polygon and the range [yleft, yright] is as maximal as possible. Now let's assume that we have a1, a2, ..., ak different points with fixed x coordinate (a1 stands for x =  - 106, a2 for x =  - 106 + 1 and so on).Now the required answer is a2a1 + a3(a2 + 22a1) + a4(a3 + 22a2 + 32a1) + ... We can see that: (a2 + 22a1) - a1 = a2 + 3a1,(a3 + 22a2 + 32a1) - (a2 + 22a1) = a3 + 3a2 + 5a1,and so on.So we can precalculate partial sums like a2 + 3a1, a3 + 3a2 + 5a1, a4 + 3a3 + 5a2 + 7a1 (the difference between two consecutive sums is 2(ai + ... + a1), so we can do that in O(k) time).After this precomputation we just need to sum the results.E Div 1Let's assume that we have a data structure which can perform such operations as: — add point (x,y) to the structure; shift all points in the structure by vector (dx,dy); answer how many point (x,y) are in the structure where x ≤ xbound, y ≤ ybound; get all elements which are now in the structure; For every vertex of the tree we will store the pointer to such structure.How we update the structures. We will proceed all the vertices in dfs order, if we are in a leaf node, than we create structure which contains only one element (0,0).Otherwise we will sort the children structures by it's size in decreasing order and assign the pointer of the biggest structure to the pointer of the current vertex (Don't forget to shift the structure by (1, weight of edge)).After that we will go over all other children one by one and do the following thing: Shift the structure by (1, weight of edge); Get all elements from the structure; For every element (x,y) answer the query xbound = L - x, ybound = W - y (we use parent's structure); Add elements one by one into the structure; After that answer the query xbound = L, ybound = W and add element (0,0).The sum of the results of all the queries is our answer. It's easy to see that there will be no more than queries and add operations.The remaining part is designing the structure.It can be done in many ways. One of the ways: We have small structures with sizes equals to powers of two; Each structure — it's two-dimensional segments tree; We can add one element in a following way: if there is no substructure with size 1, than add it; else get structures with sizes 1, 2, 4, ..., 2k and all its' elements and rebuild the structure with size 2k + 1; Shifting — just remember shifting vector for every substructure; Answering the query — go over all substructures and add the results. Editorial was prepared by sdya and Seyaua",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/7516",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 5006
        }
      ],
      "code_examples": [
        {
          "title": "CROC Champ 2013 — Round 2 - Codeforces - Code 1",
          "code": "if(F > S) cout << \"First\";\nif(F + 1 < S) cout << \"Second\";\nif(F == S) cout << \"Draw\";",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7460",
          "author": "Seyaua"
        },
        {
          "title": "CROC Champ 2013 — Round 2 - Codeforces - Code 2",
          "code": "if(F > S) cout << \"First\";\nif(F + 1 < S) cout << \"Second\";\nif(F == S) cout << \"Draw\";",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7460",
          "author": "Seyaua"
        },
        {
          "title": "CROC Champ 2013 — Round 2 - Codeforces - Code 3",
          "code": "(a+b+c)^3 - a^3 - b^3 - c^3 = 3*(a+b)*(b+c)*(c+a)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7460",
          "author": "Seyaua"
        },
        {
          "title": "CROC Champ 2013 — Round 2 - Codeforces - Code 4",
          "code": "(a+b+c)^3 - a^3 - b^3 - c^3 = 3*(a+b)*(b+c)*(c+a)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7460",
          "author": "Seyaua"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(2, 300000, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(1, 300000, \"k\");\n    inf.readEoln();\n    string s = inf.readLine();\n    ensuref(int(s.length()) == n, \"Length of the string s must be equal to n=%d, but found %d\", n, int(s.length()));\n    for (int i = 0; i < n; ++i) {\n        ensuref(s[i] == '.' || s[i] == '#', \"Character s[%d]=%c is not '.' or '#'\", i+1, s[i]);\n    }\n    ensuref(s[0] == '.', \"First character must be '.'\");\n    ensuref(s[n-1] == '.', \"Last character must be '.'\");\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(2, 300000, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(1, 300000, \"k\");\n    inf.readEoln();\n    string s = inf.readLine();\n    ensuref(int(s.length()) == n, \"Length of the string s must be equal to n=%d, but found %d\", n, int(s.length()));\n    for (int i = 0; i < n; ++i) {\n        ensuref(s[i] == '.' || s[i] == '#', \"Character s[%d]=%c is not '.' or '#'\", i+1, s[i]);\n    }\n    ensuref(s[0] == '.', \"First character must be '.'\");\n    ensuref(s[n-1] == '.', \"Last character must be '.'\");\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(2, 300000, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(1, 300000, \"k\");\n    inf.readEoln();\n    string s = inf.readLine();\n    ensuref(int(s.length()) == n, \"Length of the string s must be equal to n=%d, but found %d\", n, int(s.length()));\n    for (int i = 0; i < n; ++i) {\n        ensuref(s[i] == '.' || s[i] == '#', \"Character s[%d]=%c is not '.' or '#'\", i+1, s[i]);\n    }\n    ensuref(s[0] == '.', \"First character must be '.'\");\n    ensuref(s[n-1] == '.', \"Last character must be '.'\");\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n#include <string>\r\n\r\nusing namespace std;\r\n\r\nconst string YES = \"YES\";\r\nconst string NO = \"NO\";\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"%s\", (\"multiple \" + YES + \"/\" + NO + \" (case insensitive)\").c_str());\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int index = 0, yesCount = 0, noCount = 0;\r\n    string pa;\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        index++;\r\n        string ja = upperCase(ans.readToken());\r\n        pa = upperCase(ouf.readToken());\r\n\r\n        if (ja != YES && ja != NO)\r\n            quitf(_fail, \"%s or %s expected in answer, but %s found [%d%s token]\",\r\n                  YES.c_str(), NO.c_str(), compress(ja).c_str(), index, englishEnding(index).c_str());\r\n\r\n        if (pa == YES)\r\n            yesCount++;\r\n        else if (pa == NO)\r\n            noCount++;\r\n        else\r\n            quitf(_pe, \"%s or %s expected, but %s found [%d%s token]\",\r\n                  YES.c_str(), NO.c_str(), compress(pa).c_str(), index, englishEnding(index).c_str());\r\n\r\n        if (ja != pa)\r\n            quitf(_wa, \"expected %s, found %s [%d%s token]\",\r\n                  compress(ja).c_str(), compress(pa).c_str(), index, englishEnding(index).c_str());\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n    while (!ans.seekEof()) {\r\n        ans.readToken();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n    while (!ouf.seekEof()) {\r\n        ouf.readToken();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              index + extraInAnsCount, index);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              index + extraInOufCount, index);\r\n\r\n    if (index == 0)\r\n        quitf(_ok, \"Empty output\");\r\n    else if (index == 1)\r\n        quitf(_ok, \"%s\", pa.c_str());\r\n    else\r\n        quitf(_ok, \"%d token(s): yes count is %d, no count is %d\", index, yesCount, noCount);\r\n\r\n    quitf(_fail, \"Impossible case\");\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int k = opt<int>(\"k\");\n    string type = opt<string>(\"type\", \"random\");\n\n    string road(n, '.');\n\n    // First and last positions should be '.'\n    road[0] = '.';\n    road[n - 1] = '.';\n\n    if (type == \"random\") {\n        // Randomly place rocks in positions 1 to n-2\n        for (int i = 1; i < n - 1; ++i) {\n            if (rnd.next(2)) {\n                road[i] = '#';\n            }\n        }\n    }\n    else if (type == \"no_rocks\") {\n        // All positions are '.'\n        // Road is already initialized with '.'\n    }\n    else if (type == \"full_rocks\") {\n        // All positions except first and last are '#'\n        for (int i = 1; i < n - 1; ++i) {\n            road[i] = '#';\n        }\n    }\n    else if (type == \"blocked\" || type == \"path_not_exists\") {\n        // Create a block of rocks longer than k somewhere in the road\n        int block_len = k + 1;\n        if (block_len >= n - 2) {\n            // Can't place such a block, so fill as much as possible\n            block_len = n - 2;\n        }\n        int start_pos = rnd.next(1, n - 2 - block_len + 1);\n        for (int i = start_pos; i < start_pos + block_len; ++i) {\n            road[i] = '#';\n        }\n    }\n    else if (type == \"path_exists\") {\n        // Randomly place rocks, ensuring no block of rocks longer than k\n        int rock_block = 0;\n        for (int i = 1; i < n - 1; ++i) {\n            if (rock_block == k) {\n                // Must place '.' to avoid block longer than k\n                road[i] = '.';\n                rock_block = 0;\n            }\n            else {\n                if (rnd.next(2)) {\n                    road[i] = '#';\n                    rock_block++;\n                }\n                else {\n                    road[i] = '.';\n                    rock_block = 0;\n                }\n            }\n        }\n    }\n    else if (type == \"max_jump\") {\n        // Set k to maximum allowed value\n        k = 300000;\n        // Randomly place rocks\n        for (int i = 1; i < n - 1; ++i) {\n            if (rnd.next(2)) {\n                road[i] = '#';\n            }\n        }\n    }\n    else if (type == \"zigzag\") {\n        // Alternate between '.' and '#'\n        for (int i = 1; i < n - 1; ++i) {\n            if (i % 2 == 0) {\n                road[i] = '.';\n            }\n            else {\n                road[i] = '#';\n            }\n        }\n    }\n    else if (type == \"staircase\") {\n        // Create increasing blocks of rocks\n        int block_size = 1;\n        int i = 1;\n        while (i < n - 1) {\n            // Place '.' before each block\n            road[i++] = '.';\n            // Place block of rocks\n            for (int j = 0; j < block_size && i < n - 1; ++j, ++i) {\n                road[i] = '#';\n            }\n            block_size++;\n        }\n    }\n    else {\n        // Default to random\n        for (int i = 1; i < n - 1; ++i) {\n            if (rnd.next(2)) {\n                road[i] = '#';\n            }\n        }\n    }\n\n    // Output n and k\n    printf(\"%d %d\\n\", n, k);\n    printf(\"%s\\n\", road.c_str());\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int k = opt<int>(\"k\");\n    string type = opt<string>(\"type\", \"random\");\n\n    string road(n, '.');\n\n    // First and last positions should be '.'\n    road[0] = '.';\n    road[n - 1] = '.';\n\n    if (type == \"random\") {\n        // Randomly place rocks in positions 1 to n-2\n        for (int i = 1; i < n - 1; ++i) {\n            if (rnd.next(2)) {\n                road[i] = '#';\n            }\n        }\n    }\n    else if (type == \"no_rocks\") {\n        // All positions are '.'\n        // Road is already initialized with '.'\n    }\n    else if (type == \"full_rocks\") {\n        // All positions except first and last are '#'\n        for (int i = 1; i < n - 1; ++i) {\n            road[i] = '#';\n        }\n    }\n    else if (type == \"blocked\" || type == \"path_not_exists\") {\n        // Create a block of rocks longer than k somewhere in the road\n        int block_len = k + 1;\n        if (block_len >= n - 2) {\n            // Can't place such a block, so fill as much as possible\n            block_len = n - 2;\n        }\n        int start_pos = rnd.next(1, n - 2 - block_len + 1);\n        for (int i = start_pos; i < start_pos + block_len; ++i) {\n            road[i] = '#';\n        }\n    }\n    else if (type == \"path_exists\") {\n        // Randomly place rocks, ensuring no block of rocks longer than k\n        int rock_block = 0;\n        for (int i = 1; i < n - 1; ++i) {\n            if (rock_block == k) {\n                // Must place '.' to avoid block longer than k\n                road[i] = '.';\n                rock_block = 0;\n            }\n            else {\n                if (rnd.next(2)) {\n                    road[i] = '#';\n                    rock_block++;\n                }\n                else {\n                    road[i] = '.';\n                    rock_block = 0;\n                }\n            }\n        }\n    }\n    else if (type == \"max_jump\") {\n        // Set k to maximum allowed value\n        k = 300000;\n        // Randomly place rocks\n        for (int i = 1; i < n - 1; ++i) {\n            if (rnd.next(2)) {\n                road[i] = '#';\n            }\n        }\n    }\n    else if (type == \"zigzag\") {\n        // Alternate between '.' and '#'\n        for (int i = 1; i < n - 1; ++i) {\n            if (i % 2 == 0) {\n                road[i] = '.';\n            }\n            else {\n                road[i] = '#';\n            }\n        }\n    }\n    else if (type == \"staircase\") {\n        // Create increasing blocks of rocks\n        int block_size = 1;\n        int i = 1;\n        while (i < n - 1) {\n            // Place '.' before each block\n            road[i++] = '.';\n            // Place block of rocks\n            for (int j = 0; j < block_size && i < n - 1; ++j, ++i) {\n                road[i] = '#';\n            }\n            block_size++;\n        }\n    }\n    else {\n        // Default to random\n        for (int i = 1; i < n - 1; ++i) {\n            if (rnd.next(2)) {\n                road[i] = '#';\n            }\n        }\n    }\n\n    // Output n and k\n    printf(\"%d %d\\n\", n, k);\n    printf(\"%s\\n\", road.c_str());\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 2 -k 1 -type random\n./gen -n 5 -k 2 -type random\n./gen -n 7 -k 3 -type random\n\n./gen -n 10 -k 1 -type no_rocks\n./gen -n 100 -k 10 -type no_rocks\n./gen -n 1000 -k 100 -type no_rocks\n\n./gen -n 10 -k 10 -type full_rocks\n./gen -n 100 -k 50 -type full_rocks\n./gen -n 1000 -k 500 -type full_rocks\n\n./gen -n 20 -k 5 -type blocked\n./gen -n 100 -k 20 -type blocked\n./gen -n 1000 -k 200 -type blocked\n\n./gen -n 20 -k 5 -type path_exists\n./gen -n 100 -k 20 -type path_exists\n./gen -n 1000 -k 200 -type path_exists\n\n./gen -n 300000 -k 1 -type random\n./gen -n 300000 -k 300000 -type random\n\n./gen -n 300000 -k 300000 -type path_exists\n./gen -n 300000 -k 300000 -type blocked\n\n./gen -n 300000 -k 300000 -type no_rocks\n./gen -n 300000 -k 1 -type no_rocks\n\n./gen -n 300000 -k 1 -type full_rocks\n\n./gen -n 300000 -k 300000 -type zigzag\n./gen -n 100000 -k 100000 -type staircase\n\n./gen -n 100000 -k 5 -type random\n./gen -n 100000 -k 5 -type path_exists\n./gen -n 100000 -k 5 -type blocked\n\n./gen -n 1000 -k 1 -type zigzag\n./gen -n 1000 -k 10 -type staircase\n./gen -n 1000 -k 100 -type max_jump\n\n./gen -n 300000 -k 1 -type max_jump\n./gen -n 300000 -k 300000 -type max_jump\n\n./gen -n 299999 -k 1 -type blocked\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:04:28.477144",
        "total_tutorials": 3,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "299/C",
      "title": "C. Weird Game",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains integer n (1 ≤ n ≤ 106). The second line contains string s — Yaroslav's word. The third line contains string t — Andrey's word.It is guaranteed that both words consist of 2·n characters \"0\" and \"1\".",
      "output_spec": "OutputPrint \"First\", if both players play optimally well and Yaroslav wins. If Andrey wins, print \"Second\" and if the game ends with a draw, print \"Draw\". Print the words without the quotes.",
      "sample_tests": "ExamplesInputCopy201110001OutputCopyFirstInputCopy3110110001001OutputCopyFirstInputCopy3111000000111OutputCopyDrawInputCopy40101011000101101OutputCopyFirstInputCopy40110000010010011OutputCopySecond",
      "description": "C. Weird Game\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains integer n (1 ≤ n ≤ 106). The second line contains string s — Yaroslav's word. The third line contains string t — Andrey's word.It is guaranteed that both words consist of 2·n characters \"0\" and \"1\".\n\nOutputPrint \"First\", if both players play optimally well and Yaroslav wins. If Andrey wins, print \"Second\" and if the game ends with a draw, print \"Draw\". Print the words without the quotes.\n\nInputCopy201110001OutputCopyFirstInputCopy3110110001001OutputCopyFirstInputCopy3111000000111OutputCopyDrawInputCopy40101011000101101OutputCopyFirstInputCopy40110000010010011OutputCopySecond\n\nInputCopy201110001\n\nOutputCopyFirst\n\nInputCopy3110110001001\n\nOutputCopyFirst\n\nInputCopy3111000000111\n\nOutputCopyDraw\n\nInputCopy40101011000101101\n\nOutputCopyFirst\n\nInputCopy40110000010010011\n\nOutputCopySecond",
      "solutions": [
        {
          "title": "CROC Champ 2013 — Round 2 - Codeforces",
          "content": "Hello everyone!Round 2 of All-Russian Programming Championship CROC-2013 will take place today. Round was prepared by sdya, Seyaua, Gerald and traditionally, problem statements were translated to English by Delinur.Good news for people, who didn't qualify to this round — today everyone can participate out the competition. Additionally, round will be rated for both official participants and out of competition participants.Remind some facts about the official participants: All the participants should be 18+ years old The championship finals are going to take place on May, 16-17 in Moscow in the CROC office (50 participants) The CROC company pays for the accomodation in Moscow during the finals For Russian citizens: the travel expenses around Russia will be covered, the transport expenses outside Russia can be covered possibly partially but you need to contact CROC and clarify it for each particular case All finalists should confirm invitation and their participation in finals until May 2 A little bonus: top 200 official Championship contestants will receive t-shirts!Enjoy problems and good luck!UPD: Point values for problems will be unusual today. 500-1500-1500-2000-2500 for first division and 500-1000-1500-2500-2500 for second.UPD2: We are really sorry for technical problems. After some discussion we have decided that this round should be rated. The list of the finalists will be based on today's results.",
          "author": "Seyaua",
          "url": "https://codeforces.com/blog/entry/7460",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1426
        },
        {
          "title": "Croc Champ 2013 — Round 2 — Editorial - Codeforces",
          "content": "Here you can find the solutions for the problems from the past round. You can ask questions in the comments below.A Div 2If ai divide aj than ai ≤ aj. So the number which will divide every other number should be less than or equal to every other number, so the only possible candidate — it's the minimum in the array. So just check whether all elements are divisible by the minimal one.B Div 2Easy to see, that Ksusha is unable to complete her journey if there is a sequence of consecutive # with length more than k.C Div 2 / A Div 1The first observation — we don't care about the actual strings, all information we need — number of pairs {0,0}, {0,1}, {1,0}, {1,1}. Count that and then just follow the greedy algorithm, for the first player: try to get a index with {1,1} if there are some, than {1,0}, than {0,1} and than {0,0}.For the second player similar strategy: first {1,1}, than {0,1}, than {1,0}, than {0,0}.After that just compare who has more 1.D Div 2 / B Div 1Every path from the topleft cell to the bottomright cell contain exactly n + m - 1 cells. And all of the should be of different color. So n + m - 1 ≤ k. Due to the small constraints for k we may assume that bruteforce might work. The only optimization to get the correct solution is some canonization of the colors. So let's go over all of the cells in some order and color them but with following condition. If i > j, than color i appeared later than color j. If we bruteforce in such way we will have about 1 million different patterns for max case. Than just match them with already painted cells and calculate for each pattern how many different permutations of color we can apply to it.E Div 2 / C Div 1After reading the problem statement one can understand that all we need is to calculate the number of positive integer solutions of equation: (a + b + c)3 - a3 - b3 - c3 = n.The key observation is: 3(a + b)(a + c)(b + c) = (a + b + c)3 - a3 - b3 - c3, after that simply calculate all divisors of and then first go over all x = a + b, such that then go over all y = (a + c) ≥ x, such that and then determine z = (b + c), such that . After that we need to solve the system a + b = x, a + c = y, b + c = z and find out how many solutions it adds.D Div 1We can see that we asked to calculate for all integer points inside the polygon or on its border. We can see that we can process Xs and Ys independently.For each x determine yleft, yright, such that all points (x, y) where yleft ≤ y ≤ yright are inside the polygon and the range [yleft, yright] is as maximal as possible. Now let's assume that we have a1, a2, ..., ak different points with fixed x coordinate (a1 stands for x =  - 106, a2 for x =  - 106 + 1 and so on).Now the required answer is a2a1 + a3(a2 + 22a1) + a4(a3 + 22a2 + 32a1) + ... We can see that: (a2 + 22a1) - a1 = a2 + 3a1,(a3 + 22a2 + 32a1) - (a2 + 22a1) = a3 + 3a2 + 5a1,and so on.So we can precalculate partial sums like a2 + 3a1, a3 + 3a2 + 5a1, a4 + 3a3 + 5a2 + 7a1 (the difference between two consecutive sums is 2(ai + ... + a1), so we can do that in O(k) time).After this precomputation we just need to sum the results.E Div 1Let's assume that we have a data structure which can perform such operations as: — add point (x,y) to the structure; shift all points in the structure by vector (dx,dy); answer how many point (x,y) are in the structure where x ≤ xbound, y ≤ ybound; get all elements which are now in the structure; For every vertex of the tree we will store the pointer to such structure.How we update the structures. We will proceed all the vertices in dfs order, if we are in a leaf node, than we create structure which contains only one element (0,0).Otherwise we will sort the children structures by it's size in decreasing order and assign the pointer of the biggest structure to the pointer of the current vertex (Don't forget to shift the structure by (1, weight of edge)).After that we will go over all other children one by one and do the following thing: Shift the structure by (1, weight of edge); Get all elements from the structure; For every element (x,y) answer the query xbound = L - x, ybound = W - y (we use parent's structure); Add elements one by one into the structure; After that answer the query xbound = L, ybound = W and add element (0,0).The sum of the results of all the queries is our answer. It's easy to see that there will be no more than queries and add operations.The remaining part is designing the structure.It can be done in many ways. One of the ways: We have small structures with sizes equals to powers of two; Each structure — it's two-dimensional segments tree; We can add one element in a following way: if there is no substructure with size 1, than add it; else get structures with sizes 1, 2, 4, ..., 2k and all its' elements and rebuild the structure with size 2k + 1; Shifting — just remember shifting vector for every substructure; Answering the query — go over all substructures and add the results. Editorial was prepared by sdya and Seyaua",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/7516",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 5006
        },
        {
          "title": "Croc Champ 2013 — Round 2 — Editorial - Codeforces",
          "content": "Here you can find the solutions for the problems from the past round. You can ask questions in the comments below.A Div 2If ai divide aj than ai ≤ aj. So the number which will divide every other number should be less than or equal to every other number, so the only possible candidate — it's the minimum in the array. So just check whether all elements are divisible by the minimal one.B Div 2Easy to see, that Ksusha is unable to complete her journey if there is a sequence of consecutive # with length more than k.C Div 2 / A Div 1The first observation — we don't care about the actual strings, all information we need — number of pairs {0,0}, {0,1}, {1,0}, {1,1}. Count that and then just follow the greedy algorithm, for the first player: try to get a index with {1,1} if there are some, than {1,0}, than {0,1} and than {0,0}.For the second player similar strategy: first {1,1}, than {0,1}, than {1,0}, than {0,0}.After that just compare who has more 1.D Div 2 / B Div 1Every path from the topleft cell to the bottomright cell contain exactly n + m - 1 cells. And all of the should be of different color. So n + m - 1 ≤ k. Due to the small constraints for k we may assume that bruteforce might work. The only optimization to get the correct solution is some canonization of the colors. So let's go over all of the cells in some order and color them but with following condition. If i > j, than color i appeared later than color j. If we bruteforce in such way we will have about 1 million different patterns for max case. Than just match them with already painted cells and calculate for each pattern how many different permutations of color we can apply to it.E Div 2 / C Div 1After reading the problem statement one can understand that all we need is to calculate the number of positive integer solutions of equation: (a + b + c)3 - a3 - b3 - c3 = n.The key observation is: 3(a + b)(a + c)(b + c) = (a + b + c)3 - a3 - b3 - c3, after that simply calculate all divisors of and then first go over all x = a + b, such that then go over all y = (a + c) ≥ x, such that and then determine z = (b + c), such that . After that we need to solve the system a + b = x, a + c = y, b + c = z and find out how many solutions it adds.D Div 1We can see that we asked to calculate for all integer points inside the polygon or on its border. We can see that we can process Xs and Ys independently.For each x determine yleft, yright, such that all points (x, y) where yleft ≤ y ≤ yright are inside the polygon and the range [yleft, yright] is as maximal as possible. Now let's assume that we have a1, a2, ..., ak different points with fixed x coordinate (a1 stands for x =  - 106, a2 for x =  - 106 + 1 and so on).Now the required answer is a2a1 + a3(a2 + 22a1) + a4(a3 + 22a2 + 32a1) + ... We can see that: (a2 + 22a1) - a1 = a2 + 3a1,(a3 + 22a2 + 32a1) - (a2 + 22a1) = a3 + 3a2 + 5a1,and so on.So we can precalculate partial sums like a2 + 3a1, a3 + 3a2 + 5a1, a4 + 3a3 + 5a2 + 7a1 (the difference between two consecutive sums is 2(ai + ... + a1), so we can do that in O(k) time).After this precomputation we just need to sum the results.E Div 1Let's assume that we have a data structure which can perform such operations as: — add point (x,y) to the structure; shift all points in the structure by vector (dx,dy); answer how many point (x,y) are in the structure where x ≤ xbound, y ≤ ybound; get all elements which are now in the structure; For every vertex of the tree we will store the pointer to such structure.How we update the structures. We will proceed all the vertices in dfs order, if we are in a leaf node, than we create structure which contains only one element (0,0).Otherwise we will sort the children structures by it's size in decreasing order and assign the pointer of the biggest structure to the pointer of the current vertex (Don't forget to shift the structure by (1, weight of edge)).After that we will go over all other children one by one and do the following thing: Shift the structure by (1, weight of edge); Get all elements from the structure; For every element (x,y) answer the query xbound = L - x, ybound = W - y (we use parent's structure); Add elements one by one into the structure; After that answer the query xbound = L, ybound = W and add element (0,0).The sum of the results of all the queries is our answer. It's easy to see that there will be no more than queries and add operations.The remaining part is designing the structure.It can be done in many ways. One of the ways: We have small structures with sizes equals to powers of two; Each structure — it's two-dimensional segments tree; We can add one element in a following way: if there is no substructure with size 1, than add it; else get structures with sizes 1, 2, 4, ..., 2k and all its' elements and rebuild the structure with size 2k + 1; Shifting — just remember shifting vector for every substructure; Answering the query — go over all substructures and add the results. Editorial was prepared by sdya and Seyaua",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/7516",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 5006
        }
      ],
      "code_examples": [
        {
          "title": "CROC Champ 2013 — Round 2 - Codeforces - Code 1",
          "code": "if(F > S) cout << \"First\";\nif(F + 1 < S) cout << \"Second\";\nif(F == S) cout << \"Draw\";",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7460",
          "author": "Seyaua"
        },
        {
          "title": "CROC Champ 2013 — Round 2 - Codeforces - Code 2",
          "code": "if(F > S) cout << \"First\";\nif(F + 1 < S) cout << \"Second\";\nif(F == S) cout << \"Draw\";",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7460",
          "author": "Seyaua"
        },
        {
          "title": "CROC Champ 2013 — Round 2 - Codeforces - Code 3",
          "code": "(a+b+c)^3 - a^3 - b^3 - c^3 = 3*(a+b)*(b+c)*(c+a)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7460",
          "author": "Seyaua"
        },
        {
          "title": "CROC Champ 2013 — Round 2 - Codeforces - Code 4",
          "code": "(a+b+c)^3 - a^3 - b^3 - c^3 = 3*(a+b)*(b+c)*(c+a)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7460",
          "author": "Seyaua"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 1000000, \"n\");\n    inf.readEoln();\n\n    string s = inf.readToken();\n    inf.readEoln();\n\n    string t = inf.readToken();\n    inf.readEoln();\n\n    ensuref((int)s.length() == 2 * n, \"Length of s is %d, but expected %d\", (int)s.length(), 2 * n);\n    for (char c : s) {\n        ensuref(c == '0' || c == '1', \"Invalid character '%c' in s\", c);\n    }\n\n    ensuref((int)t.length() == 2 * n, \"Length of t is %d, but expected %d\", (int)t.length(), 2 * n);\n    for (char c : t) {\n        ensuref(c == '0' || c == '1', \"Invalid character '%c' in t\", c);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 1000000, \"n\");\n    inf.readEoln();\n\n    string s = inf.readToken();\n    inf.readEoln();\n\n    string t = inf.readToken();\n    inf.readEoln();\n\n    ensuref((int)s.length() == 2 * n, \"Length of s is %d, but expected %d\", (int)s.length(), 2 * n);\n    for (char c : s) {\n        ensuref(c == '0' || c == '1', \"Invalid character '%c' in s\", c);\n    }\n\n    ensuref((int)t.length() == 2 * n, \"Length of t is %d, but expected %d\", (int)t.length(), 2 * n);\n    for (char c : t) {\n        ensuref(c == '0' || c == '1', \"Invalid character '%c' in t\", c);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 1000000, \"n\");\n    inf.readEoln();\n\n    string s = inf.readToken();\n    inf.readEoln();\n\n    string t = inf.readToken();\n    inf.readEoln();\n\n    ensuref((int)s.length() == 2 * n, \"Length of s is %d, but expected %d\", (int)s.length(), 2 * n);\n    for (char c : s) {\n        ensuref(c == '0' || c == '1', \"Invalid character '%c' in s\", c);\n    }\n\n    ensuref((int)t.length() == 2 * n, \"Length of t is %d, but expected %d\", (int)t.length(), 2 * n);\n    for (char c : t) {\n        ensuref(c == '0' || c == '1', \"Invalid character '%c' in t\", c);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare sequences of tokens\");\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string j, p;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n\r\n        ans.readWordTo(j);\r\n        ouf.readWordTo(p);\r\n\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s words differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  compress(j).c_str(), compress(p).c_str());\r\n    }\r\n\r\n    if (ans.seekEof() && ouf.seekEof()) {\r\n        if (n == 1)\r\n            quitf(_ok, \"\\\"%s\\\"\", compress(j).c_str());\r\n        else\r\n            quitf(_ok, \"%d tokens\", n);\r\n    } else {\r\n        if (ans.seekEof())\r\n            quitf(_wa, \"Participant output contains extra tokens\");\r\n        else\r\n            quitf(_wa, \"Unexpected EOF in the participants output\");\r\n    }\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    string s(2 * n, '0');\n    string t(2 * n, '0');\n\n    if (type == \"random\") {\n        for (int i = 0; i < 2 * n; ++i) {\n            s[i] = rnd.next(2) + '0';\n            t[i] = rnd.next(2) + '0';\n        }\n    } else if (type == \"same\") {\n        for (int i = 0; i < 2 * n; ++i) {\n            s[i] = rnd.next(2) + '0';\n        }\n        t = s;\n    } else if (type == \"first_wins\") {\n        s.assign(2 * n, '1');\n        t.assign(2 * n, '0');\n    } else if (type == \"second_wins\") {\n        s.assign(2 * n, '0');\n        t.assign(2 * n, '1');\n    } else if (type == \"draw\") {\n        int ones = n; // total number of '1's for each string\n        int zeros = n;\n\n        vector<char> s_chars(2 * n);\n        vector<char> t_chars(2 * n);\n\n        for (int i = 0; i < 2 * n; ++i) {\n            if (ones > 0 && zeros > 0) {\n                if (rnd.next(2)) {\n                    s_chars[i] = '1';\n                    t_chars[i] = '1';\n                    ones--;\n                } else {\n                    s_chars[i] = '0';\n                    t_chars[i] = '0';\n                    zeros--;\n                }\n            } else if (ones > 0) {\n                s_chars[i] = '1';\n                t_chars[i] = '1';\n                ones--;\n            } else {\n                s_chars[i] = '0';\n                t_chars[i] = '0';\n                zeros--;\n            }\n        }\n        s.assign(s_chars.begin(), s_chars.end());\n        t.assign(t_chars.begin(), t_chars.end());\n    } else if (type == \"alternate\") {\n        for (int i = 0; i < 2 * n; ++i) {\n            s[i] = (i % 2) + '0';\n            t[i] = ((i + 1) % 2) + '0';\n        }\n    } else if (type == \"max_ones\") {\n        s.assign(2 * n, '1');\n        t.assign(2 * n, '1');\n    } else if (type == \"max_zeros\") {\n        s.assign(2 * n, '0');\n        t.assign(2 * n, '0');\n    } else if (type == \"half_and_half\") {\n        for (int i = 0; i < 2 * n; ++i) {\n            if (i < n) {\n                s[i] = '1';\n                t[i] = '0';\n            } else {\n                s[i] = '0';\n                t[i] = '1';\n            }\n        }\n    } else {\n        // Default: Random\n        for (int i = 0; i < 2 * n; ++i) {\n            s[i] = rnd.next(2) + '0';\n            t[i] = rnd.next(2) + '0';\n        }\n    }\n\n    // Output\n    printf(\"%d\\n\", n);\n    printf(\"%s\\n\", s.c_str());\n    printf(\"%s\\n\", t.c_str());\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    string s(2 * n, '0');\n    string t(2 * n, '0');\n\n    if (type == \"random\") {\n        for (int i = 0; i < 2 * n; ++i) {\n            s[i] = rnd.next(2) + '0';\n            t[i] = rnd.next(2) + '0';\n        }\n    } else if (type == \"same\") {\n        for (int i = 0; i < 2 * n; ++i) {\n            s[i] = rnd.next(2) + '0';\n        }\n        t = s;\n    } else if (type == \"first_wins\") {\n        s.assign(2 * n, '1');\n        t.assign(2 * n, '0');\n    } else if (type == \"second_wins\") {\n        s.assign(2 * n, '0');\n        t.assign(2 * n, '1');\n    } else if (type == \"draw\") {\n        int ones = n; // total number of '1's for each string\n        int zeros = n;\n\n        vector<char> s_chars(2 * n);\n        vector<char> t_chars(2 * n);\n\n        for (int i = 0; i < 2 * n; ++i) {\n            if (ones > 0 && zeros > 0) {\n                if (rnd.next(2)) {\n                    s_chars[i] = '1';\n                    t_chars[i] = '1';\n                    ones--;\n                } else {\n                    s_chars[i] = '0';\n                    t_chars[i] = '0';\n                    zeros--;\n                }\n            } else if (ones > 0) {\n                s_chars[i] = '1';\n                t_chars[i] = '1';\n                ones--;\n            } else {\n                s_chars[i] = '0';\n                t_chars[i] = '0';\n                zeros--;\n            }\n        }\n        s.assign(s_chars.begin(), s_chars.end());\n        t.assign(t_chars.begin(), t_chars.end());\n    } else if (type == \"alternate\") {\n        for (int i = 0; i < 2 * n; ++i) {\n            s[i] = (i % 2) + '0';\n            t[i] = ((i + 1) % 2) + '0';\n        }\n    } else if (type == \"max_ones\") {\n        s.assign(2 * n, '1');\n        t.assign(2 * n, '1');\n    } else if (type == \"max_zeros\") {\n        s.assign(2 * n, '0');\n        t.assign(2 * n, '0');\n    } else if (type == \"half_and_half\") {\n        for (int i = 0; i < 2 * n; ++i) {\n            if (i < n) {\n                s[i] = '1';\n                t[i] = '0';\n            } else {\n                s[i] = '0';\n                t[i] = '1';\n            }\n        }\n    } else {\n        // Default: Random\n        for (int i = 0; i < 2 * n; ++i) {\n            s[i] = rnd.next(2) + '0';\n            t[i] = rnd.next(2) + '0';\n        }\n    }\n\n    // Output\n    printf(\"%d\\n\", n);\n    printf(\"%s\\n\", s.c_str());\n    printf(\"%s\\n\", t.c_str());\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -type random\n./gen -n 1 -type same\n./gen -n 1 -type first_wins\n./gen -n 1 -type second_wins\n./gen -n 1 -type draw\n\n./gen -n 10 -type random\n./gen -n 10 -type same\n./gen -n 10 -type first_wins\n./gen -n 10 -type second_wins\n./gen -n 10 -type draw\n\n./gen -n 1000 -type random\n./gen -n 1000 -type same\n./gen -n 1000 -type first_wins\n./gen -n 1000 -type second_wins\n./gen -n 1000 -type draw\n\n./gen -n 100000 -type random\n./gen -n 100000 -type first_wins\n./gen -n 100000 -type second_wins\n\n./gen -n 1000000 -type random\n./gen -n 1000000 -type first_wins\n./gen -n 1000000 -type second_wins\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:04:30.628393",
        "total_tutorials": 3,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "299/D",
      "title": "D. Различные пути",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест2 секунды",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеВ первой строке записаны три целых числа n, m, k (1 ≤ n, m ≤ 1000, 1 ≤ k ≤ 10). В следующих n строках записано по m целых чисел — доска. В первой из них заданы m самых верхних клеток доски слева направо, во второй m вторых сверху и так далее. Если число в строке равно 0, то соответствующая клетка не покрашена, иначе это число задает изначальный цвет клетки доски — целое число от 1 до k.Считайте, что цвета пронумерованы от 1 до k некоторым образом.",
      "output_spec": "Выходные данныеВыведите остаток от деления количества возможных раскрасок на 1000000007 (109 + 7).",
      "sample_tests": "ПримерыВходные данныеСкопировать2 2 40 00 0Выходные данныеСкопировать48Входные данныеСкопировать2 2 41 22 1Выходные данныеСкопировать0Входные данныеСкопировать5 6 100 0 0 0 0 00 0 0 0 0 00 0 0 0 0 00 0 0 0 0 00 0 0 0 0 0Выходные данныеСкопировать3628800Входные данныеСкопировать2 6 101 2 3 4 5 60 0 0 0 0 0Выходные данныеСкопировать4096",
      "description": "D. Различные пути\n\nограничение по времени на тест2 секунды\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвыводstdout\n\nВходные данныеВ первой строке записаны три целых числа n, m, k (1 ≤ n, m ≤ 1000, 1 ≤ k ≤ 10). В следующих n строках записано по m целых чисел — доска. В первой из них заданы m самых верхних клеток доски слева направо, во второй m вторых сверху и так далее. Если число в строке равно 0, то соответствующая клетка не покрашена, иначе это число задает изначальный цвет клетки доски — целое число от 1 до k.Считайте, что цвета пронумерованы от 1 до k некоторым образом.\n\nВходные данные\n\nВыходные данныеВыведите остаток от деления количества возможных раскрасок на 1000000007 (109 + 7).\n\nВыходные данные\n\nВходные данныеСкопировать2 2 40 00 0Выходные данныеСкопировать48Входные данныеСкопировать2 2 41 22 1Выходные данныеСкопировать0Входные данныеСкопировать5 6 100 0 0 0 0 00 0 0 0 0 00 0 0 0 0 00 0 0 0 0 00 0 0 0 0 0Выходные данныеСкопировать3628800Входные данныеСкопировать2 6 101 2 3 4 5 60 0 0 0 0 0Выходные данныеСкопировать4096\n\nВходные данныеСкопировать2 2 40 00 0\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать48\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать2 2 41 22 1\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать0\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать5 6 100 0 0 0 0 00 0 0 0 0 00 0 0 0 0 00 0 0 0 0 00 0 0 0 0 0\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать3628800\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать2 6 101 2 3 4 5 60 0 0 0 0 0\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать4096\n\nВыходные данныеСкопировать\n\nСкопировать",
      "solutions": [
        {
          "title": "Чемпионат КРОК 2013 — Раунд 2 - Codeforces",
          "content": "Всем привет!Сегодня состоится второй раунд Всероссийского Открытого Чемпионата по программированию \"КРОК-2013\". Раунд для вас готовили: sdya, Seyaua, Gerald и, как обычно, задачи на английский переводила Delinur.Приятная новость для тех, кто не попал в лучшие 400 участников в предыдущем раунде — сегодня каждый может поучаствовать вне конкурса. При этом, раунд будет рейтинговым как для официальных участников чемпионата, так и для внеконкурсных.Официальным участникам напоминаем, что: Все участники чемпионата должны быть не моложе 18 лет на момент регистрации Финал чемпионата состоится 16 и 17 мая в Москве в офисе компании КРОК (50 участников) Проживание во время финала будет оплачено компанией КРОК Для граждан Российской Федерации: организаторы покроют транспортные расходы по территории РФ, транспортные расходы не по территории РФ — по согласованию (возможно, частично) Финалисты должны подтвердить свое участие до 2 мая И небольшой бонус: лучшие 200 официальных участников чемпионата получат футболки!Желаем всем получить удовольствие от решения задач ну и, конечно, удачи!UPD: Разбалловка по задачам сегодня будет немножко отличаться от стандартной: 500-1500-1500-2000-2500 для первого дивизиона и 500-1000-1500-2500-2500 для второго.UPD2: Мы приносим свои извинения за технические неполадки во время раунда. Посовещавшись, мы решили, что соревнование должно быть рейтинговым. А результаты соревнования будут учитываться в отборе на финал чемпионата КРОК.",
          "author": "Seyaua",
          "url": "https://codeforces.com/blog/entry/7460",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 1467
        },
        {
          "title": "Чемпионат КРОК 2013 — Раунд 2 — Разбор - Codeforces",
          "content": "A Div 2Если aj делится на ai, то тогда ai ≤ aj. Тогда число, на которое будут делиться все остальные числа будет не более чем любое выбранное число. То есть единственный возможный кандидат — это минимум в массиве. Поэтому просто проверим, что все элементы массива делятся на минимальный элемент.B Div 2Легко видеть, что Ксюша не сможет закончить ее путешествие, если существует последовательность подряд идущих # длиное более чем k.C Div 2 / A Div 1Первое наблюдение: мы не будем волноваться о том, как выглядят строки на самом деле, вся информация, которая нам нужна — это количество пар-символов вида: {0, 0}, {0, 1}, {1, 0}, {1, 1}. Посчитаем эти количества и будем следовать следующему жадному алгоритму:Для первого игрока: будем брать сначала {1, 1}, если их нет, то {1,0}. Если их нет, то {0, 1} и, в последнюю очередь, будем брать {0, 0}.Для второго игрока похожая стратегия: сначала {1, 1}, потом {0, 1}, потом {1, 0} и, в последнюю очередь, {0, 0}.После этого сравним у кого получилось больше единичек.D Div 2 / B Div 1Любой путь из верхней левой клетки в правую нижнюю состоит ровно из n + m - 1 клеток. И все они должны быть покрашены в разные цвета. Значит n + m - 1 ≤ k. Исходя из маленьких ограничений на k можно предположить, что брут-форс будет работать. Единственная оптимизация для получения действительно правильного решения — это некоторая канонизация раскрасок. Будем идти по всем клеткам в некотором порядке и красить их согласно следующим условиям. Если i > j, тогда цвет i встречается позже цвета j. После такого перебора мы получим примерно миллион различных шаблонов для максимального теста.Далее, просто будем сопоставлять уже покрашенные клетки с каждым шаблоном и считать, сколько различных перестановок цветов подходят к данному шаблону.E Div 2 / C Div 1После прочтения условия, можно понять, что все, что нам нужно — это посчитать количество решений уравнения (a + b + c)3 - a3 - b3 - c3 = n в положительных целых числах.Ключевое наблюдение это: 3(a + b)(a + c)(b + c) = (a + b + c)3 - a3 - b3 - c3, после чего мы можем просто вычислять все делители числа и идти по всем делителям x = a + b, таким что ? далее будем идти по делителям y = (a + c) ≥ x, где и в конце будем вычислять z = (b + c), такое что .После этого, решим систему a + b = x, a + c = y, b + c = z и добавим количество подходящих решений к ответу.D Div 1Можно заметить, что в этой задаче просят посчитать для всех целых точек внутри многоугольника (или на его границе). Можно заметить, что мы можем обрабатывать иксы и игреки независимо.Для каждого x определим yleft, yright таким образом, что все точки (x, y), где yleft ≤ y ≤ yright лежат внутри многоугольника и отрезок [yleft, yright] максимально возможный.Теперь будем считать, что мы имеем a1, a2, ..., ak различных точек для каждого фиксированного x (a1 соответствует x =  - 106, a2 соответствует x =  - 106 + 1 и так далее).Теперь требуемый ответ это a2a1 + a3(a2 + 22a1) + a4(a3 + 22a2 + 32a1) + ... Можно заметить, что (a2 + 22a1) - a1 = a2 + 3a1,(a3 + 22a2 + 32a1) - (a2 + 22a1) = a3 + 3a2 + 5a1,и так далее.Поэтому достаточно предпросчитать частичные суммы вида a2 + 3a1, a3 + 3a2 + 5a1, a4 + 3a3 + 5a2 + 7a1 (разность между двумя соседними суммами составляет 2(ai + ... + a1), поэтому мы можем делать это за O(k)).После предпросчета достаточно сложить полученные результаты.E Div 1Будем считать что у нас есть структура данных, которая позволяет осуществлять следующие операции: добавить точку (x, y) в структуру; сдвинуть все точки структуры на вектор (dx, dy); узнать как много точек (x,y), удовлетворяющих x ≤ xbound, y ≤ ybound; получить все элементы, которые на данный момент находятся в структуре; Для каждой вершины дерева мы будем хранить указатель на структуру такого вида.ОБъясним, как нужно обновлять структуры. Мы будем обрабатывать все вершины в порядке обхода в глубине, и если мы находимся в листе, то мы будем создавать структуру с единственным элементом (0, 0).В противном же случае, мы будем сортировать структуры сыновей по их размеру в убывающем порядке и будем присваивать указатель наибольшей структуры указателю на текущую вершину (здесь нужно не забыть сдвигать структуру на (1, вес ребра)).После этого будем идти по всем сыновьям вершины и делать следующее: Сдвинем структуру на (1, вес ребра); Возьмем все элементы структуры; Для каждого элемента (x, y) ответим на запрос xbound = L - x, ybound = W - y (используем родительскую структуру); Добавим элементы по одному в структуру; После этого ответим на запрос xbound = L, ybound = W и добавим элемент (0, 0).Сумма полученных результатов по всем запросам и будет ответом. Легко видеть, что мы совершим не более чем запросов и операций добавления.Осталось только объяснить, как создать нужную нам структуру данных.Существует несколько способов сделать это, один из них: Будем иметь маленькие подструктуры у которых размеры являются степенями двойки; Каждая структура — это двумерное дерево отрезков; Мы можем добавлять элемент следующим образом: если нет подструктуры размера 1, тогда создадим ее, иначе же возьмем все структуры размерами 1, 2, 4, ..., 2k и перестроим в структуру размера 2k + 1. Сдвиг: достаточно помнить вектор сдвига для каждой подструктуры; Ответ на запрос: идем по подструктурам и суммируем результаты. Разбор задач был подготовлен sdya и Seyaua",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/7516",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 5301
        },
        {
          "title": "Чемпионат КРОК 2013 — Раунд 2 — Разбор - Codeforces",
          "content": "A Div 2Если aj делится на ai, то тогда ai ≤ aj. Тогда число, на которое будут делиться все остальные числа будет не более чем любое выбранное число. То есть единственный возможный кандидат — это минимум в массиве. Поэтому просто проверим, что все элементы массива делятся на минимальный элемент.B Div 2Легко видеть, что Ксюша не сможет закончить ее путешествие, если существует последовательность подряд идущих # длиное более чем k.C Div 2 / A Div 1Первое наблюдение: мы не будем волноваться о том, как выглядят строки на самом деле, вся информация, которая нам нужна — это количество пар-символов вида: {0, 0}, {0, 1}, {1, 0}, {1, 1}. Посчитаем эти количества и будем следовать следующему жадному алгоритму:Для первого игрока: будем брать сначала {1, 1}, если их нет, то {1,0}. Если их нет, то {0, 1} и, в последнюю очередь, будем брать {0, 0}.Для второго игрока похожая стратегия: сначала {1, 1}, потом {0, 1}, потом {1, 0} и, в последнюю очередь, {0, 0}.После этого сравним у кого получилось больше единичек.D Div 2 / B Div 1Любой путь из верхней левой клетки в правую нижнюю состоит ровно из n + m - 1 клеток. И все они должны быть покрашены в разные цвета. Значит n + m - 1 ≤ k. Исходя из маленьких ограничений на k можно предположить, что брут-форс будет работать. Единственная оптимизация для получения действительно правильного решения — это некоторая канонизация раскрасок. Будем идти по всем клеткам в некотором порядке и красить их согласно следующим условиям. Если i > j, тогда цвет i встречается позже цвета j. После такого перебора мы получим примерно миллион различных шаблонов для максимального теста.Далее, просто будем сопоставлять уже покрашенные клетки с каждым шаблоном и считать, сколько различных перестановок цветов подходят к данному шаблону.E Div 2 / C Div 1После прочтения условия, можно понять, что все, что нам нужно — это посчитать количество решений уравнения (a + b + c)3 - a3 - b3 - c3 = n в положительных целых числах.Ключевое наблюдение это: 3(a + b)(a + c)(b + c) = (a + b + c)3 - a3 - b3 - c3, после чего мы можем просто вычислять все делители числа и идти по всем делителям x = a + b, таким что ? далее будем идти по делителям y = (a + c) ≥ x, где и в конце будем вычислять z = (b + c), такое что .После этого, решим систему a + b = x, a + c = y, b + c = z и добавим количество подходящих решений к ответу.D Div 1Можно заметить, что в этой задаче просят посчитать для всех целых точек внутри многоугольника (или на его границе). Можно заметить, что мы можем обрабатывать иксы и игреки независимо.Для каждого x определим yleft, yright таким образом, что все точки (x, y), где yleft ≤ y ≤ yright лежат внутри многоугольника и отрезок [yleft, yright] максимально возможный.Теперь будем считать, что мы имеем a1, a2, ..., ak различных точек для каждого фиксированного x (a1 соответствует x =  - 106, a2 соответствует x =  - 106 + 1 и так далее).Теперь требуемый ответ это a2a1 + a3(a2 + 22a1) + a4(a3 + 22a2 + 32a1) + ... Можно заметить, что (a2 + 22a1) - a1 = a2 + 3a1,(a3 + 22a2 + 32a1) - (a2 + 22a1) = a3 + 3a2 + 5a1,и так далее.Поэтому достаточно предпросчитать частичные суммы вида a2 + 3a1, a3 + 3a2 + 5a1, a4 + 3a3 + 5a2 + 7a1 (разность между двумя соседними суммами составляет 2(ai + ... + a1), поэтому мы можем делать это за O(k)).После предпросчета достаточно сложить полученные результаты.E Div 1Будем считать что у нас есть структура данных, которая позволяет осуществлять следующие операции: добавить точку (x, y) в структуру; сдвинуть все точки структуры на вектор (dx, dy); узнать как много точек (x,y), удовлетворяющих x ≤ xbound, y ≤ ybound; получить все элементы, которые на данный момент находятся в структуре; Для каждой вершины дерева мы будем хранить указатель на структуру такого вида.ОБъясним, как нужно обновлять структуры. Мы будем обрабатывать все вершины в порядке обхода в глубине, и если мы находимся в листе, то мы будем создавать структуру с единственным элементом (0, 0).В противном же случае, мы будем сортировать структуры сыновей по их размеру в убывающем порядке и будем присваивать указатель наибольшей структуры указателю на текущую вершину (здесь нужно не забыть сдвигать структуру на (1, вес ребра)).После этого будем идти по всем сыновьям вершины и делать следующее: Сдвинем структуру на (1, вес ребра); Возьмем все элементы структуры; Для каждого элемента (x, y) ответим на запрос xbound = L - x, ybound = W - y (используем родительскую структуру); Добавим элементы по одному в структуру; После этого ответим на запрос xbound = L, ybound = W и добавим элемент (0, 0).Сумма полученных результатов по всем запросам и будет ответом. Легко видеть, что мы совершим не более чем запросов и операций добавления.Осталось только объяснить, как создать нужную нам структуру данных.Существует несколько способов сделать это, один из них: Будем иметь маленькие подструктуры у которых размеры являются степенями двойки; Каждая структура — это двумерное дерево отрезков; Мы можем добавлять элемент следующим образом: если нет подструктуры размера 1, тогда создадим ее, иначе же возьмем все структуры размерами 1, 2, 4, ..., 2k и перестроим в структуру размера 2k + 1. Сдвиг: достаточно помнить вектор сдвига для каждой подструктуры; Ответ на запрос: идем по подструктурам и суммируем результаты. Разбор задач был подготовлен sdya и Seyaua",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/7516",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 5301
        }
      ],
      "code_examples": [
        {
          "title": "Чемпионат КРОК 2013 — Раунд 2 - Codeforces - Code 1",
          "code": "2 2 3\n1 2\n0 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7460",
          "author": "Seyaua"
        },
        {
          "title": "Чемпионат КРОК 2013 — Раунд 2 - Codeforces - Code 2",
          "code": "2 2 3\n1 2\n0 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7460",
          "author": "Seyaua"
        },
        {
          "title": "Чемпионат КРОК 2013 — Раунд 2 - Codeforces - Code 3",
          "code": "dp[0][1][{1,2}] == 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7460",
          "author": "Seyaua"
        },
        {
          "title": "Чемпионат КРОК 2013 — Раунд 2 - Codeforces - Code 4",
          "code": "dp[1][0][{1,2}] == 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7460",
          "author": "Seyaua"
        },
        {
          "title": "Чемпионат КРОК 2013 — Раунд 2 - Codeforces - Code 5",
          "code": "dp[1][1][{1,2,3}]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7460",
          "author": "Seyaua"
        },
        {
          "title": "Чемпионат КРОК 2013 — Раунд 2 - Codeforces - Code 6",
          "code": "5 6 10\n0 0 0 0 0 0\n0 0 0 0 0 0\n0 0 0 0 0 0\n0 0 0 0 0 0\n1 2 3 0 0 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7460",
          "author": "Seyaua"
        },
        {
          "title": "Чемпионат КРОК 2013 — Раунд 2 - Codeforces - Code 7",
          "code": "5 6 10\n0 0 0 0 0 0\n0 0 0 0 0 0\n0 0 0 0 0 0\n0 0 0 0 0 0\n1 2 3 0 0 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7460",
          "author": "Seyaua"
        },
        {
          "title": "Чемпионат КРОК 2013 — Раунд 2 - Codeforces - Code 8",
          "code": "5 6 10\n0 0 0 0 0 0\n0 0 0 0 0 0\n0 0 0 0 0 0\n4 0 0 0 0 0\n1 2 3 0 0 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7460",
          "author": "Seyaua"
        },
        {
          "title": "Чемпионат КРОК 2013 — Раунд 2 - Codeforces - Code 9",
          "code": "5 6 10\n0 0 0 0 0 0\n0 0 0 0 0 0\n0 0 0 0 0 0\n4 0 0 0 0 0\n1 2 3 0 0 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7460",
          "author": "Seyaua"
        },
        {
          "title": "Чемпионат КРОК 2013 — Раунд 2 - Codeforces - Code 10",
          "code": "if(F > S) cout << \"First\";\nif(F + 1 < S) cout << \"Second\";\nif(F == S) cout << \"Draw\";",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7460",
          "author": "Seyaua"
        },
        {
          "title": "Чемпионат КРОК 2013 — Раунд 2 - Codeforces - Code 11",
          "code": "if(F > S) cout << \"First\";\nif(F + 1 < S) cout << \"Second\";\nif(F == S) cout << \"Draw\";",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7460",
          "author": "Seyaua"
        },
        {
          "title": "Чемпионат КРОК 2013 — Раунд 2 - Codeforces - Code 12",
          "code": "При этом, раунд будет рейтинговым как для официальных участников чемпионата, так и для внеконкурсных.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7460",
          "author": "Seyaua"
        },
        {
          "title": "Чемпионат КРОК 2013 — Раунд 2 - Codeforces - Code 13",
          "code": "3\n-1000000 1000000\n-1000000 999999\n-999999 1000000",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7460",
          "author": "Seyaua"
        },
        {
          "title": "Чемпионат КРОК 2013 — Раунд 2 - Codeforces - Code 14",
          "code": "3\n-1000000 1000000\n-1000000 999999\n-999999 1000000",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7460",
          "author": "Seyaua"
        },
        {
          "title": "Чемпионат КРОК 2013 — Раунд 2 - Codeforces - Code 15",
          "code": "(a+b+c)^3 - a^3 - b^3 - c^3 = 3*(a+b)*(b+c)*(c+a)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7460",
          "author": "Seyaua"
        },
        {
          "title": "Чемпионат КРОК 2013 — Раунд 2 - Codeforces - Code 16",
          "code": "(a+b+c)^3 - a^3 - b^3 - c^3 = 3*(a+b)*(b+c)*(c+a)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7460",
          "author": "Seyaua"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 1000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 1000, \"m\");\n    inf.readSpace();\n    int k = inf.readInt(1, 10, \"k\");\n    inf.readEoln();\n\n    for (int i = 0; i < n; ++i) {\n        vector<int> row = inf.readInts(m, 0, k);\n        inf.readEoln();\n    }\n\n    inf.readEof();\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 1000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 1000, \"m\");\n    inf.readSpace();\n    int k = inf.readInt(1, 10, \"k\");\n    inf.readEoln();\n\n    for (int i = 0; i < n; ++i) {\n        vector<int> row = inf.readInts(m, 0, k);\n        inf.readEoln();\n    }\n\n    inf.readEof();\n\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 1000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 1000, \"m\");\n    inf.readSpace();\n    int k = inf.readInt(1, 10, \"k\");\n    inf.readEoln();\n\n    for (int i = 0; i < n; ++i) {\n        vector<int> row = inf.readInts(m, 0, k);\n        inf.readEoln();\n    }\n\n    inf.readEof();\n\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    int k = opt<int>(\"k\");\n    string type = opt<string>(\"type\", \"random\");\n\n    printf(\"%d %d %d\\n\", n, m, k);\n\n    // Initialize the board\n    vector<vector<int>> board(n, vector<int>(m, 0));\n\n    if (type == \"empty\") {\n        // All zeros, so board is already initialized\n    } else if (type == \"full\") {\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < m; ++j) {\n                board[i][j] = rnd.next(1, k);\n            }\n        }\n    } else if (type == \"random\") {\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < m; ++j) {\n                int painted = rnd.next(0, 1); // 0 or 1\n                if (painted) {\n                    board[i][j] = rnd.next(1, k);\n                }\n            }\n        }\n    } else if (type == \"contradiction\") {\n        // Ensure that the board leads to zero possible paintings\n        // Pre-paint (0,0) and its right or down neighbor with same color\n        int color = rnd.next(1, k);\n        board[0][0] = color;\n        if (m > 1) {\n            board[0][1] = color;\n        } else if (n > 1) {\n            board[1][0] = color;\n        } else {\n            // n == m == 1, set only cell\n            board[0][0] = color;\n        }\n    } else if (type == \"pre_painted_start_end_same_color\") {\n        int color = rnd.next(1, k);\n        board[0][0] = color;\n        board[n-1][m-1] = color;\n    } else if (type == \"pre_painted_start_end_diff_color\") {\n        board[0][0] = rnd.next(1, k);\n        int color;\n        do {\n            color = rnd.next(1, k);\n        } while (color == board[0][0]);\n        board[n-1][m-1] = color;\n    } else if (type == \"alternating\") {\n        // Paint the board in a checkerboard pattern\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < m; ++j) {\n                board[i][j] = (i + j) % k + 1;\n            }\n        }\n    } else if (type == \"one_color\") {\n        // All cells painted with color 1\n        if (k != 1) {\n            fprintf(stderr, \"Type 'one_color' requires k=1\\n\");\n            exit(1);\n        }\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < m; ++j) {\n                board[i][j] = 1;\n            }\n        }\n    } else if (type == \"max_test\") {\n        // Max n, m, k, random board\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < m; ++j) {\n                int painted = rnd.next(0, 1);\n                if (painted) {\n                    board[i][j] = rnd.next(1, k);\n                }\n            }\n        }\n    } else {\n        // Default to random\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < m; ++j) {\n                int painted = rnd.next(0, 1); // 0 or 1\n                if (painted) {\n                    board[i][j] = rnd.next(1, k);\n                }\n            }\n        }\n    }\n\n    // Output the board\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < m; ++j) {\n            printf(\"%d%c\", board[i][j], (j == m -1) ? '\\n' : ' ');\n        }\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    int k = opt<int>(\"k\");\n    string type = opt<string>(\"type\", \"random\");\n\n    printf(\"%d %d %d\\n\", n, m, k);\n\n    // Initialize the board\n    vector<vector<int>> board(n, vector<int>(m, 0));\n\n    if (type == \"empty\") {\n        // All zeros, so board is already initialized\n    } else if (type == \"full\") {\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < m; ++j) {\n                board[i][j] = rnd.next(1, k);\n            }\n        }\n    } else if (type == \"random\") {\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < m; ++j) {\n                int painted = rnd.next(0, 1); // 0 or 1\n                if (painted) {\n                    board[i][j] = rnd.next(1, k);\n                }\n            }\n        }\n    } else if (type == \"contradiction\") {\n        // Ensure that the board leads to zero possible paintings\n        // Pre-paint (0,0) and its right or down neighbor with same color\n        int color = rnd.next(1, k);\n        board[0][0] = color;\n        if (m > 1) {\n            board[0][1] = color;\n        } else if (n > 1) {\n            board[1][0] = color;\n        } else {\n            // n == m == 1, set only cell\n            board[0][0] = color;\n        }\n    } else if (type == \"pre_painted_start_end_same_color\") {\n        int color = rnd.next(1, k);\n        board[0][0] = color;\n        board[n-1][m-1] = color;\n    } else if (type == \"pre_painted_start_end_diff_color\") {\n        board[0][0] = rnd.next(1, k);\n        int color;\n        do {\n            color = rnd.next(1, k);\n        } while (color == board[0][0]);\n        board[n-1][m-1] = color;\n    } else if (type == \"alternating\") {\n        // Paint the board in a checkerboard pattern\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < m; ++j) {\n                board[i][j] = (i + j) % k + 1;\n            }\n        }\n    } else if (type == \"one_color\") {\n        // All cells painted with color 1\n        if (k != 1) {\n            fprintf(stderr, \"Type 'one_color' requires k=1\\n\");\n            exit(1);\n        }\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < m; ++j) {\n                board[i][j] = 1;\n            }\n        }\n    } else if (type == \"max_test\") {\n        // Max n, m, k, random board\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < m; ++j) {\n                int painted = rnd.next(0, 1);\n                if (painted) {\n                    board[i][j] = rnd.next(1, k);\n                }\n            }\n        }\n    } else {\n        // Default to random\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < m; ++j) {\n                int painted = rnd.next(0, 1); // 0 or 1\n                if (painted) {\n                    board[i][j] = rnd.next(1, k);\n                }\n            }\n        }\n    }\n\n    // Output the board\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < m; ++j) {\n            printf(\"%d%c\", board[i][j], (j == m -1) ? '\\n' : ' ');\n        }\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -m 1 -k 1 -type empty\n./gen -n 1 -m 1 -k 1 -type full\n./gen -n 1 -m 1 -k 1 -type random\n\n./gen -n 2 -m 2 -k 2 -type contradiction\n./gen -n 2 -m 2 -k 2 -type pre_painted_start_end_same_color\n./gen -n 2 -m 2 -k 2 -type pre_painted_start_end_diff_color\n\n./gen -n 1000 -m 1000 -k 10 -type empty\n./gen -n 1000 -m 1000 -k 10 -type full\n./gen -n 1000 -m 1000 -k 10 -type random\n./gen -n 1000 -m 1000 -k 10 -type contradiction\n\n./gen -n 1000 -m 1 -k 10 -type random\n./gen -n 1 -m 1000 -k 10 -type random\n\n./gen -n 500 -m 500 -k 2 -type alternating\n./gen -n 999 -m 999 -k 10 -type random\n\n./gen -n 1000 -m 1000 -k 1 -type one_color\n./gen -n 1000 -m 1000 -k 1 -type random\n./gen -n 1000 -m 1000 -k 1 -type contradiction\n\n./gen -n 10 -m 10 -k 10 -type pre_painted_start_end_same_color\n./gen -n 10 -m 10 -k 10 -type pre_painted_start_end_diff_color\n\n./gen -n 100 -m 100 -k 5 -type random\n./gen -n 100 -m 100 -k 5 -type full\n./gen -n 100 -m 100 -k 5 -type empty\n\n./gen -n 2 -m 3 -k 2 -type contradiction\n./gen -n 1000 -m 1000 -k 10 -type max_test\n\n# Additional test cases\n./gen -n 3 -m 3 -k 3 -type random\n./gen -n 1 -m 1000 -k 5 -type full\n./gen -n 1000 -m 1 -k 5 -type full\n./gen -n 500 -m 500 -k 10 -type random\n./gen -n 1000 -m 1000 -k 10 -type alternating\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:04:32.563236",
        "total_tutorials": 3,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "299/E",
      "title": "E. Кубическая задача",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест2 секунды",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеВ единственной строке входных данных записано целое число n (1 ≤ n ≤ 1014). Известно, что все числа a, b, c являются целыми и положительными.Пожалуйста, не используйте спецификатор %lld для чтения или записи 64-х битовых чисел на С++. Рекомендуется использовать потоки cin, cout или спецификатор %I64d.",
      "output_spec": "Выходные данныеВ единственную строку выходных данных выведите искомое количество вариантов. Если вдруг окажется, что не существует ни одного варианта подходящих размеров a, b, c — выводите 0.",
      "sample_tests": "ПримерыВходные данныеСкопировать24Выходные данныеСкопировать1Входные данныеСкопировать648Выходные данныеСкопировать7Входные данныеСкопировать5Выходные данныеСкопировать0Входные данныеСкопировать93163582512000Выходные данныеСкопировать39090",
      "description": "E. Кубическая задача\n\nограничение по времени на тест2 секунды\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвыводstdout\n\nВходные данныеВ единственной строке входных данных записано целое число n (1 ≤ n ≤ 1014). Известно, что все числа a, b, c являются целыми и положительными.Пожалуйста, не используйте спецификатор %lld для чтения или записи 64-х битовых чисел на С++. Рекомендуется использовать потоки cin, cout или спецификатор %I64d.\n\nВходные данные\n\nВыходные данныеВ единственную строку выходных данных выведите искомое количество вариантов. Если вдруг окажется, что не существует ни одного варианта подходящих размеров a, b, c — выводите 0.\n\nВыходные данные\n\nВходные данныеСкопировать24Выходные данныеСкопировать1Входные данныеСкопировать648Выходные данныеСкопировать7Входные данныеСкопировать5Выходные данныеСкопировать0Входные данныеСкопировать93163582512000Выходные данныеСкопировать39090\n\nВходные данныеСкопировать24\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать1\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать648\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать7\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать5\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать0\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать93163582512000\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать39090\n\nВыходные данныеСкопировать\n\nСкопировать",
      "solutions": [
        {
          "title": "Чемпионат КРОК 2013 — Раунд 2 - Codeforces",
          "content": "Всем привет!Сегодня состоится второй раунд Всероссийского Открытого Чемпионата по программированию \"КРОК-2013\". Раунд для вас готовили: sdya, Seyaua, Gerald и, как обычно, задачи на английский переводила Delinur.Приятная новость для тех, кто не попал в лучшие 400 участников в предыдущем раунде — сегодня каждый может поучаствовать вне конкурса. При этом, раунд будет рейтинговым как для официальных участников чемпионата, так и для внеконкурсных.Официальным участникам напоминаем, что: Все участники чемпионата должны быть не моложе 18 лет на момент регистрации Финал чемпионата состоится 16 и 17 мая в Москве в офисе компании КРОК (50 участников) Проживание во время финала будет оплачено компанией КРОК Для граждан Российской Федерации: организаторы покроют транспортные расходы по территории РФ, транспортные расходы не по территории РФ — по согласованию (возможно, частично) Финалисты должны подтвердить свое участие до 2 мая И небольшой бонус: лучшие 200 официальных участников чемпионата получат футболки!Желаем всем получить удовольствие от решения задач ну и, конечно, удачи!UPD: Разбалловка по задачам сегодня будет немножко отличаться от стандартной: 500-1500-1500-2000-2500 для первого дивизиона и 500-1000-1500-2500-2500 для второго.UPD2: Мы приносим свои извинения за технические неполадки во время раунда. Посовещавшись, мы решили, что соревнование должно быть рейтинговым. А результаты соревнования будут учитываться в отборе на финал чемпионата КРОК.",
          "author": "Seyaua",
          "url": "https://codeforces.com/blog/entry/7460",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 1467
        },
        {
          "title": "Чемпионат КРОК 2013 — Раунд 2 — Разбор - Codeforces",
          "content": "A Div 2Если aj делится на ai, то тогда ai ≤ aj. Тогда число, на которое будут делиться все остальные числа будет не более чем любое выбранное число. То есть единственный возможный кандидат — это минимум в массиве. Поэтому просто проверим, что все элементы массива делятся на минимальный элемент.B Div 2Легко видеть, что Ксюша не сможет закончить ее путешествие, если существует последовательность подряд идущих # длиное более чем k.C Div 2 / A Div 1Первое наблюдение: мы не будем волноваться о том, как выглядят строки на самом деле, вся информация, которая нам нужна — это количество пар-символов вида: {0, 0}, {0, 1}, {1, 0}, {1, 1}. Посчитаем эти количества и будем следовать следующему жадному алгоритму:Для первого игрока: будем брать сначала {1, 1}, если их нет, то {1,0}. Если их нет, то {0, 1} и, в последнюю очередь, будем брать {0, 0}.Для второго игрока похожая стратегия: сначала {1, 1}, потом {0, 1}, потом {1, 0} и, в последнюю очередь, {0, 0}.После этого сравним у кого получилось больше единичек.D Div 2 / B Div 1Любой путь из верхней левой клетки в правую нижнюю состоит ровно из n + m - 1 клеток. И все они должны быть покрашены в разные цвета. Значит n + m - 1 ≤ k. Исходя из маленьких ограничений на k можно предположить, что брут-форс будет работать. Единственная оптимизация для получения действительно правильного решения — это некоторая канонизация раскрасок. Будем идти по всем клеткам в некотором порядке и красить их согласно следующим условиям. Если i > j, тогда цвет i встречается позже цвета j. После такого перебора мы получим примерно миллион различных шаблонов для максимального теста.Далее, просто будем сопоставлять уже покрашенные клетки с каждым шаблоном и считать, сколько различных перестановок цветов подходят к данному шаблону.E Div 2 / C Div 1После прочтения условия, можно понять, что все, что нам нужно — это посчитать количество решений уравнения (a + b + c)3 - a3 - b3 - c3 = n в положительных целых числах.Ключевое наблюдение это: 3(a + b)(a + c)(b + c) = (a + b + c)3 - a3 - b3 - c3, после чего мы можем просто вычислять все делители числа и идти по всем делителям x = a + b, таким что ? далее будем идти по делителям y = (a + c) ≥ x, где и в конце будем вычислять z = (b + c), такое что .После этого, решим систему a + b = x, a + c = y, b + c = z и добавим количество подходящих решений к ответу.D Div 1Можно заметить, что в этой задаче просят посчитать для всех целых точек внутри многоугольника (или на его границе). Можно заметить, что мы можем обрабатывать иксы и игреки независимо.Для каждого x определим yleft, yright таким образом, что все точки (x, y), где yleft ≤ y ≤ yright лежат внутри многоугольника и отрезок [yleft, yright] максимально возможный.Теперь будем считать, что мы имеем a1, a2, ..., ak различных точек для каждого фиксированного x (a1 соответствует x =  - 106, a2 соответствует x =  - 106 + 1 и так далее).Теперь требуемый ответ это a2a1 + a3(a2 + 22a1) + a4(a3 + 22a2 + 32a1) + ... Можно заметить, что (a2 + 22a1) - a1 = a2 + 3a1,(a3 + 22a2 + 32a1) - (a2 + 22a1) = a3 + 3a2 + 5a1,и так далее.Поэтому достаточно предпросчитать частичные суммы вида a2 + 3a1, a3 + 3a2 + 5a1, a4 + 3a3 + 5a2 + 7a1 (разность между двумя соседними суммами составляет 2(ai + ... + a1), поэтому мы можем делать это за O(k)).После предпросчета достаточно сложить полученные результаты.E Div 1Будем считать что у нас есть структура данных, которая позволяет осуществлять следующие операции: добавить точку (x, y) в структуру; сдвинуть все точки структуры на вектор (dx, dy); узнать как много точек (x,y), удовлетворяющих x ≤ xbound, y ≤ ybound; получить все элементы, которые на данный момент находятся в структуре; Для каждой вершины дерева мы будем хранить указатель на структуру такого вида.ОБъясним, как нужно обновлять структуры. Мы будем обрабатывать все вершины в порядке обхода в глубине, и если мы находимся в листе, то мы будем создавать структуру с единственным элементом (0, 0).В противном же случае, мы будем сортировать структуры сыновей по их размеру в убывающем порядке и будем присваивать указатель наибольшей структуры указателю на текущую вершину (здесь нужно не забыть сдвигать структуру на (1, вес ребра)).После этого будем идти по всем сыновьям вершины и делать следующее: Сдвинем структуру на (1, вес ребра); Возьмем все элементы структуры; Для каждого элемента (x, y) ответим на запрос xbound = L - x, ybound = W - y (используем родительскую структуру); Добавим элементы по одному в структуру; После этого ответим на запрос xbound = L, ybound = W и добавим элемент (0, 0).Сумма полученных результатов по всем запросам и будет ответом. Легко видеть, что мы совершим не более чем запросов и операций добавления.Осталось только объяснить, как создать нужную нам структуру данных.Существует несколько способов сделать это, один из них: Будем иметь маленькие подструктуры у которых размеры являются степенями двойки; Каждая структура — это двумерное дерево отрезков; Мы можем добавлять элемент следующим образом: если нет подструктуры размера 1, тогда создадим ее, иначе же возьмем все структуры размерами 1, 2, 4, ..., 2k и перестроим в структуру размера 2k + 1. Сдвиг: достаточно помнить вектор сдвига для каждой подструктуры; Ответ на запрос: идем по подструктурам и суммируем результаты. Разбор задач был подготовлен sdya и Seyaua",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/7516",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 5301
        },
        {
          "title": "Чемпионат КРОК 2013 — Раунд 2 — Разбор - Codeforces",
          "content": "A Div 2Если aj делится на ai, то тогда ai ≤ aj. Тогда число, на которое будут делиться все остальные числа будет не более чем любое выбранное число. То есть единственный возможный кандидат — это минимум в массиве. Поэтому просто проверим, что все элементы массива делятся на минимальный элемент.B Div 2Легко видеть, что Ксюша не сможет закончить ее путешествие, если существует последовательность подряд идущих # длиное более чем k.C Div 2 / A Div 1Первое наблюдение: мы не будем волноваться о том, как выглядят строки на самом деле, вся информация, которая нам нужна — это количество пар-символов вида: {0, 0}, {0, 1}, {1, 0}, {1, 1}. Посчитаем эти количества и будем следовать следующему жадному алгоритму:Для первого игрока: будем брать сначала {1, 1}, если их нет, то {1,0}. Если их нет, то {0, 1} и, в последнюю очередь, будем брать {0, 0}.Для второго игрока похожая стратегия: сначала {1, 1}, потом {0, 1}, потом {1, 0} и, в последнюю очередь, {0, 0}.После этого сравним у кого получилось больше единичек.D Div 2 / B Div 1Любой путь из верхней левой клетки в правую нижнюю состоит ровно из n + m - 1 клеток. И все они должны быть покрашены в разные цвета. Значит n + m - 1 ≤ k. Исходя из маленьких ограничений на k можно предположить, что брут-форс будет работать. Единственная оптимизация для получения действительно правильного решения — это некоторая канонизация раскрасок. Будем идти по всем клеткам в некотором порядке и красить их согласно следующим условиям. Если i > j, тогда цвет i встречается позже цвета j. После такого перебора мы получим примерно миллион различных шаблонов для максимального теста.Далее, просто будем сопоставлять уже покрашенные клетки с каждым шаблоном и считать, сколько различных перестановок цветов подходят к данному шаблону.E Div 2 / C Div 1После прочтения условия, можно понять, что все, что нам нужно — это посчитать количество решений уравнения (a + b + c)3 - a3 - b3 - c3 = n в положительных целых числах.Ключевое наблюдение это: 3(a + b)(a + c)(b + c) = (a + b + c)3 - a3 - b3 - c3, после чего мы можем просто вычислять все делители числа и идти по всем делителям x = a + b, таким что ? далее будем идти по делителям y = (a + c) ≥ x, где и в конце будем вычислять z = (b + c), такое что .После этого, решим систему a + b = x, a + c = y, b + c = z и добавим количество подходящих решений к ответу.D Div 1Можно заметить, что в этой задаче просят посчитать для всех целых точек внутри многоугольника (или на его границе). Можно заметить, что мы можем обрабатывать иксы и игреки независимо.Для каждого x определим yleft, yright таким образом, что все точки (x, y), где yleft ≤ y ≤ yright лежат внутри многоугольника и отрезок [yleft, yright] максимально возможный.Теперь будем считать, что мы имеем a1, a2, ..., ak различных точек для каждого фиксированного x (a1 соответствует x =  - 106, a2 соответствует x =  - 106 + 1 и так далее).Теперь требуемый ответ это a2a1 + a3(a2 + 22a1) + a4(a3 + 22a2 + 32a1) + ... Можно заметить, что (a2 + 22a1) - a1 = a2 + 3a1,(a3 + 22a2 + 32a1) - (a2 + 22a1) = a3 + 3a2 + 5a1,и так далее.Поэтому достаточно предпросчитать частичные суммы вида a2 + 3a1, a3 + 3a2 + 5a1, a4 + 3a3 + 5a2 + 7a1 (разность между двумя соседними суммами составляет 2(ai + ... + a1), поэтому мы можем делать это за O(k)).После предпросчета достаточно сложить полученные результаты.E Div 1Будем считать что у нас есть структура данных, которая позволяет осуществлять следующие операции: добавить точку (x, y) в структуру; сдвинуть все точки структуры на вектор (dx, dy); узнать как много точек (x,y), удовлетворяющих x ≤ xbound, y ≤ ybound; получить все элементы, которые на данный момент находятся в структуре; Для каждой вершины дерева мы будем хранить указатель на структуру такого вида.ОБъясним, как нужно обновлять структуры. Мы будем обрабатывать все вершины в порядке обхода в глубине, и если мы находимся в листе, то мы будем создавать структуру с единственным элементом (0, 0).В противном же случае, мы будем сортировать структуры сыновей по их размеру в убывающем порядке и будем присваивать указатель наибольшей структуры указателю на текущую вершину (здесь нужно не забыть сдвигать структуру на (1, вес ребра)).После этого будем идти по всем сыновьям вершины и делать следующее: Сдвинем структуру на (1, вес ребра); Возьмем все элементы структуры; Для каждого элемента (x, y) ответим на запрос xbound = L - x, ybound = W - y (используем родительскую структуру); Добавим элементы по одному в структуру; После этого ответим на запрос xbound = L, ybound = W и добавим элемент (0, 0).Сумма полученных результатов по всем запросам и будет ответом. Легко видеть, что мы совершим не более чем запросов и операций добавления.Осталось только объяснить, как создать нужную нам структуру данных.Существует несколько способов сделать это, один из них: Будем иметь маленькие подструктуры у которых размеры являются степенями двойки; Каждая структура — это двумерное дерево отрезков; Мы можем добавлять элемент следующим образом: если нет подструктуры размера 1, тогда создадим ее, иначе же возьмем все структуры размерами 1, 2, 4, ..., 2k и перестроим в структуру размера 2k + 1. Сдвиг: достаточно помнить вектор сдвига для каждой подструктуры; Ответ на запрос: идем по подструктурам и суммируем результаты. Разбор задач был подготовлен sdya и Seyaua",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/7516",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 5301
        }
      ],
      "code_examples": [
        {
          "title": "Чемпионат КРОК 2013 — Раунд 2 - Codeforces - Code 1",
          "code": "2 2 3\n1 2\n0 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7460",
          "author": "Seyaua"
        },
        {
          "title": "Чемпионат КРОК 2013 — Раунд 2 - Codeforces - Code 2",
          "code": "2 2 3\n1 2\n0 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7460",
          "author": "Seyaua"
        },
        {
          "title": "Чемпионат КРОК 2013 — Раунд 2 - Codeforces - Code 3",
          "code": "dp[0][1][{1,2}] == 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7460",
          "author": "Seyaua"
        },
        {
          "title": "Чемпионат КРОК 2013 — Раунд 2 - Codeforces - Code 4",
          "code": "dp[1][0][{1,2}] == 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7460",
          "author": "Seyaua"
        },
        {
          "title": "Чемпионат КРОК 2013 — Раунд 2 - Codeforces - Code 5",
          "code": "dp[1][1][{1,2,3}]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7460",
          "author": "Seyaua"
        },
        {
          "title": "Чемпионат КРОК 2013 — Раунд 2 - Codeforces - Code 6",
          "code": "5 6 10\n0 0 0 0 0 0\n0 0 0 0 0 0\n0 0 0 0 0 0\n0 0 0 0 0 0\n1 2 3 0 0 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7460",
          "author": "Seyaua"
        },
        {
          "title": "Чемпионат КРОК 2013 — Раунд 2 - Codeforces - Code 7",
          "code": "5 6 10\n0 0 0 0 0 0\n0 0 0 0 0 0\n0 0 0 0 0 0\n0 0 0 0 0 0\n1 2 3 0 0 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7460",
          "author": "Seyaua"
        },
        {
          "title": "Чемпионат КРОК 2013 — Раунд 2 - Codeforces - Code 8",
          "code": "5 6 10\n0 0 0 0 0 0\n0 0 0 0 0 0\n0 0 0 0 0 0\n4 0 0 0 0 0\n1 2 3 0 0 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7460",
          "author": "Seyaua"
        },
        {
          "title": "Чемпионат КРОК 2013 — Раунд 2 - Codeforces - Code 9",
          "code": "5 6 10\n0 0 0 0 0 0\n0 0 0 0 0 0\n0 0 0 0 0 0\n4 0 0 0 0 0\n1 2 3 0 0 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7460",
          "author": "Seyaua"
        },
        {
          "title": "Чемпионат КРОК 2013 — Раунд 2 - Codeforces - Code 10",
          "code": "if(F > S) cout << \"First\";\nif(F + 1 < S) cout << \"Second\";\nif(F == S) cout << \"Draw\";",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7460",
          "author": "Seyaua"
        },
        {
          "title": "Чемпионат КРОК 2013 — Раунд 2 - Codeforces - Code 11",
          "code": "if(F > S) cout << \"First\";\nif(F + 1 < S) cout << \"Second\";\nif(F == S) cout << \"Draw\";",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7460",
          "author": "Seyaua"
        },
        {
          "title": "Чемпионат КРОК 2013 — Раунд 2 - Codeforces - Code 12",
          "code": "При этом, раунд будет рейтинговым как для официальных участников чемпионата, так и для внеконкурсных.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7460",
          "author": "Seyaua"
        },
        {
          "title": "Чемпионат КРОК 2013 — Раунд 2 - Codeforces - Code 13",
          "code": "3\n-1000000 1000000\n-1000000 999999\n-999999 1000000",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7460",
          "author": "Seyaua"
        },
        {
          "title": "Чемпионат КРОК 2013 — Раунд 2 - Codeforces - Code 14",
          "code": "3\n-1000000 1000000\n-1000000 999999\n-999999 1000000",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7460",
          "author": "Seyaua"
        },
        {
          "title": "Чемпионат КРОК 2013 — Раунд 2 - Codeforces - Code 15",
          "code": "(a+b+c)^3 - a^3 - b^3 - c^3 = 3*(a+b)*(b+c)*(c+a)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7460",
          "author": "Seyaua"
        },
        {
          "title": "Чемпионат КРОК 2013 — Раунд 2 - Codeforces - Code 16",
          "code": "(a+b+c)^3 - a^3 - b^3 - c^3 = 3*(a+b)*(b+c)*(c+a)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7460",
          "author": "Seyaua"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    long long n = inf.readLong(1, 100000000000000LL, \"n\");\n    inf.readEoln();\n    inf.readEof();\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    long long n = inf.readLong(1, 100000000000000LL, \"n\");\n    inf.readEoln();\n    inf.readEof();\n\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    long long n = inf.readLong(1, 100000000000000LL, \"n\");\n    inf.readEoln();\n    inf.readEof();\n\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst long long MIN_N = 1LL;\nconst long long MAX_N = 100000000000000LL; // 1e14\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    string type = opt<string>(\"type\", \"random\");\n\n    long long n;\n\n    if (type == \"min\") {\n        n = MIN_N;\n    } else if (type == \"max\") {\n        n = MAX_N;\n    } else if (type == \"zero\") {\n        // Select an n where there are zero solutions\n        n = 5; // From sample input, n = 5 gives 0 solutions\n    } else if (type == \"sample1\") {\n        // n from the first sample input\n        n = 24;\n    } else if (type == \"sample2\") {\n        n = 648;\n    } else if (type == \"sample3\") {\n        n = 5; // Output is zero\n    } else if (type == \"sample4\") {\n        n = 93163582512000LL; // Large n from sample input\n    } else if (type == \"random\") {\n        n = rnd.next(MIN_N, MAX_N);\n    } else if (type == \"random_small\") {\n        n = rnd.next(MIN_N, 1000LL);\n    } else if (type == \"random_large\") {\n        n = rnd.next(MAX_N / 10, MAX_N);\n    } else if (type == \"many_solutions\") {\n        // Generate n where there are potentially many solutions\n        // For example, set a = b = c = k\n        long long k = rnd.next(1LL, 1000000LL);\n        long long a = k;\n        long long b = k;\n        long long c = k;\n        long long s = a + b + c;\n        n = s * s * s - (a * a * a + b * b * b + c * c * c);\n        // Ensure n is within constraints\n        if (n < MIN_N || n > MAX_N) {\n            n = MIN_N + rnd.next(MAX_N - MIN_N);\n        }\n    } else if (type == \"specific\") {\n        // Generate n based on specific a, b, c\n        long long a = opt<long long>(\"a\");\n        long long b = opt<long long>(\"b\");\n        long long c = opt<long long>(\"c\");\n        long long s = a + b + c;\n        n = s * s * s - (a * a * a + b * b * b + c * c * c);\n        // Ensure n is within constraints\n        if (n < MIN_N || n > MAX_N) {\n            n = MIN_N + rnd.next(MAX_N - MIN_N);\n        }\n    } else {\n        // Default to random\n        n = rnd.next(MIN_N, MAX_N);\n    }\n\n    // Ensure n is within constraints\n    n = max(n, MIN_N);\n    n = min(n, MAX_N);\n\n    printf(\"%lld\\n\", n);\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst long long MIN_N = 1LL;\nconst long long MAX_N = 100000000000000LL; // 1e14\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    string type = opt<string>(\"type\", \"random\");\n\n    long long n;\n\n    if (type == \"min\") {\n        n = MIN_N;\n    } else if (type == \"max\") {\n        n = MAX_N;\n    } else if (type == \"zero\") {\n        // Select an n where there are zero solutions\n        n = 5; // From sample input, n = 5 gives 0 solutions\n    } else if (type == \"sample1\") {\n        // n from the first sample input\n        n = 24;\n    } else if (type == \"sample2\") {\n        n = 648;\n    } else if (type == \"sample3\") {\n        n = 5; // Output is zero\n    } else if (type == \"sample4\") {\n        n = 93163582512000LL; // Large n from sample input\n    } else if (type == \"random\") {\n        n = rnd.next(MIN_N, MAX_N);\n    } else if (type == \"random_small\") {\n        n = rnd.next(MIN_N, 1000LL);\n    } else if (type == \"random_large\") {\n        n = rnd.next(MAX_N / 10, MAX_N);\n    } else if (type == \"many_solutions\") {\n        // Generate n where there are potentially many solutions\n        // For example, set a = b = c = k\n        long long k = rnd.next(1LL, 1000000LL);\n        long long a = k;\n        long long b = k;\n        long long c = k;\n        long long s = a + b + c;\n        n = s * s * s - (a * a * a + b * b * b + c * c * c);\n        // Ensure n is within constraints\n        if (n < MIN_N || n > MAX_N) {\n            n = MIN_N + rnd.next(MAX_N - MIN_N);\n        }\n    } else if (type == \"specific\") {\n        // Generate n based on specific a, b, c\n        long long a = opt<long long>(\"a\");\n        long long b = opt<long long>(\"b\");\n        long long c = opt<long long>(\"c\");\n        long long s = a + b + c;\n        n = s * s * s - (a * a * a + b * b * b + c * c * c);\n        // Ensure n is within constraints\n        if (n < MIN_N || n > MAX_N) {\n            n = MIN_N + rnd.next(MAX_N - MIN_N);\n        }\n    } else {\n        // Default to random\n        n = rnd.next(MIN_N, MAX_N);\n    }\n\n    // Ensure n is within constraints\n    n = max(n, MIN_N);\n    n = min(n, MAX_N);\n\n    printf(\"%lld\\n\", n);\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -type min\n./gen -type max\n./gen -type zero\n./gen -type sample1\n./gen -type sample2\n./gen -type sample3\n./gen -type sample4\n\n./gen -type random_small\n./gen -type random_small\n./gen -type random_small\n\n./gen -type random_large\n./gen -type random_large\n./gen -type random_large\n\n./gen -type random\n./gen -type random\n./gen -type random\n\n./gen -type many_solutions\n./gen -type many_solutions\n./gen -type many_solutions\n\n./gen -type specific -a 1 -b 1 -c 1\n./gen -type specific -a 10 -b 20 -c 30\n./gen -type specific -a 100 -b 200 -c 300\n./gen -type specific -a 1000 -b 1000 -c 1000\n./gen -type specific -a 12345 -b 67890 -c 24680\n\n./gen -type random\n./gen -type random_small\n./gen -type random_large\n./gen -type many_solutions\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:04:34.551366",
        "total_tutorials": 3,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "3/A",
      "title": "A. Shortest path of the king",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test64 megabytes",
      "input_spec": "InputThe first line contains the chessboard coordinates of square s, the second line — of square t.Chessboard coordinates consist of two characters, the first one is a lowercase Latin letter (from a to h), the second one is a digit from 1 to 8.",
      "output_spec": "OutputIn the first line print n — minimum number of the king's moves. Then in n lines print the moves themselves. Each move is described with one of the 8: L, R, U, D, LU, LD, RU or RD. L, R, U, D stand respectively for moves left, right, up and down (according to the picture), and 2-letter combinations stand for diagonal moves. If the answer is not unique, print any of them.",
      "sample_tests": "ExamplesInputCopya8h1OutputCopy7RDRDRDRDRDRDRD",
      "description": "A. Shortest path of the king\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test64 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains the chessboard coordinates of square s, the second line — of square t.Chessboard coordinates consist of two characters, the first one is a lowercase Latin letter (from a to h), the second one is a digit from 1 to 8.\n\nOutputIn the first line print n — minimum number of the king's moves. Then in n lines print the moves themselves. Each move is described with one of the 8: L, R, U, D, LU, LD, RU or RD. L, R, U, D stand respectively for moves left, right, up and down (according to the picture), and 2-letter combinations stand for diagonal moves. If the answer is not unique, print any of them.\n\nInputCopya8h1OutputCopy7RDRDRDRDRDRDRD\n\nInputCopya8h1\n\nOutputCopy7RDRDRDRDRDRDRD",
      "solutions": [
        {
          "title": "Codeforces Beta Round #3 - Codeforces",
          "content": "I propose to discuss here all that concerns Codeforces Beta Round #3. Of course, during the competition it is forbidden to write anything about the solution of problems and similar things  For the time of this contest, we turned off the chat server. This does not mean that it will not operate in future - I think it is a convenient and efficient way to communicate during the competition and you may expect it in the future.  Also I'd like to announce Codeforces Beta Round #4, which will be held next week. It will be for participants from the second division (non-rated users or those having less than 1500 rating points). We will try not to delay Codeforces Beta Round #5, which will be opened for all. Wish you high rating,MikeMirzayanov",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/141",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.6,
            "reason": "宽松匹配: 包含题目编号 3 和字母"
          },
          "content_length": 742
        },
        {
          "title": "Codeforces Beta Round #3 - Codeforces",
          "content": "I propose to discuss here all that concerns Codeforces Beta Round #3. Of course, during the competition it is forbidden to write anything about the solution of problems and similar things  For the time of this contest, we turned off the chat server. This does not mean that it will not operate in future - I think it is a convenient and efficient way to communicate during the competition and you may expect it in the future.  Also I'd like to announce Codeforces Beta Round #4, which will be held next week. It will be for participants from the second division (non-rated users or those having less than 1500 rating points). We will try not to delay Codeforces Beta Round #5, which will be opened for all. Wish you high rating,MikeMirzayanov",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/192",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.6,
            "reason": "宽松匹配: 包含题目编号 3 和字母"
          },
          "content_length": 742
        },
        {
          "title": "Codeforces Beta Round #3 - Codeforces",
          "content": "I propose to discuss here all that concerns Codeforces Beta Round #3. Of course, during the competition it is forbidden to write anything about the solution of problems and similar things  For the time of this contest, we turned off the chat server. This does not mean that it will not operate in future - I think it is a convenient and efficient way to communicate during the competition and you may expect it in the future.  Also I'd like to announce Codeforces Beta Round #4, which will be held next week. It will be for participants from the second division (non-rated users or those having less than 1500 rating points). We will try not to delay Codeforces Beta Round #5, which will be opened for all. Wish you high rating,MikeMirzayanov",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/142",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.6,
            "reason": "宽松匹配: 包含题目编号 3 和字母"
          },
          "content_length": 742
        }
      ],
      "code_examples": [],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    string s = inf.readLine(\"[a-h][1-8]\", \"s\");\n    string t = inf.readLine(\"[a-h][1-8]\", \"t\");\n    inf.readEof();\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    string s = inf.readLine(\"[a-h][1-8]\", \"s\");\n    string t = inf.readLine(\"[a-h][1-8]\", \"t\");\n    inf.readEof();\n\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    string s = inf.readLine(\"[a-h][1-8]\", \"s\");\n    string t = inf.readLine(\"[a-h][1-8]\", \"t\");\n    inf.readEof();\n\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\npair<int,int> parse_position(string pos) {\n    if (pos.size() != 2) {\n        quitf(_fail, \"Invalid position format\");\n    }\n    char col_char = pos[0];\n    char row_char = pos[1];\n\n    if (col_char < 'a' || col_char > 'h') {\n        quitf(_fail, \"Invalid column character in position %s\", pos.c_str());\n    }\n    if (row_char < '1' || row_char > '8') {\n        quitf(_fail, \"Invalid row character in position %s\", pos.c_str());\n    }\n\n    int col = col_char - 'a' + 1; // columns from 1 to 8\n    int row = row_char - '1' + 1; // rows from 1 to 8\n\n    return make_pair(col, row);\n}\n\nint main(int argc, char* argv[]) {\n    registerTestlibCmd(argc, argv);\n\n    // Read starting and target positions from the input file\n    string s_str = inf.readString();\n    string t_str = inf.readString();\n\n    // Parse positions into coordinates\n    pair<int,int> s = parse_position(s_str);\n    pair<int,int> t = parse_position(t_str);\n\n    // Compute the minimal number of moves\n    int nmin = max(abs(s.first - t.first), abs(s.second - t.second));\n\n    // Read participant's output\n    int n = ouf.readInt(0, 1000, \"n\");\n    if (n != nmin) {\n        quitf(_wa, \"Number of moves is not minimal: expected %d, found %d\", nmin, n);\n    }\n\n    vector<string> moves_list;\n    for (int i = 0; i < n; ++i) {\n        string mv = ouf.readToken();\n        moves_list.push_back(mv);\n    }\n\n    // Define allowed moves\n    map<string, pair<int,int>> moves_map{\n        {\"L\",  {-1, 0}},\n        {\"R\",  {1,  0}},\n        {\"U\",  {0,  1}},\n        {\"D\",  {0, -1}},\n        {\"LU\", {-1, 1}},\n        {\"LD\", {-1,-1}},\n        {\"RU\", {1,  1}},\n        {\"RD\", {1, -1}},\n    };\n\n    // Simulate the moves\n    int x = s.first;\n    int y = s.second;\n    for (int i = 0; i < n; ++i) {\n        string mv = moves_list[i];\n        if (moves_map.find(mv) == moves_map.end()) {\n            quitf(_wa, \"Invalid move '%s' at step %d\", mv.c_str(), i+1);\n        }\n        x += moves_map[mv].first;\n        y += moves_map[mv].second;\n        // Check that new position is within the board\n        if (x < 1 || x > 8 || y < 1 || y > 8) {\n            quitf(_wa, \"Move goes off the board at step %d\", i+1);\n        }\n    }\n\n    // Check if the final position matches the target position\n    if (x != t.first || y != t.second) {\n        quitf(_wa, \"Did not reach target position after %d moves\", n);\n    }\n\n    quitf(_ok, \"Correct answer\");\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    string type = opt<string>(\"type\", \"random\");\n    string from = opt<string>(\"from\", \"\");\n    string to = opt<string>(\"to\", \"\");\n\n    // Define s and t as strings\n    string s, t;\n\n    if (type == \"random\") {\n        // If from is specified, use it. Otherwise generate random\n        if (from.empty()) {\n            char col = 'a' + rnd.next(8);\n            char row = '1' + rnd.next(8);\n            s = string(1, col) + row;\n        } else {\n            s = from;\n        }\n        if (to.empty()) {\n            char col = 'a' + rnd.next(8);\n            char row = '1' + rnd.next(8);\n            t = string(1, col) + row;\n        } else {\n            t = to;\n        }\n    }\n    else if (type == \"same\") {\n        if (from.empty()) {\n            char col = 'a' + rnd.next(8);\n            char row = '1' + rnd.next(8);\n            s = string(1, col) + row;\n        } else {\n            s = from;\n        }\n        t = s;\n    }\n    else if (type == \"max_distance\") {\n        // If from is specified, calculate to accordingly\n        // For max distance, we need difference in rows and columns to be 7\n        if (from.empty()) {\n            // Randomly choose s\n            char col_s = 'a' + rnd.next(8);\n            char row_s = '1' + rnd.next(8);\n            s = string(1, col_s) + row_s;\n        } else {\n            s = from;\n        }\n        int col_s = s[0] - 'a';\n        int row_s = s[1] - '1';\n        // Now, we need to pick to so that abs(col_s - col_t) == 7, same for row\n        int col_t = 7 - col_s;\n        int row_t = 7 - row_s;\n        t = string(1, 'a' + col_t) + (char)('1' + row_t);\n    }\n    else if (type == \"adjacent\") {\n        if (from.empty()) {\n            char col_s = 'a' + rnd.next(8);\n            char row_s = '1' + rnd.next(8);\n            s = string(1, col_s) + row_s;\n        } else {\n            s = from;\n        }\n        int col_s = s[0] - 'a';\n        int row_s = s[1] - '1';\n        // Get list of possible moves\n        vector<pair<int, int>> moves = {\n            {-1, -1}, {-1, 0}, {-1, 1},\n            {0, -1}, /*{0,0},*/ {0, 1},\n            {1, -1}, {1, 0}, {1, 1}\n        };\n        vector<pair<int, int>> adj_squares;\n        for (auto move : moves) {\n            int col_t = col_s + move.first;\n            int row_t = row_s + move.second;\n            if (col_t >= 0 && col_t < 8 && row_t >= 0 && row_t <8) {\n                adj_squares.push_back({col_t, row_t});\n            }\n        }\n        // Randomly pick one adjacent square\n        int idx = rnd.next(adj_squares.size());\n        int col_t = adj_squares[idx].first;\n        int row_t = adj_squares[idx].second;\n        t = string(1, 'a' + col_t) + (char)('1' + row_t);\n    }\n    else if (type == \"edge_cases\") {\n        // s is on the edge or corner\n        vector<pair<char, char>> edge_squares;\n        // Add corner squares\n        edge_squares.push_back({'a', '1'});\n        edge_squares.push_back({'a', '8'});\n        edge_squares.push_back({'h', '1'});\n        edge_squares.push_back({'h', '8'});\n        // Add edge squares\n        for (char col = 'b'; col <= 'g'; ++col) {\n            edge_squares.push_back({col, '1'});\n            edge_squares.push_back({col, '8'});\n        }\n        for (char row = '2'; row <= '7'; ++row) {\n            edge_squares.push_back({'a', row});\n            edge_squares.push_back({'h', row});\n        }\n        if (from.empty()) {\n            int idx = rnd.next(edge_squares.size());\n            s = string(1, edge_squares[idx].first) + edge_squares[idx].second;\n        } else {\n            s = from;\n        }\n        if (to.empty()) {\n            char col_t = 'a' + rnd.next(8);\n            char row_t = '1' + rnd.next(8);\n            t = string(1, col_t) + row_t;\n        } else {\n            t = to;\n        }\n    }\n    else {\n        // Unknown type\n        fprintf(stderr, \"Unknown type: %s\\n\", type.c_str());\n        exit(1);\n    }\n\n    // Validate s and t are valid squares\n    auto is_valid_square = [](const string& sq) -> bool {\n        if (sq.size() !=2) return false;\n        char col = sq[0];\n        char row = sq[1];\n        return col >= 'a' && col <= 'h' && row >= '1' && row <= '8';\n    };\n    if (!is_valid_square(s) || !is_valid_square(t)) {\n        fprintf(stderr, \"Invalid square generated: %s or %s\\n\", s.c_str(), t.c_str());\n        exit(1);\n    }\n\n    // Output s and t\n    printf(\"%s\\n\", s.c_str());\n    printf(\"%s\\n\", t.c_str());\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    string type = opt<string>(\"type\", \"random\");\n    string from = opt<string>(\"from\", \"\");\n    string to = opt<string>(\"to\", \"\");\n\n    // Define s and t as strings\n    string s, t;\n\n    if (type == \"random\") {\n        // If from is specified, use it. Otherwise generate random\n        if (from.empty()) {\n            char col = 'a' + rnd.next(8);\n            char row = '1' + rnd.next(8);\n            s = string(1, col) + row;\n        } else {\n            s = from;\n        }\n        if (to.empty()) {\n            char col = 'a' + rnd.next(8);\n            char row = '1' + rnd.next(8);\n            t = string(1, col) + row;\n        } else {\n            t = to;\n        }\n    }\n    else if (type == \"same\") {\n        if (from.empty()) {\n            char col = 'a' + rnd.next(8);\n            char row = '1' + rnd.next(8);\n            s = string(1, col) + row;\n        } else {\n            s = from;\n        }\n        t = s;\n    }\n    else if (type == \"max_distance\") {\n        // If from is specified, calculate to accordingly\n        // For max distance, we need difference in rows and columns to be 7\n        if (from.empty()) {\n            // Randomly choose s\n            char col_s = 'a' + rnd.next(8);\n            char row_s = '1' + rnd.next(8);\n            s = string(1, col_s) + row_s;\n        } else {\n            s = from;\n        }\n        int col_s = s[0] - 'a';\n        int row_s = s[1] - '1';\n        // Now, we need to pick to so that abs(col_s - col_t) == 7, same for row\n        int col_t = 7 - col_s;\n        int row_t = 7 - row_s;\n        t = string(1, 'a' + col_t) + (char)('1' + row_t);\n    }\n    else if (type == \"adjacent\") {\n        if (from.empty()) {\n            char col_s = 'a' + rnd.next(8);\n            char row_s = '1' + rnd.next(8);\n            s = string(1, col_s) + row_s;\n        } else {\n            s = from;\n        }\n        int col_s = s[0] - 'a';\n        int row_s = s[1] - '1';\n        // Get list of possible moves\n        vector<pair<int, int>> moves = {\n            {-1, -1}, {-1, 0}, {-1, 1},\n            {0, -1}, /*{0,0},*/ {0, 1},\n            {1, -1}, {1, 0}, {1, 1}\n        };\n        vector<pair<int, int>> adj_squares;\n        for (auto move : moves) {\n            int col_t = col_s + move.first;\n            int row_t = row_s + move.second;\n            if (col_t >= 0 && col_t < 8 && row_t >= 0 && row_t <8) {\n                adj_squares.push_back({col_t, row_t});\n            }\n        }\n        // Randomly pick one adjacent square\n        int idx = rnd.next(adj_squares.size());\n        int col_t = adj_squares[idx].first;\n        int row_t = adj_squares[idx].second;\n        t = string(1, 'a' + col_t) + (char)('1' + row_t);\n    }\n    else if (type == \"edge_cases\") {\n        // s is on the edge or corner\n        vector<pair<char, char>> edge_squares;\n        // Add corner squares\n        edge_squares.push_back({'a', '1'});\n        edge_squares.push_back({'a', '8'});\n        edge_squares.push_back({'h', '1'});\n        edge_squares.push_back({'h', '8'});\n        // Add edge squares\n        for (char col = 'b'; col <= 'g'; ++col) {\n            edge_squares.push_back({col, '1'});\n            edge_squares.push_back({col, '8'});\n        }\n        for (char row = '2'; row <= '7'; ++row) {\n            edge_squares.push_back({'a', row});\n            edge_squares.push_back({'h', row});\n        }\n        if (from.empty()) {\n            int idx = rnd.next(edge_squares.size());\n            s = string(1, edge_squares[idx].first) + edge_squares[idx].second;\n        } else {\n            s = from;\n        }\n        if (to.empty()) {\n            char col_t = 'a' + rnd.next(8);\n            char row_t = '1' + rnd.next(8);\n            t = string(1, col_t) + row_t;\n        } else {\n            t = to;\n        }\n    }\n    else {\n        // Unknown type\n        fprintf(stderr, \"Unknown type: %s\\n\", type.c_str());\n        exit(1);\n    }\n\n    // Validate s and t are valid squares\n    auto is_valid_square = [](const string& sq) -> bool {\n        if (sq.size() !=2) return false;\n        char col = sq[0];\n        char row = sq[1];\n        return col >= 'a' && col <= 'h' && row >= '1' && row <= '8';\n    };\n    if (!is_valid_square(s) || !is_valid_square(t)) {\n        fprintf(stderr, \"Invalid square generated: %s or %s\\n\", s.c_str(), t.c_str());\n        exit(1);\n    }\n\n    // Output s and t\n    printf(\"%s\\n\", s.c_str());\n    printf(\"%s\\n\", t.c_str());\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -type same\n./gen -type adjacent\n./gen -type max_distance\n./gen -type edge_cases\n\n# Random test cases\n./gen -type random\n./gen -type random\n./gen -type random\n\n# Fixed starting position\n./gen -type random -from e4\n./gen -type random -from h8\n./gen -type random -from a1\n\n# Fixed target position\n./gen -type random -to e4\n./gen -type random -to h8\n./gen -type random -to a1\n\n# Max distance from fixed starting position\n./gen -type max_distance -from a1\n./gen -type max_distance -from h8\n\n# Adjacent squares from fixed starting position\n./gen -type adjacent -from d4\n\n# Edge cases with fixed starting positions\n./gen -type edge_cases -from a1\n./gen -type edge_cases -from h8\n\n# Generate same square with fixed position\n./gen -type same -from e5\n\n# Generate edge cases with random starting positions\n./gen -type edge_cases\n./gen -type edge_cases\n./gen -type edge_cases\n\n# Generate several random test cases\n./gen -type random\n./gen -type random\n./gen -type random\n./gen -type random\n./gen -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:04:36.299962",
        "total_tutorials": 3,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "3/B",
      "title": "B. Грузовик",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест2 seconds",
      "memory_limit": "ограничение по памяти на тест64 megabytes",
      "input_spec": "Входные данныеВ первой строке записана пара целых чисел n и v (1 ≤ n ≤ 105; 1 ≤ v ≤ 109), где n это количество плавсредств на лодочной базе, а v — объем кузова грузовика в кубических метрах. Следующие n строк содержат описания плавсредств. Каждое описание это пара чисел ti, pi (1 ≤ ti ≤ 2; 1 ≤ pi ≤ 104), где ti это тип плавсредства (1 — байдарка, 2 — катамаран), а pi его грузоподъемность. Плавсредства нумеруются с единицы в порядке их появления во входном файле.",
      "output_spec": "Выходные данныеВ первую строку выведите искомую максимальную грузоподъемность набора. Во вторую строку выведите номера плавсредств, которые составляют оптимальный набор. Если решений несколько, выведите любое.",
      "sample_tests": "ПримерыВходные данныеСкопировать3 21 22 71 3Выходные данныеСкопировать72",
      "description": "B. Грузовик\n\nограничение по времени на тест2 seconds\n\nограничение по времени на тест\n\nограничение по памяти на тест64 megabytes\n\nограничение по памяти на тест\n\nвыводstdout\n\nВходные данныеВ первой строке записана пара целых чисел n и v (1 ≤ n ≤ 105; 1 ≤ v ≤ 109), где n это количество плавсредств на лодочной базе, а v — объем кузова грузовика в кубических метрах. Следующие n строк содержат описания плавсредств. Каждое описание это пара чисел ti, pi (1 ≤ ti ≤ 2; 1 ≤ pi ≤ 104), где ti это тип плавсредства (1 — байдарка, 2 — катамаран), а pi его грузоподъемность. Плавсредства нумеруются с единицы в порядке их появления во входном файле.\n\nВходные данные\n\nВыходные данныеВ первую строку выведите искомую максимальную грузоподъемность набора. Во вторую строку выведите номера плавсредств, которые составляют оптимальный набор. Если решений несколько, выведите любое.\n\nВыходные данные\n\nВходные данныеСкопировать3 21 22 71 3Выходные данныеСкопировать72\n\nВходные данныеСкопировать3 21 22 71 3\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать72\n\nВыходные данныеСкопировать\n\nСкопировать",
      "solutions": [
        {
          "title": "Codeforces Beta Round #3 - Codeforces",
          "content": "Предлагаю обсуждать здесь всего, что касается Codeforces Beta Round #3. Конечно, во время соревнования запрещено писать что-либо, касающееся решения задач и т.п.На время этого контеста мы выключили чат-сервер. Это не значит, что в будущем его не будет - я думаю это удобный и оперативный способ общения во время соревнования и его стоит ждать в будущем.Так же, пользуясь моментом, хочу анонсировать Codeforces Beta Round #4, который пройдет на следующей неделе. Он будет рассчитан на участников из второго дивизиона (новички + те, к кого рейтинг менее 1500). Мы постараемся не задерживаться с Codeforces Beta Round #5, в котором смогут принять участие все.Желаю высокого рейтинга,MikeMirzayanov",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/141",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.5,
            "reason": "宽松匹配: 包含题目编号 3"
          },
          "content_length": 694
        },
        {
          "title": "Codeforces Beta Round #3 - Codeforces",
          "content": "Предлагаю обсуждать здесь всего, что касается Codeforces Beta Round #3. Конечно, во время соревнования запрещено писать что-либо, касающееся решения задач и т.п.На время этого контеста мы выключили чат-сервер. Это не значит, что в будущем его не будет - я думаю это удобный и оперативный способ общения во время соревнования и его стоит ждать в будущем.Так же, пользуясь моментом, хочу анонсировать Codeforces Beta Round #4, который пройдет на следующей неделе. Он будет рассчитан на участников из второго дивизиона (новички + те, к кого рейтинг менее 1500). Мы постараемся не задерживаться с Codeforces Beta Round #5, в котором смогут принять участие все.Желаю высокого рейтинга,MikeMirzayanov",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/192",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.5,
            "reason": "宽松匹配: 包含题目编号 3"
          },
          "content_length": 694
        },
        {
          "title": "Codeforces Beta Round #3 - Codeforces",
          "content": "Предлагаю обсуждать здесь всего, что касается Codeforces Beta Round #3. Конечно, во время соревнования запрещено писать что-либо, касающееся решения задач и т.п.На время этого контеста мы выключили чат-сервер. Это не значит, что в будущем его не будет - я думаю это удобный и оперативный способ общения во время соревнования и его стоит ждать в будущем.Так же, пользуясь моментом, хочу анонсировать Codeforces Beta Round #4, который пройдет на следующей неделе. Он будет рассчитан на участников из второго дивизиона (новички + те, к кого рейтинг менее 1500). Мы постараемся не задерживаться с Codeforces Beta Round #5, в котором смогут принять участие все.Желаю высокого рейтинга,MikeMirzayanov",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/142",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.5,
            "reason": "宽松匹配: 包含题目编号 3"
          },
          "content_length": 694
        }
      ],
      "code_examples": [],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int v = inf.readInt(1, 1000000000, \"v\");\n    inf.readEoln();\n\n    for (int i = 0; i < n; i++) {\n        int ti = inf.readInt(1, 2, \"ti\");\n        inf.readSpace();\n        int pi = inf.readInt(1, 10000, \"pi\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int v = inf.readInt(1, 1000000000, \"v\");\n    inf.readEoln();\n\n    for (int i = 0; i < n; i++) {\n        int ti = inf.readInt(1, 2, \"ti\");\n        inf.readSpace();\n        int pi = inf.readInt(1, 10000, \"pi\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int v = inf.readInt(1, 1000000000, \"v\");\n    inf.readEoln();\n\n    for (int i = 0; i < n; i++) {\n        int ti = inf.readInt(1, 2, \"ti\");\n        inf.readSpace();\n        int pi = inf.readInt(1, 10000, \"pi\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char *argv[]) {\n    registerTestlibCmd(argc, argv);\n\n    int n = inf.readInt();\n    long long v = inf.readLong();\n    vector<int> ti(n);\n    vector<int> pi(n);\n    for (int i = 0; i < n; ++i) {\n        ti[i] = inf.readInt();\n        pi[i] = inf.readInt();\n    }\n\n    long long jury_max_capacity = ans.readLong();\n\n    long long participant_capacity = ouf.readLong();\n\n    if (participant_capacity < jury_max_capacity)\n        quitf(_wa, \"participant's capacity %lld is less than jury's maximum %lld\", participant_capacity, jury_max_capacity);\n    else if (participant_capacity > jury_max_capacity)\n        quitf(_fail, \"participant's capacity %lld is greater than jury's maximum %lld\", participant_capacity, jury_max_capacity);\n\n    // Read participant's vehicle indices\n    vector<int> indices;\n    while (!ouf.seekEof()) {\n        int idx = ouf.readInt();\n        indices.push_back(idx);\n    }\n\n    set<int> used_indices;\n    long long total_volume = 0;\n    long long total_capacity = 0;\n    for (size_t i = 0; i < indices.size(); ++i) {\n        int idx = indices[i];\n        if (idx < 1 || idx > n)\n            quitf(_wa, \"invalid vehicle index %d\", idx);\n        if (used_indices.count(idx))\n            quitf(_wa, \"duplicate vehicle index %d\", idx);\n        used_indices.insert(idx);\n        int type = ti[idx - 1];\n        int capacity = pi[idx - 1];\n        int volume = (type == 1) ? 1 : 2;\n        total_volume += volume;\n        total_capacity += capacity;\n    }\n\n    if (total_volume > v)\n        quitf(_wa, \"total volume %lld exceeds lorry capacity %lld\", total_volume, v);\n\n    if (total_capacity != participant_capacity)\n        quitf(_wa, \"participant's calculated capacity %lld does not match claimed capacity %lld\", total_capacity, participant_capacity);\n\n    quitf(_ok, \"found maximum capacity %lld\", total_capacity);\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int v = opt<int>(\"v\");\n    string type = opt<string>(\"type\", \"random\");\n    int k = opt<int>(\"k\", 10000);\n\n    if (k < 1 || k > 10000) {\n        cerr << \"Invalid k, must be between 1 and 10000\\n\";\n        return 1;\n    }\n\n    printf(\"%d %d\\n\", n, v);\n\n    if (type == \"random\") {\n        for (int i = 0; i < n; ++i) {\n            int ti = rnd.next(1, 2);\n            int pi = rnd.next(1, k);\n            printf(\"%d %d\\n\", ti, pi);\n        }\n    } else if (type == \"maxKayak\") {\n        for (int i = 0; i < n; ++i) {\n            int ti = 1; // Kayak\n            int pi = rnd.next(k / 2, k); // High carrying capacity\n            printf(\"%d %d\\n\", ti, pi);\n        }\n    } else if (type == \"maxCatamaran\") {\n        for (int i = 0; i < n; ++i) {\n            int ti = 2; // Catamaran\n            int pi = rnd.next(k / 2, k); // High carrying capacity\n            printf(\"%d %d\\n\", ti, pi);\n        }\n    } else if (type == \"alternating\") {\n        for (int i = 0; i < n; ++i) {\n            int ti = (i % 2) + 1; // Alternating between 1 and 2\n            int pi = rnd.next(1, k);\n            printf(\"%d %d\\n\", ti, pi);\n        }\n    } else {\n        fprintf(stderr, \"Unknown type: %s\\n\", type.c_str());\n        return 1;\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int v = opt<int>(\"v\");\n    string type = opt<string>(\"type\", \"random\");\n    int k = opt<int>(\"k\", 10000);\n\n    if (k < 1 || k > 10000) {\n        cerr << \"Invalid k, must be between 1 and 10000\\n\";\n        return 1;\n    }\n\n    printf(\"%d %d\\n\", n, v);\n\n    if (type == \"random\") {\n        for (int i = 0; i < n; ++i) {\n            int ti = rnd.next(1, 2);\n            int pi = rnd.next(1, k);\n            printf(\"%d %d\\n\", ti, pi);\n        }\n    } else if (type == \"maxKayak\") {\n        for (int i = 0; i < n; ++i) {\n            int ti = 1; // Kayak\n            int pi = rnd.next(k / 2, k); // High carrying capacity\n            printf(\"%d %d\\n\", ti, pi);\n        }\n    } else if (type == \"maxCatamaran\") {\n        for (int i = 0; i < n; ++i) {\n            int ti = 2; // Catamaran\n            int pi = rnd.next(k / 2, k); // High carrying capacity\n            printf(\"%d %d\\n\", ti, pi);\n        }\n    } else if (type == \"alternating\") {\n        for (int i = 0; i < n; ++i) {\n            int ti = (i % 2) + 1; // Alternating between 1 and 2\n            int pi = rnd.next(1, k);\n            printf(\"%d %d\\n\", ti, pi);\n        }\n    } else {\n        fprintf(stderr, \"Unknown type: %s\\n\", type.c_str());\n        return 1;\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -v 1 -type random\n./gen -n 1 -v 1 -type maxKayak\n./gen -n 1 -v 2 -type maxCatamaran\n./gen -n 1 -v 1 -type alternating\n\n./gen -n 2 -v 2 -type random\n./gen -n 2 -v 2 -type alternating\n\n./gen -n 10 -v 5 -type random\n./gen -n 10 -v 10 -type maxKayak\n./gen -n 10 -v 20 -type maxCatamaran\n./gen -n 10 -v 15 -type alternating\n\n./gen -n 100 -v 50 -type random\n./gen -n 100 -v 100 -type maxKayak\n./gen -n 100 -v 200 -type maxCatamaran\n./gen -n 100 -v 150 -type alternating\n\n./gen -n 1000 -v 500 -type random\n./gen -n 1000 -v 1000 -type maxKayak\n./gen -n 1000 -v 2000 -type maxCatamaran\n./gen -n 1000 -v 1500 -type alternating\n\n./gen -n 100000 -v 50000 -type random\n./gen -n 100000 -v 100000 -type maxKayak\n./gen -n 100000 -v 200000 -type maxCatamaran\n./gen -n 100000 -v 150000 -type alternating\n\n./gen -n 100000 -v 1000000000 -type random -k 1\n./gen -n 100000 -v 1000000000 -type random -k 10000\n./gen -n 100000 -v 1000000000 -type maxKayak\n./gen -n 100000 -v 1000000000 -type maxCatamaran\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:04:37.935592",
        "total_tutorials": 3,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "3/C",
      "title": "C. Tic-tac-toe",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test64 megabytes",
      "input_spec": "InputThe input consists of three lines, each of the lines contains characters \".\", \"X\" or \"0\" (a period, a capital letter X, or a digit zero).",
      "output_spec": "OutputPrint one of the six verdicts: first, second, illegal, the first player won, the second player won or draw.",
      "sample_tests": "ExamplesInputCopyX0X.0..X.OutputCopysecond",
      "description": "C. Tic-tac-toe\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test64 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe input consists of three lines, each of the lines contains characters \".\", \"X\" or \"0\" (a period, a capital letter X, or a digit zero).\n\nOutputPrint one of the six verdicts: first, second, illegal, the first player won, the second player won or draw.\n\nInputCopyX0X.0..X.OutputCopysecond\n\nInputCopyX0X.0..X.\n\nOutputCopysecond",
      "solutions": [
        {
          "title": "Codeforces Beta Round #3 - Codeforces",
          "content": "I propose to discuss here all that concerns Codeforces Beta Round #3. Of course, during the competition it is forbidden to write anything about the solution of problems and similar things  For the time of this contest, we turned off the chat server. This does not mean that it will not operate in future - I think it is a convenient and efficient way to communicate during the competition and you may expect it in the future.  Also I'd like to announce Codeforces Beta Round #4, which will be held next week. It will be for participants from the second division (non-rated users or those having less than 1500 rating points). We will try not to delay Codeforces Beta Round #5, which will be opened for all. Wish you high rating,MikeMirzayanov",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/141",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.6,
            "reason": "宽松匹配: 包含题目编号 3 和字母"
          },
          "content_length": 742
        },
        {
          "title": "Codeforces Beta Round #3 - Codeforces",
          "content": "I propose to discuss here all that concerns Codeforces Beta Round #3. Of course, during the competition it is forbidden to write anything about the solution of problems and similar things  For the time of this contest, we turned off the chat server. This does not mean that it will not operate in future - I think it is a convenient and efficient way to communicate during the competition and you may expect it in the future.  Also I'd like to announce Codeforces Beta Round #4, which will be held next week. It will be for participants from the second division (non-rated users or those having less than 1500 rating points). We will try not to delay Codeforces Beta Round #5, which will be opened for all. Wish you high rating,MikeMirzayanov",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/192",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.6,
            "reason": "宽松匹配: 包含题目编号 3 和字母"
          },
          "content_length": 742
        },
        {
          "title": "Codeforces Beta Round #3 - Codeforces",
          "content": "I propose to discuss here all that concerns Codeforces Beta Round #3. Of course, during the competition it is forbidden to write anything about the solution of problems and similar things  For the time of this contest, we turned off the chat server. This does not mean that it will not operate in future - I think it is a convenient and efficient way to communicate during the competition and you may expect it in the future.  Also I'd like to announce Codeforces Beta Round #4, which will be held next week. It will be for participants from the second division (non-rated users or those having less than 1500 rating points). We will try not to delay Codeforces Beta Round #5, which will be opened for all. Wish you high rating,MikeMirzayanov",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/142",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.6,
            "reason": "宽松匹配: 包含题目编号 3 和字母"
          },
          "content_length": 742
        }
      ],
      "code_examples": [],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    for (int i = 0; i < 3; ++i) {\n        string s = inf.readLine(\"[.X0]{3}\");\n    }\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    for (int i = 0; i < 3; ++i) {\n        string s = inf.readLine(\"[.X0]{3}\");\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    for (int i = 0; i < 3; ++i) {\n        string s = inf.readLine(\"[.X0]{3}\");\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare sequences of tokens\");\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string j, p;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n\r\n        ans.readWordTo(j);\r\n        ouf.readWordTo(p);\r\n\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s words differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  compress(j).c_str(), compress(p).c_str());\r\n    }\r\n\r\n    if (ans.seekEof() && ouf.seekEof()) {\r\n        if (n == 1)\r\n            quitf(_ok, \"\\\"%s\\\"\", compress(j).c_str());\r\n        else\r\n            quitf(_ok, \"%d tokens\", n);\r\n    } else {\r\n        if (ans.seekEof())\r\n            quitf(_wa, \"Participant output contains extra tokens\");\r\n        else\r\n            quitf(_wa, \"Unexpected EOF in the participants output\");\r\n    }\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nchar players[] = {'X', '0'};\n\nbool checkWin(vector<string> &board, char player) {\n    for(int i = 0; i < 3; ++i) {\n        if(board[i][0]==player && board[i][1]==player && board[i][2]==player) return true;\n        if(board[0][i]==player && board[1][i]==player && board[2][i]==player) return true;\n    }\n    if(board[0][0]==player && board[1][1]==player && board[2][2]==player) return true;\n    if(board[0][2]==player && board[1][1]==player && board[2][0]==player) return true;\n    return false;\n}\n\nvoid printBoard(vector<string> &board) {\n    for(int i = 0; i < 3; ++i)\n        printf(\"%s\\n\", board[i].c_str());\n}\n\nvoid generateBoard(string type) {\n    vector<string> board(3, \"...\");\n    if(type == \"first\") {\n        // Empty board\n        // Already initialized\n    } else if(type == \"second\") {\n        // One 'X' on board\n        int pos = rnd.next(9);\n        board[pos/3][pos%3] = 'X';\n    } else if(type == \"illegal_overmark\") {\n        // Difference between counts of 'X's and '0's is more than 1\n        for(int i = 0; i < 5; ++i) {\n            int pos;\n            do {\n                pos = rnd.next(9);\n            } while(board[pos/3][pos%3] != '.');\n            board[pos/3][pos%3] = 'X';\n        }\n        for(int i = 0; i < 1; ++i) {\n            int pos;\n            do {\n                pos = rnd.next(9);\n            } while(board[pos/3][pos%3] != '.');\n            board[pos/3][pos%3] = '0';\n        }\n    } else if(type == \"illegal_more0\") {\n        // More '0's than 'X's\n        for(int i = 0; i < 2; ++i) {\n            int pos;\n            do {\n                pos = rnd.next(9);\n            } while(board[pos/3][pos%3] != '.');\n            board[pos/3][pos%3] = '0';\n        }\n        int pos;\n        do {\n            pos = rnd.next(9);\n        } while(board[pos/3][pos%3] != '.');\n        board[pos/3][pos%3] = 'X';\n    } else if(type == \"illegal_bothwin\") {\n        // Both players have winning lines\n        board = {\"X0X\", \"0X0\", \"0X0\"};\n    } else if(type == \"illegal_xwon_but_more0\") {\n        // 'X' has won but there are too many '0's\n        board = {\"XXX\", \"000\", \"...\"};\n    } else if(type == \"first_wins\") {\n        // 'X' has winning line\n        board = {\"XXX\", \"...\", \"...\"};\n    } else if(type == \"second_wins\") {\n        // '0' has winning line\n        board = {\"X0X\", \"0X.\", \"0..\"};\n    } else if(type == \"draw\") {\n        // Full board, no winner\n        board = {\"X0X\", \"0X0\", \"0X0\"};\n    } else if(type == \"first_turn\") {\n        // 'X's and '0's counts are equal\n        for(int i = 0; i < 4; ++i) {\n            int pos;\n            do {\n                pos = rnd.next(9);\n            } while(board[pos/3][pos%3] != '.');\n            board[pos/3][pos%3] = players[i%2];\n        }\n    } else if(type == \"second_turn\") {\n        // 'X's count is one more than '0's\n        for(int i = 0; i < 5; ++i) {\n            int pos;\n            do {\n                pos = rnd.next(9);\n            } while(board[pos/3][pos%3] != '.');\n            board[pos/3][pos%3] = players[i%2];\n        }\n    } else if(type == \"illegal_double_xwin\") {\n        // 'X' wins in two ways\n        board = {\"X.X\", \".X.\", \"X.X\"};\n    } else if(type == \"illegal_0wins_on_equal_counts\") {\n        // '0' wins but counts are equal\n        board = {\"0X0\", \"X0X\", \"..0\"};\n    } else if(type == \"almost_full_board_no_win\") {\n        // Board is nearly full, no winner yet\n        board = {\"X0X\", \"0X0\", \"0X.\"};\n    } else if(type == \"last_move_first_wins\") {\n        // 'X' wins on last move\n        board = {\"X0X\", \"0X0\", \"0X0\"};\n    } else if(type == \"last_move_second_wins\") {\n        // '0' wins on last move\n        board = {\"X0X\", \"X0X\", \"0X0\"};\n    } else if(type == \"win_on_diagonal_first\") {\n        // 'X' wins on diagonal\n        board = {\"X0.\", \"0X.\", \"..X\"};\n    } else if(type == \"win_on_diagonal_second\") {\n        // '0' wins on diagonal\n        board = {\"0X.\", \"X0.\", \"..0\"};\n    } else if(type == \"false_win_pattern\") {\n        // Pattern that looks like a win but isn't\n        board = {\"X0X\", \"X0X\", \"0X0\"};\n    } else if(type == \"illegal_all_x\") {\n        // All 'X's, should be illegal\n        board = {\"XXX\", \"XXX\", \"XXX\"};\n    } else if(type == \"illegal_all_0\") {\n        // All '0's, should be illegal\n        board = {\"000\", \"000\", \"000\"};\n    } else if(type == \"illegal_less_x\") {\n        // Less 'X's than '0's\n        board = {\"0X0\", \"0X0\", \"...\"};\n    } else if(type == \"random_valid\") {\n        // Random valid board\n        int xCount = rnd.next(5);\n        int oCount = rnd.next(0, xCount);\n        int totalMoves = xCount + oCount;\n        vector<int> positions(9);\n        iota(positions.begin(), positions.end(), 0);\n        shuffle(positions.begin(), positions.end());\n        for(int i = 0; i < totalMoves; ++i) {\n            int pos = positions[i];\n            board[pos/3][pos%3] = players[i%2];\n        }\n    } else if(type == \"random_illegal\") {\n        // Random illegal board\n        for(int i = 0; i < 9; ++i) {\n            int r = rnd.next(3);\n            board[i/3][i%3] = (r == 0) ? '.' : (r == 1) ? 'X' : '0';\n        }\n    }\n    printBoard(board);\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    string type = opt<string>(\"type\", \"first\");\n    int count = opt<int>(\"count\", 1);\n\n    for(int i = 0; i < count; ++i) {\n        generateBoard(type);\n        if (i != count - 1) printf(\"\\n\");\n    }\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nchar players[] = {'X', '0'};\n\nbool checkWin(vector<string> &board, char player) {\n    for(int i = 0; i < 3; ++i) {\n        if(board[i][0]==player && board[i][1]==player && board[i][2]==player) return true;\n        if(board[0][i]==player && board[1][i]==player && board[2][i]==player) return true;\n    }\n    if(board[0][0]==player && board[1][1]==player && board[2][2]==player) return true;\n    if(board[0][2]==player && board[1][1]==player && board[2][0]==player) return true;\n    return false;\n}\n\nvoid printBoard(vector<string> &board) {\n    for(int i = 0; i < 3; ++i)\n        printf(\"%s\\n\", board[i].c_str());\n}\n\nvoid generateBoard(string type) {\n    vector<string> board(3, \"...\");\n    if(type == \"first\") {\n        // Empty board\n        // Already initialized\n    } else if(type == \"second\") {\n        // One 'X' on board\n        int pos = rnd.next(9);\n        board[pos/3][pos%3] = 'X';\n    } else if(type == \"illegal_overmark\") {\n        // Difference between counts of 'X's and '0's is more than 1\n        for(int i = 0; i < 5; ++i) {\n            int pos;\n            do {\n                pos = rnd.next(9);\n            } while(board[pos/3][pos%3] != '.');\n            board[pos/3][pos%3] = 'X';\n        }\n        for(int i = 0; i < 1; ++i) {\n            int pos;\n            do {\n                pos = rnd.next(9);\n            } while(board[pos/3][pos%3] != '.');\n            board[pos/3][pos%3] = '0';\n        }\n    } else if(type == \"illegal_more0\") {\n        // More '0's than 'X's\n        for(int i = 0; i < 2; ++i) {\n            int pos;\n            do {\n                pos = rnd.next(9);\n            } while(board[pos/3][pos%3] != '.');\n            board[pos/3][pos%3] = '0';\n        }\n        int pos;\n        do {\n            pos = rnd.next(9);\n        } while(board[pos/3][pos%3] != '.');\n        board[pos/3][pos%3] = 'X';\n    } else if(type == \"illegal_bothwin\") {\n        // Both players have winning lines\n        board = {\"X0X\", \"0X0\", \"0X0\"};\n    } else if(type == \"illegal_xwon_but_more0\") {\n        // 'X' has won but there are too many '0's\n        board = {\"XXX\", \"000\", \"...\"};\n    } else if(type == \"first_wins\") {\n        // 'X' has winning line\n        board = {\"XXX\", \"...\", \"...\"};\n    } else if(type == \"second_wins\") {\n        // '0' has winning line\n        board = {\"X0X\", \"0X.\", \"0..\"};\n    } else if(type == \"draw\") {\n        // Full board, no winner\n        board = {\"X0X\", \"0X0\", \"0X0\"};\n    } else if(type == \"first_turn\") {\n        // 'X's and '0's counts are equal\n        for(int i = 0; i < 4; ++i) {\n            int pos;\n            do {\n                pos = rnd.next(9);\n            } while(board[pos/3][pos%3] != '.');\n            board[pos/3][pos%3] = players[i%2];\n        }\n    } else if(type == \"second_turn\") {\n        // 'X's count is one more than '0's\n        for(int i = 0; i < 5; ++i) {\n            int pos;\n            do {\n                pos = rnd.next(9);\n            } while(board[pos/3][pos%3] != '.');\n            board[pos/3][pos%3] = players[i%2];\n        }\n    } else if(type == \"illegal_double_xwin\") {\n        // 'X' wins in two ways\n        board = {\"X.X\", \".X.\", \"X.X\"};\n    } else if(type == \"illegal_0wins_on_equal_counts\") {\n        // '0' wins but counts are equal\n        board = {\"0X0\", \"X0X\", \"..0\"};\n    } else if(type == \"almost_full_board_no_win\") {\n        // Board is nearly full, no winner yet\n        board = {\"X0X\", \"0X0\", \"0X.\"};\n    } else if(type == \"last_move_first_wins\") {\n        // 'X' wins on last move\n        board = {\"X0X\", \"0X0\", \"0X0\"};\n    } else if(type == \"last_move_second_wins\") {\n        // '0' wins on last move\n        board = {\"X0X\", \"X0X\", \"0X0\"};\n    } else if(type == \"win_on_diagonal_first\") {\n        // 'X' wins on diagonal\n        board = {\"X0.\", \"0X.\", \"..X\"};\n    } else if(type == \"win_on_diagonal_second\") {\n        // '0' wins on diagonal\n        board = {\"0X.\", \"X0.\", \"..0\"};\n    } else if(type == \"false_win_pattern\") {\n        // Pattern that looks like a win but isn't\n        board = {\"X0X\", \"X0X\", \"0X0\"};\n    } else if(type == \"illegal_all_x\") {\n        // All 'X's, should be illegal\n        board = {\"XXX\", \"XXX\", \"XXX\"};\n    } else if(type == \"illegal_all_0\") {\n        // All '0's, should be illegal\n        board = {\"000\", \"000\", \"000\"};\n    } else if(type == \"illegal_less_x\") {\n        // Less 'X's than '0's\n        board = {\"0X0\", \"0X0\", \"...\"};\n    } else if(type == \"random_valid\") {\n        // Random valid board\n        int xCount = rnd.next(5);\n        int oCount = rnd.next(0, xCount);\n        int totalMoves = xCount + oCount;\n        vector<int> positions(9);\n        iota(positions.begin(), positions.end(), 0);\n        shuffle(positions.begin(), positions.end());\n        for(int i = 0; i < totalMoves; ++i) {\n            int pos = positions[i];\n            board[pos/3][pos%3] = players[i%2];\n        }\n    } else if(type == \"random_illegal\") {\n        // Random illegal board\n        for(int i = 0; i < 9; ++i) {\n            int r = rnd.next(3);\n            board[i/3][i%3] = (r == 0) ? '.' : (r == 1) ? 'X' : '0';\n        }\n    }\n    printBoard(board);\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    string type = opt<string>(\"type\", \"first\");\n    int count = opt<int>(\"count\", 1);\n\n    for(int i = 0; i < count; ++i) {\n        generateBoard(type);\n        if (i != count - 1) printf(\"\\n\");\n    }\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Test case 1: Empty board, it's first player's turn\n./gen -type first -count 1\n\n# Test case 2: Board where counts of 'X's and '0's differ by more than 1 (illegal)\n./gen -type illegal_overmark -count 1\n\n# Test case 3: Board where there are more '0's than 'X's (illegal)\n./gen -type illegal_more0 -count 1\n\n# Test case 4: Board where both 'X' and '0' have three in a row (illegal)\n./gen -type illegal_bothwin -count 1\n\n# Test case 5: Board where 'X' has won, but there are too many '0's (illegal)\n./gen -type illegal_xwon_but_more0 -count 1\n\n# Test case 6: Board where 'X' has won (the first player won)\n./gen -type first_wins -count 1\n\n# Test case 7: Board where '0' has won (the second player won)\n./gen -type second_wins -count 1\n\n# Test case 8: Board that is a draw (fully filled, no winner)\n./gen -type draw -count 1\n\n# Test case 9: Board where no one has won yet, and it's first player's turn\n./gen -type first_turn -count 1\n\n# Test case 10: Board where no one has won yet, and it's second player's turn\n./gen -type second_turn -count 1\n\n# Generate multiple random boards for each type\n./gen -type first_turn -count 5\n./gen -type second_turn -count 5\n./gen -type first_wins -count 5\n./gen -type second_wins -count 5\n./gen -type draw -count 5\n./gen -type illegal -count 5\n\n# Include specific challenging boards\n\n# Board where 'X' has an impossible win (e.g., two winning lines)\n./gen -type illegal_double_xwin -count 1\n\n# Board where '0' has an impossible win (e.g., '0' wins when number of 'X's equals number of '0's)\n./gen -type illegal_0wins_on_equal_counts -count 1\n\n# Board where game is in progress but someone incorrectly claims it's a draw\n./gen -type almost_full_board_no_win -count 1\n\n# Edge cases\n\n# Last move winning game for each player\n./gen -type last_move_first_wins -count 1\n./gen -type last_move_second_wins -count 1\n\n# Boards with diagonal wins\n./gen -type win_on_diagonal_first -count 1\n./gen -type win_on_diagonal_second -count 1\n\n# Board with a false win pattern\n./gen -type false_win_pattern -count 1\n\n# Board with only 'X's (illegal)\n./gen -type illegal_all_x -count 1\n\n# Board with only '0's (illegal)\n./gen -type illegal_all_0 -count 1\n\n# Board where the number of 'X's is less than the number of '0's\n./gen -type illegal_less_x -count 1\n\n# Random valid boards\n./gen -type random_valid -count 10\n\n# Random illegal boards\n./gen -type random_illegal -count 10\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:04:39.762832",
        "total_tutorials": 3,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "3/D",
      "title": "D. Скобочная последовательность",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест1 second",
      "memory_limit": "ограничение по памяти на тест64 megabytes",
      "input_spec": "Входные данныеВ первой строке входного файла записан непустой шаблон четной длины, состоящий из символов «(», «)» и «?». Его длина не превосходит 5·104. Далее содержится m строк, где m — количество символов «?» в шаблоне. Каждая строка состоит из двух целых чисел ai и bi (1 leai, bi ≤ 106), где ai стоимость замены i-го символа «?» на открывающуюся скобку, а bi — на закрывающуюся.",
      "output_spec": "Выходные данныеВ первую строку выведите стоимость искомой последовательности. Во вторую выведите искомую последовательность.Если решения не существует, выведите -1. Если решений несколько, выведите любое.",
      "sample_tests": "ПримерыВходные данныеСкопировать(??)1 22 8Выходные данныеСкопировать4()()",
      "description": "D. Скобочная последовательность\n\nограничение по времени на тест1 second\n\nограничение по времени на тест\n\nограничение по памяти на тест64 megabytes\n\nограничение по памяти на тест\n\nвыводstdout\n\nВходные данныеВ первой строке входного файла записан непустой шаблон четной длины, состоящий из символов «(», «)» и «?». Его длина не превосходит 5·104. Далее содержится m строк, где m — количество символов «?» в шаблоне. Каждая строка состоит из двух целых чисел ai и bi (1 leai, bi ≤ 106), где ai стоимость замены i-го символа «?» на открывающуюся скобку, а bi — на закрывающуюся.\n\nВходные данные\n\nВыходные данныеВ первую строку выведите стоимость искомой последовательности. Во вторую выведите искомую последовательность.Если решения не существует, выведите -1. Если решений несколько, выведите любое.\n\nВыходные данные\n\nВходные данныеСкопировать(??)1 22 8Выходные данныеСкопировать4()()\n\nВходные данныеСкопировать(??)1 22 8\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать4()()\n\nВыходные данныеСкопировать\n\nСкопировать",
      "solutions": [
        {
          "title": "Codeforces Beta Round #3 - Codeforces",
          "content": "Предлагаю обсуждать здесь всего, что касается Codeforces Beta Round #3. Конечно, во время соревнования запрещено писать что-либо, касающееся решения задач и т.п.На время этого контеста мы выключили чат-сервер. Это не значит, что в будущем его не будет - я думаю это удобный и оперативный способ общения во время соревнования и его стоит ждать в будущем.Так же, пользуясь моментом, хочу анонсировать Codeforces Beta Round #4, который пройдет на следующей неделе. Он будет рассчитан на участников из второго дивизиона (новички + те, к кого рейтинг менее 1500). Мы постараемся не задерживаться с Codeforces Beta Round #5, в котором смогут принять участие все.Желаю высокого рейтинга,MikeMirzayanov",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/141",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.5,
            "reason": "宽松匹配: 包含题目编号 3"
          },
          "content_length": 694
        },
        {
          "title": "Codeforces Beta Round #3 - Codeforces",
          "content": "Предлагаю обсуждать здесь всего, что касается Codeforces Beta Round #3. Конечно, во время соревнования запрещено писать что-либо, касающееся решения задач и т.п.На время этого контеста мы выключили чат-сервер. Это не значит, что в будущем его не будет - я думаю это удобный и оперативный способ общения во время соревнования и его стоит ждать в будущем.Так же, пользуясь моментом, хочу анонсировать Codeforces Beta Round #4, который пройдет на следующей неделе. Он будет рассчитан на участников из второго дивизиона (новички + те, к кого рейтинг менее 1500). Мы постараемся не задерживаться с Codeforces Beta Round #5, в котором смогут принять участие все.Желаю высокого рейтинга,MikeMirzayanov",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/192",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.5,
            "reason": "宽松匹配: 包含题目编号 3"
          },
          "content_length": 694
        },
        {
          "title": "Codeforces Beta Round #3 - Codeforces",
          "content": "Предлагаю обсуждать здесь всего, что касается Codeforces Beta Round #3. Конечно, во время соревнования запрещено писать что-либо, касающееся решения задач и т.п.На время этого контеста мы выключили чат-сервер. Это не значит, что в будущем его не будет - я думаю это удобный и оперативный способ общения во время соревнования и его стоит ждать в будущем.Так же, пользуясь моментом, хочу анонсировать Codeforces Beta Round #4, который пройдет на следующей неделе. Он будет рассчитан на участников из второго дивизиона (новички + те, к кого рейтинг менее 1500). Мы постараемся не задерживаться с Codeforces Beta Round #5, в котором смогут принять участие все.Желаю высокого рейтинга,MikeMirzayanov",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/142",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.5,
            "reason": "宽松匹配: 包含题目编号 3"
          },
          "content_length": 694
        }
      ],
      "code_examples": [],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    string pattern = inf.readToken();\n    inf.readEoln();\n    int n = pattern.length();\n    ensure(1 <= n && n <= 50000);\n    ensure(n % 2 == 0);\n\n    int m = 0;\n    for (int i = 0; i < n; i++) {\n        char c = pattern[i];\n        ensure(c == '(' || c == ')' || c == '?');\n        if (c == '?') {\n            m++;\n        }\n    }\n\n    for (int i = 0; i < m; i++) {\n        int a = inf.readInt(1, 1000000);\n        inf.readSpace();\n        int b = inf.readInt(1, 1000000);\n        inf.readEoln();\n    }\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    string pattern = inf.readToken();\n    inf.readEoln();\n    int n = pattern.length();\n    ensure(1 <= n && n <= 50000);\n    ensure(n % 2 == 0);\n\n    int m = 0;\n    for (int i = 0; i < n; i++) {\n        char c = pattern[i];\n        ensure(c == '(' || c == ')' || c == '?');\n        if (c == '?') {\n            m++;\n        }\n    }\n\n    for (int i = 0; i < m; i++) {\n        int a = inf.readInt(1, 1000000);\n        inf.readSpace();\n        int b = inf.readInt(1, 1000000);\n        inf.readEoln();\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    string pattern = inf.readToken();\n    inf.readEoln();\n    int n = pattern.length();\n    ensure(1 <= n && n <= 50000);\n    ensure(n % 2 == 0);\n\n    int m = 0;\n    for (int i = 0; i < n; i++) {\n        char c = pattern[i];\n        ensure(c == '(' || c == ')' || c == '?');\n        if (c == '?') {\n            m++;\n        }\n    }\n\n    for (int i = 0; i < m; i++) {\n        int a = inf.readInt(1, 1000000);\n        inf.readSpace();\n        int b = inf.readInt(1, 1000000);\n        inf.readEoln();\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\n// We'll store the pattern and costs for each '?' from the input.\n// readAns() will parse either \"-1\" or \"cost + bracket-sequence\" from a given stream,\n// check if it matches the rules (correct length, matches given pattern chars,\n// regular bracket sequence, and cost correctness), then return the cost or a special value.\n\nstatic const long long NO_SOLUTION = -1;\n\nstring pattern;\nvector<long long> costOpen, costClose; // Cost for each '?'\nvector<int> qpos; // positions of '?' in the pattern\n\n// Check if bracket sequence s is a valid (regular) bracket sequence\nbool isValidBracketSequence(const string &s) {\n    int balance = 0;\n    for (char c : s) {\n        if (c == '(') balance++;\n        else balance--;\n        if (balance < 0) return false;\n    }\n    return (balance == 0);\n}\n\n// readAns() will parse the contestant (or jury) answer.\nlong long readAns(InStream &stream) {\n    // The solution may print \"-1\" if it claims no solution exists.\n    // Otherwise, the solution prints cost and then the bracket sequence.\n\n    // Try to read first token. If it's \"-1\", we are done. Otherwise it must be the cost.\n    string token = stream.readToken(\"(-1)|([0-9]+)\");\n    if (token == \"-1\") {\n        return NO_SOLUTION; // means no solution\n    }\n\n    // Otherwise, parse cost.\n    long long claimedCost = stoll(token);\n\n    // Then read the bracket sequence.\n    string seq = stream.readToken(); // the entire bracket sequence\n\n    // The sequence length must match pattern length.\n    if ((int)seq.size() != (int)pattern.size()) {\n        stream.quitf(_wa, \"the bracket sequence length doesn't match pattern length\");\n    }\n\n    // Check bracket-by-bracket:\n    //   1) for each '(' or ')' in the pattern, participant must match exactly.\n    //   2) for each '?' in the pattern, participant must provide '(' or ')',\n    //      and we sum up cost accordingly.\n    long long computedCost = 0;\n    int questionIndex = 0;\n    for (int i = 0; i < (int)pattern.size(); i++) {\n        if (pattern[i] == '(') {\n            if (seq[i] != '(') {\n                stream.quitf(_wa, \"output does not match fixed '(' in the pattern at position %d\", i+1);\n            }\n        } else if (pattern[i] == ')') {\n            if (seq[i] != ')') {\n                stream.quitf(_wa, \"output does not match fixed ')' in the pattern at position %d\", i+1);\n            }\n        } else {\n            // pattern[i] == '?'\n            if (seq[i] != '(' && seq[i] != ')') {\n                stream.quitf(_wa, \"output must replace '?' with '(' or ')'\");\n            }\n            // add cost\n            if (seq[i] == '(') {\n                computedCost += costOpen[questionIndex];\n            } else {\n                computedCost += costClose[questionIndex];\n            }\n            questionIndex++;\n        }\n    }\n\n    // Now check validity of the overall bracket sequence\n    if (!isValidBracketSequence(seq)) {\n        stream.quitf(_wa, \"the bracket sequence is not valid (not regular)\");\n    }\n\n    // Check if the claimed cost matches computed cost\n    if (claimedCost != computedCost) {\n        stream.quitf(_wa, \"claimed cost %lld does not match computed cost %lld\", claimedCost, computedCost);\n    }\n\n    return claimedCost;\n}\n\nint main(int argc, char* argv[]){\n    registerTestlibCmd(argc, argv);\n\n    // Read the pattern from input\n    pattern = inf.readLine();\n    // Count how many '?' in the pattern\n    for (int i = 0; i < (int)pattern.size(); i++) {\n        if (pattern[i] == '?') {\n            qpos.push_back(i);\n        }\n    }\n    // Read costs for each '?'\n    costOpen.resize(qpos.size());\n    costClose.resize(qpos.size());\n    for (int i = 0; i < (int)qpos.size(); i++) {\n        long long a = inf.readLong(1, 1000000);\n        long long b = inf.readLong(1, 1000000);\n        costOpen[i] = a;\n        costClose[i] = b;\n    }\n\n    // Read the jury's answer\n    long long jans = readAns(ans);\n    // Read the participant's answer\n    long long pans = readAns(ouf);\n\n    // Compare\n    if (jans == NO_SOLUTION && pans == NO_SOLUTION) {\n        // Both claim no solution\n        quitf(_ok, \"both answers claim no solution\");\n    } else if (jans == NO_SOLUTION && pans != NO_SOLUTION) {\n        // Jury says no solution, participant found one => participant is better => _fail\n        quitf(_fail, \"participant found a solution but jury claims none\");\n    } else if (jans != NO_SOLUTION && pans == NO_SOLUTION) {\n        // Jury has a solution, participant claims none => WA\n        quitf(_wa, \"jury has a solution but participant claims none\");\n    } else {\n        // both have solutions\n        if (jans < pans) {\n            // participant is worse\n            quitf(_wa, \"jury found cheaper solution: jans = %lld, pans = %lld\", jans, pans);\n        } else if (jans == pans) {\n            quitf(_ok, \"both found solution of cost %lld\", pans);\n        } else {\n            // participant is better => _fail\n            quitf(_fail, \"participant found cheaper solution: jans = %lld, pans = %lld\", jans, pans);\n        }\n    }\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    // Read parameters\n    int n = opt<int>(\"n\");\n    int k = opt<int>(\"k\");\n    string type = opt<string>(\"type\", \"random\");\n    string cost_type = opt<string>(\"cost_type\", \"random\");\n\n    // Ensure n is even and within [2, 50000]\n    ensure(n % 2 == 0 && n >= 2 && n <= 50000);\n    ensure(k >= 0 && k <= n);\n\n    string seq(n, ' ');\n\n    if (type == \"possible\") {\n        // Generate a valid regular bracket sequence\n        int balance = 0;\n        int total_open = n / 2;\n        int total_close = n / 2;\n        for (int i = 0; i < n; ++i) {\n            if (balance < total_open && (balance == 0 || rnd.next(2))) {\n                seq[i] = '(';\n                balance++;\n            } else {\n                seq[i] = ')';\n                balance--;\n            }\n        }\n\n        // Replace k positions with '?'\n        vector<int> positions(n);\n        for (int i = 0; i < n; ++i)\n            positions[i] = i;\n        shuffle(positions.begin(), positions.end());\n        int num_question_marks = min(k, n);\n        for (int i = 0; i < num_question_marks; ++i) {\n            seq[positions[i]] = '?';\n        }\n\n    } else if (type == \"impossible\") {\n        // Generate a sequence that cannot be made regular\n        int num_open = n / 2;\n        int num_close = n / 2;\n        int extra_close = rnd.next(1, n / 2);\n        int pos = 0;\n        for (int i = 0; i < extra_close; ++i) {\n            seq[pos++] = ')';\n            num_close--;\n        }\n        while (pos < n) {\n            if (num_open > 0 && (num_close == 0 || rnd.next(2))) {\n                seq[pos++] = '(';\n                num_open--;\n            } else {\n                seq[pos++] = ')';\n                num_close--;\n            }\n        }\n\n        // Replace k positions with '?'\n        vector<int> positions(n);\n        for (int i = 0; i < n; ++i)\n            positions[i] = i;\n        shuffle(positions.begin(), positions.end());\n        int num_question_marks = min(k, n);\n        for (int i = 0; i < num_question_marks; ++i) {\n            seq[positions[i]] = '?';\n        }\n\n    } else {\n        // Random sequence\n        int num_question_marks = k;\n        for (int i = 0; i < n; ++i) {\n            int choice = rnd.next(3);\n            if (choice == 0 && num_question_marks > 0) {\n                seq[i] = '?';\n                num_question_marks--;\n            } else if (choice == 1) {\n                seq[i] = '(';\n            } else {\n                seq[i] = ')';\n            }\n        }\n        // Assign remaining '?'\n        for (int i = 0; i < n && num_question_marks > 0; ++i) {\n            if (seq[i] != '?') {\n                seq[i] = '?';\n                num_question_marks--;\n            }\n        }\n    }\n\n    // Output the pattern\n    cout << seq << endl;\n\n    // Output the costs for each '?'\n    int m = 0;\n    for (char c : seq)\n        if (c == '?')\n            m++;\n    for (int i = 0; i < n; ++i) {\n        if (seq[i] == '?') {\n            int a_i, b_i;\n            if (cost_type == \"uniform\") {\n                a_i = rnd.next(1, 1000000);\n                b_i = rnd.next(1, 1000000);\n            } else if (cost_type == \"skewed\") {\n                a_i = rnd.next(1, 1000);\n                b_i = rnd.next(10000, 1000000);\n            } else {\n                a_i = rnd.next(1, 1000000);\n                b_i = rnd.next(1, 1000000);\n            }\n            cout << a_i << \" \" << b_i << endl;\n        }\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    // Read parameters\n    int n = opt<int>(\"n\");\n    int k = opt<int>(\"k\");\n    string type = opt<string>(\"type\", \"random\");\n    string cost_type = opt<string>(\"cost_type\", \"random\");\n\n    // Ensure n is even and within [2, 50000]\n    ensure(n % 2 == 0 && n >= 2 && n <= 50000);\n    ensure(k >= 0 && k <= n);\n\n    string seq(n, ' ');\n\n    if (type == \"possible\") {\n        // Generate a valid regular bracket sequence\n        int balance = 0;\n        int total_open = n / 2;\n        int total_close = n / 2;\n        for (int i = 0; i < n; ++i) {\n            if (balance < total_open && (balance == 0 || rnd.next(2))) {\n                seq[i] = '(';\n                balance++;\n            } else {\n                seq[i] = ')';\n                balance--;\n            }\n        }\n\n        // Replace k positions with '?'\n        vector<int> positions(n);\n        for (int i = 0; i < n; ++i)\n            positions[i] = i;\n        shuffle(positions.begin(), positions.end());\n        int num_question_marks = min(k, n);\n        for (int i = 0; i < num_question_marks; ++i) {\n            seq[positions[i]] = '?';\n        }\n\n    } else if (type == \"impossible\") {\n        // Generate a sequence that cannot be made regular\n        int num_open = n / 2;\n        int num_close = n / 2;\n        int extra_close = rnd.next(1, n / 2);\n        int pos = 0;\n        for (int i = 0; i < extra_close; ++i) {\n            seq[pos++] = ')';\n            num_close--;\n        }\n        while (pos < n) {\n            if (num_open > 0 && (num_close == 0 || rnd.next(2))) {\n                seq[pos++] = '(';\n                num_open--;\n            } else {\n                seq[pos++] = ')';\n                num_close--;\n            }\n        }\n\n        // Replace k positions with '?'\n        vector<int> positions(n);\n        for (int i = 0; i < n; ++i)\n            positions[i] = i;\n        shuffle(positions.begin(), positions.end());\n        int num_question_marks = min(k, n);\n        for (int i = 0; i < num_question_marks; ++i) {\n            seq[positions[i]] = '?';\n        }\n\n    } else {\n        // Random sequence\n        int num_question_marks = k;\n        for (int i = 0; i < n; ++i) {\n            int choice = rnd.next(3);\n            if (choice == 0 && num_question_marks > 0) {\n                seq[i] = '?';\n                num_question_marks--;\n            } else if (choice == 1) {\n                seq[i] = '(';\n            } else {\n                seq[i] = ')';\n            }\n        }\n        // Assign remaining '?'\n        for (int i = 0; i < n && num_question_marks > 0; ++i) {\n            if (seq[i] != '?') {\n                seq[i] = '?';\n                num_question_marks--;\n            }\n        }\n    }\n\n    // Output the pattern\n    cout << seq << endl;\n\n    // Output the costs for each '?'\n    int m = 0;\n    for (char c : seq)\n        if (c == '?')\n            m++;\n    for (int i = 0; i < n; ++i) {\n        if (seq[i] == '?') {\n            int a_i, b_i;\n            if (cost_type == \"uniform\") {\n                a_i = rnd.next(1, 1000000);\n                b_i = rnd.next(1, 1000000);\n            } else if (cost_type == \"skewed\") {\n                a_i = rnd.next(1, 1000);\n                b_i = rnd.next(10000, 1000000);\n            } else {\n                a_i = rnd.next(1, 1000000);\n                b_i = rnd.next(1, 1000000);\n            }\n            cout << a_i << \" \" << b_i << endl;\n        }\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Small tests with possible sequences\n./gen -n 2 -k 0 -type possible -cost_type uniform\n./gen -n 4 -k 1 -type possible -cost_type skewed\n./gen -n 10 -k 3 -type possible -cost_type random\n\n# Small tests with impossible sequences\n./gen -n 2 -k 0 -type impossible -cost_type uniform\n./gen -n 4 -k 1 -type impossible -cost_type skewed\n./gen -n 10 -k 5 -type impossible -cost_type random\n\n# Random sequences\n./gen -n 6 -k 2 -type random -cost_type uniform\n./gen -n 8 -k 4 -type random -cost_type skewed\n./gen -n 12 -k 6 -type random -cost_type random\n\n# Medium tests with possible sequences\n./gen -n 100 -k 20 -type possible -cost_type uniform\n./gen -n 200 -k 50 -type possible -cost_type skewed\n./gen -n 500 -k 100 -type possible -cost_type random\n\n# Medium tests with impossible sequences\n./gen -n 100 -k 20 -type impossible -cost_type uniform\n./gen -n 200 -k 50 -type impossible -cost_type skewed\n./gen -n 500 -k 100 -type impossible -cost_type random\n\n# Large tests with maximum n\n./gen -n 50000 -k 10000 -type possible -cost_type uniform\n./gen -n 50000 -k 25000 -type possible -cost_type skewed\n./gen -n 50000 -k 40000 -type possible -cost_type random\n\n./gen -n 50000 -k 10000 -type impossible -cost_type uniform\n./gen -n 50000 -k 25000 -type impossible -cost_type skewed\n./gen -n 50000 -k 40000 -type impossible -cost_type random\n\n# Tests with no question marks\n./gen -n 1000 -k 0 -type possible -cost_type uniform\n./gen -n 1000 -k 0 -type impossible -cost_type random\n\n# Tests with all question marks\n./gen -n 1000 -k 1000 -type possible -cost_type uniform\n./gen -n 1000 -k 1000 -type impossible -cost_type skewed\n\n# Tests with balanced costs\n./gen -n 1000 -k 500 -type possible -cost_type uniform\n./gen -n 1000 -k 500 -type impossible -cost_type uniform\n\n# Random large tests\n./gen -n 49998 -k 24999 -type random -cost_type random\n./gen -n 49998 -k 10000 -type random -cost_type skewed\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:04:41.522996",
        "total_tutorials": 3,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "30/A",
      "title": "A. Бухгалтерский учёт",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест2 seconds",
      "memory_limit": "ограничение по памяти на тест256 megabytes",
      "input_spec": "Входные данныеВ единственной строке записаны три целых числа A, B, n, удовлетворяющих условиям: |A|, |B| ≤ 1000, 1 ≤ n ≤ 10.",
      "output_spec": "Выходные данныеВыведите единственное целое число — искомый целый коэффициент X, или фразу «No solution», если такого коэффициента не существует, или он не целый. Если ответов несколько, выведите любой.",
      "sample_tests": "ПримерыВходные данныеСкопировать2 18 2Выходные данныеСкопировать3Входные данныеСкопировать-1 8 3Выходные данныеСкопировать-2Входные данныеСкопировать0 0 10Выходные данныеСкопировать5Входные данныеСкопировать1 16 5Выходные данныеСкопироватьNo solution",
      "description": "A. Бухгалтерский учёт\n\nограничение по времени на тест2 seconds\n\nограничение по времени на тест\n\nограничение по памяти на тест256 megabytes\n\nограничение по памяти на тест\n\nвыводstdout\n\nВходные данныеВ единственной строке записаны три целых числа A, B, n, удовлетворяющих условиям: |A|, |B| ≤ 1000, 1 ≤ n ≤ 10.\n\nВходные данные\n\nВыходные данныеВыведите единственное целое число — искомый целый коэффициент X, или фразу «No solution», если такого коэффициента не существует, или он не целый. Если ответов несколько, выведите любой.\n\nВыходные данные\n\nВходные данныеСкопировать2 18 2Выходные данныеСкопировать3Входные данныеСкопировать-1 8 3Выходные данныеСкопировать-2Входные данныеСкопировать0 0 10Выходные данныеСкопировать5Входные данныеСкопировать1 16 5Выходные данныеСкопироватьNo solution\n\nВходные данныеСкопировать2 18 2\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать3\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать-1 8 3\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать-2\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать0 0 10\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать5\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать1 16 5\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопироватьNo solution\n\nВыходные данныеСкопировать\n\nСкопировать",
      "solutions": [
        {
          "title": "Codeforces Beta Round #30 (Codeforces format) - Codeforces",
          "content": "Сегодняшний контест подготовлен нами, командой Saratov SU 2 (Максим Иванов, Артем Рахов, Коля Кузнецов).От Вас потребуется решить пять простых и не очень задачек для одного Царя, про которого вы вряд ли что-нибудь слышали раньше. Царь надеется, что задачи окажутся не очень сложными для Вас, и у него будет богатый выбор среди различных решений по каждой задаче.UPD. Контест окончен, всем спасибо.Таблица результатов.Поздравляем rng_58 с победой!Разборы задач: A, B, C, D, E. Контест помогали готовить Михаил Мирзаянов и Дмитрий Матов.Условия задач можно скачать одним PDF-файлом:русская версияанглийская версияP.S. Не забудьте ознакомиться с правилами контеста Codeforces Format, если вы участвуете впервые!",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/692",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 708
        },
        {
          "title": "Codeforces Beta Round #30. Разбор A - Codeforces",
          "content": "Разбор задачи \"A. Бухгалтерский учёт\"Первый способ решения: переборПереберём все возможные X, и проверим каждое, подходит ли оно под указанные A и B. Понятно, что имеет смысл перебирать только в тех же пределах, которыми ограничены сами A и B, т.е. от -1000 до 1000 (легко понять, что сузить эти рамки никак нельзя - для любого числа от -1000 до 1000 найдётся соответствующий тест). При фиксированном X проверять ответ надо было, n раз производя умножения, но аккуратно следя за тем, чтобы переменная не переполнилась (на что многие попадали), например, прекращая умножать, если текущее произведение уже вылезло за пределы [ - 1000;1000].Второй способ решения: формулаЛегко заметить, что если ответ есть, то это корень n-ой степени из отношения |B| и |A|, возможно, с изменённым знаком, - если A и B имеют разный знак, и n нечётно (если n чётно, то в этом случае, очевидно, ответа не будет). Поэтому можно было просто воспользоваться функцией возведения числа в степень (возводить надо было в 1 / n-ю степень), которая есть во многих языках, и проверить, что получилось целое число (разумеется, с учётом точности, - например, что оно отличается от ближайшего целого не более чем на 10 - 9).Но здесь надо быть аккуратным со всякими нулями. Плохо, когда A = 0, и этот случай надо разобрать отдельно (B = 0 или B ≠ 0).Вообще очень многие ошибались на тесте с A = 0 или B = 0, и если бы такие тесты не содержались в претестах, то, наверное, у половины людей задача бы упала :)",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/696",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 1472
        },
        {
          "title": "Codeforces Beta Round #30. Разбор D - Codeforces",
          "content": "Разбор задачи \"D. Задача Царя?\"В этой задаче для правильного решения требуется следующая цепочка рассуждений (хотя, если некоторые шаги опустить или осуществить не полностью, всё равно получатся правильные решения :) ):Заметим, что после того, как мы пришли в город n + 1, дальнейший ответ зависит только от самого левого и самого правого из непосещённых городов (и ответом на задачу будет - пойти в ближайший к n+1-ому городу из них, а потом пойти в другой город). Отсюда сразу получаем решение для случая k = n + 1, и этот случай мы дальше не рассматриваем.Часть пути до города n + 1 - она покрывает какой-то отрезок городов на оси OX. Причём этот отрезок обязательно содержит точку k. Но таких отрезков может быть O(n2), поэтому пока это плохое решение.Можно понять, что если человек до перехода в город n + 1 как-то походил, но не посетил самый левый на оси город или самый правый, то тогда он совершил бессмысленное и невыгодное действие. В самом деле, ведь после прихода в точку n + 1 ответ будет однозначно определяться позициям самого левого и самого правого из непосещённых городов, а таким странным действием человек не изменит ни левую, ни правую границу, т.е. только ухудшит их.Остался случай, когда человек из города k пошёл в город n + 1 напрямик, и только потом спустился вниз. Во-первых, можно было просто вставить этот переход в программу, и больше не думать над ним :) Во-вторых, можно было всё же догадаться и доказать, что этот переход невыгоден. Для этого надо просто расписать два варианта пути: из k в n + 1, потом обратно в 1, потом в n (я считаю, что город 1 ближе к n + 1, чем n, и что k не совпадает ни с 1, ни с n), и второй вариант: из k в 1, потом в n + 1, потом в k + 1, потом в n. Выписыв явно эти две формулы, сократив одинаковые слагаемые, можно получить, что по неравенству треугольников второй вариант всегда лучше (не хуже).Таким образом, достаточно перебирать только два вида отрезков: [1;i] для i ≥ k, и [i;n] для i ≤ k (я считаю для удобства, что города отсортированы по абсциссе).Осталось аккуратно обработать каждый такой переход. Для этого перебираем все возможные i. Пусть, например, i ≤ k. Тогда надо попробовать такой переход: пойти из k в n, потом обратно в i, потом в n + 1, и потом обойти оставшуюся часть [1;i - 1]. Также обязательно надо попробовать второй переход: из k в i, потом в n, потом в n + 1, потом обойти оставшуюся часть [1;i - 1]. При i ≥ k - всё симметрично, получатся два других перехода.Итого, не считая сортировки в начале программы (без которой, наверное, можно обойтись), получается решение за O(n).",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/697",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 2568
        }
      ],
      "code_examples": [],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int A = inf.readInt(-1000, 1000); // Read A in [-1000, 1000]\n    inf.readSpace(); // Expect a space\n    int B = inf.readInt(-1000, 1000); // Read B in [-1000, 1000]\n    inf.readSpace(); // Expect a space\n    int n = inf.readInt(1, 10); // Read n in [1, 10]\n    inf.readEoln(); // Expect EOLN\n    inf.readEof(); // Expect EOF\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int A = inf.readInt(-1000, 1000); // Read A in [-1000, 1000]\n    inf.readSpace(); // Expect a space\n    int B = inf.readInt(-1000, 1000); // Read B in [-1000, 1000]\n    inf.readSpace(); // Expect a space\n    int n = inf.readInt(1, 10); // Read n in [1, 10]\n    inf.readEoln(); // Expect EOLN\n    inf.readEof(); // Expect EOF\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int A = inf.readInt(-1000, 1000); // Read A in [-1000, 1000]\n    inf.readSpace(); // Expect a space\n    int B = inf.readInt(-1000, 1000); // Read B in [-1000, 1000]\n    inf.readSpace(); // Expect a space\n    int n = inf.readInt(1, 10); // Read n in [1, 10]\n    inf.readEoln(); // Expect EOLN\n    inf.readEof(); // Expect EOF\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\n// We want to check if the contestant's answer is a valid integer X such that\n// A * (X^n) = B, given integers A, B, n.  If no such integer X exists, the\n// correct output is \"No solution\".  Notably, there can be multiple valid answers;\n// for example, if A = 0 and B = 0, then any integer X satisfies A * X^n = B.\n//\n// Outline of the checker:\n// 1) Read A, B, n from the input file.\n// 2) Read one token from contestant output.  It can either be the word \"No\" (we then\n//    expect \"No solution\") or an integer representing a proposed X.\n// 3) If \"No solution\" was provided:\n//      - Accept if indeed no integer X satisfies the equation\n//      - Otherwise reject.\n// 4) If an integer X was provided:\n//      - Check if A * (X^n) == B, taking care of edge cases (e.g., A=0, etc.).\n//      - If yes, accept. Otherwise reject.\n\nstatic long long safePow(long long base, int exp, bool &overflowed)\n{\n    // Computes base^exp in 64-bit, setting 'overflowed' = true if\n    // an overflow is detected or magnitude grows beyond any possible\n    // need for matching B up to |B| <= 1000 (since |A| <= 1000).\n    // If overflowed is set, the return value is not meaningful.\n    overflowed = false;\n    if(exp < 0) {\n        // Not expected in problem statement; no fractional exponent required.\n        // Mark overflow just to be safe:\n        overflowed = true;\n        return 0;\n    }\n\n    long long result = 1;\n    long long limit = (1LL << 62); // a rough limit to detect 64-bit overflow\n    for(int i = 0; i < exp; i++){\n        // Check about to multiply\n        // If |result| > limit / max(1, |base|), we'd call it overflow.\n        if (base != 0 && llabs(result) > limit / llabs(base)) {\n            overflowed = true;\n            return 0LL;\n        }\n        result *= base;\n        // Additional check in case of sign overflow\n        if (llabs(result) > limit) {\n            overflowed = true;\n            return 0LL;\n        }\n    }\n    return result;\n}\n\nbool hasSolution(int A, int B, int n, long long &anyX)\n{\n    // This helper can be used to detect whether there exists *some* integer X\n    // satisfying A*X^n = B. If so, 'anyX' receives one such integer solution.\n    // We'll do a brute force for all possible X in range [-1000..1000]\n    // because |A|, |B| <= 1000 and n <= 10.\n    //\n    // Alternatively, we could handle the special case A=0 separately.\n\n    // A=0 and B=0 -> infinite solutions. Let's pick X=0 as an example.\n    if(A == 0 && B == 0){\n        anyX = 0; // arbitrary\n        return true;\n    }\n\n    // A=0 and B!=0 -> no solutions\n    if(A == 0 && B != 0){\n        return false;\n    }\n\n    // If A!=0, we want X^n = B/A, but we have to check B% A == 0\n    if(B == 0){\n        // Then we need A*(X^n)=0 => X^n=0 => X=0\n        anyX = 0;\n        return true;\n    }\n\n    // If B != 0\n    if(B % A != 0) {\n        return false;\n    }\n    long long Y = (long long)B / A;\n\n    // Now search for X in [-1000..1000] such that X^n = Y\n    // In practice, that is not too large for n<=10.\n    for(long long X = -1000; X <= 1000; X++){\n        bool of = false;\n        long long p = safePow(X, n, of);\n        if(!of && p == Y){\n            anyX = X;\n            return true;\n        }\n    }\n    return false;\n}\n\nbool checkContestantSolution(int A, int B, int n, const string &token)\n{\n    // If token == \"No solution\", let's see if there's no correct integer X.\n    if(token == \"No\" || token == \"No solution\")\n    {\n        // Make sure we fully match \"No solution\" (two tokens or single token).\n        // If it is just \"No\", attempt reading next token from ouf, to see if it is \"solution\".\n        // However, typically we read a single token, so let's allow either\n        // \"No\" or \"No solution\" as the entire output.\n\n        // Actually, the statement says output exactly \"No solution\". Let's allow a small relaxation:\n        // We'll accept if the first token is \"No\" and the second is \"solution\".\n        // The example usage with testlib typically would read the entire line or token(s).\n        // But let's keep it simple here: if user wrote \"No\" or \"No solution\",\n        // we treat that as \"No solution\".\n        long long dummyX;\n        if(!hasSolution(A, B, n, dummyX))\n            return true; // means \"No solution\" is correct\n        else\n            return false; // a solution does exist\n    }\n\n    // Otherwise, the user must have provided an integer X. Let's parse it safely.\n    long long XfromUser;\n    {\n        // If it can't parse, it's WA.\n        // testlib can parse directly, but let's do manual parse:\n        // We'll just try to read a long long from 'token'.\n        // If it fails or out of range, that is a WA.\n        bool ok = true;\n        try {\n            XfromUser = stoll(token);\n        } catch(...) {\n            ok = false;\n        }\n        if(!ok) return false;\n    }\n\n    // Now let's check if A*(X^n) == B\n    // handle special cases:\n    if(A == 0 && B == 0){\n        // Then any X is correct\n        return true;\n    }\n    if(A == 0 && B != 0){\n        // Then no X is correct\n        return false;\n    }\n    // now A != 0\n    // if B=0 => we want X^n=0 => X=0\n    if(B == 0){\n        return (XfromUser == 0);\n    }\n\n    // last case: B != 0\n    // check if B % A == 0\n    if(B % A != 0) {\n        return false;\n    }\n\n    long long Y = (long long)B / A;\n    // compute X^n carefully\n    bool of = false;\n    long long powX = safePow(XfromUser, n, of);\n    if(of) return false; // overflow => can't match\n    return (powX == Y);\n}\n\nint main(int argc, char* argv[])\n{\n    registerTestlibCmd(argc, argv);\n\n    int A = inf.readInt(-1000, 1000, \"A\");\n    int B = inf.readInt(-1000, 1000, \"B\");\n    int n = inf.readInt(1, 10,   \"n\");\n\n    // Read the contestant's entire output (it might be \"No solution\" or an integer).\n    // We'll read the first token. If \"No\" we suspect maybe next token \"solution\".\n    // But the problem statement's example always says \"No solution\" in one line, so let's\n    // just read a full line and trim it.\n    string line = ouf.readLine();\n    // trim\n    auto start = line.find_first_not_of(\" \\t\");\n    if(start == string::npos) {\n        // empty line => WA\n        ouf.quitf(_wa, \"Output is empty\");\n    }\n    auto end = line.find_last_not_of(\" \\t\");\n    line = line.substr(start, end - start + 1);\n\n    // We allow exactly either an integer or \"No solution\".\n    // So let's just check it directly with our check function:\n    if(!checkContestantSolution(A, B, n, line)){\n        ouf.quitf(_wa, \"Contestant output \\\"%s\\\" is not a valid solution\", line.c_str());\n    }\n\n    // If everything is correct:\n    ouf.quitf(_ok, \"Solution is correct\");\n    return 0; // not reachable\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\n// Function to check if B is a perfect n-th power times A\nbool isPerfectPower(int B, int n, int A) {\n    if (A == 0)\n        return B == 0;\n    if (n == 0) // n >= 1 as per constraints, but just in case\n        return B == A;\n    double X = pow((double)B / A, 1.0 / n);\n    int X_int = (int)round(X);\n    long long check = A;\n    for (int i = 0; i < n; i++)\n        check *= X_int;\n    return check == B;\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\", rnd.next(1, 10));\n    string type = opt<string>(\"type\", \"random\");\n\n    int A, B;\n\n    if (type == \"random\") {\n        // Random A, B, n within constraints\n        A = rnd.next(-1000, 1000);\n        B = rnd.next(-1000, 1000);\n    } else if (type == \"A_zero\") {\n        A = 0;\n        B = rnd.next(-1000, 1000);\n    } else if (type == \"B_zero\") {\n        A = rnd.next(-1000, 1000);\n        B = 0;\n    } else if (type == \"A_B_zero\") {\n        A = 0;\n        B = 0;\n    } else if (type == \"No_solution\") {\n        // Generate A, B, n such that no integer X satisfies A·X^n = B\n        do {\n            A = rnd.next(-1000, 1000);\n        } while (A == 0);\n        n = rnd.next(1, 10);\n        do {\n            B = rnd.next(-1000, 1000);\n        } while (isPerfectPower(B, n, A) || B == A);\n    } else if (type == \"Negative_A_B\") {\n        A = rnd.next(-1000, -1);\n        B = rnd.next(-1000, -1);\n    } else if (type == \"n_small\") {\n        n = 1;\n        A = rnd.next(-1000, 1000);\n        B = rnd.next(-1000, 1000);\n    } else if (type == \"n_large\") {\n        n = 10;\n        A = rnd.next(-1000, 1000);\n        B = rnd.next(-1000, 1000);\n    } else if (type == \"X_zero\") {\n        // Set B = 0, A ≠ 0, n ≥ 1\n        do {\n            A = rnd.next(-1000, 1000);\n        } while (A == 0);\n        n = rnd.next(1, 10);\n        B = 0;\n    } else if (type == \"Fractional_X\") {\n        // Generate A, B, n such that X is not integer\n        do {\n            A = rnd.next(-1000, 1000);\n        } while (A == 0);\n        n = rnd.next(1, 10);\n        do {\n            B = rnd.next(-1000, 1000);\n            double X = pow((double)B / A, 1.0 / n);\n        } while (B == A || fabs(round(pow((double)B / A, 1.0 / n)) - pow((double)B / A, 1.0 / n)) < 1e-6);\n    } else {\n        // Default to random\n        A = rnd.next(-1000, 1000);\n        B = rnd.next(-1000, 1000);\n    }\n\n    // Ensure A and B are within constraints\n    A = max(-1000, min(1000, A));\n    B = max(-1000, min(1000, B));\n\n    printf(\"%d %d %d\\n\", A, B, n);\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\n// Function to check if B is a perfect n-th power times A\nbool isPerfectPower(int B, int n, int A) {\n    if (A == 0)\n        return B == 0;\n    if (n == 0) // n >= 1 as per constraints, but just in case\n        return B == A;\n    double X = pow((double)B / A, 1.0 / n);\n    int X_int = (int)round(X);\n    long long check = A;\n    for (int i = 0; i < n; i++)\n        check *= X_int;\n    return check == B;\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\", rnd.next(1, 10));\n    string type = opt<string>(\"type\", \"random\");\n\n    int A, B;\n\n    if (type == \"random\") {\n        // Random A, B, n within constraints\n        A = rnd.next(-1000, 1000);\n        B = rnd.next(-1000, 1000);\n    } else if (type == \"A_zero\") {\n        A = 0;\n        B = rnd.next(-1000, 1000);\n    } else if (type == \"B_zero\") {\n        A = rnd.next(-1000, 1000);\n        B = 0;\n    } else if (type == \"A_B_zero\") {\n        A = 0;\n        B = 0;\n    } else if (type == \"No_solution\") {\n        // Generate A, B, n such that no integer X satisfies A·X^n = B\n        do {\n            A = rnd.next(-1000, 1000);\n        } while (A == 0);\n        n = rnd.next(1, 10);\n        do {\n            B = rnd.next(-1000, 1000);\n        } while (isPerfectPower(B, n, A) || B == A);\n    } else if (type == \"Negative_A_B\") {\n        A = rnd.next(-1000, -1);\n        B = rnd.next(-1000, -1);\n    } else if (type == \"n_small\") {\n        n = 1;\n        A = rnd.next(-1000, 1000);\n        B = rnd.next(-1000, 1000);\n    } else if (type == \"n_large\") {\n        n = 10;\n        A = rnd.next(-1000, 1000);\n        B = rnd.next(-1000, 1000);\n    } else if (type == \"X_zero\") {\n        // Set B = 0, A ≠ 0, n ≥ 1\n        do {\n            A = rnd.next(-1000, 1000);\n        } while (A == 0);\n        n = rnd.next(1, 10);\n        B = 0;\n    } else if (type == \"Fractional_X\") {\n        // Generate A, B, n such that X is not integer\n        do {\n            A = rnd.next(-1000, 1000);\n        } while (A == 0);\n        n = rnd.next(1, 10);\n        do {\n            B = rnd.next(-1000, 1000);\n            double X = pow((double)B / A, 1.0 / n);\n        } while (B == A || fabs(round(pow((double)B / A, 1.0 / n)) - pow((double)B / A, 1.0 / n)) < 1e-6);\n    } else {\n        // Default to random\n        A = rnd.next(-1000, 1000);\n        B = rnd.next(-1000, 1000);\n    }\n\n    // Ensure A and B are within constraints\n    A = max(-1000, min(1000, A));\n    B = max(-1000, min(1000, B));\n\n    printf(\"%d %d %d\\n\", A, B, n);\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Random test cases\n./gen -type random\n./gen -type random\n./gen -type random\n./gen -type random\n./gen -type random\n\n# A_zero test cases\n./gen -type A_zero\n./gen -type A_zero\n\n# B_zero test cases\n./gen -type B_zero\n./gen -type B_zero\n\n# A_B_zero test case\n./gen -type A_B_zero\n\n# No_solution test cases\n./gen -type No_solution\n./gen -type No_solution\n./gen -type No_solution\n\n# Negative_A_B test cases\n./gen -type Negative_A_B\n./gen -type Negative_A_B\n\n# n_small test cases\n./gen -type n_small\n./gen -type n_small\n\n# n_large test cases\n./gen -type n_large\n./gen -type n_large\n\n# X_zero test cases\n./gen -type X_zero\n./gen -type X_zero\n\n# Fractional_X test cases\n./gen -type Fractional_X\n./gen -type Fractional_X\n./gen -type Fractional_X\n\n# Specific n test cases\n./gen -n 1 -type random\n./gen -n 2 -type No_solution\n./gen -n 10 -type random\n./gen -n 5 -type Fractional_X\n\n# Mixed test cases\n./gen -n 3 -type Negative_A_B\n./gen -n 7 -type X_zero\n./gen -n 9 -type A_zero\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:04:43.315493",
        "total_tutorials": 3,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "30/B",
      "title": "B. Codeforces World Finals",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains the date DD.MM.YY, the second line contains the date BD.BM.BY. It is guaranteed that both dates are correct, and YY and BY are always in [01;99].It could be that by passport Bob was born after the finals. In this case, he can still change the order of numbers in date.",
      "output_spec": "OutputIf it is possible to rearrange the numbers in the date of birth so that Bob will be at least 18 years old on the DD.MM.YY, output YES. In the other case, output NO. Each number contains exactly two digits and stands for day, month or year in a date. Note that it is permitted to rearrange only numbers, not digits.",
      "sample_tests": "ExamplesInputCopy01.01.9801.01.80OutputCopyYESInputCopy20.10.2010.02.30OutputCopyNOInputCopy28.02.7428.02.64OutputCopyNO",
      "description": "B. Codeforces World Finals\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains the date DD.MM.YY, the second line contains the date BD.BM.BY. It is guaranteed that both dates are correct, and YY and BY are always in [01;99].It could be that by passport Bob was born after the finals. In this case, he can still change the order of numbers in date.\n\nOutputIf it is possible to rearrange the numbers in the date of birth so that Bob will be at least 18 years old on the DD.MM.YY, output YES. In the other case, output NO. Each number contains exactly two digits and stands for day, month or year in a date. Note that it is permitted to rearrange only numbers, not digits.\n\nInputCopy01.01.9801.01.80OutputCopyYESInputCopy20.10.2010.02.30OutputCopyNOInputCopy28.02.7428.02.64OutputCopyNO\n\nInputCopy01.01.9801.01.80\n\nOutputCopyYES\n\nInputCopy20.10.2010.02.30\n\nOutputCopyNO\n\nInputCopy28.02.7428.02.64\n\nOutputCopyNO",
      "solutions": [
        {
          "title": "Codeforces Beta Round #30 (Codeforces format) - Codeforces",
          "content": "Today's contest was prepared by Saratov SU 2 team (Maxim Ivanov, Artem Rakhov, Nickolay Kuznetsov).You will be asked to solve five easy and not so easy problems for some King, whom you hardly heard anything before. The king hopes that the problems won't turn out very difficult to you, and he will have a wide choice among different solutions to each of the problems.UPD. The contest has finished, thanks to all of you.The Results table.Greeting to rng_58 for his win in today's round!Problem tutorials: A, B, C, D, E. Thanks to Mike Mirzayanov and Dmitry Matov who helped to prepare this round too.Problem statements can be downloaded as a single PDF-file:english versionrussian versionP.S. Don't forget to look through Codeforces Format contest rules, if you participate for the first time!",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/692",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 792
        },
        {
          "title": "Codeforces Beta Round #30. Tutorial for problem A - Codeforces",
          "content": "Tutorial for problem \"A. Accounting\"First solution: naive bruteLet's brute all possible values of X, and check each of them. It's easy to understand, that X will be constrained in the same limits as values A and B, that is, from -1000 to 1000 inclusive (obviously, there exists a test for each such X, so we can't decrease these limits).When we have some fixed value of X, we check it simply by multiplying A by X n times. But, you should be careful with possible integer (and even 64-bit integer :) ) overflow. For example, you should stop multiplying by X if the currect result exceeds 1000 by absolute value already.Second solution: formulaIt's easy to note, that if solution exists, then it is n-th root from |B| / |A| fraction, with changed sign if A and B have different signs and if n is odd (if n is even, then no solution exists). That's why we could just use pow() function (or some analog in your language) to calculate 1 / n-th power of the fraction, and after that we just have to check - is the result integer number or not. Of course, we have to check it with taking into account precision errors: that is, number is integer if it is within 10 - 9 (or some another number) from nearest integer.Moreover, in this solution you should be careful with zeroes. The worst case is when A = 0, and this case should be checked manually (you should note the difference between B = 0 and B ≠ 0 cases).It should be told that many of the solutions failed on tests with A = 0, or B = 0, and if these tests were not included in the pretestset, I think, about half of participants would fail to solve this problem :)",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/696",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1615
        },
        {
          "title": "Codeforces Beta Round #30. Tutorial for problem D - Codeforces",
          "content": "Tutorial for problem \"D. Kings Problem?\"In this problem to create a wright solution you need to perform the following chain of inferences (though, if you skip some steps or do them not completely, you can still get an AC solution :) ):Note that after we visit the city numbered n + 1, the further answer depends only from the leftmost and the rightmost unvisited cities (and it would be optimal to come to the nearest to n + 1-th city of them, and the come to another of them). That's why we know the answer for the case k = n + 1, and won't consider this case later.Before we visit the n + 1-th city, - this part of the path covers some segment of cities lying in the OX axis. This segment, obviously, contains the point k. But we can't iterate over all such possible segments, because there are O(n2) of them, so it's still a slow solution.Let's understand the following fact: if before visiting city n + 1 we visited some other cities, but neither the leftmost nor the rightmost, then it was surely unprofitable. Really, after we come into the n + 1, the answer will depend only on the leftmost and the rightmost of non-visited cities. So, if before the n + 1-th city we performed some movements, but didn't change the leftmost and the rightmost cities, then it was completely unnecessary and unprofitable action.We can can get even more: there is no optimal solution, where we should move from the start city k to the n + 1-th city directly, without vithout visiting other cities (here I suppose that k is neither the leftmost nor the rightmost city). Btw, this step of reasoning could be skipped - we can believe it's sometimes profitable to come from k to n + 1 directly, and it's not difficult to support this case in a solution we'll build later; but in order to describe the problem completely let's prove this fact too. In order to prove this, let's write down two formulas: first for the length of the answer if we come from k to n + 1 directly, then come to city 1, and then to city n (here I suppose that 1 and n are the leftmost and the rightmost cities, accordingly, and city 1 is nearer to n + 1 than n); second formula - for the length of the answer if we come from k to 1 first, then to n + 1, then to k + 1, and then to n. If we compare these two formulas, then after the cancellation of like terms we can use the triangle's inequality to see that the second formula always gives smaller value (at least, not greater) than the first. So, it's really unprofitable to come from k to n + 1 directly.So, to make a right solution, it's enough to iterate over only two types of segments: [1;i] for i ≥ k, and [i;n] for i ≤ k (here I suppose for convenience that cities are sorted by their x-coordinate).The last idea is how to process each of these cases accurately. In order to do this we iterate over all possible i = 1... n. Let, for example, i ≤ k. Then we have to try the following case: go from k to n, then return to i, then come to n + 1, and then return back to the OX axis if need (if i > 1). Also it is required to check another type of cases: try to go from k to i, then to n, and then come to n + 1, and return back to the OX axis if need. Answer for each of these cases can be calculated in O(1). For i ≥ k everything is symmetric.So, not taking into account the sorting of the citites in the beginning of the program, we get a O(n)-solution.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/697",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 3369
        }
      ],
      "code_examples": [],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nbool isLeapYear(int year) {\n    return (year % 4 == 0);\n}\n\nvoid validateDate(int dd, int mm, int yy, string dateName) {\n    ensuref(1 <= mm && mm <= 12, \"In %s, month mm=%d is out of range [1,12]\", dateName.c_str(), mm);\n    ensuref(1 <= yy && yy <= 99, \"In %s, year yy=%d is out of range [1,99]\", dateName.c_str(), yy);\n\n    int year = 2000 + yy;\n    int maxDay;\n    if (mm == 2) {\n        maxDay = isLeapYear(year) ? 29 : 28;\n    } else if (mm == 4 || mm == 6 || mm == 9 || mm == 11) {\n        maxDay = 30;\n    } else {\n        maxDay = 31;\n    }\n\n    ensuref(1 <= dd && dd <= maxDay, \"In %s, day dd=%d is out of range [1,%d] for month %d and year %d\", dateName.c_str(), dd, maxDay, mm, year);\n}\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    string date1 = inf.readLine(\"[0-9]{2}\\\\.[0-9]{2}\\\\.[0-9]{2}\", \"Date of finals\");\n    string date2 = inf.readLine(\"[0-9]{2}\\\\.[0-9]{2}\\\\.[0-9]{2}\", \"Bob's date of birth\");\n\n    string dd1_str = date1.substr(0, 2);\n    string mm1_str = date1.substr(3, 2);\n    string yy1_str = date1.substr(6, 2);\n\n    string dd2_str = date2.substr(0, 2);\n    string mm2_str = date2.substr(3, 2);\n    string yy2_str = date2.substr(6, 2);\n\n    int dd1 = stoi(dd1_str);\n    int mm1 = stoi(mm1_str);\n    int yy1 = stoi(yy1_str);\n\n    int dd2 = stoi(dd2_str);\n    int mm2 = stoi(mm2_str);\n    int yy2 = stoi(yy2_str);\n\n    validateDate(dd1, mm1, yy1, \"Date of finals\");\n    validateDate(dd2, mm2, yy2, \"Bob's date of birth\");\n\n    inf.readEof();\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nbool isLeapYear(int year) {\n    return (year % 4 == 0);\n}\n\nvoid validateDate(int dd, int mm, int yy, string dateName) {\n    ensuref(1 <= mm && mm <= 12, \"In %s, month mm=%d is out of range [1,12]\", dateName.c_str(), mm);\n    ensuref(1 <= yy && yy <= 99, \"In %s, year yy=%d is out of range [1,99]\", dateName.c_str(), yy);\n\n    int year = 2000 + yy;\n    int maxDay;\n    if (mm == 2) {\n        maxDay = isLeapYear(year) ? 29 : 28;\n    } else if (mm == 4 || mm == 6 || mm == 9 || mm == 11) {\n        maxDay = 30;\n    } else {\n        maxDay = 31;\n    }\n\n    ensuref(1 <= dd && dd <= maxDay, \"In %s, day dd=%d is out of range [1,%d] for month %d and year %d\", dateName.c_str(), dd, maxDay, mm, year);\n}\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    string date1 = inf.readLine(\"[0-9]{2}\\\\.[0-9]{2}\\\\.[0-9]{2}\", \"Date of finals\");\n    string date2 = inf.readLine(\"[0-9]{2}\\\\.[0-9]{2}\\\\.[0-9]{2}\", \"Bob's date of birth\");\n\n    string dd1_str = date1.substr(0, 2);\n    string mm1_str = date1.substr(3, 2);\n    string yy1_str = date1.substr(6, 2);\n\n    string dd2_str = date2.substr(0, 2);\n    string mm2_str = date2.substr(3, 2);\n    string yy2_str = date2.substr(6, 2);\n\n    int dd1 = stoi(dd1_str);\n    int mm1 = stoi(mm1_str);\n    int yy1 = stoi(yy1_str);\n\n    int dd2 = stoi(dd2_str);\n    int mm2 = stoi(mm2_str);\n    int yy2 = stoi(yy2_str);\n\n    validateDate(dd1, mm1, yy1, \"Date of finals\");\n    validateDate(dd2, mm2, yy2, \"Bob's date of birth\");\n\n    inf.readEof();\n\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nbool isLeapYear(int year) {\n    return (year % 4 == 0);\n}\n\nvoid validateDate(int dd, int mm, int yy, string dateName) {\n    ensuref(1 <= mm && mm <= 12, \"In %s, month mm=%d is out of range [1,12]\", dateName.c_str(), mm);\n    ensuref(1 <= yy && yy <= 99, \"In %s, year yy=%d is out of range [1,99]\", dateName.c_str(), yy);\n\n    int year = 2000 + yy;\n    int maxDay;\n    if (mm == 2) {\n        maxDay = isLeapYear(year) ? 29 : 28;\n    } else if (mm == 4 || mm == 6 || mm == 9 || mm == 11) {\n        maxDay = 30;\n    } else {\n        maxDay = 31;\n    }\n\n    ensuref(1 <= dd && dd <= maxDay, \"In %s, day dd=%d is out of range [1,%d] for month %d and year %d\", dateName.c_str(), dd, maxDay, mm, year);\n}\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    string date1 = inf.readLine(\"[0-9]{2}\\\\.[0-9]{2}\\\\.[0-9]{2}\", \"Date of finals\");\n    string date2 = inf.readLine(\"[0-9]{2}\\\\.[0-9]{2}\\\\.[0-9]{2}\", \"Bob's date of birth\");\n\n    string dd1_str = date1.substr(0, 2);\n    string mm1_str = date1.substr(3, 2);\n    string yy1_str = date1.substr(6, 2);\n\n    string dd2_str = date2.substr(0, 2);\n    string mm2_str = date2.substr(3, 2);\n    string yy2_str = date2.substr(6, 2);\n\n    int dd1 = stoi(dd1_str);\n    int mm1 = stoi(mm1_str);\n    int yy1 = stoi(yy1_str);\n\n    int dd2 = stoi(dd2_str);\n    int mm2 = stoi(mm2_str);\n    int yy2 = stoi(yy2_str);\n\n    validateDate(dd1, mm1, yy1, \"Date of finals\");\n    validateDate(dd2, mm2, yy2, \"Bob's date of birth\");\n\n    inf.readEof();\n\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n#include <string>\r\n\r\nusing namespace std;\r\n\r\nconst string YES = \"YES\";\r\nconst string NO = \"NO\";\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"%s\", (\"multiple \" + YES + \"/\" + NO + \" (case insensitive)\").c_str());\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int index = 0, yesCount = 0, noCount = 0;\r\n    string pa;\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        index++;\r\n        string ja = upperCase(ans.readToken());\r\n        pa = upperCase(ouf.readToken());\r\n\r\n        if (ja != YES && ja != NO)\r\n            quitf(_fail, \"%s or %s expected in answer, but %s found [%d%s token]\",\r\n                  YES.c_str(), NO.c_str(), compress(ja).c_str(), index, englishEnding(index).c_str());\r\n\r\n        if (pa == YES)\r\n            yesCount++;\r\n        else if (pa == NO)\r\n            noCount++;\r\n        else\r\n            quitf(_pe, \"%s or %s expected, but %s found [%d%s token]\",\r\n                  YES.c_str(), NO.c_str(), compress(pa).c_str(), index, englishEnding(index).c_str());\r\n\r\n        if (ja != pa)\r\n            quitf(_wa, \"expected %s, found %s [%d%s token]\",\r\n                  compress(ja).c_str(), compress(pa).c_str(), index, englishEnding(index).c_str());\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n    while (!ans.seekEof()) {\r\n        ans.readToken();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n    while (!ouf.seekEof()) {\r\n        ouf.readToken();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              index + extraInAnsCount, index);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              index + extraInOufCount, index);\r\n\r\n    if (index == 0)\r\n        quitf(_ok, \"Empty output\");\r\n    else if (index == 1)\r\n        quitf(_ok, \"%s\", pa.c_str());\r\n    else\r\n        quitf(_ok, \"%d token(s): yes count is %d, no count is %d\", index, yesCount, noCount);\r\n\r\n    quitf(_fail, \"Impossible case\");\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\n/*\n    This generator produces exactly ONE test (two lines).\n    1) Final date in the format DD.MM.YY\n    2) Birth date in the format DD.MM.YY\n\n    Use the parameter --type (string) to control the style of generation:\n      - random: fully random valid final date in [01..99] year, random valid birth date\n      - borderline: final date random (year >= 19), and the birth date is exactly 18 years earlier (if invalid, adjust day)\n      - leapfinal: final date forced to be 29.02 in a leap year, birth date random\n      - earlyyear: final date forced to 01.01 of some year, birth date random\n      - lateryear: final date forced to 31.12 of some year (if valid), birth date random\n      - near18plus: final date random, birth date chosen near the 18-year boundary\n      - fixedA, fixedB, etc.: produce some “hand-crafted” corner cases\n\n    Feel free to add more custom modes or tweak them to generate additional corner cases.\n*/\n\n/* Checks if a given year (two-digit) is leap by problem statement (divisible by 4). */\nbool isLeap(int yy) {\n    return (yy % 4 == 0);\n}\n\n/* Returns the number of days in month m of year yy (both in [1..99]). */\nint daysInMonth(int m, int yy) {\n    switch(m) {\n        case 2: return isLeap(yy) ? 29 : 28;\n        case 4: case 6: case 9: case 11: return 30;\n        default: return 31;\n    }\n}\n\n/* Checks if the date (d, m, y) is valid under the problem constraints:\n   - 1 <= y <= 99\n   - 1 <= m <= 12\n   - 1 <= d <= daysInMonth(m,y) */\nbool isValidDate(int d, int m, int y) {\n    if (y < 1 || y > 99) return false;\n    if (m < 1 || m > 12) return false;\n    if (d < 1) return false;\n    int dm = daysInMonth(m, y);\n    return (d <= dm);\n}\n\n/* Generates a random valid date in years [1..99]. */\nvoid genRandomDate(int &d, int &m, int &y) {\n    while(true) {\n        y = rnd.next(1, 99);\n        m = rnd.next(1, 12);\n        int dm = daysInMonth(m, y);\n        d = rnd.next(1, dm);\n        if(isValidDate(d,m,y)) {\n            break;\n        }\n    }\n}\n\n/* Safely subtract exactly 18 from the year, adjusting day if needed:\n   Tries to produce a date exactly 18 years earlier, if that date is invalid (e.g. 29.02 in a non-leap year),\n   we decrement the day by 1 until it becomes valid (or we fail, which is unlikely). \n*/\nvoid makeBirthExactly18YearsEarlier(int &bd, int &bm, int &by, int fd, int fm, int fy) {\n    // We assume fy >= 19 for \"borderline\". We'll attempt to set by = fy - 18 exactly.\n    by = fy - 18;\n    bm = fm;\n    bd = fd;\n\n    // If it's invalid because the day is too large for the new month-year, reduce day slightly.\n    while(!isValidDate(bd, bm, by)) {\n        bd--;\n        if(bd < 1) {\n            // If we can't fix it easily, just switch it to something simpler:\n            // e.g. set to 01.01.(fy-18) if that is valid\n            bd = 1;\n            bm = 1;\n            // If that is still not valid, we'll do a fallback to a known valid date\n            if(!isValidDate(bd, bm, by)) {\n                // fallback\n                bd = 15; \n                bm = 6; \n            }\n            break;\n        }\n    }\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    string type = opt<string>(\"type\", \"random\");\n\n    // We'll store final date in fd,fm,fy and birth date in bd,bm,by\n    int fd, fm, fy;\n    int bd, bm, by;\n\n    // Start by generating random final date\n    if (type == \"random\") {\n        genRandomDate(fd, fm, fy);\n        genRandomDate(bd, bm, by);\n    }\n    else if (type == \"borderline\") {\n        // Force final-year >= 19, so there's room for 18-year difference\n        // We'll do it by randomizing year in [19..99], month in [1..12], day in valid range\n        while(true) {\n            fy = rnd.next(19, 99);\n            fm = rnd.next(1, 12);\n            int dm = daysInMonth(fm, fy);\n            fd = rnd.next(1, dm);\n            if(isValidDate(fd,fm,fy)) break;\n        }\n        // Now pick birth date exactly 18 years earlier (adjust if needed)\n        makeBirthExactly18YearsEarlier(bd, bm, by, fd, fm, fy);\n    }\n    else if (type == \"leapfinal\") {\n        // Force final date to be 29.02 in some valid leap year\n        // We'll pick a leap year in [4..96], stepping by 4\n        vector<int> leaps;\n        for(int y=4; y<=96; y+=4) leaps.push_back(y);\n        fy = leaps[rnd.next((int)leaps.size())];  // pick a random leap year\n        fm = 2;\n        fd = 29;\n        // Then random birth date\n        genRandomDate(bd, bm, by);\n    }\n    else if (type == \"earlyyear\") {\n        // Final date at 01.01 of some random year\n        fy = rnd.next(1, 99);\n        fm = 1;\n        fd = 1;\n        genRandomDate(bd, bm, by);\n    }\n    else if (type == \"lateryear\") {\n        // Final date at 31.12 of some year. 31.12 is always valid.\n        fy = rnd.next(1, 99);\n        fm = 12;\n        fd = 31;\n        genRandomDate(bd, bm, by);\n    }\n    else if (type == \"near18plus\") {\n        // We'll pick final date random, then birth date near (18 years earlier) but randomly +/- a few days\n        genRandomDate(fd, fm, fy);\n        // We only handle if final year >= 3 to allow some negative offset. But let's just do a loop.\n        // We'll keep generating final date until fy >= 20 (so that we have a bit of room).\n        while (fy < 20) {\n            genRandomDate(fd, fm, fy);\n        }\n        makeBirthExactly18YearsEarlier(bd, bm, by, fd, fm, fy);\n        // Then tweak birth date by +/- up to 5 days randomly\n        int shift = rnd.next(-5, 5);\n        bd += shift;\n        // Fix if invalid\n        while(!isValidDate(bd, bm, by)) {\n            // revert shift step by step\n            if(shift > 0) shift--;\n            else if(shift < 0) shift++;\n            if(shift == 0) break; // just stop if we can't fix\n            bd = fd - 18*365/365; // not exact, but let's do a simpler fallback\n            bd += shift;\n        }\n        if(!isValidDate(bd,bm,by)) {\n            // fallback random\n            genRandomDate(bd, bm, by);\n        }\n    }\n    // Some fixed corner cases:\n    else if (type == \"fixedA\") {\n        // Final date: 01.01.98 (a leap year if 98%4==2 => not leap)\n        // Birth date: 01.01.80\n        fd = 1; fm = 1; fy = 98;\n        bd = 1; bm = 1; by = 80;\n    }\n    else if (type == \"fixedB\") {\n        // Final date: 20.10.20\n        // Birth date: 10.02.30  (like in sample #2)\n        fd = 20; fm = 10; fy = 20;\n        bd = 10; bm = 2; by = 30;\n    }\n    else if (type == \"fixedC\") {\n        // Final date: 28.02.74\n        // Birth date: 28.02.64\n        fd = 28; fm = 2; fy = 74;\n        bd = 28; bm = 2; by = 64;\n    }\n    else if (type == \"fixedLeap\") {\n        // Final date: 29.02.04 (definitely a leap year)\n        // Birth date: 29.02.00 is not valid in the 20YY range => so let's do 01.03.86 random\n        // Actually, year 00 isn't valid by the problem statement ([01..99]).\n        // We'll do birth date: 28.02.86 for a typically borderline leap scenario\n        fd = 29; fm = 2; fy = 4;\n        bd = 28; bm = 2; by = 86;\n    }\n    else if (type == \"fixedEdge1\") {\n        // 29.02.08 final (leap), birth = 29.02.90? That doesn't exist in the sense of \"the same century\" means 20YY => 2090 is not valid 2-digit year because 90 is valid but it is earlier. So it's 1990 is not the same century. Actually the problem states \"If the final date is 20YY, birth date also has YY in [01..99]\" is fine. So 90 is still in the same century. \n        fd = 29; fm = 2; fy = 8;\n        // We'll do birth date: 29.02.90 => that is valid if 90%4 == 2 => not leap. So 29.02.90 is invalid. We must fix it, let's do 28.02.90\n        bd = 28; bm = 2; by = 90;\n    }\n    else if (type == \"fixedEdge2\") {\n        // 01.03.08 final, birth date = 29.02.90 => invalid. We'll do 28.02.90\n        fd = 1; fm = 3; fy = 8;\n        bd = 28; bm = 2; by = 90;\n    }\n    else {\n        // Default fallback: random\n        genRandomDate(fd, fm, fy);\n        genRandomDate(bd, bm, by);\n    }\n\n    // Make sure our final is valid. If not, fix by randomizing it again.\n    // (Some modes might produce invalid combos if we didn't carefully handle them.)\n    while(!isValidDate(fd,fm,fy)) {\n        genRandomDate(fd, fm, fy);\n    }\n    // Make sure birth is valid. If not, fix by randomizing it again.\n    while(!isValidDate(bd,bm,by)) {\n        genRandomDate(bd, bm, by);\n    }\n\n    // Output in the required format: DD.MM.YY\n    printf(\"%02d.%02d.%02d\\n\", fd, fm, fy);\n    printf(\"%02d.%02d.%02d\\n\", bd, bm, by);\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\n/*\n    This generator produces exactly ONE test (two lines).\n    1) Final date in the format DD.MM.YY\n    2) Birth date in the format DD.MM.YY\n\n    Use the parameter --type (string) to control the style of generation:\n      - random: fully random valid final date in [01..99] year, random valid birth date\n      - borderline: final date random (year >= 19), and the birth date is exactly 18 years earlier (if invalid, adjust day)\n      - leapfinal: final date forced to be 29.02 in a leap year, birth date random\n      - earlyyear: final date forced to 01.01 of some year, birth date random\n      - lateryear: final date forced to 31.12 of some year (if valid), birth date random\n      - near18plus: final date random, birth date chosen near the 18-year boundary\n      - fixedA, fixedB, etc.: produce some “hand-crafted” corner cases\n\n    Feel free to add more custom modes or tweak them to generate additional corner cases.\n*/\n\n/* Checks if a given year (two-digit) is leap by problem statement (divisible by 4). */\nbool isLeap(int yy) {\n    return (yy % 4 == 0);\n}\n\n/* Returns the number of days in month m of year yy (both in [1..99]). */\nint daysInMonth(int m, int yy) {\n    switch(m) {\n        case 2: return isLeap(yy) ? 29 : 28;\n        case 4: case 6: case 9: case 11: return 30;\n        default: return 31;\n    }\n}\n\n/* Checks if the date (d, m, y) is valid under the problem constraints:\n   - 1 <= y <= 99\n   - 1 <= m <= 12\n   - 1 <= d <= daysInMonth(m,y) */\nbool isValidDate(int d, int m, int y) {\n    if (y < 1 || y > 99) return false;\n    if (m < 1 || m > 12) return false;\n    if (d < 1) return false;\n    int dm = daysInMonth(m, y);\n    return (d <= dm);\n}\n\n/* Generates a random valid date in years [1..99]. */\nvoid genRandomDate(int &d, int &m, int &y) {\n    while(true) {\n        y = rnd.next(1, 99);\n        m = rnd.next(1, 12);\n        int dm = daysInMonth(m, y);\n        d = rnd.next(1, dm);\n        if(isValidDate(d,m,y)) {\n            break;\n        }\n    }\n}\n\n/* Safely subtract exactly 18 from the year, adjusting day if needed:\n   Tries to produce a date exactly 18 years earlier, if that date is invalid (e.g. 29.02 in a non-leap year),\n   we decrement the day by 1 until it becomes valid (or we fail, which is unlikely). \n*/\nvoid makeBirthExactly18YearsEarlier(int &bd, int &bm, int &by, int fd, int fm, int fy) {\n    // We assume fy >= 19 for \"borderline\". We'll attempt to set by = fy - 18 exactly.\n    by = fy - 18;\n    bm = fm;\n    bd = fd;\n\n    // If it's invalid because the day is too large for the new month-year, reduce day slightly.\n    while(!isValidDate(bd, bm, by)) {\n        bd--;\n        if(bd < 1) {\n            // If we can't fix it easily, just switch it to something simpler:\n            // e.g. set to 01.01.(fy-18) if that is valid\n            bd = 1;\n            bm = 1;\n            // If that is still not valid, we'll do a fallback to a known valid date\n            if(!isValidDate(bd, bm, by)) {\n                // fallback\n                bd = 15; \n                bm = 6; \n            }\n            break;\n        }\n    }\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    string type = opt<string>(\"type\", \"random\");\n\n    // We'll store final date in fd,fm,fy and birth date in bd,bm,by\n    int fd, fm, fy;\n    int bd, bm, by;\n\n    // Start by generating random final date\n    if (type == \"random\") {\n        genRandomDate(fd, fm, fy);\n        genRandomDate(bd, bm, by);\n    }\n    else if (type == \"borderline\") {\n        // Force final-year >= 19, so there's room for 18-year difference\n        // We'll do it by randomizing year in [19..99], month in [1..12], day in valid range\n        while(true) {\n            fy = rnd.next(19, 99);\n            fm = rnd.next(1, 12);\n            int dm = daysInMonth(fm, fy);\n            fd = rnd.next(1, dm);\n            if(isValidDate(fd,fm,fy)) break;\n        }\n        // Now pick birth date exactly 18 years earlier (adjust if needed)\n        makeBirthExactly18YearsEarlier(bd, bm, by, fd, fm, fy);\n    }\n    else if (type == \"leapfinal\") {\n        // Force final date to be 29.02 in some valid leap year\n        // We'll pick a leap year in [4..96], stepping by 4\n        vector<int> leaps;\n        for(int y=4; y<=96; y+=4) leaps.push_back(y);\n        fy = leaps[rnd.next((int)leaps.size())];  // pick a random leap year\n        fm = 2;\n        fd = 29;\n        // Then random birth date\n        genRandomDate(bd, bm, by);\n    }\n    else if (type == \"earlyyear\") {\n        // Final date at 01.01 of some random year\n        fy = rnd.next(1, 99);\n        fm = 1;\n        fd = 1;\n        genRandomDate(bd, bm, by);\n    }\n    else if (type == \"lateryear\") {\n        // Final date at 31.12 of some year. 31.12 is always valid.\n        fy = rnd.next(1, 99);\n        fm = 12;\n        fd = 31;\n        genRandomDate(bd, bm, by);\n    }\n    else if (type == \"near18plus\") {\n        // We'll pick final date random, then birth date near (18 years earlier) but randomly +/- a few days\n        genRandomDate(fd, fm, fy);\n        // We only handle if final year >= 3 to allow some negative offset. But let's just do a loop.\n        // We'll keep generating final date until fy >= 20 (so that we have a bit of room).\n        while (fy < 20) {\n            genRandomDate(fd, fm, fy);\n        }\n        makeBirthExactly18YearsEarlier(bd, bm, by, fd, fm, fy);\n        // Then tweak birth date by +/- up to 5 days randomly\n        int shift = rnd.next(-5, 5);\n        bd += shift;\n        // Fix if invalid\n        while(!isValidDate(bd, bm, by)) {\n            // revert shift step by step\n            if(shift > 0) shift--;\n            else if(shift < 0) shift++;\n            if(shift == 0) break; // just stop if we can't fix\n            bd = fd - 18*365/365; // not exact, but let's do a simpler fallback\n            bd += shift;\n        }\n        if(!isValidDate(bd,bm,by)) {\n            // fallback random\n            genRandomDate(bd, bm, by);\n        }\n    }\n    // Some fixed corner cases:\n    else if (type == \"fixedA\") {\n        // Final date: 01.01.98 (a leap year if 98%4==2 => not leap)\n        // Birth date: 01.01.80\n        fd = 1; fm = 1; fy = 98;\n        bd = 1; bm = 1; by = 80;\n    }\n    else if (type == \"fixedB\") {\n        // Final date: 20.10.20\n        // Birth date: 10.02.30  (like in sample #2)\n        fd = 20; fm = 10; fy = 20;\n        bd = 10; bm = 2; by = 30;\n    }\n    else if (type == \"fixedC\") {\n        // Final date: 28.02.74\n        // Birth date: 28.02.64\n        fd = 28; fm = 2; fy = 74;\n        bd = 28; bm = 2; by = 64;\n    }\n    else if (type == \"fixedLeap\") {\n        // Final date: 29.02.04 (definitely a leap year)\n        // Birth date: 29.02.00 is not valid in the 20YY range => so let's do 01.03.86 random\n        // Actually, year 00 isn't valid by the problem statement ([01..99]).\n        // We'll do birth date: 28.02.86 for a typically borderline leap scenario\n        fd = 29; fm = 2; fy = 4;\n        bd = 28; bm = 2; by = 86;\n    }\n    else if (type == \"fixedEdge1\") {\n        // 29.02.08 final (leap), birth = 29.02.90? That doesn't exist in the sense of \"the same century\" means 20YY => 2090 is not valid 2-digit year because 90 is valid but it is earlier. So it's 1990 is not the same century. Actually the problem states \"If the final date is 20YY, birth date also has YY in [01..99]\" is fine. So 90 is still in the same century. \n        fd = 29; fm = 2; fy = 8;\n        // We'll do birth date: 29.02.90 => that is valid if 90%4 == 2 => not leap. So 29.02.90 is invalid. We must fix it, let's do 28.02.90\n        bd = 28; bm = 2; by = 90;\n    }\n    else if (type == \"fixedEdge2\") {\n        // 01.03.08 final, birth date = 29.02.90 => invalid. We'll do 28.02.90\n        fd = 1; fm = 3; fy = 8;\n        bd = 28; bm = 2; by = 90;\n    }\n    else {\n        // Default fallback: random\n        genRandomDate(fd, fm, fy);\n        genRandomDate(bd, bm, by);\n    }\n\n    // Make sure our final is valid. If not, fix by randomizing it again.\n    // (Some modes might produce invalid combos if we didn't carefully handle them.)\n    while(!isValidDate(fd,fm,fy)) {\n        genRandomDate(fd, fm, fy);\n    }\n    // Make sure birth is valid. If not, fix by randomizing it again.\n    while(!isValidDate(bd,bm,by)) {\n        genRandomDate(bd, bm, by);\n    }\n\n    // Output in the required format: DD.MM.YY\n    printf(\"%02d.%02d.%02d\\n\", fd, fm, fy);\n    printf(\"%02d.%02d.%02d\\n\", bd, bm, by);\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen --type random\n./gen --type random\n./gen --type borderline\n./gen --type borderline\n./gen --type leapfinal\n./gen --type earlyyear\n./gen --type lateryear\n./gen --type near18plus\n./gen --type near18plus\n./gen --type fixedA\n./gen --type fixedB\n./gen --type fixedC\n./gen --type fixedLeap\n./gen --type fixedEdge1\n./gen --type fixedEdge2\n./gen --type random\n./gen --type borderline\n./gen --type leapfinal\n./gen --type near18plus\n./gen --type lateryear\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:04:45.084446",
        "total_tutorials": 3,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "30/C",
      "title": "C. Тир",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест2 seconds",
      "memory_limit": "ограничение по памяти на тест256 megabytes",
      "input_spec": "Входные данныеВ первой строке задано число n — число мишеней в тире (1 ≤ n ≤ 1000). Далее в следующих строках описаны n мишеней: в i-ой строке идёт описание i-ой мишени. Каждое описание представляет собой четвёрку чисел xi, yi, ti, pi (где xi, yi, ti — целые,  - 1000 ≤ xi, yi ≤ 1000, 0 ≤ ti ≤ 109, а вещественное число pi задано не более чем с 6 знаками после десятичной точки, и выполняется 0 ≤ pi ≤ 1). Никакие две различные мишени не могут находиться в одной и той же точке.",
      "output_spec": "Выходные данныеВыведите единственное число — максимальное математическое ожидание количества попаданий в мишени. Ответ будет принят, если он отличается от правильного не более чем на 10 - 6.",
      "sample_tests": "ПримерыВходные данныеСкопировать10 0 0 0.5Выходные данныеСкопировать0.5000000000Входные данныеСкопировать20 0 0 0.65 0 5 0.7Выходные данныеСкопировать1.3000000000",
      "description": "ограничение по времени на тест2 seconds\n\nограничение по времени на тест\n\nограничение по памяти на тест256 megabytes\n\nограничение по памяти на тест\n\nвыводstdout\n\nВходные данныеВ первой строке задано число n — число мишеней в тире (1 ≤ n ≤ 1000). Далее в следующих строках описаны n мишеней: в i-ой строке идёт описание i-ой мишени. Каждое описание представляет собой четвёрку чисел xi, yi, ti, pi (где xi, yi, ti — целые,  - 1000 ≤ xi, yi ≤ 1000, 0 ≤ ti ≤ 109, а вещественное число pi задано не более чем с 6 знаками после десятичной точки, и выполняется 0 ≤ pi ≤ 1). Никакие две различные мишени не могут находиться в одной и той же точке.\n\nВходные данные\n\nВыходные данныеВыведите единственное число — максимальное математическое ожидание количества попаданий в мишени. Ответ будет принят, если он отличается от правильного не более чем на 10 - 6.\n\nВыходные данные\n\nВходные данныеСкопировать10 0 0 0.5Выходные данныеСкопировать0.5000000000Входные данныеСкопировать20 0 0 0.65 0 5 0.7Выходные данныеСкопировать1.3000000000\n\nВходные данныеСкопировать10 0 0 0.5\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать0.5000000000\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать20 0 0 0.65 0 5 0.7\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать1.3000000000\n\nВыходные данныеСкопировать\n\nСкопировать",
      "solutions": [
        {
          "title": "Codeforces Beta Round #30 (Codeforces format) - Codeforces",
          "content": "Сегодняшний контест подготовлен нами, командой Saratov SU 2 (Максим Иванов, Артем Рахов, Коля Кузнецов).От Вас потребуется решить пять простых и не очень задачек для одного Царя, про которого вы вряд ли что-нибудь слышали раньше. Царь надеется, что задачи окажутся не очень сложными для Вас, и у него будет богатый выбор среди различных решений по каждой задаче.UPD. Контест окончен, всем спасибо.Таблица результатов.Поздравляем rng_58 с победой!Разборы задач: A, B, C, D, E. Контест помогали готовить Михаил Мирзаянов и Дмитрий Матов.Условия задач можно скачать одним PDF-файлом:русская версияанглийская версияP.S. Не забудьте ознакомиться с правилами контеста Codeforces Format, если вы участвуете впервые!",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/692",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 708
        },
        {
          "title": "Codeforces Beta Round #30. Разбор A - Codeforces",
          "content": "Разбор задачи \"A. Бухгалтерский учёт\"Первый способ решения: переборПереберём все возможные X, и проверим каждое, подходит ли оно под указанные A и B. Понятно, что имеет смысл перебирать только в тех же пределах, которыми ограничены сами A и B, т.е. от -1000 до 1000 (легко понять, что сузить эти рамки никак нельзя - для любого числа от -1000 до 1000 найдётся соответствующий тест). При фиксированном X проверять ответ надо было, n раз производя умножения, но аккуратно следя за тем, чтобы переменная не переполнилась (на что многие попадали), например, прекращая умножать, если текущее произведение уже вылезло за пределы [ - 1000;1000].Второй способ решения: формулаЛегко заметить, что если ответ есть, то это корень n-ой степени из отношения |B| и |A|, возможно, с изменённым знаком, - если A и B имеют разный знак, и n нечётно (если n чётно, то в этом случае, очевидно, ответа не будет). Поэтому можно было просто воспользоваться функцией возведения числа в степень (возводить надо было в 1 / n-ю степень), которая есть во многих языках, и проверить, что получилось целое число (разумеется, с учётом точности, - например, что оно отличается от ближайшего целого не более чем на 10 - 9).Но здесь надо быть аккуратным со всякими нулями. Плохо, когда A = 0, и этот случай надо разобрать отдельно (B = 0 или B ≠ 0).Вообще очень многие ошибались на тесте с A = 0 или B = 0, и если бы такие тесты не содержались в претестах, то, наверное, у половины людей задача бы упала :)",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/696",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 1472
        },
        {
          "title": "Codeforces Beta Round #30. Разбор D - Codeforces",
          "content": "Разбор задачи \"D. Задача Царя?\"В этой задаче для правильного решения требуется следующая цепочка рассуждений (хотя, если некоторые шаги опустить или осуществить не полностью, всё равно получатся правильные решения :) ):Заметим, что после того, как мы пришли в город n + 1, дальнейший ответ зависит только от самого левого и самого правого из непосещённых городов (и ответом на задачу будет - пойти в ближайший к n+1-ому городу из них, а потом пойти в другой город). Отсюда сразу получаем решение для случая k = n + 1, и этот случай мы дальше не рассматриваем.Часть пути до города n + 1 - она покрывает какой-то отрезок городов на оси OX. Причём этот отрезок обязательно содержит точку k. Но таких отрезков может быть O(n2), поэтому пока это плохое решение.Можно понять, что если человек до перехода в город n + 1 как-то походил, но не посетил самый левый на оси город или самый правый, то тогда он совершил бессмысленное и невыгодное действие. В самом деле, ведь после прихода в точку n + 1 ответ будет однозначно определяться позициям самого левого и самого правого из непосещённых городов, а таким странным действием человек не изменит ни левую, ни правую границу, т.е. только ухудшит их.Остался случай, когда человек из города k пошёл в город n + 1 напрямик, и только потом спустился вниз. Во-первых, можно было просто вставить этот переход в программу, и больше не думать над ним :) Во-вторых, можно было всё же догадаться и доказать, что этот переход невыгоден. Для этого надо просто расписать два варианта пути: из k в n + 1, потом обратно в 1, потом в n (я считаю, что город 1 ближе к n + 1, чем n, и что k не совпадает ни с 1, ни с n), и второй вариант: из k в 1, потом в n + 1, потом в k + 1, потом в n. Выписыв явно эти две формулы, сократив одинаковые слагаемые, можно получить, что по неравенству треугольников второй вариант всегда лучше (не хуже).Таким образом, достаточно перебирать только два вида отрезков: [1;i] для i ≥ k, и [i;n] для i ≤ k (я считаю для удобства, что города отсортированы по абсциссе).Осталось аккуратно обработать каждый такой переход. Для этого перебираем все возможные i. Пусть, например, i ≤ k. Тогда надо попробовать такой переход: пойти из k в n, потом обратно в i, потом в n + 1, и потом обойти оставшуюся часть [1;i - 1]. Также обязательно надо попробовать второй переход: из k в i, потом в n, потом в n + 1, потом обойти оставшуюся часть [1;i - 1]. При i ≥ k - всё симметрично, получатся два других перехода.Итого, не считая сортировки в начале программы (без которой, наверное, можно обойтись), получается решение за O(n).",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/697",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 2568
        }
      ],
      "code_examples": [],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 1000, \"n\");\n    inf.readEoln();\n\n    set<pair<int, int>> points;\n\n    for (int i = 0; i < n; i++) {\n        int xi = inf.readInt(-1000, 1000, \"xi\");\n        inf.readSpace();\n        int yi = inf.readInt(-1000, 1000, \"yi\");\n        inf.readSpace();\n        int ti = inf.readInt(0, 1000000000, \"ti\");\n        inf.readSpace();\n\n        string pi_str = inf.readToken(\"(?:0(?:\\\\.[0-9]{1,6})?|1(?:\\\\.0{1,6})?)\", \"pi\");\n        inf.readEoln();\n\n        // Check that xi and yi form a unique point\n        ensuref(points.count(make_pair(xi, yi)) == 0, \"No two targets may be at the same point\");\n        points.insert(make_pair(xi, yi));\n\n        // Parse pi_str to double and ensure it is between 0 and 1 inclusive\n        double pi = stod(pi_str);\n        ensuref(pi >= 0.0 && pi <= 1.0, \"pi must be between 0 and 1 inclusive\");\n\n        // Ensure that pi_str has no more than 6 digits after decimal point\n        size_t dot_pos = pi_str.find('.');\n        if (dot_pos != string::npos) {\n            size_t decimal_digits = pi_str.size() - dot_pos - 1;\n            ensuref(decimal_digits <= 6, \"pi must have no more than 6 digits after decimal point\");\n        }\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 1000, \"n\");\n    inf.readEoln();\n\n    set<pair<int, int>> points;\n\n    for (int i = 0; i < n; i++) {\n        int xi = inf.readInt(-1000, 1000, \"xi\");\n        inf.readSpace();\n        int yi = inf.readInt(-1000, 1000, \"yi\");\n        inf.readSpace();\n        int ti = inf.readInt(0, 1000000000, \"ti\");\n        inf.readSpace();\n\n        string pi_str = inf.readToken(\"(?:0(?:\\\\.[0-9]{1,6})?|1(?:\\\\.0{1,6})?)\", \"pi\");\n        inf.readEoln();\n\n        // Check that xi and yi form a unique point\n        ensuref(points.count(make_pair(xi, yi)) == 0, \"No two targets may be at the same point\");\n        points.insert(make_pair(xi, yi));\n\n        // Parse pi_str to double and ensure it is between 0 and 1 inclusive\n        double pi = stod(pi_str);\n        ensuref(pi >= 0.0 && pi <= 1.0, \"pi must be between 0 and 1 inclusive\");\n\n        // Ensure that pi_str has no more than 6 digits after decimal point\n        size_t dot_pos = pi_str.find('.');\n        if (dot_pos != string::npos) {\n            size_t decimal_digits = pi_str.size() - dot_pos - 1;\n            ensuref(decimal_digits <= 6, \"pi must have no more than 6 digits after decimal point\");\n        }\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 1000, \"n\");\n    inf.readEoln();\n\n    set<pair<int, int>> points;\n\n    for (int i = 0; i < n; i++) {\n        int xi = inf.readInt(-1000, 1000, \"xi\");\n        inf.readSpace();\n        int yi = inf.readInt(-1000, 1000, \"yi\");\n        inf.readSpace();\n        int ti = inf.readInt(0, 1000000000, \"ti\");\n        inf.readSpace();\n\n        string pi_str = inf.readToken(\"(?:0(?:\\\\.[0-9]{1,6})?|1(?:\\\\.0{1,6})?)\", \"pi\");\n        inf.readEoln();\n\n        // Check that xi and yi form a unique point\n        ensuref(points.count(make_pair(xi, yi)) == 0, \"No two targets may be at the same point\");\n        points.insert(make_pair(xi, yi));\n\n        // Parse pi_str to double and ensure it is between 0 and 1 inclusive\n        double pi = stod(pi_str);\n        ensuref(pi >= 0.0 && pi <= 1.0, \"pi must be between 0 and 1 inclusive\");\n\n        // Ensure that pi_str has no more than 6 digits after decimal point\n        size_t dot_pos = pi_str.find('.');\n        if (dot_pos != string::npos) {\n            size_t decimal_digits = pi_str.size() - dot_pos - 1;\n            ensuref(decimal_digits <= 6, \"pi must have no more than 6 digits after decimal point\");\n        }\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nconst double EPS = 1E-6;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare two sequences of doubles, max absolute or relative  error = %.7f\", EPS);\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    double j = 0, p = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        n++;\r\n        j = ans.readDouble();\r\n        p = ouf.readDouble();\r\n        if (!doubleCompare(j, p, EPS)) {\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%.7f', found: '%.7f', error = '%.7f'\",\r\n                  n, englishEnding(n).c_str(), j, p, doubleDelta(j, p));\r\n        }\r\n    }\r\n\r\n    if (n == 1)\r\n        quitf(_ok, \"found '%.7f', expected '%.7f', error '%.7f'\", p, j, doubleDelta(j, p));\r\n\r\n    quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> xi(n), yi(n);\n    vector<int> ti(n);\n    vector<double> pi(n);\n\n    if (type == \"random\") {\n        // Generate completely random data within constraints.\n        set<pair<int,int>> positions;\n\n        for(int i = 0; i < n; ++i) {\n            // xi, yi between -1000 and 1000\n            int x, y;\n            do {\n                x = rnd.next(-1000, 1000);\n                y = rnd.next(-1000, 1000);\n            } while (positions.count({x, y}));\n            positions.insert({x, y});\n            xi[i] = x;\n            yi[i] = y;\n\n            // ti between 0 and 1e9\n            ti[i] = rnd.next(0, 1000000000);\n\n            // pi between 0 and 1 with up to 6 decimal digits\n            double p = rnd.next(0.0, 1.0);\n            p = floor(p * 1e6 + 0.5) / 1e6;\n            pi[i] = p;\n        }\n    }\n    else if (type == \"same_time\") {\n        // All targets appear at the same time\n        set<pair<int,int>> positions;\n\n        int t = rnd.next(0, 1000000000);\n        for (int i = 0; i < n; ++i) {\n            int x, y;\n            do {\n                x = rnd.next(-1000, 1000);\n                y = rnd.next(-1000, 1000);\n            } while (positions.count({x, y}));\n            positions.insert({x, y});\n\n            xi[i] = x;\n            yi[i] = y;\n            ti[i] = t;\n\n            double p = rnd.next(0.0, 1.0);\n            p = floor(p * 1e6 + 0.5) / 1e6;\n            pi[i] = p;\n        }\n    }\n    else if (type == \"high_pi\") {\n        // All pi close to 1\n        set<pair<int,int>> positions;\n\n        for (int i = 0; i < n; ++i) {\n            int x, y;\n            do {\n                x = rnd.next(-1000, 1000);\n                y = rnd.next(-1000, 1000);\n            } while (positions.count({x, y}));\n            positions.insert({x, y});\n\n            xi[i] = x;\n            yi[i] = y;\n            ti[i] = rnd.next(0, 1000000000);\n\n            double p = rnd.next(0.9, 1.0);\n            p = floor(p * 1e6 + 0.5) / 1e6;\n            pi[i] = p;\n        }\n    }\n    else if (type == \"low_pi\") {\n        // All pi close to 0\n        set<pair<int,int>> positions;\n\n        for (int i = 0; i < n; ++i) {\n            int x, y;\n            do {\n                x = rnd.next(-1000, 1000);\n                y = rnd.next(-1000, 1000);\n            } while (positions.count({x, y}));\n            positions.insert({x, y});\n\n            xi[i] = x;\n            yi[i] = y;\n            ti[i] = rnd.next(0, 1000000000);\n\n            double p = rnd.next(0.0, 0.1);\n            p = floor(p * 1e6 + 0.5) / 1e6;\n            pi[i] = p;\n        }\n    }\n    else if (type == \"pi_zero\") {\n        // All pi = 0\n        set<pair<int,int>> positions;\n\n        for (int i = 0; i < n; ++i) {\n            int x, y;\n            do {\n                x = rnd.next(-1000, 1000);\n                y = rnd.next(-1000, 1000);\n            } while (positions.count({x, y}));\n            positions.insert({x, y});\n\n            xi[i] = x;\n            yi[i] = y;\n            ti[i] = rnd.next(0, 1000000000);\n\n            pi[i] = 0.0;\n        }\n    }\n    else if (type == \"pi_one\") {\n        // All pi = 1\n        set<pair<int,int>> positions;\n\n        for (int i = 0; i < n; ++i) {\n            int x, y;\n            do {\n                x = rnd.next(-1000, 1000);\n                y = rnd.next(-1000, 1000);\n            } while (positions.count({x, y}));\n            positions.insert({x, y});\n\n            xi[i] = x;\n            yi[i] = y;\n            ti[i] = rnd.next(0, 1000000000);\n\n            pi[i] = 1.0;\n        }\n    }\n    else if (type == \"large_time_gaps\") {\n        // ti spread out\n        set<pair<int,int>> positions;\n\n        int time_interval = 1000000000 / n;\n        int t = 0;\n        for (int i = 0; i < n; ++i) {\n            int x, y;\n            do {\n                x = rnd.next(-1000, 1000);\n                y = rnd.next(-1000, 1000);\n            } while (positions.count({x, y}));\n            positions.insert({x, y});\n\n            xi[i] = x;\n            yi[i] = y;\n\n            ti[i] = t;\n            t += time_interval;\n\n            double p = rnd.next(0.0, 1.0);\n            p = floor(p * 1e6 + 0.5) / 1e6;\n            pi[i] = p;\n        }\n    }\n    else if (type == \"short_time_intervals\") {\n        // ti very close together\n        set<pair<int,int>> positions;\n\n        int t_start = rnd.next(0, 1000000000 - n);\n        int time_step = 1; // ti incremented by 1\n        for (int i = 0; i < n; ++i) {\n            int x, y;\n            do {\n                x = rnd.next(-1000, 1000);\n                y = rnd.next(-1000, 1000);\n            } while (positions.count({x, y}));\n            positions.insert({x, y});\n\n            xi[i] = x;\n            yi[i] = y;\n\n            ti[i] = t_start + i * time_step;\n\n            double p = rnd.next(0.0, 1.0);\n            p = floor(p * 1e6 + 0.5) / 1e6;\n            pi[i] = p;\n        }\n    }\n    else {\n        // Default to random\n        set<pair<int,int>> positions;\n\n        for(int i = 0; i < n; ++i) {\n            int x, y;\n            do {\n                x = rnd.next(-1000, 1000);\n                y = rnd.next(-1000, 1000);\n            } while (positions.count({x, y}));\n            positions.insert({x, y});\n            xi[i] = x;\n            yi[i] = y;\n\n            ti[i] = rnd.next(0, 1000000000);\n\n            double p = rnd.next(0.0, 1.0);\n            p = floor(p * 1e6 + 0.5) / 1e6;\n            pi[i] = p;\n        }\n    }\n\n    // Output n\n    printf(\"%d\\n\", n);\n\n    // Output the targets\n    for(int i = 0; i < n; ++i) {\n        printf(\"%d %d %d %.6f\\n\", xi[i], yi[i], ti[i], pi[i]);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> xi(n), yi(n);\n    vector<int> ti(n);\n    vector<double> pi(n);\n\n    if (type == \"random\") {\n        // Generate completely random data within constraints.\n        set<pair<int,int>> positions;\n\n        for(int i = 0; i < n; ++i) {\n            // xi, yi between -1000 and 1000\n            int x, y;\n            do {\n                x = rnd.next(-1000, 1000);\n                y = rnd.next(-1000, 1000);\n            } while (positions.count({x, y}));\n            positions.insert({x, y});\n            xi[i] = x;\n            yi[i] = y;\n\n            // ti between 0 and 1e9\n            ti[i] = rnd.next(0, 1000000000);\n\n            // pi between 0 and 1 with up to 6 decimal digits\n            double p = rnd.next(0.0, 1.0);\n            p = floor(p * 1e6 + 0.5) / 1e6;\n            pi[i] = p;\n        }\n    }\n    else if (type == \"same_time\") {\n        // All targets appear at the same time\n        set<pair<int,int>> positions;\n\n        int t = rnd.next(0, 1000000000);\n        for (int i = 0; i < n; ++i) {\n            int x, y;\n            do {\n                x = rnd.next(-1000, 1000);\n                y = rnd.next(-1000, 1000);\n            } while (positions.count({x, y}));\n            positions.insert({x, y});\n\n            xi[i] = x;\n            yi[i] = y;\n            ti[i] = t;\n\n            double p = rnd.next(0.0, 1.0);\n            p = floor(p * 1e6 + 0.5) / 1e6;\n            pi[i] = p;\n        }\n    }\n    else if (type == \"high_pi\") {\n        // All pi close to 1\n        set<pair<int,int>> positions;\n\n        for (int i = 0; i < n; ++i) {\n            int x, y;\n            do {\n                x = rnd.next(-1000, 1000);\n                y = rnd.next(-1000, 1000);\n            } while (positions.count({x, y}));\n            positions.insert({x, y});\n\n            xi[i] = x;\n            yi[i] = y;\n            ti[i] = rnd.next(0, 1000000000);\n\n            double p = rnd.next(0.9, 1.0);\n            p = floor(p * 1e6 + 0.5) / 1e6;\n            pi[i] = p;\n        }\n    }\n    else if (type == \"low_pi\") {\n        // All pi close to 0\n        set<pair<int,int>> positions;\n\n        for (int i = 0; i < n; ++i) {\n            int x, y;\n            do {\n                x = rnd.next(-1000, 1000);\n                y = rnd.next(-1000, 1000);\n            } while (positions.count({x, y}));\n            positions.insert({x, y});\n\n            xi[i] = x;\n            yi[i] = y;\n            ti[i] = rnd.next(0, 1000000000);\n\n            double p = rnd.next(0.0, 0.1);\n            p = floor(p * 1e6 + 0.5) / 1e6;\n            pi[i] = p;\n        }\n    }\n    else if (type == \"pi_zero\") {\n        // All pi = 0\n        set<pair<int,int>> positions;\n\n        for (int i = 0; i < n; ++i) {\n            int x, y;\n            do {\n                x = rnd.next(-1000, 1000);\n                y = rnd.next(-1000, 1000);\n            } while (positions.count({x, y}));\n            positions.insert({x, y});\n\n            xi[i] = x;\n            yi[i] = y;\n            ti[i] = rnd.next(0, 1000000000);\n\n            pi[i] = 0.0;\n        }\n    }\n    else if (type == \"pi_one\") {\n        // All pi = 1\n        set<pair<int,int>> positions;\n\n        for (int i = 0; i < n; ++i) {\n            int x, y;\n            do {\n                x = rnd.next(-1000, 1000);\n                y = rnd.next(-1000, 1000);\n            } while (positions.count({x, y}));\n            positions.insert({x, y});\n\n            xi[i] = x;\n            yi[i] = y;\n            ti[i] = rnd.next(0, 1000000000);\n\n            pi[i] = 1.0;\n        }\n    }\n    else if (type == \"large_time_gaps\") {\n        // ti spread out\n        set<pair<int,int>> positions;\n\n        int time_interval = 1000000000 / n;\n        int t = 0;\n        for (int i = 0; i < n; ++i) {\n            int x, y;\n            do {\n                x = rnd.next(-1000, 1000);\n                y = rnd.next(-1000, 1000);\n            } while (positions.count({x, y}));\n            positions.insert({x, y});\n\n            xi[i] = x;\n            yi[i] = y;\n\n            ti[i] = t;\n            t += time_interval;\n\n            double p = rnd.next(0.0, 1.0);\n            p = floor(p * 1e6 + 0.5) / 1e6;\n            pi[i] = p;\n        }\n    }\n    else if (type == \"short_time_intervals\") {\n        // ti very close together\n        set<pair<int,int>> positions;\n\n        int t_start = rnd.next(0, 1000000000 - n);\n        int time_step = 1; // ti incremented by 1\n        for (int i = 0; i < n; ++i) {\n            int x, y;\n            do {\n                x = rnd.next(-1000, 1000);\n                y = rnd.next(-1000, 1000);\n            } while (positions.count({x, y}));\n            positions.insert({x, y});\n\n            xi[i] = x;\n            yi[i] = y;\n\n            ti[i] = t_start + i * time_step;\n\n            double p = rnd.next(0.0, 1.0);\n            p = floor(p * 1e6 + 0.5) / 1e6;\n            pi[i] = p;\n        }\n    }\n    else {\n        // Default to random\n        set<pair<int,int>> positions;\n\n        for(int i = 0; i < n; ++i) {\n            int x, y;\n            do {\n                x = rnd.next(-1000, 1000);\n                y = rnd.next(-1000, 1000);\n            } while (positions.count({x, y}));\n            positions.insert({x, y});\n            xi[i] = x;\n            yi[i] = y;\n\n            ti[i] = rnd.next(0, 1000000000);\n\n            double p = rnd.next(0.0, 1.0);\n            p = floor(p * 1e6 + 0.5) / 1e6;\n            pi[i] = p;\n        }\n    }\n\n    // Output n\n    printf(\"%d\\n\", n);\n\n    // Output the targets\n    for(int i = 0; i < n; ++i) {\n        printf(\"%d %d %d %.6f\\n\", xi[i], yi[i], ti[i], pi[i]);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -type random\n./gen -n 1 -type pi_zero\n./gen -n 1 -type pi_one\n./gen -n 10 -type random\n./gen -n 10 -type same_time\n./gen -n 10 -type high_pi\n./gen -n 10 -type low_pi\n./gen -n 10 -type large_time_gaps\n./gen -n 10 -type short_time_intervals\n./gen -n 100 -type random\n./gen -n 100 -type same_time\n./gen -n 100 -type high_pi\n./gen -n 100 -type pi_zero\n./gen -n 100 -type pi_one\n./gen -n 100 -type large_time_gaps\n./gen -n 100 -type short_time_intervals\n./gen -n 500 -type random\n./gen -n 500 -type same_time\n./gen -n 500 -type low_pi\n./gen -n 500 -type pi_zero\n./gen -n 500 -type pi_one\n./gen -n 500 -type large_time_gaps\n./gen -n 500 -type short_time_intervals\n./gen -n 1000 -type random\n./gen -n 1000 -type same_time\n./gen -n 1000 -type high_pi\n./gen -n 1000 -type low_pi\n./gen -n 1000 -type pi_zero\n./gen -n 1000 -type pi_one\n./gen -n 1000 -type large_time_gaps\n./gen -n 1000 -type short_time_intervals\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:04:46.983034",
        "total_tutorials": 3,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "30/D",
      "title": "D. King's Problem?",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test3 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains two integers n and k (1 ≤ n ≤ 105, 1 ≤ k ≤ n + 1) — amount of cities and index of the starting city. The second line contains n + 1 numbers xi. The third line contains yn + 1. All coordinates are integers and do not exceed 106 by absolute value. No two cities coincide.",
      "output_spec": "OutputOutput the minimum possible length of the journey. Your answer must have relative or absolute error less than 10 - 6.",
      "sample_tests": "ExamplesInputCopy3 10 1 2 11OutputCopy3.41421356237309490000InputCopy3 11 0 2 11OutputCopy3.82842712474619030000InputCopy4 50 5 -1 -5 23OutputCopy14.24264068711928400000",
      "description": "D. King's Problem?\n\ntime limit per test3 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains two integers n and k (1 ≤ n ≤ 105, 1 ≤ k ≤ n + 1) — amount of cities and index of the starting city. The second line contains n + 1 numbers xi. The third line contains yn + 1. All coordinates are integers and do not exceed 106 by absolute value. No two cities coincide.\n\nOutputOutput the minimum possible length of the journey. Your answer must have relative or absolute error less than 10 - 6.\n\nInputCopy3 10 1 2 11OutputCopy3.41421356237309490000InputCopy3 11 0 2 11OutputCopy3.82842712474619030000InputCopy4 50 5 -1 -5 23OutputCopy14.24264068711928400000\n\nInputCopy3 10 1 2 11\n\nOutputCopy3.41421356237309490000\n\nInputCopy3 11 0 2 11\n\nOutputCopy3.82842712474619030000\n\nInputCopy4 50 5 -1 -5 23\n\nOutputCopy14.24264068711928400000",
      "solutions": [
        {
          "title": "Codeforces Beta Round #30 (Codeforces format) - Codeforces",
          "content": "Today's contest was prepared by Saratov SU 2 team (Maxim Ivanov, Artem Rakhov, Nickolay Kuznetsov).You will be asked to solve five easy and not so easy problems for some King, whom you hardly heard anything before. The king hopes that the problems won't turn out very difficult to you, and he will have a wide choice among different solutions to each of the problems.UPD. The contest has finished, thanks to all of you.The Results table.Greeting to rng_58 for his win in today's round!Problem tutorials: A, B, C, D, E. Thanks to Mike Mirzayanov and Dmitry Matov who helped to prepare this round too.Problem statements can be downloaded as a single PDF-file:english versionrussian versionP.S. Don't forget to look through Codeforces Format contest rules, if you participate for the first time!",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/692",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 792
        },
        {
          "title": "Codeforces Beta Round #30. Tutorial for problem A - Codeforces",
          "content": "Tutorial for problem \"A. Accounting\"First solution: naive bruteLet's brute all possible values of X, and check each of them. It's easy to understand, that X will be constrained in the same limits as values A and B, that is, from -1000 to 1000 inclusive (obviously, there exists a test for each such X, so we can't decrease these limits).When we have some fixed value of X, we check it simply by multiplying A by X n times. But, you should be careful with possible integer (and even 64-bit integer :) ) overflow. For example, you should stop multiplying by X if the currect result exceeds 1000 by absolute value already.Second solution: formulaIt's easy to note, that if solution exists, then it is n-th root from |B| / |A| fraction, with changed sign if A and B have different signs and if n is odd (if n is even, then no solution exists). That's why we could just use pow() function (or some analog in your language) to calculate 1 / n-th power of the fraction, and after that we just have to check - is the result integer number or not. Of course, we have to check it with taking into account precision errors: that is, number is integer if it is within 10 - 9 (or some another number) from nearest integer.Moreover, in this solution you should be careful with zeroes. The worst case is when A = 0, and this case should be checked manually (you should note the difference between B = 0 and B ≠ 0 cases).It should be told that many of the solutions failed on tests with A = 0, or B = 0, and if these tests were not included in the pretestset, I think, about half of participants would fail to solve this problem :)",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/696",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1615
        },
        {
          "title": "Codeforces Beta Round #30. Tutorial for problem D - Codeforces",
          "content": "Tutorial for problem \"D. Kings Problem?\"In this problem to create a wright solution you need to perform the following chain of inferences (though, if you skip some steps or do them not completely, you can still get an AC solution :) ):Note that after we visit the city numbered n + 1, the further answer depends only from the leftmost and the rightmost unvisited cities (and it would be optimal to come to the nearest to n + 1-th city of them, and the come to another of them). That's why we know the answer for the case k = n + 1, and won't consider this case later.Before we visit the n + 1-th city, - this part of the path covers some segment of cities lying in the OX axis. This segment, obviously, contains the point k. But we can't iterate over all such possible segments, because there are O(n2) of them, so it's still a slow solution.Let's understand the following fact: if before visiting city n + 1 we visited some other cities, but neither the leftmost nor the rightmost, then it was surely unprofitable. Really, after we come into the n + 1, the answer will depend only on the leftmost and the rightmost of non-visited cities. So, if before the n + 1-th city we performed some movements, but didn't change the leftmost and the rightmost cities, then it was completely unnecessary and unprofitable action.We can can get even more: there is no optimal solution, where we should move from the start city k to the n + 1-th city directly, without vithout visiting other cities (here I suppose that k is neither the leftmost nor the rightmost city). Btw, this step of reasoning could be skipped - we can believe it's sometimes profitable to come from k to n + 1 directly, and it's not difficult to support this case in a solution we'll build later; but in order to describe the problem completely let's prove this fact too. In order to prove this, let's write down two formulas: first for the length of the answer if we come from k to n + 1 directly, then come to city 1, and then to city n (here I suppose that 1 and n are the leftmost and the rightmost cities, accordingly, and city 1 is nearer to n + 1 than n); second formula - for the length of the answer if we come from k to 1 first, then to n + 1, then to k + 1, and then to n. If we compare these two formulas, then after the cancellation of like terms we can use the triangle's inequality to see that the second formula always gives smaller value (at least, not greater) than the first. So, it's really unprofitable to come from k to n + 1 directly.So, to make a right solution, it's enough to iterate over only two types of segments: [1;i] for i ≥ k, and [i;n] for i ≤ k (here I suppose for convenience that cities are sorted by their x-coordinate).The last idea is how to process each of these cases accurately. In order to do this we iterate over all possible i = 1... n. Let, for example, i ≤ k. Then we have to try the following case: go from k to n, then return to i, then come to n + 1, and then return back to the OX axis if need (if i > 1). Also it is required to check another type of cases: try to go from k to i, then to n, and then come to n + 1, and return back to the OX axis if need. Answer for each of these cases can be calculated in O(1). For i ≥ k everything is symmetric.So, not taking into account the sorting of the citites in the beginning of the program, we get a O(n)-solution.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/697",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 3369
        }
      ],
      "code_examples": [],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(1, n + 1, \"k\");\n    inf.readEoln();\n\n    vector<int> xi = inf.readInts(n + 1, -1000000, 1000000, \"xi\");\n    inf.readEoln();\n\n    int ynp1 = inf.readInt(-1000000, 1000000, \"yn+1\");\n    inf.readEoln();\n\n    set<pair<int, int>> cities;\n\n    for (int i = 0; i <= n; ++i) {\n        int x = xi[i];\n        int y = (i < n) ? 0 : ynp1;\n        if (!cities.insert({x, y}).second) {\n            ensuref(false, \"No two cities may be located at the same point\");\n        }\n    }\n\n    inf.readEof();\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(1, n + 1, \"k\");\n    inf.readEoln();\n\n    vector<int> xi = inf.readInts(n + 1, -1000000, 1000000, \"xi\");\n    inf.readEoln();\n\n    int ynp1 = inf.readInt(-1000000, 1000000, \"yn+1\");\n    inf.readEoln();\n\n    set<pair<int, int>> cities;\n\n    for (int i = 0; i <= n; ++i) {\n        int x = xi[i];\n        int y = (i < n) ? 0 : ynp1;\n        if (!cities.insert({x, y}).second) {\n            ensuref(false, \"No two cities may be located at the same point\");\n        }\n    }\n\n    inf.readEof();\n\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(1, n + 1, \"k\");\n    inf.readEoln();\n\n    vector<int> xi = inf.readInts(n + 1, -1000000, 1000000, \"xi\");\n    inf.readEoln();\n\n    int ynp1 = inf.readInt(-1000000, 1000000, \"yn+1\");\n    inf.readEoln();\n\n    set<pair<int, int>> cities;\n\n    for (int i = 0; i <= n; ++i) {\n        int x = xi[i];\n        int y = (i < n) ? 0 : ynp1;\n        if (!cities.insert({x, y}).second) {\n            ensuref(false, \"No two cities may be located at the same point\");\n        }\n    }\n\n    inf.readEof();\n\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nconst double EPS = 1E-6;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare two sequences of doubles, max absolute or relative  error = %.7f\", EPS);\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    double j = 0, p = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        n++;\r\n        j = ans.readDouble();\r\n        p = ouf.readDouble();\r\n        if (!doubleCompare(j, p, EPS)) {\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%.7f', found: '%.7f', error = '%.7f'\",\r\n                  n, englishEnding(n).c_str(), j, p, doubleDelta(j, p));\r\n        }\r\n    }\r\n\r\n    if (n == 1)\r\n        quitf(_ok, \"found '%.7f', expected '%.7f', error '%.7f'\", p, j, doubleDelta(j, p));\r\n\r\n    quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    // Read parameters\n    int n = opt<int>(\"n\");\n    int k = opt<int>(\"k\", -1); // default to -1, will set later\n    string type = opt<string>(\"type\", \"random\");\n\n    if (n < 1 || n > 100000) {\n        fprintf(stderr, \"Invalid value of n: %d (should be between 1 and 1e5)\\n\", n);\n        exit(1);\n    }\n\n    // Now, depending on type, generate xi and yn+1\n    // Make sure xi are integers, abs(xi) ≤ 1e6\n\n    vector<int> xi(n);\n    int xn_plus1 = 0;\n    int yn_plus1 = 0;\n    int max_abs_coord = 1000000;\n\n    set<pair<int,int>> city_coords; // To ensure no two cities coincide\n\n    if (type == \"all_positive\") {\n        for (int i = 0; i < n; ++i) {\n            xi[i] = rnd.next(1, max_abs_coord);\n        }\n        xn_plus1 = rnd.next(1, max_abs_coord);\n        yn_plus1 = rnd.next(1, max_abs_coord);\n    } else if (type == \"all_negative\") {\n        for (int i = 0; i < n; ++i) {\n            xi[i] = -rnd.next(1, max_abs_coord);\n        }\n        xn_plus1 = -rnd.next(1, max_abs_coord);\n        yn_plus1 = -rnd.next(1, max_abs_coord);\n    } else if (type == \"small_range\") {\n        int range = 10;\n        for (int i = 0; i < n; ++i) {\n            xi[i] = rnd.next(-range, range);\n        }\n        xn_plus1 = rnd.next(-range, range);\n        yn_plus1 = rnd.next(-range, range);\n    } else if (type == \"large_range\") {\n        for (int i = 0; i < n; ++i) {\n            xi[i] = rnd.next(-max_abs_coord, max_abs_coord);\n        }\n        xn_plus1 = rnd.next(-max_abs_coord, max_abs_coord);\n        yn_plus1 = rnd.next(-max_abs_coord, max_abs_coord);\n    } else if (type == \"clustered\") {\n        // Clustered around some point\n        int center = rnd.next(-100, 100);\n        int range = 10;\n        for (int i = 0; i < n; ++i) {\n            xi[i] = rnd.next(center - range, center + range);\n        }\n        xn_plus1 = rnd.next(center - range, center + range);\n        yn_plus1 = rnd.next(center - range, center + range);\n    } else if (type == \"sparse\") {\n        // Spread over full range\n        for (int i = 0; i < n; ++i) {\n            xi[i] = rnd.next(-max_abs_coord, max_abs_coord);\n        }\n        xn_plus1 = rnd.next(-max_abs_coord, max_abs_coord);\n        yn_plus1 = rnd.next(-max_abs_coord, max_abs_coord);\n    } else if (type == \"mixed\") {\n        for (int i = 0; i < n; ++i) {\n            xi[i] = rnd.next(-max_abs_coord, max_abs_coord);\n        }\n        xn_plus1 = rnd.next(-max_abs_coord, max_abs_coord);\n        yn_plus1 = rnd.next(-max_abs_coord, max_abs_coord);\n    } else if (type == \"yn_zero\") {\n        // Let's make yn+1 = 0\n        for (int i = 0; i < n; ++i) {\n            xi[i] = rnd.next(-max_abs_coord, max_abs_coord);\n        }\n        xn_plus1 = rnd.next(-max_abs_coord, max_abs_coord);\n        yn_plus1 = 0;\n    } else if (type == \"yn_large\") {\n        for (int i = 0; i < n; ++i) {\n            xi[i] = rnd.next(-max_abs_coord, max_abs_coord);\n        }\n        xn_plus1 = rnd.next(-max_abs_coord, max_abs_coord);\n        int sign = rnd.next(0, 1) ? 1 : -1;\n        yn_plus1 = sign * max_abs_coord;\n    } else if (type == \"start_first\") {\n        // Same as random\n        for (int i = 0; i < n; ++i) {\n            xi[i] = rnd.next(-max_abs_coord, max_abs_coord);\n        }\n        xn_plus1 = rnd.next(-max_abs_coord, max_abs_coord);\n        yn_plus1 = rnd.next(-max_abs_coord, max_abs_coord);\n        if (k == -1) k = 1;\n    } else if (type == \"start_last\") {\n        for (int i = 0; i < n; ++i) {\n            xi[i] = rnd.next(-max_abs_coord, max_abs_coord);\n        }\n        xn_plus1 = rnd.next(-max_abs_coord, max_abs_coord);\n        yn_plus1 = rnd.next(-max_abs_coord, max_abs_coord);\n        if (k == -1) k = n + 1;\n    } else if (type == \"start_middle\") {\n        for (int i = 0; i < n; ++i) {\n            xi[i] = rnd.next(-max_abs_coord, max_abs_coord);\n        }\n        xn_plus1 = rnd.next(-max_abs_coord, max_abs_coord);\n        yn_plus1 = rnd.next(-max_abs_coord, max_abs_coord);\n        if (k == -1) k = rnd.next(1, n+1);\n    } else {\n        // Default random\n        for (int i = 0; i < n; ++i) {\n            xi[i] = rnd.next(-max_abs_coord, max_abs_coord);\n        }\n        xn_plus1 = rnd.next(-max_abs_coord, max_abs_coord);\n        yn_plus1 = rnd.next(-max_abs_coord, max_abs_coord);\n    }\n\n    // Now, ensure no two cities coincide\n    // The cities are at (x_i, 0) for 1 <= i <= n, and (x_{n+1}, y_{n+1}) for i = n+1\n    // We'll use a set to store the city coordinates as pairs\n\n    city_coords.clear();\n    for (int i = 0; i < n; ++i) {\n        while (city_coords.count({xi[i], 0})) {\n            xi[i] = rnd.next(-max_abs_coord, max_abs_coord);\n        }\n        city_coords.insert({xi[i], 0});\n    }\n\n    // Now check if (xn_plus1, yn_plus1) coincides with any existing city\n\n    while (city_coords.count({xn_plus1, yn_plus1})) {\n        xn_plus1 = rnd.next(-max_abs_coord, max_abs_coord);\n        yn_plus1 = rnd.next(-max_abs_coord, max_abs_coord);\n    }\n\n    city_coords.insert({xn_plus1, yn_plus1});\n\n    // Now if k is still -1, set it randomly\n\n    if (k == -1) {\n        k = rnd.next(1, n + 1);\n    }\n\n    if (k < 1 || k > n + 1) {\n        fprintf(stderr, \"Invalid value of k: %d (should be between 1 and n+1)\\n\", k);\n        exit(1);\n    }\n\n    // Now output\n\n    printf(\"%d %d\\n\", n, k);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d \", xi[i]);\n    }\n    printf(\"%d\\n\", xn_plus1);\n    printf(\"%d\\n\", yn_plus1);\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    // Read parameters\n    int n = opt<int>(\"n\");\n    int k = opt<int>(\"k\", -1); // default to -1, will set later\n    string type = opt<string>(\"type\", \"random\");\n\n    if (n < 1 || n > 100000) {\n        fprintf(stderr, \"Invalid value of n: %d (should be between 1 and 1e5)\\n\", n);\n        exit(1);\n    }\n\n    // Now, depending on type, generate xi and yn+1\n    // Make sure xi are integers, abs(xi) ≤ 1e6\n\n    vector<int> xi(n);\n    int xn_plus1 = 0;\n    int yn_plus1 = 0;\n    int max_abs_coord = 1000000;\n\n    set<pair<int,int>> city_coords; // To ensure no two cities coincide\n\n    if (type == \"all_positive\") {\n        for (int i = 0; i < n; ++i) {\n            xi[i] = rnd.next(1, max_abs_coord);\n        }\n        xn_plus1 = rnd.next(1, max_abs_coord);\n        yn_plus1 = rnd.next(1, max_abs_coord);\n    } else if (type == \"all_negative\") {\n        for (int i = 0; i < n; ++i) {\n            xi[i] = -rnd.next(1, max_abs_coord);\n        }\n        xn_plus1 = -rnd.next(1, max_abs_coord);\n        yn_plus1 = -rnd.next(1, max_abs_coord);\n    } else if (type == \"small_range\") {\n        int range = 10;\n        for (int i = 0; i < n; ++i) {\n            xi[i] = rnd.next(-range, range);\n        }\n        xn_plus1 = rnd.next(-range, range);\n        yn_plus1 = rnd.next(-range, range);\n    } else if (type == \"large_range\") {\n        for (int i = 0; i < n; ++i) {\n            xi[i] = rnd.next(-max_abs_coord, max_abs_coord);\n        }\n        xn_plus1 = rnd.next(-max_abs_coord, max_abs_coord);\n        yn_plus1 = rnd.next(-max_abs_coord, max_abs_coord);\n    } else if (type == \"clustered\") {\n        // Clustered around some point\n        int center = rnd.next(-100, 100);\n        int range = 10;\n        for (int i = 0; i < n; ++i) {\n            xi[i] = rnd.next(center - range, center + range);\n        }\n        xn_plus1 = rnd.next(center - range, center + range);\n        yn_plus1 = rnd.next(center - range, center + range);\n    } else if (type == \"sparse\") {\n        // Spread over full range\n        for (int i = 0; i < n; ++i) {\n            xi[i] = rnd.next(-max_abs_coord, max_abs_coord);\n        }\n        xn_plus1 = rnd.next(-max_abs_coord, max_abs_coord);\n        yn_plus1 = rnd.next(-max_abs_coord, max_abs_coord);\n    } else if (type == \"mixed\") {\n        for (int i = 0; i < n; ++i) {\n            xi[i] = rnd.next(-max_abs_coord, max_abs_coord);\n        }\n        xn_plus1 = rnd.next(-max_abs_coord, max_abs_coord);\n        yn_plus1 = rnd.next(-max_abs_coord, max_abs_coord);\n    } else if (type == \"yn_zero\") {\n        // Let's make yn+1 = 0\n        for (int i = 0; i < n; ++i) {\n            xi[i] = rnd.next(-max_abs_coord, max_abs_coord);\n        }\n        xn_plus1 = rnd.next(-max_abs_coord, max_abs_coord);\n        yn_plus1 = 0;\n    } else if (type == \"yn_large\") {\n        for (int i = 0; i < n; ++i) {\n            xi[i] = rnd.next(-max_abs_coord, max_abs_coord);\n        }\n        xn_plus1 = rnd.next(-max_abs_coord, max_abs_coord);\n        int sign = rnd.next(0, 1) ? 1 : -1;\n        yn_plus1 = sign * max_abs_coord;\n    } else if (type == \"start_first\") {\n        // Same as random\n        for (int i = 0; i < n; ++i) {\n            xi[i] = rnd.next(-max_abs_coord, max_abs_coord);\n        }\n        xn_plus1 = rnd.next(-max_abs_coord, max_abs_coord);\n        yn_plus1 = rnd.next(-max_abs_coord, max_abs_coord);\n        if (k == -1) k = 1;\n    } else if (type == \"start_last\") {\n        for (int i = 0; i < n; ++i) {\n            xi[i] = rnd.next(-max_abs_coord, max_abs_coord);\n        }\n        xn_plus1 = rnd.next(-max_abs_coord, max_abs_coord);\n        yn_plus1 = rnd.next(-max_abs_coord, max_abs_coord);\n        if (k == -1) k = n + 1;\n    } else if (type == \"start_middle\") {\n        for (int i = 0; i < n; ++i) {\n            xi[i] = rnd.next(-max_abs_coord, max_abs_coord);\n        }\n        xn_plus1 = rnd.next(-max_abs_coord, max_abs_coord);\n        yn_plus1 = rnd.next(-max_abs_coord, max_abs_coord);\n        if (k == -1) k = rnd.next(1, n+1);\n    } else {\n        // Default random\n        for (int i = 0; i < n; ++i) {\n            xi[i] = rnd.next(-max_abs_coord, max_abs_coord);\n        }\n        xn_plus1 = rnd.next(-max_abs_coord, max_abs_coord);\n        yn_plus1 = rnd.next(-max_abs_coord, max_abs_coord);\n    }\n\n    // Now, ensure no two cities coincide\n    // The cities are at (x_i, 0) for 1 <= i <= n, and (x_{n+1}, y_{n+1}) for i = n+1\n    // We'll use a set to store the city coordinates as pairs\n\n    city_coords.clear();\n    for (int i = 0; i < n; ++i) {\n        while (city_coords.count({xi[i], 0})) {\n            xi[i] = rnd.next(-max_abs_coord, max_abs_coord);\n        }\n        city_coords.insert({xi[i], 0});\n    }\n\n    // Now check if (xn_plus1, yn_plus1) coincides with any existing city\n\n    while (city_coords.count({xn_plus1, yn_plus1})) {\n        xn_plus1 = rnd.next(-max_abs_coord, max_abs_coord);\n        yn_plus1 = rnd.next(-max_abs_coord, max_abs_coord);\n    }\n\n    city_coords.insert({xn_plus1, yn_plus1});\n\n    // Now if k is still -1, set it randomly\n\n    if (k == -1) {\n        k = rnd.next(1, n + 1);\n    }\n\n    if (k < 1 || k > n + 1) {\n        fprintf(stderr, \"Invalid value of k: %d (should be between 1 and n+1)\\n\", k);\n        exit(1);\n    }\n\n    // Now output\n\n    printf(\"%d %d\\n\", n, k);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d \", xi[i]);\n    }\n    printf(\"%d\\n\", xn_plus1);\n    printf(\"%d\\n\", yn_plus1);\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -type random\n./gen -n 1 -type all_positive\n./gen -n 1 -type all_negative\n./gen -n 1 -type small_range\n\n./gen -n 100000 -type random\n./gen -n 100000 -type all_positive\n./gen -n 100000 -type all_negative\n./gen -n 100000 -type small_range\n\n./gen -n 100000 -type clustered\n./gen -n 100000 -type sparse\n\n./gen -n 100000 -type yn_zero\n./gen -n 100000 -type yn_large\n\n./gen -n 100000 -type start_first\n./gen -n 100000 -type start_last\n./gen -n 100000 -type start_middle\n\n./gen -n 99999 -k 1 -type random\n./gen -n 99999 -k 50000 -type random\n./gen -n 99999 -k 99999 -type random\n./gen -n 99999 -k 100000 -type random\n\n./gen -n 2 -type random\n./gen -n 100 -type mixed\n./gen -n 1000 -k 1 -type yn_zero\n./gen -n 1000 -k 1001 -type yn_large\n\n./gen -n 77777 -type mixed\n./gen -n 55555 -type start_last\n./gen -n 33333 -type start_first\n\n./gen -n 100000 -type small_range\n./gen -n 100000 -type large_range\n./gen -n 100000 -type all_positive\n./gen -n 100000 -type all_negative\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:04:48.788368",
        "total_tutorials": 3,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "30/E",
      "title": "E. Tricky and Clever Password",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe input contains single string of small Latin letters with length from 1 to 105 characters.",
      "output_spec": "OutputThe first line should contain integer k — amount of nonempty parts of the password in your answer (). In each of the following k lines output two integers xi and li — start and length of the corresponding part of the password. Output pairs in order of increasing xi. Separate the numbers in pairs by a single space.Starting position xi should be an integer from 1 to the length of the input string. All li must be positive, because you should output only non-empty parts. The middle part must have odd length.If there are several solutions, output any. Note that your goal is to maximize the sum of li, but not to maximize k.",
      "sample_tests": "ExamplesInputCopyabacabaOutputCopy11 7InputCopyaxbyaOutputCopy31 12 15 1InputCopyxabyczbaOutputCopy32 24 17 2",
      "description": "E. Tricky and Clever Password\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe input contains single string of small Latin letters with length from 1 to 105 characters.\n\nOutputThe first line should contain integer k — amount of nonempty parts of the password in your answer (). In each of the following k lines output two integers xi and li — start and length of the corresponding part of the password. Output pairs in order of increasing xi. Separate the numbers in pairs by a single space.Starting position xi should be an integer from 1 to the length of the input string. All li must be positive, because you should output only non-empty parts. The middle part must have odd length.If there are several solutions, output any. Note that your goal is to maximize the sum of li, but not to maximize k.\n\nInputCopyabacabaOutputCopy11 7InputCopyaxbyaOutputCopy31 12 15 1InputCopyxabyczbaOutputCopy32 24 17 2\n\nInputCopyabacaba\n\nOutputCopy11 7\n\nInputCopyaxbya\n\nOutputCopy31 12 15 1\n\nInputCopyxabyczba\n\nOutputCopy32 24 17 2",
      "solutions": [
        {
          "title": "Codeforces Beta Round #30 (Codeforces format) - Codeforces",
          "content": "Today's contest was prepared by Saratov SU 2 team (Maxim Ivanov, Artem Rakhov, Nickolay Kuznetsov).You will be asked to solve five easy and not so easy problems for some King, whom you hardly heard anything before. The king hopes that the problems won't turn out very difficult to you, and he will have a wide choice among different solutions to each of the problems.UPD. The contest has finished, thanks to all of you.The Results table.Greeting to rng_58 for his win in today's round!Problem tutorials: A, B, C, D, E. Thanks to Mike Mirzayanov and Dmitry Matov who helped to prepare this round too.Problem statements can be downloaded as a single PDF-file:english versionrussian versionP.S. Don't forget to look through Codeforces Format contest rules, if you participate for the first time!",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/692",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 792
        },
        {
          "title": "Codeforces Beta Round #30. Tutorial for problem A - Codeforces",
          "content": "Tutorial for problem \"A. Accounting\"First solution: naive bruteLet's brute all possible values of X, and check each of them. It's easy to understand, that X will be constrained in the same limits as values A and B, that is, from -1000 to 1000 inclusive (obviously, there exists a test for each such X, so we can't decrease these limits).When we have some fixed value of X, we check it simply by multiplying A by X n times. But, you should be careful with possible integer (and even 64-bit integer :) ) overflow. For example, you should stop multiplying by X if the currect result exceeds 1000 by absolute value already.Second solution: formulaIt's easy to note, that if solution exists, then it is n-th root from |B| / |A| fraction, with changed sign if A and B have different signs and if n is odd (if n is even, then no solution exists). That's why we could just use pow() function (or some analog in your language) to calculate 1 / n-th power of the fraction, and after that we just have to check - is the result integer number or not. Of course, we have to check it with taking into account precision errors: that is, number is integer if it is within 10 - 9 (or some another number) from nearest integer.Moreover, in this solution you should be careful with zeroes. The worst case is when A = 0, and this case should be checked manually (you should note the difference between B = 0 and B ≠ 0 cases).It should be told that many of the solutions failed on tests with A = 0, or B = 0, and if these tests were not included in the pretestset, I think, about half of participants would fail to solve this problem :)",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/696",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1615
        },
        {
          "title": "Codeforces Beta Round #30. Tutorial for problem D - Codeforces",
          "content": "Tutorial for problem \"D. Kings Problem?\"In this problem to create a wright solution you need to perform the following chain of inferences (though, if you skip some steps or do them not completely, you can still get an AC solution :) ):Note that after we visit the city numbered n + 1, the further answer depends only from the leftmost and the rightmost unvisited cities (and it would be optimal to come to the nearest to n + 1-th city of them, and the come to another of them). That's why we know the answer for the case k = n + 1, and won't consider this case later.Before we visit the n + 1-th city, - this part of the path covers some segment of cities lying in the OX axis. This segment, obviously, contains the point k. But we can't iterate over all such possible segments, because there are O(n2) of them, so it's still a slow solution.Let's understand the following fact: if before visiting city n + 1 we visited some other cities, but neither the leftmost nor the rightmost, then it was surely unprofitable. Really, after we come into the n + 1, the answer will depend only on the leftmost and the rightmost of non-visited cities. So, if before the n + 1-th city we performed some movements, but didn't change the leftmost and the rightmost cities, then it was completely unnecessary and unprofitable action.We can can get even more: there is no optimal solution, where we should move from the start city k to the n + 1-th city directly, without vithout visiting other cities (here I suppose that k is neither the leftmost nor the rightmost city). Btw, this step of reasoning could be skipped - we can believe it's sometimes profitable to come from k to n + 1 directly, and it's not difficult to support this case in a solution we'll build later; but in order to describe the problem completely let's prove this fact too. In order to prove this, let's write down two formulas: first for the length of the answer if we come from k to n + 1 directly, then come to city 1, and then to city n (here I suppose that 1 and n are the leftmost and the rightmost cities, accordingly, and city 1 is nearer to n + 1 than n); second formula - for the length of the answer if we come from k to 1 first, then to n + 1, then to k + 1, and then to n. If we compare these two formulas, then after the cancellation of like terms we can use the triangle's inequality to see that the second formula always gives smaller value (at least, not greater) than the first. So, it's really unprofitable to come from k to n + 1 directly.So, to make a right solution, it's enough to iterate over only two types of segments: [1;i] for i ≥ k, and [i;n] for i ≤ k (here I suppose for convenience that cities are sorted by their x-coordinate).The last idea is how to process each of these cases accurately. In order to do this we iterate over all possible i = 1... n. Let, for example, i ≤ k. Then we have to try the following case: go from k to n, then return to i, then come to n + 1, and then return back to the OX axis if need (if i > 1). Also it is required to check another type of cases: try to go from k to i, then to n, and then come to n + 1, and return back to the OX axis if need. Answer for each of these cases can be calculated in O(1). For i ≥ k everything is symmetric.So, not taking into account the sorting of the citites in the beginning of the program, we get a O(n)-solution.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/697",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 3369
        }
      ],
      "code_examples": [],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    string s = inf.readToken(\"[a-z]{1,100000}\", \"s\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    string s = inf.readToken(\"[a-z]{1,100000}\", \"s\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    string s = inf.readToken(\"[a-z]{1,100000}\", \"s\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerTestlibCmd(argc, argv);\n\n    string S = inf.readString(); // Read the input string S\n    int N = S.size();\n\n    int k = ouf.readInt(1, 3, \"k\"); // Read k, the number of non-empty parts (should be 1 or 3)\n    if (k != 1 && k != 3) {\n        quitf(_wa, \"Invalid number of parts k = %d: should be 1 or 3\", k);\n    }\n\n    vector<int> xi(k), li(k);\n    for (int i = 0; i < k; ++i) {\n        xi[i] = ouf.readInt(1, N, format(\"xi[%d]\", i + 1).c_str()); // Read xi\n        li[i] = ouf.readInt(1, N - xi[i] + 1, format(\"li[%d]\", i + 1).c_str()); // Read li\n        if (i > 0 && xi[i] < xi[i - 1]) {\n            quitf(_wa, \"Positions xi must be in increasing order: xi[%d] = %d < xi[%d] = %d\", i + 1, xi[i], i, xi[i - 1]);\n        }\n    }\n\n    vector<string> parts(k);\n    for (int i = 0; i < k; ++i) {\n        parts[i] = S.substr(xi[i] - 1, li[i]); // Extract the substrings\n    }\n\n    string password;\n    if (k == 1) {\n        // Only middle part exists\n        if (li[0] % 2 == 0) {\n            quitf(_wa, \"Middle part must have odd length, found length %d\", li[0]);\n        }\n        password = parts[0];\n    } else {\n        // Prefix, middle, and suffix parts exist\n        if (li[1] % 2 == 0) {\n            quitf(_wa, \"Middle part must have odd length, found length %d\", li[1]);\n        }\n        if (li[0] != li[2]) {\n            quitf(_wa, \"Prefix and suffix lengths must be equal, found %d and %d\", li[0], li[2]);\n        }\n        password = parts[0] + parts[1] + parts[2];\n    }\n\n    if (password.length() % 2 == 0) {\n        quitf(_wa, \"Password length must be odd, found length %d\", password.length());\n    }\n\n    string reversed_password = password;\n    reverse(reversed_password.begin(), reversed_password.end());\n    if (password != reversed_password) {\n        quitf(_wa, \"Password is not a palindrome\");\n    }\n\n    // All checks passed\n    quitf(_ok, \"Password length = %d\", password.length());\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\n// Function to generate a palindrome of given odd length\nstring generatePalindrome(int length) {\n    int half_length = length / 2;\n    string half = \"\";\n    for (int i = 0; i < half_length; i++) {\n        char c = 'a' + rnd.next(26);\n        half += c;\n    }\n    char middle = 'a' + rnd.next(26);\n    string s = half + middle;\n    reverse(half.begin(), half.end());\n    s += half;\n    return s;\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    if (type == \"full_palindrome\") {\n        // Ensure n is odd and at least 1\n        if (n % 2 == 0) {\n            if (n >= 1) n--;\n            else n = 1;\n        }\n        string s = generatePalindrome(n);\n        cout << s << endl;\n    } else if (type == \"random\") {\n        string s = \"\";\n        for (int i = 0; i < n; i++) {\n            char c = 'a' + rnd.next(26);\n            s += c;\n        }\n        cout << s << endl;\n    } else if (type == \"password_in_middle\") {\n        // Generate password\n        int max_Lp = min(n, 100000);\n        int Lp = rnd.next(1, max_Lp);\n        if (Lp % 2 == 0) Lp--;\n        if (Lp <= 0) Lp = 1;\n        int max_x = (Lp - 1) / 2;\n        int x = rnd.next(0, max_x);\n        int middle_length = Lp - 2 * x; // Must be odd\n\n        int extra_length = n - Lp;\n        int A_length = rnd.next(0, extra_length);\n        int B_length = rnd.next(0, extra_length - A_length);\n        int C_length = extra_length - A_length - B_length;\n\n        string A = \"\";\n        for (int i = 0; i < A_length; i++) {\n            A += 'a' + rnd.next(26);\n        }\n        string B = \"\";\n        for (int i = 0; i < B_length; i++) {\n            B += 'a' + rnd.next(26);\n        }\n        string C = \"\";\n        for (int i = 0; i < C_length; i++) {\n            C += 'a' + rnd.next(26);\n        }\n        string password = generatePalindrome(Lp);\n        string prefix = password.substr(0, x);\n        string middle = password.substr(x, middle_length);\n        string suffix = password.substr(Lp - x, x);\n\n        string S = A + prefix + B + middle + C + suffix;\n\n        // Adjust length if necessary\n        if (S.length() > n) {\n            S = S.substr(0, n);\n        } else if (S.length() < n) {\n            for (size_t i = S.length(); i < n; i++) {\n                S += 'a' + rnd.next(26);\n            }\n        }\n        cout << S << endl;\n    } else if (type == \"password_at_beginning\") {\n        // Generate password\n        int max_Lp = min(n, 100000);\n        int Lp = rnd.next(1, max_Lp);\n        if (Lp % 2 == 0) Lp--;\n        if (Lp <= 0) Lp = 1;\n        int max_x = (Lp - 1) / 2;\n        int x = rnd.next(0, max_x);\n        int middle_length = Lp - 2 * x; // Must be odd\n\n        int extra_length = n - Lp;\n        int B_length = rnd.next(0, extra_length);\n        int C_length = extra_length - B_length;\n\n        string B = \"\";\n        for (int i = 0; i < B_length; i++) {\n            B += 'a' + rnd.next(26);\n        }\n        string C = \"\";\n        for (int i = 0; i < C_length; i++) {\n            C += 'a' + rnd.next(26);\n        }\n        string password = generatePalindrome(Lp);\n        string prefix = password.substr(0, x);\n        string middle = password.substr(x, middle_length);\n        string suffix = password.substr(Lp - x, x);\n\n        string S = prefix + B + middle + C + suffix;\n\n        if (S.length() > n) {\n            S = S.substr(0, n);\n        } else if (S.length() < n) {\n            for (size_t i = S.length(); i < n; i++) {\n                S += 'a' + rnd.next(26);\n            }\n        }\n        cout << S << endl;\n    } else if (type == \"password_at_end\") {\n        // Generate password\n        int max_Lp = min(n, 100000);\n        int Lp = rnd.next(1, max_Lp);\n        if (Lp % 2 == 0) Lp--;\n        if (Lp <= 0) Lp = 1;\n        int max_x = (Lp - 1) / 2;\n        int x = rnd.next(0, max_x);\n        int middle_length = Lp - 2 * x; // Must be odd\n\n        int extra_length = n - Lp;\n        int A_length = rnd.next(0, extra_length);\n        int B_length = extra_length - A_length;\n\n        string A = \"\";\n        for (int i = 0; i < A_length; i++) {\n            A += 'a' + rnd.next(26);\n        }\n        string B = \"\";\n        for (int i = 0; i < B_length; i++) {\n            B += 'a' + rnd.next(26);\n        }\n        string password = generatePalindrome(Lp);\n        string prefix = password.substr(0, x);\n        string middle = password.substr(x, middle_length);\n        string suffix = password.substr(Lp - x, x);\n\n        string S = A + prefix + B + middle + suffix;\n\n        if (S.length() > n) {\n            S = S.substr(0, n);\n        } else if (S.length() < n) {\n            for (size_t i = S.length(); i < n; i++) {\n                S += 'a' + rnd.next(26);\n            }\n        }\n        cout << S << endl;\n    } else if (type == \"no_long_palindrome\") {\n        // Generate a string where maximum odd-length palindrome is small\n        string s = \"\";\n        char prev_char = 'a' + rnd.next(26);\n        s += prev_char;\n        for (int i = 1; i < n; i++) {\n            char c = 'a' + rnd.next(26);\n            while (c == prev_char) {\n                c = 'a' + rnd.next(26);\n            }\n            s += c;\n            prev_char = c;\n        }\n        cout << s << endl;\n    } else {\n        // Default to random string if type is unrecognized\n        string s = \"\";\n        for (int i = 0; i < n; i++) {\n            char c = 'a' + rnd.next(26);\n            s += c;\n        }\n        cout << s << endl;\n    }\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\n// Function to generate a palindrome of given odd length\nstring generatePalindrome(int length) {\n    int half_length = length / 2;\n    string half = \"\";\n    for (int i = 0; i < half_length; i++) {\n        char c = 'a' + rnd.next(26);\n        half += c;\n    }\n    char middle = 'a' + rnd.next(26);\n    string s = half + middle;\n    reverse(half.begin(), half.end());\n    s += half;\n    return s;\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    if (type == \"full_palindrome\") {\n        // Ensure n is odd and at least 1\n        if (n % 2 == 0) {\n            if (n >= 1) n--;\n            else n = 1;\n        }\n        string s = generatePalindrome(n);\n        cout << s << endl;\n    } else if (type == \"random\") {\n        string s = \"\";\n        for (int i = 0; i < n; i++) {\n            char c = 'a' + rnd.next(26);\n            s += c;\n        }\n        cout << s << endl;\n    } else if (type == \"password_in_middle\") {\n        // Generate password\n        int max_Lp = min(n, 100000);\n        int Lp = rnd.next(1, max_Lp);\n        if (Lp % 2 == 0) Lp--;\n        if (Lp <= 0) Lp = 1;\n        int max_x = (Lp - 1) / 2;\n        int x = rnd.next(0, max_x);\n        int middle_length = Lp - 2 * x; // Must be odd\n\n        int extra_length = n - Lp;\n        int A_length = rnd.next(0, extra_length);\n        int B_length = rnd.next(0, extra_length - A_length);\n        int C_length = extra_length - A_length - B_length;\n\n        string A = \"\";\n        for (int i = 0; i < A_length; i++) {\n            A += 'a' + rnd.next(26);\n        }\n        string B = \"\";\n        for (int i = 0; i < B_length; i++) {\n            B += 'a' + rnd.next(26);\n        }\n        string C = \"\";\n        for (int i = 0; i < C_length; i++) {\n            C += 'a' + rnd.next(26);\n        }\n        string password = generatePalindrome(Lp);\n        string prefix = password.substr(0, x);\n        string middle = password.substr(x, middle_length);\n        string suffix = password.substr(Lp - x, x);\n\n        string S = A + prefix + B + middle + C + suffix;\n\n        // Adjust length if necessary\n        if (S.length() > n) {\n            S = S.substr(0, n);\n        } else if (S.length() < n) {\n            for (size_t i = S.length(); i < n; i++) {\n                S += 'a' + rnd.next(26);\n            }\n        }\n        cout << S << endl;\n    } else if (type == \"password_at_beginning\") {\n        // Generate password\n        int max_Lp = min(n, 100000);\n        int Lp = rnd.next(1, max_Lp);\n        if (Lp % 2 == 0) Lp--;\n        if (Lp <= 0) Lp = 1;\n        int max_x = (Lp - 1) / 2;\n        int x = rnd.next(0, max_x);\n        int middle_length = Lp - 2 * x; // Must be odd\n\n        int extra_length = n - Lp;\n        int B_length = rnd.next(0, extra_length);\n        int C_length = extra_length - B_length;\n\n        string B = \"\";\n        for (int i = 0; i < B_length; i++) {\n            B += 'a' + rnd.next(26);\n        }\n        string C = \"\";\n        for (int i = 0; i < C_length; i++) {\n            C += 'a' + rnd.next(26);\n        }\n        string password = generatePalindrome(Lp);\n        string prefix = password.substr(0, x);\n        string middle = password.substr(x, middle_length);\n        string suffix = password.substr(Lp - x, x);\n\n        string S = prefix + B + middle + C + suffix;\n\n        if (S.length() > n) {\n            S = S.substr(0, n);\n        } else if (S.length() < n) {\n            for (size_t i = S.length(); i < n; i++) {\n                S += 'a' + rnd.next(26);\n            }\n        }\n        cout << S << endl;\n    } else if (type == \"password_at_end\") {\n        // Generate password\n        int max_Lp = min(n, 100000);\n        int Lp = rnd.next(1, max_Lp);\n        if (Lp % 2 == 0) Lp--;\n        if (Lp <= 0) Lp = 1;\n        int max_x = (Lp - 1) / 2;\n        int x = rnd.next(0, max_x);\n        int middle_length = Lp - 2 * x; // Must be odd\n\n        int extra_length = n - Lp;\n        int A_length = rnd.next(0, extra_length);\n        int B_length = extra_length - A_length;\n\n        string A = \"\";\n        for (int i = 0; i < A_length; i++) {\n            A += 'a' + rnd.next(26);\n        }\n        string B = \"\";\n        for (int i = 0; i < B_length; i++) {\n            B += 'a' + rnd.next(26);\n        }\n        string password = generatePalindrome(Lp);\n        string prefix = password.substr(0, x);\n        string middle = password.substr(x, middle_length);\n        string suffix = password.substr(Lp - x, x);\n\n        string S = A + prefix + B + middle + suffix;\n\n        if (S.length() > n) {\n            S = S.substr(0, n);\n        } else if (S.length() < n) {\n            for (size_t i = S.length(); i < n; i++) {\n                S += 'a' + rnd.next(26);\n            }\n        }\n        cout << S << endl;\n    } else if (type == \"no_long_palindrome\") {\n        // Generate a string where maximum odd-length palindrome is small\n        string s = \"\";\n        char prev_char = 'a' + rnd.next(26);\n        s += prev_char;\n        for (int i = 1; i < n; i++) {\n            char c = 'a' + rnd.next(26);\n            while (c == prev_char) {\n                c = 'a' + rnd.next(26);\n            }\n            s += c;\n            prev_char = c;\n        }\n        cout << s << endl;\n    } else {\n        // Default to random string if type is unrecognized\n        string s = \"\";\n        for (int i = 0; i < n; i++) {\n            char c = 'a' + rnd.next(26);\n            s += c;\n        }\n        cout << s << endl;\n    }\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -type full_palindrome\n./gen -n 3 -type full_palindrome\n./gen -n 5 -type full_palindrome\n./gen -n 100 -type full_palindrome\n./gen -n 100000 -type full_palindrome\n\n./gen -n 1 -type random\n./gen -n 10 -type random\n./gen -n 100 -type random\n./gen -n 1000 -type random\n./gen -n 10000 -type random\n./gen -n 100000 -type random\n\n./gen -n 10 -type password_in_middle\n./gen -n 100 -type password_in_middle\n./gen -n 1000 -type password_in_middle\n./gen -n 10000 -type password_in_middle\n./gen -n 100000 -type password_in_middle\n\n./gen -n 10 -type password_at_beginning\n./gen -n 100 -type password_at_beginning\n./gen -n 1000 -type password_at_beginning\n./gen -n 10000 -type password_at_beginning\n./gen -n 100000 -type password_at_beginning\n\n./gen -n 10 -type password_at_end\n./gen -n 100 -type password_at_end\n./gen -n 1000 -type password_at_end\n./gen -n 10000 -type password_at_end\n./gen -n 100000 -type password_at_end\n\n./gen -n 10 -type no_long_palindrome\n./gen -n 100 -type no_long_palindrome\n./gen -n 1000 -type no_long_palindrome\n./gen -n 10000 -type no_long_palindrome\n./gen -n 100000 -type no_long_palindrome\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:04:50.670136",
        "total_tutorials": 3,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "300/A",
      "title": "A. Array",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line of the input contains integer n (3 ≤ n ≤ 100). The second line contains n space-separated distinct integers a1, a2, ..., an (|ai| ≤ 103) — the array elements.",
      "output_spec": "OutputIn the first line print integer n1 (n1 > 0) — the number of elements in the first set. Then print n1 numbers — the elements that got to the first set.In the next line print integer n2 (n2 > 0) — the number of elements in the second set. Then print n2 numbers — the elements that got to the second set.In the next line print integer n3 (n3 > 0) — the number of elements in the third set. Then print n3 numbers — the elements that got to the third set.The printed sets must meet the described conditions. It is guaranteed that the solution exists. If there are several solutions, you are allowed to print any of them.",
      "sample_tests": "ExamplesInputCopy3-1 2 0OutputCopy1 -11 21 0InputCopy4-1 -2 -3 0OutputCopy1 -12 -3 -21 0",
      "description": "time limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line of the input contains integer n (3 ≤ n ≤ 100). The second line contains n space-separated distinct integers a1, a2, ..., an (|ai| ≤ 103) — the array elements.\n\nOutputIn the first line print integer n1 (n1 > 0) — the number of elements in the first set. Then print n1 numbers — the elements that got to the first set.In the next line print integer n2 (n2 > 0) — the number of elements in the second set. Then print n2 numbers — the elements that got to the second set.In the next line print integer n3 (n3 > 0) — the number of elements in the third set. Then print n3 numbers — the elements that got to the third set.The printed sets must meet the described conditions. It is guaranteed that the solution exists. If there are several solutions, you are allowed to print any of them.\n\nInputCopy3-1 2 0OutputCopy1 -11 21 0InputCopy4-1 -2 -3 0OutputCopy1 -12 -3 -21 0\n\nInputCopy3-1 2 0\n\nOutputCopy1 -11 21 0\n\nInputCopy4-1 -2 -3 0\n\nOutputCopy1 -12 -3 -21 0",
      "solutions": [
        {
          "title": "Codeforces Round #181 (Div. 2) - Codeforces",
          "content": "Hello!A few hours later, 25 апреля в 19:30 MSK, you are lucky to participate in Codeforces Round #181 for Div. 2 participants. Traditionally, Div. 1 participants can take part out of the competition.Problems have been prepared by: Gridnev Vitaliy (gridnevvvit), Ignatyev Alexander (aiMR). We want to thank Gerald Agapov(Gerald) for help in preparation of this round, Michael Mirzayanov(MikeMirzayanov) for marvelous Codeforces and Polygon systems, Mary Belova(Delinur) for translating the problems.About authors: me and Alexander are third year students of Mathematics Department, Saratov State University. It’s our first round and I hope not last.We hope you will like these problems, and that it will be fun to solve them. Also we strongly recommend you to read all the problems.We wish everyone good luck and high rating!UPD: Scoring will be dynamic. Problems are sorted by increasing order of difficulty.UPD1: Editorial hereUPD2: Contest finished. Congratulations to winners: ballmaids02 VIProgrammer emachaidze",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/7479",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1015
        },
        {
          "title": "Editorial Codeforces Round #181 (Div.2) - Codeforces",
          "content": "300A - ArrayIn this problem you just need to implement following algorithm. Split input data into 3 vectors: first will contain negative numbers, second positive numbers, third zeroes. If size of first vector is even move one number from it to the third vector. If second vector is empty, then move two numbers from first vector to the second vector. This solution works in O(n).Аuthor's solution300B - CoachInput data represents a graph. If there is a connected component with at least 4 vertexes, then answer is  - 1. Every connected component with 3 vertexes is a complete team. Other teams are made from 1 or 2-vertex components. If amount of 2-vertex components is greater than 1-vertex answer is  - 1. Otherwise match 2-vertex components with 1-vertex. If there are some 1-vertex components left then split them into groups of three. This algorithm works in O(n + m). Also you could implement O(n4) solution.Аuthor's solution300C - Beautiful NumbersLet's MOD = 1000000007. Let's precalc factorial values modulo MOD. fact[i] = i!%MOD, . Let i be an amount of digits equal to a in current excellent number. In this case we can find sum of digits in this number: sum = ai + b(n - i). If sum is good, then add C[n][i] to answer. In this problem it's impossible to calculate binomial coefficients using Pascal's triangle, because of large n. However it can be done this way C[n][i] = fact[n]inv(fact[n - i]fact[i]). inv(a) is multiplicative inverse element(modulo MOD). MOD is a prime number, so inv(a) = aMOD - 2. Calculating this values for each i from 0 to n will give correct answer in O(nlog(MOD)).Аuthor's solution300D - Painting SquareThis picture is helpful for understanding.Let's consider problem D in graph terms:We have matrix n × n, which represents a graph: It is tree. Every vertex, except leaves, has 4 children. There are 4k distinct vertexes, with distance k from root. We need to color k vertexes of this graph. By that we mean also to color all vertexes on path from i to 1(root).Knowing height of tree we can build it in unique way. Let's find height of tree in this way: int height = 0;\nwhile (n > 1 && n % 2 == 1) {\n n /= 2; height++;\n}Let's consider following DP: z[i][j] — number of ways to color graph height i in j steps.Naive solution in O(k4log(n)): z[0][0] = 1; z[0][i] = 0, i > 0; z[i][0] = 1, i > 0\nz[i][j] = 0;\nfor(int k1 = 0; k1 <= j - 1; k1++) \n for(int k2 = 0; k2 <= j - 1 - k1; k2++)\n for(int k3 = 0; k3 <= j - 1 - k1 - k2; k3++)\n {\n int k4 = j - 1 - k1 - k2 - k3;\n z[i][j] += z[i-1][k1] * z[i-1][k2] * z[i-1][k3] * z[i-1][k4];\n z[i][j] %= mod;\n }But it is not what we whant in time terms. Let's consider current DP as polynomial coefficients: z[i][j] — coefficient of power j of polynomial i. In that case z[i + 1][j + 1] — coefficient of power j of polynomial i to the 4-th power. This approach allows to solve problem in O(k2log(n)). However this solution is quite slow, because of modulo operations. As you see, this modulo is not so big ( ≤ 107), that allows us to reduce number of modulo operations, thus giving huge perfomance boost. Also it is possible to use FFT to solve in O(klog(k)log(n)).Аuthor's solution. Uses FFTАuthor's solution. Without FFT300E - Empire Strikes BackLet's . val is upper bound for answer. val! is divisible by , you can easily prove it using facts about prime powers in factorial and following inequality . By the way, is called multinomial coefficient. So answer can't exceed 1013. If n! divisible by den, then (n + 1)! is also divisible by den. That means that function of divisibility is monotonic and we can use binary search.For every i, i = 2..., 107, let's precalc max prime in i using linear sieve of Eratosthenes. For i it will be lp[i]. After that let's create a vector, with all primes less then 107.Now let's calculate following values cnt[i] — amount of numbers a, i <  = a.Now me can factorize denominator like this: for(int i = max; i>=2; i--) {\n if (lp[i] != i) \n cnt[lp[i]] += cnt[i];\n cnt[i / lp[i]] += cnt[i];\n}Finally we use binary search from lf = 1 to .Аuthor's solution",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/7497",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 300\\s*A"
          },
          "content_length": 4064
        },
        {
          "title": "Editorial Codeforces Round #181 (Div.2) - Codeforces",
          "content": "300A - ArrayIn this problem you just need to implement following algorithm. Split input data into 3 vectors: first will contain negative numbers, second positive numbers, third zeroes. If size of first vector is even move one number from it to the third vector. If second vector is empty, then move two numbers from first vector to the second vector. This solution works in O(n).Аuthor's solution300B - CoachInput data represents a graph. If there is a connected component with at least 4 vertexes, then answer is  - 1. Every connected component with 3 vertexes is a complete team. Other teams are made from 1 or 2-vertex components. If amount of 2-vertex components is greater than 1-vertex answer is  - 1. Otherwise match 2-vertex components with 1-vertex. If there are some 1-vertex components left then split them into groups of three. This algorithm works in O(n + m). Also you could implement O(n4) solution.Аuthor's solution300C - Beautiful NumbersLet's MOD = 1000000007. Let's precalc factorial values modulo MOD. fact[i] = i!%MOD, . Let i be an amount of digits equal to a in current excellent number. In this case we can find sum of digits in this number: sum = ai + b(n - i). If sum is good, then add C[n][i] to answer. In this problem it's impossible to calculate binomial coefficients using Pascal's triangle, because of large n. However it can be done this way C[n][i] = fact[n]inv(fact[n - i]fact[i]). inv(a) is multiplicative inverse element(modulo MOD). MOD is a prime number, so inv(a) = aMOD - 2. Calculating this values for each i from 0 to n will give correct answer in O(nlog(MOD)).Аuthor's solution300D - Painting SquareThis picture is helpful for understanding.Let's consider problem D in graph terms:We have matrix n × n, which represents a graph: It is tree. Every vertex, except leaves, has 4 children. There are 4k distinct vertexes, with distance k from root. We need to color k vertexes of this graph. By that we mean also to color all vertexes on path from i to 1(root).Knowing height of tree we can build it in unique way. Let's find height of tree in this way: int height = 0;\nwhile (n > 1 && n % 2 == 1) {\n n /= 2; height++;\n}Let's consider following DP: z[i][j] — number of ways to color graph height i in j steps.Naive solution in O(k4log(n)): z[0][0] = 1; z[0][i] = 0, i > 0; z[i][0] = 1, i > 0\nz[i][j] = 0;\nfor(int k1 = 0; k1 <= j - 1; k1++) \n for(int k2 = 0; k2 <= j - 1 - k1; k2++)\n for(int k3 = 0; k3 <= j - 1 - k1 - k2; k3++)\n {\n int k4 = j - 1 - k1 - k2 - k3;\n z[i][j] += z[i-1][k1] * z[i-1][k2] * z[i-1][k3] * z[i-1][k4];\n z[i][j] %= mod;\n }But it is not what we whant in time terms. Let's consider current DP as polynomial coefficients: z[i][j] — coefficient of power j of polynomial i. In that case z[i + 1][j + 1] — coefficient of power j of polynomial i to the 4-th power. This approach allows to solve problem in O(k2log(n)). However this solution is quite slow, because of modulo operations. As you see, this modulo is not so big ( ≤ 107), that allows us to reduce number of modulo operations, thus giving huge perfomance boost. Also it is possible to use FFT to solve in O(klog(k)log(n)).Аuthor's solution. Uses FFTАuthor's solution. Without FFT300E - Empire Strikes BackLet's . val is upper bound for answer. val! is divisible by , you can easily prove it using facts about prime powers in factorial and following inequality . By the way, is called multinomial coefficient. So answer can't exceed 1013. If n! divisible by den, then (n + 1)! is also divisible by den. That means that function of divisibility is monotonic and we can use binary search.For every i, i = 2..., 107, let's precalc max prime in i using linear sieve of Eratosthenes. For i it will be lp[i]. After that let's create a vector, with all primes less then 107.Now let's calculate following values cnt[i] — amount of numbers a, i <  = a.Now me can factorize denominator like this: for(int i = max; i>=2; i--) {\n if (lp[i] != i) \n cnt[lp[i]] += cnt[i];\n cnt[i / lp[i]] += cnt[i];\n}Finally we use binary search from lf = 1 to .Аuthor's solution",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/7497",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 300\\s*A"
          },
          "content_length": 4064
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #181 (Div. 2) - Codeforces - Code 1",
          "code": "WTF???\nUPD: he has already -179 hacks...",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7479",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #181 (Div. 2) - Codeforces - Code 2",
          "code": "WTF???\nUPD: he has already -179 hacks...",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7479",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #181 (Div. 2) - Codeforces - Code 3",
          "code": "// ax + by = gcd(a,b) = d\nvoid eea(int a, int b, int& x, int& y, int& d) {\n    if (!b) {x = 1; y = 0; d = a; return; }\n    eea(b, a % b, x, y, d);\n    int x1 = y, y1 = x - (a / b) * y;\n    x = x1, y = y1;\n}\nint divide(int a, int b) {\n    int d, x, y;\n    eea(b, MOD, x, y, d);\n    // if(a%d==0)\n    return ((x+MOD)*(a/d)) % (MOD/d);\n    // else   \"no quotient\"\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7479",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #181 (Div. 2) - Codeforces - Code 4",
          "code": "// ax + by = gcd(a,b) = d\nvoid eea(int a, int b, int& x, int& y, int& d) {\n    if (!b) {x = 1; y = 0; d = a; return; }\n    eea(b, a % b, x, y, d);\n    int x1 = y, y1 = x - (a / b) * y;\n    x = x1, y = y1;\n}\nint divide(int a, int b) {\n    int d, x, y;\n    eea(b, MOD, x, y, d);\n    // if(a%d==0)\n    return ((x+MOD)*(a/d)) % (MOD/d);\n    // else   \"no quotient\"\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7479",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #181 (Div.2) - Codeforces - Code 1",
          "code": "int height = 0;\nwhile (n > 1 && n % 2 == 1) {\n n /= 2; height++;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7497",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #181 (Div.2) - Codeforces - Code 2",
          "code": "int height = 0;\nwhile (n > 1 && n % 2 == 1) {\n n /= 2; height++;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7497",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #181 (Div.2) - Codeforces - Code 3",
          "code": "z[0][0] = 1; z[0][i] = 0, i > 0; z[i][0] = 1, i > 0\nz[i][j] = 0;\nfor(int k1 = 0; k1 <= j - 1; k1++) \n  for(int k2 = 0; k2 <= j - 1 - k1; k2++)\n    for(int k3 = 0; k3 <= j - 1 - k1 - k2; k3++)\n      {\n         int k4 = j - 1 - k1 - k2 - k3;\n  z[i][j] += z[i-1][k1] * z[i-1][k2] * z[i-1][k3] * z[i-1][k4];\n  z[i][j] %= mod;\n      }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7497",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #181 (Div.2) - Codeforces - Code 4",
          "code": "z[0][0] = 1; z[0][i] = 0, i > 0; z[i][0] = 1, i > 0\nz[i][j] = 0;\nfor(int k1 = 0; k1 <= j - 1; k1++) \n  for(int k2 = 0; k2 <= j - 1 - k1; k2++)\n    for(int k3 = 0; k3 <= j - 1 - k1 - k2; k3++)\n      {\n         int k4 = j - 1 - k1 - k2 - k3;\n  z[i][j] += z[i-1][k1] * z[i-1][k2] * z[i-1][k3] * z[i-1][k4];\n  z[i][j] %= mod;\n      }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7497",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #181 (Div.2) - Codeforces - Code 5",
          "code": "for(int i = max; i>=2; i--) {\n if (lp[i] != i) \n  cnt[lp[i]] += cnt[i];\n cnt[i / lp[i]] += cnt[i];\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7497",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #181 (Div.2) - Codeforces - Code 6",
          "code": "for(int i = max; i>=2; i--) {\n if (lp[i] != i) \n  cnt[lp[i]] += cnt[i];\n cnt[i / lp[i]] += cnt[i];\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7497",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #181 (Div.2) - Codeforces - Code 7",
          "code": "for(int j=0; j<=MK; j++)\n                        for(int k=0; k<=MK-j; k++)\n                                d[j+k]+=dp[i][j]*dp[i][k];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7497",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #181 (Div.2) - Codeforces - Code 8",
          "code": "for(int j=0; j<=MK; j++)\n                        for(int k=0; k<=MK-j; k++)\n                                d[j+k]+=dp[i][j]*dp[i][k];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7497",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #181 (Div.2) - Codeforces - Code 9",
          "code": "for(int j=0; j<=MK; j++)\n                        for(int k=0; k<=MK-j; k++)\n                                dp[i+1][j+k+1]+=d[j]*d[k];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7497",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #181 (Div.2) - Codeforces - Code 10",
          "code": "for(int j=0; j<=MK; j++)\n                        for(int k=0; k<=MK-j; k++)\n                                dp[i+1][j+k+1]+=d[j]*d[k];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7497",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #181 (Div.2) - Codeforces - Code 11",
          "code": "for(int i=10000000;i>=2;i--)\n\t{\n\t\tCount[Min[i]]+=Delta[i];\n\t\tDelta[i/Prime[Min[i]]]+=Delta[i];\n\t}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7497",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #181 (Div.2) - Codeforces - Code 12",
          "code": "for(int i=10000000;i>=2;i--)\n\t{\n\t\tCount[Min[i]]+=Delta[i];\n\t\tDelta[i/Prime[Min[i]]]+=Delta[i];\n\t}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7497",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #181 (Div.2) - Codeforces - Code 13",
          "code": "for(int i = 0; i < n; i++) scanf(\"%d\",&a[i]),cnt[a[i]]++,sum+=a[i];\n\tfor(int i = M - 10; i >= 2; i--) cnt[i] += cnt[i+1];\n\tfor(int i = M - 10; i >= 2; i--)\n\t{\n\t\tif(lp[i]!=i) cnt[lp[i]] += cnt[i];\n\t\tcnt[i/lp[i]] += cnt[i];\n\t}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7497",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #181 (Div.2) - Codeforces - Code 14",
          "code": "for(int i = 0; i < n; i++) scanf(\"%d\",&a[i]),cnt[a[i]]++,sum+=a[i];\n\tfor(int i = M - 10; i >= 2; i--) cnt[i] += cnt[i+1];\n\tfor(int i = M - 10; i >= 2; i--)\n\t{\n\t\tif(lp[i]!=i) cnt[lp[i]] += cnt[i];\n\t\tcnt[i/lp[i]] += cnt[i];\n\t}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7497",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #181 (Div.2) - Codeforces - Code 1",
          "code": "int height = 0;\nwhile (n > 1 && n % 2 == 1) {\n n /= 2; height++;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7497",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #181 (Div.2) - Codeforces - Code 2",
          "code": "int height = 0;\nwhile (n > 1 && n % 2 == 1) {\n n /= 2; height++;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7497",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #181 (Div.2) - Codeforces - Code 3",
          "code": "z[0][0] = 1; z[0][i] = 0, i > 0; z[i][0] = 1, i > 0\nz[i][j] = 0;\nfor(int k1 = 0; k1 <= j - 1; k1++) \n  for(int k2 = 0; k2 <= j - 1 - k1; k2++)\n    for(int k3 = 0; k3 <= j - 1 - k1 - k2; k3++)\n      {\n         int k4 = j - 1 - k1 - k2 - k3;\n  z[i][j] += z[i-1][k1] * z[i-1][k2] * z[i-1][k3] * z[i-1][k4];\n  z[i][j] %= mod;\n      }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7497",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #181 (Div.2) - Codeforces - Code 4",
          "code": "z[0][0] = 1; z[0][i] = 0, i > 0; z[i][0] = 1, i > 0\nz[i][j] = 0;\nfor(int k1 = 0; k1 <= j - 1; k1++) \n  for(int k2 = 0; k2 <= j - 1 - k1; k2++)\n    for(int k3 = 0; k3 <= j - 1 - k1 - k2; k3++)\n      {\n         int k4 = j - 1 - k1 - k2 - k3;\n  z[i][j] += z[i-1][k1] * z[i-1][k2] * z[i-1][k3] * z[i-1][k4];\n  z[i][j] %= mod;\n      }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7497",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #181 (Div.2) - Codeforces - Code 5",
          "code": "for(int i = max; i>=2; i--) {\n if (lp[i] != i) \n  cnt[lp[i]] += cnt[i];\n cnt[i / lp[i]] += cnt[i];\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7497",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #181 (Div.2) - Codeforces - Code 6",
          "code": "for(int i = max; i>=2; i--) {\n if (lp[i] != i) \n  cnt[lp[i]] += cnt[i];\n cnt[i / lp[i]] += cnt[i];\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7497",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #181 (Div.2) - Codeforces - Code 7",
          "code": "for(int j=0; j<=MK; j++)\n                        for(int k=0; k<=MK-j; k++)\n                                d[j+k]+=dp[i][j]*dp[i][k];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7497",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #181 (Div.2) - Codeforces - Code 8",
          "code": "for(int j=0; j<=MK; j++)\n                        for(int k=0; k<=MK-j; k++)\n                                d[j+k]+=dp[i][j]*dp[i][k];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7497",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #181 (Div.2) - Codeforces - Code 9",
          "code": "for(int j=0; j<=MK; j++)\n                        for(int k=0; k<=MK-j; k++)\n                                dp[i+1][j+k+1]+=d[j]*d[k];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7497",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #181 (Div.2) - Codeforces - Code 10",
          "code": "for(int j=0; j<=MK; j++)\n                        for(int k=0; k<=MK-j; k++)\n                                dp[i+1][j+k+1]+=d[j]*d[k];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7497",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #181 (Div.2) - Codeforces - Code 11",
          "code": "for(int i=10000000;i>=2;i--)\n\t{\n\t\tCount[Min[i]]+=Delta[i];\n\t\tDelta[i/Prime[Min[i]]]+=Delta[i];\n\t}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7497",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #181 (Div.2) - Codeforces - Code 12",
          "code": "for(int i=10000000;i>=2;i--)\n\t{\n\t\tCount[Min[i]]+=Delta[i];\n\t\tDelta[i/Prime[Min[i]]]+=Delta[i];\n\t}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7497",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #181 (Div.2) - Codeforces - Code 13",
          "code": "for(int i = 0; i < n; i++) scanf(\"%d\",&a[i]),cnt[a[i]]++,sum+=a[i];\n\tfor(int i = M - 10; i >= 2; i--) cnt[i] += cnt[i+1];\n\tfor(int i = M - 10; i >= 2; i--)\n\t{\n\t\tif(lp[i]!=i) cnt[lp[i]] += cnt[i];\n\t\tcnt[i/lp[i]] += cnt[i];\n\t}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7497",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #181 (Div.2) - Codeforces - Code 14",
          "code": "for(int i = 0; i < n; i++) scanf(\"%d\",&a[i]),cnt[a[i]]++,sum+=a[i];\n\tfor(int i = M - 10; i >= 2; i--) cnt[i] += cnt[i+1];\n\tfor(int i = M - 10; i >= 2; i--)\n\t{\n\t\tif(lp[i]!=i) cnt[lp[i]] += cnt[i];\n\t\tcnt[i/lp[i]] += cnt[i];\n\t}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7497",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(3, 100, \"n\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, -1000, 1000, \"a_i\");\n    inf.readEoln();\n\n    set<int> s(a.begin(), a.end());\n    ensuref((int)s.size() == n, \"Elements a_i should be distinct\");\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(3, 100, \"n\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, -1000, 1000, \"a_i\");\n    inf.readEoln();\n\n    set<int> s(a.begin(), a.end());\n    ensuref((int)s.size() == n, \"Elements a_i should be distinct\");\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(3, 100, \"n\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, -1000, 1000, \"a_i\");\n    inf.readEoln();\n\n    set<int> s(a.begin(), a.end());\n    ensuref((int)s.size() == n, \"Elements a_i should be distinct\");\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\n// Returns +1 if product > 0, -1 if product < 0, 0 if product = 0.\nint getProductSign(const vector<int> &subset) {\n    bool hasZero = false;\n    int negCount = 0;\n    for (int x : subset) {\n        if (x == 0) {\n            hasZero = true;\n            break;\n        }\n        if (x < 0) {\n            negCount++;\n        }\n    }\n    if (hasZero) return 0;\n    return (negCount % 2 == 0) ? +1 : -1;\n}\n\nint main(int argc, char *argv[]) {\n    registerTestlibCmd(argc, argv);\n\n    // 1) Read input (n and its distinct integers).\n    int n = inf.readInt(3, 100, \"n\");\n    vector<int> arr(n);\n\n    // Store frequency of each value; must be used exactly once by the output partition.\n    unordered_map<int,int> freq;\n    freq.reserve(n);\n\n    for (int i = 0; i < n; i++) {\n        arr[i] = inf.readInt(-1000, 1000, \"arr[i]\");\n        freq[arr[i]]++;\n    }\n\n    // 2) Read the output sets from the contestant:\n    //    First line: n1, then n1 integers.\n    int n1 = ouf.readInt(1, n, \"n1\");\n    vector<int> s1(n1);\n    for (int i = 0; i < n1; i++) {\n        s1[i] = ouf.readInt(-1000, 1000, \"first_set_element\");\n    }\n\n    //    Second line: n2, then n2 integers.\n    int n2 = ouf.readInt(1, n, \"n2\");\n    vector<int> s2(n2);\n    for (int i = 0; i < n2; i++) {\n        s2[i] = ouf.readInt(-1000, 1000, \"second_set_element\");\n    }\n\n    //    Third line: n3, then n3 integers.\n    int n3 = ouf.readInt(1, n, \"n3\");\n    vector<int> s3(n3);\n    for (int i = 0; i < n3; i++) {\n        s3[i] = ouf.readInt(-1000, 1000, \"third_set_element\");\n    }\n\n    // 3) Skip leftover whitespace. If something remains (like \".\"), read leftover line and fail.\n    ouf.skipBlanks();\n    if (!ouf.eof()) {\n        string leftover = ouf.readLine();\n        // Trim trailing spaces/tabs.\n        while (!leftover.empty() && isspace((unsigned char) leftover.back())) {\n            leftover.pop_back();\n        }\n        if (!leftover.empty()) {\n            ouf.quitf(_wa, \"unexpected extra data found in contestant's output: \\\"%s\\\"\", leftover.c_str());\n        }\n    }\n\n    // 4) Check that the total number of elements in the sets equals n.\n    if ((n1 + n2 + n3) != n) {\n        ouf.quitf(_wa, \"the total number of elements in the three sets is %d, while n = %d\",\n                  (n1 + n2 + n3), n);\n    }\n\n    // 5) Verify that every element from the input is used exactly once.\n    auto useElement = [&](int x) {\n        if (!freq.count(x) || freq[x] == 0) {\n            ouf.quitf(_wa, \"element %d is either not in the input array or is repeated\", x);\n        }\n        freq[x]--;\n    };\n\n    for (int x : s1) useElement(x);\n    for (int x : s2) useElement(x);\n    for (int x : s3) useElement(x);\n\n    // 6) Check that set1 has product < 0, set2 has product > 0, and set3 has product = 0.\n    if (getProductSign(s1) >= 0) {\n        ouf.quitf(_wa, \"product of the first set is not negative\");\n    }\n    if (getProductSign(s2) <= 0) {\n        ouf.quitf(_wa, \"product of the second set is not positive\");\n    }\n    if (getProductSign(s3) != 0) {\n        ouf.quitf(_wa, \"product of the third set is not zero\");\n    }\n\n    // 7) If all checks pass, accept the solution.\n    ouf.quitf(_ok, \"partition is valid\");\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAX_ABS_A = 1000;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    set<int> used_numbers;\n    vector<int> a;\n\n    if (type == \"random_with_zero\") {\n        // Include zero\n        a.push_back(0);\n        used_numbers.insert(0);\n\n        while ((int)a.size() < n) {\n            int x = rnd.next(-MAX_ABS_A, MAX_ABS_A);\n            if (x == 0 || used_numbers.count(x)) continue;\n            a.push_back(x);\n            used_numbers.insert(x);\n        }\n        \n        shuffle(a.begin(), a.end());\n    } else if (type == \"random_no_zero\") {\n        // No zero, ensure enough negative numbers for the solution\n        int neg_cnt = max(3, n / 2); // Ensure at least 3 negatives\n        neg_cnt = min(neg_cnt, n - 2);\n\n        int pos_cnt = n - neg_cnt;\n\n        // Add negative numbers\n        while ((int)a.size() < neg_cnt) {\n            int x = -rnd.next(1, MAX_ABS_A);\n            if (used_numbers.count(x)) continue;\n            a.push_back(x);\n            used_numbers.insert(x);\n        }\n        // Add positive numbers\n        while ((int)a.size() < n) {\n            int x = rnd.next(1, MAX_ABS_A);\n            if (used_numbers.count(x)) continue;\n            a.push_back(x);\n            used_numbers.insert(x);\n        }\n\n        shuffle(a.begin(), a.end());\n\n    } else if (type == \"all_negatives\") {\n        // All negative numbers, include zero to ensure solution exists\n        a.push_back(0); // Add zero\n        used_numbers.insert(0);\n\n        while ((int)a.size() < n) {\n            int x = -rnd.next(1, MAX_ABS_A);\n            if (used_numbers.count(x)) continue;\n            a.push_back(x);\n            used_numbers.insert(x);\n        }\n\n        shuffle(a.begin(), a.end());\n    } else if (type == \"all_positives_one_negative\") {\n        // All positive numbers, include one negative and one zero to ensure solution exists\n        int neg = -rnd.next(1, MAX_ABS_A);\n        used_numbers.insert(neg);\n        a.push_back(neg);\n\n        int zero = 0;\n        used_numbers.insert(zero);\n        a.push_back(zero);\n\n        while ((int)a.size() < n) {\n            int x = rnd.next(1, MAX_ABS_A);\n            if (used_numbers.count(x)) continue;\n            a.push_back(x);\n            used_numbers.insert(x);\n        }\n\n        shuffle(a.begin(), a.end());\n    } else if (type == \"max_n\") {\n        n = 100;\n        a.push_back(0); // Include zero to ensure solution exists\n        used_numbers.insert(0);\n\n        while ((int)a.size() < n) {\n            int x = rnd.next(-MAX_ABS_A, MAX_ABS_A);\n            if (x == 0 || used_numbers.count(x)) continue;\n            a.push_back(x);\n            used_numbers.insert(x);\n        }\n\n        shuffle(a.begin(), a.end());\n    } else if (type == \"min_n\") {\n        n = 3; \n        a.push_back(0); // Include zero to ensure solution exists\n        used_numbers.insert(0);\n\n        while ((int)a.size() < n) {\n            int x = rnd.next(-MAX_ABS_A, MAX_ABS_A);\n            if (x == 0 || used_numbers.count(x)) continue;\n            a.push_back(x);\n            used_numbers.insert(x);\n        }\n        shuffle(a.begin(), a.end());\n    }\n\n    printf(\"%d\\n\", n);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d%c\", a[i], i+1==n?'\\n':' ');\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAX_ABS_A = 1000;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    set<int> used_numbers;\n    vector<int> a;\n\n    if (type == \"random_with_zero\") {\n        // Include zero\n        a.push_back(0);\n        used_numbers.insert(0);\n\n        while ((int)a.size() < n) {\n            int x = rnd.next(-MAX_ABS_A, MAX_ABS_A);\n            if (x == 0 || used_numbers.count(x)) continue;\n            a.push_back(x);\n            used_numbers.insert(x);\n        }\n        \n        shuffle(a.begin(), a.end());\n    } else if (type == \"random_no_zero\") {\n        // No zero, ensure enough negative numbers for the solution\n        int neg_cnt = max(3, n / 2); // Ensure at least 3 negatives\n        neg_cnt = min(neg_cnt, n - 2);\n\n        int pos_cnt = n - neg_cnt;\n\n        // Add negative numbers\n        while ((int)a.size() < neg_cnt) {\n            int x = -rnd.next(1, MAX_ABS_A);\n            if (used_numbers.count(x)) continue;\n            a.push_back(x);\n            used_numbers.insert(x);\n        }\n        // Add positive numbers\n        while ((int)a.size() < n) {\n            int x = rnd.next(1, MAX_ABS_A);\n            if (used_numbers.count(x)) continue;\n            a.push_back(x);\n            used_numbers.insert(x);\n        }\n\n        shuffle(a.begin(), a.end());\n\n    } else if (type == \"all_negatives\") {\n        // All negative numbers, include zero to ensure solution exists\n        a.push_back(0); // Add zero\n        used_numbers.insert(0);\n\n        while ((int)a.size() < n) {\n            int x = -rnd.next(1, MAX_ABS_A);\n            if (used_numbers.count(x)) continue;\n            a.push_back(x);\n            used_numbers.insert(x);\n        }\n\n        shuffle(a.begin(), a.end());\n    } else if (type == \"all_positives_one_negative\") {\n        // All positive numbers, include one negative and one zero to ensure solution exists\n        int neg = -rnd.next(1, MAX_ABS_A);\n        used_numbers.insert(neg);\n        a.push_back(neg);\n\n        int zero = 0;\n        used_numbers.insert(zero);\n        a.push_back(zero);\n\n        while ((int)a.size() < n) {\n            int x = rnd.next(1, MAX_ABS_A);\n            if (used_numbers.count(x)) continue;\n            a.push_back(x);\n            used_numbers.insert(x);\n        }\n\n        shuffle(a.begin(), a.end());\n    } else if (type == \"max_n\") {\n        n = 100;\n        a.push_back(0); // Include zero to ensure solution exists\n        used_numbers.insert(0);\n\n        while ((int)a.size() < n) {\n            int x = rnd.next(-MAX_ABS_A, MAX_ABS_A);\n            if (x == 0 || used_numbers.count(x)) continue;\n            a.push_back(x);\n            used_numbers.insert(x);\n        }\n\n        shuffle(a.begin(), a.end());\n    } else if (type == \"min_n\") {\n        n = 3; \n        a.push_back(0); // Include zero to ensure solution exists\n        used_numbers.insert(0);\n\n        while ((int)a.size() < n) {\n            int x = rnd.next(-MAX_ABS_A, MAX_ABS_A);\n            if (x == 0 || used_numbers.count(x)) continue;\n            a.push_back(x);\n            used_numbers.insert(x);\n        }\n        shuffle(a.begin(), a.end());\n    }\n\n    printf(\"%d\\n\", n);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d%c\", a[i], i+1==n?'\\n':' ');\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 3 -type min_n\n./gen -n 100 -type max_n\n\n./gen -n 10 -type random_with_zero\n./gen -n 10 -type random_no_zero\n./gen -n 10 -type all_negatives\n./gen -n 10 -type all_positives_one_negative\n\n./gen -n 25 -type random_with_zero\n./gen -n 25 -type random_no_zero\n./gen -n 25 -type all_negatives\n./gen -n 25 -type all_positives_one_negative\n\n./gen -n 50 -type random_with_zero\n./gen -n 50 -type random_no_zero\n./gen -n 50 -type all_negatives\n./gen -n 50 -type all_positives_one_negative\n\n./gen -n 75 -type random_with_zero\n./gen -n 75 -type random_no_zero\n./gen -n 75 -type all_negatives\n./gen -n 75 -type all_positives_one_negative\n\n./gen -n 99 -type random_with_zero\n./gen -n 99 -type random_no_zero\n./gen -n 99 -type all_negatives\n./gen -n 99 -type all_positives_one_negative\n\n./gen -n 4 -type random_with_zero\n./gen -n 4 -type random_no_zero\n./gen -n 4 -type all_negatives\n./gen -n 4 -type all_positives_one_negative\n\n./gen -n 50 -type random_with_zero\n./gen -n 50 -type random_no_zero\n./gen -n 50 -type all_negatives\n./gen -n 50 -type all_positives_one_negative\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:04:52.412541",
        "total_tutorials": 3,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "300/B",
      "title": "B. Coach",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line of the input contains integers n and m (3 ≤ n ≤ 48, . Then follow m lines, each contains a pair of integers ai, bi (1 ≤ ai < bi ≤ n) — the pair ai, bi means that students with numbers ai and bi want to be on the same team.It is guaranteed that n is divisible by 3. It is guaranteed that each pair ai, bi occurs in the input at most once.",
      "output_spec": "OutputIf the required division into teams doesn't exist, print number -1. Otherwise, print  lines. In each line print three integers xi, yi, zi (1 ≤ xi, yi, zi ≤ n) — the i-th team. If there are multiple answers, you are allowed to print any of them.",
      "sample_tests": "ExamplesInputCopy3 0OutputCopy3 2 1 InputCopy6 41 22 33 45 6OutputCopy-1InputCopy3 31 22 31 3OutputCopy3 2 1",
      "description": "time limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line of the input contains integers n and m (3 ≤ n ≤ 48, . Then follow m lines, each contains a pair of integers ai, bi (1 ≤ ai < bi ≤ n) — the pair ai, bi means that students with numbers ai and bi want to be on the same team.It is guaranteed that n is divisible by 3. It is guaranteed that each pair ai, bi occurs in the input at most once.\n\nOutputIf the required division into teams doesn't exist, print number -1. Otherwise, print  lines. In each line print three integers xi, yi, zi (1 ≤ xi, yi, zi ≤ n) — the i-th team. If there are multiple answers, you are allowed to print any of them.\n\nInputCopy3 0OutputCopy3 2 1 InputCopy6 41 22 33 45 6OutputCopy-1InputCopy3 31 22 31 3OutputCopy3 2 1\n\nInputCopy3 0\n\nOutputCopy3 2 1\n\nInputCopy6 41 22 33 45 6\n\nOutputCopy-1\n\nInputCopy3 31 22 31 3\n\nOutputCopy3 2 1",
      "solutions": [
        {
          "title": "Codeforces Round #181 (Div. 2) - Codeforces",
          "content": "Hello!A few hours later, 25 апреля в 19:30 MSK, you are lucky to participate in Codeforces Round #181 for Div. 2 participants. Traditionally, Div. 1 participants can take part out of the competition.Problems have been prepared by: Gridnev Vitaliy (gridnevvvit), Ignatyev Alexander (aiMR). We want to thank Gerald Agapov(Gerald) for help in preparation of this round, Michael Mirzayanov(MikeMirzayanov) for marvelous Codeforces and Polygon systems, Mary Belova(Delinur) for translating the problems.About authors: me and Alexander are third year students of Mathematics Department, Saratov State University. It’s our first round and I hope not last.We hope you will like these problems, and that it will be fun to solve them. Also we strongly recommend you to read all the problems.We wish everyone good luck and high rating!UPD: Scoring will be dynamic. Problems are sorted by increasing order of difficulty.UPD1: Editorial hereUPD2: Contest finished. Congratulations to winners: ballmaids02 VIProgrammer emachaidze",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/7479",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1015
        },
        {
          "title": "Editorial Codeforces Round #181 (Div.2) - Codeforces",
          "content": "300A - ArrayIn this problem you just need to implement following algorithm. Split input data into 3 vectors: first will contain negative numbers, second positive numbers, third zeroes. If size of first vector is even move one number from it to the third vector. If second vector is empty, then move two numbers from first vector to the second vector. This solution works in O(n).Аuthor's solution300B - CoachInput data represents a graph. If there is a connected component with at least 4 vertexes, then answer is  - 1. Every connected component with 3 vertexes is a complete team. Other teams are made from 1 or 2-vertex components. If amount of 2-vertex components is greater than 1-vertex answer is  - 1. Otherwise match 2-vertex components with 1-vertex. If there are some 1-vertex components left then split them into groups of three. This algorithm works in O(n + m). Also you could implement O(n4) solution.Аuthor's solution300C - Beautiful NumbersLet's MOD = 1000000007. Let's precalc factorial values modulo MOD. fact[i] = i!%MOD, . Let i be an amount of digits equal to a in current excellent number. In this case we can find sum of digits in this number: sum = ai + b(n - i). If sum is good, then add C[n][i] to answer. In this problem it's impossible to calculate binomial coefficients using Pascal's triangle, because of large n. However it can be done this way C[n][i] = fact[n]inv(fact[n - i]fact[i]). inv(a) is multiplicative inverse element(modulo MOD). MOD is a prime number, so inv(a) = aMOD - 2. Calculating this values for each i from 0 to n will give correct answer in O(nlog(MOD)).Аuthor's solution300D - Painting SquareThis picture is helpful for understanding.Let's consider problem D in graph terms:We have matrix n × n, which represents a graph: It is tree. Every vertex, except leaves, has 4 children. There are 4k distinct vertexes, with distance k from root. We need to color k vertexes of this graph. By that we mean also to color all vertexes on path from i to 1(root).Knowing height of tree we can build it in unique way. Let's find height of tree in this way: int height = 0;\nwhile (n > 1 && n % 2 == 1) {\n n /= 2; height++;\n}Let's consider following DP: z[i][j] — number of ways to color graph height i in j steps.Naive solution in O(k4log(n)): z[0][0] = 1; z[0][i] = 0, i > 0; z[i][0] = 1, i > 0\nz[i][j] = 0;\nfor(int k1 = 0; k1 <= j - 1; k1++) \n for(int k2 = 0; k2 <= j - 1 - k1; k2++)\n for(int k3 = 0; k3 <= j - 1 - k1 - k2; k3++)\n {\n int k4 = j - 1 - k1 - k2 - k3;\n z[i][j] += z[i-1][k1] * z[i-1][k2] * z[i-1][k3] * z[i-1][k4];\n z[i][j] %= mod;\n }But it is not what we whant in time terms. Let's consider current DP as polynomial coefficients: z[i][j] — coefficient of power j of polynomial i. In that case z[i + 1][j + 1] — coefficient of power j of polynomial i to the 4-th power. This approach allows to solve problem in O(k2log(n)). However this solution is quite slow, because of modulo operations. As you see, this modulo is not so big ( ≤ 107), that allows us to reduce number of modulo operations, thus giving huge perfomance boost. Also it is possible to use FFT to solve in O(klog(k)log(n)).Аuthor's solution. Uses FFTАuthor's solution. Without FFT300E - Empire Strikes BackLet's . val is upper bound for answer. val! is divisible by , you can easily prove it using facts about prime powers in factorial and following inequality . By the way, is called multinomial coefficient. So answer can't exceed 1013. If n! divisible by den, then (n + 1)! is also divisible by den. That means that function of divisibility is monotonic and we can use binary search.For every i, i = 2..., 107, let's precalc max prime in i using linear sieve of Eratosthenes. For i it will be lp[i]. After that let's create a vector, with all primes less then 107.Now let's calculate following values cnt[i] — amount of numbers a, i <  = a.Now me can factorize denominator like this: for(int i = max; i>=2; i--) {\n if (lp[i] != i) \n cnt[lp[i]] += cnt[i];\n cnt[i / lp[i]] += cnt[i];\n}Finally we use binary search from lf = 1 to .Аuthor's solution",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/7497",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 300\\s*B"
          },
          "content_length": 4064
        },
        {
          "title": "Editorial Codeforces Round #181 (Div.2) - Codeforces",
          "content": "300A - ArrayIn this problem you just need to implement following algorithm. Split input data into 3 vectors: first will contain negative numbers, second positive numbers, third zeroes. If size of first vector is even move one number from it to the third vector. If second vector is empty, then move two numbers from first vector to the second vector. This solution works in O(n).Аuthor's solution300B - CoachInput data represents a graph. If there is a connected component with at least 4 vertexes, then answer is  - 1. Every connected component with 3 vertexes is a complete team. Other teams are made from 1 or 2-vertex components. If amount of 2-vertex components is greater than 1-vertex answer is  - 1. Otherwise match 2-vertex components with 1-vertex. If there are some 1-vertex components left then split them into groups of three. This algorithm works in O(n + m). Also you could implement O(n4) solution.Аuthor's solution300C - Beautiful NumbersLet's MOD = 1000000007. Let's precalc factorial values modulo MOD. fact[i] = i!%MOD, . Let i be an amount of digits equal to a in current excellent number. In this case we can find sum of digits in this number: sum = ai + b(n - i). If sum is good, then add C[n][i] to answer. In this problem it's impossible to calculate binomial coefficients using Pascal's triangle, because of large n. However it can be done this way C[n][i] = fact[n]inv(fact[n - i]fact[i]). inv(a) is multiplicative inverse element(modulo MOD). MOD is a prime number, so inv(a) = aMOD - 2. Calculating this values for each i from 0 to n will give correct answer in O(nlog(MOD)).Аuthor's solution300D - Painting SquareThis picture is helpful for understanding.Let's consider problem D in graph terms:We have matrix n × n, which represents a graph: It is tree. Every vertex, except leaves, has 4 children. There are 4k distinct vertexes, with distance k from root. We need to color k vertexes of this graph. By that we mean also to color all vertexes on path from i to 1(root).Knowing height of tree we can build it in unique way. Let's find height of tree in this way: int height = 0;\nwhile (n > 1 && n % 2 == 1) {\n n /= 2; height++;\n}Let's consider following DP: z[i][j] — number of ways to color graph height i in j steps.Naive solution in O(k4log(n)): z[0][0] = 1; z[0][i] = 0, i > 0; z[i][0] = 1, i > 0\nz[i][j] = 0;\nfor(int k1 = 0; k1 <= j - 1; k1++) \n for(int k2 = 0; k2 <= j - 1 - k1; k2++)\n for(int k3 = 0; k3 <= j - 1 - k1 - k2; k3++)\n {\n int k4 = j - 1 - k1 - k2 - k3;\n z[i][j] += z[i-1][k1] * z[i-1][k2] * z[i-1][k3] * z[i-1][k4];\n z[i][j] %= mod;\n }But it is not what we whant in time terms. Let's consider current DP as polynomial coefficients: z[i][j] — coefficient of power j of polynomial i. In that case z[i + 1][j + 1] — coefficient of power j of polynomial i to the 4-th power. This approach allows to solve problem in O(k2log(n)). However this solution is quite slow, because of modulo operations. As you see, this modulo is not so big ( ≤ 107), that allows us to reduce number of modulo operations, thus giving huge perfomance boost. Also it is possible to use FFT to solve in O(klog(k)log(n)).Аuthor's solution. Uses FFTАuthor's solution. Without FFT300E - Empire Strikes BackLet's . val is upper bound for answer. val! is divisible by , you can easily prove it using facts about prime powers in factorial and following inequality . By the way, is called multinomial coefficient. So answer can't exceed 1013. If n! divisible by den, then (n + 1)! is also divisible by den. That means that function of divisibility is monotonic and we can use binary search.For every i, i = 2..., 107, let's precalc max prime in i using linear sieve of Eratosthenes. For i it will be lp[i]. After that let's create a vector, with all primes less then 107.Now let's calculate following values cnt[i] — amount of numbers a, i <  = a.Now me can factorize denominator like this: for(int i = max; i>=2; i--) {\n if (lp[i] != i) \n cnt[lp[i]] += cnt[i];\n cnt[i / lp[i]] += cnt[i];\n}Finally we use binary search from lf = 1 to .Аuthor's solution",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/7497",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 300\\s*B"
          },
          "content_length": 4064
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #181 (Div. 2) - Codeforces - Code 1",
          "code": "WTF???\nUPD: he has already -179 hacks...",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7479",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #181 (Div. 2) - Codeforces - Code 2",
          "code": "WTF???\nUPD: he has already -179 hacks...",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7479",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #181 (Div. 2) - Codeforces - Code 3",
          "code": "// ax + by = gcd(a,b) = d\nvoid eea(int a, int b, int& x, int& y, int& d) {\n    if (!b) {x = 1; y = 0; d = a; return; }\n    eea(b, a % b, x, y, d);\n    int x1 = y, y1 = x - (a / b) * y;\n    x = x1, y = y1;\n}\nint divide(int a, int b) {\n    int d, x, y;\n    eea(b, MOD, x, y, d);\n    // if(a%d==0)\n    return ((x+MOD)*(a/d)) % (MOD/d);\n    // else   \"no quotient\"\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7479",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #181 (Div. 2) - Codeforces - Code 4",
          "code": "// ax + by = gcd(a,b) = d\nvoid eea(int a, int b, int& x, int& y, int& d) {\n    if (!b) {x = 1; y = 0; d = a; return; }\n    eea(b, a % b, x, y, d);\n    int x1 = y, y1 = x - (a / b) * y;\n    x = x1, y = y1;\n}\nint divide(int a, int b) {\n    int d, x, y;\n    eea(b, MOD, x, y, d);\n    // if(a%d==0)\n    return ((x+MOD)*(a/d)) % (MOD/d);\n    // else   \"no quotient\"\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7479",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #181 (Div.2) - Codeforces - Code 1",
          "code": "int height = 0;\nwhile (n > 1 && n % 2 == 1) {\n n /= 2; height++;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7497",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #181 (Div.2) - Codeforces - Code 2",
          "code": "int height = 0;\nwhile (n > 1 && n % 2 == 1) {\n n /= 2; height++;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7497",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #181 (Div.2) - Codeforces - Code 3",
          "code": "z[0][0] = 1; z[0][i] = 0, i > 0; z[i][0] = 1, i > 0\nz[i][j] = 0;\nfor(int k1 = 0; k1 <= j - 1; k1++) \n  for(int k2 = 0; k2 <= j - 1 - k1; k2++)\n    for(int k3 = 0; k3 <= j - 1 - k1 - k2; k3++)\n      {\n         int k4 = j - 1 - k1 - k2 - k3;\n  z[i][j] += z[i-1][k1] * z[i-1][k2] * z[i-1][k3] * z[i-1][k4];\n  z[i][j] %= mod;\n      }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7497",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #181 (Div.2) - Codeforces - Code 4",
          "code": "z[0][0] = 1; z[0][i] = 0, i > 0; z[i][0] = 1, i > 0\nz[i][j] = 0;\nfor(int k1 = 0; k1 <= j - 1; k1++) \n  for(int k2 = 0; k2 <= j - 1 - k1; k2++)\n    for(int k3 = 0; k3 <= j - 1 - k1 - k2; k3++)\n      {\n         int k4 = j - 1 - k1 - k2 - k3;\n  z[i][j] += z[i-1][k1] * z[i-1][k2] * z[i-1][k3] * z[i-1][k4];\n  z[i][j] %= mod;\n      }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7497",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #181 (Div.2) - Codeforces - Code 5",
          "code": "for(int i = max; i>=2; i--) {\n if (lp[i] != i) \n  cnt[lp[i]] += cnt[i];\n cnt[i / lp[i]] += cnt[i];\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7497",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #181 (Div.2) - Codeforces - Code 6",
          "code": "for(int i = max; i>=2; i--) {\n if (lp[i] != i) \n  cnt[lp[i]] += cnt[i];\n cnt[i / lp[i]] += cnt[i];\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7497",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #181 (Div.2) - Codeforces - Code 7",
          "code": "for(int j=0; j<=MK; j++)\n                        for(int k=0; k<=MK-j; k++)\n                                d[j+k]+=dp[i][j]*dp[i][k];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7497",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #181 (Div.2) - Codeforces - Code 8",
          "code": "for(int j=0; j<=MK; j++)\n                        for(int k=0; k<=MK-j; k++)\n                                d[j+k]+=dp[i][j]*dp[i][k];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7497",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #181 (Div.2) - Codeforces - Code 9",
          "code": "for(int j=0; j<=MK; j++)\n                        for(int k=0; k<=MK-j; k++)\n                                dp[i+1][j+k+1]+=d[j]*d[k];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7497",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #181 (Div.2) - Codeforces - Code 10",
          "code": "for(int j=0; j<=MK; j++)\n                        for(int k=0; k<=MK-j; k++)\n                                dp[i+1][j+k+1]+=d[j]*d[k];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7497",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #181 (Div.2) - Codeforces - Code 11",
          "code": "for(int i=10000000;i>=2;i--)\n\t{\n\t\tCount[Min[i]]+=Delta[i];\n\t\tDelta[i/Prime[Min[i]]]+=Delta[i];\n\t}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7497",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #181 (Div.2) - Codeforces - Code 12",
          "code": "for(int i=10000000;i>=2;i--)\n\t{\n\t\tCount[Min[i]]+=Delta[i];\n\t\tDelta[i/Prime[Min[i]]]+=Delta[i];\n\t}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7497",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #181 (Div.2) - Codeforces - Code 13",
          "code": "for(int i = 0; i < n; i++) scanf(\"%d\",&a[i]),cnt[a[i]]++,sum+=a[i];\n\tfor(int i = M - 10; i >= 2; i--) cnt[i] += cnt[i+1];\n\tfor(int i = M - 10; i >= 2; i--)\n\t{\n\t\tif(lp[i]!=i) cnt[lp[i]] += cnt[i];\n\t\tcnt[i/lp[i]] += cnt[i];\n\t}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7497",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #181 (Div.2) - Codeforces - Code 14",
          "code": "for(int i = 0; i < n; i++) scanf(\"%d\",&a[i]),cnt[a[i]]++,sum+=a[i];\n\tfor(int i = M - 10; i >= 2; i--) cnt[i] += cnt[i+1];\n\tfor(int i = M - 10; i >= 2; i--)\n\t{\n\t\tif(lp[i]!=i) cnt[lp[i]] += cnt[i];\n\t\tcnt[i/lp[i]] += cnt[i];\n\t}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7497",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #181 (Div.2) - Codeforces - Code 1",
          "code": "int height = 0;\nwhile (n > 1 && n % 2 == 1) {\n n /= 2; height++;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7497",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #181 (Div.2) - Codeforces - Code 2",
          "code": "int height = 0;\nwhile (n > 1 && n % 2 == 1) {\n n /= 2; height++;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7497",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #181 (Div.2) - Codeforces - Code 3",
          "code": "z[0][0] = 1; z[0][i] = 0, i > 0; z[i][0] = 1, i > 0\nz[i][j] = 0;\nfor(int k1 = 0; k1 <= j - 1; k1++) \n  for(int k2 = 0; k2 <= j - 1 - k1; k2++)\n    for(int k3 = 0; k3 <= j - 1 - k1 - k2; k3++)\n      {\n         int k4 = j - 1 - k1 - k2 - k3;\n  z[i][j] += z[i-1][k1] * z[i-1][k2] * z[i-1][k3] * z[i-1][k4];\n  z[i][j] %= mod;\n      }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7497",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #181 (Div.2) - Codeforces - Code 4",
          "code": "z[0][0] = 1; z[0][i] = 0, i > 0; z[i][0] = 1, i > 0\nz[i][j] = 0;\nfor(int k1 = 0; k1 <= j - 1; k1++) \n  for(int k2 = 0; k2 <= j - 1 - k1; k2++)\n    for(int k3 = 0; k3 <= j - 1 - k1 - k2; k3++)\n      {\n         int k4 = j - 1 - k1 - k2 - k3;\n  z[i][j] += z[i-1][k1] * z[i-1][k2] * z[i-1][k3] * z[i-1][k4];\n  z[i][j] %= mod;\n      }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7497",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #181 (Div.2) - Codeforces - Code 5",
          "code": "for(int i = max; i>=2; i--) {\n if (lp[i] != i) \n  cnt[lp[i]] += cnt[i];\n cnt[i / lp[i]] += cnt[i];\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7497",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #181 (Div.2) - Codeforces - Code 6",
          "code": "for(int i = max; i>=2; i--) {\n if (lp[i] != i) \n  cnt[lp[i]] += cnt[i];\n cnt[i / lp[i]] += cnt[i];\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7497",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #181 (Div.2) - Codeforces - Code 7",
          "code": "for(int j=0; j<=MK; j++)\n                        for(int k=0; k<=MK-j; k++)\n                                d[j+k]+=dp[i][j]*dp[i][k];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7497",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #181 (Div.2) - Codeforces - Code 8",
          "code": "for(int j=0; j<=MK; j++)\n                        for(int k=0; k<=MK-j; k++)\n                                d[j+k]+=dp[i][j]*dp[i][k];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7497",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #181 (Div.2) - Codeforces - Code 9",
          "code": "for(int j=0; j<=MK; j++)\n                        for(int k=0; k<=MK-j; k++)\n                                dp[i+1][j+k+1]+=d[j]*d[k];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7497",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #181 (Div.2) - Codeforces - Code 10",
          "code": "for(int j=0; j<=MK; j++)\n                        for(int k=0; k<=MK-j; k++)\n                                dp[i+1][j+k+1]+=d[j]*d[k];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7497",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #181 (Div.2) - Codeforces - Code 11",
          "code": "for(int i=10000000;i>=2;i--)\n\t{\n\t\tCount[Min[i]]+=Delta[i];\n\t\tDelta[i/Prime[Min[i]]]+=Delta[i];\n\t}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7497",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #181 (Div.2) - Codeforces - Code 12",
          "code": "for(int i=10000000;i>=2;i--)\n\t{\n\t\tCount[Min[i]]+=Delta[i];\n\t\tDelta[i/Prime[Min[i]]]+=Delta[i];\n\t}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7497",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #181 (Div.2) - Codeforces - Code 13",
          "code": "for(int i = 0; i < n; i++) scanf(\"%d\",&a[i]),cnt[a[i]]++,sum+=a[i];\n\tfor(int i = M - 10; i >= 2; i--) cnt[i] += cnt[i+1];\n\tfor(int i = M - 10; i >= 2; i--)\n\t{\n\t\tif(lp[i]!=i) cnt[lp[i]] += cnt[i];\n\t\tcnt[i/lp[i]] += cnt[i];\n\t}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7497",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #181 (Div.2) - Codeforces - Code 14",
          "code": "for(int i = 0; i < n; i++) scanf(\"%d\",&a[i]),cnt[a[i]]++,sum+=a[i];\n\tfor(int i = M - 10; i >= 2; i--) cnt[i] += cnt[i+1];\n\tfor(int i = M - 10; i >= 2; i--)\n\t{\n\t\tif(lp[i]!=i) cnt[lp[i]] += cnt[i];\n\t\tcnt[i/lp[i]] += cnt[i];\n\t}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7497",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(3, 48, \"n\");\n    ensuref(n % 3 == 0, \"n must be divisible by 3\");\n    inf.readSpace();\n    int m = inf.readInt(0, n*(n-1)/2, \"m\");\n    inf.readEoln();\n    set<pair<int, int>> edges;\n    for (int i = 0; i < m; i++) {\n        int ai = inf.readInt(1, n, \"ai\");\n        inf.readSpace();\n        int bi = inf.readInt(1, n, \"bi\");\n        inf.readEoln();\n        ensuref(ai < bi, \"ai must be less than bi\");\n        pair<int, int> p = make_pair(ai, bi);\n        ensuref(edges.count(p) == 0, \"Pair (%d, %d) occurs multiple times\", ai, bi);\n        edges.insert(p);\n    }\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(3, 48, \"n\");\n    ensuref(n % 3 == 0, \"n must be divisible by 3\");\n    inf.readSpace();\n    int m = inf.readInt(0, n*(n-1)/2, \"m\");\n    inf.readEoln();\n    set<pair<int, int>> edges;\n    for (int i = 0; i < m; i++) {\n        int ai = inf.readInt(1, n, \"ai\");\n        inf.readSpace();\n        int bi = inf.readInt(1, n, \"bi\");\n        inf.readEoln();\n        ensuref(ai < bi, \"ai must be less than bi\");\n        pair<int, int> p = make_pair(ai, bi);\n        ensuref(edges.count(p) == 0, \"Pair (%d, %d) occurs multiple times\", ai, bi);\n        edges.insert(p);\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(3, 48, \"n\");\n    ensuref(n % 3 == 0, \"n must be divisible by 3\");\n    inf.readSpace();\n    int m = inf.readInt(0, n*(n-1)/2, \"m\");\n    inf.readEoln();\n    set<pair<int, int>> edges;\n    for (int i = 0; i < m; i++) {\n        int ai = inf.readInt(1, n, \"ai\");\n        inf.readSpace();\n        int bi = inf.readInt(1, n, \"bi\");\n        inf.readEoln();\n        ensuref(ai < bi, \"ai must be less than bi\");\n        pair<int, int> p = make_pair(ai, bi);\n        ensuref(edges.count(p) == 0, \"Pair (%d, %d) occurs multiple times\", ai, bi);\n        edges.insert(p);\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nstruct Edge {\n    int a, b;\n};\n\nint n, m;\nvector<Edge> wants;\n\n// Safely parse a string as a 64-bit integer. Quit with _wa if it fails.\nlong long toLongLongOrWA(InStream &stream, const string &s)\n{\n    if (s.empty())\n        stream.quitf(_wa, \"Empty token where integer was expected\");\n\n    char *endptr;\n    long long val = strtoll(s.c_str(), &endptr, 10);\n    if (*endptr != '\\0')\n        stream.quitf(_wa, \"Expected integer but found '%s'\", s.c_str());\n\n    return val;\n}\n\n// Reads the participant (or jury) output.\n// Returns an empty vector if the output is \"-1\", signifying impossibility.\n// Otherwise returns a vector of size (n/3), each containing 3 distinct integers in [1..n].\n// If anything is invalid, calls stream.quitf(_wa) if participant solution is invalid,\n// or _fail if the jury solution is invalid. (testlib automatically changes _wa -> _fail internally\n// if it's the jury’s output that is invalid, so we can just use _wa for convenience.)\nvector<vector<int>> readSolution(InStream &stream, bool &impossible)\n{\n    if (stream.eof())\n        stream.quitf(_wa, \"No output at all\");\n\n    // Try reading the first token\n    string firstToken = stream.readToken();\n\n    // Check if it's -1\n    if (firstToken == \"-1\")\n    {\n        // Mark impossible, and ensure there's no more non-whitespace content\n        impossible = true;\n\n        // We will allow whitespace after -1, but no more tokens.\n        // If we can read *any* token after this, it's extra output.\n        while (!stream.eof())\n        {\n            char c = stream.readChar();\n            if (!isspace(c))\n                stream.quitf(_wa, \"Unexpected extra data after -1\");\n        }\n        return {};\n    }\n    else\n    {\n        // It's not -1; parse it as a student number\n        impossible = false;\n        long long x1 = toLongLongOrWA(stream, firstToken);\n        if (x1 < 1 || x1 > n)\n            stream.quitf(_wa, \"Invalid student number %lld (should be in [1..%d])\", x1, n);\n\n        // We read exactly n/3 teams. We already read one student from the first team.\n        vector<vector<int>> teams;\n        teams.reserve(n / 3);\n\n        int a1 = (int)x1;\n        int a2 = stream.readInt(1, n, \"team student\");\n        int a3 = stream.readInt(1, n, \"team student\");\n        if (a1 == a2 || a1 == a3 || a2 == a3)\n            stream.quitf(_wa, \"Repeated student in the same team: %d %d %d\", a1, a2, a3);\n\n        teams.push_back({a1, a2, a3});\n\n        // read the remaining n/3 - 1 teams of 3 integers\n        for (int i = 1; i < n/3; i++)\n        {\n            int b1 = stream.readInt(1, n, \"team student\");\n            int b2 = stream.readInt(1, n, \"team student\");\n            int b3 = stream.readInt(1, n, \"team student\");\n            if (b1 == b2 || b2 == b3 || b1 == b3)\n                stream.quitf(_wa, \"Repeated student in the same team: %d %d %d\", b1, b2, b3);\n\n            teams.push_back({b1, b2, b3});\n        }\n\n        // After reading all n/3 teams, we should have no more non-whitespace content\n        while (!stream.eof())\n        {\n            char c = stream.readChar();\n            if (!isspace(c))\n                stream.quitf(_wa, \"Unexpected extra output after reading n/3 teams\");\n        }\n\n        // Check that each student is used exactly once\n        vector<int> used(n+1, 0);\n        for (auto &tm : teams)\n            for (int mem : tm)\n                used[mem]++;\n        for (int i = 1; i <= n; i++)\n            if (used[i] != 1)\n                stream.quitf(_wa,\n                    \"Each student must appear exactly once; student %d appears %d time(s)\",\n                    i, used[i]);\n\n        // Check that every pair wanting to be together is indeed in the same team\n        // We'll map each student to its team\n        vector<int> teamOf(n+1);\n        for (int i = 0; i < (int)teams.size(); i++)\n        {\n            for (int x : teams[i])\n                teamOf[x] = i;\n        }\n\n        for (auto &ed : wants)\n        {\n            if (teamOf[ed.a] != teamOf[ed.b])\n                stream.quitf(_wa,\n                    \"Students %d and %d want to be on the same team but are in different teams\",\n                    ed.a, ed.b);\n        }\n\n        return teams;\n    }\n}\n\nint main(int argc, char* argv[])\n{\n    registerTestlibCmd(argc, argv);\n\n    // Read n, m\n    n = inf.readInt(3, 48, \"n\");\n    if (n % 3 != 0)\n        inf.quitf(_fail, \"n must be divisible by 3, got %d\", n);\n    m = inf.readInt(0, (n*(n-1))/2, \"m\");\n\n    // Read the pairs\n    wants.resize(m);\n    for (int i = 0; i < m; i++)\n    {\n        int a = inf.readInt(1, n, \"a_i\");\n        int b = inf.readInt(1, n, \"b_i\");\n        if (a >= b)\n            inf.quitf(_fail, \"Expected a_i < b_i, got %d >= %d\", a, b);\n        wants[i] = {a, b};\n    }\n\n    // Read the jury's solution\n    bool juryImpossible;\n    vector<vector<int>> jurySol = readSolution(ans, juryImpossible);\n\n    // Read the participant's solution\n    bool participantImpossible;\n    vector<vector<int>> partSol = readSolution(ouf, participantImpossible);\n\n    // Compare logic\n    if (juryImpossible)\n    {\n        // Jury says no solution\n        if (participantImpossible)\n            quitf(_ok, \"Both indicate no solution\");\n        else\n            quitf(_wa, \"Jury says no solution, participant claims a solution\");\n    }\n    else\n    {\n        // Jury says a solution exists\n        if (participantImpossible)\n            quitf(_wa, \"A valid solution exists, participant outputs -1\");\n        else\n            quitf(_ok, \"Participant's solution is accepted\");\n    }\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    int m;\n    vector<pair<int, int>> edges;\n\n    if (type == \"random\") {\n        double density = opt<double>(\"density\", 0.5);\n        int max_m = n * (n - 1) / 2;\n        m = int(max_m * density);\n        m = min(m, max_m);\n\n        set<pair<int, int>> edges_set;\n        while (int(edges_set.size()) < m) {\n            int a = rnd.next(1, n);\n            int b = rnd.next(1, n);\n            if (a == b) continue;\n            if (a > b) swap(a, b);\n            edges_set.insert(make_pair(a, b));\n        }\n        edges.assign(edges_set.begin(), edges_set.end());\n    }\n    else if (type == \"chain\") {\n        m = n - 1;\n        for (int i = 1; i < n; i++) {\n            edges.push_back(make_pair(i, i + 1));\n        }\n    }\n    else if (type == \"clique\") {\n        int clique_size = opt<int>(\"clique_size\", 4);\n        clique_size = min(clique_size, n);\n        vector<int> clique_nodes;\n        for (int i = 1; i <= clique_size; i++) {\n            clique_nodes.push_back(i);\n        }\n        for (int i = 0; i < int(clique_nodes.size()); i++) {\n            for (int j = i + 1; j < int(clique_nodes.size()); j++) {\n                edges.push_back(make_pair(clique_nodes[i], clique_nodes[j]));\n            }\n        }\n    }\n    else if (type == \"full_groups\") {\n        int group_size = 3;\n        m = 0;\n        for (int i = 1; i <= n; i += group_size) {\n            vector<int> group;\n            for (int j = 0; j < group_size; j++) {\n                group.push_back(i + j);\n            }\n            for (int a = 0; a < group_size; a++) {\n                for (int b = a + 1; b < group_size; b++) {\n                    edges.push_back(make_pair(group[a], group[b]));\n                    m++;\n                }\n            }\n        }\n    }\n    else if (type == \"impossible\") {\n        vector<int> component_sizes;\n        int remaining_n = n;\n        vector<int> sizes = {4, 5, 7};\n        int idx = 0;\n        while (remaining_n > 0) {\n            int size = sizes[idx % sizes.size()];\n            size = min(size, remaining_n);\n            if (size % 3 == 0) size++;\n            if (size > remaining_n) {\n                size = remaining_n;\n                if (size % 3 == 0) size--;\n            }\n            component_sizes.push_back(size);\n            remaining_n -= size;\n            idx++;\n        }\n        int id = 1;\n        for (int size : component_sizes) {\n            vector<int> nodes;\n            for (int i = 0; i < size; i++) {\n                nodes.push_back(id++);\n            }\n            for (int i = 0; i < size; i++) {\n                for (int j = i + 1; j < size; j++) {\n                    edges.push_back(make_pair(nodes[i], nodes[j]));\n                }\n            }\n        }\n    }\n    else if (type == \"no_pairs\") {\n        m = 0;\n        // edges remain empty\n    }\n    else if (type == \"max_pairs\") {\n        m = n * (n - 1) / 2;\n        for (int i = 1; i <= n; i++) {\n            for (int j = i + 1; j <= n; j++) {\n                edges.push_back(make_pair(i, j));\n            }\n        }\n    }\n    else {\n        // Default to random if unknown type\n        double density = opt<double>(\"density\", 0.5);\n        int max_m = n * (n - 1) / 2;\n        m = int(max_m * density);\n        m = min(m, max_m);\n\n        set<pair<int, int>> edges_set;\n        while (int(edges_set.size()) < m) {\n            int a = rnd.next(1, n);\n            int b = rnd.next(1, n);\n            if (a == b) continue;\n            if (a > b) swap(a, b);\n            edges_set.insert(make_pair(a, b));\n        }\n        edges.assign(edges_set.begin(), edges_set.end());\n    }\n\n    printf(\"%d %d\\n\", n, int(edges.size()));\n    for (auto& e : edges) {\n        printf(\"%d %d\\n\", e.first, e.second);\n    }\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    int m;\n    vector<pair<int, int>> edges;\n\n    if (type == \"random\") {\n        double density = opt<double>(\"density\", 0.5);\n        int max_m = n * (n - 1) / 2;\n        m = int(max_m * density);\n        m = min(m, max_m);\n\n        set<pair<int, int>> edges_set;\n        while (int(edges_set.size()) < m) {\n            int a = rnd.next(1, n);\n            int b = rnd.next(1, n);\n            if (a == b) continue;\n            if (a > b) swap(a, b);\n            edges_set.insert(make_pair(a, b));\n        }\n        edges.assign(edges_set.begin(), edges_set.end());\n    }\n    else if (type == \"chain\") {\n        m = n - 1;\n        for (int i = 1; i < n; i++) {\n            edges.push_back(make_pair(i, i + 1));\n        }\n    }\n    else if (type == \"clique\") {\n        int clique_size = opt<int>(\"clique_size\", 4);\n        clique_size = min(clique_size, n);\n        vector<int> clique_nodes;\n        for (int i = 1; i <= clique_size; i++) {\n            clique_nodes.push_back(i);\n        }\n        for (int i = 0; i < int(clique_nodes.size()); i++) {\n            for (int j = i + 1; j < int(clique_nodes.size()); j++) {\n                edges.push_back(make_pair(clique_nodes[i], clique_nodes[j]));\n            }\n        }\n    }\n    else if (type == \"full_groups\") {\n        int group_size = 3;\n        m = 0;\n        for (int i = 1; i <= n; i += group_size) {\n            vector<int> group;\n            for (int j = 0; j < group_size; j++) {\n                group.push_back(i + j);\n            }\n            for (int a = 0; a < group_size; a++) {\n                for (int b = a + 1; b < group_size; b++) {\n                    edges.push_back(make_pair(group[a], group[b]));\n                    m++;\n                }\n            }\n        }\n    }\n    else if (type == \"impossible\") {\n        vector<int> component_sizes;\n        int remaining_n = n;\n        vector<int> sizes = {4, 5, 7};\n        int idx = 0;\n        while (remaining_n > 0) {\n            int size = sizes[idx % sizes.size()];\n            size = min(size, remaining_n);\n            if (size % 3 == 0) size++;\n            if (size > remaining_n) {\n                size = remaining_n;\n                if (size % 3 == 0) size--;\n            }\n            component_sizes.push_back(size);\n            remaining_n -= size;\n            idx++;\n        }\n        int id = 1;\n        for (int size : component_sizes) {\n            vector<int> nodes;\n            for (int i = 0; i < size; i++) {\n                nodes.push_back(id++);\n            }\n            for (int i = 0; i < size; i++) {\n                for (int j = i + 1; j < size; j++) {\n                    edges.push_back(make_pair(nodes[i], nodes[j]));\n                }\n            }\n        }\n    }\n    else if (type == \"no_pairs\") {\n        m = 0;\n        // edges remain empty\n    }\n    else if (type == \"max_pairs\") {\n        m = n * (n - 1) / 2;\n        for (int i = 1; i <= n; i++) {\n            for (int j = i + 1; j <= n; j++) {\n                edges.push_back(make_pair(i, j));\n            }\n        }\n    }\n    else {\n        // Default to random if unknown type\n        double density = opt<double>(\"density\", 0.5);\n        int max_m = n * (n - 1) / 2;\n        m = int(max_m * density);\n        m = min(m, max_m);\n\n        set<pair<int, int>> edges_set;\n        while (int(edges_set.size()) < m) {\n            int a = rnd.next(1, n);\n            int b = rnd.next(1, n);\n            if (a == b) continue;\n            if (a > b) swap(a, b);\n            edges_set.insert(make_pair(a, b));\n        }\n        edges.assign(edges_set.begin(), edges_set.end());\n    }\n\n    printf(\"%d %d\\n\", n, int(edges.size()));\n    for (auto& e : edges) {\n        printf(\"%d %d\\n\", e.first, e.second);\n    }\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 3 -type random\n./gen -n 3 -type chain\n./gen -n 3 -type full_groups\n./gen -n 6 -type impossible\n./gen -n 9 -type random\n./gen -n 9 -type chain\n./gen -n 9 -type full_groups\n./gen -n 9 -type impossible\n./gen -n 9 -type no_pairs\n./gen -n 9 -type max_pairs\n\n./gen -n 12 -type random\n./gen -n 12 -type chain\n./gen -n 12 -type full_groups\n./gen -n 12 -type impossible\n./gen -n 12 -type clique -clique_size 4\n\n./gen -n 15 -type random\n./gen -n 15 -type impossible\n./gen -n 15 -type random -density 1.0\n\n./gen -n 30 -type full_groups\n./gen -n 30 -type random\n./gen -n 30 -type random -density 0.1\n./gen -n 30 -type chain\n./gen -n 30 -type impossible\n\n./gen -n 48 -type random\n./gen -n 48 -type random -density 1.0\n./gen -n 48 -type random -density 0.5\n./gen -n 48 -type chain\n./gen -n 48 -type full_groups\n./gen -n 48 -type impossible\n\n./gen -n 48 -type clique -clique_size 9\n./gen -n 48 -type max_pairs\n./gen -n 48 -type no_pairs\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:04:54.052311",
        "total_tutorials": 3,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "300/C",
      "title": "C. Beautiful Numbers",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains three integers: a, b, n (1 ≤ a < b ≤ 9, 1 ≤ n ≤ 106).",
      "output_spec": "OutputPrint a single integer — the answer to the problem modulo 1000000007 (109 + 7).",
      "sample_tests": "ExamplesInputCopy1 3 3OutputCopy1InputCopy2 3 10OutputCopy165",
      "description": "C. Beautiful Numbers\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains three integers: a, b, n (1 ≤ a < b ≤ 9, 1 ≤ n ≤ 106).\n\nOutputPrint a single integer — the answer to the problem modulo 1000000007 (109 + 7).\n\nInputCopy1 3 3OutputCopy1InputCopy2 3 10OutputCopy165\n\nInputCopy1 3 3\n\nOutputCopy1\n\nInputCopy2 3 10\n\nOutputCopy165",
      "solutions": [
        {
          "title": "Codeforces Round #181 (Div. 2) - Codeforces",
          "content": "Hello!A few hours later, 25 апреля в 19:30 MSK, you are lucky to participate in Codeforces Round #181 for Div. 2 participants. Traditionally, Div. 1 participants can take part out of the competition.Problems have been prepared by: Gridnev Vitaliy (gridnevvvit), Ignatyev Alexander (aiMR). We want to thank Gerald Agapov(Gerald) for help in preparation of this round, Michael Mirzayanov(MikeMirzayanov) for marvelous Codeforces and Polygon systems, Mary Belova(Delinur) for translating the problems.About authors: me and Alexander are third year students of Mathematics Department, Saratov State University. It’s our first round and I hope not last.We hope you will like these problems, and that it will be fun to solve them. Also we strongly recommend you to read all the problems.We wish everyone good luck and high rating!UPD: Scoring will be dynamic. Problems are sorted by increasing order of difficulty.UPD1: Editorial hereUPD2: Contest finished. Congratulations to winners: ballmaids02 VIProgrammer emachaidze",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/7479",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1015
        },
        {
          "title": "Editorial Codeforces Round #181 (Div.2) - Codeforces",
          "content": "300A - ArrayIn this problem you just need to implement following algorithm. Split input data into 3 vectors: first will contain negative numbers, second positive numbers, third zeroes. If size of first vector is even move one number from it to the third vector. If second vector is empty, then move two numbers from first vector to the second vector. This solution works in O(n).Аuthor's solution300B - CoachInput data represents a graph. If there is a connected component with at least 4 vertexes, then answer is  - 1. Every connected component with 3 vertexes is a complete team. Other teams are made from 1 or 2-vertex components. If amount of 2-vertex components is greater than 1-vertex answer is  - 1. Otherwise match 2-vertex components with 1-vertex. If there are some 1-vertex components left then split them into groups of three. This algorithm works in O(n + m). Also you could implement O(n4) solution.Аuthor's solution300C - Beautiful NumbersLet's MOD = 1000000007. Let's precalc factorial values modulo MOD. fact[i] = i!%MOD, . Let i be an amount of digits equal to a in current excellent number. In this case we can find sum of digits in this number: sum = ai + b(n - i). If sum is good, then add C[n][i] to answer. In this problem it's impossible to calculate binomial coefficients using Pascal's triangle, because of large n. However it can be done this way C[n][i] = fact[n]inv(fact[n - i]fact[i]). inv(a) is multiplicative inverse element(modulo MOD). MOD is a prime number, so inv(a) = aMOD - 2. Calculating this values for each i from 0 to n will give correct answer in O(nlog(MOD)).Аuthor's solution300D - Painting SquareThis picture is helpful for understanding.Let's consider problem D in graph terms:We have matrix n × n, which represents a graph: It is tree. Every vertex, except leaves, has 4 children. There are 4k distinct vertexes, with distance k from root. We need to color k vertexes of this graph. By that we mean also to color all vertexes on path from i to 1(root).Knowing height of tree we can build it in unique way. Let's find height of tree in this way: int height = 0;\nwhile (n > 1 && n % 2 == 1) {\n n /= 2; height++;\n}Let's consider following DP: z[i][j] — number of ways to color graph height i in j steps.Naive solution in O(k4log(n)): z[0][0] = 1; z[0][i] = 0, i > 0; z[i][0] = 1, i > 0\nz[i][j] = 0;\nfor(int k1 = 0; k1 <= j - 1; k1++) \n for(int k2 = 0; k2 <= j - 1 - k1; k2++)\n for(int k3 = 0; k3 <= j - 1 - k1 - k2; k3++)\n {\n int k4 = j - 1 - k1 - k2 - k3;\n z[i][j] += z[i-1][k1] * z[i-1][k2] * z[i-1][k3] * z[i-1][k4];\n z[i][j] %= mod;\n }But it is not what we whant in time terms. Let's consider current DP as polynomial coefficients: z[i][j] — coefficient of power j of polynomial i. In that case z[i + 1][j + 1] — coefficient of power j of polynomial i to the 4-th power. This approach allows to solve problem in O(k2log(n)). However this solution is quite slow, because of modulo operations. As you see, this modulo is not so big ( ≤ 107), that allows us to reduce number of modulo operations, thus giving huge perfomance boost. Also it is possible to use FFT to solve in O(klog(k)log(n)).Аuthor's solution. Uses FFTАuthor's solution. Without FFT300E - Empire Strikes BackLet's . val is upper bound for answer. val! is divisible by , you can easily prove it using facts about prime powers in factorial and following inequality . By the way, is called multinomial coefficient. So answer can't exceed 1013. If n! divisible by den, then (n + 1)! is also divisible by den. That means that function of divisibility is monotonic and we can use binary search.For every i, i = 2..., 107, let's precalc max prime in i using linear sieve of Eratosthenes. For i it will be lp[i]. After that let's create a vector, with all primes less then 107.Now let's calculate following values cnt[i] — amount of numbers a, i <  = a.Now me can factorize denominator like this: for(int i = max; i>=2; i--) {\n if (lp[i] != i) \n cnt[lp[i]] += cnt[i];\n cnt[i / lp[i]] += cnt[i];\n}Finally we use binary search from lf = 1 to .Аuthor's solution",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/7497",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 300\\s*C"
          },
          "content_length": 4064
        },
        {
          "title": "Editorial Codeforces Round #181 (Div.2) - Codeforces",
          "content": "300A - ArrayIn this problem you just need to implement following algorithm. Split input data into 3 vectors: first will contain negative numbers, second positive numbers, third zeroes. If size of first vector is even move one number from it to the third vector. If second vector is empty, then move two numbers from first vector to the second vector. This solution works in O(n).Аuthor's solution300B - CoachInput data represents a graph. If there is a connected component with at least 4 vertexes, then answer is  - 1. Every connected component with 3 vertexes is a complete team. Other teams are made from 1 or 2-vertex components. If amount of 2-vertex components is greater than 1-vertex answer is  - 1. Otherwise match 2-vertex components with 1-vertex. If there are some 1-vertex components left then split them into groups of three. This algorithm works in O(n + m). Also you could implement O(n4) solution.Аuthor's solution300C - Beautiful NumbersLet's MOD = 1000000007. Let's precalc factorial values modulo MOD. fact[i] = i!%MOD, . Let i be an amount of digits equal to a in current excellent number. In this case we can find sum of digits in this number: sum = ai + b(n - i). If sum is good, then add C[n][i] to answer. In this problem it's impossible to calculate binomial coefficients using Pascal's triangle, because of large n. However it can be done this way C[n][i] = fact[n]inv(fact[n - i]fact[i]). inv(a) is multiplicative inverse element(modulo MOD). MOD is a prime number, so inv(a) = aMOD - 2. Calculating this values for each i from 0 to n will give correct answer in O(nlog(MOD)).Аuthor's solution300D - Painting SquareThis picture is helpful for understanding.Let's consider problem D in graph terms:We have matrix n × n, which represents a graph: It is tree. Every vertex, except leaves, has 4 children. There are 4k distinct vertexes, with distance k from root. We need to color k vertexes of this graph. By that we mean also to color all vertexes on path from i to 1(root).Knowing height of tree we can build it in unique way. Let's find height of tree in this way: int height = 0;\nwhile (n > 1 && n % 2 == 1) {\n n /= 2; height++;\n}Let's consider following DP: z[i][j] — number of ways to color graph height i in j steps.Naive solution in O(k4log(n)): z[0][0] = 1; z[0][i] = 0, i > 0; z[i][0] = 1, i > 0\nz[i][j] = 0;\nfor(int k1 = 0; k1 <= j - 1; k1++) \n for(int k2 = 0; k2 <= j - 1 - k1; k2++)\n for(int k3 = 0; k3 <= j - 1 - k1 - k2; k3++)\n {\n int k4 = j - 1 - k1 - k2 - k3;\n z[i][j] += z[i-1][k1] * z[i-1][k2] * z[i-1][k3] * z[i-1][k4];\n z[i][j] %= mod;\n }But it is not what we whant in time terms. Let's consider current DP as polynomial coefficients: z[i][j] — coefficient of power j of polynomial i. In that case z[i + 1][j + 1] — coefficient of power j of polynomial i to the 4-th power. This approach allows to solve problem in O(k2log(n)). However this solution is quite slow, because of modulo operations. As you see, this modulo is not so big ( ≤ 107), that allows us to reduce number of modulo operations, thus giving huge perfomance boost. Also it is possible to use FFT to solve in O(klog(k)log(n)).Аuthor's solution. Uses FFTАuthor's solution. Without FFT300E - Empire Strikes BackLet's . val is upper bound for answer. val! is divisible by , you can easily prove it using facts about prime powers in factorial and following inequality . By the way, is called multinomial coefficient. So answer can't exceed 1013. If n! divisible by den, then (n + 1)! is also divisible by den. That means that function of divisibility is monotonic and we can use binary search.For every i, i = 2..., 107, let's precalc max prime in i using linear sieve of Eratosthenes. For i it will be lp[i]. After that let's create a vector, with all primes less then 107.Now let's calculate following values cnt[i] — amount of numbers a, i <  = a.Now me can factorize denominator like this: for(int i = max; i>=2; i--) {\n if (lp[i] != i) \n cnt[lp[i]] += cnt[i];\n cnt[i / lp[i]] += cnt[i];\n}Finally we use binary search from lf = 1 to .Аuthor's solution",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/7497",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 300\\s*C"
          },
          "content_length": 4064
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #181 (Div. 2) - Codeforces - Code 1",
          "code": "WTF???\nUPD: he has already -179 hacks...",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7479",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #181 (Div. 2) - Codeforces - Code 2",
          "code": "WTF???\nUPD: he has already -179 hacks...",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7479",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #181 (Div. 2) - Codeforces - Code 3",
          "code": "// ax + by = gcd(a,b) = d\nvoid eea(int a, int b, int& x, int& y, int& d) {\n    if (!b) {x = 1; y = 0; d = a; return; }\n    eea(b, a % b, x, y, d);\n    int x1 = y, y1 = x - (a / b) * y;\n    x = x1, y = y1;\n}\nint divide(int a, int b) {\n    int d, x, y;\n    eea(b, MOD, x, y, d);\n    // if(a%d==0)\n    return ((x+MOD)*(a/d)) % (MOD/d);\n    // else   \"no quotient\"\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7479",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #181 (Div. 2) - Codeforces - Code 4",
          "code": "// ax + by = gcd(a,b) = d\nvoid eea(int a, int b, int& x, int& y, int& d) {\n    if (!b) {x = 1; y = 0; d = a; return; }\n    eea(b, a % b, x, y, d);\n    int x1 = y, y1 = x - (a / b) * y;\n    x = x1, y = y1;\n}\nint divide(int a, int b) {\n    int d, x, y;\n    eea(b, MOD, x, y, d);\n    // if(a%d==0)\n    return ((x+MOD)*(a/d)) % (MOD/d);\n    // else   \"no quotient\"\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7479",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #181 (Div.2) - Codeforces - Code 1",
          "code": "int height = 0;\nwhile (n > 1 && n % 2 == 1) {\n n /= 2; height++;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7497",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #181 (Div.2) - Codeforces - Code 2",
          "code": "int height = 0;\nwhile (n > 1 && n % 2 == 1) {\n n /= 2; height++;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7497",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #181 (Div.2) - Codeforces - Code 3",
          "code": "z[0][0] = 1; z[0][i] = 0, i > 0; z[i][0] = 1, i > 0\nz[i][j] = 0;\nfor(int k1 = 0; k1 <= j - 1; k1++) \n  for(int k2 = 0; k2 <= j - 1 - k1; k2++)\n    for(int k3 = 0; k3 <= j - 1 - k1 - k2; k3++)\n      {\n         int k4 = j - 1 - k1 - k2 - k3;\n  z[i][j] += z[i-1][k1] * z[i-1][k2] * z[i-1][k3] * z[i-1][k4];\n  z[i][j] %= mod;\n      }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7497",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #181 (Div.2) - Codeforces - Code 4",
          "code": "z[0][0] = 1; z[0][i] = 0, i > 0; z[i][0] = 1, i > 0\nz[i][j] = 0;\nfor(int k1 = 0; k1 <= j - 1; k1++) \n  for(int k2 = 0; k2 <= j - 1 - k1; k2++)\n    for(int k3 = 0; k3 <= j - 1 - k1 - k2; k3++)\n      {\n         int k4 = j - 1 - k1 - k2 - k3;\n  z[i][j] += z[i-1][k1] * z[i-1][k2] * z[i-1][k3] * z[i-1][k4];\n  z[i][j] %= mod;\n      }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7497",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #181 (Div.2) - Codeforces - Code 5",
          "code": "for(int i = max; i>=2; i--) {\n if (lp[i] != i) \n  cnt[lp[i]] += cnt[i];\n cnt[i / lp[i]] += cnt[i];\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7497",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #181 (Div.2) - Codeforces - Code 6",
          "code": "for(int i = max; i>=2; i--) {\n if (lp[i] != i) \n  cnt[lp[i]] += cnt[i];\n cnt[i / lp[i]] += cnt[i];\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7497",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #181 (Div.2) - Codeforces - Code 7",
          "code": "for(int j=0; j<=MK; j++)\n                        for(int k=0; k<=MK-j; k++)\n                                d[j+k]+=dp[i][j]*dp[i][k];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7497",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #181 (Div.2) - Codeforces - Code 8",
          "code": "for(int j=0; j<=MK; j++)\n                        for(int k=0; k<=MK-j; k++)\n                                d[j+k]+=dp[i][j]*dp[i][k];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7497",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #181 (Div.2) - Codeforces - Code 9",
          "code": "for(int j=0; j<=MK; j++)\n                        for(int k=0; k<=MK-j; k++)\n                                dp[i+1][j+k+1]+=d[j]*d[k];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7497",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #181 (Div.2) - Codeforces - Code 10",
          "code": "for(int j=0; j<=MK; j++)\n                        for(int k=0; k<=MK-j; k++)\n                                dp[i+1][j+k+1]+=d[j]*d[k];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7497",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #181 (Div.2) - Codeforces - Code 11",
          "code": "for(int i=10000000;i>=2;i--)\n\t{\n\t\tCount[Min[i]]+=Delta[i];\n\t\tDelta[i/Prime[Min[i]]]+=Delta[i];\n\t}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7497",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #181 (Div.2) - Codeforces - Code 12",
          "code": "for(int i=10000000;i>=2;i--)\n\t{\n\t\tCount[Min[i]]+=Delta[i];\n\t\tDelta[i/Prime[Min[i]]]+=Delta[i];\n\t}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7497",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #181 (Div.2) - Codeforces - Code 13",
          "code": "for(int i = 0; i < n; i++) scanf(\"%d\",&a[i]),cnt[a[i]]++,sum+=a[i];\n\tfor(int i = M - 10; i >= 2; i--) cnt[i] += cnt[i+1];\n\tfor(int i = M - 10; i >= 2; i--)\n\t{\n\t\tif(lp[i]!=i) cnt[lp[i]] += cnt[i];\n\t\tcnt[i/lp[i]] += cnt[i];\n\t}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7497",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #181 (Div.2) - Codeforces - Code 14",
          "code": "for(int i = 0; i < n; i++) scanf(\"%d\",&a[i]),cnt[a[i]]++,sum+=a[i];\n\tfor(int i = M - 10; i >= 2; i--) cnt[i] += cnt[i+1];\n\tfor(int i = M - 10; i >= 2; i--)\n\t{\n\t\tif(lp[i]!=i) cnt[lp[i]] += cnt[i];\n\t\tcnt[i/lp[i]] += cnt[i];\n\t}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7497",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #181 (Div.2) - Codeforces - Code 1",
          "code": "int height = 0;\nwhile (n > 1 && n % 2 == 1) {\n n /= 2; height++;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7497",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #181 (Div.2) - Codeforces - Code 2",
          "code": "int height = 0;\nwhile (n > 1 && n % 2 == 1) {\n n /= 2; height++;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7497",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #181 (Div.2) - Codeforces - Code 3",
          "code": "z[0][0] = 1; z[0][i] = 0, i > 0; z[i][0] = 1, i > 0\nz[i][j] = 0;\nfor(int k1 = 0; k1 <= j - 1; k1++) \n  for(int k2 = 0; k2 <= j - 1 - k1; k2++)\n    for(int k3 = 0; k3 <= j - 1 - k1 - k2; k3++)\n      {\n         int k4 = j - 1 - k1 - k2 - k3;\n  z[i][j] += z[i-1][k1] * z[i-1][k2] * z[i-1][k3] * z[i-1][k4];\n  z[i][j] %= mod;\n      }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7497",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #181 (Div.2) - Codeforces - Code 4",
          "code": "z[0][0] = 1; z[0][i] = 0, i > 0; z[i][0] = 1, i > 0\nz[i][j] = 0;\nfor(int k1 = 0; k1 <= j - 1; k1++) \n  for(int k2 = 0; k2 <= j - 1 - k1; k2++)\n    for(int k3 = 0; k3 <= j - 1 - k1 - k2; k3++)\n      {\n         int k4 = j - 1 - k1 - k2 - k3;\n  z[i][j] += z[i-1][k1] * z[i-1][k2] * z[i-1][k3] * z[i-1][k4];\n  z[i][j] %= mod;\n      }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7497",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #181 (Div.2) - Codeforces - Code 5",
          "code": "for(int i = max; i>=2; i--) {\n if (lp[i] != i) \n  cnt[lp[i]] += cnt[i];\n cnt[i / lp[i]] += cnt[i];\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7497",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #181 (Div.2) - Codeforces - Code 6",
          "code": "for(int i = max; i>=2; i--) {\n if (lp[i] != i) \n  cnt[lp[i]] += cnt[i];\n cnt[i / lp[i]] += cnt[i];\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7497",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #181 (Div.2) - Codeforces - Code 7",
          "code": "for(int j=0; j<=MK; j++)\n                        for(int k=0; k<=MK-j; k++)\n                                d[j+k]+=dp[i][j]*dp[i][k];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7497",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #181 (Div.2) - Codeforces - Code 8",
          "code": "for(int j=0; j<=MK; j++)\n                        for(int k=0; k<=MK-j; k++)\n                                d[j+k]+=dp[i][j]*dp[i][k];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7497",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #181 (Div.2) - Codeforces - Code 9",
          "code": "for(int j=0; j<=MK; j++)\n                        for(int k=0; k<=MK-j; k++)\n                                dp[i+1][j+k+1]+=d[j]*d[k];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7497",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #181 (Div.2) - Codeforces - Code 10",
          "code": "for(int j=0; j<=MK; j++)\n                        for(int k=0; k<=MK-j; k++)\n                                dp[i+1][j+k+1]+=d[j]*d[k];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7497",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #181 (Div.2) - Codeforces - Code 11",
          "code": "for(int i=10000000;i>=2;i--)\n\t{\n\t\tCount[Min[i]]+=Delta[i];\n\t\tDelta[i/Prime[Min[i]]]+=Delta[i];\n\t}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7497",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #181 (Div.2) - Codeforces - Code 12",
          "code": "for(int i=10000000;i>=2;i--)\n\t{\n\t\tCount[Min[i]]+=Delta[i];\n\t\tDelta[i/Prime[Min[i]]]+=Delta[i];\n\t}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7497",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #181 (Div.2) - Codeforces - Code 13",
          "code": "for(int i = 0; i < n; i++) scanf(\"%d\",&a[i]),cnt[a[i]]++,sum+=a[i];\n\tfor(int i = M - 10; i >= 2; i--) cnt[i] += cnt[i+1];\n\tfor(int i = M - 10; i >= 2; i--)\n\t{\n\t\tif(lp[i]!=i) cnt[lp[i]] += cnt[i];\n\t\tcnt[i/lp[i]] += cnt[i];\n\t}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7497",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #181 (Div.2) - Codeforces - Code 14",
          "code": "for(int i = 0; i < n; i++) scanf(\"%d\",&a[i]),cnt[a[i]]++,sum+=a[i];\n\tfor(int i = M - 10; i >= 2; i--) cnt[i] += cnt[i+1];\n\tfor(int i = M - 10; i >= 2; i--)\n\t{\n\t\tif(lp[i]!=i) cnt[lp[i]] += cnt[i];\n\t\tcnt[i/lp[i]] += cnt[i];\n\t}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7497",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int a = inf.readInt(1, 8, \"a\");\n    inf.readSpace();\n    int b = inf.readInt(a + 1, 9, \"b\");\n    inf.readSpace();\n    int n = inf.readInt(1, 1000000, \"n\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int a = inf.readInt(1, 8, \"a\");\n    inf.readSpace();\n    int b = inf.readInt(a + 1, 9, \"b\");\n    inf.readSpace();\n    int n = inf.readInt(1, 1000000, \"n\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int a = inf.readInt(1, 8, \"a\");\n    inf.readSpace();\n    int b = inf.readInt(a + 1, 9, \"b\");\n    inf.readSpace();\n    int n = inf.readInt(1, 1000000, \"n\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\n// Function to generate a case where there are no excellent numbers\nvoid generate_no_excellent_numbers(int& a, int& b) {\n    // Choosing digits where the sum of digits cannot be a good number\n    a = 2;\n    b = 5;\n}\n\n// Function to generate a case where all good numbers are excellent\nvoid generate_all_excellent_numbers(int& a, int& b) {\n    // Choosing digits where the sum of digits of any good number is also a good number\n    a = 1;\n    b = 1; // However, since a < b, we need to increment b\n    b = 2;\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int a = opt<int>(\"a\", -1);\n    int b = opt<int>(\"b\", -1);\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n   \n    if (type == \"min\") {\n        a = 1;\n        b = 2;\n        n = 1;\n    } else if (type == \"max\") {\n        a = 8;\n        b = 9;\n        n = 1000000;\n    } else if (type == \"no_valid_numbers\") {\n        generate_no_excellent_numbers(a, b);\n    } else if (type == \"all_excellent\") {\n        generate_all_excellent_numbers(a, b);\n    } else {\n        // 'random' or other types, generate random values\n        if (a == -1) {\n            a = rnd.next(1, 8);\n        }\n        if (b == -1) {\n            b = rnd.next(a + 1, 9);\n        }\n    }\n    if (a == -1 || b == -1) {\n        ensuref(false, \"Invalid a or b\");\n    }\n    if (a >= b) {\n        ensuref(false, \"a must be less than b\");\n    }\n    ensuref(1 <= a && a <= 9, \"Invalid value for a\");\n    ensuref(1 <= b && b <= 9, \"Invalid value for b\");\n    ensuref(1 <= n && n <= 1000000, \"Invalid value for n\");\n\n    printf(\"%d %d %d\\n\", a, b, n);\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\n// Function to generate a case where there are no excellent numbers\nvoid generate_no_excellent_numbers(int& a, int& b) {\n    // Choosing digits where the sum of digits cannot be a good number\n    a = 2;\n    b = 5;\n}\n\n// Function to generate a case where all good numbers are excellent\nvoid generate_all_excellent_numbers(int& a, int& b) {\n    // Choosing digits where the sum of digits of any good number is also a good number\n    a = 1;\n    b = 1; // However, since a < b, we need to increment b\n    b = 2;\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int a = opt<int>(\"a\", -1);\n    int b = opt<int>(\"b\", -1);\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n   \n    if (type == \"min\") {\n        a = 1;\n        b = 2;\n        n = 1;\n    } else if (type == \"max\") {\n        a = 8;\n        b = 9;\n        n = 1000000;\n    } else if (type == \"no_valid_numbers\") {\n        generate_no_excellent_numbers(a, b);\n    } else if (type == \"all_excellent\") {\n        generate_all_excellent_numbers(a, b);\n    } else {\n        // 'random' or other types, generate random values\n        if (a == -1) {\n            a = rnd.next(1, 8);\n        }\n        if (b == -1) {\n            b = rnd.next(a + 1, 9);\n        }\n    }\n    if (a == -1 || b == -1) {\n        ensuref(false, \"Invalid a or b\");\n    }\n    if (a >= b) {\n        ensuref(false, \"a must be less than b\");\n    }\n    ensuref(1 <= a && a <= 9, \"Invalid value for a\");\n    ensuref(1 <= b && b <= 9, \"Invalid value for b\");\n    ensuref(1 <= n && n <= 1000000, \"Invalid value for n\");\n\n    printf(\"%d %d %d\\n\", a, b, n);\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -type min\n./gen -n 1000000 -type max\n./gen -n 500000 -type no_valid_numbers\n./gen -n 1000000 -type no_valid_numbers\n./gen -n 1 -type all_excellent\n./gen -n 10 -type all_excellent\n./gen -n 100 -type all_excellent\n\n./gen -n 1\n./gen -n 100\n./gen -n 1000\n./gen -n 10000\n./gen -n 100000\n./gen -n 1000000\n\n./gen -n 1 -a 1 -b 2\n./gen -n 1000000 -a 8 -b 9\n./gen -n 500000 -a 2 -b 5\n\n./gen -n 123456 -a 3 -b 7\n./gen -n 654321 -a 1 -b 9\n./gen -n 999999 -a 2 -b 9\n\n./gen -n 100 -a 1 -b 8\n./gen -n 200 -a 2 -b 7\n./gen -n 300 -a 3 -b 6\n./gen -n 400 -a 4 -b 5\n\n./gen -n 100 -a 2 -b 9 -type no_valid_numbers\n./gen -n 200 -a 1 -b 3 -type all_excellent\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:04:56.259891",
        "total_tutorials": 3,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "300/D",
      "title": "D. Painting Square",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test3 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains integer q (1 ≤ q ≤ 105) — the number of test data.Each of the following q lines contains two integers n and k (1 ≤ n ≤ 109, 0 ≤ k ≤ 1000) — the size of the initial table and the number of moves for the corresponding test.",
      "output_spec": "OutputFor each test from the input print the answer to the problem modulo 7340033. Print the answers to the tests in the order in which the tests are given in the input.",
      "sample_tests": "ExamplesInputCopy81 01 13 03 12 02 13 27 2OutputCopy10111004",
      "description": "D. Painting Square\n\ntime limit per test3 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains integer q (1 ≤ q ≤ 105) — the number of test data.Each of the following q lines contains two integers n and k (1 ≤ n ≤ 109, 0 ≤ k ≤ 1000) — the size of the initial table and the number of moves for the corresponding test.\n\nOutputFor each test from the input print the answer to the problem modulo 7340033. Print the answers to the tests in the order in which the tests are given in the input.\n\nInputCopy81 01 13 03 12 02 13 27 2OutputCopy10111004\n\nInputCopy81 01 13 03 12 02 13 27 2\n\nOutputCopy10111004\n\nNoteAll possible painting ways for the test n = 7 and k = 2 are:",
      "solutions": [
        {
          "title": "Codeforces Round #181 (Div. 2) - Codeforces",
          "content": "Hello!A few hours later, 25 апреля в 19:30 MSK, you are lucky to participate in Codeforces Round #181 for Div. 2 participants. Traditionally, Div. 1 participants can take part out of the competition.Problems have been prepared by: Gridnev Vitaliy (gridnevvvit), Ignatyev Alexander (aiMR). We want to thank Gerald Agapov(Gerald) for help in preparation of this round, Michael Mirzayanov(MikeMirzayanov) for marvelous Codeforces and Polygon systems, Mary Belova(Delinur) for translating the problems.About authors: me and Alexander are third year students of Mathematics Department, Saratov State University. It’s our first round and I hope not last.We hope you will like these problems, and that it will be fun to solve them. Also we strongly recommend you to read all the problems.We wish everyone good luck and high rating!UPD: Scoring will be dynamic. Problems are sorted by increasing order of difficulty.UPD1: Editorial hereUPD2: Contest finished. Congratulations to winners: ballmaids02 VIProgrammer emachaidze",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/7479",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1015
        },
        {
          "title": "Editorial Codeforces Round #181 (Div.2) - Codeforces",
          "content": "300A - ArrayIn this problem you just need to implement following algorithm. Split input data into 3 vectors: first will contain negative numbers, second positive numbers, third zeroes. If size of first vector is even move one number from it to the third vector. If second vector is empty, then move two numbers from first vector to the second vector. This solution works in O(n).Аuthor's solution300B - CoachInput data represents a graph. If there is a connected component with at least 4 vertexes, then answer is  - 1. Every connected component with 3 vertexes is a complete team. Other teams are made from 1 or 2-vertex components. If amount of 2-vertex components is greater than 1-vertex answer is  - 1. Otherwise match 2-vertex components with 1-vertex. If there are some 1-vertex components left then split them into groups of three. This algorithm works in O(n + m). Also you could implement O(n4) solution.Аuthor's solution300C - Beautiful NumbersLet's MOD = 1000000007. Let's precalc factorial values modulo MOD. fact[i] = i!%MOD, . Let i be an amount of digits equal to a in current excellent number. In this case we can find sum of digits in this number: sum = ai + b(n - i). If sum is good, then add C[n][i] to answer. In this problem it's impossible to calculate binomial coefficients using Pascal's triangle, because of large n. However it can be done this way C[n][i] = fact[n]inv(fact[n - i]fact[i]). inv(a) is multiplicative inverse element(modulo MOD). MOD is a prime number, so inv(a) = aMOD - 2. Calculating this values for each i from 0 to n will give correct answer in O(nlog(MOD)).Аuthor's solution300D - Painting SquareThis picture is helpful for understanding.Let's consider problem D in graph terms:We have matrix n × n, which represents a graph: It is tree. Every vertex, except leaves, has 4 children. There are 4k distinct vertexes, with distance k from root. We need to color k vertexes of this graph. By that we mean also to color all vertexes on path from i to 1(root).Knowing height of tree we can build it in unique way. Let's find height of tree in this way: int height = 0;\nwhile (n > 1 && n % 2 == 1) {\n n /= 2; height++;\n}Let's consider following DP: z[i][j] — number of ways to color graph height i in j steps.Naive solution in O(k4log(n)): z[0][0] = 1; z[0][i] = 0, i > 0; z[i][0] = 1, i > 0\nz[i][j] = 0;\nfor(int k1 = 0; k1 <= j - 1; k1++) \n for(int k2 = 0; k2 <= j - 1 - k1; k2++)\n for(int k3 = 0; k3 <= j - 1 - k1 - k2; k3++)\n {\n int k4 = j - 1 - k1 - k2 - k3;\n z[i][j] += z[i-1][k1] * z[i-1][k2] * z[i-1][k3] * z[i-1][k4];\n z[i][j] %= mod;\n }But it is not what we whant in time terms. Let's consider current DP as polynomial coefficients: z[i][j] — coefficient of power j of polynomial i. In that case z[i + 1][j + 1] — coefficient of power j of polynomial i to the 4-th power. This approach allows to solve problem in O(k2log(n)). However this solution is quite slow, because of modulo operations. As you see, this modulo is not so big ( ≤ 107), that allows us to reduce number of modulo operations, thus giving huge perfomance boost. Also it is possible to use FFT to solve in O(klog(k)log(n)).Аuthor's solution. Uses FFTАuthor's solution. Without FFT300E - Empire Strikes BackLet's . val is upper bound for answer. val! is divisible by , you can easily prove it using facts about prime powers in factorial and following inequality . By the way, is called multinomial coefficient. So answer can't exceed 1013. If n! divisible by den, then (n + 1)! is also divisible by den. That means that function of divisibility is monotonic and we can use binary search.For every i, i = 2..., 107, let's precalc max prime in i using linear sieve of Eratosthenes. For i it will be lp[i]. After that let's create a vector, with all primes less then 107.Now let's calculate following values cnt[i] — amount of numbers a, i <  = a.Now me can factorize denominator like this: for(int i = max; i>=2; i--) {\n if (lp[i] != i) \n cnt[lp[i]] += cnt[i];\n cnt[i / lp[i]] += cnt[i];\n}Finally we use binary search from lf = 1 to .Аuthor's solution",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/7497",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 300\\s*D"
          },
          "content_length": 4064
        },
        {
          "title": "Editorial Codeforces Round #181 (Div.2) - Codeforces",
          "content": "300A - ArrayIn this problem you just need to implement following algorithm. Split input data into 3 vectors: first will contain negative numbers, second positive numbers, third zeroes. If size of first vector is even move one number from it to the third vector. If second vector is empty, then move two numbers from first vector to the second vector. This solution works in O(n).Аuthor's solution300B - CoachInput data represents a graph. If there is a connected component with at least 4 vertexes, then answer is  - 1. Every connected component with 3 vertexes is a complete team. Other teams are made from 1 or 2-vertex components. If amount of 2-vertex components is greater than 1-vertex answer is  - 1. Otherwise match 2-vertex components with 1-vertex. If there are some 1-vertex components left then split them into groups of three. This algorithm works in O(n + m). Also you could implement O(n4) solution.Аuthor's solution300C - Beautiful NumbersLet's MOD = 1000000007. Let's precalc factorial values modulo MOD. fact[i] = i!%MOD, . Let i be an amount of digits equal to a in current excellent number. In this case we can find sum of digits in this number: sum = ai + b(n - i). If sum is good, then add C[n][i] to answer. In this problem it's impossible to calculate binomial coefficients using Pascal's triangle, because of large n. However it can be done this way C[n][i] = fact[n]inv(fact[n - i]fact[i]). inv(a) is multiplicative inverse element(modulo MOD). MOD is a prime number, so inv(a) = aMOD - 2. Calculating this values for each i from 0 to n will give correct answer in O(nlog(MOD)).Аuthor's solution300D - Painting SquareThis picture is helpful for understanding.Let's consider problem D in graph terms:We have matrix n × n, which represents a graph: It is tree. Every vertex, except leaves, has 4 children. There are 4k distinct vertexes, with distance k from root. We need to color k vertexes of this graph. By that we mean also to color all vertexes on path from i to 1(root).Knowing height of tree we can build it in unique way. Let's find height of tree in this way: int height = 0;\nwhile (n > 1 && n % 2 == 1) {\n n /= 2; height++;\n}Let's consider following DP: z[i][j] — number of ways to color graph height i in j steps.Naive solution in O(k4log(n)): z[0][0] = 1; z[0][i] = 0, i > 0; z[i][0] = 1, i > 0\nz[i][j] = 0;\nfor(int k1 = 0; k1 <= j - 1; k1++) \n for(int k2 = 0; k2 <= j - 1 - k1; k2++)\n for(int k3 = 0; k3 <= j - 1 - k1 - k2; k3++)\n {\n int k4 = j - 1 - k1 - k2 - k3;\n z[i][j] += z[i-1][k1] * z[i-1][k2] * z[i-1][k3] * z[i-1][k4];\n z[i][j] %= mod;\n }But it is not what we whant in time terms. Let's consider current DP as polynomial coefficients: z[i][j] — coefficient of power j of polynomial i. In that case z[i + 1][j + 1] — coefficient of power j of polynomial i to the 4-th power. This approach allows to solve problem in O(k2log(n)). However this solution is quite slow, because of modulo operations. As you see, this modulo is not so big ( ≤ 107), that allows us to reduce number of modulo operations, thus giving huge perfomance boost. Also it is possible to use FFT to solve in O(klog(k)log(n)).Аuthor's solution. Uses FFTАuthor's solution. Without FFT300E - Empire Strikes BackLet's . val is upper bound for answer. val! is divisible by , you can easily prove it using facts about prime powers in factorial and following inequality . By the way, is called multinomial coefficient. So answer can't exceed 1013. If n! divisible by den, then (n + 1)! is also divisible by den. That means that function of divisibility is monotonic and we can use binary search.For every i, i = 2..., 107, let's precalc max prime in i using linear sieve of Eratosthenes. For i it will be lp[i]. After that let's create a vector, with all primes less then 107.Now let's calculate following values cnt[i] — amount of numbers a, i <  = a.Now me can factorize denominator like this: for(int i = max; i>=2; i--) {\n if (lp[i] != i) \n cnt[lp[i]] += cnt[i];\n cnt[i / lp[i]] += cnt[i];\n}Finally we use binary search from lf = 1 to .Аuthor's solution",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/7497",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 300\\s*D"
          },
          "content_length": 4064
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #181 (Div. 2) - Codeforces - Code 1",
          "code": "WTF???\nUPD: he has already -179 hacks...",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7479",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #181 (Div. 2) - Codeforces - Code 2",
          "code": "WTF???\nUPD: he has already -179 hacks...",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7479",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #181 (Div. 2) - Codeforces - Code 3",
          "code": "// ax + by = gcd(a,b) = d\nvoid eea(int a, int b, int& x, int& y, int& d) {\n    if (!b) {x = 1; y = 0; d = a; return; }\n    eea(b, a % b, x, y, d);\n    int x1 = y, y1 = x - (a / b) * y;\n    x = x1, y = y1;\n}\nint divide(int a, int b) {\n    int d, x, y;\n    eea(b, MOD, x, y, d);\n    // if(a%d==0)\n    return ((x+MOD)*(a/d)) % (MOD/d);\n    // else   \"no quotient\"\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7479",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #181 (Div. 2) - Codeforces - Code 4",
          "code": "// ax + by = gcd(a,b) = d\nvoid eea(int a, int b, int& x, int& y, int& d) {\n    if (!b) {x = 1; y = 0; d = a; return; }\n    eea(b, a % b, x, y, d);\n    int x1 = y, y1 = x - (a / b) * y;\n    x = x1, y = y1;\n}\nint divide(int a, int b) {\n    int d, x, y;\n    eea(b, MOD, x, y, d);\n    // if(a%d==0)\n    return ((x+MOD)*(a/d)) % (MOD/d);\n    // else   \"no quotient\"\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7479",
          "author": "Qingyu"
        },
        {
          "title": "Editorial Codeforces Round #181 (Div.2) - Codeforces - Code 1",
          "code": "int height = 0;\nwhile (n > 1 && n % 2 == 1) {\n n /= 2; height++;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7497",
          "author": "Qingyu"
        },
        {
          "title": "Editorial Codeforces Round #181 (Div.2) - Codeforces - Code 2",
          "code": "int height = 0;\nwhile (n > 1 && n % 2 == 1) {\n n /= 2; height++;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7497",
          "author": "Qingyu"
        },
        {
          "title": "Editorial Codeforces Round #181 (Div.2) - Codeforces - Code 3",
          "code": "z[0][0] = 1; z[0][i] = 0, i > 0; z[i][0] = 1, i > 0\nz[i][j] = 0;\nfor(int k1 = 0; k1 <= j - 1; k1++) \n  for(int k2 = 0; k2 <= j - 1 - k1; k2++)\n    for(int k3 = 0; k3 <= j - 1 - k1 - k2; k3++)\n      {\n         int k4 = j - 1 - k1 - k2 - k3;\n  z[i][j] += z[i-1][k1] * z[i-1][k2] * z[i-1][k3] * z[i-1][k4];\n  z[i][j] %= mod;\n      }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7497",
          "author": "Qingyu"
        },
        {
          "title": "Editorial Codeforces Round #181 (Div.2) - Codeforces - Code 4",
          "code": "z[0][0] = 1; z[0][i] = 0, i > 0; z[i][0] = 1, i > 0\nz[i][j] = 0;\nfor(int k1 = 0; k1 <= j - 1; k1++) \n  for(int k2 = 0; k2 <= j - 1 - k1; k2++)\n    for(int k3 = 0; k3 <= j - 1 - k1 - k2; k3++)\n      {\n         int k4 = j - 1 - k1 - k2 - k3;\n  z[i][j] += z[i-1][k1] * z[i-1][k2] * z[i-1][k3] * z[i-1][k4];\n  z[i][j] %= mod;\n      }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7497",
          "author": "Qingyu"
        },
        {
          "title": "Editorial Codeforces Round #181 (Div.2) - Codeforces - Code 5",
          "code": "for(int i = max; i>=2; i--) {\n if (lp[i] != i) \n  cnt[lp[i]] += cnt[i];\n cnt[i / lp[i]] += cnt[i];\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7497",
          "author": "Qingyu"
        },
        {
          "title": "Editorial Codeforces Round #181 (Div.2) - Codeforces - Code 6",
          "code": "for(int i = max; i>=2; i--) {\n if (lp[i] != i) \n  cnt[lp[i]] += cnt[i];\n cnt[i / lp[i]] += cnt[i];\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7497",
          "author": "Qingyu"
        },
        {
          "title": "Editorial Codeforces Round #181 (Div.2) - Codeforces - Code 7",
          "code": "for(int j=0; j<=MK; j++)\n                        for(int k=0; k<=MK-j; k++)\n                                d[j+k]+=dp[i][j]*dp[i][k];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7497",
          "author": "Qingyu"
        },
        {
          "title": "Editorial Codeforces Round #181 (Div.2) - Codeforces - Code 8",
          "code": "for(int j=0; j<=MK; j++)\n                        for(int k=0; k<=MK-j; k++)\n                                d[j+k]+=dp[i][j]*dp[i][k];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7497",
          "author": "Qingyu"
        },
        {
          "title": "Editorial Codeforces Round #181 (Div.2) - Codeforces - Code 9",
          "code": "for(int j=0; j<=MK; j++)\n                        for(int k=0; k<=MK-j; k++)\n                                dp[i+1][j+k+1]+=d[j]*d[k];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7497",
          "author": "Qingyu"
        },
        {
          "title": "Editorial Codeforces Round #181 (Div.2) - Codeforces - Code 10",
          "code": "for(int j=0; j<=MK; j++)\n                        for(int k=0; k<=MK-j; k++)\n                                dp[i+1][j+k+1]+=d[j]*d[k];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7497",
          "author": "Qingyu"
        },
        {
          "title": "Editorial Codeforces Round #181 (Div.2) - Codeforces - Code 11",
          "code": "for(int i=10000000;i>=2;i--)\n\t{\n\t\tCount[Min[i]]+=Delta[i];\n\t\tDelta[i/Prime[Min[i]]]+=Delta[i];\n\t}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7497",
          "author": "Qingyu"
        },
        {
          "title": "Editorial Codeforces Round #181 (Div.2) - Codeforces - Code 12",
          "code": "for(int i=10000000;i>=2;i--)\n\t{\n\t\tCount[Min[i]]+=Delta[i];\n\t\tDelta[i/Prime[Min[i]]]+=Delta[i];\n\t}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7497",
          "author": "Qingyu"
        },
        {
          "title": "Editorial Codeforces Round #181 (Div.2) - Codeforces - Code 13",
          "code": "for(int i = 0; i < n; i++) scanf(\"%d\",&a[i]),cnt[a[i]]++,sum+=a[i];\n\tfor(int i = M - 10; i >= 2; i--) cnt[i] += cnt[i+1];\n\tfor(int i = M - 10; i >= 2; i--)\n\t{\n\t\tif(lp[i]!=i) cnt[lp[i]] += cnt[i];\n\t\tcnt[i/lp[i]] += cnt[i];\n\t}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7497",
          "author": "Qingyu"
        },
        {
          "title": "Editorial Codeforces Round #181 (Div.2) - Codeforces - Code 14",
          "code": "for(int i = 0; i < n; i++) scanf(\"%d\",&a[i]),cnt[a[i]]++,sum+=a[i];\n\tfor(int i = M - 10; i >= 2; i--) cnt[i] += cnt[i+1];\n\tfor(int i = M - 10; i >= 2; i--)\n\t{\n\t\tif(lp[i]!=i) cnt[lp[i]] += cnt[i];\n\t\tcnt[i/lp[i]] += cnt[i];\n\t}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7497",
          "author": "Qingyu"
        },
        {
          "title": "Editorial Codeforces Round #181 (Div.2) - Codeforces - Code 1",
          "code": "int height = 0;\nwhile (n > 1 && n % 2 == 1) {\n n /= 2; height++;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7497",
          "author": "Qingyu"
        },
        {
          "title": "Editorial Codeforces Round #181 (Div.2) - Codeforces - Code 2",
          "code": "int height = 0;\nwhile (n > 1 && n % 2 == 1) {\n n /= 2; height++;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7497",
          "author": "Qingyu"
        },
        {
          "title": "Editorial Codeforces Round #181 (Div.2) - Codeforces - Code 3",
          "code": "z[0][0] = 1; z[0][i] = 0, i > 0; z[i][0] = 1, i > 0\nz[i][j] = 0;\nfor(int k1 = 0; k1 <= j - 1; k1++) \n  for(int k2 = 0; k2 <= j - 1 - k1; k2++)\n    for(int k3 = 0; k3 <= j - 1 - k1 - k2; k3++)\n      {\n         int k4 = j - 1 - k1 - k2 - k3;\n  z[i][j] += z[i-1][k1] * z[i-1][k2] * z[i-1][k3] * z[i-1][k4];\n  z[i][j] %= mod;\n      }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7497",
          "author": "Qingyu"
        },
        {
          "title": "Editorial Codeforces Round #181 (Div.2) - Codeforces - Code 4",
          "code": "z[0][0] = 1; z[0][i] = 0, i > 0; z[i][0] = 1, i > 0\nz[i][j] = 0;\nfor(int k1 = 0; k1 <= j - 1; k1++) \n  for(int k2 = 0; k2 <= j - 1 - k1; k2++)\n    for(int k3 = 0; k3 <= j - 1 - k1 - k2; k3++)\n      {\n         int k4 = j - 1 - k1 - k2 - k3;\n  z[i][j] += z[i-1][k1] * z[i-1][k2] * z[i-1][k3] * z[i-1][k4];\n  z[i][j] %= mod;\n      }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7497",
          "author": "Qingyu"
        },
        {
          "title": "Editorial Codeforces Round #181 (Div.2) - Codeforces - Code 5",
          "code": "for(int i = max; i>=2; i--) {\n if (lp[i] != i) \n  cnt[lp[i]] += cnt[i];\n cnt[i / lp[i]] += cnt[i];\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7497",
          "author": "Qingyu"
        },
        {
          "title": "Editorial Codeforces Round #181 (Div.2) - Codeforces - Code 6",
          "code": "for(int i = max; i>=2; i--) {\n if (lp[i] != i) \n  cnt[lp[i]] += cnt[i];\n cnt[i / lp[i]] += cnt[i];\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7497",
          "author": "Qingyu"
        },
        {
          "title": "Editorial Codeforces Round #181 (Div.2) - Codeforces - Code 7",
          "code": "for(int j=0; j<=MK; j++)\n                        for(int k=0; k<=MK-j; k++)\n                                d[j+k]+=dp[i][j]*dp[i][k];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7497",
          "author": "Qingyu"
        },
        {
          "title": "Editorial Codeforces Round #181 (Div.2) - Codeforces - Code 8",
          "code": "for(int j=0; j<=MK; j++)\n                        for(int k=0; k<=MK-j; k++)\n                                d[j+k]+=dp[i][j]*dp[i][k];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7497",
          "author": "Qingyu"
        },
        {
          "title": "Editorial Codeforces Round #181 (Div.2) - Codeforces - Code 9",
          "code": "for(int j=0; j<=MK; j++)\n                        for(int k=0; k<=MK-j; k++)\n                                dp[i+1][j+k+1]+=d[j]*d[k];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7497",
          "author": "Qingyu"
        },
        {
          "title": "Editorial Codeforces Round #181 (Div.2) - Codeforces - Code 10",
          "code": "for(int j=0; j<=MK; j++)\n                        for(int k=0; k<=MK-j; k++)\n                                dp[i+1][j+k+1]+=d[j]*d[k];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7497",
          "author": "Qingyu"
        },
        {
          "title": "Editorial Codeforces Round #181 (Div.2) - Codeforces - Code 11",
          "code": "for(int i=10000000;i>=2;i--)\n\t{\n\t\tCount[Min[i]]+=Delta[i];\n\t\tDelta[i/Prime[Min[i]]]+=Delta[i];\n\t}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7497",
          "author": "Qingyu"
        },
        {
          "title": "Editorial Codeforces Round #181 (Div.2) - Codeforces - Code 12",
          "code": "for(int i=10000000;i>=2;i--)\n\t{\n\t\tCount[Min[i]]+=Delta[i];\n\t\tDelta[i/Prime[Min[i]]]+=Delta[i];\n\t}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7497",
          "author": "Qingyu"
        },
        {
          "title": "Editorial Codeforces Round #181 (Div.2) - Codeforces - Code 13",
          "code": "for(int i = 0; i < n; i++) scanf(\"%d\",&a[i]),cnt[a[i]]++,sum+=a[i];\n\tfor(int i = M - 10; i >= 2; i--) cnt[i] += cnt[i+1];\n\tfor(int i = M - 10; i >= 2; i--)\n\t{\n\t\tif(lp[i]!=i) cnt[lp[i]] += cnt[i];\n\t\tcnt[i/lp[i]] += cnt[i];\n\t}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7497",
          "author": "Qingyu"
        },
        {
          "title": "Editorial Codeforces Round #181 (Div.2) - Codeforces - Code 14",
          "code": "for(int i = 0; i < n; i++) scanf(\"%d\",&a[i]),cnt[a[i]]++,sum+=a[i];\n\tfor(int i = M - 10; i >= 2; i--) cnt[i] += cnt[i+1];\n\tfor(int i = M - 10; i >= 2; i--)\n\t{\n\t\tif(lp[i]!=i) cnt[lp[i]] += cnt[i];\n\t\tcnt[i/lp[i]] += cnt[i];\n\t}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7497",
          "author": "Qingyu"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    \n    int q = inf.readInt(1, 100000, \"q\");\n    inf.readEoln();\n\n    for(int test = 0; test < q; test++) {\n        int n = inf.readInt(1, 1000000000, \"n\");\n        inf.readSpace();\n        int k = inf.readInt(0, 1000, \"k\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    \n    int q = inf.readInt(1, 100000, \"q\");\n    inf.readEoln();\n\n    for(int test = 0; test < q; test++) {\n        int n = inf.readInt(1, 1000000000, \"n\");\n        inf.readSpace();\n        int k = inf.readInt(0, 1000, \"k\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    \n    int q = inf.readInt(1, 100000, \"q\");\n    inf.readEoln();\n\n    for(int test = 0; test < q; test++) {\n        int n = inf.readInt(1, 1000000000, \"n\");\n        inf.readSpace();\n        int k = inf.readInt(0, 1000, \"k\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAX_N = 1000000000; // 1e9\nconst int MAX_K = 1000;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int q = opt<int>(\"q\");\n    string type = opt<string>(\"type\", \"random\");\n\n    if (type == \"samples\") {\n        // Output the sample test cases from the problem statement\n        printf(\"8\\n\");\n        printf(\"1 0\\n\");\n        printf(\"1 1\\n\");\n        printf(\"3 0\\n\");\n        printf(\"3 1\\n\");\n        printf(\"2 0\\n\");\n        printf(\"2 1\\n\");\n        printf(\"3 2\\n\");\n        printf(\"7 2\\n\");\n    } else {\n        // If the type is 'large_q_random', set q to the maximum value\n        if (type == \"large_q_random\") {\n            q = 100000;\n        }\n        printf(\"%d\\n\", q);\n        for (int i = 0; i < q; ++i) {\n            int n, k;\n            if (type == \"random\") {\n                n = rnd.next(1, MAX_N);\n                k = rnd.next(0, MAX_K);\n            } else if (type == \"min_n\") {\n                n = 1;\n                k = rnd.next(0, MAX_K);\n            } else if (type == \"max_n\") {\n                n = MAX_N;\n                k = rnd.next(0, MAX_K);\n            } else if (type == \"min_k\") {\n                n = rnd.next(1, MAX_N);\n                k = 0;\n            } else if (type == \"max_k\") {\n                n = rnd.next(1, MAX_N);\n                k = MAX_K;\n            } else if (type == \"n_equals_k\") {\n                n = rnd.next(1, MAX_K);\n                k = n;\n            } else if (type == \"n_large_k_small\") {\n                n = rnd.next(100000000, MAX_N); // n between 1e8 and 1e9\n                k = rnd.next(0, 10);\n            } else if (type == \"n_small_k_large\") {\n                n = rnd.next(1, 1000);\n                k = rnd.next(500, MAX_K);\n            } else {\n                // Default to random if the type is unrecognized\n                n = rnd.next(1, MAX_N);\n                k = rnd.next(0, MAX_K);\n            }\n            printf(\"%d %d\\n\", n, k);\n        }\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAX_N = 1000000000; // 1e9\nconst int MAX_K = 1000;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int q = opt<int>(\"q\");\n    string type = opt<string>(\"type\", \"random\");\n\n    if (type == \"samples\") {\n        // Output the sample test cases from the problem statement\n        printf(\"8\\n\");\n        printf(\"1 0\\n\");\n        printf(\"1 1\\n\");\n        printf(\"3 0\\n\");\n        printf(\"3 1\\n\");\n        printf(\"2 0\\n\");\n        printf(\"2 1\\n\");\n        printf(\"3 2\\n\");\n        printf(\"7 2\\n\");\n    } else {\n        // If the type is 'large_q_random', set q to the maximum value\n        if (type == \"large_q_random\") {\n            q = 100000;\n        }\n        printf(\"%d\\n\", q);\n        for (int i = 0; i < q; ++i) {\n            int n, k;\n            if (type == \"random\") {\n                n = rnd.next(1, MAX_N);\n                k = rnd.next(0, MAX_K);\n            } else if (type == \"min_n\") {\n                n = 1;\n                k = rnd.next(0, MAX_K);\n            } else if (type == \"max_n\") {\n                n = MAX_N;\n                k = rnd.next(0, MAX_K);\n            } else if (type == \"min_k\") {\n                n = rnd.next(1, MAX_N);\n                k = 0;\n            } else if (type == \"max_k\") {\n                n = rnd.next(1, MAX_N);\n                k = MAX_K;\n            } else if (type == \"n_equals_k\") {\n                n = rnd.next(1, MAX_K);\n                k = n;\n            } else if (type == \"n_large_k_small\") {\n                n = rnd.next(100000000, MAX_N); // n between 1e8 and 1e9\n                k = rnd.next(0, 10);\n            } else if (type == \"n_small_k_large\") {\n                n = rnd.next(1, 1000);\n                k = rnd.next(500, MAX_K);\n            } else {\n                // Default to random if the type is unrecognized\n                n = rnd.next(1, MAX_N);\n                k = rnd.next(0, MAX_K);\n            }\n            printf(\"%d %d\\n\", n, k);\n        }\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -q 1 -type random\n./gen -q 1 -type min_n\n./gen -q 1 -type max_n\n./gen -q 1 -type min_k\n./gen -q 1 -type max_k\n./gen -q 1 -type n_equals_k\n./gen -q 1 -type n_large_k_small\n./gen -q 1 -type n_small_k_large\n\n./gen -q 100 -type random\n./gen -q 100 -type min_n\n./gen -q 100 -type max_n\n./gen -q 100 -type min_k\n./gen -q 100 -type max_k\n./gen -q 100 -type n_equals_k\n./gen -q 100 -type n_large_k_small\n./gen -q 100 -type n_small_k_large\n\n./gen -q 1000 -type random\n./gen -q 1000 -type min_n\n./gen -q 1000 -type max_n\n./gen -q 1000 -type min_k\n./gen -q 1000 -type max_k\n./gen -q 1000 -type n_equals_k\n./gen -q 1000 -type n_large_k_small\n./gen -q 1000 -type n_small_k_large\n\n./gen -q 100000 -type random\n./gen -q 100000 -type min_n\n./gen -q 100000 -type max_n\n./gen -q 100000 -type min_k\n./gen -q 100000 -type max_k\n./gen -q 100000 -type n_equals_k\n./gen -q 100000 -type n_large_k_small\n./gen -q 100000 -type n_small_k_large\n\n./gen -q 1 -type samples\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:04:58.325414",
        "total_tutorials": 3,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "300/E",
      "title": "E. Империя наносит ответный удар",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест5 seconds",
      "memory_limit": "ограничение по памяти на тест512 megabytes",
      "input_spec": "Входные данныеВ первой строке записано целое число k (1 ≤ k ≤ 106). Во второй строке записаны k целых чисел a1, a2, ..., ak (1 ≤ ai ≤ 107).",
      "output_spec": "Выходные данныеВыведите минимальное целое положительное число n, необходимое для победы Империи.Пожалуйста, не используйте спецификатор %lld для чтения или записи 64-х битовых чисел на С++. Рекомендуется использовать потоки cin, cout или спецификатор %I64d.",
      "sample_tests": "ПримерыВходные данныеСкопировать21000 1000Выходные данныеСкопировать2000Входные данныеСкопировать12Выходные данныеСкопировать2",
      "description": "E. Империя наносит ответный удар\n\nограничение по времени на тест5 seconds\n\nограничение по времени на тест\n\nограничение по памяти на тест512 megabytes\n\nограничение по памяти на тест\n\nвыводstdout\n\nВходные данныеВ первой строке записано целое число k (1 ≤ k ≤ 106). Во второй строке записаны k целых чисел a1, a2, ..., ak (1 ≤ ai ≤ 107).\n\nВходные данные\n\nВыходные данныеВыведите минимальное целое положительное число n, необходимое для победы Империи.Пожалуйста, не используйте спецификатор %lld для чтения или записи 64-х битовых чисел на С++. Рекомендуется использовать потоки cin, cout или спецификатор %I64d.\n\nВыходные данные\n\nВходные данныеСкопировать21000 1000Выходные данныеСкопировать2000Входные данныеСкопировать12Выходные данныеСкопировать2\n\nВходные данныеСкопировать21000 1000\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать2000\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать12\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать2\n\nВыходные данныеСкопировать\n\nСкопировать",
      "solutions": [
        {
          "title": "Codeforces Round #181 (Div. 2) - Codeforces",
          "content": "Всем привет!Очень скоро, 25 апреля в 19:30 MSK, состоится очередной Codeforces Round #181 для участников Div. 2. Как обычно, Div. 1 участники смогут поучаствовать в этом раунде вне конкурса.Задачи были подготовлены группой авторов в составе: Гриднев Виталий (gridnevvvit), Игнатьев Александр (aiMR). Выражаем благодарность Геральду Агапову(Gerald) за помощь в подготовке задач, Михаилу Мирзаянову(MikeMirzayanov) за замечательные системы Codeforces и Polygon, Марии Беловой(Delinur) за перевод задач на английский язык.Немного информации об авторах: я и Александр — студенты 3 курса Механико-Математического факультета Саратовского Государственного Университета. Для нас это первый раунд и, я думаю, что не последний. Мы надеемся, что Вам понравятся наши задачи, и вы получите удовольствие от их решения. Также настоятельно рекомендую Вам прочесть условия всех задач! Всем удачи и высокого рейтинга!UPD: Разбалловка задач будет динамической. Задачи расположены в порядке предполагаемой сложности.UPD1: Разбор задачUPD2: Соревнование закончено. Поздравляем победителей: ballmaids02 VIProgrammer emachaidze",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/7479",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 1104
        },
        {
          "title": "Разбор задач Codeforces Round #181 (Div.2) - Codeforces",
          "content": "300A - МассивВ этой задаче нужно было просто реализовать следующий алгоритм. Разделим входной массив на 3 вектора: первый будет содержать все отрицательные числа, второй — все положительные числа, третий — ноль. Если первый вектор содержит четное количество элементов, то переместим ровно одно число в третий вектор. Если второй вектор пуст, то переместим ровно 2 элемента из первого вектора во второй.Такое решение работает за O(n)Авторское решение300B - ТренерЗаметим, что входных данных задан некоторый граф. Заметим, что если в этом графе есть хотя бы одна компонента связности, в которой как минимум 4 вершины, то ответ очевидно  - 1. Сразу следует заметить, что все компоненты связности, в которых уже ровно 3 вершины, уже образуют некоторую команду. Далее у нас остались компоненты связности, в которых либо 1 вершина, либо 2. Не трудно понять, что если количество компонент, в которых ровно 2 вершины больше количества компонент с 1 вершиной, то ответ  - 1. Иначе решение существует. Каждой компоненте из 2 вершин сопоставим одну компоненту из 1 вершины. Далее соединим все одноэлементые компоненты в группы по 3. Таким образом, получим решение за ассимптотику O(n + m).Также следует отметить, что также можно было написать решение и за ассимптотику O(n4).Авторское решение300C - Прекрасные числаПусть MOD = 1000000007. Для начала подсчитаем массив fact[i] = i!%MOD, . Далее будем перебирать, сколько раз встретится цифра a в искомом числе. Пусть она встречается i раз. Тогда очевидно, что мы можем подсчитать какова сумма цифр в нашем числе сейчас: val = ai + b(n - i). Если число val — хорошее, то к ответу нужно прибавить C[n][i]. Однако n слишком большее, чтобы считать биномиальные коэффициенты используя треугольник Паскаля. Тогда C[n][i] = fact[n]inv(fact[n - i]fact[i]). inv(a) — обратный элемент в кольце по модулю. Так как модуль простой, то inv(a) = aMOD - 2. Возвести число a в степень, можно используя бинарное возведение в степень.Авторское решение300D - Покраска квадратаЭта картинка полезна для понимания.Переформулируем задачу в терминах графов:Нам задана таблица n × n, которая представляет некоторый граф следующего вида: Этот граф — дерево У всех вершин, кроме листьев, ровно четыре сына Пусть некоторая вершина удалена от корня на расстояние k. Тогда существует ровно 4k вершин, которые также удалены на расстояние k. Нам нужно покрасить ровно k вершин этого графа. Причем, если вершина i покрашена, то тогда покрашены все вершины, лежащие на пути из вершины 1 до вершины i. Понятно, что мы можем однозначно восстановить дерево по его высоте. Высоту графа можно найти с помощью простого кода: int height = 0;\nwhile (n > 1 && n % 2 == 1) {\n\tn /= 2; height++;\n}Поэтому заведем следующее динамическое программирование: z[i][j] — количество способов раскрасить граф высоты i за j операций.Можно привести простой код решения за ассимптотику O(k4log(n)): z[0][0] = 1; z[0][i] = 0, i > 0; z[i][0] = 1, i > 0\nz[i][j] = 0;\nfor(int k1 = 0; k1 <= j - 1; k1++) \n for(int k2 = 0; k2 <= j - 1 - k1; k2++)\n for(int k3 = 0; k3 <= j - 1 - k1 - k2; k3++)\n {\n int k4 = j - 1 - k1 - k2 - k3;\n\t z[i][j] += z[i-1][k1] * z[i-1][k2] * z[i-1][k3] * z[i-1][k4];\n\t z[i][j] %= mod;\n }Однако такое решение работает долго. Пусть z[i][j] — означает что оно и означало раньше:количество способов раскрасить граф высоты i за j операций. Однако посмотрим на него с другой стороны: z[i][j] — коэффициент при j степени i-ого многочлена. Тогда не трудно заметить что z[i + 1][j + 1] — коэффициент при j степени i-ого многочлена, возведенного в 4 степень. Таким образом получим решение за ассимптотику O(k2log(n)). Модуль, указанный в условии, позволяет так же воспользоваться быстрым преобразованием Фурье и написать решение за ассимптотику O(klog(k)log(n)). Однако такое решение все равно может получить ТЛ, если вы часто будете брать по модулю. Так как модуль довольно не большой ( ≤ 107) можно брать по модулю реже. Это позволяет ускорить работу решения в несколько раз. Авторское решение. Использует FFTАвторское решение. Без FFT300E - Империя наносит ответный ударПусть . val это верхняя граница ответа. val! делится на , это просто доказать, используя то факт, что . Так же, — мультиномиальный коэффициент. Итак, ответ не превосходит 1013. Если n! делится на den, тогда (n + 1)! также делится на den. Это означает, что мы можем использовать бинарный поиск по ответу.Для всех i, i = 2..., 107, посчитаем максимальное простое в i, используя линейное решето Эратосфена. Пусть для i — это lp[i]. Также предпосчитаем все простые  ≤ 107.Далее предпосчитаем cnt[i] — количество чисел a, i <  = a.Теперь мы можем посчитать факторизацию знаменателя: for(int i = max; i>=2; i--) {\n if (lp[i] != i) \n cnt[lp[i]] += cnt[i];\n cnt[i / lp[i]] += cnt[i];\n}Далее воспользуемся бинарным поиском от lf = 1 до .Авторское решение",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/7497",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 300\\s*E"
          },
          "content_length": 4806
        },
        {
          "title": "Разбор задач Codeforces Round #181 (Div.2) - Codeforces",
          "content": "300A - МассивВ этой задаче нужно было просто реализовать следующий алгоритм. Разделим входной массив на 3 вектора: первый будет содержать все отрицательные числа, второй — все положительные числа, третий — ноль. Если первый вектор содержит четное количество элементов, то переместим ровно одно число в третий вектор. Если второй вектор пуст, то переместим ровно 2 элемента из первого вектора во второй.Такое решение работает за O(n)Авторское решение300B - ТренерЗаметим, что входных данных задан некоторый граф. Заметим, что если в этом графе есть хотя бы одна компонента связности, в которой как минимум 4 вершины, то ответ очевидно  - 1. Сразу следует заметить, что все компоненты связности, в которых уже ровно 3 вершины, уже образуют некоторую команду. Далее у нас остались компоненты связности, в которых либо 1 вершина, либо 2. Не трудно понять, что если количество компонент, в которых ровно 2 вершины больше количества компонент с 1 вершиной, то ответ  - 1. Иначе решение существует. Каждой компоненте из 2 вершин сопоставим одну компоненту из 1 вершины. Далее соединим все одноэлементые компоненты в группы по 3. Таким образом, получим решение за ассимптотику O(n + m).Также следует отметить, что также можно было написать решение и за ассимптотику O(n4).Авторское решение300C - Прекрасные числаПусть MOD = 1000000007. Для начала подсчитаем массив fact[i] = i!%MOD, . Далее будем перебирать, сколько раз встретится цифра a в искомом числе. Пусть она встречается i раз. Тогда очевидно, что мы можем подсчитать какова сумма цифр в нашем числе сейчас: val = ai + b(n - i). Если число val — хорошее, то к ответу нужно прибавить C[n][i]. Однако n слишком большее, чтобы считать биномиальные коэффициенты используя треугольник Паскаля. Тогда C[n][i] = fact[n]inv(fact[n - i]fact[i]). inv(a) — обратный элемент в кольце по модулю. Так как модуль простой, то inv(a) = aMOD - 2. Возвести число a в степень, можно используя бинарное возведение в степень.Авторское решение300D - Покраска квадратаЭта картинка полезна для понимания.Переформулируем задачу в терминах графов:Нам задана таблица n × n, которая представляет некоторый граф следующего вида: Этот граф — дерево У всех вершин, кроме листьев, ровно четыре сына Пусть некоторая вершина удалена от корня на расстояние k. Тогда существует ровно 4k вершин, которые также удалены на расстояние k. Нам нужно покрасить ровно k вершин этого графа. Причем, если вершина i покрашена, то тогда покрашены все вершины, лежащие на пути из вершины 1 до вершины i. Понятно, что мы можем однозначно восстановить дерево по его высоте. Высоту графа можно найти с помощью простого кода: int height = 0;\nwhile (n > 1 && n % 2 == 1) {\n\tn /= 2; height++;\n}Поэтому заведем следующее динамическое программирование: z[i][j] — количество способов раскрасить граф высоты i за j операций.Можно привести простой код решения за ассимптотику O(k4log(n)): z[0][0] = 1; z[0][i] = 0, i > 0; z[i][0] = 1, i > 0\nz[i][j] = 0;\nfor(int k1 = 0; k1 <= j - 1; k1++) \n for(int k2 = 0; k2 <= j - 1 - k1; k2++)\n for(int k3 = 0; k3 <= j - 1 - k1 - k2; k3++)\n {\n int k4 = j - 1 - k1 - k2 - k3;\n\t z[i][j] += z[i-1][k1] * z[i-1][k2] * z[i-1][k3] * z[i-1][k4];\n\t z[i][j] %= mod;\n }Однако такое решение работает долго. Пусть z[i][j] — означает что оно и означало раньше:количество способов раскрасить граф высоты i за j операций. Однако посмотрим на него с другой стороны: z[i][j] — коэффициент при j степени i-ого многочлена. Тогда не трудно заметить что z[i + 1][j + 1] — коэффициент при j степени i-ого многочлена, возведенного в 4 степень. Таким образом получим решение за ассимптотику O(k2log(n)). Модуль, указанный в условии, позволяет так же воспользоваться быстрым преобразованием Фурье и написать решение за ассимптотику O(klog(k)log(n)). Однако такое решение все равно может получить ТЛ, если вы часто будете брать по модулю. Так как модуль довольно не большой ( ≤ 107) можно брать по модулю реже. Это позволяет ускорить работу решения в несколько раз. Авторское решение. Использует FFTАвторское решение. Без FFT300E - Империя наносит ответный ударПусть . val это верхняя граница ответа. val! делится на , это просто доказать, используя то факт, что . Так же, — мультиномиальный коэффициент. Итак, ответ не превосходит 1013. Если n! делится на den, тогда (n + 1)! также делится на den. Это означает, что мы можем использовать бинарный поиск по ответу.Для всех i, i = 2..., 107, посчитаем максимальное простое в i, используя линейное решето Эратосфена. Пусть для i — это lp[i]. Также предпосчитаем все простые  ≤ 107.Далее предпосчитаем cnt[i] — количество чисел a, i <  = a.Теперь мы можем посчитать факторизацию знаменателя: for(int i = max; i>=2; i--) {\n if (lp[i] != i) \n cnt[lp[i]] += cnt[i];\n cnt[i / lp[i]] += cnt[i];\n}Далее воспользуемся бинарным поиском от lf = 1 до .Авторское решение",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/7497",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 300\\s*E"
          },
          "content_length": 4806
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #181 (Div. 2) - Codeforces - Code 1",
          "code": "17 \tboy_boy10 \t0\n18 \tboy_boy9 \t0\n19 \tboy_boy8 \t0\n...",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7479",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #181 (Div. 2) - Codeforces - Code 2",
          "code": "17 \tboy_boy10 \t0\n18 \tboy_boy9 \t0\n19 \tboy_boy8 \t0\n...",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7479",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #181 (Div. 2) - Codeforces - Code 3",
          "code": "WTF???\nUPD: he has already -179 hacks...",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7479",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #181 (Div. 2) - Codeforces - Code 4",
          "code": "WTF???\nUPD: he has already -179 hacks...",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7479",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #181 (Div. 2) - Codeforces - Code 5",
          "code": "// ax + by = gcd(a,b) = d\nvoid eea(int a, int b, int& x, int& y, int& d) {\n    if (!b) {x = 1; y = 0; d = a; return; }\n    eea(b, a % b, x, y, d);\n    int x1 = y, y1 = x - (a / b) * y;\n    x = x1, y = y1;\n}\nint divide(int a, int b) {\n    int d, x, y;\n    eea(b, MOD, x, y, d);\n    // if(a%d==0)\n    return ((x+MOD)*(a/d)) % (MOD/d);\n    // else   \"no quotient\"\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7479",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #181 (Div. 2) - Codeforces - Code 6",
          "code": "// ax + by = gcd(a,b) = d\nvoid eea(int a, int b, int& x, int& y, int& d) {\n    if (!b) {x = 1; y = 0; d = a; return; }\n    eea(b, a % b, x, y, d);\n    int x1 = y, y1 = x - (a / b) * y;\n    x = x1, y = y1;\n}\nint divide(int a, int b) {\n    int d, x, y;\n    eea(b, MOD, x, y, d);\n    // if(a%d==0)\n    return ((x+MOD)*(a/d)) % (MOD/d);\n    // else   \"no quotient\"\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7479",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Codeforces Round #181 (Div.2) - Codeforces - Code 1",
          "code": "int height = 0;\nwhile (n > 1 && n % 2 == 1) {\n\tn /= 2; height++;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7497",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Codeforces Round #181 (Div.2) - Codeforces - Code 2",
          "code": "int height = 0;\nwhile (n > 1 && n % 2 == 1) {\n\tn /= 2; height++;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7497",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Codeforces Round #181 (Div.2) - Codeforces - Code 3",
          "code": "z[0][0] = 1; z[0][i] = 0, i > 0; z[i][0] = 1, i > 0\nz[i][j] = 0;\nfor(int k1 = 0; k1 <= j - 1; k1++) \n  for(int k2 = 0; k2 <= j - 1 - k1; k2++)\n    for(int k3 = 0; k3 <= j - 1 - k1 - k2; k3++)\n      {\n         int k4 = j - 1 - k1 - k2 - k3;\n\t z[i][j] += z[i-1][k1] * z[i-1][k2] * z[i-1][k3] * z[i-1][k4];\n\t z[i][j] %= mod;\n      }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7497",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Codeforces Round #181 (Div.2) - Codeforces - Code 4",
          "code": "z[0][0] = 1; z[0][i] = 0, i > 0; z[i][0] = 1, i > 0\nz[i][j] = 0;\nfor(int k1 = 0; k1 <= j - 1; k1++) \n  for(int k2 = 0; k2 <= j - 1 - k1; k2++)\n    for(int k3 = 0; k3 <= j - 1 - k1 - k2; k3++)\n      {\n         int k4 = j - 1 - k1 - k2 - k3;\n\t z[i][j] += z[i-1][k1] * z[i-1][k2] * z[i-1][k3] * z[i-1][k4];\n\t z[i][j] %= mod;\n      }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7497",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Codeforces Round #181 (Div.2) - Codeforces - Code 5",
          "code": "for(int i = max; i>=2; i--) {\n if (lp[i] != i) \n  cnt[lp[i]] += cnt[i];\n cnt[i / lp[i]] += cnt[i];\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7497",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Codeforces Round #181 (Div.2) - Codeforces - Code 6",
          "code": "for(int i = max; i>=2; i--) {\n if (lp[i] != i) \n  cnt[lp[i]] += cnt[i];\n cnt[i / lp[i]] += cnt[i];\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7497",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Codeforces Round #181 (Div.2) - Codeforces - Code 7",
          "code": "for(i = n; i > b; i--){\n        ll x = i;\n        while(a > 0 && x % a == 0){ x /= a; a--;}\n        v.pb(x);\n    }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7497",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Codeforces Round #181 (Div.2) - Codeforces - Code 8",
          "code": "for(i = n; i > b; i--){\n        ll x = i;\n        while(a > 0 && x % a == 0){ x /= a; a--;}\n        v.pb(x);\n    }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7497",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Codeforces Round #181 (Div.2) - Codeforces - Code 9",
          "code": "for(int j=0; j<=MK; j++)\n                        for(int k=0; k<=MK-j; k++)\n                                d[j+k]+=dp[i][j]*dp[i][k];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7497",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Codeforces Round #181 (Div.2) - Codeforces - Code 10",
          "code": "for(int j=0; j<=MK; j++)\n                        for(int k=0; k<=MK-j; k++)\n                                d[j+k]+=dp[i][j]*dp[i][k];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7497",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Codeforces Round #181 (Div.2) - Codeforces - Code 11",
          "code": "for(int j=0; j<=MK; j++)\n                        for(int k=0; k<=MK-j; k++)\n                                dp[i+1][j+k+1]+=d[j]*d[k];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7497",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Codeforces Round #181 (Div.2) - Codeforces - Code 12",
          "code": "for(int j=0; j<=MK; j++)\n                        for(int k=0; k<=MK-j; k++)\n                                dp[i+1][j+k+1]+=d[j]*d[k];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7497",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Codeforces Round #181 (Div.2) - Codeforces - Code 13",
          "code": "for(int i=10000000;i>=2;i--)\n\t{\n\t\tCount[Min[i]]+=Delta[i];\n\t\tDelta[i/Prime[Min[i]]]+=Delta[i];\n\t}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7497",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Codeforces Round #181 (Div.2) - Codeforces - Code 14",
          "code": "for(int i=10000000;i>=2;i--)\n\t{\n\t\tCount[Min[i]]+=Delta[i];\n\t\tDelta[i/Prime[Min[i]]]+=Delta[i];\n\t}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7497",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Codeforces Round #181 (Div.2) - Codeforces - Code 15",
          "code": "for(int i = 0; i < n; i++) scanf(\"%d\",&a[i]),cnt[a[i]]++,sum+=a[i];\n\tfor(int i = M - 10; i >= 2; i--) cnt[i] += cnt[i+1];\n\tfor(int i = M - 10; i >= 2; i--)\n\t{\n\t\tif(lp[i]!=i) cnt[lp[i]] += cnt[i];\n\t\tcnt[i/lp[i]] += cnt[i];\n\t}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7497",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Codeforces Round #181 (Div.2) - Codeforces - Code 16",
          "code": "for(int i = 0; i < n; i++) scanf(\"%d\",&a[i]),cnt[a[i]]++,sum+=a[i];\n\tfor(int i = M - 10; i >= 2; i--) cnt[i] += cnt[i+1];\n\tfor(int i = M - 10; i >= 2; i--)\n\t{\n\t\tif(lp[i]!=i) cnt[lp[i]] += cnt[i];\n\t\tcnt[i/lp[i]] += cnt[i];\n\t}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7497",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Codeforces Round #181 (Div.2) - Codeforces - Code 1",
          "code": "int height = 0;\nwhile (n > 1 && n % 2 == 1) {\n\tn /= 2; height++;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7497",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Codeforces Round #181 (Div.2) - Codeforces - Code 2",
          "code": "int height = 0;\nwhile (n > 1 && n % 2 == 1) {\n\tn /= 2; height++;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7497",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Codeforces Round #181 (Div.2) - Codeforces - Code 3",
          "code": "z[0][0] = 1; z[0][i] = 0, i > 0; z[i][0] = 1, i > 0\nz[i][j] = 0;\nfor(int k1 = 0; k1 <= j - 1; k1++) \n  for(int k2 = 0; k2 <= j - 1 - k1; k2++)\n    for(int k3 = 0; k3 <= j - 1 - k1 - k2; k3++)\n      {\n         int k4 = j - 1 - k1 - k2 - k3;\n\t z[i][j] += z[i-1][k1] * z[i-1][k2] * z[i-1][k3] * z[i-1][k4];\n\t z[i][j] %= mod;\n      }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7497",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Codeforces Round #181 (Div.2) - Codeforces - Code 4",
          "code": "z[0][0] = 1; z[0][i] = 0, i > 0; z[i][0] = 1, i > 0\nz[i][j] = 0;\nfor(int k1 = 0; k1 <= j - 1; k1++) \n  for(int k2 = 0; k2 <= j - 1 - k1; k2++)\n    for(int k3 = 0; k3 <= j - 1 - k1 - k2; k3++)\n      {\n         int k4 = j - 1 - k1 - k2 - k3;\n\t z[i][j] += z[i-1][k1] * z[i-1][k2] * z[i-1][k3] * z[i-1][k4];\n\t z[i][j] %= mod;\n      }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7497",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Codeforces Round #181 (Div.2) - Codeforces - Code 5",
          "code": "for(int i = max; i>=2; i--) {\n if (lp[i] != i) \n  cnt[lp[i]] += cnt[i];\n cnt[i / lp[i]] += cnt[i];\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7497",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Codeforces Round #181 (Div.2) - Codeforces - Code 6",
          "code": "for(int i = max; i>=2; i--) {\n if (lp[i] != i) \n  cnt[lp[i]] += cnt[i];\n cnt[i / lp[i]] += cnt[i];\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7497",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Codeforces Round #181 (Div.2) - Codeforces - Code 7",
          "code": "for(i = n; i > b; i--){\n        ll x = i;\n        while(a > 0 && x % a == 0){ x /= a; a--;}\n        v.pb(x);\n    }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7497",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Codeforces Round #181 (Div.2) - Codeforces - Code 8",
          "code": "for(i = n; i > b; i--){\n        ll x = i;\n        while(a > 0 && x % a == 0){ x /= a; a--;}\n        v.pb(x);\n    }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7497",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Codeforces Round #181 (Div.2) - Codeforces - Code 9",
          "code": "for(int j=0; j<=MK; j++)\n                        for(int k=0; k<=MK-j; k++)\n                                d[j+k]+=dp[i][j]*dp[i][k];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7497",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Codeforces Round #181 (Div.2) - Codeforces - Code 10",
          "code": "for(int j=0; j<=MK; j++)\n                        for(int k=0; k<=MK-j; k++)\n                                d[j+k]+=dp[i][j]*dp[i][k];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7497",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Codeforces Round #181 (Div.2) - Codeforces - Code 11",
          "code": "for(int j=0; j<=MK; j++)\n                        for(int k=0; k<=MK-j; k++)\n                                dp[i+1][j+k+1]+=d[j]*d[k];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7497",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Codeforces Round #181 (Div.2) - Codeforces - Code 12",
          "code": "for(int j=0; j<=MK; j++)\n                        for(int k=0; k<=MK-j; k++)\n                                dp[i+1][j+k+1]+=d[j]*d[k];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7497",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Codeforces Round #181 (Div.2) - Codeforces - Code 13",
          "code": "for(int i=10000000;i>=2;i--)\n\t{\n\t\tCount[Min[i]]+=Delta[i];\n\t\tDelta[i/Prime[Min[i]]]+=Delta[i];\n\t}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7497",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Codeforces Round #181 (Div.2) - Codeforces - Code 14",
          "code": "for(int i=10000000;i>=2;i--)\n\t{\n\t\tCount[Min[i]]+=Delta[i];\n\t\tDelta[i/Prime[Min[i]]]+=Delta[i];\n\t}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7497",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Codeforces Round #181 (Div.2) - Codeforces - Code 15",
          "code": "for(int i = 0; i < n; i++) scanf(\"%d\",&a[i]),cnt[a[i]]++,sum+=a[i];\n\tfor(int i = M - 10; i >= 2; i--) cnt[i] += cnt[i+1];\n\tfor(int i = M - 10; i >= 2; i--)\n\t{\n\t\tif(lp[i]!=i) cnt[lp[i]] += cnt[i];\n\t\tcnt[i/lp[i]] += cnt[i];\n\t}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7497",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Codeforces Round #181 (Div.2) - Codeforces - Code 16",
          "code": "for(int i = 0; i < n; i++) scanf(\"%d\",&a[i]),cnt[a[i]]++,sum+=a[i];\n\tfor(int i = M - 10; i >= 2; i--) cnt[i] += cnt[i+1];\n\tfor(int i = M - 10; i >= 2; i--)\n\t{\n\t\tif(lp[i]!=i) cnt[lp[i]] += cnt[i];\n\t\tcnt[i/lp[i]] += cnt[i];\n\t}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7497",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int k = inf.readInt(1, 1000000, \"k\");\n    inf.readEoln();\n    inf.readInts(k, 1, 10000000);\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int k = inf.readInt(1, 1000000, \"k\");\n    inf.readEoln();\n    inf.readInts(k, 1, 10000000);\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int k = inf.readInt(1, 1000000, \"k\");\n    inf.readEoln();\n    inf.readInts(k, 1, 10000000);\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst int max_ai = 10000000;\nconst int min_ai = 1;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int k = opt<int>(\"k\");\n    int amin = opt<int>(\"amin\", 1);\n    int amax = opt<int>(\"amax\", max_ai);\n    string type = opt<string>(\"type\", \"random\");\n\n    // Ensure amin and amax are within allowed range\n    amin = max(min_ai, amin);\n    amax = min(max_ai, amax);\n    if (amin > amax) {\n        // Swap if necessary\n        swap(amin, amax);\n    }\n\n    vector<int> ai(k);\n\n    if (type == \"random\") {\n        for (int i = 0; i < k; ++i) {\n            ai[i] = rnd.next(amin, amax);\n        }\n    } else if (type == \"same\") {\n        int a = rnd.next(amin, amax);\n        for (int i = 0; i < k; ++i) {\n            ai[i] = a;\n        }\n    } else if (type == \"ascending\") {\n        // Ensure the sequence can accommodate k elements\n        if (amin + k - 1 > amax) {\n            amax = amin + k - 1;\n            if (amax > max_ai) amax = max_ai;\n        }\n        for (int i = 0; i < k; ++i) {\n            ai[i] = amin + i;\n            if (ai[i] > max_ai) ai[i] = max_ai;\n        }\n    } else if (type == \"descending\") {\n        if (amax - k + 1 < amin) {\n            amin = amax - k + 1;\n            if (amin < min_ai) amin = min_ai;\n        }\n        for (int i = 0; i < k; ++i) {\n            ai[i] = amax - i;\n            if (ai[i] < min_ai) ai[i] = min_ai;\n        }\n    } else if (type == \"alternating\") {\n        int a1 = amin;\n        int a2 = amax;\n        for (int i = 0; i < k; ++i) {\n            ai[i] = (i % 2 == 0) ? a1 : a2;\n        }\n    } else if (type == \"maxsum\") {\n        for (int i = 0; i < k; ++i) {\n            ai[i] = max_ai;\n        }\n    } else if (type == \"minsum\") {\n        for (int i = 0; i < k; ++i) {\n            ai[i] = min_ai;\n        }\n    } else {\n        // Default to random\n        for (int i = 0; i < k; ++i) {\n            ai[i] = rnd.next(amin, amax);\n        }\n    }\n\n    // Output the test case\n    printf(\"%d\\n\", k);\n    for (int i = 0; i < k; ++i) {\n        printf(\"%d\", ai[i]);\n        if (i < k - 1) printf(\" \");\n    }\n    printf(\"\\n\");\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst int max_ai = 10000000;\nconst int min_ai = 1;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int k = opt<int>(\"k\");\n    int amin = opt<int>(\"amin\", 1);\n    int amax = opt<int>(\"amax\", max_ai);\n    string type = opt<string>(\"type\", \"random\");\n\n    // Ensure amin and amax are within allowed range\n    amin = max(min_ai, amin);\n    amax = min(max_ai, amax);\n    if (amin > amax) {\n        // Swap if necessary\n        swap(amin, amax);\n    }\n\n    vector<int> ai(k);\n\n    if (type == \"random\") {\n        for (int i = 0; i < k; ++i) {\n            ai[i] = rnd.next(amin, amax);\n        }\n    } else if (type == \"same\") {\n        int a = rnd.next(amin, amax);\n        for (int i = 0; i < k; ++i) {\n            ai[i] = a;\n        }\n    } else if (type == \"ascending\") {\n        // Ensure the sequence can accommodate k elements\n        if (amin + k - 1 > amax) {\n            amax = amin + k - 1;\n            if (amax > max_ai) amax = max_ai;\n        }\n        for (int i = 0; i < k; ++i) {\n            ai[i] = amin + i;\n            if (ai[i] > max_ai) ai[i] = max_ai;\n        }\n    } else if (type == \"descending\") {\n        if (amax - k + 1 < amin) {\n            amin = amax - k + 1;\n            if (amin < min_ai) amin = min_ai;\n        }\n        for (int i = 0; i < k; ++i) {\n            ai[i] = amax - i;\n            if (ai[i] < min_ai) ai[i] = min_ai;\n        }\n    } else if (type == \"alternating\") {\n        int a1 = amin;\n        int a2 = amax;\n        for (int i = 0; i < k; ++i) {\n            ai[i] = (i % 2 == 0) ? a1 : a2;\n        }\n    } else if (type == \"maxsum\") {\n        for (int i = 0; i < k; ++i) {\n            ai[i] = max_ai;\n        }\n    } else if (type == \"minsum\") {\n        for (int i = 0; i < k; ++i) {\n            ai[i] = min_ai;\n        }\n    } else {\n        // Default to random\n        for (int i = 0; i < k; ++i) {\n            ai[i] = rnd.next(amin, amax);\n        }\n    }\n\n    // Output the test case\n    printf(\"%d\\n\", k);\n    for (int i = 0; i < k; ++i) {\n        printf(\"%d\", ai[i]);\n        if (i < k - 1) printf(\" \");\n    }\n    printf(\"\\n\");\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -k 1 -amin 1 -amax 1 -type same\n./gen -k 1 -amin 10000000 -amax 10000000 -type same\n./gen -k 2 -amin 1 -amax 10000000 -type alternating\n./gen -k 1000 -amin 1 -amax 1 -type same\n./gen -k 1000 -amin 10000000 -amax 10000000 -type same\n./gen -k 1000 -amin 1 -amax 1000 -type ascending\n./gen -k 1000 -amin 1 -amax 1000 -type descending\n./gen -k 1000000 -amin 1 -amax 1 -type same\n./gen -k 1000000 -amin 10000000 -amax 10000000 -type same\n./gen -k 1000000 -amin 1 -amax 10000000 -type random\n./gen -k 1000000 -amin 1 -amax 10000000 -type ascending\n./gen -k 1000000 -amin 1 -amax 10000000 -type descending\n./gen -k 1000000 -amin 1 -amax 10000000 -type alternating\n./gen -k 500000 -amin 1 -amax 10000000 -type alternating\n./gen -k 1000000 -type maxsum\n./gen -k 1000000 -type minsum\n./gen -k 1 -amin 10000000 -amax 10000000 -type same\n./gen -k 1000000 -amin 1 -amax 10 -type random\n./gen -k 500 -amin 9999990 -amax 10000000 -type random\n./gen -k 999999 -amin 1 -amax 1 -type same\n./gen -k 1000000 -amin 5000000 -amax 10000000 -type random\n./gen -k 1000000 -amin 1 -amax 5000000 -type random\n./gen -k 1000000 -amin 9999000 -amax 10000000 -type random\n./gen -k 1000000 -amin 1 -amax 1000 -type random\n./gen -k 1 -amin 1 -amax 1 -type same\n./gen -k 2 -amin 1 -amax 2 -type ascending\n./gen -k 10 -amin 10000000 -amax 10000000 -type same\n./gen -k 3 -amin 1 -amax 1 -type same\n./gen -k 1000000 -amin 1000 -amax 1000 -type same\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:05:00.286654",
        "total_tutorials": 3,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "301/A",
      "title": "A. Ярослав и последовательность",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест2 секунды",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеВ первой строке содержится целое число n (2 ≤ n ≤ 100). Во второй строке содержится (2·n - 1) целых чисел — элементы массива. Элементы массива не превосходят 1000 по модулю.",
      "output_spec": "Выходные данныеВ единственную строку выведите ответ на задачу — максимальную сумму, которою может получить Ярослав.",
      "sample_tests": "ПримерыВходные данныеСкопировать250 50 50Выходные данныеСкопировать150Входные данныеСкопировать2-1 -100 -1Выходные данныеСкопировать100",
      "description": "A. Ярослав и последовательность\n\nограничение по времени на тест2 секунды\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвыводstdout\n\nВходные данныеВ первой строке содержится целое число n (2 ≤ n ≤ 100). Во второй строке содержится (2·n - 1) целых чисел — элементы массива. Элементы массива не превосходят 1000 по модулю.\n\nВходные данные\n\nВыходные данныеВ единственную строку выведите ответ на задачу — максимальную сумму, которою может получить Ярослав.\n\nВыходные данные\n\nВходные данныеСкопировать250 50 50Выходные данныеСкопировать150Входные данныеСкопировать2-1 -100 -1Выходные данныеСкопировать100\n\nВходные данныеСкопировать250 50 50\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать150\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать2-1 -100 -1\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать100\n\nВыходные данныеСкопировать\n\nСкопировать\n\nПримечаниеВ первом примере ничего менять не нужно. Сумма элементов равна 150.Во втором примере стоит поменять знак у первых двух элементов. Тогда получим сумму элементов равную 100.",
      "solutions": [
        {
          "title": "Codeforces Round #182 - Codeforces",
          "content": "Всем привет!Совсем скоро, 5 мая в 19:30 MSK состоится Codeforces Round #182, автором которого являюсь я. Это мой шестой раунд на Codeforces и я надеюсь, что не последний.Спасибо Геральду Агапову (Gerald) и Диме Соболеву(sdya) за помощь в подготовке раунда и Марии Беловой (Delinur) за перевод условий на английский.Настоятельно рекомендую прочитать условия ВСЕХ задач.Gl & hf ! :)По техническим причинам начало соревнования было сорвано. Приносим извинения, контест будет НЕРЕЙТИНГОВЫМ.Разбор.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/7557",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 493
        },
        {
          "title": "Codeforces Round #182 - Codeforces",
          "content": "Всем привет!Совсем скоро, 5 мая в 19:30 MSK состоится Codeforces Round #182, автором которого являюсь я. Это мой шестой раунд на Codeforces и я надеюсь, что не последний.Спасибо Геральду Агапову (Gerald) и Диме Соболеву(sdya) за помощь в подготовке раунда и Марии Беловой (Delinur) за перевод условий на английский.Настоятельно рекомендую прочитать условия ВСЕХ задач.Gl & hf ! :)По техническим причинам начало соревнования было сорвано. Приносим извинения, контест будет НЕРЕЙТИНГОВЫМ.Разбор.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/7557",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 493
        },
        {
          "title": "Codeforces Round #182 tutorial - Codeforces",
          "content": "302A - Евгений и массивЕсли длина отрезка — парное число, и количество 1 и -1 по отдельности не меньше половины длины, то ответ положительный. 302B - Евгений и плейлистЗапомним для каждой песни момент, когда она окончится (например частичными суммами). Дальше просто бинарным поиском или двумя указателями найдем максимальный номер песни, что ее конец не меньше заданного числа. 301A - Ярослав и последовательностьС помощью поиска в глубину посчитаем сколько отрицательных чисел мы можем получить. Заметим, что можно сделать либо все числа положительными либо одно число отрицательное(показать это просто, если изменить знак у числа Ч и некоторого набора чисел, а затем у числа У с тем же набором). Если можно получить все положительные числа, то ответом будет просто сумма модулей чисел иначе нужно поменять знак у числа с минимальным значением по модулю. 301B - Ярослав и времяБинарным поиском будем искать ответ. Далее воспользуемся простым алгоритмом Форда-Белмана. На каждом шагу будем хранить максимальное значение таймера при нахождении персонажа в конкретной вершине, при переходе будем проверять: не умрет ли персонаж при переходе между вершинами. Если переход возможен, то будем обновлять значение конечной вершины. Благодаря тому что a_i<=d и координаты — целые мы не получим циклов. 301C - Ярослав и алгоритмНужно воспользоваться тем, что у нас есть знак вопроса(возможно, есть решение, которое не использует этот знак). Поставим знак вопроса в начало строки. Далее будем двигать его пока он не достигнет конца строки. Далее заменим его на два знака вопроса. И будем тянуть их к началу пока перед ним находится число 9, как только мы нашли другую цифру — просто увеличим ее и закончим алгоритм. Если мы дошли до начала строки, то просто поставим 1 в начало и закончим алгоритм.Смотрите любой прошедший код для большей ясности. 301D - Ярослав и делителиЗададим все пары вида: (x,y) ((d[x]%d[y]==0) || (d[y]%d[x]==0)). Задавать такие можно с помощью решета Эретосфена. Пар заданного вида будет порядка O(n*log(n)) благодаря тому, что нам задана перестановка. Дальше с помощью сортировки подсчетом отсортируем их. Отсортируем заданные на входе отрезки. Дальше для каждого такого отрезка нужно посчитать кол — во вложенных из заданных ранее. Такую задачу можно решить с помощью дерева Фенвика. На каждом шаге добавлять отрезки в порядке сортировки по правому краю. На каждой итерации будем обновлять Дерево Фенвика, которое сможет считать количество начал уже добавленных отрезков на отрезке. С помощью такой информации легко найти ответ. Сложность решения: O(n*log^2(n)), учитывая, что мы используем дерево Фенвика. Константа в решении очень маленькая. 301E - Ярослав и расстановкиБудем строить нужные нам массивы последовательно добавляя числа. Давайте посмотрим на то, какие параметры нам нужны. Во первых, очевидно что нужно хранить количество способов построить массив на уже добавленных числах, во вторых нужно знать общее количество добавленных чисел. Теперь посмотрим на то, что происходит когда мы добавляем новое число(то есть число, большее всех предыдущих в некотором количестве). Понятно, что добавленные числа должны стоять между числами на 1 меньше. При этом если мы поставим 2 новых числа подряд, то между ними должно стоять большее(так как меньшие мы уже расставили). При этом очевидно, что нужно покрыть все предыдущие числа(между которыми должны стоять новодобавленные).Таким образом имеем еще один параметр: количество чисел, между которыми мы можем ставить новые. Таким образом мы имеем динамику от четырех параметров: dp[all][ways][lastnumber][counttoadd].Переход.Понятно, что нужно добавлять не менее counttoadd чисел, но как это повлияет на количество способов расставить числа? Все просто. Пусть мы добавили x чисел, тогда количество способов нужно будет умножить на величину Q(x-counttoadd, counttoadd), где Q(x,y) — количество способов расставить x одинаковых шариков в y разных коробок. Q(x,y) = C(x+y-1,y-1), где C(x,y) — биномиальный коэффициент.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/7560",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 301\\s*A"
          },
          "content_length": 3984
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #182 - Codeforces - Code 1",
          "code": "**Server Problem !!!!**",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7557",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #182 - Codeforces - Code 2",
          "code": "**Bad Gateway**",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7557",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #182 - Codeforces - Code 3",
          "code": "-959 -542 -669 -513 160\n-959 -542 669 513 -160\n959 542 669 513 160",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7557",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #182 - Codeforces - Code 4",
          "code": "-959 -542 -669 -513 160\n-959 -542 669 513 -160\n959 542 669 513 160",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7557",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #182 - Codeforces - Code 5",
          "code": "3 1000\n3000\n0 0\n0 1\n0 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7557",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #182 - Codeforces - Code 6",
          "code": "3 1000\n3000\n0 0\n0 1\n0 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7557",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #182 - Codeforces - Code 7",
          "code": "3 100\n300\n0 0\n0 1\n0 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7557",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #182 - Codeforces - Code 8",
          "code": "3 100\n300\n0 0\n0 1\n0 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7557",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #182 - Codeforces - Code 9",
          "code": "3 1000\n2000\n0 0\n0 1\n0 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7557",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #182 - Codeforces - Code 10",
          "code": "3 1000\n2000\n0 0\n0 1\n0 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7557",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #182 - Codeforces - Code 11",
          "code": "??0>>0??\n??1>>1??\n??2>>2??\n??3>>3??\n??4>>4??\n??5>>5??\n??6>>6??\n??7>>7??\n??8>>8??\n??9>>9??\n??>>?\n0?<>1\n1?<>2\n2?<>3\n3?<>4\n4?<>5\n5?<>6\n6?<>7\n7?<>8\n8?<>9\n9?>>?0\n?<>1\n0>>??0\n1>>??1\n2>>??2\n3>>??3\n4>>??4\n5>>??5\n6>>??6\n7>>??7\n8>>??8\n9>>??9",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7557",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #182 - Codeforces - Code 12",
          "code": "??0>>0??\n??1>>1??\n??2>>2??\n??3>>3??\n??4>>4??\n??5>>5??\n??6>>6??\n??7>>7??\n??8>>8??\n??9>>9??\n??>>?\n0?<>1\n1?<>2\n2?<>3\n3?<>4\n4?<>5\n5?<>6\n6?<>7\n7?<>8\n8?<>9\n9?>>?0\n?<>1\n0>>??0\n1>>??1\n2>>??2\n3>>??3\n4>>??4\n5>>??5\n6>>??6\n7>>??7\n8>>??8\n9>>??9",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7557",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #182 - Codeforces - Code 13",
          "code": "98\n.7\n.6\n.5\n.4\n.3\n12",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7557",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #182 - Codeforces - Code 14",
          "code": "98\n.7\n.6\n.5\n.4\n.3\n12",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7557",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #182 - Codeforces - Code 1",
          "code": "**Server Problem !!!!**",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7557",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #182 - Codeforces - Code 2",
          "code": "**Bad Gateway**",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7557",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #182 - Codeforces - Code 3",
          "code": "-959 -542 -669 -513 160\n-959 -542 669 513 -160\n959 542 669 513 160",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7557",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #182 - Codeforces - Code 4",
          "code": "-959 -542 -669 -513 160\n-959 -542 669 513 -160\n959 542 669 513 160",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7557",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #182 - Codeforces - Code 5",
          "code": "3 1000\n3000\n0 0\n0 1\n0 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7557",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #182 - Codeforces - Code 6",
          "code": "3 1000\n3000\n0 0\n0 1\n0 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7557",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #182 - Codeforces - Code 7",
          "code": "3 100\n300\n0 0\n0 1\n0 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7557",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #182 - Codeforces - Code 8",
          "code": "3 100\n300\n0 0\n0 1\n0 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7557",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #182 - Codeforces - Code 9",
          "code": "3 1000\n2000\n0 0\n0 1\n0 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7557",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #182 - Codeforces - Code 10",
          "code": "3 1000\n2000\n0 0\n0 1\n0 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7557",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #182 - Codeforces - Code 11",
          "code": "??0>>0??\n??1>>1??\n??2>>2??\n??3>>3??\n??4>>4??\n??5>>5??\n??6>>6??\n??7>>7??\n??8>>8??\n??9>>9??\n??>>?\n0?<>1\n1?<>2\n2?<>3\n3?<>4\n4?<>5\n5?<>6\n6?<>7\n7?<>8\n8?<>9\n9?>>?0\n?<>1\n0>>??0\n1>>??1\n2>>??2\n3>>??3\n4>>??4\n5>>??5\n6>>??6\n7>>??7\n8>>??8\n9>>??9",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7557",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #182 - Codeforces - Code 12",
          "code": "??0>>0??\n??1>>1??\n??2>>2??\n??3>>3??\n??4>>4??\n??5>>5??\n??6>>6??\n??7>>7??\n??8>>8??\n??9>>9??\n??>>?\n0?<>1\n1?<>2\n2?<>3\n3?<>4\n4?<>5\n5?<>6\n6?<>7\n7?<>8\n8?<>9\n9?>>?0\n?<>1\n0>>??0\n1>>??1\n2>>??2\n3>>??3\n4>>??4\n5>>??5\n6>>??6\n7>>??7\n8>>??8\n9>>??9",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7557",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #182 - Codeforces - Code 13",
          "code": "98\n.7\n.6\n.5\n.4\n.3\n12",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7557",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #182 - Codeforces - Code 14",
          "code": "98\n.7\n.6\n.5\n.4\n.3\n12",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7557",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #182 tutorial - Codeforces - Code 1",
          "code": "8 1000\n1000 1000 1000 1000 1000 1000\n0 0 \n0 1\n1 1\n2 1\n2 0\n2 -1\n3 -1\n4 -1\n4 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7560",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #182 tutorial - Codeforces - Code 2",
          "code": "8 1000\n1000 1000 1000 1000 1000 1000\n0 0 \n0 1\n1 1\n2 1\n2 0\n2 -1\n3 -1\n4 -1\n4 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7560",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #182 tutorial - Codeforces - Code 3",
          "code": "for (int a = 1; a <= n; a++)\n    for (int b = a; b <= n; b += a)\n        remember_pair(a, b);// b % a == 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7560",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #182 tutorial - Codeforces - Code 4",
          "code": "for (int a = 1; a <= n; a++)\n    for (int b = a; b <= n; b += a)\n        remember_pair(a, b);// b % a == 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7560",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #182 tutorial - Codeforces - Code 5",
          "code": "ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    cin.tie(0);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7560",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #182 tutorial - Codeforces - Code 6",
          "code": "ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    cin.tie(0);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7560",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #182 tutorial - Codeforces - Code 7",
          "code": "3 1\n1000\n0 0\n0 100\n0 101",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7560",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #182 tutorial - Codeforces - Code 8",
          "code": "3 1\n1000\n0 0\n0 100\n0 101",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7560",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(2, 100);\n    inf.readEoln();\n    int m = 2 * n - 1;\n    vector<int> a = inf.readInts(m, -1000, 1000);\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(2, 100);\n    inf.readEoln();\n    int m = 2 * n - 1;\n    vector<int> a = inf.readInts(m, -1000, 1000);\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(2, 100);\n    inf.readEoln();\n    int m = 2 * n - 1;\n    vector<int> a = inf.readInts(m, -1000, 1000);\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    int len = 2 * n - 1;\n\n    vector<int> a(len);\n\n    if (type == \"random\") {\n        // Generate random integers in [-1000, 1000]\n        for (int i = 0; i < len; ++i) {\n            a[i] = rnd.next(-1000, 1000);\n        }\n    } else if (type == \"all_positive\") {\n        for (int i = 0; i < len; ++i) {\n            a[i] = rnd.next(1, 1000);\n        }\n    } else if (type == \"all_negative\") {\n        for (int i = 0; i < len; ++i) {\n            a[i] = rnd.next(-1000, -1);\n        }\n    } else if (type == \"zeros\") {\n        for (int i = 0; i < len; ++i) {\n            a[i] = 0;\n        }\n    } else if (type == \"max_positive\") {\n        for (int i = 0; i < len; ++i) {\n            a[i] = 1000;\n        }\n    } else if (type == \"max_negative\") {\n        for (int i = 0; i < len; ++i) {\n            a[i] = -1000;\n        }\n    } else if (type == \"alternating\") {\n        for (int i = 0; i < len; ++i) {\n            if (i % 2 == 0)\n                a[i] = -1000;\n            else\n                a[i] = 1000;\n        }\n    } else if (type == \"one_zero_rest_positive\") {\n        for (int i = 0; i < len; ++i) {\n            a[i] = rnd.next(1, 1000);\n        }\n        a[rnd.next(0, len - 1)] = 0;\n    } else if (type == \"one_zero_rest_negative\") {\n        for (int i = 0; i < len; ++i) {\n            a[i] = rnd.next(-1000, -1);\n        }\n        a[rnd.next(0, len - 1)] = 0;\n    } else if (type == \"mix_with_zeroes\") {\n        for (int i = 0; i < len; ++i) {\n            int choice = rnd.next(1, 3); // 1: negative, 2: zero, 3: positive\n            if (choice == 1)\n                a[i] = rnd.next(-1000, -1);\n            else if (choice == 2)\n                a[i] = 0;\n            else\n                a[i] = rnd.next(1, 1000);\n        }\n    } else {\n        // Unrecognized type, default to random\n        for (int i = 0; i < len; ++i) {\n            a[i] = rnd.next(-1000, 1000);\n        }\n    }\n\n    // Output the test case\n    printf(\"%d\\n\", n);\n    for (int i = 0; i < len; ++i) {\n        printf(\"%d\", a[i]);\n        if (i + 1 < len)\n            printf(\" \");\n        else\n            printf(\"\\n\");\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    int len = 2 * n - 1;\n\n    vector<int> a(len);\n\n    if (type == \"random\") {\n        // Generate random integers in [-1000, 1000]\n        for (int i = 0; i < len; ++i) {\n            a[i] = rnd.next(-1000, 1000);\n        }\n    } else if (type == \"all_positive\") {\n        for (int i = 0; i < len; ++i) {\n            a[i] = rnd.next(1, 1000);\n        }\n    } else if (type == \"all_negative\") {\n        for (int i = 0; i < len; ++i) {\n            a[i] = rnd.next(-1000, -1);\n        }\n    } else if (type == \"zeros\") {\n        for (int i = 0; i < len; ++i) {\n            a[i] = 0;\n        }\n    } else if (type == \"max_positive\") {\n        for (int i = 0; i < len; ++i) {\n            a[i] = 1000;\n        }\n    } else if (type == \"max_negative\") {\n        for (int i = 0; i < len; ++i) {\n            a[i] = -1000;\n        }\n    } else if (type == \"alternating\") {\n        for (int i = 0; i < len; ++i) {\n            if (i % 2 == 0)\n                a[i] = -1000;\n            else\n                a[i] = 1000;\n        }\n    } else if (type == \"one_zero_rest_positive\") {\n        for (int i = 0; i < len; ++i) {\n            a[i] = rnd.next(1, 1000);\n        }\n        a[rnd.next(0, len - 1)] = 0;\n    } else if (type == \"one_zero_rest_negative\") {\n        for (int i = 0; i < len; ++i) {\n            a[i] = rnd.next(-1000, -1);\n        }\n        a[rnd.next(0, len - 1)] = 0;\n    } else if (type == \"mix_with_zeroes\") {\n        for (int i = 0; i < len; ++i) {\n            int choice = rnd.next(1, 3); // 1: negative, 2: zero, 3: positive\n            if (choice == 1)\n                a[i] = rnd.next(-1000, -1);\n            else if (choice == 2)\n                a[i] = 0;\n            else\n                a[i] = rnd.next(1, 1000);\n        }\n    } else {\n        // Unrecognized type, default to random\n        for (int i = 0; i < len; ++i) {\n            a[i] = rnd.next(-1000, 1000);\n        }\n    }\n\n    // Output the test case\n    printf(\"%d\\n\", n);\n    for (int i = 0; i < len; ++i) {\n        printf(\"%d\", a[i]);\n        if (i + 1 < len)\n            printf(\" \");\n        else\n            printf(\"\\n\");\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# For n = 2\n./gen -n 2 -type random\n./gen -n 2 -type all_positive\n./gen -n 2 -type all_negative\n./gen -n 2 -type zeros\n./gen -n 2 -type max_positive\n./gen -n 2 -type max_negative\n./gen -n 2 -type alternating\n./gen -n 2 -type one_zero_rest_positive\n./gen -n 2 -type one_zero_rest_negative\n./gen -n 2 -type mix_with_zeroes\n\n# For n = 50\n./gen -n 50 -type random\n./gen -n 50 -type all_positive\n./gen -n 50 -type all_negative\n./gen -n 50 -type zeros\n./gen -n 50 -type max_positive\n./gen -n 50 -type max_negative\n./gen -n 50 -type alternating\n./gen -n 50 -type one_zero_rest_positive\n./gen -n 50 -type one_zero_rest_negative\n./gen -n 50 -type mix_with_zeroes\n\n# For n = 100\n./gen -n 100 -type random\n./gen -n 100 -type all_positive\n./gen -n 100 -type all_negative\n./gen -n 100 -type zeros\n./gen -n 100 -type max_positive\n./gen -n 100 -type max_negative\n./gen -n 100 -type alternating\n./gen -n 100 -type one_zero_rest_positive\n./gen -n 100 -type one_zero_rest_negative\n./gen -n 100 -type mix_with_zeroes\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:05:01.987490",
        "total_tutorials": 3,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "301/B",
      "title": "B. Ярослав и время",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест2 секунды",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеВ первой строке содержатся целые числа n и d (3 ≤ n ≤ 100, 103 ≤ d ≤ 105) — количество станций и константа из условия.Во второй строке заданы n - 2 целых числа: a2, a3, ..., an - 1 (1 ≤ ai ≤ 103). В следующих n строках содержатся координаты станций. В i-той из них записаны два целых чисел xi, yi (-100 ≤ xi, yi ≤ 100).Гарантируется, что никакие две станции не находятся в одной точке.",
      "output_spec": "Выходные данныеВ единственную строку выведите целое число — ответ на задачу.",
      "sample_tests": "ПримерыВходные данныеСкопировать3 100010000 00 10 3Выходные данныеСкопировать2000Входные данныеСкопировать3 100010001 01 11 2Выходные данныеСкопировать1000",
      "description": "B. Ярослав и время\n\nограничение по времени на тест2 секунды\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвыводstdout\n\nВходные данныеВ первой строке содержатся целые числа n и d (3 ≤ n ≤ 100, 103 ≤ d ≤ 105) — количество станций и константа из условия.Во второй строке заданы n - 2 целых числа: a2, a3, ..., an - 1 (1 ≤ ai ≤ 103). В следующих n строках содержатся координаты станций. В i-той из них записаны два целых чисел xi, yi (-100 ≤ xi, yi ≤ 100).Гарантируется, что никакие две станции не находятся в одной точке.\n\nВходные данные\n\nВыходные данныеВ единственную строку выведите целое число — ответ на задачу.\n\nВыходные данные\n\nВходные данныеСкопировать3 100010000 00 10 3Выходные данныеСкопировать2000Входные данныеСкопировать3 100010001 01 11 2Выходные данныеСкопировать1000\n\nВходные данныеСкопировать3 100010000 00 10 3\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать2000\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать3 100010001 01 11 2\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать1000\n\nВыходные данныеСкопировать\n\nСкопировать",
      "solutions": [
        {
          "title": "Codeforces Round #182 - Codeforces",
          "content": "Всем привет!Совсем скоро, 5 мая в 19:30 MSK состоится Codeforces Round #182, автором которого являюсь я. Это мой шестой раунд на Codeforces и я надеюсь, что не последний.Спасибо Геральду Агапову (Gerald) и Диме Соболеву(sdya) за помощь в подготовке раунда и Марии Беловой (Delinur) за перевод условий на английский.Настоятельно рекомендую прочитать условия ВСЕХ задач.Gl & hf ! :)По техническим причинам начало соревнования было сорвано. Приносим извинения, контест будет НЕРЕЙТИНГОВЫМ.Разбор.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/7557",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 493
        },
        {
          "title": "Codeforces Round #182 - Codeforces",
          "content": "Всем привет!Совсем скоро, 5 мая в 19:30 MSK состоится Codeforces Round #182, автором которого являюсь я. Это мой шестой раунд на Codeforces и я надеюсь, что не последний.Спасибо Геральду Агапову (Gerald) и Диме Соболеву(sdya) за помощь в подготовке раунда и Марии Беловой (Delinur) за перевод условий на английский.Настоятельно рекомендую прочитать условия ВСЕХ задач.Gl & hf ! :)По техническим причинам начало соревнования было сорвано. Приносим извинения, контест будет НЕРЕЙТИНГОВЫМ.Разбор.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/7557",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 493
        },
        {
          "title": "Codeforces Round #182 tutorial - Codeforces",
          "content": "302A - Евгений и массивЕсли длина отрезка — парное число, и количество 1 и -1 по отдельности не меньше половины длины, то ответ положительный. 302B - Евгений и плейлистЗапомним для каждой песни момент, когда она окончится (например частичными суммами). Дальше просто бинарным поиском или двумя указателями найдем максимальный номер песни, что ее конец не меньше заданного числа. 301A - Ярослав и последовательностьС помощью поиска в глубину посчитаем сколько отрицательных чисел мы можем получить. Заметим, что можно сделать либо все числа положительными либо одно число отрицательное(показать это просто, если изменить знак у числа Ч и некоторого набора чисел, а затем у числа У с тем же набором). Если можно получить все положительные числа, то ответом будет просто сумма модулей чисел иначе нужно поменять знак у числа с минимальным значением по модулю. 301B - Ярослав и времяБинарным поиском будем искать ответ. Далее воспользуемся простым алгоритмом Форда-Белмана. На каждом шагу будем хранить максимальное значение таймера при нахождении персонажа в конкретной вершине, при переходе будем проверять: не умрет ли персонаж при переходе между вершинами. Если переход возможен, то будем обновлять значение конечной вершины. Благодаря тому что a_i<=d и координаты — целые мы не получим циклов. 301C - Ярослав и алгоритмНужно воспользоваться тем, что у нас есть знак вопроса(возможно, есть решение, которое не использует этот знак). Поставим знак вопроса в начало строки. Далее будем двигать его пока он не достигнет конца строки. Далее заменим его на два знака вопроса. И будем тянуть их к началу пока перед ним находится число 9, как только мы нашли другую цифру — просто увеличим ее и закончим алгоритм. Если мы дошли до начала строки, то просто поставим 1 в начало и закончим алгоритм.Смотрите любой прошедший код для большей ясности. 301D - Ярослав и делителиЗададим все пары вида: (x,y) ((d[x]%d[y]==0) || (d[y]%d[x]==0)). Задавать такие можно с помощью решета Эретосфена. Пар заданного вида будет порядка O(n*log(n)) благодаря тому, что нам задана перестановка. Дальше с помощью сортировки подсчетом отсортируем их. Отсортируем заданные на входе отрезки. Дальше для каждого такого отрезка нужно посчитать кол — во вложенных из заданных ранее. Такую задачу можно решить с помощью дерева Фенвика. На каждом шаге добавлять отрезки в порядке сортировки по правому краю. На каждой итерации будем обновлять Дерево Фенвика, которое сможет считать количество начал уже добавленных отрезков на отрезке. С помощью такой информации легко найти ответ. Сложность решения: O(n*log^2(n)), учитывая, что мы используем дерево Фенвика. Константа в решении очень маленькая. 301E - Ярослав и расстановкиБудем строить нужные нам массивы последовательно добавляя числа. Давайте посмотрим на то, какие параметры нам нужны. Во первых, очевидно что нужно хранить количество способов построить массив на уже добавленных числах, во вторых нужно знать общее количество добавленных чисел. Теперь посмотрим на то, что происходит когда мы добавляем новое число(то есть число, большее всех предыдущих в некотором количестве). Понятно, что добавленные числа должны стоять между числами на 1 меньше. При этом если мы поставим 2 новых числа подряд, то между ними должно стоять большее(так как меньшие мы уже расставили). При этом очевидно, что нужно покрыть все предыдущие числа(между которыми должны стоять новодобавленные).Таким образом имеем еще один параметр: количество чисел, между которыми мы можем ставить новые. Таким образом мы имеем динамику от четырех параметров: dp[all][ways][lastnumber][counttoadd].Переход.Понятно, что нужно добавлять не менее counttoadd чисел, но как это повлияет на количество способов расставить числа? Все просто. Пусть мы добавили x чисел, тогда количество способов нужно будет умножить на величину Q(x-counttoadd, counttoadd), где Q(x,y) — количество способов расставить x одинаковых шариков в y разных коробок. Q(x,y) = C(x+y-1,y-1), где C(x,y) — биномиальный коэффициент.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/7560",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 301\\s*B"
          },
          "content_length": 3984
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #182 - Codeforces - Code 1",
          "code": "**Server Problem !!!!**",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7557",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #182 - Codeforces - Code 2",
          "code": "**Bad Gateway**",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7557",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #182 - Codeforces - Code 3",
          "code": "-959 -542 -669 -513 160\n-959 -542 669 513 -160\n959 542 669 513 160",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7557",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #182 - Codeforces - Code 4",
          "code": "-959 -542 -669 -513 160\n-959 -542 669 513 -160\n959 542 669 513 160",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7557",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #182 - Codeforces - Code 5",
          "code": "3 1000\n3000\n0 0\n0 1\n0 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7557",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #182 - Codeforces - Code 6",
          "code": "3 1000\n3000\n0 0\n0 1\n0 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7557",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #182 - Codeforces - Code 7",
          "code": "3 100\n300\n0 0\n0 1\n0 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7557",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #182 - Codeforces - Code 8",
          "code": "3 100\n300\n0 0\n0 1\n0 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7557",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #182 - Codeforces - Code 9",
          "code": "3 1000\n2000\n0 0\n0 1\n0 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7557",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #182 - Codeforces - Code 10",
          "code": "3 1000\n2000\n0 0\n0 1\n0 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7557",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #182 - Codeforces - Code 11",
          "code": "??0>>0??\n??1>>1??\n??2>>2??\n??3>>3??\n??4>>4??\n??5>>5??\n??6>>6??\n??7>>7??\n??8>>8??\n??9>>9??\n??>>?\n0?<>1\n1?<>2\n2?<>3\n3?<>4\n4?<>5\n5?<>6\n6?<>7\n7?<>8\n8?<>9\n9?>>?0\n?<>1\n0>>??0\n1>>??1\n2>>??2\n3>>??3\n4>>??4\n5>>??5\n6>>??6\n7>>??7\n8>>??8\n9>>??9",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7557",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #182 - Codeforces - Code 12",
          "code": "??0>>0??\n??1>>1??\n??2>>2??\n??3>>3??\n??4>>4??\n??5>>5??\n??6>>6??\n??7>>7??\n??8>>8??\n??9>>9??\n??>>?\n0?<>1\n1?<>2\n2?<>3\n3?<>4\n4?<>5\n5?<>6\n6?<>7\n7?<>8\n8?<>9\n9?>>?0\n?<>1\n0>>??0\n1>>??1\n2>>??2\n3>>??3\n4>>??4\n5>>??5\n6>>??6\n7>>??7\n8>>??8\n9>>??9",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7557",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #182 - Codeforces - Code 13",
          "code": "98\n.7\n.6\n.5\n.4\n.3\n12",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7557",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #182 - Codeforces - Code 14",
          "code": "98\n.7\n.6\n.5\n.4\n.3\n12",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7557",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #182 - Codeforces - Code 1",
          "code": "**Server Problem !!!!**",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7557",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #182 - Codeforces - Code 2",
          "code": "**Bad Gateway**",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7557",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #182 - Codeforces - Code 3",
          "code": "-959 -542 -669 -513 160\n-959 -542 669 513 -160\n959 542 669 513 160",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7557",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #182 - Codeforces - Code 4",
          "code": "-959 -542 -669 -513 160\n-959 -542 669 513 -160\n959 542 669 513 160",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7557",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #182 - Codeforces - Code 5",
          "code": "3 1000\n3000\n0 0\n0 1\n0 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7557",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #182 - Codeforces - Code 6",
          "code": "3 1000\n3000\n0 0\n0 1\n0 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7557",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #182 - Codeforces - Code 7",
          "code": "3 100\n300\n0 0\n0 1\n0 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7557",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #182 - Codeforces - Code 8",
          "code": "3 100\n300\n0 0\n0 1\n0 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7557",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #182 - Codeforces - Code 9",
          "code": "3 1000\n2000\n0 0\n0 1\n0 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7557",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #182 - Codeforces - Code 10",
          "code": "3 1000\n2000\n0 0\n0 1\n0 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7557",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #182 - Codeforces - Code 11",
          "code": "??0>>0??\n??1>>1??\n??2>>2??\n??3>>3??\n??4>>4??\n??5>>5??\n??6>>6??\n??7>>7??\n??8>>8??\n??9>>9??\n??>>?\n0?<>1\n1?<>2\n2?<>3\n3?<>4\n4?<>5\n5?<>6\n6?<>7\n7?<>8\n8?<>9\n9?>>?0\n?<>1\n0>>??0\n1>>??1\n2>>??2\n3>>??3\n4>>??4\n5>>??5\n6>>??6\n7>>??7\n8>>??8\n9>>??9",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7557",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #182 - Codeforces - Code 12",
          "code": "??0>>0??\n??1>>1??\n??2>>2??\n??3>>3??\n??4>>4??\n??5>>5??\n??6>>6??\n??7>>7??\n??8>>8??\n??9>>9??\n??>>?\n0?<>1\n1?<>2\n2?<>3\n3?<>4\n4?<>5\n5?<>6\n6?<>7\n7?<>8\n8?<>9\n9?>>?0\n?<>1\n0>>??0\n1>>??1\n2>>??2\n3>>??3\n4>>??4\n5>>??5\n6>>??6\n7>>??7\n8>>??8\n9>>??9",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7557",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #182 - Codeforces - Code 13",
          "code": "98\n.7\n.6\n.5\n.4\n.3\n12",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7557",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #182 - Codeforces - Code 14",
          "code": "98\n.7\n.6\n.5\n.4\n.3\n12",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7557",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #182 tutorial - Codeforces - Code 1",
          "code": "8 1000\n1000 1000 1000 1000 1000 1000\n0 0 \n0 1\n1 1\n2 1\n2 0\n2 -1\n3 -1\n4 -1\n4 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7560",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #182 tutorial - Codeforces - Code 2",
          "code": "8 1000\n1000 1000 1000 1000 1000 1000\n0 0 \n0 1\n1 1\n2 1\n2 0\n2 -1\n3 -1\n4 -1\n4 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7560",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #182 tutorial - Codeforces - Code 3",
          "code": "for (int a = 1; a <= n; a++)\n    for (int b = a; b <= n; b += a)\n        remember_pair(a, b);// b % a == 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7560",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #182 tutorial - Codeforces - Code 4",
          "code": "for (int a = 1; a <= n; a++)\n    for (int b = a; b <= n; b += a)\n        remember_pair(a, b);// b % a == 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7560",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #182 tutorial - Codeforces - Code 5",
          "code": "ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    cin.tie(0);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7560",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #182 tutorial - Codeforces - Code 6",
          "code": "ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    cin.tie(0);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7560",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #182 tutorial - Codeforces - Code 7",
          "code": "3 1\n1000\n0 0\n0 100\n0 101",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7560",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #182 tutorial - Codeforces - Code 8",
          "code": "3 1\n1000\n0 0\n0 100\n0 101",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7560",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(3, 100, \"n\");\n    inf.readSpace();\n    int d = inf.readInt(1000, 100000, \"d\");\n    inf.readEoln();\n\n    if (n - 2 > 0) {\n        vector<int> ai = inf.readInts(n - 2, 1, 1000, \"ai\");\n        inf.readEoln();\n    }\n\n    vector<pair<int, int>> coords;\n    for (int i = 0; i < n; ++i) {\n        int xi = inf.readInt(-100, 100, \"xi\");\n        inf.readSpace();\n        int yi = inf.readInt(-100, 100, \"yi\");\n        inf.readEoln();\n        coords.emplace_back(xi, yi);\n    }\n\n    ensuref(coords.size() == n, \"Number of stations read is incorrect\");\n    ensuref(set<pair<int, int>>(coords.begin(), coords.end()).size() == n, \"No two stations should have the same coordinates\");\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(3, 100, \"n\");\n    inf.readSpace();\n    int d = inf.readInt(1000, 100000, \"d\");\n    inf.readEoln();\n\n    if (n - 2 > 0) {\n        vector<int> ai = inf.readInts(n - 2, 1, 1000, \"ai\");\n        inf.readEoln();\n    }\n\n    vector<pair<int, int>> coords;\n    for (int i = 0; i < n; ++i) {\n        int xi = inf.readInt(-100, 100, \"xi\");\n        inf.readSpace();\n        int yi = inf.readInt(-100, 100, \"yi\");\n        inf.readEoln();\n        coords.emplace_back(xi, yi);\n    }\n\n    ensuref(coords.size() == n, \"Number of stations read is incorrect\");\n    ensuref(set<pair<int, int>>(coords.begin(), coords.end()).size() == n, \"No two stations should have the same coordinates\");\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(3, 100, \"n\");\n    inf.readSpace();\n    int d = inf.readInt(1000, 100000, \"d\");\n    inf.readEoln();\n\n    if (n - 2 > 0) {\n        vector<int> ai = inf.readInts(n - 2, 1, 1000, \"ai\");\n        inf.readEoln();\n    }\n\n    vector<pair<int, int>> coords;\n    for (int i = 0; i < n; ++i) {\n        int xi = inf.readInt(-100, 100, \"xi\");\n        inf.readSpace();\n        int yi = inf.readInt(-100, 100, \"yi\");\n        inf.readEoln();\n        coords.emplace_back(xi, yi);\n    }\n\n    ensuref(coords.size() == n, \"Number of stations read is incorrect\");\n    ensuref(set<pair<int, int>>(coords.begin(), coords.end()).size() == n, \"No two stations should have the same coordinates\");\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    \n    registerGen(argc, argv, 1);\n    \n    int n = opt<int>(\"n\");\n    int d = opt<int>(\"d\", 1000);\n    string ai_type = opt<string>(\"ai_type\", \"random\");\n    string coord_type = opt<string>(\"coord_type\", \"random\");\n    \n    vector<int> ai(n - 2);\n    if (ai_type == \"min\") {\n        fill(ai.begin(), ai.end(), 1);\n    } else if (ai_type == \"max\") {\n        fill(ai.begin(), ai.end(), 1000);\n    } else {\n        for (int i = 0; i < n - 2; ++i)\n            ai[i] = rnd.next(1, 1000);\n    }\n\n    set<pair<int, int>> coords_set;\n    vector<pair<int, int>> coords(n);\n\n    if (coord_type == \"line\") {\n        int x = rnd.next(-100, 100);\n        int y = rnd.next(-100, 100);\n        int dx = rnd.next(1, 5); // increment in x\n        int dy = rnd.next(-5, 5); // increment in y\n        for (int i = 0; i < n; ++i) {\n            coords[i] = {x + i * dx, y + i * dy};\n            coords_set.insert(coords[i]);\n        }\n    } else if (coord_type == \"circle\") {\n        double r = rnd.next(10, 90);\n        double cx = rnd.next(-50, 50);\n        double cy = rnd.next(-50, 50);\n        set<pair<int, int>> temp_set;\n        for (int i = 0; i < n; ++i) {\n            double angle = 2 * M_PI * i / n;\n            int x = (int) round(cx + r * cos(angle));\n            int y = (int) round(cy + r * sin(angle));\n            while (coords_set.count({x, y})) {\n                angle += 0.01;\n                x = (int) round(cx + r * cos(angle));\n                y = (int) round(cy + r * sin(angle));\n            }\n            coords[i] = {x, y};\n            coords_set.insert(coords[i]);\n        }\n    } else if (coord_type == \"grid\") {\n        int grid_size = (int) ceil(sqrt(n));\n        vector<int> xs, ys;\n        for (int i = -50; i <= 50 && xs.size() < grid_size; i += 10)\n            xs.push_back(i);\n        for (int i = -50; i <= 50 && ys.size() < grid_size; i += 10)\n            ys.push_back(i);\n        shuffle(xs.begin(), xs.end());\n        shuffle(ys.begin(), ys.end());\n        int idx = 0;\n        for (int i = 0; i < xs.size() && idx < n; ++i) {\n            for (int j = 0; j < ys.size() && idx < n; ++j) {\n                coords[idx] = {xs[i], ys[j]};\n                coords_set.insert(coords[idx]);\n                idx++;\n            }\n        }\n    } else if (coord_type == \"cluster\") {\n        int num_clusters = rnd.next(2, 5);\n        vector<pair<int, int>> clusters;\n        for (int i = 0; i < num_clusters; ++i) {\n            int cx = rnd.next(-90, 90);\n            int cy = rnd.next(-90, 90);\n            clusters.push_back({cx, cy});\n        }\n        for (int i = 0; i < n; ++i) {\n            int cluster_idx = rnd.next(0, num_clusters - 1);\n            int x, y;\n            do {\n                x = clusters[cluster_idx].first + rnd.next(-5, 5);\n                y = clusters[cluster_idx].second + rnd.next(-5, 5);\n            } while (coords_set.count({x, y}) || x < -100 || x > 100 || y < -100 || y > 100);\n            coords[i] = {x, y};\n            coords_set.insert(coords[i]);\n        }\n    } else { // random\n        for (int i = 0; i < n; ++i) {\n            int x, y;\n            do {\n                x = rnd.next(-100, 100);\n                y = rnd.next(-100, 100);\n            } while (coords_set.count({x, y}));\n            coords_set.insert({x, y});\n            coords[i] = {x, y};\n        }\n    }\n\n    // Output\n    printf(\"%d %d\\n\", n, d);\n    if (n - 2 > 0) {\n        for (int i = 0; i < n - 2; ++i) {\n            printf(\"%d\", ai[i]);\n            if (i + 1 < n - 2)\n                printf(\" \");\n            else\n                printf(\"\\n\");\n        }\n    } else {\n        // No ai values, just print an empty line\n        printf(\"\\n\");\n    }\n\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d %d\\n\", coords[i].first, coords[i].second);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    \n    registerGen(argc, argv, 1);\n    \n    int n = opt<int>(\"n\");\n    int d = opt<int>(\"d\", 1000);\n    string ai_type = opt<string>(\"ai_type\", \"random\");\n    string coord_type = opt<string>(\"coord_type\", \"random\");\n    \n    vector<int> ai(n - 2);\n    if (ai_type == \"min\") {\n        fill(ai.begin(), ai.end(), 1);\n    } else if (ai_type == \"max\") {\n        fill(ai.begin(), ai.end(), 1000);\n    } else {\n        for (int i = 0; i < n - 2; ++i)\n            ai[i] = rnd.next(1, 1000);\n    }\n\n    set<pair<int, int>> coords_set;\n    vector<pair<int, int>> coords(n);\n\n    if (coord_type == \"line\") {\n        int x = rnd.next(-100, 100);\n        int y = rnd.next(-100, 100);\n        int dx = rnd.next(1, 5); // increment in x\n        int dy = rnd.next(-5, 5); // increment in y\n        for (int i = 0; i < n; ++i) {\n            coords[i] = {x + i * dx, y + i * dy};\n            coords_set.insert(coords[i]);\n        }\n    } else if (coord_type == \"circle\") {\n        double r = rnd.next(10, 90);\n        double cx = rnd.next(-50, 50);\n        double cy = rnd.next(-50, 50);\n        set<pair<int, int>> temp_set;\n        for (int i = 0; i < n; ++i) {\n            double angle = 2 * M_PI * i / n;\n            int x = (int) round(cx + r * cos(angle));\n            int y = (int) round(cy + r * sin(angle));\n            while (coords_set.count({x, y})) {\n                angle += 0.01;\n                x = (int) round(cx + r * cos(angle));\n                y = (int) round(cy + r * sin(angle));\n            }\n            coords[i] = {x, y};\n            coords_set.insert(coords[i]);\n        }\n    } else if (coord_type == \"grid\") {\n        int grid_size = (int) ceil(sqrt(n));\n        vector<int> xs, ys;\n        for (int i = -50; i <= 50 && xs.size() < grid_size; i += 10)\n            xs.push_back(i);\n        for (int i = -50; i <= 50 && ys.size() < grid_size; i += 10)\n            ys.push_back(i);\n        shuffle(xs.begin(), xs.end());\n        shuffle(ys.begin(), ys.end());\n        int idx = 0;\n        for (int i = 0; i < xs.size() && idx < n; ++i) {\n            for (int j = 0; j < ys.size() && idx < n; ++j) {\n                coords[idx] = {xs[i], ys[j]};\n                coords_set.insert(coords[idx]);\n                idx++;\n            }\n        }\n    } else if (coord_type == \"cluster\") {\n        int num_clusters = rnd.next(2, 5);\n        vector<pair<int, int>> clusters;\n        for (int i = 0; i < num_clusters; ++i) {\n            int cx = rnd.next(-90, 90);\n            int cy = rnd.next(-90, 90);\n            clusters.push_back({cx, cy});\n        }\n        for (int i = 0; i < n; ++i) {\n            int cluster_idx = rnd.next(0, num_clusters - 1);\n            int x, y;\n            do {\n                x = clusters[cluster_idx].first + rnd.next(-5, 5);\n                y = clusters[cluster_idx].second + rnd.next(-5, 5);\n            } while (coords_set.count({x, y}) || x < -100 || x > 100 || y < -100 || y > 100);\n            coords[i] = {x, y};\n            coords_set.insert(coords[i]);\n        }\n    } else { // random\n        for (int i = 0; i < n; ++i) {\n            int x, y;\n            do {\n                x = rnd.next(-100, 100);\n                y = rnd.next(-100, 100);\n            } while (coords_set.count({x, y}));\n            coords_set.insert({x, y});\n            coords[i] = {x, y};\n        }\n    }\n\n    // Output\n    printf(\"%d %d\\n\", n, d);\n    if (n - 2 > 0) {\n        for (int i = 0; i < n - 2; ++i) {\n            printf(\"%d\", ai[i]);\n            if (i + 1 < n - 2)\n                printf(\" \");\n            else\n                printf(\"\\n\");\n        }\n    } else {\n        // No ai values, just print an empty line\n        printf(\"\\n\");\n    }\n\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d %d\\n\", coords[i].first, coords[i].second);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 3 -d 1000 -ai_type min -coord_type line\n./gen -n 100 -d 100000 -ai_type max -coord_type random\n./gen -n 50 -d 50000 -ai_type random -coord_type grid\n./gen -n 5 -d 1000 -ai_type random -coord_type line\n./gen -n 5 -d 1000 -ai_type random -coord_type circle\n./gen -n 100 -d 1000 -ai_type random -coord_type line\n./gen -n 100 -d 1000 -ai_type random -coord_type circle\n./gen -n 100 -d 1000 -ai_type random -coord_type grid\n./gen -n 100 -d 1000 -ai_type random -coord_type cluster\n./gen -n 100 -d 1000 -ai_type random -coord_type random\n./gen -n 100 -d 1000 -ai_type min -coord_type random\n./gen -n 100 -d 1000 -ai_type max -coord_type random\n./gen -n 100 -d 1000 -ai_type min -coord_type random\n./gen -n 100 -d 100000 -ai_type max -coord_type random\n./gen -n 3 -d 1000 -ai_type min -coord_type random\n./gen -n 3 -d 1000 -ai_type max -coord_type random\n./gen -n 67 -d 12345 -ai_type random -coord_type random\n./gen -n 80 -d 54321 -ai_type random -coord_type cluster\n./gen -n 90 -d 99999 -ai_type random -coord_type grid\n./gen -n 70 -d 100000 -ai_type random -coord_type random\n./gen -n 70 -d 1000 -ai_type random -coord_type random\n./gen -n 100 -d 1000 -ai_type random -coord_type line\n./gen -n 100 -d 20000 -ai_type random -coord_type cluster\n./gen -n 100 -d 20000 -ai_type random -coord_type cluster\n./gen -n 100 -d 1000 -ai_type min -coord_type random\n./gen -n 100 -d 100000 -ai_type max -coord_type random\n./gen -n 100 -d 50000 -ai_type random -coord_type circle\n./gen -n 100 -d 50000 -ai_type random -coord_type grid\n./gen -n 100 -d 50000 -ai_type random -coord_type cluster\n./gen -n 100 -d 50000 -ai_type random -coord_type line\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:05:04.182311",
        "total_tutorials": 3,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "301/C",
      "title": "C. Ярослав и алгоритм",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест2 секунды",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеВ первой строке содержится целое число n (1 ≤ n ≤ 100) — количество чисел в наборе. В следующих n строках содержится по одному целому положительному числу. Все заданные числа меньше 1025.",
      "output_spec": "Выходные данныеВыведите алгоритм, который сможет по отдельности увеличить каждое число из набора. В i-той строке выведите команду номер i без пробелов. Ваш алгоритм будет запущен для каждого из данных чисел. Ответ будет считаться правильным, если:   Каждая строка будет корректной командой алгоритма (смотри описание в условии задачи).  Количество команд не будет превышать 50.  Алгоритм будет увеличивать каждое из заданных чисел на единицу.  Для получения ответа алгоритм выполнит не более 200 итераций для каждого числа.",
      "sample_tests": "ПримерыВходные данныеСкопировать21079Выходные данныеСкопировать10<>1179<>80",
      "description": "C. Ярослав и алгоритм\n\nограничение по времени на тест2 секунды\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвыводstdout\n\nВходные данныеВ первой строке содержится целое число n (1 ≤ n ≤ 100) — количество чисел в наборе. В следующих n строках содержится по одному целому положительному числу. Все заданные числа меньше 1025.\n\nВходные данные\n\nВыходные данныеВыведите алгоритм, который сможет по отдельности увеличить каждое число из набора. В i-той строке выведите команду номер i без пробелов. Ваш алгоритм будет запущен для каждого из данных чисел. Ответ будет считаться правильным, если:   Каждая строка будет корректной командой алгоритма (смотри описание в условии задачи).  Количество команд не будет превышать 50.  Алгоритм будет увеличивать каждое из заданных чисел на единицу.  Для получения ответа алгоритм выполнит не более 200 итераций для каждого числа.\n\nВыходные данные\n\nВходные данныеСкопировать21079Выходные данныеСкопировать10<>1179<>80\n\nВходные данныеСкопировать21079\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать10<>1179<>80\n\nВыходные данныеСкопировать\n\nСкопировать",
      "solutions": [
        {
          "title": "Codeforces Round #182 - Codeforces",
          "content": "Всем привет!Совсем скоро, 5 мая в 19:30 MSK состоится Codeforces Round #182, автором которого являюсь я. Это мой шестой раунд на Codeforces и я надеюсь, что не последний.Спасибо Геральду Агапову (Gerald) и Диме Соболеву(sdya) за помощь в подготовке раунда и Марии Беловой (Delinur) за перевод условий на английский.Настоятельно рекомендую прочитать условия ВСЕХ задач.Gl & hf ! :)По техническим причинам начало соревнования было сорвано. Приносим извинения, контест будет НЕРЕЙТИНГОВЫМ.Разбор.",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/7557",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 493
        },
        {
          "title": "Codeforces Round #182 - Codeforces",
          "content": "Всем привет!Совсем скоро, 5 мая в 19:30 MSK состоится Codeforces Round #182, автором которого являюсь я. Это мой шестой раунд на Codeforces и я надеюсь, что не последний.Спасибо Геральду Агапову (Gerald) и Диме Соболеву(sdya) за помощь в подготовке раунда и Марии Беловой (Delinur) за перевод условий на английский.Настоятельно рекомендую прочитать условия ВСЕХ задач.Gl & hf ! :)По техническим причинам начало соревнования было сорвано. Приносим извинения, контест будет НЕРЕЙТИНГОВЫМ.Разбор.",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/7557",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 493
        },
        {
          "title": "Codeforces Round #182 tutorial - Codeforces",
          "content": "302A - Евгений и массивЕсли длина отрезка — парное число, и количество 1 и -1 по отдельности не меньше половины длины, то ответ положительный. 302B - Евгений и плейлистЗапомним для каждой песни момент, когда она окончится (например частичными суммами). Дальше просто бинарным поиском или двумя указателями найдем максимальный номер песни, что ее конец не меньше заданного числа. 301A - Ярослав и последовательностьС помощью поиска в глубину посчитаем сколько отрицательных чисел мы можем получить. Заметим, что можно сделать либо все числа положительными либо одно число отрицательное(показать это просто, если изменить знак у числа Ч и некоторого набора чисел, а затем у числа У с тем же набором). Если можно получить все положительные числа, то ответом будет просто сумма модулей чисел иначе нужно поменять знак у числа с минимальным значением по модулю. 301B - Ярослав и времяБинарным поиском будем искать ответ. Далее воспользуемся простым алгоритмом Форда-Белмана. На каждом шагу будем хранить максимальное значение таймера при нахождении персонажа в конкретной вершине, при переходе будем проверять: не умрет ли персонаж при переходе между вершинами. Если переход возможен, то будем обновлять значение конечной вершины. Благодаря тому что a_i<=d и координаты — целые мы не получим циклов. 301C - Ярослав и алгоритмНужно воспользоваться тем, что у нас есть знак вопроса(возможно, есть решение, которое не использует этот знак). Поставим знак вопроса в начало строки. Далее будем двигать его пока он не достигнет конца строки. Далее заменим его на два знака вопроса. И будем тянуть их к началу пока перед ним находится число 9, как только мы нашли другую цифру — просто увеличим ее и закончим алгоритм. Если мы дошли до начала строки, то просто поставим 1 в начало и закончим алгоритм.Смотрите любой прошедший код для большей ясности. 301D - Ярослав и делителиЗададим все пары вида: (x,y) ((d[x]%d[y]==0) || (d[y]%d[x]==0)). Задавать такие можно с помощью решета Эретосфена. Пар заданного вида будет порядка O(n*log(n)) благодаря тому, что нам задана перестановка. Дальше с помощью сортировки подсчетом отсортируем их. Отсортируем заданные на входе отрезки. Дальше для каждого такого отрезка нужно посчитать кол — во вложенных из заданных ранее. Такую задачу можно решить с помощью дерева Фенвика. На каждом шаге добавлять отрезки в порядке сортировки по правому краю. На каждой итерации будем обновлять Дерево Фенвика, которое сможет считать количество начал уже добавленных отрезков на отрезке. С помощью такой информации легко найти ответ. Сложность решения: O(n*log^2(n)), учитывая, что мы используем дерево Фенвика. Константа в решении очень маленькая. 301E - Ярослав и расстановкиБудем строить нужные нам массивы последовательно добавляя числа. Давайте посмотрим на то, какие параметры нам нужны. Во первых, очевидно что нужно хранить количество способов построить массив на уже добавленных числах, во вторых нужно знать общее количество добавленных чисел. Теперь посмотрим на то, что происходит когда мы добавляем новое число(то есть число, большее всех предыдущих в некотором количестве). Понятно, что добавленные числа должны стоять между числами на 1 меньше. При этом если мы поставим 2 новых числа подряд, то между ними должно стоять большее(так как меньшие мы уже расставили). При этом очевидно, что нужно покрыть все предыдущие числа(между которыми должны стоять новодобавленные).Таким образом имеем еще один параметр: количество чисел, между которыми мы можем ставить новые. Таким образом мы имеем динамику от четырех параметров: dp[all][ways][lastnumber][counttoadd].Переход.Понятно, что нужно добавлять не менее counttoadd чисел, но как это повлияет на количество способов расставить числа? Все просто. Пусть мы добавили x чисел, тогда количество способов нужно будет умножить на величину Q(x-counttoadd, counttoadd), где Q(x,y) — количество способов расставить x одинаковых шариков в y разных коробок. Q(x,y) = C(x+y-1,y-1), где C(x,y) — биномиальный коэффициент.",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/7560",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 301\\s*C"
          },
          "content_length": 3984
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #182 - Codeforces - Code 1",
          "code": "**Server Problem !!!!**",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7557",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #182 - Codeforces - Code 2",
          "code": "**Bad Gateway**",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7557",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #182 - Codeforces - Code 3",
          "code": "-959 -542 -669 -513 160\n-959 -542 669 513 -160\n959 542 669 513 160",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7557",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #182 - Codeforces - Code 4",
          "code": "-959 -542 -669 -513 160\n-959 -542 669 513 -160\n959 542 669 513 160",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7557",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #182 - Codeforces - Code 5",
          "code": "3 1000\n3000\n0 0\n0 1\n0 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7557",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #182 - Codeforces - Code 6",
          "code": "3 1000\n3000\n0 0\n0 1\n0 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7557",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #182 - Codeforces - Code 7",
          "code": "3 100\n300\n0 0\n0 1\n0 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7557",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #182 - Codeforces - Code 8",
          "code": "3 100\n300\n0 0\n0 1\n0 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7557",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #182 - Codeforces - Code 9",
          "code": "3 1000\n2000\n0 0\n0 1\n0 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7557",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #182 - Codeforces - Code 10",
          "code": "3 1000\n2000\n0 0\n0 1\n0 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7557",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #182 - Codeforces - Code 11",
          "code": "??0>>0??\n??1>>1??\n??2>>2??\n??3>>3??\n??4>>4??\n??5>>5??\n??6>>6??\n??7>>7??\n??8>>8??\n??9>>9??\n??>>?\n0?<>1\n1?<>2\n2?<>3\n3?<>4\n4?<>5\n5?<>6\n6?<>7\n7?<>8\n8?<>9\n9?>>?0\n?<>1\n0>>??0\n1>>??1\n2>>??2\n3>>??3\n4>>??4\n5>>??5\n6>>??6\n7>>??7\n8>>??8\n9>>??9",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7557",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #182 - Codeforces - Code 12",
          "code": "??0>>0??\n??1>>1??\n??2>>2??\n??3>>3??\n??4>>4??\n??5>>5??\n??6>>6??\n??7>>7??\n??8>>8??\n??9>>9??\n??>>?\n0?<>1\n1?<>2\n2?<>3\n3?<>4\n4?<>5\n5?<>6\n6?<>7\n7?<>8\n8?<>9\n9?>>?0\n?<>1\n0>>??0\n1>>??1\n2>>??2\n3>>??3\n4>>??4\n5>>??5\n6>>??6\n7>>??7\n8>>??8\n9>>??9",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7557",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #182 - Codeforces - Code 13",
          "code": "98\n.7\n.6\n.5\n.4\n.3\n12",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7557",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #182 - Codeforces - Code 14",
          "code": "98\n.7\n.6\n.5\n.4\n.3\n12",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7557",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #182 - Codeforces - Code 1",
          "code": "**Server Problem !!!!**",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7557",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #182 - Codeforces - Code 2",
          "code": "**Bad Gateway**",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7557",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #182 - Codeforces - Code 3",
          "code": "-959 -542 -669 -513 160\n-959 -542 669 513 -160\n959 542 669 513 160",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7557",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #182 - Codeforces - Code 4",
          "code": "-959 -542 -669 -513 160\n-959 -542 669 513 -160\n959 542 669 513 160",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7557",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #182 - Codeforces - Code 5",
          "code": "3 1000\n3000\n0 0\n0 1\n0 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7557",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #182 - Codeforces - Code 6",
          "code": "3 1000\n3000\n0 0\n0 1\n0 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7557",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #182 - Codeforces - Code 7",
          "code": "3 100\n300\n0 0\n0 1\n0 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7557",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #182 - Codeforces - Code 8",
          "code": "3 100\n300\n0 0\n0 1\n0 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7557",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #182 - Codeforces - Code 9",
          "code": "3 1000\n2000\n0 0\n0 1\n0 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7557",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #182 - Codeforces - Code 10",
          "code": "3 1000\n2000\n0 0\n0 1\n0 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7557",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #182 - Codeforces - Code 11",
          "code": "??0>>0??\n??1>>1??\n??2>>2??\n??3>>3??\n??4>>4??\n??5>>5??\n??6>>6??\n??7>>7??\n??8>>8??\n??9>>9??\n??>>?\n0?<>1\n1?<>2\n2?<>3\n3?<>4\n4?<>5\n5?<>6\n6?<>7\n7?<>8\n8?<>9\n9?>>?0\n?<>1\n0>>??0\n1>>??1\n2>>??2\n3>>??3\n4>>??4\n5>>??5\n6>>??6\n7>>??7\n8>>??8\n9>>??9",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7557",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #182 - Codeforces - Code 12",
          "code": "??0>>0??\n??1>>1??\n??2>>2??\n??3>>3??\n??4>>4??\n??5>>5??\n??6>>6??\n??7>>7??\n??8>>8??\n??9>>9??\n??>>?\n0?<>1\n1?<>2\n2?<>3\n3?<>4\n4?<>5\n5?<>6\n6?<>7\n7?<>8\n8?<>9\n9?>>?0\n?<>1\n0>>??0\n1>>??1\n2>>??2\n3>>??3\n4>>??4\n5>>??5\n6>>??6\n7>>??7\n8>>??8\n9>>??9",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7557",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #182 - Codeforces - Code 13",
          "code": "98\n.7\n.6\n.5\n.4\n.3\n12",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7557",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #182 - Codeforces - Code 14",
          "code": "98\n.7\n.6\n.5\n.4\n.3\n12",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7557",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #182 tutorial - Codeforces - Code 1",
          "code": "8 1000\n1000 1000 1000 1000 1000 1000\n0 0 \n0 1\n1 1\n2 1\n2 0\n2 -1\n3 -1\n4 -1\n4 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7560",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #182 tutorial - Codeforces - Code 2",
          "code": "8 1000\n1000 1000 1000 1000 1000 1000\n0 0 \n0 1\n1 1\n2 1\n2 0\n2 -1\n3 -1\n4 -1\n4 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7560",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #182 tutorial - Codeforces - Code 3",
          "code": "for (int a = 1; a <= n; a++)\n    for (int b = a; b <= n; b += a)\n        remember_pair(a, b);// b % a == 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7560",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #182 tutorial - Codeforces - Code 4",
          "code": "for (int a = 1; a <= n; a++)\n    for (int b = a; b <= n; b += a)\n        remember_pair(a, b);// b % a == 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7560",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #182 tutorial - Codeforces - Code 5",
          "code": "ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    cin.tie(0);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7560",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #182 tutorial - Codeforces - Code 6",
          "code": "ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    cin.tie(0);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7560",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #182 tutorial - Codeforces - Code 7",
          "code": "3 1\n1000\n0 0\n0 100\n0 101",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7560",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #182 tutorial - Codeforces - Code 8",
          "code": "3 1\n1000\n0 0\n0 100\n0 101",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7560",
          "author": "Qingyu"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readEoln();\n    for (int i = 0; i < n; ++i) {\n        int x = inf.readInt(1, 1024, \"number\");\n        inf.readEoln();\n    }\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readEoln();\n    for (int i = 0; i < n; ++i) {\n        int x = inf.readInt(1, 1024, \"number\");\n        inf.readEoln();\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readEoln();\n    for (int i = 0; i < n; ++i) {\n        int x = inf.readInt(1, 1024, \"number\");\n        inf.readEoln();\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nstruct Command {\n    string s;\n    bool terminate; // true if \"<>\", false if \">>\"\n    string w;\n};\n\n// Returns true if all characters of str are digits or '?'\nbool validPattern(const string &str) {\n    for (char c: str) {\n        if (!isdigit(c) && c != '?') return false;\n    }\n    return true;\n}\n\n// Apply the algorithm (the list of commands) to string a.\n// Return the resulting string after at most 200 iterations or quitf with _wa if invalid.\nstring applyAlgorithm(const vector<Command> &cmds, const string &input) {\n    string a = input;\n    for (int iteration = 1; iteration <= 200; iteration++) {\n        bool matched = false;\n        // Search for the first command whose 's' is a substring of 'a'\n        for (int i = 0; i < (int)cmds.size(); i++) {\n            const auto &c = cmds[i];\n            // Find first occurrence of c.s in a\n            size_t pos = a.find(c.s);\n            if (pos != string::npos) {\n                // Found substring; replace\n                a = a.substr(0, pos) + c.w + a.substr(pos + c.s.size());\n\n                // If this command has '<>', the algorithm terminates now\n                if (c.terminate) {\n                    return a;\n                }\n                // Otherwise (\">>\"), continue to next iteration\n                matched = true;\n                break;\n            }\n        }\n        // If no command matched, algorithm terminates\n        if (!matched) {\n            return a;\n        }\n    }\n    // If we reach here, more than 200 iterations\n    quitf(_wa, \"Algorithm did not terminate within 200 iterations for input \\\"%s\\\"\", input.c_str());\n    // unreachable:\n    return a;\n}\n\nint main(int argc, char* argv[]) {\n    registerTestlibCmd(argc, argv);\n\n    // Read the input\n    int n = inf.readInt(1, 100, \"n\");\n    vector<int> numbers(n);\n    for (int i = 0; i < n; i++) {\n        numbers[i] = inf.readInt(1, 1024, \"number\");\n    }\n\n    // Read commands from participant's output\n    // We allow up to 50 lines\n    vector<Command> cmds;\n    for (int lineCount = 0; !ouf.eof(); lineCount++) {\n        if (lineCount >= 50) {\n            quitf(_wa, \"Too many commands (more than 50)\");\n        }\n        string line = ouf.readLine();\n        if (line.empty()) {\n            // Possibly just extra empty lines - ignore them\n            // but stop if there's no more content\n            if (ouf.eof()) break;\n            // Otherwise continue to parse if there's more lines\n            continue;\n        }\n\n        // Find operator \">>\" or \"<>\"\n        // Exactly one of them must appear\n        int posOp = -1;\n        bool foundShift = false;  // for \">>\"\n        bool foundAngle = false;  // for \"<>\"\n\n        // Try to find \">>\"\n        {\n            size_t pos = line.find(\">>\");\n            if (pos != string::npos) {\n                posOp = (int)pos;\n                foundShift = true;\n            }\n        }\n        // Try to find \"<>\" if \">>\" not found\n        if (!foundShift) {\n            size_t pos = line.find(\"<>\");\n            if (pos != string::npos) {\n                posOp = (int)pos;\n                foundAngle = true;\n            }\n        }\n\n        if (posOp < 0) {\n            quitf(_wa, \"Each command must contain either \\\">>\\\" or \\\"<>\\\"\");\n        }\n\n        // Parse s and w\n        string s = line.substr(0, posOp);\n        string w = line.substr(posOp + 2);\n        if ((int)s.size() > 7 || (int)w.size() > 7) {\n            quitf(_wa, \"Strings si and wi must have length at most 7\");\n        }\n        if (!validPattern(s) || !validPattern(w)) {\n            quitf(_wa, \"Strings si and wi must contain only digits and '?'\");\n        }\n\n        cmds.push_back(Command{s, foundAngle, w});\n    }\n\n    // Now check that for each input number, the resulting string is (number + 1)\n    for (int num : numbers) {\n        // initial string\n        string start = to_string(num);\n        string result = applyAlgorithm(cmds, start);\n        // must match num+1 exactly as decimal\n        string correct = to_string(num + 1);\n        if (result != correct) {\n            quitf(_wa,\n                  \"For input %d, expected \\\"%s\\\", but got \\\"%s\\\"\",\n                  num, correct.c_str(), result.c_str());\n        }\n    }\n\n    // If all good, accept\n    quitf(_ok, \"All numbers increased by 1 correctly\");\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> numbers(n);\n\n    if (type == \"random\") {\n        for (int i = 0; i < n; i++) {\n            numbers[i] = rnd.next(1, 1024);\n        }\n    } else if (type == \"max\") {\n        for (int i = 0; i < n; i++) {\n            numbers[i] = 1024;\n        }\n    } else if (type == \"min\") {\n        for (int i = 0; i < n; i++) {\n            numbers[i] = 1;\n        }\n    } else if (type == \"carry\") {\n        vector<int> carry_numbers = {9, 99, 999};\n        for (int i = 0; i < n; i++) {\n            numbers[i] = carry_numbers[rnd.next(carry_numbers.size())];\n        }\n    } else if (type == \"zeros\") {\n        vector<int> zero_numbers = {10, 100, 1000};\n        for (int i = 0; i < n; i++) {\n            numbers[i] = zero_numbers[rnd.next(zero_numbers.size())];\n        }\n    } else if (type == \"same\") {\n        int value = opt<int>(\"value\", 100);\n        for (int i = 0; i < n; i++) {\n            numbers[i] = value;\n        }\n    } else if (type == \"small\") {\n        for (int i = 0; i < n; i++) {\n            numbers[i] = rnd.next(1, 512);\n        }\n    } else if (type == \"large\") {\n        for (int i = 0; i < n; i++) {\n            numbers[i] = rnd.next(513, 1024);\n        }\n    } else if (type == \"edge\") {\n        for (int i = 0; i < n; i++) {\n            numbers[i] = (i % 2 == 0) ? 1 : 1024;\n        }\n    } else if (type == \"pow2\") {\n        vector<int> pow2_numbers;\n        for (int i = 0; i <= 10; ++i) { // Powers of 2 up to 1024\n            pow2_numbers.push_back(1 << i);\n        }\n        for (int i = 0; i < n; i++) {\n            numbers[i] = pow2_numbers[rnd.next(pow2_numbers.size())];\n        }\n    } else {\n        // Default to random\n        for (int i = 0; i < n; i++) {\n            numbers[i] = rnd.next(1, 1024);\n        }\n    }\n\n    // Output n\n    printf(\"%d\\n\", n);\n\n    // Output the numbers\n    for (int i = 0; i < n; i++) {\n        printf(\"%d\\n\", numbers[i]);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> numbers(n);\n\n    if (type == \"random\") {\n        for (int i = 0; i < n; i++) {\n            numbers[i] = rnd.next(1, 1024);\n        }\n    } else if (type == \"max\") {\n        for (int i = 0; i < n; i++) {\n            numbers[i] = 1024;\n        }\n    } else if (type == \"min\") {\n        for (int i = 0; i < n; i++) {\n            numbers[i] = 1;\n        }\n    } else if (type == \"carry\") {\n        vector<int> carry_numbers = {9, 99, 999};\n        for (int i = 0; i < n; i++) {\n            numbers[i] = carry_numbers[rnd.next(carry_numbers.size())];\n        }\n    } else if (type == \"zeros\") {\n        vector<int> zero_numbers = {10, 100, 1000};\n        for (int i = 0; i < n; i++) {\n            numbers[i] = zero_numbers[rnd.next(zero_numbers.size())];\n        }\n    } else if (type == \"same\") {\n        int value = opt<int>(\"value\", 100);\n        for (int i = 0; i < n; i++) {\n            numbers[i] = value;\n        }\n    } else if (type == \"small\") {\n        for (int i = 0; i < n; i++) {\n            numbers[i] = rnd.next(1, 512);\n        }\n    } else if (type == \"large\") {\n        for (int i = 0; i < n; i++) {\n            numbers[i] = rnd.next(513, 1024);\n        }\n    } else if (type == \"edge\") {\n        for (int i = 0; i < n; i++) {\n            numbers[i] = (i % 2 == 0) ? 1 : 1024;\n        }\n    } else if (type == \"pow2\") {\n        vector<int> pow2_numbers;\n        for (int i = 0; i <= 10; ++i) { // Powers of 2 up to 1024\n            pow2_numbers.push_back(1 << i);\n        }\n        for (int i = 0; i < n; i++) {\n            numbers[i] = pow2_numbers[rnd.next(pow2_numbers.size())];\n        }\n    } else {\n        // Default to random\n        for (int i = 0; i < n; i++) {\n            numbers[i] = rnd.next(1, 1024);\n        }\n    }\n\n    // Output n\n    printf(\"%d\\n\", n);\n\n    // Output the numbers\n    for (int i = 0; i < n; i++) {\n        printf(\"%d\\n\", numbers[i]);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -type min\r\n./gen -n 1 -type max\r\n./gen -n 1 -type carry\r\n./gen -n 1 -type zeros\r\n./gen -n 1 -type random\r\n\r\n./gen -n 2 -type edge\r\n./gen -n 5 -type same -value 1\r\n./gen -n 5 -type same -value 1024\r\n\r\n./gen -n 10 -type carry\r\n./gen -n 10 -type zeros\r\n\r\n./gen -n 20 -type pow2\r\n./gen -n 20 -type random\r\n\r\n./gen -n 50 -type small\r\n./gen -n 50 -type large\r\n\r\n./gen -n 100 -type min\r\n./gen -n 100 -type max\r\n./gen -n 100 -type random\r\n./gen -n 100 -type edge\r\n./gen -n 100 -type pow2\r\n\r\n./gen -n 99 -type same -value 512\r\n./gen -n 100 -type carry\r\n./gen -n 100 -type zeros\r\n\r\n./gen -n 100 -type same -value 999\r\n./gen -n 100 -type same -value 1000\r\n\r\n./gen -n 1 -type same -value 1023\r\n./gen -n 100 -type same -value 1023\r\n\r\n./gen -n 100 -type small\r\n./gen -n 100 -type large\r\n\r\n./gen -n 50 -type random\r\n./gen -n 75 -type random\r\n./gen -n 100 -type random",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:05:06.494343",
        "total_tutorials": 3,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "301/D",
      "title": "D. Ярослав и делители",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест2 секунды",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеВ первой строке записаны целые числа n и m (1 ≤ n, m ≤ 2·105). Во второй строке записаны n различных целых чисел p1, p2, ..., pn (1 ≤ pi ≤ n). В следующих m строках заданы запросы Ярослава. В i-той строке записаны целые числа li, ri (1 ≤ li ≤ ri ≤ n).",
      "output_spec": "Выходные данныеВыведите m целых чисел — ответы на запросы Ярослава в порядке их следования во входных данных.Пожалуйста, не используйте спецификатор %lld для чтения или записи 64-х битовых чисел на C++. Рекомендуется использовать потоки cin, cout или спецификатор %I64d.",
      "sample_tests": "ПримерыВходные данныеСкопировать1 111 1Выходные данныеСкопировать1Входные данныеСкопировать10 91 2 3 4 5 6 7 8 9 101 102 93 84 75 62 29 105 104 10Выходные данныеСкопировать27148421279",
      "description": "D. Ярослав и делители\n\nограничение по времени на тест2 секунды\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвыводstdout\n\nВходные данныеВ первой строке записаны целые числа n и m (1 ≤ n, m ≤ 2·105). Во второй строке записаны n различных целых чисел p1, p2, ..., pn (1 ≤ pi ≤ n). В следующих m строках заданы запросы Ярослава. В i-той строке записаны целые числа li, ri (1 ≤ li ≤ ri ≤ n).\n\nВходные данные\n\nВыходные данныеВыведите m целых чисел — ответы на запросы Ярослава в порядке их следования во входных данных.Пожалуйста, не используйте спецификатор %lld для чтения или записи 64-х битовых чисел на C++. Рекомендуется использовать потоки cin, cout или спецификатор %I64d.\n\nВыходные данные\n\nВходные данныеСкопировать1 111 1Выходные данныеСкопировать1Входные данныеСкопировать10 91 2 3 4 5 6 7 8 9 101 102 93 84 75 62 29 105 104 10Выходные данныеСкопировать27148421279\n\nВходные данныеСкопировать1 111 1\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать1\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать10 91 2 3 4 5 6 7 8 9 101 102 93 84 75 62 29 105 104 10\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать27148421279\n\nВыходные данныеСкопировать\n\nСкопировать",
      "solutions": [
        {
          "title": "Codeforces Round #182 - Codeforces",
          "content": "Всем привет!Совсем скоро, 5 мая в 19:30 MSK состоится Codeforces Round #182, автором которого являюсь я. Это мой шестой раунд на Codeforces и я надеюсь, что не последний.Спасибо Геральду Агапову (Gerald) и Диме Соболеву(sdya) за помощь в подготовке раунда и Марии Беловой (Delinur) за перевод условий на английский.Настоятельно рекомендую прочитать условия ВСЕХ задач.Gl & hf ! :)По техническим причинам начало соревнования было сорвано. Приносим извинения, контест будет НЕРЕЙТИНГОВЫМ.Разбор.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/7557",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 493
        },
        {
          "title": "Codeforces Round #182 - Codeforces",
          "content": "Всем привет!Совсем скоро, 5 мая в 19:30 MSK состоится Codeforces Round #182, автором которого являюсь я. Это мой шестой раунд на Codeforces и я надеюсь, что не последний.Спасибо Геральду Агапову (Gerald) и Диме Соболеву(sdya) за помощь в подготовке раунда и Марии Беловой (Delinur) за перевод условий на английский.Настоятельно рекомендую прочитать условия ВСЕХ задач.Gl & hf ! :)По техническим причинам начало соревнования было сорвано. Приносим извинения, контест будет НЕРЕЙТИНГОВЫМ.Разбор.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/7557",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 493
        },
        {
          "title": "Codeforces Round #182 tutorial - Codeforces",
          "content": "302A - Евгений и массивЕсли длина отрезка — парное число, и количество 1 и -1 по отдельности не меньше половины длины, то ответ положительный. 302B - Евгений и плейлистЗапомним для каждой песни момент, когда она окончится (например частичными суммами). Дальше просто бинарным поиском или двумя указателями найдем максимальный номер песни, что ее конец не меньше заданного числа. 301A - Ярослав и последовательностьС помощью поиска в глубину посчитаем сколько отрицательных чисел мы можем получить. Заметим, что можно сделать либо все числа положительными либо одно число отрицательное(показать это просто, если изменить знак у числа Ч и некоторого набора чисел, а затем у числа У с тем же набором). Если можно получить все положительные числа, то ответом будет просто сумма модулей чисел иначе нужно поменять знак у числа с минимальным значением по модулю. 301B - Ярослав и времяБинарным поиском будем искать ответ. Далее воспользуемся простым алгоритмом Форда-Белмана. На каждом шагу будем хранить максимальное значение таймера при нахождении персонажа в конкретной вершине, при переходе будем проверять: не умрет ли персонаж при переходе между вершинами. Если переход возможен, то будем обновлять значение конечной вершины. Благодаря тому что a_i<=d и координаты — целые мы не получим циклов. 301C - Ярослав и алгоритмНужно воспользоваться тем, что у нас есть знак вопроса(возможно, есть решение, которое не использует этот знак). Поставим знак вопроса в начало строки. Далее будем двигать его пока он не достигнет конца строки. Далее заменим его на два знака вопроса. И будем тянуть их к началу пока перед ним находится число 9, как только мы нашли другую цифру — просто увеличим ее и закончим алгоритм. Если мы дошли до начала строки, то просто поставим 1 в начало и закончим алгоритм.Смотрите любой прошедший код для большей ясности. 301D - Ярослав и делителиЗададим все пары вида: (x,y) ((d[x]%d[y]==0) || (d[y]%d[x]==0)). Задавать такие можно с помощью решета Эретосфена. Пар заданного вида будет порядка O(n*log(n)) благодаря тому, что нам задана перестановка. Дальше с помощью сортировки подсчетом отсортируем их. Отсортируем заданные на входе отрезки. Дальше для каждого такого отрезка нужно посчитать кол — во вложенных из заданных ранее. Такую задачу можно решить с помощью дерева Фенвика. На каждом шаге добавлять отрезки в порядке сортировки по правому краю. На каждой итерации будем обновлять Дерево Фенвика, которое сможет считать количество начал уже добавленных отрезков на отрезке. С помощью такой информации легко найти ответ. Сложность решения: O(n*log^2(n)), учитывая, что мы используем дерево Фенвика. Константа в решении очень маленькая. 301E - Ярослав и расстановкиБудем строить нужные нам массивы последовательно добавляя числа. Давайте посмотрим на то, какие параметры нам нужны. Во первых, очевидно что нужно хранить количество способов построить массив на уже добавленных числах, во вторых нужно знать общее количество добавленных чисел. Теперь посмотрим на то, что происходит когда мы добавляем новое число(то есть число, большее всех предыдущих в некотором количестве). Понятно, что добавленные числа должны стоять между числами на 1 меньше. При этом если мы поставим 2 новых числа подряд, то между ними должно стоять большее(так как меньшие мы уже расставили). При этом очевидно, что нужно покрыть все предыдущие числа(между которыми должны стоять новодобавленные).Таким образом имеем еще один параметр: количество чисел, между которыми мы можем ставить новые. Таким образом мы имеем динамику от четырех параметров: dp[all][ways][lastnumber][counttoadd].Переход.Понятно, что нужно добавлять не менее counttoadd чисел, но как это повлияет на количество способов расставить числа? Все просто. Пусть мы добавили x чисел, тогда количество способов нужно будет умножить на величину Q(x-counttoadd, counttoadd), где Q(x,y) — количество способов расставить x одинаковых шариков в y разных коробок. Q(x,y) = C(x+y-1,y-1), где C(x,y) — биномиальный коэффициент.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/7560",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 301\\s*D"
          },
          "content_length": 3984
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #182 - Codeforces - Code 1",
          "code": "**Server Problem !!!!**",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7557",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #182 - Codeforces - Code 2",
          "code": "**Bad Gateway**",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7557",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #182 - Codeforces - Code 3",
          "code": "-959 -542 -669 -513 160\n-959 -542 669 513 -160\n959 542 669 513 160",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7557",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #182 - Codeforces - Code 4",
          "code": "-959 -542 -669 -513 160\n-959 -542 669 513 -160\n959 542 669 513 160",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7557",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #182 - Codeforces - Code 5",
          "code": "3 1000\n3000\n0 0\n0 1\n0 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7557",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #182 - Codeforces - Code 6",
          "code": "3 1000\n3000\n0 0\n0 1\n0 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7557",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #182 - Codeforces - Code 7",
          "code": "3 100\n300\n0 0\n0 1\n0 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7557",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #182 - Codeforces - Code 8",
          "code": "3 100\n300\n0 0\n0 1\n0 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7557",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #182 - Codeforces - Code 9",
          "code": "3 1000\n2000\n0 0\n0 1\n0 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7557",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #182 - Codeforces - Code 10",
          "code": "3 1000\n2000\n0 0\n0 1\n0 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7557",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #182 - Codeforces - Code 11",
          "code": "??0>>0??\n??1>>1??\n??2>>2??\n??3>>3??\n??4>>4??\n??5>>5??\n??6>>6??\n??7>>7??\n??8>>8??\n??9>>9??\n??>>?\n0?<>1\n1?<>2\n2?<>3\n3?<>4\n4?<>5\n5?<>6\n6?<>7\n7?<>8\n8?<>9\n9?>>?0\n?<>1\n0>>??0\n1>>??1\n2>>??2\n3>>??3\n4>>??4\n5>>??5\n6>>??6\n7>>??7\n8>>??8\n9>>??9",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7557",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #182 - Codeforces - Code 12",
          "code": "??0>>0??\n??1>>1??\n??2>>2??\n??3>>3??\n??4>>4??\n??5>>5??\n??6>>6??\n??7>>7??\n??8>>8??\n??9>>9??\n??>>?\n0?<>1\n1?<>2\n2?<>3\n3?<>4\n4?<>5\n5?<>6\n6?<>7\n7?<>8\n8?<>9\n9?>>?0\n?<>1\n0>>??0\n1>>??1\n2>>??2\n3>>??3\n4>>??4\n5>>??5\n6>>??6\n7>>??7\n8>>??8\n9>>??9",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7557",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #182 - Codeforces - Code 13",
          "code": "98\n.7\n.6\n.5\n.4\n.3\n12",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7557",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #182 - Codeforces - Code 14",
          "code": "98\n.7\n.6\n.5\n.4\n.3\n12",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7557",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #182 - Codeforces - Code 1",
          "code": "**Server Problem !!!!**",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7557",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #182 - Codeforces - Code 2",
          "code": "**Bad Gateway**",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7557",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #182 - Codeforces - Code 3",
          "code": "-959 -542 -669 -513 160\n-959 -542 669 513 -160\n959 542 669 513 160",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7557",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #182 - Codeforces - Code 4",
          "code": "-959 -542 -669 -513 160\n-959 -542 669 513 -160\n959 542 669 513 160",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7557",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #182 - Codeforces - Code 5",
          "code": "3 1000\n3000\n0 0\n0 1\n0 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7557",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #182 - Codeforces - Code 6",
          "code": "3 1000\n3000\n0 0\n0 1\n0 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7557",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #182 - Codeforces - Code 7",
          "code": "3 100\n300\n0 0\n0 1\n0 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7557",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #182 - Codeforces - Code 8",
          "code": "3 100\n300\n0 0\n0 1\n0 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7557",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #182 - Codeforces - Code 9",
          "code": "3 1000\n2000\n0 0\n0 1\n0 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7557",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #182 - Codeforces - Code 10",
          "code": "3 1000\n2000\n0 0\n0 1\n0 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7557",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #182 - Codeforces - Code 11",
          "code": "??0>>0??\n??1>>1??\n??2>>2??\n??3>>3??\n??4>>4??\n??5>>5??\n??6>>6??\n??7>>7??\n??8>>8??\n??9>>9??\n??>>?\n0?<>1\n1?<>2\n2?<>3\n3?<>4\n4?<>5\n5?<>6\n6?<>7\n7?<>8\n8?<>9\n9?>>?0\n?<>1\n0>>??0\n1>>??1\n2>>??2\n3>>??3\n4>>??4\n5>>??5\n6>>??6\n7>>??7\n8>>??8\n9>>??9",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7557",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #182 - Codeforces - Code 12",
          "code": "??0>>0??\n??1>>1??\n??2>>2??\n??3>>3??\n??4>>4??\n??5>>5??\n??6>>6??\n??7>>7??\n??8>>8??\n??9>>9??\n??>>?\n0?<>1\n1?<>2\n2?<>3\n3?<>4\n4?<>5\n5?<>6\n6?<>7\n7?<>8\n8?<>9\n9?>>?0\n?<>1\n0>>??0\n1>>??1\n2>>??2\n3>>??3\n4>>??4\n5>>??5\n6>>??6\n7>>??7\n8>>??8\n9>>??9",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7557",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #182 - Codeforces - Code 13",
          "code": "98\n.7\n.6\n.5\n.4\n.3\n12",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7557",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #182 - Codeforces - Code 14",
          "code": "98\n.7\n.6\n.5\n.4\n.3\n12",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7557",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #182 tutorial - Codeforces - Code 1",
          "code": "8 1000\n1000 1000 1000 1000 1000 1000\n0 0 \n0 1\n1 1\n2 1\n2 0\n2 -1\n3 -1\n4 -1\n4 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7560",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #182 tutorial - Codeforces - Code 2",
          "code": "8 1000\n1000 1000 1000 1000 1000 1000\n0 0 \n0 1\n1 1\n2 1\n2 0\n2 -1\n3 -1\n4 -1\n4 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7560",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #182 tutorial - Codeforces - Code 3",
          "code": "for (int a = 1; a <= n; a++)\n    for (int b = a; b <= n; b += a)\n        remember_pair(a, b);// b % a == 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7560",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #182 tutorial - Codeforces - Code 4",
          "code": "for (int a = 1; a <= n; a++)\n    for (int b = a; b <= n; b += a)\n        remember_pair(a, b);// b % a == 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7560",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #182 tutorial - Codeforces - Code 5",
          "code": "ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    cin.tie(0);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7560",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #182 tutorial - Codeforces - Code 6",
          "code": "ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    cin.tie(0);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7560",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #182 tutorial - Codeforces - Code 7",
          "code": "3 1\n1000\n0 0\n0 100\n0 101",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7560",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #182 tutorial - Codeforces - Code 8",
          "code": "3 1\n1000\n0 0\n0 100\n0 101",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7560",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 200000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 200000, \"m\");\n    inf.readEoln();\n\n    vector<int> p = inf.readInts(n, 1, n, \"p_i\");\n    inf.readEoln();\n\n    set<int> p_set(p.begin(), p.end());\n    ensuref((int)p_set.size() == n, \"p_i are not distinct\");\n\n    for (int i = 0; i < m; ++i) {\n        int l = inf.readInt(1, n, \"l_i\");\n        inf.readSpace();\n        int r = inf.readInt(1, n, \"r_i\");\n        inf.readEoln();\n        ensuref(l <= r, \"In query %d, l_i(%d) > r_i(%d)\", i + 1, l, r);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 200000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 200000, \"m\");\n    inf.readEoln();\n\n    vector<int> p = inf.readInts(n, 1, n, \"p_i\");\n    inf.readEoln();\n\n    set<int> p_set(p.begin(), p.end());\n    ensuref((int)p_set.size() == n, \"p_i are not distinct\");\n\n    for (int i = 0; i < m; ++i) {\n        int l = inf.readInt(1, n, \"l_i\");\n        inf.readSpace();\n        int r = inf.readInt(1, n, \"r_i\");\n        inf.readEoln();\n        ensuref(l <= r, \"In query %d, l_i(%d) > r_i(%d)\", i + 1, l, r);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 200000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 200000, \"m\");\n    inf.readEoln();\n\n    vector<int> p = inf.readInts(n, 1, n, \"p_i\");\n    inf.readEoln();\n\n    set<int> p_set(p.begin(), p.end());\n    ensuref((int)p_set.size() == n, \"p_i are not distinct\");\n\n    for (int i = 0; i < m; ++i) {\n        int l = inf.readInt(1, n, \"l_i\");\n        inf.readSpace();\n        int r = inf.readInt(1, n, \"r_i\");\n        inf.readEoln();\n        ensuref(l <= r, \"In query %d, l_i(%d) > r_i(%d)\", i + 1, l, r);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string p_type = opt<string>(\"p_type\", \"random\");\n    string q_type = opt<string>(\"q_type\", \"random\");\n    \n    // Generate p according to p_type\n    vector<int> p(n);\n    if (p_type == \"random\") {\n        for (int i = 0; i < n; ++i)\n            p[i] = i + 1;\n        shuffle(p.begin(), p.end());\n    } else if (p_type == \"sorted\") {\n        for (int i = 0; i < n; ++i)\n            p[i] = i + 1;\n    } else if (p_type == \"reversed\") {\n        for (int i = 0; i < n; ++i)\n            p[i] = n - i;\n    } else {\n        // Other types can be added here\n        // For now, default to random\n        for (int i = 0; i < n; ++i)\n            p[i] = i + 1;\n        shuffle(p.begin(), p.end());\n    }\n    \n    // Output n and m\n    printf(\"%d %d\\n\", n, m);\n    // Output p\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d%c\", p[i], i == n - 1 ? '\\n' : ' ');\n    }\n    \n    // Generate m queries\n    vector<pair<int, int>> queries;\n    if (q_type == \"random\") {\n        for (int i = 0; i < m; ++i) {\n            int l = rnd.next(1, n);\n            int r = rnd.next(l, n);\n            queries.push_back(make_pair(l, r));\n        }\n    } else if (q_type == \"full\") {\n        // All queries are [1, n]\n        for (int i = 0; i < m; ++i) {\n            queries.push_back(make_pair(1, n));\n        }\n    } else if (q_type == \"single\") {\n        // All queries are [k, k], k random\n        for (int i = 0; i < m; ++i) {\n            int k = rnd.next(1, n);\n            queries.push_back(make_pair(k, k));\n        }\n    } else if (q_type == \"small\") {\n        // Queries of small intervals\n        for (int i = 0; i < m; ++i) {\n            int l = rnd.next(1, max(1, n - 5));\n            int r = l + rnd.next(0, min(n - l, 5));\n            queries.push_back(make_pair(l, r));\n        }\n    } else if (q_type == \"same_pos\") {\n        // All queries are [k, k], k fixed\n        int k = rnd.next(1, n);\n        for (int i = 0; i < m; ++i) {\n            queries.push_back(make_pair(k, k));\n        }\n    } else if (q_type == \"first_half\") {\n        // Queries in first half\n        int mid = n / 2;\n        for (int i = 0; i < m; ++i) {\n            int l = rnd.next(1, mid);\n            int r = rnd.next(l, mid);\n            queries.push_back(make_pair(l, r));\n        }\n    } else if (q_type == \"second_half\") {\n        // Queries in second half\n        int mid = n / 2 + 1;\n        for (int i = 0; i < m; ++i) {\n            int l = rnd.next(mid, n);\n            int r = rnd.next(l, n);\n            queries.push_back(make_pair(l, r));\n        }\n    } else {\n        // Default to random queries\n        for (int i = 0; i < m; ++i) {\n            int l = rnd.next(1, n);\n            int r = rnd.next(l, n);\n            queries.push_back(make_pair(l, r));\n        }\n    }\n    // Output the queries\n    for (int i = 0; i < m; ++i) {\n        printf(\"%d %d\\n\", queries[i].first, queries[i].second);\n    }\n    \n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string p_type = opt<string>(\"p_type\", \"random\");\n    string q_type = opt<string>(\"q_type\", \"random\");\n    \n    // Generate p according to p_type\n    vector<int> p(n);\n    if (p_type == \"random\") {\n        for (int i = 0; i < n; ++i)\n            p[i] = i + 1;\n        shuffle(p.begin(), p.end());\n    } else if (p_type == \"sorted\") {\n        for (int i = 0; i < n; ++i)\n            p[i] = i + 1;\n    } else if (p_type == \"reversed\") {\n        for (int i = 0; i < n; ++i)\n            p[i] = n - i;\n    } else {\n        // Other types can be added here\n        // For now, default to random\n        for (int i = 0; i < n; ++i)\n            p[i] = i + 1;\n        shuffle(p.begin(), p.end());\n    }\n    \n    // Output n and m\n    printf(\"%d %d\\n\", n, m);\n    // Output p\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d%c\", p[i], i == n - 1 ? '\\n' : ' ');\n    }\n    \n    // Generate m queries\n    vector<pair<int, int>> queries;\n    if (q_type == \"random\") {\n        for (int i = 0; i < m; ++i) {\n            int l = rnd.next(1, n);\n            int r = rnd.next(l, n);\n            queries.push_back(make_pair(l, r));\n        }\n    } else if (q_type == \"full\") {\n        // All queries are [1, n]\n        for (int i = 0; i < m; ++i) {\n            queries.push_back(make_pair(1, n));\n        }\n    } else if (q_type == \"single\") {\n        // All queries are [k, k], k random\n        for (int i = 0; i < m; ++i) {\n            int k = rnd.next(1, n);\n            queries.push_back(make_pair(k, k));\n        }\n    } else if (q_type == \"small\") {\n        // Queries of small intervals\n        for (int i = 0; i < m; ++i) {\n            int l = rnd.next(1, max(1, n - 5));\n            int r = l + rnd.next(0, min(n - l, 5));\n            queries.push_back(make_pair(l, r));\n        }\n    } else if (q_type == \"same_pos\") {\n        // All queries are [k, k], k fixed\n        int k = rnd.next(1, n);\n        for (int i = 0; i < m; ++i) {\n            queries.push_back(make_pair(k, k));\n        }\n    } else if (q_type == \"first_half\") {\n        // Queries in first half\n        int mid = n / 2;\n        for (int i = 0; i < m; ++i) {\n            int l = rnd.next(1, mid);\n            int r = rnd.next(l, mid);\n            queries.push_back(make_pair(l, r));\n        }\n    } else if (q_type == \"second_half\") {\n        // Queries in second half\n        int mid = n / 2 + 1;\n        for (int i = 0; i < m; ++i) {\n            int l = rnd.next(mid, n);\n            int r = rnd.next(l, n);\n            queries.push_back(make_pair(l, r));\n        }\n    } else {\n        // Default to random queries\n        for (int i = 0; i < m; ++i) {\n            int l = rnd.next(1, n);\n            int r = rnd.next(l, n);\n            queries.push_back(make_pair(l, r));\n        }\n    }\n    // Output the queries\n    for (int i = 0; i < m; ++i) {\n        printf(\"%d %d\\n\", queries[i].first, queries[i].second);\n    }\n    \n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -m 1 -p_type sorted -q_type full\n./gen -n 1 -m 1 -p_type random -q_type random\n./gen -n 1 -m 1 -p_type reversed -q_type single\n\n./gen -n 2 -m 1 -p_type sorted -q_type full\n./gen -n 2 -m 2 -p_type random -q_type random\n./gen -n 2 -m 2 -p_type reversed -q_type single\n\n./gen -n 10 -m 10 -p_type sorted -q_type random\n./gen -n 10 -m 10 -p_type random -q_type full\n./gen -n 10 -m 10 -p_type reversed -q_type small\n\n./gen -n 1000 -m 1000 -p_type random -q_type random\n./gen -n 1000 -m 1000 -p_type sorted -q_type full\n./gen -n 1000 -m 1000 -p_type reversed -q_type small\n\n./gen -n 200000 -m 200000 -p_type random -q_type random\n./gen -n 200000 -m 200000 -p_type sorted -q_type full\n./gen -n 200000 -m 200000 -p_type reversed -q_type small\n\n# Edge cases\n./gen -n 200000 -m 1 -p_type sorted -q_type full\n./gen -n 1 -m 200000 -p_type sorted -q_type single\n\n./gen -n 99999 -m 199999 -p_type random -q_type random\n\n# Testing small intervals\n./gen -n 200000 -m 200000 -p_type random -q_type small\n\n# Testing queries of minimal intervals\n./gen -n 200000 -m 200000 -p_type random -q_type single\n\n# Testing mid-sized n and m\n./gen -n 10000 -m 10000 -p_type random -q_type random\n./gen -n 10000 -m 10000 -p_type sorted -q_type random\n\n# Special case: max n, m, and p reversed\n./gen -n 200000 -m 200000 -p_type reversed -q_type single\n\n# Random data\n./gen -n 200000 -m 200000 -p_type random -q_type random\n\n# All queries are on the same position\n./gen -n 200000 -m 200000 -p_type random -q_type same_pos\n\n# All queries in the first half of the array\n./gen -n 200000 -m 200000 -p_type random -q_type first_half\n\n# All queries in the second half of the array\n./gen -n 200000 -m 200000 -p_type random -q_type second_half\n\n# Maximum n and m with sorted p and full queries\n./gen -n 200000 -m 200000 -p_type sorted -q_type full\n\n# Maximum n and m with reversed p and random queries\n./gen -n 200000 -m 200000 -p_type reversed -q_type random\n\n# Small n and maximum m with random p and single-element queries\n./gen -n 10 -m 200000 -p_type random -q_type single\n\n# Maximum n with minimal m and random p and queries\n./gen -n 200000 -m 1 -p_type random -q_type random\n\n# Medium n and m with random p and small interval queries\n./gen -n 50000 -m 50000 -p_type random -q_type small\n\n# Randomized test with large n and m\n./gen -n 150000 -m 150000 -p_type random -q_type random\n\n# Randomized test with random p and full queries\n./gen -n 180000 -m 180000 -p_type random -q_type full\n\n# Randomized test with random p and same position queries\n./gen -n 150000 -m 150000 -p_type random -q_type same_pos\n\n# Reversed p with random queries\n./gen -n 200000 -m 200000 -p_type reversed -q_type random\n\n# Sorted p with small interval queries\n./gen -n 200000 -m 200000 -p_type sorted -q_type small\n\n# Random p with first half queries\n./gen -n 200000 -m 200000 -p_type random -q_type first_half\n\n# Random p with second half queries\n./gen -n 200000 -m 200000 -p_type random -q_type second_half\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:05:08.887880",
        "total_tutorials": 3,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "301/E",
      "title": "E. Yaroslav and Arrangements",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test3 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe single line contains three integers n, m, k (1 ≤ n, m, k ≤ 100).",
      "output_spec": "OutputIn a single line print the remainder after dividing the answer to the problem by number 1000000007 (109 + 7).",
      "sample_tests": "ExamplesInputCopy1 1 1OutputCopy0InputCopy3 3 3OutputCopy2",
      "description": "E. Yaroslav and Arrangements\n\ntime limit per test3 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe single line contains three integers n, m, k (1 ≤ n, m, k ≤ 100).\n\nOutputIn a single line print the remainder after dividing the answer to the problem by number 1000000007 (109 + 7).\n\nInputCopy1 1 1OutputCopy0InputCopy3 3 3OutputCopy2\n\nInputCopy1 1 1\n\nOutputCopy0\n\nInputCopy3 3 3\n\nOutputCopy2",
      "solutions": [
        {
          "title": "Codeforces Round #182 - Codeforces",
          "content": "Hello everyone!Codeforces Round #182 will take place on Sunday, May 5th at 19:30 MSK. This is my sixth Codeforces round and I hope not the last.I'd like to thank Gerald and sdya for helping me to prepare the round. Special thanks to Delinur for translation of all problem statements into English.I strongly recommend you to read ALL the problems.Gl & hf ! :)Because of technical issue the start of the contest was unsuccessful. Sorry about it. The contest will be UNRATED.Tutorial.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/7557",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 481
        },
        {
          "title": "Codeforces Round #182 - Codeforces",
          "content": "Hello everyone!Codeforces Round #182 will take place on Sunday, May 5th at 19:30 MSK. This is my sixth Codeforces round and I hope not the last.I'd like to thank Gerald and sdya for helping me to prepare the round. Special thanks to Delinur for translation of all problem statements into English.I strongly recommend you to read ALL the problems.Gl & hf ! :)Because of technical issue the start of the contest was unsuccessful. Sorry about it. The contest will be UNRATED.Tutorial.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/7557",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 481
        },
        {
          "title": "Codeforces Round #182 tutorial - Codeforces",
          "content": "302A - Eugeny and ArrayIf the length of the given segment is even and count of 1 in input is not lower then half of the length of the segment and count of -1 in the input is not lower then half of the length of the segment so we have answer 1, otherwise 0. 302B - Eugeny and Play ListFor each song we will count moment of time, when it will be over (some sums on the prefixes, for example). Further, we will use binary search of two itaratos method to solve the problem. 301A - Yaroslav and SequenceUsing dfs we will find number of numbers that we can set as positive. Note that we can either set all of the numbers as positive or leave one number(any) as negative. If we can obtain all numbers as positive, we just return sum of modules of the numbers, but if we cannot we will count the same sum and will subtract minimal modular value multiple 2 from sum. 301B - Yaroslav and TimeWe will use binary search to find the answer. Further we will use Ford-Bellman algorithm. On each step we will have an array of maximum values on timer, when we stand in some point. On in transfer we will check: will our player stay alive after travelling beetwen points. If we can make transfer, we will update value of the final destination point. Becouse of a_i<=d and integer coordinates we haven't optimal cycles, and solution exists. 301C - Yaroslav and AlgorithmWe will use ? as iterator. In the begin we will set ? before the number. Then we will move it to the end of the string. Then we will change ? to ?? and we will move it to the begin, while we have 9 before ??. If we have another digit, we just increase it, and finish the algorithm. If we have ?? at the begin, we change it to 1, and end the algorithm. Look for accepted solutions for better understanding. 301D - Yaroslav and DivisorsLets add all pair: (x,y) ((d[x]%d[y]==0) || (d[y]%d[x]==0)) to some lest. We can count such pairs using Eretosphen algorithm. Here will be O(n*log(n)) sych pairs using fact, that we have permutation. We will sort all this paairs using counting-sort. Also we will sort given in input intervals. For each given interval we should count number of pairs that countained in given them . Such problem we can solve using Fenvik tree. On each step we will add segments(that are sorted by right side). On each step we will update Fenfick-tree that count number of added pairs on some suffix. Using such tree if it easy to count the answer. So we have O(n*log^2(n)) solution. 301E - Yaroslav and ArrangementsWe will build the needed arrays sequentially adding numbers. Let's look at what states we need. First, it is obvious that you need to keep the number of ways to build an array of already added numbers, secondly you need to know the total amount of added numbers. Now let's look at what happens when we add a new number (that is greater than all of the previous in a certain amount). It is clear that the added numbers should stand between the numbers 1 to less. In this case, if we put two new numbers in a row, between them should stand more (since we already have placed less). It is obvious that you need to cover all the previous numbers (among which must stand newly added). Thus, we have another state: the number of integers between which we should put the new ones. Thus we have the dynamics of the four parameters: dp [all] [ways] [lastnumber] [counttoadd]. Transfer. It is clear that you need to add at least counttoadd numbers, but how will this affect the number of ways to arrange the numbers? It's simple. Suppose we added number x, then the number of ways to be multiplied by the value of Q (x-counttoadd, counttoadd), where Q (x, y) — the number of ways to assign the same x balls in y different boxes. Q (x, y) = C (x + y-1, y-1) where C (x, y) — binomial coefficient.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/7560",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 301\\s*E"
          },
          "content_length": 3769
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #182 - Codeforces - Code 1",
          "code": "**Server Problem !!!!**",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7557",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #182 - Codeforces - Code 2",
          "code": "**Bad Gateway**",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7557",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #182 - Codeforces - Code 3",
          "code": "-959 -542 -669 -513 160\n-959 -542 669 513 -160\n959 542 669 513 160",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7557",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #182 - Codeforces - Code 4",
          "code": "-959 -542 -669 -513 160\n-959 -542 669 513 -160\n959 542 669 513 160",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7557",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #182 - Codeforces - Code 5",
          "code": "3 1000\n2000\n0 0\n0 1\n0 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7557",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #182 - Codeforces - Code 6",
          "code": "3 1000\n2000\n0 0\n0 1\n0 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7557",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #182 - Codeforces - Code 7",
          "code": "??0>>0??\n??1>>1??\n??2>>2??\n??3>>3??\n??4>>4??\n??5>>5??\n??6>>6??\n??7>>7??\n??8>>8??\n??9>>9??\n??>>?\n0?<>1\n1?<>2\n2?<>3\n3?<>4\n4?<>5\n5?<>6\n6?<>7\n7?<>8\n8?<>9\n9?>>?0\n?<>1\n0>>??0\n1>>??1\n2>>??2\n3>>??3\n4>>??4\n5>>??5\n6>>??6\n7>>??7\n8>>??8\n9>>??9",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7557",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #182 - Codeforces - Code 8",
          "code": "??0>>0??\n??1>>1??\n??2>>2??\n??3>>3??\n??4>>4??\n??5>>5??\n??6>>6??\n??7>>7??\n??8>>8??\n??9>>9??\n??>>?\n0?<>1\n1?<>2\n2?<>3\n3?<>4\n4?<>5\n5?<>6\n6?<>7\n7?<>8\n8?<>9\n9?>>?0\n?<>1\n0>>??0\n1>>??1\n2>>??2\n3>>??3\n4>>??4\n5>>??5\n6>>??6\n7>>??7\n8>>??8\n9>>??9",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7557",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #182 - Codeforces - Code 9",
          "code": "98\n.7\n.6\n.5\n.4\n.3\n12",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7557",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #182 - Codeforces - Code 10",
          "code": "98\n.7\n.6\n.5\n.4\n.3\n12",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7557",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #182 - Codeforces - Code 1",
          "code": "**Server Problem !!!!**",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7557",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #182 - Codeforces - Code 2",
          "code": "**Bad Gateway**",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7557",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #182 - Codeforces - Code 3",
          "code": "-959 -542 -669 -513 160\n-959 -542 669 513 -160\n959 542 669 513 160",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7557",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #182 - Codeforces - Code 4",
          "code": "-959 -542 -669 -513 160\n-959 -542 669 513 -160\n959 542 669 513 160",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7557",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #182 - Codeforces - Code 5",
          "code": "3 1000\n2000\n0 0\n0 1\n0 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7557",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #182 - Codeforces - Code 6",
          "code": "3 1000\n2000\n0 0\n0 1\n0 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7557",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #182 - Codeforces - Code 7",
          "code": "??0>>0??\n??1>>1??\n??2>>2??\n??3>>3??\n??4>>4??\n??5>>5??\n??6>>6??\n??7>>7??\n??8>>8??\n??9>>9??\n??>>?\n0?<>1\n1?<>2\n2?<>3\n3?<>4\n4?<>5\n5?<>6\n6?<>7\n7?<>8\n8?<>9\n9?>>?0\n?<>1\n0>>??0\n1>>??1\n2>>??2\n3>>??3\n4>>??4\n5>>??5\n6>>??6\n7>>??7\n8>>??8\n9>>??9",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7557",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #182 - Codeforces - Code 8",
          "code": "??0>>0??\n??1>>1??\n??2>>2??\n??3>>3??\n??4>>4??\n??5>>5??\n??6>>6??\n??7>>7??\n??8>>8??\n??9>>9??\n??>>?\n0?<>1\n1?<>2\n2?<>3\n3?<>4\n4?<>5\n5?<>6\n6?<>7\n7?<>8\n8?<>9\n9?>>?0\n?<>1\n0>>??0\n1>>??1\n2>>??2\n3>>??3\n4>>??4\n5>>??5\n6>>??6\n7>>??7\n8>>??8\n9>>??9",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7557",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #182 - Codeforces - Code 9",
          "code": "98\n.7\n.6\n.5\n.4\n.3\n12",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7557",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #182 - Codeforces - Code 10",
          "code": "98\n.7\n.6\n.5\n.4\n.3\n12",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7557",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #182 tutorial - Codeforces - Code 1",
          "code": "for (int a = 1; a <= n; a++)\n    for (int b = a; b <= n; b += a)\n        remember_pair(a, b);// b % a == 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7560",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #182 tutorial - Codeforces - Code 2",
          "code": "for (int a = 1; a <= n; a++)\n    for (int b = a; b <= n; b += a)\n        remember_pair(a, b);// b % a == 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7560",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #182 tutorial - Codeforces - Code 3",
          "code": "ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    cin.tie(0);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7560",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #182 tutorial - Codeforces - Code 4",
          "code": "ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    cin.tie(0);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7560",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #182 tutorial - Codeforces - Code 5",
          "code": "3 1\n1000\n0 0\n0 100\n0 101",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7560",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #182 tutorial - Codeforces - Code 6",
          "code": "3 1\n1000\n0 0\n0 100\n0 101",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7560",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 100, \"m\");\n    inf.readSpace();\n    int k = inf.readInt(1, 100, \"k\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 100, \"m\");\n    inf.readSpace();\n    int k = inf.readInt(1, 100, \"k\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 100, \"m\");\n    inf.readSpace();\n    int k = inf.readInt(1, 100, \"k\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    int k = opt<int>(\"k\");\n\n    printf(\"%d %d %d\\n\", n, m, k);\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    int k = opt<int>(\"k\");\n\n    printf(\"%d %d %d\\n\", n, m, k);\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Minimal values\n./gen -n 1 -m 1 -k 1\n\n# Maximal values\n./gen -n 100 -m 100 -k 100\n\n# Varying n with minimal m and k\n./gen -n 1 -m 1 -k 1\n./gen -n 50 -m 1 -k 1\n./gen -n 100 -m 1 -k 1\n\n# Varying m with minimal n and k\n./gen -n 1 -m 1 -k 1\n./gen -n 1 -m 50 -k 1\n./gen -n 1 -m 100 -k 1\n\n# Varying k with minimal n and m\n./gen -n 1 -m 1 -k 1\n./gen -n 1 -m 1 -k 50\n./gen -n 1 -m 1 -k 100\n\n# Mid-range values\n./gen -n 50 -m 50 -k 50\n\n# Varying n, m, k independently\n./gen -n 20 -m 30 -k 40\n./gen -n 40 -m 30 -k 20\n./gen -n 30 -m 20 -k 40\n./gen -n 40 -m 20 -k 30\n\n# Edge cases\n./gen -n 2 -m 2 -k 2\n./gen -n 3 -m 3 -k 3\n./gen -n 4 -m 4 -k 4\n\n# Maximal n, minimal m, k\n./gen -n 100 -m 1 -k 1\n\n# Minimal n, maximal m, k\n./gen -n 1 -m 100 -k 100\n\n# Random values\n./gen -n 37 -m 58 -k 73\n./gen -n 61 -m 45 -k 29\n./gen -n 89 -m 21 -k 13\n\n# Additional test cases\n./gen -n 100 -m 100 -k 1\n./gen -n 100 -m 1 -k 100\n./gen -n 1 -m 100 -k 100\n\n# Potential corner cases\n./gen -n 99 -m 99 -k 2\n./gen -n 2 -m 99 -k 99\n./gen -n 99 -m 2 -k 99\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:05:10.606523",
        "total_tutorials": 3,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "302/A",
      "title": "Problem 302/A",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "",
      "memory_limit": "",
      "input_spec": "",
      "output_spec": "",
      "sample_tests": "",
      "description": "",
      "solutions": [],
      "code_examples": [],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 200000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 200000, \"m\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, -1, 1, \"a_i\");\n    inf.readEoln();\n\n    for (int i = 0; i < n; ++i) {\n        ensuref(a[i] == -1 || a[i] == 1, \"a[%d] must be -1 or 1\", i+1);\n    }\n\n    for (int i = 0; i < m; ++i) {\n        int l = inf.readInt(1, n, \"l_i\");\n        inf.readSpace();\n        int r = inf.readInt(1, n, \"r_i\");\n        inf.readEoln();\n\n        ensuref(l <= r, \"In query %d, l_i (%d) must be <= r_i (%d)\", i+1, l, r);\n    }\n\n    inf.readEof();\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 200000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 200000, \"m\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, -1, 1, \"a_i\");\n    inf.readEoln();\n\n    for (int i = 0; i < n; ++i) {\n        ensuref(a[i] == -1 || a[i] == 1, \"a[%d] must be -1 or 1\", i+1);\n    }\n\n    for (int i = 0; i < m; ++i) {\n        int l = inf.readInt(1, n, \"l_i\");\n        inf.readSpace();\n        int r = inf.readInt(1, n, \"r_i\");\n        inf.readEoln();\n\n        ensuref(l <= r, \"In query %d, l_i (%d) must be <= r_i (%d)\", i+1, l, r);\n    }\n\n    inf.readEof();\n\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 200000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 200000, \"m\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, -1, 1, \"a_i\");\n    inf.readEoln();\n\n    for (int i = 0; i < n; ++i) {\n        ensuref(a[i] == -1 || a[i] == 1, \"a[%d] must be -1 or 1\", i+1);\n    }\n\n    for (int i = 0; i < m; ++i) {\n        int l = inf.readInt(1, n, \"l_i\");\n        inf.readSpace();\n        int r = inf.readInt(1, n, \"r_i\");\n        inf.readEoln();\n\n        ensuref(l <= r, \"In query %d, l_i (%d) must be <= r_i (%d)\", i+1, l, r);\n    }\n\n    inf.readEof();\n\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    // Parameters\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n\n    string type = opt<string>(\"type\", \"random\");\n    string qtype = opt<string>(\"qtype\", \"random\");\n\n    // Generate array a\n    vector<int> a(n);\n\n    if (type == \"all_ones\") {\n        fill(a.begin(), a.end(), 1);\n    } else if (type == \"all_minus_ones\") {\n        fill(a.begin(), a.end(), -1);\n    } else if (type == \"equal\") {\n        // Equal number of 1s and -1s\n        int ones = n / 2;\n        int minus_ones = n - ones;\n        vector<int> tmp;\n        for (int i = 0; i < ones; i++) tmp.push_back(1);\n        for (int i = 0; i < minus_ones; i++) tmp.push_back(-1);\n        shuffle(tmp.begin(), tmp.end());\n        a = tmp;\n    } else if (type == \"more_ones\") {\n        int ones = n * 2 / 3;\n        int minus_ones = n - ones;\n        vector<int> tmp;\n        for (int i = 0; i < ones; i++) tmp.push_back(1);\n        for (int i = 0; i < minus_ones; i++) tmp.push_back(-1);\n        shuffle(tmp.begin(), tmp.end());\n        a = tmp;\n    } else if (type == \"more_minus_ones\") {\n        int minus_ones = n * 2 / 3;\n        int ones = n - minus_ones;\n        vector<int> tmp;\n        for (int i = 0; i < ones; i++) tmp.push_back(1);\n        for (int i = 0; i < minus_ones; i++) tmp.push_back(-1);\n        shuffle(tmp.begin(), tmp.end());\n        a = tmp;\n    } else if (type == \"random\") {\n        for (int i = 0; i < n; i++) {\n            a[i] = rnd.next(2) == 0 ? -1 : 1;\n        }\n    } else {\n        // Default is random\n        for (int i = 0; i < n; i++) {\n            a[i] = rnd.next(2) == 0 ? -1 : 1;\n        }\n    }\n\n    // Generate m queries\n    vector<pair<int,int>> queries(m);\n\n    if (qtype == \"full_range\") {\n        for (int i = 0; i < m; i++) {\n            queries[i] = {1, n};\n        }\n    } else if (qtype == \"single_element\") {\n        for (int i = 0; i < m; i++) {\n            int pos = rnd.next(1, n);\n            queries[i] = {pos, pos};\n        }\n    } else if (qtype == \"prefix\") {\n        for (int i = 0; i < m; i++) {\n            int r = rnd.next(1, n);\n            queries[i] = {1, r};\n        }\n    } else if (qtype == \"suffix\") {\n        for (int i = 0; i < m; i++) {\n            int l = rnd.next(1, n);\n            queries[i] = {l, n};\n        }\n    } else if (qtype == \"equal_intervals\") {\n        // Divides the array into m equal intervals\n        int len = n / m;\n        if (len == 0) len = 1;\n        int current = 1;\n        for (int i = 0; i < m; i++) {\n            int l = current;\n            int r = min(n, current + len - 1);\n            queries[i] = {l, r};\n            current = r + 1;\n            if (current > n)\n                current = 1;\n        }\n    } else { // \"random\" and default\n        for (int i = 0; i < m; i++) {\n            int l = rnd.next(1, n);\n            int r = rnd.next(1, n);\n            if (l > r) swap(l, r);\n            queries[i] = {l, r};\n        }\n    }\n\n    // Output the data\n    printf(\"%d %d\\n\", n, m);\n    for (int i = 0; i < n; i++) {\n        printf(\"%d%c\", a[i], i == n - 1 ? '\\n' : ' ');\n    }\n    for (int i = 0; i < m; i++) {\n        printf(\"%d %d\\n\", queries[i].first, queries[i].second);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    // Parameters\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n\n    string type = opt<string>(\"type\", \"random\");\n    string qtype = opt<string>(\"qtype\", \"random\");\n\n    // Generate array a\n    vector<int> a(n);\n\n    if (type == \"all_ones\") {\n        fill(a.begin(), a.end(), 1);\n    } else if (type == \"all_minus_ones\") {\n        fill(a.begin(), a.end(), -1);\n    } else if (type == \"equal\") {\n        // Equal number of 1s and -1s\n        int ones = n / 2;\n        int minus_ones = n - ones;\n        vector<int> tmp;\n        for (int i = 0; i < ones; i++) tmp.push_back(1);\n        for (int i = 0; i < minus_ones; i++) tmp.push_back(-1);\n        shuffle(tmp.begin(), tmp.end());\n        a = tmp;\n    } else if (type == \"more_ones\") {\n        int ones = n * 2 / 3;\n        int minus_ones = n - ones;\n        vector<int> tmp;\n        for (int i = 0; i < ones; i++) tmp.push_back(1);\n        for (int i = 0; i < minus_ones; i++) tmp.push_back(-1);\n        shuffle(tmp.begin(), tmp.end());\n        a = tmp;\n    } else if (type == \"more_minus_ones\") {\n        int minus_ones = n * 2 / 3;\n        int ones = n - minus_ones;\n        vector<int> tmp;\n        for (int i = 0; i < ones; i++) tmp.push_back(1);\n        for (int i = 0; i < minus_ones; i++) tmp.push_back(-1);\n        shuffle(tmp.begin(), tmp.end());\n        a = tmp;\n    } else if (type == \"random\") {\n        for (int i = 0; i < n; i++) {\n            a[i] = rnd.next(2) == 0 ? -1 : 1;\n        }\n    } else {\n        // Default is random\n        for (int i = 0; i < n; i++) {\n            a[i] = rnd.next(2) == 0 ? -1 : 1;\n        }\n    }\n\n    // Generate m queries\n    vector<pair<int,int>> queries(m);\n\n    if (qtype == \"full_range\") {\n        for (int i = 0; i < m; i++) {\n            queries[i] = {1, n};\n        }\n    } else if (qtype == \"single_element\") {\n        for (int i = 0; i < m; i++) {\n            int pos = rnd.next(1, n);\n            queries[i] = {pos, pos};\n        }\n    } else if (qtype == \"prefix\") {\n        for (int i = 0; i < m; i++) {\n            int r = rnd.next(1, n);\n            queries[i] = {1, r};\n        }\n    } else if (qtype == \"suffix\") {\n        for (int i = 0; i < m; i++) {\n            int l = rnd.next(1, n);\n            queries[i] = {l, n};\n        }\n    } else if (qtype == \"equal_intervals\") {\n        // Divides the array into m equal intervals\n        int len = n / m;\n        if (len == 0) len = 1;\n        int current = 1;\n        for (int i = 0; i < m; i++) {\n            int l = current;\n            int r = min(n, current + len - 1);\n            queries[i] = {l, r};\n            current = r + 1;\n            if (current > n)\n                current = 1;\n        }\n    } else { // \"random\" and default\n        for (int i = 0; i < m; i++) {\n            int l = rnd.next(1, n);\n            int r = rnd.next(1, n);\n            if (l > r) swap(l, r);\n            queries[i] = {l, r};\n        }\n    }\n\n    // Output the data\n    printf(\"%d %d\\n\", n, m);\n    for (int i = 0; i < n; i++) {\n        printf(\"%d%c\", a[i], i == n - 1 ? '\\n' : ' ');\n    }\n    for (int i = 0; i < m; i++) {\n        printf(\"%d %d\\n\", queries[i].first, queries[i].second);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -m 1 -type all_ones -qtype full_range\n./gen -n 1 -m 1 -type all_minus_ones -qtype full_range\n./gen -n 2 -m 1 -type equal -qtype single_element\n./gen -n 5 -m 5 -type random -qtype random\n./gen -n 10 -m 10 -type more_ones -qtype random\n./gen -n 10 -m 10 -type more_minus_ones -qtype random\n./gen -n 100 -m 100 -type equal -qtype prefix\n./gen -n 100 -m 100 -type equal -qtype suffix\n./gen -n 1000 -m 1000 -type equal -qtype equal_intervals\n./gen -n 10000 -m 10000 -type random -qtype random\n./gen -n 100000 -m 100000 -type random -qtype random\n./gen -n 200000 -m 200000 -type all_minus_ones -qtype full_range\n./gen -n 200000 -m 200000 -type all_ones -qtype full_range\n./gen -n 200000 -m 200000 -type equal -qtype random\n./gen -n 200000 -m 200000 -type more_ones -qtype random\n./gen -n 200000 -m 200000 -type more_minus_ones -qtype random\n./gen -n 200000 -m 200000 -type random -qtype single_element\n./gen -n 200000 -m 200000 -type random -qtype prefix\n./gen -n 200000 -m 200000 -type random -qtype suffix\n./gen -n 200000 -m 200000 -type random -qtype equal_intervals\n./gen -n 15 -m 25 -type equal -qtype random\n./gen -n 2 -m 1 -type random -qtype single_element\n./gen -n 100 -m 200 -type random -qtype random\n./gen -n 1 -m 1 -type random -qtype random\n./gen -n 2 -m 1 -type random -qtype random\n./gen -n 3 -m 3 -type random -qtype random\n./gen -n 4 -m 6 -type random -qtype random\n./gen -n 100000 -m 100000 -type all_ones -qtype random\n./gen -n 100000 -m 100000 -type all_minus_ones -qtype random\n./gen -n 10 -m 100 -type random -qtype random\n./gen -n 100000 -m 200000 -type random -qtype random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:05:12.571613",
        "total_tutorials": 0,
        "has_ai_judgment": false,
        "has_code_files": true
      }
    },
    {
      "problem_id": "302/B",
      "title": "B. Eugeny and Play List",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains two integers n, m (1 ≤ n, m ≤ 105). The next n lines contain pairs of integers. The i-th line contains integers ci, ti (1 ≤ ci, ti ≤ 109) — the description of the play list. It is guaranteed that the play list's total duration doesn't exceed 109 .The next line contains m positive integers v1, v2, ..., vm, that describe the moments Eugeny has written out. It is guaranteed that there isn't such moment of time vi, when the music doesn't play any longer. It is guaranteed that vi < vi + 1 (i < m).The moment of time vi means that Eugeny wants to know which song was playing during the vi-th munite from the start of listening to the playlist.",
      "output_spec": "OutputPrint m integers — the i-th number must equal the number of the song that was playing during the vi-th minute after Eugeny started listening to the play list.",
      "sample_tests": "ExamplesInputCopy1 22 81 16OutputCopy11InputCopy4 91 22 11 12 21 2 3 4 5 6 7 8 9OutputCopy112234444",
      "description": "B. Eugeny and Play List\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains two integers n, m (1 ≤ n, m ≤ 105). The next n lines contain pairs of integers. The i-th line contains integers ci, ti (1 ≤ ci, ti ≤ 109) — the description of the play list. It is guaranteed that the play list's total duration doesn't exceed 109 .The next line contains m positive integers v1, v2, ..., vm, that describe the moments Eugeny has written out. It is guaranteed that there isn't such moment of time vi, when the music doesn't play any longer. It is guaranteed that vi < vi + 1 (i < m).The moment of time vi means that Eugeny wants to know which song was playing during the vi-th munite from the start of listening to the playlist.\n\nOutputPrint m integers — the i-th number must equal the number of the song that was playing during the vi-th minute after Eugeny started listening to the play list.\n\nInputCopy1 22 81 16OutputCopy11InputCopy4 91 22 11 12 21 2 3 4 5 6 7 8 9OutputCopy112234444\n\nInputCopy1 22 81 16\n\nOutputCopy11\n\nInputCopy4 91 22 11 12 21 2 3 4 5 6 7 8 9\n\nOutputCopy112234444",
      "solutions": [
        {
          "title": "Codeforces Round #182 - Codeforces",
          "content": "Hello everyone!Codeforces Round #182 will take place on Sunday, May 5th at 19:30 MSK. This is my sixth Codeforces round and I hope not the last.I'd like to thank Gerald and sdya for helping me to prepare the round. Special thanks to Delinur for translation of all problem statements into English.I strongly recommend you to read ALL the problems.Gl & hf ! :)Because of technical issue the start of the contest was unsuccessful. Sorry about it. The contest will be UNRATED.Tutorial.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/7557",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 481
        },
        {
          "title": "Codeforces Round #182 tutorial - Codeforces",
          "content": "302A - Eugeny and ArrayIf the length of the given segment is even and count of 1 in input is not lower then half of the length of the segment and count of -1 in the input is not lower then half of the length of the segment so we have answer 1, otherwise 0. 302B - Eugeny and Play ListFor each song we will count moment of time, when it will be over (some sums on the prefixes, for example). Further, we will use binary search of two itaratos method to solve the problem. 301A - Yaroslav and SequenceUsing dfs we will find number of numbers that we can set as positive. Note that we can either set all of the numbers as positive or leave one number(any) as negative. If we can obtain all numbers as positive, we just return sum of modules of the numbers, but if we cannot we will count the same sum and will subtract minimal modular value multiple 2 from sum. 301B - Yaroslav and TimeWe will use binary search to find the answer. Further we will use Ford-Bellman algorithm. On each step we will have an array of maximum values on timer, when we stand in some point. On in transfer we will check: will our player stay alive after travelling beetwen points. If we can make transfer, we will update value of the final destination point. Becouse of a_i<=d and integer coordinates we haven't optimal cycles, and solution exists. 301C - Yaroslav and AlgorithmWe will use ? as iterator. In the begin we will set ? before the number. Then we will move it to the end of the string. Then we will change ? to ?? and we will move it to the begin, while we have 9 before ??. If we have another digit, we just increase it, and finish the algorithm. If we have ?? at the begin, we change it to 1, and end the algorithm. Look for accepted solutions for better understanding. 301D - Yaroslav and DivisorsLets add all pair: (x,y) ((d[x]%d[y]==0) || (d[y]%d[x]==0)) to some lest. We can count such pairs using Eretosphen algorithm. Here will be O(n*log(n)) sych pairs using fact, that we have permutation. We will sort all this paairs using counting-sort. Also we will sort given in input intervals. For each given interval we should count number of pairs that countained in given them . Such problem we can solve using Fenvik tree. On each step we will add segments(that are sorted by right side). On each step we will update Fenfick-tree that count number of added pairs on some suffix. Using such tree if it easy to count the answer. So we have O(n*log^2(n)) solution. 301E - Yaroslav and ArrangementsWe will build the needed arrays sequentially adding numbers. Let's look at what states we need. First, it is obvious that you need to keep the number of ways to build an array of already added numbers, secondly you need to know the total amount of added numbers. Now let's look at what happens when we add a new number (that is greater than all of the previous in a certain amount). It is clear that the added numbers should stand between the numbers 1 to less. In this case, if we put two new numbers in a row, between them should stand more (since we already have placed less). It is obvious that you need to cover all the previous numbers (among which must stand newly added). Thus, we have another state: the number of integers between which we should put the new ones. Thus we have the dynamics of the four parameters: dp [all] [ways] [lastnumber] [counttoadd]. Transfer. It is clear that you need to add at least counttoadd numbers, but how will this affect the number of ways to arrange the numbers? It's simple. Suppose we added number x, then the number of ways to be multiplied by the value of Q (x-counttoadd, counttoadd), where Q (x, y) — the number of ways to assign the same x balls in y different boxes. Q (x, y) = C (x + y-1, y-1) where C (x, y) — binomial coefficient.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/7560",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 302\\s*B"
          },
          "content_length": 3769
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #182 - Codeforces - Code 1",
          "code": "**Server Problem !!!!**",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7557",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #182 - Codeforces - Code 2",
          "code": "**Bad Gateway**",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7557",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #182 - Codeforces - Code 3",
          "code": "-959 -542 -669 -513 160\n-959 -542 669 513 -160\n959 542 669 513 160",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7557",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #182 - Codeforces - Code 4",
          "code": "-959 -542 -669 -513 160\n-959 -542 669 513 -160\n959 542 669 513 160",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7557",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #182 - Codeforces - Code 5",
          "code": "3 1000\n2000\n0 0\n0 1\n0 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7557",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #182 - Codeforces - Code 6",
          "code": "3 1000\n2000\n0 0\n0 1\n0 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7557",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #182 - Codeforces - Code 7",
          "code": "??0>>0??\n??1>>1??\n??2>>2??\n??3>>3??\n??4>>4??\n??5>>5??\n??6>>6??\n??7>>7??\n??8>>8??\n??9>>9??\n??>>?\n0?<>1\n1?<>2\n2?<>3\n3?<>4\n4?<>5\n5?<>6\n6?<>7\n7?<>8\n8?<>9\n9?>>?0\n?<>1\n0>>??0\n1>>??1\n2>>??2\n3>>??3\n4>>??4\n5>>??5\n6>>??6\n7>>??7\n8>>??8\n9>>??9",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7557",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #182 - Codeforces - Code 8",
          "code": "??0>>0??\n??1>>1??\n??2>>2??\n??3>>3??\n??4>>4??\n??5>>5??\n??6>>6??\n??7>>7??\n??8>>8??\n??9>>9??\n??>>?\n0?<>1\n1?<>2\n2?<>3\n3?<>4\n4?<>5\n5?<>6\n6?<>7\n7?<>8\n8?<>9\n9?>>?0\n?<>1\n0>>??0\n1>>??1\n2>>??2\n3>>??3\n4>>??4\n5>>??5\n6>>??6\n7>>??7\n8>>??8\n9>>??9",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7557",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #182 - Codeforces - Code 9",
          "code": "98\n.7\n.6\n.5\n.4\n.3\n12",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7557",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #182 - Codeforces - Code 10",
          "code": "98\n.7\n.6\n.5\n.4\n.3\n12",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7557",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #182 tutorial - Codeforces - Code 1",
          "code": "for (int a = 1; a <= n; a++)\n    for (int b = a; b <= n; b += a)\n        remember_pair(a, b);// b % a == 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7560",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #182 tutorial - Codeforces - Code 2",
          "code": "for (int a = 1; a <= n; a++)\n    for (int b = a; b <= n; b += a)\n        remember_pair(a, b);// b % a == 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7560",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #182 tutorial - Codeforces - Code 3",
          "code": "ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    cin.tie(0);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7560",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #182 tutorial - Codeforces - Code 4",
          "code": "ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    cin.tie(0);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7560",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #182 tutorial - Codeforces - Code 5",
          "code": "3 1\n1000\n0 0\n0 100\n0 101",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7560",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #182 tutorial - Codeforces - Code 6",
          "code": "3 1\n1000\n0 0\n0 100\n0 101",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7560",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    \n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 100000, \"m\");\n    inf.readEoln();\n\n    long long total_duration = 0;\n\n    for (int i = 1; i <= n; i++) {\n        int ci = inf.readInt(1, 1000000000);\n        inf.readSpace();\n        int ti = inf.readInt(1, 1000000000);\n        inf.readEoln();\n\n        total_duration += (long long)ci * ti;\n    }\n\n    ensuref(total_duration <= 1000000000LL, \"Total duration %lld exceeds 1e9\", total_duration);\n\n    vector<long long> v = inf.readLongs(m, 1LL, total_duration);\n    inf.readEoln();\n\n    for (int i = 1; i < m; i++) {\n        ensuref(v[i-1] < v[i], \"v[%d]=%lld is not less than v[%d]=%lld\", i, v[i-1], i+1, v[i]);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    \n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 100000, \"m\");\n    inf.readEoln();\n\n    long long total_duration = 0;\n\n    for (int i = 1; i <= n; i++) {\n        int ci = inf.readInt(1, 1000000000);\n        inf.readSpace();\n        int ti = inf.readInt(1, 1000000000);\n        inf.readEoln();\n\n        total_duration += (long long)ci * ti;\n    }\n\n    ensuref(total_duration <= 1000000000LL, \"Total duration %lld exceeds 1e9\", total_duration);\n\n    vector<long long> v = inf.readLongs(m, 1LL, total_duration);\n    inf.readEoln();\n\n    for (int i = 1; i < m; i++) {\n        ensuref(v[i-1] < v[i], \"v[%d]=%lld is not less than v[%d]=%lld\", i, v[i-1], i+1, v[i]);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    \n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 100000, \"m\");\n    inf.readEoln();\n\n    long long total_duration = 0;\n\n    for (int i = 1; i <= n; i++) {\n        int ci = inf.readInt(1, 1000000000);\n        inf.readSpace();\n        int ti = inf.readInt(1, 1000000000);\n        inf.readEoln();\n\n        total_duration += (long long)ci * ti;\n    }\n\n    ensuref(total_duration <= 1000000000LL, \"Total duration %lld exceeds 1e9\", total_duration);\n\n    vector<long long> v = inf.readLongs(m, 1LL, total_duration);\n    inf.readEoln();\n\n    for (int i = 1; i < m; i++) {\n        ensuref(v[i-1] < v[i], \"v[%d]=%lld is not less than v[%d]=%lld\", i, v[i-1], i+1, v[i]);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\n// Constants\ntypedef long long ll;\nconst ll MAX_TOTAL_DURATION = 1000000000LL;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    int n = opt<int>(\"n\", 1);\n    int m = opt<int>(\"m\", 1);\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> c;\n    vector<int> t;\n    ll total_duration = 0;\n    ll total_duration_limit = MAX_TOTAL_DURATION;\n\n    if (type == \"minimal\") {\n        // Minimal test case\n        n = 1;\n        m = 1;\n        c.push_back(1);\n        t.push_back(1);\n        total_duration = 1 * 1;\n    } else if (type == \"max_c_all_1\") {\n        // All c_i = 1, t_i varies\n        c.resize(n, 1);\n        ll remaining_duration = MAX_TOTAL_DURATION;\n        for (int i = 0; i < n; ++i) {\n            if (remaining_duration <= 0) {\n                n = i;\n                c.resize(n);\n                break;\n            }\n            ll max_ti = min(remaining_duration / (n - i), 1000000000LL);\n            if (max_ti <= 0) max_ti = 1;\n            ll t_i = rnd.next(1LL, max_ti);\n            t.push_back((int)t_i);\n            remaining_duration -= t_i;\n            total_duration += t_i;\n        }\n    } else if (type == \"max_t_all_1\") {\n        // All t_i = 1, c_i varies\n        t.resize(n, 1);\n        ll remaining_duration = MAX_TOTAL_DURATION;\n        for (int i = 0; i < n; ++i) {\n            if (remaining_duration <= 0) {\n                n = i;\n                t.resize(n);\n                break;\n            }\n            ll max_ci = min(remaining_duration / (n - i), 1000000000LL);\n            if (max_ci <= 0) max_ci = 1;\n            ll c_i = rnd.next(1LL, max_ci);\n            c.push_back((int)c_i);\n            remaining_duration -= c_i;\n            total_duration += c_i;\n        }\n    } else if (type == \"small_n_large_c_t\") {\n        // Small n, large c_i and t_i\n        n = min(n, 10);\n        for (int i = 0; i < n; ++i) {\n            ll remaining_duration = total_duration_limit - total_duration;\n            if (remaining_duration <= 0) break;\n            ll max_ct = min(remaining_duration, 1000000000LL * 1000000000LL);\n            ll c_i = rnd.next(1LL, 1000000000LL);\n            ll t_i = min(remaining_duration / c_i, 1000000000LL);\n            if (t_i < 1) t_i = 1;\n            c.push_back((int)c_i);\n            t.push_back((int)t_i);\n            total_duration += c_i * t_i;\n        }\n        n = c.size();\n    } else if (type == \"large_n_small_c_t\") {\n        // Large n, small c_i and t_i\n        for (int i = 0; i < n; ++i) {\n            ll remaining_duration = total_duration_limit - total_duration;\n            if (remaining_duration <= 0) {\n                n = i;\n                break;\n            }\n            c.push_back(1);\n            t.push_back(1);\n            total_duration += 1 * 1;\n        }\n    } else if (type == \"queries_at_end\") {\n        // Queries near the end of the playlist\n        c.resize(n, 1);\n        ll remaining_duration = MAX_TOTAL_DURATION;\n        for (int i = 0; i < n; ++i) {\n            if (remaining_duration <= 0) {\n                n = i;\n                c.resize(n);\n                break;\n            }\n            ll max_ti = min(remaining_duration / (n - i), 1000000000LL);\n            if (max_ti <= 0) max_ti = 1;\n            ll t_i = rnd.next(1LL, max_ti);\n            t.push_back((int)t_i);\n            remaining_duration -= t_i;\n            total_duration += t_i;\n        }\n    } else { // default to random\n        // Random c_i and t_i\n        for (int i = 0; i < n; ++i) {\n            ll remaining_duration = total_duration_limit - total_duration;\n            if (remaining_duration <= 0) {\n                n = i;\n                break;\n            }\n            ll max_ci = min(1000000000LL, remaining_duration / 1);\n            if (max_ci < 1) max_ci = 1;\n            ll c_i = rnd.next(1LL, max_ci);\n            ll max_ti = min(1000000000LL, remaining_duration / c_i);\n            if (max_ti < 1) max_ti = 1;\n            ll t_i = rnd.next(1LL, max_ti);\n            c.push_back((int)c_i);\n            t.push_back((int)t_i);\n            total_duration += c_i * t_i;\n        }\n    }\n\n    if (n == 0 || total_duration == 0) {\n        // Ensure there is at least one song and total duration is positive\n        printf(\"1 1\\n1 1\\n1\\n\");\n        return 0;\n    }\n\n    // Generate m moments v_i in increasing order\n    vector<ll> v;\n    if (type == \"queries_at_end\") {\n        for (int i = 0; i < m; ++i) {\n            ll min_v = max(1LL, total_duration - m - 10);\n            ll v_i = rnd.next(min_v, total_duration);\n            v.push_back(v_i);\n        }\n    } else {\n        for (int i = 0; i < m; ++i) {\n            ll v_i = rnd.next(1LL, total_duration);\n            v.push_back(v_i);\n        }\n    }\n    sort(v.begin(), v.end());\n    // Ensure v_i < v_{i+1}\n    for (int i = 1; i < m; ++i) {\n        if (v[i] == v[i - 1]) {\n            if (v[i] + 1 <= total_duration) {\n                v[i] += 1;\n            }\n        }\n    }\n\n    // Output the data\n    printf(\"%d %d\\n\", n, m);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d %d\\n\", c[i], t[i]);\n    }\n    for (int i = 0; i < m; ++i) {\n        printf(\"%lld\", v[i]);\n        if (i < m -1) printf(\" \");\n    }\n    printf(\"\\n\");\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\n// Constants\ntypedef long long ll;\nconst ll MAX_TOTAL_DURATION = 1000000000LL;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    int n = opt<int>(\"n\", 1);\n    int m = opt<int>(\"m\", 1);\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> c;\n    vector<int> t;\n    ll total_duration = 0;\n    ll total_duration_limit = MAX_TOTAL_DURATION;\n\n    if (type == \"minimal\") {\n        // Minimal test case\n        n = 1;\n        m = 1;\n        c.push_back(1);\n        t.push_back(1);\n        total_duration = 1 * 1;\n    } else if (type == \"max_c_all_1\") {\n        // All c_i = 1, t_i varies\n        c.resize(n, 1);\n        ll remaining_duration = MAX_TOTAL_DURATION;\n        for (int i = 0; i < n; ++i) {\n            if (remaining_duration <= 0) {\n                n = i;\n                c.resize(n);\n                break;\n            }\n            ll max_ti = min(remaining_duration / (n - i), 1000000000LL);\n            if (max_ti <= 0) max_ti = 1;\n            ll t_i = rnd.next(1LL, max_ti);\n            t.push_back((int)t_i);\n            remaining_duration -= t_i;\n            total_duration += t_i;\n        }\n    } else if (type == \"max_t_all_1\") {\n        // All t_i = 1, c_i varies\n        t.resize(n, 1);\n        ll remaining_duration = MAX_TOTAL_DURATION;\n        for (int i = 0; i < n; ++i) {\n            if (remaining_duration <= 0) {\n                n = i;\n                t.resize(n);\n                break;\n            }\n            ll max_ci = min(remaining_duration / (n - i), 1000000000LL);\n            if (max_ci <= 0) max_ci = 1;\n            ll c_i = rnd.next(1LL, max_ci);\n            c.push_back((int)c_i);\n            remaining_duration -= c_i;\n            total_duration += c_i;\n        }\n    } else if (type == \"small_n_large_c_t\") {\n        // Small n, large c_i and t_i\n        n = min(n, 10);\n        for (int i = 0; i < n; ++i) {\n            ll remaining_duration = total_duration_limit - total_duration;\n            if (remaining_duration <= 0) break;\n            ll max_ct = min(remaining_duration, 1000000000LL * 1000000000LL);\n            ll c_i = rnd.next(1LL, 1000000000LL);\n            ll t_i = min(remaining_duration / c_i, 1000000000LL);\n            if (t_i < 1) t_i = 1;\n            c.push_back((int)c_i);\n            t.push_back((int)t_i);\n            total_duration += c_i * t_i;\n        }\n        n = c.size();\n    } else if (type == \"large_n_small_c_t\") {\n        // Large n, small c_i and t_i\n        for (int i = 0; i < n; ++i) {\n            ll remaining_duration = total_duration_limit - total_duration;\n            if (remaining_duration <= 0) {\n                n = i;\n                break;\n            }\n            c.push_back(1);\n            t.push_back(1);\n            total_duration += 1 * 1;\n        }\n    } else if (type == \"queries_at_end\") {\n        // Queries near the end of the playlist\n        c.resize(n, 1);\n        ll remaining_duration = MAX_TOTAL_DURATION;\n        for (int i = 0; i < n; ++i) {\n            if (remaining_duration <= 0) {\n                n = i;\n                c.resize(n);\n                break;\n            }\n            ll max_ti = min(remaining_duration / (n - i), 1000000000LL);\n            if (max_ti <= 0) max_ti = 1;\n            ll t_i = rnd.next(1LL, max_ti);\n            t.push_back((int)t_i);\n            remaining_duration -= t_i;\n            total_duration += t_i;\n        }\n    } else { // default to random\n        // Random c_i and t_i\n        for (int i = 0; i < n; ++i) {\n            ll remaining_duration = total_duration_limit - total_duration;\n            if (remaining_duration <= 0) {\n                n = i;\n                break;\n            }\n            ll max_ci = min(1000000000LL, remaining_duration / 1);\n            if (max_ci < 1) max_ci = 1;\n            ll c_i = rnd.next(1LL, max_ci);\n            ll max_ti = min(1000000000LL, remaining_duration / c_i);\n            if (max_ti < 1) max_ti = 1;\n            ll t_i = rnd.next(1LL, max_ti);\n            c.push_back((int)c_i);\n            t.push_back((int)t_i);\n            total_duration += c_i * t_i;\n        }\n    }\n\n    if (n == 0 || total_duration == 0) {\n        // Ensure there is at least one song and total duration is positive\n        printf(\"1 1\\n1 1\\n1\\n\");\n        return 0;\n    }\n\n    // Generate m moments v_i in increasing order\n    vector<ll> v;\n    if (type == \"queries_at_end\") {\n        for (int i = 0; i < m; ++i) {\n            ll min_v = max(1LL, total_duration - m - 10);\n            ll v_i = rnd.next(min_v, total_duration);\n            v.push_back(v_i);\n        }\n    } else {\n        for (int i = 0; i < m; ++i) {\n            ll v_i = rnd.next(1LL, total_duration);\n            v.push_back(v_i);\n        }\n    }\n    sort(v.begin(), v.end());\n    // Ensure v_i < v_{i+1}\n    for (int i = 1; i < m; ++i) {\n        if (v[i] == v[i - 1]) {\n            if (v[i] + 1 <= total_duration) {\n                v[i] += 1;\n            }\n        }\n    }\n\n    // Output the data\n    printf(\"%d %d\\n\", n, m);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d %d\\n\", c[i], t[i]);\n    }\n    for (int i = 0; i < m; ++i) {\n        printf(\"%lld\", v[i]);\n        if (i < m -1) printf(\" \");\n    }\n    printf(\"\\n\");\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -type minimal\n\n./gen -n 1 -m 1 -type random\n./gen -n 10 -m 10 -type random\n./gen -n 100 -m 100 -type random\n./gen -n 1000 -m 1000 -type random\n./gen -n 10000 -m 10000 -type random\n./gen -n 100000 -m 100000 -type random\n\n./gen -n 1 -m 1 -type max_c_all_1\n./gen -n 10 -m 10 -type max_c_all_1\n./gen -n 100 -m 100 -type max_c_all_1\n./gen -n 1000 -m 1000 -type max_c_all_1\n./gen -n 10000 -m 10000 -type max_c_all_1\n./gen -n 100000 -m 100000 -type max_c_all_1\n\n./gen -n 1 -m 1 -type max_t_all_1\n./gen -n 10 -m 10 -type max_t_all_1\n./gen -n 100 -m 100 -type max_t_all_1\n./gen -n 1000 -m 1000 -type max_t_all_1\n./gen -n 10000 -m 10000 -type max_t_all_1\n./gen -n 100000 -m 100000 -type max_t_all_1\n\n./gen -n 5 -m 100000 -type small_n_large_c_t\n./gen -n 10 -m 100000 -type small_n_large_c_t\n\n./gen -n 100000 -m 100000 -type large_n_small_c_t\n\n./gen -n 100000 -m 100000 -type queries_at_end\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:05:14.745820",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "302/C",
      "title": "C. Yaroslav and Sequence",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains an integer n (2 ≤ n ≤ 100). The second line contains (2·n - 1) integers — the array elements. The array elements do not exceed 1000 in their absolute value.",
      "output_spec": "OutputIn a single line print the answer to the problem — the maximum sum that Yaroslav can get.",
      "sample_tests": "ExamplesInputCopy250 50 50OutputCopy150InputCopy2-1 -100 -1OutputCopy100",
      "description": "C. Yaroslav and Sequence\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains an integer n (2 ≤ n ≤ 100). The second line contains (2·n - 1) integers — the array elements. The array elements do not exceed 1000 in their absolute value.\n\nOutputIn a single line print the answer to the problem — the maximum sum that Yaroslav can get.\n\nInputCopy250 50 50OutputCopy150InputCopy2-1 -100 -1OutputCopy100\n\nInputCopy250 50 50\n\nOutputCopy150\n\nInputCopy2-1 -100 -1\n\nOutputCopy100\n\nNoteIn the first sample you do not need to change anything. The sum of elements equals 150.In the second sample you need to change the sign of the first two elements. Then we get the sum of the elements equal to 100.",
      "solutions": [
        {
          "title": "Codeforces Round #182 - Codeforces",
          "content": "Hello everyone!Codeforces Round #182 will take place on Sunday, May 5th at 19:30 MSK. This is my sixth Codeforces round and I hope not the last.I'd like to thank Gerald and sdya for helping me to prepare the round. Special thanks to Delinur for translation of all problem statements into English.I strongly recommend you to read ALL the problems.Gl & hf ! :)Because of technical issue the start of the contest was unsuccessful. Sorry about it. The contest will be UNRATED.Tutorial.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/7557",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 481
        },
        {
          "title": "Codeforces Round #182 tutorial - Codeforces",
          "content": "302A - Eugeny and ArrayIf the length of the given segment is even and count of 1 in input is not lower then half of the length of the segment and count of -1 in the input is not lower then half of the length of the segment so we have answer 1, otherwise 0. 302B - Eugeny and Play ListFor each song we will count moment of time, when it will be over (some sums on the prefixes, for example). Further, we will use binary search of two itaratos method to solve the problem. 301A - Yaroslav and SequenceUsing dfs we will find number of numbers that we can set as positive. Note that we can either set all of the numbers as positive or leave one number(any) as negative. If we can obtain all numbers as positive, we just return sum of modules of the numbers, but if we cannot we will count the same sum and will subtract minimal modular value multiple 2 from sum. 301B - Yaroslav and TimeWe will use binary search to find the answer. Further we will use Ford-Bellman algorithm. On each step we will have an array of maximum values on timer, when we stand in some point. On in transfer we will check: will our player stay alive after travelling beetwen points. If we can make transfer, we will update value of the final destination point. Becouse of a_i<=d and integer coordinates we haven't optimal cycles, and solution exists. 301C - Yaroslav and AlgorithmWe will use ? as iterator. In the begin we will set ? before the number. Then we will move it to the end of the string. Then we will change ? to ?? and we will move it to the begin, while we have 9 before ??. If we have another digit, we just increase it, and finish the algorithm. If we have ?? at the begin, we change it to 1, and end the algorithm. Look for accepted solutions for better understanding. 301D - Yaroslav and DivisorsLets add all pair: (x,y) ((d[x]%d[y]==0) || (d[y]%d[x]==0)) to some lest. We can count such pairs using Eretosphen algorithm. Here will be O(n*log(n)) sych pairs using fact, that we have permutation. We will sort all this paairs using counting-sort. Also we will sort given in input intervals. For each given interval we should count number of pairs that countained in given them . Such problem we can solve using Fenvik tree. On each step we will add segments(that are sorted by right side). On each step we will update Fenfick-tree that count number of added pairs on some suffix. Using such tree if it easy to count the answer. So we have O(n*log^2(n)) solution. 301E - Yaroslav and ArrangementsWe will build the needed arrays sequentially adding numbers. Let's look at what states we need. First, it is obvious that you need to keep the number of ways to build an array of already added numbers, secondly you need to know the total amount of added numbers. Now let's look at what happens when we add a new number (that is greater than all of the previous in a certain amount). It is clear that the added numbers should stand between the numbers 1 to less. In this case, if we put two new numbers in a row, between them should stand more (since we already have placed less). It is obvious that you need to cover all the previous numbers (among which must stand newly added). Thus, we have another state: the number of integers between which we should put the new ones. Thus we have the dynamics of the four parameters: dp [all] [ways] [lastnumber] [counttoadd]. Transfer. It is clear that you need to add at least counttoadd numbers, but how will this affect the number of ways to arrange the numbers? It's simple. Suppose we added number x, then the number of ways to be multiplied by the value of Q (x-counttoadd, counttoadd), where Q (x, y) — the number of ways to assign the same x balls in y different boxes. Q (x, y) = C (x + y-1, y-1) where C (x, y) — binomial coefficient.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/7560",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.6,
            "reason": "宽松匹配: 包含题目编号 302 和字母"
          },
          "content_length": 3769
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #182 - Codeforces - Code 1",
          "code": "**Server Problem !!!!**",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7557",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #182 - Codeforces - Code 2",
          "code": "**Bad Gateway**",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7557",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #182 - Codeforces - Code 3",
          "code": "-959 -542 -669 -513 160\n-959 -542 669 513 -160\n959 542 669 513 160",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7557",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #182 - Codeforces - Code 4",
          "code": "-959 -542 -669 -513 160\n-959 -542 669 513 -160\n959 542 669 513 160",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7557",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #182 - Codeforces - Code 5",
          "code": "3 1000\n2000\n0 0\n0 1\n0 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7557",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #182 - Codeforces - Code 6",
          "code": "3 1000\n2000\n0 0\n0 1\n0 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7557",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #182 - Codeforces - Code 7",
          "code": "??0>>0??\n??1>>1??\n??2>>2??\n??3>>3??\n??4>>4??\n??5>>5??\n??6>>6??\n??7>>7??\n??8>>8??\n??9>>9??\n??>>?\n0?<>1\n1?<>2\n2?<>3\n3?<>4\n4?<>5\n5?<>6\n6?<>7\n7?<>8\n8?<>9\n9?>>?0\n?<>1\n0>>??0\n1>>??1\n2>>??2\n3>>??3\n4>>??4\n5>>??5\n6>>??6\n7>>??7\n8>>??8\n9>>??9",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7557",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #182 - Codeforces - Code 8",
          "code": "??0>>0??\n??1>>1??\n??2>>2??\n??3>>3??\n??4>>4??\n??5>>5??\n??6>>6??\n??7>>7??\n??8>>8??\n??9>>9??\n??>>?\n0?<>1\n1?<>2\n2?<>3\n3?<>4\n4?<>5\n5?<>6\n6?<>7\n7?<>8\n8?<>9\n9?>>?0\n?<>1\n0>>??0\n1>>??1\n2>>??2\n3>>??3\n4>>??4\n5>>??5\n6>>??6\n7>>??7\n8>>??8\n9>>??9",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7557",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #182 - Codeforces - Code 9",
          "code": "98\n.7\n.6\n.5\n.4\n.3\n12",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7557",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #182 - Codeforces - Code 10",
          "code": "98\n.7\n.6\n.5\n.4\n.3\n12",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7557",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #182 tutorial - Codeforces - Code 1",
          "code": "for (int a = 1; a <= n; a++)\n    for (int b = a; b <= n; b += a)\n        remember_pair(a, b);// b % a == 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7560",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #182 tutorial - Codeforces - Code 2",
          "code": "for (int a = 1; a <= n; a++)\n    for (int b = a; b <= n; b += a)\n        remember_pair(a, b);// b % a == 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7560",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #182 tutorial - Codeforces - Code 3",
          "code": "ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    cin.tie(0);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7560",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #182 tutorial - Codeforces - Code 4",
          "code": "ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    cin.tie(0);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7560",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #182 tutorial - Codeforces - Code 5",
          "code": "3 1\n1000\n0 0\n0 100\n0 101",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7560",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #182 tutorial - Codeforces - Code 6",
          "code": "3 1\n1000\n0 0\n0 100\n0 101",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7560",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(2, 100, \"n\");\n    inf.readEoln();\n    \n    vector<int> a = inf.readInts(2 * n - 1, -1000, 1000, \"a\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(2, 100, \"n\");\n    inf.readEoln();\n    \n    vector<int> a = inf.readInts(2 * n - 1, -1000, 1000, \"a\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(2, 100, \"n\");\n    inf.readEoln();\n    \n    vector<int> a = inf.readInts(2 * n - 1, -1000, 1000, \"a\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\");\n\n    printf(\"%d\\n\", n);\n\n    vector<int> arr(2 * n - 1);\n\n    if (type == \"all_positive\") {\n        /* Generate all positive numbers */\n        for (int i = 0; i < 2 * n - 1; ++i) {\n            arr[i] = rnd.next(1, 1000);\n        }\n    } else if (type == \"all_negative\") {\n        /* Generate all negative numbers */\n        for (int i = 0; i < 2 * n - 1; ++i) {\n            arr[i] = -rnd.next(1, 1000);\n        }\n    } else if (type == \"zeros\") {\n        /* Generate all zeros */\n        for (int i = 0; i < 2 * n - 1; ++i) {\n            arr[i] = 0;\n        }\n    } else if (type == \"max_values\") {\n        /* Generate numbers with maximum absolute values */\n        for (int i = 0; i < 2 * n - 1; ++i) {\n            arr[i] = (rnd.next(0, 1) ? 1000 : -1000);\n        }\n    } else if (type == \"needs_flipping\") {\n        /* Generate an array where flipping negatives increases the sum */\n        int num_negatives = rnd.next(1, n - 1);\n        int num_positives = 2 * n - 1 - num_negatives;\n\n        vector<int> negatives(num_negatives);\n        vector<int> positives(num_positives);\n\n        for (int i = 0; i < num_negatives; ++i) {\n            negatives[i] = -rnd.next(1, 1000);\n        }\n        for (int i = 0; i < num_positives; ++i) {\n            positives[i] = rnd.next(1, 1000);\n        }\n\n        /* Combine negatives and positives */\n        arr = negatives;\n        arr.insert(arr.end(), positives.begin(), positives.end());\n\n        /* Shuffle the array */\n        shuffle(arr.begin(), arr.end());\n    } else if (type == \"tricky\") {\n        /* Generate a tricky test case */\n        for (int i = 0; i < 2 * n - 1; ++i) {\n            if (i % 2 == 0)\n                arr[i] = -rnd.next(1, 1000);\n            else\n                arr[i] = rnd.next(1, 1000);\n        }\n        /* Shuffle the array */\n        shuffle(arr.begin(), arr.end());\n    } else {\n        /* Default to random values within constraints */\n        for (int i = 0; i < 2 * n - 1; ++i) {\n            arr[i] = rnd.next(-1000, 1000);\n        }\n    }\n\n    /* Output the array */\n    for (int i = 0; i < 2 * n - 1; ++i) {\n        printf(\"%d\", arr[i]);\n        if (i + 1 < 2 * n - 1) printf(\" \");\n    }\n    printf(\"\\n\");\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\");\n\n    printf(\"%d\\n\", n);\n\n    vector<int> arr(2 * n - 1);\n\n    if (type == \"all_positive\") {\n        /* Generate all positive numbers */\n        for (int i = 0; i < 2 * n - 1; ++i) {\n            arr[i] = rnd.next(1, 1000);\n        }\n    } else if (type == \"all_negative\") {\n        /* Generate all negative numbers */\n        for (int i = 0; i < 2 * n - 1; ++i) {\n            arr[i] = -rnd.next(1, 1000);\n        }\n    } else if (type == \"zeros\") {\n        /* Generate all zeros */\n        for (int i = 0; i < 2 * n - 1; ++i) {\n            arr[i] = 0;\n        }\n    } else if (type == \"max_values\") {\n        /* Generate numbers with maximum absolute values */\n        for (int i = 0; i < 2 * n - 1; ++i) {\n            arr[i] = (rnd.next(0, 1) ? 1000 : -1000);\n        }\n    } else if (type == \"needs_flipping\") {\n        /* Generate an array where flipping negatives increases the sum */\n        int num_negatives = rnd.next(1, n - 1);\n        int num_positives = 2 * n - 1 - num_negatives;\n\n        vector<int> negatives(num_negatives);\n        vector<int> positives(num_positives);\n\n        for (int i = 0; i < num_negatives; ++i) {\n            negatives[i] = -rnd.next(1, 1000);\n        }\n        for (int i = 0; i < num_positives; ++i) {\n            positives[i] = rnd.next(1, 1000);\n        }\n\n        /* Combine negatives and positives */\n        arr = negatives;\n        arr.insert(arr.end(), positives.begin(), positives.end());\n\n        /* Shuffle the array */\n        shuffle(arr.begin(), arr.end());\n    } else if (type == \"tricky\") {\n        /* Generate a tricky test case */\n        for (int i = 0; i < 2 * n - 1; ++i) {\n            if (i % 2 == 0)\n                arr[i] = -rnd.next(1, 1000);\n            else\n                arr[i] = rnd.next(1, 1000);\n        }\n        /* Shuffle the array */\n        shuffle(arr.begin(), arr.end());\n    } else {\n        /* Default to random values within constraints */\n        for (int i = 0; i < 2 * n - 1; ++i) {\n            arr[i] = rnd.next(-1000, 1000);\n        }\n    }\n\n    /* Output the array */\n    for (int i = 0; i < 2 * n - 1; ++i) {\n        printf(\"%d\", arr[i]);\n        if (i + 1 < 2 * n - 1) printf(\" \");\n    }\n    printf(\"\\n\");\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 2 -type all_positive\n./gen -n 2 -type all_negative\n./gen -n 2 -type zeros\n./gen -n 2 -type max_values\n./gen -n 2 -type needs_flipping\n./gen -n 2 -type tricky\n./gen -n 2 -type random\n\n./gen -n 5 -type all_positive\n./gen -n 5 -type all_negative\n./gen -n 5 -type zeros\n./gen -n 5 -type max_values\n./gen -n 5 -type needs_flipping\n./gen -n 5 -type tricky\n./gen -n 5 -type random\n\n./gen -n 10 -type all_positive\n./gen -n 10 -type all_negative\n./gen -n 10 -type zeros\n./gen -n 10 -type max_values\n./gen -n 10 -type needs_flipping\n./gen -n 10 -type tricky\n./gen -n 10 -type random\n\n./gen -n 50 -type all_positive\n./gen -n 50 -type all_negative\n./gen -n 50 -type zeros\n./gen -n 50 -type max_values\n./gen -n 50 -type needs_flipping\n./gen -n 50 -type tricky\n./gen -n 50 -type random\n\n./gen -n 100 -type all_positive\n./gen -n 100 -type all_negative\n./gen -n 100 -type zeros\n./gen -n 100 -type max_values\n./gen -n 100 -type needs_flipping\n./gen -n 100 -type tricky\n./gen -n 100 -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:05:16.751204",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "302/D",
      "title": "D. Yaroslav and Time",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains integers n and d (3 ≤ n ≤ 100, 103 ≤ d ≤ 105) — the number of stations and the constant from the statement.The second line contains n - 2 integers: a2, a3, ..., an - 1 (1 ≤ ai ≤ 103). The next n lines contain the coordinates of the stations. The i-th of them contains two integers xi, yi (-100 ≤ xi, yi ≤ 100).It is guaranteed that no two stations are located at the same point.",
      "output_spec": "OutputIn a single line print an integer — the answer to the problem.",
      "sample_tests": "ExamplesInputCopy3 100010000 00 10 3OutputCopy2000InputCopy3 100010001 01 11 2OutputCopy1000",
      "description": "D. Yaroslav and Time\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains integers n and d (3 ≤ n ≤ 100, 103 ≤ d ≤ 105) — the number of stations and the constant from the statement.The second line contains n - 2 integers: a2, a3, ..., an - 1 (1 ≤ ai ≤ 103). The next n lines contain the coordinates of the stations. The i-th of them contains two integers xi, yi (-100 ≤ xi, yi ≤ 100).It is guaranteed that no two stations are located at the same point.\n\nOutputIn a single line print an integer — the answer to the problem.\n\nInputCopy3 100010000 00 10 3OutputCopy2000InputCopy3 100010001 01 11 2OutputCopy1000\n\nInputCopy3 100010000 00 10 3\n\nOutputCopy2000\n\nInputCopy3 100010001 01 11 2\n\nOutputCopy1000",
      "solutions": [
        {
          "title": "Codeforces Round #182 - Codeforces",
          "content": "Hello everyone!Codeforces Round #182 will take place on Sunday, May 5th at 19:30 MSK. This is my sixth Codeforces round and I hope not the last.I'd like to thank Gerald and sdya for helping me to prepare the round. Special thanks to Delinur for translation of all problem statements into English.I strongly recommend you to read ALL the problems.Gl & hf ! :)Because of technical issue the start of the contest was unsuccessful. Sorry about it. The contest will be UNRATED.Tutorial.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/7557",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 481
        },
        {
          "title": "Codeforces Round #182 tutorial - Codeforces",
          "content": "302A - Eugeny and ArrayIf the length of the given segment is even and count of 1 in input is not lower then half of the length of the segment and count of -1 in the input is not lower then half of the length of the segment so we have answer 1, otherwise 0. 302B - Eugeny and Play ListFor each song we will count moment of time, when it will be over (some sums on the prefixes, for example). Further, we will use binary search of two itaratos method to solve the problem. 301A - Yaroslav and SequenceUsing dfs we will find number of numbers that we can set as positive. Note that we can either set all of the numbers as positive or leave one number(any) as negative. If we can obtain all numbers as positive, we just return sum of modules of the numbers, but if we cannot we will count the same sum and will subtract minimal modular value multiple 2 from sum. 301B - Yaroslav and TimeWe will use binary search to find the answer. Further we will use Ford-Bellman algorithm. On each step we will have an array of maximum values on timer, when we stand in some point. On in transfer we will check: will our player stay alive after travelling beetwen points. If we can make transfer, we will update value of the final destination point. Becouse of a_i<=d and integer coordinates we haven't optimal cycles, and solution exists. 301C - Yaroslav and AlgorithmWe will use ? as iterator. In the begin we will set ? before the number. Then we will move it to the end of the string. Then we will change ? to ?? and we will move it to the begin, while we have 9 before ??. If we have another digit, we just increase it, and finish the algorithm. If we have ?? at the begin, we change it to 1, and end the algorithm. Look for accepted solutions for better understanding. 301D - Yaroslav and DivisorsLets add all pair: (x,y) ((d[x]%d[y]==0) || (d[y]%d[x]==0)) to some lest. We can count such pairs using Eretosphen algorithm. Here will be O(n*log(n)) sych pairs using fact, that we have permutation. We will sort all this paairs using counting-sort. Also we will sort given in input intervals. For each given interval we should count number of pairs that countained in given them . Such problem we can solve using Fenvik tree. On each step we will add segments(that are sorted by right side). On each step we will update Fenfick-tree that count number of added pairs on some suffix. Using such tree if it easy to count the answer. So we have O(n*log^2(n)) solution. 301E - Yaroslav and ArrangementsWe will build the needed arrays sequentially adding numbers. Let's look at what states we need. First, it is obvious that you need to keep the number of ways to build an array of already added numbers, secondly you need to know the total amount of added numbers. Now let's look at what happens when we add a new number (that is greater than all of the previous in a certain amount). It is clear that the added numbers should stand between the numbers 1 to less. In this case, if we put two new numbers in a row, between them should stand more (since we already have placed less). It is obvious that you need to cover all the previous numbers (among which must stand newly added). Thus, we have another state: the number of integers between which we should put the new ones. Thus we have the dynamics of the four parameters: dp [all] [ways] [lastnumber] [counttoadd]. Transfer. It is clear that you need to add at least counttoadd numbers, but how will this affect the number of ways to arrange the numbers? It's simple. Suppose we added number x, then the number of ways to be multiplied by the value of Q (x-counttoadd, counttoadd), where Q (x, y) — the number of ways to assign the same x balls in y different boxes. Q (x, y) = C (x + y-1, y-1) where C (x, y) — binomial coefficient.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/7560",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.6,
            "reason": "宽松匹配: 包含题目编号 302 和字母"
          },
          "content_length": 3769
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #182 - Codeforces - Code 1",
          "code": "**Server Problem !!!!**",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7557",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #182 - Codeforces - Code 2",
          "code": "**Bad Gateway**",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7557",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #182 - Codeforces - Code 3",
          "code": "-959 -542 -669 -513 160\n-959 -542 669 513 -160\n959 542 669 513 160",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7557",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #182 - Codeforces - Code 4",
          "code": "-959 -542 -669 -513 160\n-959 -542 669 513 -160\n959 542 669 513 160",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7557",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #182 - Codeforces - Code 5",
          "code": "3 1000\n2000\n0 0\n0 1\n0 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7557",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #182 - Codeforces - Code 6",
          "code": "3 1000\n2000\n0 0\n0 1\n0 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7557",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #182 - Codeforces - Code 7",
          "code": "??0>>0??\n??1>>1??\n??2>>2??\n??3>>3??\n??4>>4??\n??5>>5??\n??6>>6??\n??7>>7??\n??8>>8??\n??9>>9??\n??>>?\n0?<>1\n1?<>2\n2?<>3\n3?<>4\n4?<>5\n5?<>6\n6?<>7\n7?<>8\n8?<>9\n9?>>?0\n?<>1\n0>>??0\n1>>??1\n2>>??2\n3>>??3\n4>>??4\n5>>??5\n6>>??6\n7>>??7\n8>>??8\n9>>??9",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7557",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #182 - Codeforces - Code 8",
          "code": "??0>>0??\n??1>>1??\n??2>>2??\n??3>>3??\n??4>>4??\n??5>>5??\n??6>>6??\n??7>>7??\n??8>>8??\n??9>>9??\n??>>?\n0?<>1\n1?<>2\n2?<>3\n3?<>4\n4?<>5\n5?<>6\n6?<>7\n7?<>8\n8?<>9\n9?>>?0\n?<>1\n0>>??0\n1>>??1\n2>>??2\n3>>??3\n4>>??4\n5>>??5\n6>>??6\n7>>??7\n8>>??8\n9>>??9",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7557",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #182 - Codeforces - Code 9",
          "code": "98\n.7\n.6\n.5\n.4\n.3\n12",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7557",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #182 - Codeforces - Code 10",
          "code": "98\n.7\n.6\n.5\n.4\n.3\n12",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7557",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #182 tutorial - Codeforces - Code 1",
          "code": "for (int a = 1; a <= n; a++)\n    for (int b = a; b <= n; b += a)\n        remember_pair(a, b);// b % a == 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7560",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #182 tutorial - Codeforces - Code 2",
          "code": "for (int a = 1; a <= n; a++)\n    for (int b = a; b <= n; b += a)\n        remember_pair(a, b);// b % a == 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7560",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #182 tutorial - Codeforces - Code 3",
          "code": "ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    cin.tie(0);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7560",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #182 tutorial - Codeforces - Code 4",
          "code": "ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    cin.tie(0);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7560",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #182 tutorial - Codeforces - Code 5",
          "code": "3 1\n1000\n0 0\n0 100\n0 101",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7560",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #182 tutorial - Codeforces - Code 6",
          "code": "3 1\n1000\n0 0\n0 100\n0 101",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7560",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    \n    // Read n and d from first line\n    int n = inf.readInt(3, 100, \"n\");\n    inf.readSpace();\n    int d = inf.readInt(1000, 100000, \"d\");\n    inf.readEoln();\n    \n    // Read a2 to an-1\n    vector<int> a = inf.readInts(n - 2, 1, 1000, \"a_i\");\n    inf.readEoln();\n    \n    // Read positions of the n stations\n    vector<pair<int, int>> positions(n);\n    for (int i = 0; i < n; ++i) {\n        int x = inf.readInt(-100, 100, \"x_i\");\n        inf.readSpace();\n        int y = inf.readInt(-100, 100, \"y_i\");\n        inf.readEoln();\n        positions[i] = make_pair(x, y);\n    }\n    \n    // Check that no two stations are located at the same point\n    set<pair<int, int>> unique_positions(positions.begin(), positions.end());\n    ensuref((int)unique_positions.size() == n, \"Stations must be at unique positions\");\n    \n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    \n    // Read n and d from first line\n    int n = inf.readInt(3, 100, \"n\");\n    inf.readSpace();\n    int d = inf.readInt(1000, 100000, \"d\");\n    inf.readEoln();\n    \n    // Read a2 to an-1\n    vector<int> a = inf.readInts(n - 2, 1, 1000, \"a_i\");\n    inf.readEoln();\n    \n    // Read positions of the n stations\n    vector<pair<int, int>> positions(n);\n    for (int i = 0; i < n; ++i) {\n        int x = inf.readInt(-100, 100, \"x_i\");\n        inf.readSpace();\n        int y = inf.readInt(-100, 100, \"y_i\");\n        inf.readEoln();\n        positions[i] = make_pair(x, y);\n    }\n    \n    // Check that no two stations are located at the same point\n    set<pair<int, int>> unique_positions(positions.begin(), positions.end());\n    ensuref((int)unique_positions.size() == n, \"Stations must be at unique positions\");\n    \n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    \n    // Read n and d from first line\n    int n = inf.readInt(3, 100, \"n\");\n    inf.readSpace();\n    int d = inf.readInt(1000, 100000, \"d\");\n    inf.readEoln();\n    \n    // Read a2 to an-1\n    vector<int> a = inf.readInts(n - 2, 1, 1000, \"a_i\");\n    inf.readEoln();\n    \n    // Read positions of the n stations\n    vector<pair<int, int>> positions(n);\n    for (int i = 0; i < n; ++i) {\n        int x = inf.readInt(-100, 100, \"x_i\");\n        inf.readSpace();\n        int y = inf.readInt(-100, 100, \"y_i\");\n        inf.readEoln();\n        positions[i] = make_pair(x, y);\n    }\n    \n    // Check that no two stations are located at the same point\n    set<pair<int, int>> unique_positions(positions.begin(), positions.end());\n    ensuref((int)unique_positions.size() == n, \"Stations must be at unique positions\");\n    \n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int d = opt<int>(\"d\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> ai(n - 2, 1); // default ai values\n\n    vector<pair<int, int>> coords(n);\n\n    if (type == \"random\") {\n        // Random ai between 1 and 1000\n        for (int i = 0; i < n - 2; ++i) {\n            ai[i] = rnd.next(1, 1000);\n        }\n        // Random coordinates between -100 and 100, ensure no overlaps\n        set<pair<int, int>> used_coords;\n        for (int i = 0; i < n; ++i) {\n            int x, y;\n            do {\n                x = rnd.next(-100, 100);\n                y = rnd.next(-100, 100);\n            } while (used_coords.count({x, y}));\n            used_coords.insert({x, y});\n            coords[i] = {x, y};\n        }\n    } else if (type == \"max_ai\") {\n        // Set ai to max value 1000\n        fill(ai.begin(), ai.end(), 1000);\n\n        // Random coordinates between -100 and 100, ensure no overlaps\n        set<pair<int, int>> used_coords;\n        for (int i = 0; i < n; ++i) {\n            int x, y;\n            do {\n                x = rnd.next(-100, 100);\n                y = rnd.next(-100, 100);\n            } while (used_coords.count({x, y}));\n            used_coords.insert({x, y});\n            coords[i] = {x, y};\n        }\n    } else if (type == \"min_ai\") {\n        // Set ai to min value 1\n        fill(ai.begin(), ai.end(), 1);\n\n        // Random coordinates between -100 and 100, ensure no overlaps\n        set<pair<int, int>> used_coords;\n        for (int i = 0; i < n; ++i) {\n            int x, y;\n            do {\n                x = rnd.next(-100, 100);\n                y = rnd.next(-100, 100);\n            } while (used_coords.count({x, y}));\n            used_coords.insert({x, y});\n            coords[i] = {x, y};\n        }\n    } else if (type == \"line\") {\n        // Stations in a straight line\n        for (int i = 0; i < n - 2; ++i) {\n            ai[i] = rnd.next(1, 1000);\n        }\n        // x from -100 to 100, y = 0\n        for (int i = 0; i < n; ++i) {\n            int x = -100 + (200 * i) / (n - 1); // Evenly spaced\n            int y = 0;\n            coords[i] = {x, y};\n        }\n    } else if (type == \"clustered\") {\n        // Stations clustered together\n        for (int i = 0; i < n - 2; ++i) {\n            ai[i] = rnd.next(1, 1000);\n        }\n        // All stations between x = 0 to x = 10, y = 0 to y = 10\n        set<pair<int, int>> used_coords;\n        for (int i = 0; i < n; ++i) {\n            int x, y;\n            do {\n                x = rnd.next(0, 10);\n                y = rnd.next(0, 10);\n            } while (used_coords.count({x, y}));\n            used_coords.insert({x, y});\n            coords[i] = {x, y};\n        }\n    } else if (type == \"sparse\") {\n        // Stations spread out as much as possible\n        for (int i = 0; i < n - 2; ++i) {\n            ai[i] = rnd.next(1, 1000);\n        }\n        // Stations at the corners of the coordinate limits\n        coords[0] = {-100, -100};\n        coords[1] = {100, 100};\n        set<pair<int, int>> used_coords;\n        used_coords.insert(coords[0]);\n        used_coords.insert(coords[1]);\n\n        for (int i = 2; i < n; ++i) {\n            int x, y;\n            do {\n                x = rnd.next(-100, 100);\n                y = rnd.next(-100, 100);\n            } while (used_coords.count({x, y}));\n            used_coords.insert({x, y});\n            coords[i] = {x, y};\n        }\n    } else if (type == \"impossible\") {\n        // Generate a case where it's impossible to reach station n without buying time at station 1\n        fill(ai.begin(), ai.end(), 1);\n\n        // Place station 1 and station 2 far apart\n        coords[0] = {-100, -100};\n        coords[1] = {100, 100};\n        set<pair<int, int>> used_coords;\n        used_coords.insert(coords[0]);\n        used_coords.insert(coords[1]);\n\n        for (int i = 2; i < n; ++i) {\n            int x, y;\n            do {\n                x = rnd.next(-50, 50);\n                y = rnd.next(-50, 50);\n            } while (used_coords.count({x, y}));\n            used_coords.insert({x, y});\n            coords[i] = {x, y};\n        }\n    }\n\n    // Output format:\n\n    // First line: n d\n    printf(\"%d %d\\n\", n, d);\n\n    // Second line: a2, a3, ..., a_{n-1}\n    for (int i = 0; i < n - 2; ++i) {\n        if (i > 0)\n            printf(\" \");\n        printf(\"%d\", ai[i]);\n    }\n    printf(\"\\n\");\n\n    // Next n lines: xi yi\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d %d\\n\", coords[i].first, coords[i].second);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int d = opt<int>(\"d\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> ai(n - 2, 1); // default ai values\n\n    vector<pair<int, int>> coords(n);\n\n    if (type == \"random\") {\n        // Random ai between 1 and 1000\n        for (int i = 0; i < n - 2; ++i) {\n            ai[i] = rnd.next(1, 1000);\n        }\n        // Random coordinates between -100 and 100, ensure no overlaps\n        set<pair<int, int>> used_coords;\n        for (int i = 0; i < n; ++i) {\n            int x, y;\n            do {\n                x = rnd.next(-100, 100);\n                y = rnd.next(-100, 100);\n            } while (used_coords.count({x, y}));\n            used_coords.insert({x, y});\n            coords[i] = {x, y};\n        }\n    } else if (type == \"max_ai\") {\n        // Set ai to max value 1000\n        fill(ai.begin(), ai.end(), 1000);\n\n        // Random coordinates between -100 and 100, ensure no overlaps\n        set<pair<int, int>> used_coords;\n        for (int i = 0; i < n; ++i) {\n            int x, y;\n            do {\n                x = rnd.next(-100, 100);\n                y = rnd.next(-100, 100);\n            } while (used_coords.count({x, y}));\n            used_coords.insert({x, y});\n            coords[i] = {x, y};\n        }\n    } else if (type == \"min_ai\") {\n        // Set ai to min value 1\n        fill(ai.begin(), ai.end(), 1);\n\n        // Random coordinates between -100 and 100, ensure no overlaps\n        set<pair<int, int>> used_coords;\n        for (int i = 0; i < n; ++i) {\n            int x, y;\n            do {\n                x = rnd.next(-100, 100);\n                y = rnd.next(-100, 100);\n            } while (used_coords.count({x, y}));\n            used_coords.insert({x, y});\n            coords[i] = {x, y};\n        }\n    } else if (type == \"line\") {\n        // Stations in a straight line\n        for (int i = 0; i < n - 2; ++i) {\n            ai[i] = rnd.next(1, 1000);\n        }\n        // x from -100 to 100, y = 0\n        for (int i = 0; i < n; ++i) {\n            int x = -100 + (200 * i) / (n - 1); // Evenly spaced\n            int y = 0;\n            coords[i] = {x, y};\n        }\n    } else if (type == \"clustered\") {\n        // Stations clustered together\n        for (int i = 0; i < n - 2; ++i) {\n            ai[i] = rnd.next(1, 1000);\n        }\n        // All stations between x = 0 to x = 10, y = 0 to y = 10\n        set<pair<int, int>> used_coords;\n        for (int i = 0; i < n; ++i) {\n            int x, y;\n            do {\n                x = rnd.next(0, 10);\n                y = rnd.next(0, 10);\n            } while (used_coords.count({x, y}));\n            used_coords.insert({x, y});\n            coords[i] = {x, y};\n        }\n    } else if (type == \"sparse\") {\n        // Stations spread out as much as possible\n        for (int i = 0; i < n - 2; ++i) {\n            ai[i] = rnd.next(1, 1000);\n        }\n        // Stations at the corners of the coordinate limits\n        coords[0] = {-100, -100};\n        coords[1] = {100, 100};\n        set<pair<int, int>> used_coords;\n        used_coords.insert(coords[0]);\n        used_coords.insert(coords[1]);\n\n        for (int i = 2; i < n; ++i) {\n            int x, y;\n            do {\n                x = rnd.next(-100, 100);\n                y = rnd.next(-100, 100);\n            } while (used_coords.count({x, y}));\n            used_coords.insert({x, y});\n            coords[i] = {x, y};\n        }\n    } else if (type == \"impossible\") {\n        // Generate a case where it's impossible to reach station n without buying time at station 1\n        fill(ai.begin(), ai.end(), 1);\n\n        // Place station 1 and station 2 far apart\n        coords[0] = {-100, -100};\n        coords[1] = {100, 100};\n        set<pair<int, int>> used_coords;\n        used_coords.insert(coords[0]);\n        used_coords.insert(coords[1]);\n\n        for (int i = 2; i < n; ++i) {\n            int x, y;\n            do {\n                x = rnd.next(-50, 50);\n                y = rnd.next(-50, 50);\n            } while (used_coords.count({x, y}));\n            used_coords.insert({x, y});\n            coords[i] = {x, y};\n        }\n    }\n\n    // Output format:\n\n    // First line: n d\n    printf(\"%d %d\\n\", n, d);\n\n    // Second line: a2, a3, ..., a_{n-1}\n    for (int i = 0; i < n - 2; ++i) {\n        if (i > 0)\n            printf(\" \");\n        printf(\"%d\", ai[i]);\n    }\n    printf(\"\\n\");\n\n    // Next n lines: xi yi\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d %d\\n\", coords[i].first, coords[i].second);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 3 -d 1000 -type random\n./gen -n 3 -d 100000 -type random\n./gen -n 100 -d 1000 -type random\n./gen -n 100 -d 100000 -type random\n./gen -n 50 -d 50000 -type max_ai\n./gen -n 50 -d 50000 -type min_ai\n./gen -n 30 -d 1000 -type line\n./gen -n 30 -d 1000 -type clustered\n./gen -n 30 -d 1000 -type sparse\n./gen -n 100 -d 100000 -type line\n./gen -n 100 -d 100000 -type clustered\n./gen -n 100 -d 100000 -type sparse\n./gen -n 3 -d 100000 -type impossible\n./gen -n 10 -d 100000 -type impossible\n./gen -n 3 -d 100000 -type sparse\n./gen -n 100 -d 1000 -type min_ai\n./gen -n 100 -d 100000 -type max_ai\n./gen -n 100 -d 1000 -type min_ai\n./gen -n 50 -d 1000 -type clustered\n./gen -n 100 -d 100000 -type impossible\n./gen -n 3 -d 1000 -type impossible\n./gen -n 3 -d 100000 -type line\n./gen -n 100 -d 1000 -type line\n./gen -n 3 -d 1000 -type min_ai\n./gen -n 100 -d 100000 -type max_ai\n./gen -n 50 -d 50000 -type sparse\n./gen -n 3 -d 1000 -type clustered\n./gen -n 3 -d 1000 -type sparse\n./gen -n 100 -d 100000 -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:05:18.980381",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "302/E",
      "title": "E. Yaroslav and Algorithm",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains integer n (1 ≤ n ≤ 100) — the number of elements in the set. The next n lines contains one positive integer each. All the given numbers are less than 1025.",
      "output_spec": "OutputPrint the algorithm which can individually increase each number of the set. In the i-th line print the command number i without spaces.Your algorithm will be launched for each of these numbers. The answer will be considered correct if:     Each line will a correct algorithm command (see the description in the problem statement).  The number of commands should not exceed 50.  The algorithm will increase each of the given numbers by one.  To get a respond, the algorithm will perform no more than 200 iterations for each number.",
      "sample_tests": "ExamplesInputCopy21079OutputCopy10<>1179<>80",
      "description": "E. Yaroslav and Algorithm\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains integer n (1 ≤ n ≤ 100) — the number of elements in the set. The next n lines contains one positive integer each. All the given numbers are less than 1025.\n\nOutputPrint the algorithm which can individually increase each number of the set. In the i-th line print the command number i without spaces.Your algorithm will be launched for each of these numbers. The answer will be considered correct if:     Each line will a correct algorithm command (see the description in the problem statement).  The number of commands should not exceed 50.  The algorithm will increase each of the given numbers by one.  To get a respond, the algorithm will perform no more than 200 iterations for each number.\n\nInputCopy21079OutputCopy10<>1179<>80\n\nInputCopy21079\n\nOutputCopy10<>1179<>80",
      "solutions": [
        {
          "title": "Codeforces Round #182 - Codeforces",
          "content": "Hello everyone!Codeforces Round #182 will take place on Sunday, May 5th at 19:30 MSK. This is my sixth Codeforces round and I hope not the last.I'd like to thank Gerald and sdya for helping me to prepare the round. Special thanks to Delinur for translation of all problem statements into English.I strongly recommend you to read ALL the problems.Gl & hf ! :)Because of technical issue the start of the contest was unsuccessful. Sorry about it. The contest will be UNRATED.Tutorial.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/7557",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 481
        },
        {
          "title": "Codeforces Round #182 tutorial - Codeforces",
          "content": "302A - Eugeny and ArrayIf the length of the given segment is even and count of 1 in input is not lower then half of the length of the segment and count of -1 in the input is not lower then half of the length of the segment so we have answer 1, otherwise 0. 302B - Eugeny and Play ListFor each song we will count moment of time, when it will be over (some sums on the prefixes, for example). Further, we will use binary search of two itaratos method to solve the problem. 301A - Yaroslav and SequenceUsing dfs we will find number of numbers that we can set as positive. Note that we can either set all of the numbers as positive or leave one number(any) as negative. If we can obtain all numbers as positive, we just return sum of modules of the numbers, but if we cannot we will count the same sum and will subtract minimal modular value multiple 2 from sum. 301B - Yaroslav and TimeWe will use binary search to find the answer. Further we will use Ford-Bellman algorithm. On each step we will have an array of maximum values on timer, when we stand in some point. On in transfer we will check: will our player stay alive after travelling beetwen points. If we can make transfer, we will update value of the final destination point. Becouse of a_i<=d and integer coordinates we haven't optimal cycles, and solution exists. 301C - Yaroslav and AlgorithmWe will use ? as iterator. In the begin we will set ? before the number. Then we will move it to the end of the string. Then we will change ? to ?? and we will move it to the begin, while we have 9 before ??. If we have another digit, we just increase it, and finish the algorithm. If we have ?? at the begin, we change it to 1, and end the algorithm. Look for accepted solutions for better understanding. 301D - Yaroslav and DivisorsLets add all pair: (x,y) ((d[x]%d[y]==0) || (d[y]%d[x]==0)) to some lest. We can count such pairs using Eretosphen algorithm. Here will be O(n*log(n)) sych pairs using fact, that we have permutation. We will sort all this paairs using counting-sort. Also we will sort given in input intervals. For each given interval we should count number of pairs that countained in given them . Such problem we can solve using Fenvik tree. On each step we will add segments(that are sorted by right side). On each step we will update Fenfick-tree that count number of added pairs on some suffix. Using such tree if it easy to count the answer. So we have O(n*log^2(n)) solution. 301E - Yaroslav and ArrangementsWe will build the needed arrays sequentially adding numbers. Let's look at what states we need. First, it is obvious that you need to keep the number of ways to build an array of already added numbers, secondly you need to know the total amount of added numbers. Now let's look at what happens when we add a new number (that is greater than all of the previous in a certain amount). It is clear that the added numbers should stand between the numbers 1 to less. In this case, if we put two new numbers in a row, between them should stand more (since we already have placed less). It is obvious that you need to cover all the previous numbers (among which must stand newly added). Thus, we have another state: the number of integers between which we should put the new ones. Thus we have the dynamics of the four parameters: dp [all] [ways] [lastnumber] [counttoadd]. Transfer. It is clear that you need to add at least counttoadd numbers, but how will this affect the number of ways to arrange the numbers? It's simple. Suppose we added number x, then the number of ways to be multiplied by the value of Q (x-counttoadd, counttoadd), where Q (x, y) — the number of ways to assign the same x balls in y different boxes. Q (x, y) = C (x + y-1, y-1) where C (x, y) — binomial coefficient.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/7560",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.6,
            "reason": "宽松匹配: 包含题目编号 302 和字母"
          },
          "content_length": 3769
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #182 - Codeforces - Code 1",
          "code": "**Server Problem !!!!**",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7557",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #182 - Codeforces - Code 2",
          "code": "**Bad Gateway**",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7557",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #182 - Codeforces - Code 3",
          "code": "-959 -542 -669 -513 160\n-959 -542 669 513 -160\n959 542 669 513 160",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7557",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #182 - Codeforces - Code 4",
          "code": "-959 -542 -669 -513 160\n-959 -542 669 513 -160\n959 542 669 513 160",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7557",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #182 - Codeforces - Code 5",
          "code": "3 1000\n2000\n0 0\n0 1\n0 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7557",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #182 - Codeforces - Code 6",
          "code": "3 1000\n2000\n0 0\n0 1\n0 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7557",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #182 - Codeforces - Code 7",
          "code": "??0>>0??\n??1>>1??\n??2>>2??\n??3>>3??\n??4>>4??\n??5>>5??\n??6>>6??\n??7>>7??\n??8>>8??\n??9>>9??\n??>>?\n0?<>1\n1?<>2\n2?<>3\n3?<>4\n4?<>5\n5?<>6\n6?<>7\n7?<>8\n8?<>9\n9?>>?0\n?<>1\n0>>??0\n1>>??1\n2>>??2\n3>>??3\n4>>??4\n5>>??5\n6>>??6\n7>>??7\n8>>??8\n9>>??9",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7557",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #182 - Codeforces - Code 8",
          "code": "??0>>0??\n??1>>1??\n??2>>2??\n??3>>3??\n??4>>4??\n??5>>5??\n??6>>6??\n??7>>7??\n??8>>8??\n??9>>9??\n??>>?\n0?<>1\n1?<>2\n2?<>3\n3?<>4\n4?<>5\n5?<>6\n6?<>7\n7?<>8\n8?<>9\n9?>>?0\n?<>1\n0>>??0\n1>>??1\n2>>??2\n3>>??3\n4>>??4\n5>>??5\n6>>??6\n7>>??7\n8>>??8\n9>>??9",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7557",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #182 - Codeforces - Code 9",
          "code": "98\n.7\n.6\n.5\n.4\n.3\n12",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7557",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #182 - Codeforces - Code 10",
          "code": "98\n.7\n.6\n.5\n.4\n.3\n12",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7557",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #182 tutorial - Codeforces - Code 1",
          "code": "for (int a = 1; a <= n; a++)\n    for (int b = a; b <= n; b += a)\n        remember_pair(a, b);// b % a == 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7560",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #182 tutorial - Codeforces - Code 2",
          "code": "for (int a = 1; a <= n; a++)\n    for (int b = a; b <= n; b += a)\n        remember_pair(a, b);// b % a == 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7560",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #182 tutorial - Codeforces - Code 3",
          "code": "ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    cin.tie(0);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7560",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #182 tutorial - Codeforces - Code 4",
          "code": "ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    cin.tie(0);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7560",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #182 tutorial - Codeforces - Code 5",
          "code": "3 1\n1000\n0 0\n0 100\n0 101",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7560",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #182 tutorial - Codeforces - Code 6",
          "code": "3 1\n1000\n0 0\n0 100\n0 101",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7560",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readEoln();\n\n    for (int i = 0; i < n; ++i) {\n        int x = inf.readInt(1, 1024, \"a_i\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readEoln();\n\n    for (int i = 0; i < n; ++i) {\n        int x = inf.readInt(1, 1024, \"a_i\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readEoln();\n\n    for (int i = 0; i < n; ++i) {\n        int x = inf.readInt(1, 1024, \"a_i\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\n// We'll store each command as a struct:\nstruct Command {\n    string s;   // substring to search\n    string w;   // substring to replace with\n    bool stop;  // true if \"<>\", false if \">>\"\n};\n\nstatic const int MAX_CMD = 50;       // The number of commands must not exceed 50\nstatic const int MAX_ITER = 200;     // No more than 200 iterations for each number\nstatic const int MAX_LEN = 7;        // s_i, w_i length at most 7\n\n// Tries to parse a single line of output as s_i>>w_i or s_i<>w_i.\n// Returns {s, w, stopFlag}, or quits in case of an invalid format.\nCommand parseCommand(InStream &stream, const string &line) {\n    // A valid command is:  ^([0-9?]{0,7})(>>|<>)([0-9?]{0,7})$\n    // We'll search for either \">>\" or \"<>\".\n    // We'll ensure there's exactly one occurrence, no spaces, and s,w use only digits+?.\n\n    // No spaces allowed:\n    if (line.find(' ') != string::npos || line.find('\\t') != string::npos) {\n        stream.quitf(_wa, \"command contains whitespace: \\\"%s\\\"\", line.c_str());\n    }\n\n    // Find operator positions (we look for \">>\" or \"<>\").\n    // We must ensure exactly one match of either \">>\" or \"<>\".\n    // We'll do a small check: find the first occurrence of \">>\" or \"<>\".\n    // If exactly one is found, we parse accordingly.\n    \n    // We'll see if \"<>\" or \">>\" appears. We also must check which one appears first if any.\n    // But the problem statement says commands look either as s_i >> w_i OR s_i <> w_i, \n    // so there's no case with both.\n\n    int posAngleAngle = line.find(\">>\");\n    int posAngleDiamond = line.find(\"<>\");\n\n    if (posAngleAngle == string::npos && posAngleDiamond == string::npos) {\n        stream.quitf(_wa, \"command must contain either '>>' or '<>': \\\"%s\\\"\", line.c_str());\n    }\n    if (posAngleAngle != string::npos && posAngleDiamond != string::npos) {\n        // Two different operators are present\n        stream.quitf(_wa, \"command cannot contain both '>>' and '<>': \\\"%s\\\"\", line.c_str());\n    }\n\n    bool isStop = false;\n    int posOp = -1;     // position of the operator\n    int opLen = 2;      // length of the operator\n\n    if (posAngleAngle != string::npos) {\n        isStop = false; // '>>'\n        posOp = posAngleAngle;\n    } else {\n        isStop = true;  // '<>'\n        posOp = posAngleDiamond;\n    }\n\n    // Now extract s and w\n    string sPart = line.substr(0, posOp);\n    string wPart = line.substr(posOp + opLen);\n\n    // Check length constraints\n    if ((int)sPart.size() > MAX_LEN || (int)wPart.size() > MAX_LEN) {\n        stream.quitf(_wa, \"s or w length exceeds %d in \\\"%s\\\"\", MAX_LEN, line.c_str());\n    }\n    // Check valid characters ([0-9?]*)\n    auto validChars = [&](const string &x) {\n        for (char c : x) {\n            if (!(isdigit(c) || c == '?')) {\n                return false;\n            }\n        }\n        return true;\n    };\n    if (!validChars(sPart) || !validChars(wPart)) {\n        stream.quitf(_wa, \"invalid characters in s or w: \\\"%s\\\"\", line.c_str());\n    }\n\n    Command cmd;\n    cmd.s = sPart;\n    cmd.w = wPart;\n    cmd.stop = isStop;\n    return cmd;\n}\n\n// This function simulates the described algorithm on 'inputStr' using the list of commands.\n// If it finishes in <= MAX_ITER steps, returns the resulting string.\n// Otherwise, or if we detect an error, we produce a verdict.\nstring runAlgorithm(const string &inputStr, const vector<Command> &cmds) {\n    // We'll start with a = inputStr\n    // On each iteration:\n    //   find the first command i for which s_i occurs in a. If none found, we terminate.\n    //   replace the first occurrence of s_i by w_i in a\n    //   if the command is \">>\", continue; if \"<>\", we terminate\n\n    string a = inputStr;\n    for (int iter = 0; iter < MAX_ITER; iter++) {\n        bool found = false;\n        for (int i = 0; i < (int)cmds.size(); i++) {\n            const string &s = cmds[i].s;\n            const string &w = cmds[i].w;\n            // find first occurrence of s in a\n            // note that s can be empty, in which case the first occurrence is position 0\n            size_t pos;\n            if (s.empty()) {\n                // empty string occurs at position 0\n                pos = 0;\n                // but we only do that if we haven't replaced anything else previously\n                // i.e., if no earlier command matched\n            } else {\n                pos = a.find(s);\n            }\n\n            if (pos != string::npos) {\n                // Found an occurrence => do the replacement\n                a.replace(pos, s.size(), w);\n                found = true;\n                if (cmds[i].stop) {\n                    // command is \"<>\", so we terminate the algorithm\n                    return a;\n                }\n                // else continue to next iteration\n                break;\n            }\n        }\n        // if we didn't find any command, we terminate\n        if (!found) {\n            return a;\n        }\n    }\n    // If we exit the loop, that means we've done 200 replacements without terminating\n    // => that's not allowed by problem statement.\n    // We'll declare it incorrect.\n    // (Though it might be an infinite loop, we stop checking here.)\n    return \"$EXCEED_ITERATIONS$\";\n}\n\nint main(int argc, char* argv[]) {\n    registerTestlibCmd(argc, argv);\n\n    // First, read from the input file (inf).\n    // We have n, then n positive integers each < 1025.\n    int n = inf.readInt(1, 100, \"n\");\n    vector<int> values(n);\n    for (int i = 0; i < n; i++) {\n        int val = inf.readInt(1, 1024, \"value\");\n        values[i] = val;\n    }\n\n    // Now read from the output file (ouf) up to 50 lines of commands.\n    vector<Command> commands;\n    // We'll read until EOF or until we exceed 50 lines\n    for (int lineCount = 0; !ouf.eof(); lineCount++) {\n        if (lineCount == MAX_CMD) {\n            // If there's a 51st line, that's too many commands\n            if (!ouf.eof()) {\n                // There's more data, so it's a WA\n                ouf.quitf(_wa, \"too many commands (more than %d)\", MAX_CMD);\n            }\n            break;\n        }\n        string line;\n        // Attempt to read a line\n        line = ouf.readString(); // readToken would stop at spaces, readString reads until whitespace but might mix lines.\n        // Actually, let's do readLine() to handle the entire line properly.\n        // But we've already used readString() - that might break if the line has no spaces (which it shouldn't).\n        // We'll do readString() as there's no space expected in each command.\n        // If that hits an empty line, let's break if we indeed reached EOF.\n\n        Command cmd = parseCommand(ouf, line);\n        commands.push_back(cmd);\n    }\n\n    // We have our commands, let's check each of the n input numbers\n    //  - run them for at most 200 iterations\n    //  - check that output == input+1\n    // If not, WA.\n\n    for (int i = 0; i < n; i++) {\n        int originalValue = values[i];\n        // compute correct answer = originalValue + 1\n        int correctValue = originalValue + 1;\n        ostringstream oss;\n        oss << correctValue;\n        string correctString = oss.str();\n\n        // convert the number to string\n        ostringstream oss2;\n        oss2 << originalValue;\n        string inputString = oss2.str();\n\n        // run the algorithm\n        string result = runAlgorithm(inputString, commands);\n        if (result == \"$EXCEED_ITERATIONS$\") {\n            ouf.quitf(_wa, \"algorithm did not terminate within %d iterations on input \\\"%s\\\"\",\n                      MAX_ITER, inputString.c_str());\n        }\n        // compare the result with correctString\n        if (result != correctString) {\n            ouf.quitf(_wa, \"expected \\\"%s\\\" but got \\\"%s\\\" for input \\\"%s\\\"\",\n                      correctString.c_str(), result.c_str(), inputString.c_str());\n        }\n    }\n\n    // If we reach here, everything is correct\n    ouf.quitf(_ok, \"valid algorithm\");\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\");\n\n    vector<int> numbers(n); // to store generated numbers\n\n    if (type == \"min\") {\n        n = 1;\n        numbers.resize(n);\n        numbers[0] = 1;\n    } else if (type == \"max\") {\n        n = 100;\n        numbers.resize(n);\n        for(int i = 0; i < n; ++i)\n            numbers[i] = 1024;\n    } else if (type == \"random\") {\n        for(int i = 0; i < n; ++i)\n            numbers[i] = rnd.next(1,1024);\n    } else if (type == \"sequential\") {\n        n = min(n,1024);\n        numbers.resize(n);\n        for(int i = 0; i < n; ++i)\n            numbers[i] = i + 1;\n    } else if (type == \"powers_of_two\") {\n        vector<int> powers;\n        for(int i = 0; i <= 10; ++i)\n            powers.push_back(1<<i); // 2^i\n        for(int i = 0; i < n; ++i)\n            numbers[i] = powers[i % powers.size()];\n    } else if (type == \"increase_length\") {\n        vector<int> nums;\n        for(int x = 1; x <= 1023; ++x) {\n            string s = to_string(x);\n            string t = to_string(x+1);\n            if (s.length() < t.length()) {\n                nums.push_back(x);\n            }\n        }\n        for(int i = 0; i < n; ++i)\n            numbers[i] = nums[i % nums.size()];\n    } else if (type == \"near_boundary\") {\n        vector<int> nums = {1, 2, 1023, 1024};\n        for(int i = 0; i < n; ++i)\n            numbers[i] = nums[i % nums.size()];\n    } else if (type == \"all_same\") {\n        int num = rnd.next(1,1024);\n        for(int i = 0; i< n; ++i)\n            numbers[i] = num;\n    } else {\n        // Default, generate random numbers\n        for(int i = 0; i< n; ++i)\n            numbers[i] = rnd.next(1,1024);\n    }\n\n    // Now, we output 'n' and the numbers\n\n    printf(\"%d\\n\", n);\n    for(int i = 0; i < n; ++i)\n        printf(\"%d\\n\", numbers[i]);\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\");\n\n    vector<int> numbers(n); // to store generated numbers\n\n    if (type == \"min\") {\n        n = 1;\n        numbers.resize(n);\n        numbers[0] = 1;\n    } else if (type == \"max\") {\n        n = 100;\n        numbers.resize(n);\n        for(int i = 0; i < n; ++i)\n            numbers[i] = 1024;\n    } else if (type == \"random\") {\n        for(int i = 0; i < n; ++i)\n            numbers[i] = rnd.next(1,1024);\n    } else if (type == \"sequential\") {\n        n = min(n,1024);\n        numbers.resize(n);\n        for(int i = 0; i < n; ++i)\n            numbers[i] = i + 1;\n    } else if (type == \"powers_of_two\") {\n        vector<int> powers;\n        for(int i = 0; i <= 10; ++i)\n            powers.push_back(1<<i); // 2^i\n        for(int i = 0; i < n; ++i)\n            numbers[i] = powers[i % powers.size()];\n    } else if (type == \"increase_length\") {\n        vector<int> nums;\n        for(int x = 1; x <= 1023; ++x) {\n            string s = to_string(x);\n            string t = to_string(x+1);\n            if (s.length() < t.length()) {\n                nums.push_back(x);\n            }\n        }\n        for(int i = 0; i < n; ++i)\n            numbers[i] = nums[i % nums.size()];\n    } else if (type == \"near_boundary\") {\n        vector<int> nums = {1, 2, 1023, 1024};\n        for(int i = 0; i < n; ++i)\n            numbers[i] = nums[i % nums.size()];\n    } else if (type == \"all_same\") {\n        int num = rnd.next(1,1024);\n        for(int i = 0; i< n; ++i)\n            numbers[i] = num;\n    } else {\n        // Default, generate random numbers\n        for(int i = 0; i< n; ++i)\n            numbers[i] = rnd.next(1,1024);\n    }\n\n    // Now, we output 'n' and the numbers\n\n    printf(\"%d\\n\", n);\n    for(int i = 0; i < n; ++i)\n        printf(\"%d\\n\", numbers[i]);\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -type min\n\n./gen -n 100 -type max\n\n./gen -n 10 -type random\n./gen -n 50 -type random\n./gen -n 100 -type random\n\n./gen -n 100 -type sequential\n\n./gen -n 100 -type powers_of_two\n\n./gen -n 50 -type increase_length\n\n./gen -n 100 -type near_boundary\n\n./gen -n 100 -type all_same\n\n# Additional variations\n\n./gen -n 1 -type random\n\n./gen -n 100 -type random\n\n./gen -n 33 -type powers_of_two\n\n./gen -n 10 -type increase_length\n\n./gen -n 100 -type increase_length\n\n./gen -n 25 -type near_boundary\n\n./gen -n 50 -type all_same\n\n./gen -n 99 -type sequential\n\n./gen -n 98 -type random\n\n./gen -n 97 -type powers_of_two\n\n./gen -n 96 -type near_boundary\n\n./gen -n 95 -type increase_length\n\n# Edge cases\n\n./gen -n 1 -type max\n\n./gen -n 1 -type powers_of_two\n\n./gen -n 1 -type near_boundary\n\n./gen -n 100 -type min\n\n./gen -n 100 -type random\n\n# Random n with specified types\n\n./gen -n 73 -type random\n./gen -n 64 -type random\n./gen -n 82 -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:05:20.566433",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "303/A",
      "title": "A. Lucky Permutation Triple",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains a single integer n (1 ≤ n ≤ 105).",
      "output_spec": "OutputIf no Lucky Permutation Triple of length n exists print -1.Otherwise, you need to print three lines. Each line contains n space-seperated integers. The first line must contain permutation a, the second line — permutation b, the third — permutation c.If there are multiple solutions, print any of them.",
      "sample_tests": "ExamplesInputCopy5OutputCopy1 4 3 2 01 0 2 4 32 4 0 1 3InputCopy2OutputCopy-1",
      "description": "A. Lucky Permutation Triple\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains a single integer n (1 ≤ n ≤ 105).\n\nOutputIf no Lucky Permutation Triple of length n exists print -1.Otherwise, you need to print three lines. Each line contains n space-seperated integers. The first line must contain permutation a, the second line — permutation b, the third — permutation c.If there are multiple solutions, print any of them.\n\nInputCopy5OutputCopy1 4 3 2 01 0 2 4 32 4 0 1 3InputCopy2OutputCopy-1\n\nOutputCopy1 4 3 2 01 0 2 4 32 4 0 1 3\n\nOutputCopy-1\n\nNoteIn Sample 1, the permutation triple ([1, 4, 3, 2, 0], [1, 0, 2, 4, 3], [2, 4, 0, 1, 3]) is Lucky Permutation Triple, as following holds:  ;  ;  ;  ;  . In Sample 2, you can easily notice that no lucky permutation triple exists.",
      "solutions": [
        {
          "title": "Codeforces Round #183 - Codeforces",
          "content": "Three drops in a line, back to yellow so quickly ...Anyway, Codeforces Round #183 will be take place on Sunday, May 12th at 17:00 MSK(21:00 CST). Right after the Google Code Jam Round 1C.Setters are: Yuzhou Gu sevenkplus (For Problem B && E) Yuping Luo roosephu (For Problem A && D) Jiatai Huang CMHJT (Problem C) Testers are YuukaKazami, havaliza, Velicue && me.We gratefully acknowledge Gerald Agapov(Gerald) for his help in giving advise about the problems, Delinur for her help in translating the problems to Russian, and MikeMirzayanov, who has designed such a powerful platform.We strongly recommend you to take a glance over all five problems, there must be one suitable to your taste.Oh one more thing, this time, scoring will be dynamic, but problems are sorted by increasing order of their difficulty as usual.Good Luck!",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/7499",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 830
        },
        {
          "title": "Codeforces Round #183 Editorial - Codeforces",
          "content": "Overview ...。。。(; Д ;) 。Tutorial ... Problem 2A. Pythagorean Theorem II Math, implementationThis problem can be solve by brute-force, but it come up with a nicer solution if we involve some math.Check the following article if you are interested.http://en.wikipedia.org/wiki/Pythagorean_triple#Generating_a_triple Problem 2B. Calender Math, implementationThis problem can be solve by brute-force, but it come up with a nicer solution if we involve some math.Check kabar's code if you are interested.http://codeforces.com/contest/304/submission/3715756 Problem A. Lucky Permutation Triple Math, Constructive algorithms, Congruent when n is odd, A[i] = B[i] = i when n is even, there is no solution. So why? Because: S = \\Sum_{i=0}^{n-1} i = n/2 (mod n) but 2*S = 0 (mod n)See also at:http://codeforces.com/blog/entry/7499#comment-133446 Problem B. Rectangle Puzzle II Math, GeometryGive you n, m, x, y, a, b.Find a maximum sub-rectangle within (0, 0) — (n, m), so that it contains the given point(x, y) and its length-width radio is exactly (a, b). If there are multiple solutions, find the rectangle which is closest to (x, y). If there are still multiple solutions, find the lexicographically minimum one.Split the problem into x-axis and y-axis. Then you can solve the sub tasks in O(1). d = gcd(a,b)\na /= d\nb /= d\nt = min(n/a, m/b)\na *= t\nb *= tBe careful, when the length is outside the original rectangle. Problem C. Minimum Modular Math, Graph theory, Brute-force, CongruentIt is hard to solve this problem at once, so at first, let us consider on k = 0, this easier case can be solved by enumerate on the ans. Let us define a bool array diff[], which diff[x] is weather there are two number, ai, aj, such that abs(ai - aj) = x.So ans is legal <=> diff[ans], diff[2*ans] … are false.The time-complexity O(n2 + mlogm). Here m is the maximum ai.Consider on k > 0, we need to know how many pairs which has difference x. Store them invector<pair <int, int> > diff[x];Then use a dsu to maintain the how many a_i are congruent when enumerate on the ans. Problem D. Rotatable Number Math, Number theory(Coming Soon...)http://codeforces.com/blog/entry/7499#comment-133342 Problem E. Random Ranking Math, Probability(Coming After D...)http://codeforces.com/blog/entry/7499#comment-133488",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/7641",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 2283
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #183 - Codeforces - Code 1",
          "code": "from datetime import date\n\na1 = map(int, raw_input().split(\":\"))\na2 = map(int, raw_input().split(\":\"))\n\nprint abs((date(a1[0], a1[1], a1[2]) - date(a2[0], a2[1], a2[2])).days)",
          "language": "Python",
          "source": "https://codeforces.com/blog/entry/7499",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #183 - Codeforces - Code 2",
          "code": "from datetime import date\n\na1 = map(int, raw_input().split(\":\"))\na2 = map(int, raw_input().split(\":\"))\n\nprint abs((date(a1[0], a1[1], a1[2]) - date(a2[0], a2[1], a2[2])).days)",
          "language": "Python",
          "source": "https://codeforces.com/blog/entry/7499",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #183 - Codeforces - Code 3",
          "code": "if (l[i] <= L && r[i] >= R)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7499",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #183 Editorial - Codeforces - Code 1",
          "code": "d = gcd(a,b)\na /= d\nb /= d\nt = min(n/a, m/b)\na *= t\nb *= t",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7641",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #183 Editorial - Codeforces - Code 2",
          "code": "d = gcd(a,b)\na /= d\nb /= d\nt = min(n/a, m/b)\na *= t\nb *= t",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7641",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #183 Editorial - Codeforces - Code 3",
          "code": "vector<pair <int, int> > diff[x];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7641",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint n;\n\nstruct PermutationTriple {\n    vector<int> a, b, c;\n};\n\nPermutationTriple readSolution(InStream& stream) {\n    PermutationTriple sol;\n    int firstVal = stream.readInt(-1, n - 1);\n    if (firstVal == -1) {\n        return sol; // Empty solution indicates -1 was read\n    }\n\n    // Read the rest of permutation a\n    vector<int> perm_a(n);\n    perm_a[0] = firstVal;\n    set<int> used_a;\n    used_a.insert(firstVal);\n    for (int i = 1; i < n; i++) {\n        int val = stream.readInt(0, n - 1, format(\"a[%d]\", i + 1).c_str());\n        if (used_a.count(val))\n            stream.quitf(_wa, \"Duplicate value %d in permutation a\", val);\n        used_a.insert(val);\n        perm_a[i] = val;\n    }\n    sol.a = perm_a;\n\n    // Read permutation b\n    vector<int> perm_b(n);\n    set<int> used_b;\n    for (int i = 0; i < n; i++) {\n        int val = stream.readInt(0, n - 1, format(\"b[%d]\", i + 1).c_str());\n        if (used_b.count(val))\n            stream.quitf(_wa, \"Duplicate value %d in permutation b\", val);\n        used_b.insert(val);\n        perm_b[i] = val;\n    }\n    sol.b = perm_b;\n\n    // Read permutation c\n    vector<int> perm_c(n);\n    set<int> used_c;\n    for (int i = 0; i < n; i++) {\n        int val = stream.readInt(0, n - 1, format(\"c[%d]\", i + 1).c_str());\n        if (used_c.count(val))\n            stream.quitf(_wa, \"Duplicate value %d in permutation c\", val);\n        used_c.insert(val);\n        perm_c[i] = val;\n    }\n    sol.c = perm_c;\n\n    return sol;\n}\n\nint main(int argc, char* argv[]) {\n    registerTestlibCmd(argc, argv);\n\n    n = inf.readInt(1, 100000);\n\n    PermutationTriple jurySol = readSolution(ans);\n    PermutationTriple partSol = readSolution(ouf);\n\n    bool juryHasSolution = !jurySol.a.empty();\n    bool participantHasSolution = !partSol.a.empty();\n\n    if (!participantHasSolution) {\n        if (!juryHasSolution) {\n            quitf(_ok, \"Correct, both report no solution exists\");\n        } else {\n            quitf(_wa, \"No solution found, but solution exists\");\n        }\n    } else {\n        // Participant provided a solution\n        if (partSol.a.size() != n || partSol.b.size() != n || partSol.c.size() != n) {\n            quitf(_wa, \"Permutation sizes are incorrect\");\n        }\n\n        // Check the condition (ai + bi) mod n == ci mod n\n        for (int i = 0; i < n; i++) {\n            int a_i = partSol.a[i];\n            int b_i = partSol.b[i];\n            int c_i = partSol.c[i];\n            if ((a_i + b_i) % n != c_i % n) {\n                quitf(_wa, \"Condition failed at position %d: (%d + %d) mod %d != %d mod %d\", \n                      i + 1, a_i, b_i, n, c_i, n);\n            }\n        }\n\n        if (!juryHasSolution) {\n            // Jury says no solution exists, but participant found one\n            quitf(_fail, \"Participant found a solution, but jury says none exists\");\n        } else {\n            quitf(_ok, \"Correct solution\");\n        }\n    }\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\n// A helper function to get a large prime number less than or equal to max_n\nint largestPrimeUnder(int max_n) {\n    // List of large primes under 100000\n    vector<int> primes = {99991, 99989, 99971, 99961, 99931, 99661, 99667, 99679, 99689, 99707};\n    for (int prime : primes) {\n        if (prime <= max_n) return prime;\n    }\n    return 9973; // A smaller prime as default\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\", -1);\n    string type = opt<string>(\"type\", \"random\");\n    \n    if (n == -1) {\n        // n not specified, determine n based on the type parameter\n        if (type == \"n1\") {\n            n = 1;\n        } else if (type == \"n2\") {\n            n = 2;\n        } else if (type == \"small_odd\") {\n            n = 3;\n        } else if (type == \"small_even\") {\n            n = 4;\n        } else if (type == \"small_odd_prime\") {\n            n = 7;\n        } else if (type == \"small_odd_composite\") {\n            n = 9;\n        } else if (type == \"large_odd\") {\n            n = 99999;\n            if (n % 2 == 0) n--;\n        } else if (type == \"large_even\") {\n            n = 99998;\n            if (n % 2 == 1) n--;\n        } else if (type == \"large_odd_prime\") {\n            n = largestPrimeUnder(100000);\n        } else if (type == \"large_odd_composite\") {\n            n = 99999; // 99999 is composite\n        } else if (type == \"max_odd\") {\n            n = 100000;\n            if (n % 2 == 0) n--;\n        } else if (type == \"max_even\") {\n            n = 100000;\n            if (n % 2 == 1) n--;\n        } else if (type == \"random\") {\n            n = rnd.next(1, 100000);\n        } else {\n            n = 5; // default value\n        }\n    }\n\n    ensure(1 <= n && n <= 100000); // Ensure n is within the problem constraints\n    printf(\"%d\\n\", n);\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\n// A helper function to get a large prime number less than or equal to max_n\nint largestPrimeUnder(int max_n) {\n    // List of large primes under 100000\n    vector<int> primes = {99991, 99989, 99971, 99961, 99931, 99661, 99667, 99679, 99689, 99707};\n    for (int prime : primes) {\n        if (prime <= max_n) return prime;\n    }\n    return 9973; // A smaller prime as default\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\", -1);\n    string type = opt<string>(\"type\", \"random\");\n    \n    if (n == -1) {\n        // n not specified, determine n based on the type parameter\n        if (type == \"n1\") {\n            n = 1;\n        } else if (type == \"n2\") {\n            n = 2;\n        } else if (type == \"small_odd\") {\n            n = 3;\n        } else if (type == \"small_even\") {\n            n = 4;\n        } else if (type == \"small_odd_prime\") {\n            n = 7;\n        } else if (type == \"small_odd_composite\") {\n            n = 9;\n        } else if (type == \"large_odd\") {\n            n = 99999;\n            if (n % 2 == 0) n--;\n        } else if (type == \"large_even\") {\n            n = 99998;\n            if (n % 2 == 1) n--;\n        } else if (type == \"large_odd_prime\") {\n            n = largestPrimeUnder(100000);\n        } else if (type == \"large_odd_composite\") {\n            n = 99999; // 99999 is composite\n        } else if (type == \"max_odd\") {\n            n = 100000;\n            if (n % 2 == 0) n--;\n        } else if (type == \"max_even\") {\n            n = 100000;\n            if (n % 2 == 1) n--;\n        } else if (type == \"random\") {\n            n = rnd.next(1, 100000);\n        } else {\n            n = 5; // default value\n        }\n    }\n\n    ensure(1 <= n && n <= 100000); // Ensure n is within the problem constraints\n    printf(\"%d\\n\", n);\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -type n1\n./gen -type n2\n./gen -type small_odd\n./gen -type small_even\n./gen -type small_odd_prime\n./gen -type small_odd_composite\n./gen -type large_odd\n./gen -type large_even\n./gen -type large_odd_prime\n./gen -type large_odd_composite\n./gen -type max_odd\n./gen -type max_even\n./gen -n 1\n./gen -n 2\n./gen -n 3\n./gen -n 4\n./gen -n 5\n./gen -n 99999\n./gen -n 100000\n./gen -n 99998\n./gen -n 50000\n./gen -n 50001\n./gen -type random\n./gen -type random\n./gen -type random\n./gen -type random\n./gen -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:05:22.564480",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "303/B",
      "title": "B. Rectangle Puzzle II",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains six integers n, m, x, y, a, b (1 ≤ n, m ≤ 109, 0 ≤ x ≤ n, 0 ≤ y ≤ m, 1 ≤ a ≤ n, 1 ≤ b ≤ m).",
      "output_spec": "OutputPrint four integers x1, y1, x2, y2, which represent the founded sub-rectangle whose left-bottom point is (x1, y1) and right-up point is (x2, y2).",
      "sample_tests": "ExamplesInputCopy9 9 5 5 2 1OutputCopy1 3 9 7InputCopy100 100 52 50 46 56OutputCopy17 8 86 92",
      "description": "B. Rectangle Puzzle II\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains six integers n, m, x, y, a, b (1 ≤ n, m ≤ 109, 0 ≤ x ≤ n, 0 ≤ y ≤ m, 1 ≤ a ≤ n, 1 ≤ b ≤ m).\n\nOutputPrint four integers x1, y1, x2, y2, which represent the founded sub-rectangle whose left-bottom point is (x1, y1) and right-up point is (x2, y2).\n\nInputCopy9 9 5 5 2 1OutputCopy1 3 9 7InputCopy100 100 52 50 46 56OutputCopy17 8 86 92\n\nInputCopy9 9 5 5 2 1\n\nOutputCopy1 3 9 7\n\nInputCopy100 100 52 50 46 56\n\nOutputCopy17 8 86 92",
      "solutions": [
        {
          "title": "Codeforces Round #183 - Codeforces",
          "content": "Three drops in a line, back to yellow so quickly ...Anyway, Codeforces Round #183 will be take place on Sunday, May 12th at 17:00 MSK(21:00 CST). Right after the Google Code Jam Round 1C.Setters are: Yuzhou Gu sevenkplus (For Problem B && E) Yuping Luo roosephu (For Problem A && D) Jiatai Huang CMHJT (Problem C) Testers are YuukaKazami, havaliza, Velicue && me.We gratefully acknowledge Gerald Agapov(Gerald) for his help in giving advise about the problems, Delinur for her help in translating the problems to Russian, and MikeMirzayanov, who has designed such a powerful platform.We strongly recommend you to take a glance over all five problems, there must be one suitable to your taste.Oh one more thing, this time, scoring will be dynamic, but problems are sorted by increasing order of their difficulty as usual.Good Luck!",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/7499",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 830
        },
        {
          "title": "Codeforces Round #183 Editorial - Codeforces",
          "content": "Overview ...。。。(; Д ;) 。Tutorial ... Problem 2A. Pythagorean Theorem II Math, implementationThis problem can be solve by brute-force, but it come up with a nicer solution if we involve some math.Check the following article if you are interested.http://en.wikipedia.org/wiki/Pythagorean_triple#Generating_a_triple Problem 2B. Calender Math, implementationThis problem can be solve by brute-force, but it come up with a nicer solution if we involve some math.Check kabar's code if you are interested.http://codeforces.com/contest/304/submission/3715756 Problem A. Lucky Permutation Triple Math, Constructive algorithms, Congruent when n is odd, A[i] = B[i] = i when n is even, there is no solution. So why? Because: S = \\Sum_{i=0}^{n-1} i = n/2 (mod n) but 2*S = 0 (mod n)See also at:http://codeforces.com/blog/entry/7499#comment-133446 Problem B. Rectangle Puzzle II Math, GeometryGive you n, m, x, y, a, b.Find a maximum sub-rectangle within (0, 0) — (n, m), so that it contains the given point(x, y) and its length-width radio is exactly (a, b). If there are multiple solutions, find the rectangle which is closest to (x, y). If there are still multiple solutions, find the lexicographically minimum one.Split the problem into x-axis and y-axis. Then you can solve the sub tasks in O(1). d = gcd(a,b)\na /= d\nb /= d\nt = min(n/a, m/b)\na *= t\nb *= tBe careful, when the length is outside the original rectangle. Problem C. Minimum Modular Math, Graph theory, Brute-force, CongruentIt is hard to solve this problem at once, so at first, let us consider on k = 0, this easier case can be solved by enumerate on the ans. Let us define a bool array diff[], which diff[x] is weather there are two number, ai, aj, such that abs(ai - aj) = x.So ans is legal <=> diff[ans], diff[2*ans] … are false.The time-complexity O(n2 + mlogm). Here m is the maximum ai.Consider on k > 0, we need to know how many pairs which has difference x. Store them invector<pair <int, int> > diff[x];Then use a dsu to maintain the how many a_i are congruent when enumerate on the ans. Problem D. Rotatable Number Math, Number theory(Coming Soon...)http://codeforces.com/blog/entry/7499#comment-133342 Problem E. Random Ranking Math, Probability(Coming After D...)http://codeforces.com/blog/entry/7499#comment-133488",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/7641",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 2283
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #183 - Codeforces - Code 1",
          "code": "from datetime import date\n\na1 = map(int, raw_input().split(\":\"))\na2 = map(int, raw_input().split(\":\"))\n\nprint abs((date(a1[0], a1[1], a1[2]) - date(a2[0], a2[1], a2[2])).days)",
          "language": "Python",
          "source": "https://codeforces.com/blog/entry/7499",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #183 - Codeforces - Code 2",
          "code": "from datetime import date\n\na1 = map(int, raw_input().split(\":\"))\na2 = map(int, raw_input().split(\":\"))\n\nprint abs((date(a1[0], a1[1], a1[2]) - date(a2[0], a2[1], a2[2])).days)",
          "language": "Python",
          "source": "https://codeforces.com/blog/entry/7499",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #183 - Codeforces - Code 3",
          "code": "if (l[i] <= L && r[i] >= R)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7499",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #183 Editorial - Codeforces - Code 1",
          "code": "d = gcd(a,b)\na /= d\nb /= d\nt = min(n/a, m/b)\na *= t\nb *= t",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7641",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #183 Editorial - Codeforces - Code 2",
          "code": "d = gcd(a,b)\na /= d\nb /= d\nt = min(n/a, m/b)\na *= t\nb *= t",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7641",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #183 Editorial - Codeforces - Code 3",
          "code": "vector<pair <int, int> > diff[x];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7641",
          "author": "Qingyu"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 1000000000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 1000000000, \"m\");\n    inf.readSpace();\n    int x = inf.readInt(0, n, \"x\");\n    inf.readSpace();\n    int y = inf.readInt(0, m, \"y\");\n    inf.readSpace();\n    int a = inf.readInt(1, n, \"a\");\n    inf.readSpace();\n    int b = inf.readInt(1, m, \"b\");\n    inf.readEoln();\n    inf.readEof();\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 1000000000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 1000000000, \"m\");\n    inf.readSpace();\n    int x = inf.readInt(0, n, \"x\");\n    inf.readSpace();\n    int y = inf.readInt(0, m, \"y\");\n    inf.readSpace();\n    int a = inf.readInt(1, n, \"a\");\n    inf.readSpace();\n    int b = inf.readInt(1, m, \"b\");\n    inf.readEoln();\n    inf.readEof();\n\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 1000000000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 1000000000, \"m\");\n    inf.readSpace();\n    int x = inf.readInt(0, n, \"x\");\n    inf.readSpace();\n    int y = inf.readInt(0, m, \"y\");\n    inf.readSpace();\n    int a = inf.readInt(1, n, \"a\");\n    inf.readSpace();\n    int b = inf.readInt(1, m, \"b\");\n    inf.readEoln();\n    inf.readEof();\n\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    long long n = opt<long long>(\"n\");\n    long long m = opt<long long>(\"m\");\n    string type = opt<string>(\"type\", \"random\");\n\n    long long x, y, a, b;\n    if (type == \"random\") {\n        x = rnd.next(0LL, n);\n        y = rnd.next(0LL, m);\n        a = rnd.next(1LL, n);\n        b = rnd.next(1LL, m);\n    } else if (type == \"x0_y0\") {\n        x = 0;\n        y = 0;\n        a = rnd.next(1LL, n);\n        b = rnd.next(1LL, m);\n    } else if (type == \"x0_y_m\") {\n        x = 0;\n        y = m;\n        a = rnd.next(1LL, n);\n        b = rnd.next(1LL, m);\n    } else if (type == \"x_n_y0\") {\n        x = n;\n        y = 0;\n        a = rnd.next(1LL, n);\n        b = rnd.next(1LL, m);\n    } else if (type == \"x_n_y_m\") {\n        x = n;\n        y = m;\n        a = rnd.next(1LL, n);\n        b = rnd.next(1LL, m);\n    } else if (type == \"x_mid_y_mid\") {\n        x = n / 2;\n        y = m / 2;\n        a = rnd.next(1LL, n);\n        b = rnd.next(1LL, m);\n    } else if (type == \"a1_b1\") {\n        x = rnd.next(0LL, n);\n        y = rnd.next(0LL, m);\n        a = 1;\n        b = 1;\n    } else if (type == \"a_n_b_m\") {\n        x = rnd.next(0LL, n);\n        y = rnd.next(0LL, m);\n        a = n;\n        b = m;\n    } else if (type == \"max_area\") {\n        x = rnd.next(0LL, n);\n        y = rnd.next(0LL, m);\n        a = n;\n        b = m;\n    } else if (type == \"min_area\") {\n        x = rnd.next(0LL, n);\n        y = rnd.next(0LL, m);\n        a = 1;\n        b = 1;\n    } else if (type == \"square\") {\n        x = rnd.next(0LL, n);\n        y = rnd.next(0LL, m);\n        a = b = min(n, m);\n    } else {\n        // default to random\n        x = rnd.next(0LL, n);\n        y = rnd.next(0LL, m);\n        a = rnd.next(1LL, n);\n        b = rnd.next(1LL, m);\n    }\n\n    // Ensure a and b within limits\n    a = min(a, n);\n    b = min(b, m);\n\n    // Output\n    printf(\"%lld %lld %lld %lld %lld %lld\\n\", n, m, x, y, a, b);\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    long long n = opt<long long>(\"n\");\n    long long m = opt<long long>(\"m\");\n    string type = opt<string>(\"type\", \"random\");\n\n    long long x, y, a, b;\n    if (type == \"random\") {\n        x = rnd.next(0LL, n);\n        y = rnd.next(0LL, m);\n        a = rnd.next(1LL, n);\n        b = rnd.next(1LL, m);\n    } else if (type == \"x0_y0\") {\n        x = 0;\n        y = 0;\n        a = rnd.next(1LL, n);\n        b = rnd.next(1LL, m);\n    } else if (type == \"x0_y_m\") {\n        x = 0;\n        y = m;\n        a = rnd.next(1LL, n);\n        b = rnd.next(1LL, m);\n    } else if (type == \"x_n_y0\") {\n        x = n;\n        y = 0;\n        a = rnd.next(1LL, n);\n        b = rnd.next(1LL, m);\n    } else if (type == \"x_n_y_m\") {\n        x = n;\n        y = m;\n        a = rnd.next(1LL, n);\n        b = rnd.next(1LL, m);\n    } else if (type == \"x_mid_y_mid\") {\n        x = n / 2;\n        y = m / 2;\n        a = rnd.next(1LL, n);\n        b = rnd.next(1LL, m);\n    } else if (type == \"a1_b1\") {\n        x = rnd.next(0LL, n);\n        y = rnd.next(0LL, m);\n        a = 1;\n        b = 1;\n    } else if (type == \"a_n_b_m\") {\n        x = rnd.next(0LL, n);\n        y = rnd.next(0LL, m);\n        a = n;\n        b = m;\n    } else if (type == \"max_area\") {\n        x = rnd.next(0LL, n);\n        y = rnd.next(0LL, m);\n        a = n;\n        b = m;\n    } else if (type == \"min_area\") {\n        x = rnd.next(0LL, n);\n        y = rnd.next(0LL, m);\n        a = 1;\n        b = 1;\n    } else if (type == \"square\") {\n        x = rnd.next(0LL, n);\n        y = rnd.next(0LL, m);\n        a = b = min(n, m);\n    } else {\n        // default to random\n        x = rnd.next(0LL, n);\n        y = rnd.next(0LL, m);\n        a = rnd.next(1LL, n);\n        b = rnd.next(1LL, m);\n    }\n\n    // Ensure a and b within limits\n    a = min(a, n);\n    b = min(b, m);\n\n    // Output\n    printf(\"%lld %lld %lld %lld %lld %lld\\n\", n, m, x, y, a, b);\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -m 1 -type random\n./gen -n 1 -m 1 -type x0_y0\n./gen -n 1 -m 1 -type a1_b1\n\n./gen -n 10 -m 10 -type random\n./gen -n 10 -m 10 -type x0_y0\n./gen -n 10 -m 10 -type x_n_y_m\n./gen -n 10 -m 10 -type x_mid_y_mid\n./gen -n 10 -m 10 -type a_n_b_m\n./gen -n 10 -m 10 -type square\n\n./gen -n 1000 -m 1000 -type random\n./gen -n 1000 -m 1000 -type x0_y0\n./gen -n 1000 -m 1000 -type x_n_y_m\n./gen -n 1000 -m 1000 -type x_mid_y_mid\n./gen -n 1000 -m 1000 -type a_n_b_m\n./gen -n 1000 -m 1000 -type square\n\n./gen -n 1000000 -m 1000000 -type random\n./gen -n 1000000 -m 1000000 -type x0_y0\n./gen -n 1000000 -m 1000000 -type x_n_y_m\n./gen -n 1000000 -m 1000000 -type x_mid_y_mid\n./gen -n 1000000 -m 1000000 -type a_n_b_m\n./gen -n 1000000 -m 1000000 -type square\n\n./gen -n 1000000000 -m 1000000000 -type random\n./gen -n 1000000000 -m 1000000000 -type x0_y0\n./gen -n 1000000000 -m 1000000000 -type x_n_y_m\n./gen -n 1000000000 -m 1000000000 -type x_mid_y_mid\n./gen -n 1000000000 -m 1000000000 -type a_n_b_m\n./gen -n 1000000000 -m 1000000000 -type square\n\n./gen -n 1000000000 -m 1000000000 -type a1_b1\n./gen -n 1000000000 -m 1000000000 -type min_area\n./gen -n 1000000000 -m 1000000000 -type max_area\n./gen -n 1000000000 -m 1000000000 -type x0_y_m\n./gen -n 1000000000 -m 1000000000 -type x_n_y0\n\n./gen -n 999999937 -m 1000000007 -type random\n./gen -n 999999937 -m 1000000007 -type x_mid_y_mid\n./gen -n 999999937 -m 999999937 -type random\n./gen -n 999999937 -m 999999937 -type square\n\n./gen -n 10 -m 1000000000 -type random\n./gen -n 1000000000 -m 10 -type random\n\n./gen -n 500000000 -m 500000000 -type random\n./gen -n 1 -m 1000000000 -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:05:24.652552",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "303/C",
      "title": "C. Minimum Modular",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains two integers n and k (1  ≤ n  ≤ 5000, 0 ≤ k ≤ 4), which we have mentioned above. The second line contains n distinct integers a1, a2, ..., an (0 ≤ ai ≤ 106).",
      "output_spec": "OutputPrint a single positive integer — the minimum m.",
      "sample_tests": "ExamplesInputCopy7 00 2 3 6 7 12 18OutputCopy13InputCopy7 10 2 3 6 7 12 18OutputCopy7",
      "description": "C. Minimum Modular\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains two integers n and k (1  ≤ n  ≤ 5000, 0 ≤ k ≤ 4), which we have mentioned above. The second line contains n distinct integers a1, a2, ..., an (0 ≤ ai ≤ 106).\n\nOutputPrint a single positive integer — the minimum m.\n\nInputCopy7 00 2 3 6 7 12 18OutputCopy13InputCopy7 10 2 3 6 7 12 18OutputCopy7\n\nInputCopy7 00 2 3 6 7 12 18\n\nOutputCopy13\n\nInputCopy7 10 2 3 6 7 12 18\n\nOutputCopy7",
      "solutions": [
        {
          "title": "Codeforces Round #183 - Codeforces",
          "content": "Three drops in a line, back to yellow so quickly ...Anyway, Codeforces Round #183 will be take place on Sunday, May 12th at 17:00 MSK(21:00 CST). Right after the Google Code Jam Round 1C.Setters are: Yuzhou Gu sevenkplus (For Problem B && E) Yuping Luo roosephu (For Problem A && D) Jiatai Huang CMHJT (Problem C) Testers are YuukaKazami, havaliza, Velicue && me.We gratefully acknowledge Gerald Agapov(Gerald) for his help in giving advise about the problems, Delinur for her help in translating the problems to Russian, and MikeMirzayanov, who has designed such a powerful platform.We strongly recommend you to take a glance over all five problems, there must be one suitable to your taste.Oh one more thing, this time, scoring will be dynamic, but problems are sorted by increasing order of their difficulty as usual.Good Luck!",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/7499",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 830
        },
        {
          "title": "Codeforces Round #183 Editorial - Codeforces",
          "content": "Overview ...。。。(; Д ;) 。Tutorial ... Problem 2A. Pythagorean Theorem II Math, implementationThis problem can be solve by brute-force, but it come up with a nicer solution if we involve some math.Check the following article if you are interested.http://en.wikipedia.org/wiki/Pythagorean_triple#Generating_a_triple Problem 2B. Calender Math, implementationThis problem can be solve by brute-force, but it come up with a nicer solution if we involve some math.Check kabar's code if you are interested.http://codeforces.com/contest/304/submission/3715756 Problem A. Lucky Permutation Triple Math, Constructive algorithms, Congruent when n is odd, A[i] = B[i] = i when n is even, there is no solution. So why? Because: S = \\Sum_{i=0}^{n-1} i = n/2 (mod n) but 2*S = 0 (mod n)See also at:http://codeforces.com/blog/entry/7499#comment-133446 Problem B. Rectangle Puzzle II Math, GeometryGive you n, m, x, y, a, b.Find a maximum sub-rectangle within (0, 0) — (n, m), so that it contains the given point(x, y) and its length-width radio is exactly (a, b). If there are multiple solutions, find the rectangle which is closest to (x, y). If there are still multiple solutions, find the lexicographically minimum one.Split the problem into x-axis and y-axis. Then you can solve the sub tasks in O(1). d = gcd(a,b)\na /= d\nb /= d\nt = min(n/a, m/b)\na *= t\nb *= tBe careful, when the length is outside the original rectangle. Problem C. Minimum Modular Math, Graph theory, Brute-force, CongruentIt is hard to solve this problem at once, so at first, let us consider on k = 0, this easier case can be solved by enumerate on the ans. Let us define a bool array diff[], which diff[x] is weather there are two number, ai, aj, such that abs(ai - aj) = x.So ans is legal <=> diff[ans], diff[2*ans] … are false.The time-complexity O(n2 + mlogm). Here m is the maximum ai.Consider on k > 0, we need to know how many pairs which has difference x. Store them invector<pair <int, int> > diff[x];Then use a dsu to maintain the how many a_i are congruent when enumerate on the ans. Problem D. Rotatable Number Math, Number theory(Coming Soon...)http://codeforces.com/blog/entry/7499#comment-133342 Problem E. Random Ranking Math, Probability(Coming After D...)http://codeforces.com/blog/entry/7499#comment-133488",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/7641",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 2283
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #183 - Codeforces - Code 1",
          "code": "from datetime import date\n\na1 = map(int, raw_input().split(\":\"))\na2 = map(int, raw_input().split(\":\"))\n\nprint abs((date(a1[0], a1[1], a1[2]) - date(a2[0], a2[1], a2[2])).days)",
          "language": "Python",
          "source": "https://codeforces.com/blog/entry/7499",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #183 - Codeforces - Code 2",
          "code": "from datetime import date\n\na1 = map(int, raw_input().split(\":\"))\na2 = map(int, raw_input().split(\":\"))\n\nprint abs((date(a1[0], a1[1], a1[2]) - date(a2[0], a2[1], a2[2])).days)",
          "language": "Python",
          "source": "https://codeforces.com/blog/entry/7499",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #183 - Codeforces - Code 3",
          "code": "if (l[i] <= L && r[i] >= R)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7499",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #183 Editorial - Codeforces - Code 1",
          "code": "d = gcd(a,b)\na /= d\nb /= d\nt = min(n/a, m/b)\na *= t\nb *= t",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7641",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #183 Editorial - Codeforces - Code 2",
          "code": "d = gcd(a,b)\na /= d\nb /= d\nt = min(n/a, m/b)\na *= t\nb *= t",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7641",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #183 Editorial - Codeforces - Code 3",
          "code": "vector<pair <int, int> > diff[x];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7641",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 5000, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(0, 4, \"k\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, 0, 1000000, \"a_i\");\n    inf.readEoln();\n\n    set<int> s(a.begin(), a.end());\n    ensuref(s.size() == n, \"All elements in a_i must be distinct.\");\n\n    inf.readEof();\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 5000, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(0, 4, \"k\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, 0, 1000000, \"a_i\");\n    inf.readEoln();\n\n    set<int> s(a.begin(), a.end());\n    ensuref(s.size() == n, \"All elements in a_i must be distinct.\");\n\n    inf.readEof();\n\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 5000, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(0, 4, \"k\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, 0, 1000000, \"a_i\");\n    inf.readEoln();\n\n    set<int> s(a.begin(), a.end());\n    ensuref(s.size() == n, \"All elements in a_i must be distinct.\");\n\n    inf.readEof();\n\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int k = opt<int>(\"k\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> a(n);\n\n    if (type == \"random\") {\n        // Generate n distinct integers in range [0, 1e6]\n        set<int> used;\n        for (int i = 0; i < n; ++i) {\n            int x;\n            do {\n                x = rnd.next(0, 1000000);\n            } while (used.count(x));\n            used.insert(x);\n            a[i] = x;\n        }\n    } else if (type == \"small_m\") {\n        // Generate ai such that minimal m is small\n        // Alternate between two residues to force minimal m to be small\n        for (int i = 0; i < n; ++i) {\n            a[i] = (i % 2) + i * 2;\n        }\n    } else if (type == \"large_m\") {\n        // Generate ai such that minimal m is large\n        // Use large numbers to increase minimal m\n        int base = 1000000 - n * 2;\n        for (int i = 0; i < n; ++i) {\n            a[i] = base + i * 2;\n        }\n    } else if (type == \"duplicates_mod_m\") {\n        // Create ai such that there are duplicates modulo m\n        int m = opt<int>(\"m\", 10);\n        for (int i = 0; i < n; ++i) {\n            a[i] = (i % m) + rnd.next(0, 100000) * m;\n        }\n    } else if (type == \"minimal_m\") {\n        // Generate ai such that minimal m is 1\n        for (int i = 0; i < n; ++i) {\n            a[i] = i + 1;\n        }\n    } else if (type == \"max_ai\") {\n        // Generate ai with maximum values\n        for (int i = 0; i < n; ++i) {\n            a[i] = 1000000 - i;\n        }\n    } else if (type == \"small_n\") {\n        // n is minimal (n = 1 or 2)\n        n = opt<int>(\"n\", 1);\n        k = opt<int>(\"k\", 0);\n        a.resize(n);\n        set<int> used;\n        for (int i = 0; i < n; ++i) {\n            int x;\n            do {\n                x = rnd.next(0, 1000000);\n            } while (used.count(x));\n            used.insert(x);\n            a[i] = x;\n        }\n    } else {\n        // Default to random if type is unknown\n        set<int> used;\n        for (int i = 0; i < n; ++i) {\n            int x;\n            do {\n                x = rnd.next(0, 1000000);\n            } while (used.count(x));\n            used.insert(x);\n            a[i] = x;\n        }\n    }\n\n    // Shuffle ai\n    shuffle(a.begin(), a.end());\n\n    // Output n and k\n    printf(\"%d %d\\n\", n, k);\n    // Output ai\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d%c\", a[i], i == n -1 ? '\\n' : ' ');\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int k = opt<int>(\"k\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> a(n);\n\n    if (type == \"random\") {\n        // Generate n distinct integers in range [0, 1e6]\n        set<int> used;\n        for (int i = 0; i < n; ++i) {\n            int x;\n            do {\n                x = rnd.next(0, 1000000);\n            } while (used.count(x));\n            used.insert(x);\n            a[i] = x;\n        }\n    } else if (type == \"small_m\") {\n        // Generate ai such that minimal m is small\n        // Alternate between two residues to force minimal m to be small\n        for (int i = 0; i < n; ++i) {\n            a[i] = (i % 2) + i * 2;\n        }\n    } else if (type == \"large_m\") {\n        // Generate ai such that minimal m is large\n        // Use large numbers to increase minimal m\n        int base = 1000000 - n * 2;\n        for (int i = 0; i < n; ++i) {\n            a[i] = base + i * 2;\n        }\n    } else if (type == \"duplicates_mod_m\") {\n        // Create ai such that there are duplicates modulo m\n        int m = opt<int>(\"m\", 10);\n        for (int i = 0; i < n; ++i) {\n            a[i] = (i % m) + rnd.next(0, 100000) * m;\n        }\n    } else if (type == \"minimal_m\") {\n        // Generate ai such that minimal m is 1\n        for (int i = 0; i < n; ++i) {\n            a[i] = i + 1;\n        }\n    } else if (type == \"max_ai\") {\n        // Generate ai with maximum values\n        for (int i = 0; i < n; ++i) {\n            a[i] = 1000000 - i;\n        }\n    } else if (type == \"small_n\") {\n        // n is minimal (n = 1 or 2)\n        n = opt<int>(\"n\", 1);\n        k = opt<int>(\"k\", 0);\n        a.resize(n);\n        set<int> used;\n        for (int i = 0; i < n; ++i) {\n            int x;\n            do {\n                x = rnd.next(0, 1000000);\n            } while (used.count(x));\n            used.insert(x);\n            a[i] = x;\n        }\n    } else {\n        // Default to random if type is unknown\n        set<int> used;\n        for (int i = 0; i < n; ++i) {\n            int x;\n            do {\n                x = rnd.next(0, 1000000);\n            } while (used.count(x));\n            used.insert(x);\n            a[i] = x;\n        }\n    }\n\n    // Shuffle ai\n    shuffle(a.begin(), a.end());\n\n    // Output n and k\n    printf(\"%d %d\\n\", n, k);\n    // Output ai\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d%c\", a[i], i == n -1 ? '\\n' : ' ');\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 7 -k 0 -type random\n./gen -n 7 -k 1 -type random\n./gen -n 10 -k 0 -type small_m\n./gen -n 10 -k 0 -type large_m\n./gen -n 10 -k 4 -type duplicates_mod_m -m 3\n./gen -n 100 -k 4 -type random\n./gen -n 5000 -k 4 -type random\n./gen -n 5000 -k 0 -type small_m\n./gen -n 5000 -k 2 -type large_m\n./gen -n 5000 -k 4 -type duplicates_mod_m -m 5\n./gen -n 5000 -k 4 -type duplicates_mod_m -m 1\n./gen -n 5000 -k 0 -type duplicates_mod_m -m 1000\n./gen -n 1 -k 0 -type small_n\n./gen -n 2 -k 0 -type small_n\n./gen -n 5000 -k 4 -type minimal_m\n./gen -n 5000 -k 4 -type max_ai\n./gen -n 5000 -k 4 -type small_m\n./gen -n 5000 -k 4 -type large_m\n./gen -n 5000 -k 0 -type minimal_m\n./gen -n 1000 -k 2 -type random\n./gen -n 1000 -k 0 -type duplicates_mod_m -m 2\n./gen -n 5000 -k 4 -type duplicates_mod_m -m 2\n./gen -n 2500 -k 0 -type duplicates_mod_m -m 3\n./gen -n 500 -k 0 -type minimal_m\n./gen -n 500 -k 4 -type large_m\n./gen -n 5000 -k 4 -type max_n\n./gen -n 5000 -k 0 -type max_n\n./gen -n 1 -k 4 -type small_n\n./gen -n 2 -k 4 -type small_n\n./gen -n 5000 -k 4 -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:05:26.233424",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "303/D",
      "title": "D. Rotatable Number",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe only line contains two space-separated integers n, x (1 ≤ n ≤ 5·106, 2 ≤ x ≤ 109).",
      "output_spec": "OutputPrint a single integer — the largest b you found. If no such b exists, print -1 instead.",
      "sample_tests": "ExamplesInputCopy6 11OutputCopy10InputCopy5 8OutputCopy-1",
      "description": "D. Rotatable Number\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe only line contains two space-separated integers n, x (1 ≤ n ≤ 5·106, 2 ≤ x ≤ 109).\n\nOutputPrint a single integer — the largest b you found. If no such b exists, print -1 instead.\n\nInputCopy6 11OutputCopy10InputCopy5 8OutputCopy-1\n\nInputCopy6 11\n\nOutputCopy10\n\nInputCopy5 8\n\nOutputCopy-1",
      "solutions": [
        {
          "title": "Codeforces Round #183 - Codeforces",
          "content": "Three drops in a line, back to yellow so quickly ...Anyway, Codeforces Round #183 will be take place on Sunday, May 12th at 17:00 MSK(21:00 CST). Right after the Google Code Jam Round 1C.Setters are: Yuzhou Gu sevenkplus (For Problem B && E) Yuping Luo roosephu (For Problem A && D) Jiatai Huang CMHJT (Problem C) Testers are YuukaKazami, havaliza, Velicue && me.We gratefully acknowledge Gerald Agapov(Gerald) for his help in giving advise about the problems, Delinur for her help in translating the problems to Russian, and MikeMirzayanov, who has designed such a powerful platform.We strongly recommend you to take a glance over all five problems, there must be one suitable to your taste.Oh one more thing, this time, scoring will be dynamic, but problems are sorted by increasing order of their difficulty as usual.Good Luck!",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/7499",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 830
        },
        {
          "title": "Codeforces Round #183 Editorial - Codeforces",
          "content": "Overview ...。。。(; Д ;) 。Tutorial ... Problem 2A. Pythagorean Theorem II Math, implementationThis problem can be solve by brute-force, but it come up with a nicer solution if we involve some math.Check the following article if you are interested.http://en.wikipedia.org/wiki/Pythagorean_triple#Generating_a_triple Problem 2B. Calender Math, implementationThis problem can be solve by brute-force, but it come up with a nicer solution if we involve some math.Check kabar's code if you are interested.http://codeforces.com/contest/304/submission/3715756 Problem A. Lucky Permutation Triple Math, Constructive algorithms, Congruent when n is odd, A[i] = B[i] = i when n is even, there is no solution. So why? Because: S = \\Sum_{i=0}^{n-1} i = n/2 (mod n) but 2*S = 0 (mod n)See also at:http://codeforces.com/blog/entry/7499#comment-133446 Problem B. Rectangle Puzzle II Math, GeometryGive you n, m, x, y, a, b.Find a maximum sub-rectangle within (0, 0) — (n, m), so that it contains the given point(x, y) and its length-width radio is exactly (a, b). If there are multiple solutions, find the rectangle which is closest to (x, y). If there are still multiple solutions, find the lexicographically minimum one.Split the problem into x-axis and y-axis. Then you can solve the sub tasks in O(1). d = gcd(a,b)\na /= d\nb /= d\nt = min(n/a, m/b)\na *= t\nb *= tBe careful, when the length is outside the original rectangle. Problem C. Minimum Modular Math, Graph theory, Brute-force, CongruentIt is hard to solve this problem at once, so at first, let us consider on k = 0, this easier case can be solved by enumerate on the ans. Let us define a bool array diff[], which diff[x] is weather there are two number, ai, aj, such that abs(ai - aj) = x.So ans is legal <=> diff[ans], diff[2*ans] … are false.The time-complexity O(n2 + mlogm). Here m is the maximum ai.Consider on k > 0, we need to know how many pairs which has difference x. Store them invector<pair <int, int> > diff[x];Then use a dsu to maintain the how many a_i are congruent when enumerate on the ans. Problem D. Rotatable Number Math, Number theory(Coming Soon...)http://codeforces.com/blog/entry/7499#comment-133342 Problem E. Random Ranking Math, Probability(Coming After D...)http://codeforces.com/blog/entry/7499#comment-133488",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/7641",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 2283
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #183 - Codeforces - Code 1",
          "code": "from datetime import date\n\na1 = map(int, raw_input().split(\":\"))\na2 = map(int, raw_input().split(\":\"))\n\nprint abs((date(a1[0], a1[1], a1[2]) - date(a2[0], a2[1], a2[2])).days)",
          "language": "Python",
          "source": "https://codeforces.com/blog/entry/7499",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #183 - Codeforces - Code 2",
          "code": "from datetime import date\n\na1 = map(int, raw_input().split(\":\"))\na2 = map(int, raw_input().split(\":\"))\n\nprint abs((date(a1[0], a1[1], a1[2]) - date(a2[0], a2[1], a2[2])).days)",
          "language": "Python",
          "source": "https://codeforces.com/blog/entry/7499",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #183 - Codeforces - Code 3",
          "code": "if (l[i] <= L && r[i] >= R)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7499",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #183 Editorial - Codeforces - Code 1",
          "code": "d = gcd(a,b)\na /= d\nb /= d\nt = min(n/a, m/b)\na *= t\nb *= t",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7641",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #183 Editorial - Codeforces - Code 2",
          "code": "d = gcd(a,b)\na /= d\nb /= d\nt = min(n/a, m/b)\na *= t\nb *= t",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7641",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #183 Editorial - Codeforces - Code 3",
          "code": "vector<pair <int, int> > diff[x];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7641",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 5000000, \"n\");\n    inf.readSpace();\n    int x = inf.readInt(2, 1000000000, \"x\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 5000000, \"n\");\n    inf.readSpace();\n    int x = inf.readInt(2, 1000000000, \"x\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 5000000, \"n\");\n    inf.readSpace();\n    int x = inf.readInt(2, 1000000000, \"x\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n_max = int(5e6);\n    int x_max = int(1e9);\n\n    int n = opt<int>(\"n\", -1);\n    int x = opt<int>(\"x\", -1);\n    string type = opt<string>(\"type\", \"random\");\n\n    if (type == \"random\") {\n        if (n == -1) n = rnd.next(1, n_max);\n        if (x == -1) x = rnd.next(2, x_max);\n    } else if (type == \"max\") {\n        n = n_max;\n        x = x_max;\n    } else if (type == \"min\") {\n        n = 1;\n        x = 2;\n    } else if (type == \"small\") {\n        n = rnd.next(1, 10);\n        x = rnd.next(2, 100);\n    } else if (type == \"edge_n\") {\n        n = 1;\n        x = rnd.next(2, x_max);\n    } else if (type == \"edge_x\") {\n        n = rnd.next(1, n_max);\n        x = 2;\n    } else if (type == \"fixed\") {\n        ensure(n != -1 && x != -1);\n    } else if (type == \"special\") {\n        /* Generate specific edge cases */\n        n = n_max;\n        x = 2;\n    } else {\n        /* Default random */\n        if (n == -1) n = rnd.next(1, n_max);\n        if (x == -1) x = rnd.next(2, x_max);\n    }\n\n    ensure(1 <= n && n <= n_max);\n    ensure(2 <= x && x <= x_max);\n\n    printf(\"%d %d\\n\", n, x);\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n_max = int(5e6);\n    int x_max = int(1e9);\n\n    int n = opt<int>(\"n\", -1);\n    int x = opt<int>(\"x\", -1);\n    string type = opt<string>(\"type\", \"random\");\n\n    if (type == \"random\") {\n        if (n == -1) n = rnd.next(1, n_max);\n        if (x == -1) x = rnd.next(2, x_max);\n    } else if (type == \"max\") {\n        n = n_max;\n        x = x_max;\n    } else if (type == \"min\") {\n        n = 1;\n        x = 2;\n    } else if (type == \"small\") {\n        n = rnd.next(1, 10);\n        x = rnd.next(2, 100);\n    } else if (type == \"edge_n\") {\n        n = 1;\n        x = rnd.next(2, x_max);\n    } else if (type == \"edge_x\") {\n        n = rnd.next(1, n_max);\n        x = 2;\n    } else if (type == \"fixed\") {\n        ensure(n != -1 && x != -1);\n    } else if (type == \"special\") {\n        /* Generate specific edge cases */\n        n = n_max;\n        x = 2;\n    } else {\n        /* Default random */\n        if (n == -1) n = rnd.next(1, n_max);\n        if (x == -1) x = rnd.next(2, x_max);\n    }\n\n    ensure(1 <= n && n <= n_max);\n    ensure(2 <= x && x <= x_max);\n\n    printf(\"%d %d\\n\", n, x);\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -type min\n./gen -type max\n./gen -type small\n./gen -type small\n./gen -type small\n./gen -type small\n./gen -type random\n./gen -type random\n./gen -type random\n./gen -type random\n./gen -type random\n./gen -type edge_n\n./gen -type edge_x\n./gen -type fixed -n 1 -x 2\n./gen -type fixed -n 5000000 -x 1000000000\n./gen -type fixed -n 1 -x 1000000000\n./gen -type fixed -n 5000000 -x 2\n./gen -type fixed -n 5000000 -x 999999999\n./gen -type fixed -n 1 -x 999999999\n./gen -type fixed -n 100 -x 100\n./gen -type fixed -n 1000 -x 1000\n./gen -type fixed -n 100000 -x 1000000\n./gen -type fixed -n 1234567 -x 7654321\n./gen -type fixed -n 5 -x 8\n./gen -type fixed -n 6 -x 11\n./gen -type special\n./gen -type special\n./gen -type special\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:05:28.122115",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "303/E",
      "title": "E. Random Ranking",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains integer n (1  ≤ n  ≤ 80), showing how many participants we have. Each of the next n lines contains our predictions, the i-th line contains a pair of integers li, ri (0 ≤ li < ri ≤ 109) as the distributed interval for participant i.Consider the participants numbered from 1 to n in some way.",
      "output_spec": "OutputOutput a distributed matrix a of order n. The element aij of the matrix is the probability that participant i has rank j.Your answer will considered correct if it has at most 10 - 6 absolute or relative error.",
      "sample_tests": "ExamplesInputCopy21 64 9OutputCopy0.9200000000 0.080 0.080 0.9200000000 InputCopy80 21 32 43 54 65 76 87 9OutputCopy0.875 0.125 0 0 0 0 0 0 0.125 0.750 0.125 0 0 0 0 0 0 0.125 0.750 0.125 0 0 0 0 0 0 0.125 0.750 0.125 0 0 0 0 0 0 0.125 0.750 0.125 0 0 0 0 0 0 0.125 0.750 0.125 0 0 0 0 0 0 0.125 0.750 0.125 0 0 0 0 0 0 0.125 0.875",
      "description": "E. Random Ranking\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains integer n (1  ≤ n  ≤ 80), showing how many participants we have. Each of the next n lines contains our predictions, the i-th line contains a pair of integers li, ri (0 ≤ li < ri ≤ 109) as the distributed interval for participant i.Consider the participants numbered from 1 to n in some way.\n\nOutputOutput a distributed matrix a of order n. The element aij of the matrix is the probability that participant i has rank j.Your answer will considered correct if it has at most 10 - 6 absolute or relative error.\n\nInputCopy21 64 9OutputCopy0.9200000000 0.080 0.080 0.9200000000 InputCopy80 21 32 43 54 65 76 87 9OutputCopy0.875 0.125 0 0 0 0 0 0 0.125 0.750 0.125 0 0 0 0 0 0 0.125 0.750 0.125 0 0 0 0 0 0 0.125 0.750 0.125 0 0 0 0 0 0 0.125 0.750 0.125 0 0 0 0 0 0 0.125 0.750 0.125 0 0 0 0 0 0 0.125 0.750 0.125 0 0 0 0 0 0 0.125 0.875\n\nInputCopy21 64 9\n\nOutputCopy0.9200000000 0.080 0.080 0.9200000000\n\nInputCopy80 21 32 43 54 65 76 87 9\n\nOutputCopy0.875 0.125 0 0 0 0 0 0 0.125 0.750 0.125 0 0 0 0 0 0 0.125 0.750 0.125 0 0 0 0 0 0 0.125 0.750 0.125 0 0 0 0 0 0 0.125 0.750 0.125 0 0 0 0 0 0 0.125 0.750 0.125 0 0 0 0 0 0 0.125 0.750 0.125 0 0 0 0 0 0 0.125 0.875\n\nNoteThe score probability distribution is continuous, which means, there is no possibility for a draw.",
      "solutions": [
        {
          "title": "Codeforces Round #183 - Codeforces",
          "content": "Three drops in a line, back to yellow so quickly ...Anyway, Codeforces Round #183 will be take place on Sunday, May 12th at 17:00 MSK(21:00 CST). Right after the Google Code Jam Round 1C.Setters are: Yuzhou Gu sevenkplus (For Problem B && E) Yuping Luo roosephu (For Problem A && D) Jiatai Huang CMHJT (Problem C) Testers are YuukaKazami, havaliza, Velicue && me.We gratefully acknowledge Gerald Agapov(Gerald) for his help in giving advise about the problems, Delinur for her help in translating the problems to Russian, and MikeMirzayanov, who has designed such a powerful platform.We strongly recommend you to take a glance over all five problems, there must be one suitable to your taste.Oh one more thing, this time, scoring will be dynamic, but problems are sorted by increasing order of their difficulty as usual.Good Luck!",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/7499",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 830
        },
        {
          "title": "Codeforces Round #183 Editorial - Codeforces",
          "content": "Overview ...。。。(; Д ;) 。Tutorial ... Problem 2A. Pythagorean Theorem II Math, implementationThis problem can be solve by brute-force, but it come up with a nicer solution if we involve some math.Check the following article if you are interested.http://en.wikipedia.org/wiki/Pythagorean_triple#Generating_a_triple Problem 2B. Calender Math, implementationThis problem can be solve by brute-force, but it come up with a nicer solution if we involve some math.Check kabar's code if you are interested.http://codeforces.com/contest/304/submission/3715756 Problem A. Lucky Permutation Triple Math, Constructive algorithms, Congruent when n is odd, A[i] = B[i] = i when n is even, there is no solution. So why? Because: S = \\Sum_{i=0}^{n-1} i = n/2 (mod n) but 2*S = 0 (mod n)See also at:http://codeforces.com/blog/entry/7499#comment-133446 Problem B. Rectangle Puzzle II Math, GeometryGive you n, m, x, y, a, b.Find a maximum sub-rectangle within (0, 0) — (n, m), so that it contains the given point(x, y) and its length-width radio is exactly (a, b). If there are multiple solutions, find the rectangle which is closest to (x, y). If there are still multiple solutions, find the lexicographically minimum one.Split the problem into x-axis and y-axis. Then you can solve the sub tasks in O(1). d = gcd(a,b)\na /= d\nb /= d\nt = min(n/a, m/b)\na *= t\nb *= tBe careful, when the length is outside the original rectangle. Problem C. Minimum Modular Math, Graph theory, Brute-force, CongruentIt is hard to solve this problem at once, so at first, let us consider on k = 0, this easier case can be solved by enumerate on the ans. Let us define a bool array diff[], which diff[x] is weather there are two number, ai, aj, such that abs(ai - aj) = x.So ans is legal <=> diff[ans], diff[2*ans] … are false.The time-complexity O(n2 + mlogm). Here m is the maximum ai.Consider on k > 0, we need to know how many pairs which has difference x. Store them invector<pair <int, int> > diff[x];Then use a dsu to maintain the how many a_i are congruent when enumerate on the ans. Problem D. Rotatable Number Math, Number theory(Coming Soon...)http://codeforces.com/blog/entry/7499#comment-133342 Problem E. Random Ranking Math, Probability(Coming After D...)http://codeforces.com/blog/entry/7499#comment-133488",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/7641",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 2283
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #183 - Codeforces - Code 1",
          "code": "from datetime import date\n\na1 = map(int, raw_input().split(\":\"))\na2 = map(int, raw_input().split(\":\"))\n\nprint abs((date(a1[0], a1[1], a1[2]) - date(a2[0], a2[1], a2[2])).days)",
          "language": "Python",
          "source": "https://codeforces.com/blog/entry/7499",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #183 - Codeforces - Code 2",
          "code": "from datetime import date\n\na1 = map(int, raw_input().split(\":\"))\na2 = map(int, raw_input().split(\":\"))\n\nprint abs((date(a1[0], a1[1], a1[2]) - date(a2[0], a2[1], a2[2])).days)",
          "language": "Python",
          "source": "https://codeforces.com/blog/entry/7499",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #183 - Codeforces - Code 3",
          "code": "if (l[i] <= L && r[i] >= R)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7499",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #183 Editorial - Codeforces - Code 1",
          "code": "d = gcd(a,b)\na /= d\nb /= d\nt = min(n/a, m/b)\na *= t\nb *= t",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7641",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #183 Editorial - Codeforces - Code 2",
          "code": "d = gcd(a,b)\na /= d\nb /= d\nt = min(n/a, m/b)\na *= t\nb *= t",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7641",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #183 Editorial - Codeforces - Code 3",
          "code": "vector<pair <int, int> > diff[x];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7641",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 80, \"n\");\n    inf.readEoln();\n\n    for (int i = 1; i <= n; ++i) {\n        int li = inf.readInt(0, 1000000000, \"li\");\n        inf.readSpace();\n        int ri = inf.readInt(0, 1000000000, \"ri\");\n        inf.readEoln();\n\n        ensuref(li < ri, \"For participant %d, li (%d) must be less than ri (%d)\", i, li, ri);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 80, \"n\");\n    inf.readEoln();\n\n    for (int i = 1; i <= n; ++i) {\n        int li = inf.readInt(0, 1000000000, \"li\");\n        inf.readSpace();\n        int ri = inf.readInt(0, 1000000000, \"ri\");\n        inf.readEoln();\n\n        ensuref(li < ri, \"For participant %d, li (%d) must be less than ri (%d)\", i, li, ri);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 80, \"n\");\n    inf.readEoln();\n\n    for (int i = 1; i <= n; ++i) {\n        int li = inf.readInt(0, 1000000000, \"li\");\n        inf.readSpace();\n        int ri = inf.readInt(0, 1000000000, \"ri\");\n        inf.readEoln();\n\n        ensuref(li < ri, \"For participant %d, li (%d) must be less than ri (%d)\", i, li, ri);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nconst double EPS = 1E-6;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare two sequences of doubles, max absolute or relative  error = %.7f\", EPS);\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    double j = 0, p = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        n++;\r\n        j = ans.readDouble();\r\n        p = ouf.readDouble();\r\n        if (!doubleCompare(j, p, EPS)) {\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%.7f', found: '%.7f', error = '%.7f'\",\r\n                  n, englishEnding(n).c_str(), j, p, doubleDelta(j, p));\r\n        }\r\n    }\r\n\r\n    if (n == 1)\r\n        quitf(_ok, \"found '%.7f', expected '%.7f', error '%.7f'\", p, j, doubleDelta(j, p));\r\n\r\n    quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> l(n), r(n);\n\n    if (type == \"random\") {\n        // Generate random intervals within [0, 1e9]\n        for(int i = 0; i < n; ++i) {\n            int a = rnd.next(0, int(1e9) - 1);\n            int b = rnd.next(a + 1, int(1e9));\n            l[i] = a;\n            r[i] = b;\n        }\n    } else if (type == \"all_same\") {\n        // All participants have the same interval\n        int a = rnd.next(0, int(1e9) - 1);\n        int b = rnd.next(a + 1, int(1e9));\n        for(int i = 0; i < n; ++i) {\n            l[i] = a;\n            r[i] = b;\n        }\n    } else if (type == \"non_overlapping_ordered\") {\n        // Non-overlapping intervals, ordered\n        int total_range = int(1e9);\n        int interval_size = total_range / n;\n        int start = 0;\n        for(int i = 0; i < n; ++i) {\n            l[i] = start;\n            r[i] = start + interval_size - 1;\n            start += interval_size;\n        }\n    } else if (type == \"non_overlapping_random\") {\n        // Non-overlapping intervals, shuffled\n        int total_range = int(1e9);\n        int interval_size = total_range / n;\n        vector<pair<int, int>> intervals;\n        int start = 0;\n        for(int i = 0; i < n; ++i) {\n            int a = start;\n            int b = start + interval_size - 1;\n            intervals.push_back({a, b});\n            start += interval_size;\n        }\n        shuffle(intervals.begin(), intervals.end());\n        for(int i = 0; i < n; ++i) {\n            l[i] = intervals[i].first;\n            r[i] = intervals[i].second;\n        }\n    } else if (type == \"one_dominant\") {\n        // One participant has a different interval\n        // Participant 1 has a low interval, others have high intervals\n        l[0] = rnd.next(0, int(1e9) / 2 - 1);\n        r[0] = rnd.next(l[0] + 1, int(1e9) / 2);\n        for(int i = 1; i < n; ++i) {\n            l[i] = rnd.next(int(1e9) / 2, int(1e9) - 1);\n            r[i] = rnd.next(l[i] + 1, int(1e9));\n        }\n    } else if (type == \"small_ranges\") {\n        // Intervals are very small\n        for(int i = 0; i < n; ++i) {\n            int a = rnd.next(0, int(1e9) - 2);\n            l[i] = a;\n            r[i] = a + 1; // l_i and r_i differ by 1\n        }\n    } else if (type == \"large_ranges\") {\n        // Intervals cover the whole range\n        for(int i = 0; i < n; ++i) {\n            l[i] = 0;\n            r[i] = int(1e9);\n        }\n    } else {\n        // Default to random intervals\n        for(int i = 0; i < n; ++i) {\n            int a = rnd.next(0, int(1e9) - 1);\n            int b = rnd.next(a + 1, int(1e9));\n            l[i] = a;\n            r[i] = b;\n        }\n    }\n\n    // Output the test case\n    printf(\"%d\\n\", n);\n    for(int i = 0; i < n; ++i) {\n        printf(\"%d %d\\n\", l[i], r[i]);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> l(n), r(n);\n\n    if (type == \"random\") {\n        // Generate random intervals within [0, 1e9]\n        for(int i = 0; i < n; ++i) {\n            int a = rnd.next(0, int(1e9) - 1);\n            int b = rnd.next(a + 1, int(1e9));\n            l[i] = a;\n            r[i] = b;\n        }\n    } else if (type == \"all_same\") {\n        // All participants have the same interval\n        int a = rnd.next(0, int(1e9) - 1);\n        int b = rnd.next(a + 1, int(1e9));\n        for(int i = 0; i < n; ++i) {\n            l[i] = a;\n            r[i] = b;\n        }\n    } else if (type == \"non_overlapping_ordered\") {\n        // Non-overlapping intervals, ordered\n        int total_range = int(1e9);\n        int interval_size = total_range / n;\n        int start = 0;\n        for(int i = 0; i < n; ++i) {\n            l[i] = start;\n            r[i] = start + interval_size - 1;\n            start += interval_size;\n        }\n    } else if (type == \"non_overlapping_random\") {\n        // Non-overlapping intervals, shuffled\n        int total_range = int(1e9);\n        int interval_size = total_range / n;\n        vector<pair<int, int>> intervals;\n        int start = 0;\n        for(int i = 0; i < n; ++i) {\n            int a = start;\n            int b = start + interval_size - 1;\n            intervals.push_back({a, b});\n            start += interval_size;\n        }\n        shuffle(intervals.begin(), intervals.end());\n        for(int i = 0; i < n; ++i) {\n            l[i] = intervals[i].first;\n            r[i] = intervals[i].second;\n        }\n    } else if (type == \"one_dominant\") {\n        // One participant has a different interval\n        // Participant 1 has a low interval, others have high intervals\n        l[0] = rnd.next(0, int(1e9) / 2 - 1);\n        r[0] = rnd.next(l[0] + 1, int(1e9) / 2);\n        for(int i = 1; i < n; ++i) {\n            l[i] = rnd.next(int(1e9) / 2, int(1e9) - 1);\n            r[i] = rnd.next(l[i] + 1, int(1e9));\n        }\n    } else if (type == \"small_ranges\") {\n        // Intervals are very small\n        for(int i = 0; i < n; ++i) {\n            int a = rnd.next(0, int(1e9) - 2);\n            l[i] = a;\n            r[i] = a + 1; // l_i and r_i differ by 1\n        }\n    } else if (type == \"large_ranges\") {\n        // Intervals cover the whole range\n        for(int i = 0; i < n; ++i) {\n            l[i] = 0;\n            r[i] = int(1e9);\n        }\n    } else {\n        // Default to random intervals\n        for(int i = 0; i < n; ++i) {\n            int a = rnd.next(0, int(1e9) - 1);\n            int b = rnd.next(a + 1, int(1e9));\n            l[i] = a;\n            r[i] = b;\n        }\n    }\n\n    // Output the test case\n    printf(\"%d\\n\", n);\n    for(int i = 0; i < n; ++i) {\n        printf(\"%d %d\\n\", l[i], r[i]);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -type random\n./gen -n 2 -type random\n./gen -n 3 -type all_same\n./gen -n 4 -type non_overlapping_ordered\n./gen -n 5 -type non_overlapping_random\n./gen -n 6 -type one_dominant\n./gen -n 7 -type small_ranges\n./gen -n 8 -type large_ranges\n\n./gen -n 10 -type random\n./gen -n 10 -type all_same\n./gen -n 10 -type non_overlapping_ordered\n./gen -n 10 -type non_overlapping_random\n./gen -n 10 -type one_dominant\n./gen -n 10 -type small_ranges\n./gen -n 10 -type large_ranges\n\n./gen -n 20 -type random\n./gen -n 30 -type random\n./gen -n 40 -type random\n./gen -n 50 -type random\n./gen -n 60 -type random\n./gen -n 70 -type random\n\n./gen -n 80 -type random\n./gen -n 80 -type all_same\n./gen -n 80 -type non_overlapping_ordered\n./gen -n 80 -type non_overlapping_random\n./gen -n 80 -type one_dominant\n./gen -n 80 -type small_ranges\n./gen -n 80 -type large_ranges\n\n./gen -n 1 -type all_same\n./gen -n 80 -type small_ranges\n./gen -n 80 -type large_ranges\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:05:29.831661",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "304/A",
      "title": "A. Pythagorean Theorem II",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test3 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe only line contains one integer n (1 ≤ n ≤ 104) as we mentioned above.",
      "output_spec": "OutputPrint a single integer — the answer to the problem.",
      "sample_tests": "ExamplesInputCopy5OutputCopy1InputCopy74OutputCopy35",
      "description": "A. Pythagorean Theorem II\n\ntime limit per test3 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe only line contains one integer n (1 ≤ n ≤ 104) as we mentioned above.\n\nOutputPrint a single integer — the answer to the problem.\n\nInputCopy5OutputCopy1InputCopy74OutputCopy35\n\nOutputCopy1\n\nInputCopy74\n\nOutputCopy35",
      "solutions": [
        {
          "title": "Codeforces Round #183 - Codeforces",
          "content": "Three drops in a line, back to yellow so quickly ...Anyway, Codeforces Round #183 will be take place on Sunday, May 12th at 17:00 MSK(21:00 CST). Right after the Google Code Jam Round 1C.Setters are: Yuzhou Gu sevenkplus (For Problem B && E) Yuping Luo roosephu (For Problem A && D) Jiatai Huang CMHJT (Problem C) Testers are YuukaKazami, havaliza, Velicue && me.We gratefully acknowledge Gerald Agapov(Gerald) for his help in giving advise about the problems, Delinur for her help in translating the problems to Russian, and MikeMirzayanov, who has designed such a powerful platform.We strongly recommend you to take a glance over all five problems, there must be one suitable to your taste.Oh one more thing, this time, scoring will be dynamic, but problems are sorted by increasing order of their difficulty as usual.Good Luck!",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/7499",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 830
        },
        {
          "title": "Codeforces Round #183 Editorial - Codeforces",
          "content": "Overview ...。。。(; Д ;) 。Tutorial ... Problem 2A. Pythagorean Theorem II Math, implementationThis problem can be solve by brute-force, but it come up with a nicer solution if we involve some math.Check the following article if you are interested.http://en.wikipedia.org/wiki/Pythagorean_triple#Generating_a_triple Problem 2B. Calender Math, implementationThis problem can be solve by brute-force, but it come up with a nicer solution if we involve some math.Check kabar's code if you are interested.http://codeforces.com/contest/304/submission/3715756 Problem A. Lucky Permutation Triple Math, Constructive algorithms, Congruent when n is odd, A[i] = B[i] = i when n is even, there is no solution. So why? Because: S = \\Sum_{i=0}^{n-1} i = n/2 (mod n) but 2*S = 0 (mod n)See also at:http://codeforces.com/blog/entry/7499#comment-133446 Problem B. Rectangle Puzzle II Math, GeometryGive you n, m, x, y, a, b.Find a maximum sub-rectangle within (0, 0) — (n, m), so that it contains the given point(x, y) and its length-width radio is exactly (a, b). If there are multiple solutions, find the rectangle which is closest to (x, y). If there are still multiple solutions, find the lexicographically minimum one.Split the problem into x-axis and y-axis. Then you can solve the sub tasks in O(1). d = gcd(a,b)\na /= d\nb /= d\nt = min(n/a, m/b)\na *= t\nb *= tBe careful, when the length is outside the original rectangle. Problem C. Minimum Modular Math, Graph theory, Brute-force, CongruentIt is hard to solve this problem at once, so at first, let us consider on k = 0, this easier case can be solved by enumerate on the ans. Let us define a bool array diff[], which diff[x] is weather there are two number, ai, aj, such that abs(ai - aj) = x.So ans is legal <=> diff[ans], diff[2*ans] … are false.The time-complexity O(n2 + mlogm). Here m is the maximum ai.Consider on k > 0, we need to know how many pairs which has difference x. Store them invector<pair <int, int> > diff[x];Then use a dsu to maintain the how many a_i are congruent when enumerate on the ans. Problem D. Rotatable Number Math, Number theory(Coming Soon...)http://codeforces.com/blog/entry/7499#comment-133342 Problem E. Random Ranking Math, Probability(Coming After D...)http://codeforces.com/blog/entry/7499#comment-133488",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/7641",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.6,
            "reason": "宽松匹配: 包含题目编号 304 和字母"
          },
          "content_length": 2283
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #183 - Codeforces - Code 1",
          "code": "from datetime import date\n\na1 = map(int, raw_input().split(\":\"))\na2 = map(int, raw_input().split(\":\"))\n\nprint abs((date(a1[0], a1[1], a1[2]) - date(a2[0], a2[1], a2[2])).days)",
          "language": "Python",
          "source": "https://codeforces.com/blog/entry/7499",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #183 - Codeforces - Code 2",
          "code": "from datetime import date\n\na1 = map(int, raw_input().split(\":\"))\na2 = map(int, raw_input().split(\":\"))\n\nprint abs((date(a1[0], a1[1], a1[2]) - date(a2[0], a2[1], a2[2])).days)",
          "language": "Python",
          "source": "https://codeforces.com/blog/entry/7499",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #183 - Codeforces - Code 3",
          "code": "if (l[i] <= L && r[i] >= R)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7499",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #183 Editorial - Codeforces - Code 1",
          "code": "d = gcd(a,b)\na /= d\nb /= d\nt = min(n/a, m/b)\na *= t\nb *= t",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7641",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #183 Editorial - Codeforces - Code 2",
          "code": "d = gcd(a,b)\na /= d\nb /= d\nt = min(n/a, m/b)\na *= t\nb *= t",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7641",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #183 Editorial - Codeforces - Code 3",
          "code": "vector<pair <int, int> > diff[x];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7641",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 10000, \"n\");\n    inf.readEoln();\n    inf.readEof();\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 10000, \"n\");\n    inf.readEoln();\n    inf.readEof();\n\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 10000, \"n\");\n    inf.readEoln();\n    inf.readEof();\n\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    \n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\", -1);\n    string type = opt<string>(\"type\", \"random\");\n\n    if (type == \"sample\"){\n        n = 5;\n    } else if (type == \"min\"){\n        n = 1;\n    } else if (type == \"max\"){\n        n = 10000;\n    } else if (type == \"small\"){\n        n = rnd.next(1, 10);\n    } else if (type == \"medium\"){\n        n = rnd.next(10, 100);\n    } else if (type == \"large\"){\n        n = rnd.next(9000, 10000);\n    } else if (type == \"square\"){\n        int m = rnd.next(1, 100);\n        n = m * m;\n        if (n > 10000) n = 10000;\n    } else if (type == \"custom\"){\n        if (n == -1){\n            n = 5000; // default value if n is not provided\n        }\n        // Ensure n is within bounds\n        if (n < 1) n = 1;\n        if (n > 10000) n = 10000;\n    } else {\n        // Random n between 1 and 10000\n        n = rnd.next(1, 10000);\n    }\n\n    // Output n\n    printf(\"%d\\n\", n);\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    \n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\", -1);\n    string type = opt<string>(\"type\", \"random\");\n\n    if (type == \"sample\"){\n        n = 5;\n    } else if (type == \"min\"){\n        n = 1;\n    } else if (type == \"max\"){\n        n = 10000;\n    } else if (type == \"small\"){\n        n = rnd.next(1, 10);\n    } else if (type == \"medium\"){\n        n = rnd.next(10, 100);\n    } else if (type == \"large\"){\n        n = rnd.next(9000, 10000);\n    } else if (type == \"square\"){\n        int m = rnd.next(1, 100);\n        n = m * m;\n        if (n > 10000) n = 10000;\n    } else if (type == \"custom\"){\n        if (n == -1){\n            n = 5000; // default value if n is not provided\n        }\n        // Ensure n is within bounds\n        if (n < 1) n = 1;\n        if (n > 10000) n = 10000;\n    } else {\n        // Random n between 1 and 10000\n        n = rnd.next(1, 10000);\n    }\n\n    // Output n\n    printf(\"%d\\n\", n);\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -type sample\n./gen -type min\n./gen -type max\n\n./gen -type small\n./gen -type small\n./gen -type small\n\n./gen -type medium\n./gen -type medium\n./gen -type medium\n\n./gen -type large\n./gen -type large\n./gen -type large\n\n./gen -type square\n./gen -type square\n./gen -type square\n\n./gen -type custom -n 13\n./gen -type custom -n 25\n./gen -type custom -n 36\n./gen -type custom -n 100\n./gen -type custom -n 10000\n./gen -type custom -n 9999\n./gen -type custom -n 0   # Should adjust n to minimum allowed\n./gen -type custom -n 10001  # Should adjust n to maximum allowed\n\n./gen -type random\n./gen -type random\n./gen -type random\n./gen -type random\n./gen -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:05:31.766700",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "304/B",
      "title": "B. Календарь",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест2 секунды",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеПервые две строки содержат две даты, каждая дата записана в формате yyyy:mm:dd (1900 ≤ yyyy ≤ 2038 и yyyy:mm:dd — корректная дата).",
      "output_spec": "Выходные данныеВыведите единственное целое число — ответ на задачу.",
      "sample_tests": "ПримерыВходные данныеСкопировать1900:01:012038:12:31Выходные данныеСкопировать50768Входные данныеСкопировать1996:03:091991:11:12Выходные данныеСкопировать1579",
      "description": "B. Календарь\n\nограничение по времени на тест2 секунды\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвыводstdout\n\nВходные данныеПервые две строки содержат две даты, каждая дата записана в формате yyyy:mm:dd (1900 ≤ yyyy ≤ 2038 и yyyy:mm:dd — корректная дата).\n\nВходные данные\n\nВыходные данныеВыведите единственное целое число — ответ на задачу.\n\nВыходные данные\n\nВходные данныеСкопировать1900:01:012038:12:31Выходные данныеСкопировать50768Входные данныеСкопировать1996:03:091991:11:12Выходные данныеСкопировать1579\n\nВходные данныеСкопировать1900:01:012038:12:31\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать50768\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать1996:03:091991:11:12\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать1579\n\nВыходные данныеСкопировать\n\nСкопировать",
      "solutions": [
        {
          "title": "Codeforces Round #183 - Codeforces",
          "content": "Три промаха друг за другом, и вот я мигом вернулся в желтый цвет...Раунд Codeforces Round #183 пройдет в воскресенье, 12 мая, в 17:00 MSK (21:00 CST). Сразу после раунда Google Code Jam Round 1C.Авторы раунда: Yuzhou Gu sevenkplus (Задачи B и E) Yuping Luo roosephu (Задачи A и D) Jiatai Huang CMHJT (Задача C) Тестеры:YuukaKazami, havaliza, Velicue и я.Мы благодарим Геральда Агапова (Gerald) за помощь и советы по задачам, Delinur за помощь с переводом задач на русский и MikeMirzayanov, разработавшего такую мощную платформу.Настоятельно рекомендуем Вам просмотреть все пять задач, хотя бы одна Вам обязательно придется по нраву.И еще кое-что. В этот раз будет динамическое распределение баллов по задачам, тем не менее задачи расположены в порядке предполагаемой сложности.Удачи!",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/7499",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 783
        },
        {
          "title": "Codeforces Round #183 Editorial - Codeforces",
          "content": "Overview ...。。。(; Д ;) 。Tutorial ... Problem 2A. Pythagorean Theorem II Math, implementationThis problem can be solve by brute-force, but it come up with a nicer solution if we involve some math.Check the following article if you are interested.http://en.wikipedia.org/wiki/Pythagorean_triple#Generating_a_triple Problem 2B. Calender Math, implementationThis problem can be solve by brute-force, but it come up with a nicer solution if we involve some math.Check kabar's code if you are interested.http://codeforces.com/contest/304/submission/3715756 Problem A. Lucky Permutation Triple Math, Constructive algorithms, Congruent when n is odd, A[i] = B[i] = i when n is even, there is no solution. So why? Because: S = \\Sum_{i=0}^{n-1} i = n/2 (mod n) but 2*S = 0 (mod n)See also at:http://codeforces.com/blog/entry/7499#comment-133446 Problem B. Rectangle Puzzle II Math, GeometryGive you n, m, x, y, a, b.Find a maximum sub-rectangle within (0, 0) — (n, m), so that it contains the given point(x, y) and its length-width radio is exactly (a, b). If there are multiple solutions, find the rectangle which is closest to (x, y). If there are still multiple solutions, find the lexicographically minimum one.Split the problem into x-axis and y-axis. Then you can solve the sub tasks in O(1). d = gcd(a,b)\na /= d\nb /= d\nt = min(n/a, m/b)\na *= t\nb *= tBe careful, when the length is outside the original rectangle. Problem C. Minimum Modular Math, Graph theory, Brute-force, CongruentIt is hard to solve this problem at once, so at first, let us consider on k = 0, this easier case can be solved by enumerate on the ans. Let us define a bool array diff[], which diff[x] is weather there are two number, ai, aj, such that abs(ai - aj) = x.So ans is legal <=> diff[ans], diff[2*ans] … are false.The time-complexity O(n2 + mlogm). Here m is the maximum ai.Consider on k > 0, we need to know how many pairs which has difference x. Store them invector<pair <int, int> > diff[x];Then use a dsu to maintain the how many a_i are congruent when enumerate on the ans. Problem D. Rotatable Number Math, Number theory(Coming Soon...)http://codeforces.com/blog/entry/7499#comment-133342 Problem E. Random Ranking Math, Probability(Coming After D...)http://codeforces.com/blog/entry/7499#comment-133488",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/7641",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.6,
            "reason": "宽松匹配: 包含题目编号 304 和字母"
          },
          "content_length": 2283
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #183 - Codeforces - Code 1",
          "code": "from datetime import date\n\na1 = map(int, raw_input().split(\":\"))\na2 = map(int, raw_input().split(\":\"))\n\nprint abs((date(a1[0], a1[1], a1[2]) - date(a2[0], a2[1], a2[2])).days)",
          "language": "Python",
          "source": "https://codeforces.com/blog/entry/7499",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #183 - Codeforces - Code 2",
          "code": "from datetime import date\n\na1 = map(int, raw_input().split(\":\"))\na2 = map(int, raw_input().split(\":\"))\n\nprint abs((date(a1[0], a1[1], a1[2]) - date(a2[0], a2[1], a2[2])).days)",
          "language": "Python",
          "source": "https://codeforces.com/blog/entry/7499",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #183 - Codeforces - Code 3",
          "code": "import java.math.BigInteger;\n\npublic class D {\n\n\tpublic static void main(String[] args){\n\t\tBigInteger.valueOf(3).isProbablePrime(1);\n\t}\n\n}",
          "language": "Python",
          "source": "https://codeforces.com/blog/entry/7499",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #183 - Codeforces - Code 4",
          "code": "import java.math.BigInteger;\n\npublic class D {\n\n\tpublic static void main(String[] args){\n\t\tBigInteger.valueOf(3).isProbablePrime(1);\n\t}\n\n}",
          "language": "Python",
          "source": "https://codeforces.com/blog/entry/7499",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #183 - Codeforces - Code 5",
          "code": "if (l[i] <= L && r[i] >= R)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7499",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #183 Editorial - Codeforces - Code 1",
          "code": "d = gcd(a,b)\na /= d\nb /= d\nt = min(n/a, m/b)\na *= t\nb *= t",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7641",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #183 Editorial - Codeforces - Code 2",
          "code": "d = gcd(a,b)\na /= d\nb /= d\nt = min(n/a, m/b)\na *= t\nb *= t",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7641",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #183 Editorial - Codeforces - Code 3",
          "code": "vector<pair <int, int> > diff[x];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7641",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nbool isLeapYear(int y) {\n    return (y % 4 == 0) && (y % 100 != 0 || y % 400 == 0);\n}\n\nint daysInMonth(int y, int m) {\n    int days[] = {31,28,31,30,31,30,31,31,30,31,30,31};\n    if (m == 2) {\n        return isLeapYear(y) ? 29 : 28;\n    } else {\n        return days[m - 1];\n    }\n}\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    string date1 = inf.readLine(\"^\\\\d{4}:\\\\d{2}:\\\\d{2}$\", \"date1\");\n    int y1, m1, d1;\n    sscanf(date1.c_str(), \"%d:%d:%d\", &y1, &m1, &d1);\n\n    ensuref(1900 <= y1 && y1 <= 2038, \"year y1 (%d) is out of bounds\", y1);\n    ensuref(1 <= m1 && m1 <= 12, \"month m1 (%d) is out of bounds\", m1);\n    int dim1 = daysInMonth(y1, m1);\n    ensuref(1 <= d1 && d1 <= dim1, \"day d1 (%d) is invalid for year %d and month %d\", d1, y1, m1);\n\n    string date2 = inf.readLine(\"^\\\\d{4}:\\\\d{2}:\\\\d{2}$\", \"date2\");\n    int y2, m2, d2;\n    sscanf(date2.c_str(), \"%d:%d:%d\", &y2, &m2, &d2);\n\n    ensuref(1900 <= y2 && y2 <= 2038, \"year y2 (%d) is out of bounds\", y2);\n    ensuref(1 <= m2 && m2 <= 12, \"month m2 (%d) is out of bounds\", m2);\n    int dim2 = daysInMonth(y2, m2);\n    ensuref(1 <= d2 && d2 <= dim2, \"day d2 (%d) is invalid for year %d and month %d\", d2, y2, m2);\n\n    inf.readEof();\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nbool isLeapYear(int y) {\n    return (y % 4 == 0) && (y % 100 != 0 || y % 400 == 0);\n}\n\nint daysInMonth(int y, int m) {\n    int days[] = {31,28,31,30,31,30,31,31,30,31,30,31};\n    if (m == 2) {\n        return isLeapYear(y) ? 29 : 28;\n    } else {\n        return days[m - 1];\n    }\n}\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    string date1 = inf.readLine(\"^\\\\d{4}:\\\\d{2}:\\\\d{2}$\", \"date1\");\n    int y1, m1, d1;\n    sscanf(date1.c_str(), \"%d:%d:%d\", &y1, &m1, &d1);\n\n    ensuref(1900 <= y1 && y1 <= 2038, \"year y1 (%d) is out of bounds\", y1);\n    ensuref(1 <= m1 && m1 <= 12, \"month m1 (%d) is out of bounds\", m1);\n    int dim1 = daysInMonth(y1, m1);\n    ensuref(1 <= d1 && d1 <= dim1, \"day d1 (%d) is invalid for year %d and month %d\", d1, y1, m1);\n\n    string date2 = inf.readLine(\"^\\\\d{4}:\\\\d{2}:\\\\d{2}$\", \"date2\");\n    int y2, m2, d2;\n    sscanf(date2.c_str(), \"%d:%d:%d\", &y2, &m2, &d2);\n\n    ensuref(1900 <= y2 && y2 <= 2038, \"year y2 (%d) is out of bounds\", y2);\n    ensuref(1 <= m2 && m2 <= 12, \"month m2 (%d) is out of bounds\", m2);\n    int dim2 = daysInMonth(y2, m2);\n    ensuref(1 <= d2 && d2 <= dim2, \"day d2 (%d) is invalid for year %d and month %d\", d2, y2, m2);\n\n    inf.readEof();\n\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nbool isLeapYear(int y) {\n    return (y % 4 == 0) && (y % 100 != 0 || y % 400 == 0);\n}\n\nint daysInMonth(int y, int m) {\n    int days[] = {31,28,31,30,31,30,31,31,30,31,30,31};\n    if (m == 2) {\n        return isLeapYear(y) ? 29 : 28;\n    } else {\n        return days[m - 1];\n    }\n}\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    string date1 = inf.readLine(\"^\\\\d{4}:\\\\d{2}:\\\\d{2}$\", \"date1\");\n    int y1, m1, d1;\n    sscanf(date1.c_str(), \"%d:%d:%d\", &y1, &m1, &d1);\n\n    ensuref(1900 <= y1 && y1 <= 2038, \"year y1 (%d) is out of bounds\", y1);\n    ensuref(1 <= m1 && m1 <= 12, \"month m1 (%d) is out of bounds\", m1);\n    int dim1 = daysInMonth(y1, m1);\n    ensuref(1 <= d1 && d1 <= dim1, \"day d1 (%d) is invalid for year %d and month %d\", d1, y1, m1);\n\n    string date2 = inf.readLine(\"^\\\\d{4}:\\\\d{2}:\\\\d{2}$\", \"date2\");\n    int y2, m2, d2;\n    sscanf(date2.c_str(), \"%d:%d:%d\", &y2, &m2, &d2);\n\n    ensuref(1900 <= y2 && y2 <= 2038, \"year y2 (%d) is out of bounds\", y2);\n    ensuref(1 <= m2 && m2 <= 12, \"month m2 (%d) is out of bounds\", m2);\n    int dim2 = daysInMonth(y2, m2);\n    ensuref(1 <= d2 && d2 <= dim2, \"day d2 (%d) is invalid for year %d and month %d\", d2, y2, m2);\n\n    inf.readEof();\n\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nbool isLeapYear(int year) {\n    if (year % 4 != 0) return false;\n    if (year % 100 != 0) return true;\n    if (year % 400 != 0) return false;\n    return true;\n}\n\nint dateToDays(int year, int month, int day) {\n    int days = 0;\n    // From 1900 to year - 1\n    for (int y = 1900; y < year; y++) {\n        days += isLeapYear(y) ? 366 : 365;\n    }\n    // From month 1 to month -1\n    for (int m = 1; m < month; m++) {\n        int dim;\n        if (m == 2) {\n            dim = isLeapYear(year) ? 29 : 28;\n        } else if (m == 4 || m == 6 || m == 9 || m == 11) {\n            dim = 30;\n        } else {\n            dim = 31;\n        }\n        days += dim;\n    }\n    days += day - 1; // Since day 1 is the first day of the month\n    return days;\n}\n\nvoid daysToDate(int days, int& year, int& month, int& day) {\n    year = 1900;\n    while (true) {\n        int days_in_year = isLeapYear(year) ? 366 : 365;\n        if (days >= days_in_year) {\n            days -= days_in_year;\n            year++;\n        } else {\n            break;\n        }\n    }\n    month = 1;\n    while (true) {\n        int dim;\n        if (month == 2) {\n            dim = isLeapYear(year) ? 29 : 28;\n        } else if (month == 4 || month == 6 || month == 9 || month == 11) {\n            dim = 30;\n        } else {\n            dim = 31;\n        }\n        if (days >= dim) {\n            days -= dim;\n            month++;\n        } else {\n            break;\n        }\n    }\n    day = days + 1;\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    string type = opt<string>(\"type\", \"random\");\n\n    // Precompute total_days\n    int total_days = dateToDays(2039,1,1); // Total days up to 2038-12-31\n\n    if (type == \"random\") {\n        // Generate two random dates\n        int d1 = rnd.next(0, total_days - 1);\n        int d2 = rnd.next(0, total_days - 1);\n\n        int y1, m1, day1;\n        daysToDate(d1, y1, m1, day1);\n\n        int y2, m2, day2;\n        daysToDate(d2, y2, m2, day2);\n\n        printf(\"%04d:%02d:%02d\\n\", y1, m1, day1);\n        printf(\"%04d:%02d:%02d\\n\", y2, m2, day2);\n    } else if (type == \"same_date\") {\n        // Generate one random date, print twice\n        int d1 = rnd.next(0, total_days - 1);\n        int y1, m1, day1;\n        daysToDate(d1, y1, m1, day1);\n\n        printf(\"%04d:%02d:%02d\\n\", y1, m1, day1);\n        printf(\"%04d:%02d:%02d\\n\", y1, m1, day1);\n    } else if (type == \"adjacent_dates\") {\n        // Generate a random date between 1900-01-01 and 2038-12-30\n        int d1 = rnd.next(0, total_days - 2); // Ensure d1 + 1 is within range\n        int d2 = d1 + 1;\n\n        int y1, m1, day1;\n        daysToDate(d1, y1, m1, day1);\n\n        int y2, m2, day2;\n        daysToDate(d2, y2, m2, day2);\n\n        printf(\"%04d:%02d:%02d\\n\", y1, m1, day1);\n        printf(\"%04d:%02d:%02d\\n\", y2, m2, day2);\n    } else if (type == \"leap_year\") {\n        // Choose a random leap year between 1900 and 2038\n        vector<int> leap_years;\n        for (int y = 1900; y <= 2038; y++) {\n            if (isLeapYear(y)) {\n                leap_years.push_back(y);\n            }\n        }\n        int ly = leap_years[rnd.next(0, (int)leap_years.size() - 1)];\n        // Pick a date involving Feb 29\n        int y1 = ly;\n        int m1 = 2;\n        int day1 = 29;\n        // Second date can be random\n        int d2 = rnd.next(0, total_days - 1);\n        int y2, m2, day2;\n        daysToDate(d2, y2, m2, day2);\n        printf(\"%04d:%02d:%02d\\n\", y1, m1, day1);\n        printf(\"%04d:%02d:%02d\\n\", y2, m2, day2);\n    } else if (type == \"non_leap_century\") {\n        int y1 = 1900;\n        int m1 = rnd.next(1,12);\n        int day1;\n        if (m1 == 2) {\n            day1 = rnd.next(1, 28);  // Non-leap year\n        } else {\n            int dim;\n            if (m1 == 4 || m1 ==6 || m1 ==9 || m1 ==11) dim=30;\n            else dim=31;\n            day1 = rnd.next(1, dim);\n        }\n        int d2 = rnd.next(0, total_days -1);\n        int y2, m2, day2;\n        daysToDate(d2, y2, m2, day2);\n        printf(\"%04d:%02d:%02d\\n\", y1, m1, day1);\n        printf(\"%04d:%02d:%02d\\n\", y2, m2, day2);\n    } else if (type == \"leap_century\") {  // Year 2000\n        int y1 = 2000;\n        int m1 = rnd.next(1,12);\n        int day1;\n        if (m1 == 2) {\n            day1 = rnd.next(1, 29);  // Leap year\n        } else {\n            int dim;\n            if (m1 == 4 || m1 ==6 || m1 ==9 || m1 ==11) dim=30;\n            else dim=31;\n            day1 = rnd.next(1, dim);\n        }\n        int d2 = rnd.next(0, total_days -1);\n        int y2, m2, day2;\n        daysToDate(d2, y2, m2, day2);\n        printf(\"%04d:%02d:%02d\\n\", y1, m1, day1);\n        printf(\"%04d:%02d:%02d\\n\", y2, m2, day2);\n    } else if (type == \"boundary\") {\n        // Use dates 1900-01-01 and 2038-12-31\n        printf(\"1900:01:01\\n\");\n        printf(\"2038:12:31\\n\");\n    } else if (type == \"reverse_dates\") {\n        // Generate two random dates, ensure first is after second\n        int d1 = rnd.next(0, total_days -1);\n        int d2 = rnd.next(0, total_days -1);\n        if (d1 < d2) swap(d1, d2);\n        int y1, m1, day1;\n        daysToDate(d1, y1, m1, day1);\n        int y2, m2, day2;\n        daysToDate(d2, y2, m2, day2);\n        printf(\"%04d:%02d:%02d\\n\", y1, m1, day1);\n        printf(\"%04d:%02d:%02d\\n\", y2, m2, day2);        \n    } else if (type == \"maximum_interval\") {\n        printf(\"1900:01:01\\n\");\n        printf(\"2038:12:31\\n\");\n    } else if (type == \"minimum_interval\") {\n        // Dates are one day apart\n        int d1 = rnd.next(0, total_days - 2);\n        int d2 = d1 + 1;\n        int y1, m1, day1;\n        daysToDate(d1, y1, m1, day1);\n        int y2, m2, day2;\n        daysToDate(d2, y2, m2, day2);\n        printf(\"%04d:%02d:%02d\\n\", y1, m1, day1);\n        printf(\"%04d:%02d:%02d\\n\", y2, m2, day2);\n    } else if (type == \"feb29_leap_year\") {\n        vector<int> leap_years;\n        for (int y = 1900; y <= 2038; y++) {\n            if (isLeapYear(y)) {\n                leap_years.push_back(y);\n            }\n        }\n        int ly = leap_years[rnd.next(0, (int)leap_years.size() - 1)];\n        int y1 = ly;\n        int m1 = 2;\n        int day1 = 29;\n        int y2 = ly;\n        int m2 = 3;\n        int day2 = 1;\n        printf(\"%04d:%02d:%02d\\n\", y1, m1, day1);\n        printf(\"%04d:%02d:%02d\\n\", y2, m2, day2);\n    } else if (type == \"feb28_non_leap_year\") {\n        // Choose a non-leap year\n        vector<int> non_leap_years;\n        for (int y = 1900; y <= 2038; y++) {\n            if (!isLeapYear(y)) {\n                non_leap_years.push_back(y);\n            }\n        }\n        int y = non_leap_years[rnd.next(0, (int)non_leap_years.size() -1)];\n        int y1 = y;\n        int m1 = 2;\n        int day1 = 28;\n        int y2 = y;\n        int m2 = 3;\n        int day2 = 1;\n        printf(\"%04d:%02d:%02d\\n\", y1, m1, day1);\n        printf(\"%04d:%02d:%02d\\n\", y2, m2, day2);\n    } else {\n        // Default to random\n        int d1 = rnd.next(0, total_days - 1);\n        int d2 = rnd.next(0, total_days - 1);\n\n        int y1, m1, day1;\n        daysToDate(d1, y1, m1, day1);\n\n        int y2, m2, day2;\n        daysToDate(d2, y2, m2, day2);\n\n        printf(\"%04d:%02d:%02d\\n\", y1, m1, day1);\n        printf(\"%04d:%02d:%02d\\n\", y2, m2, day2);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nbool isLeapYear(int year) {\n    if (year % 4 != 0) return false;\n    if (year % 100 != 0) return true;\n    if (year % 400 != 0) return false;\n    return true;\n}\n\nint dateToDays(int year, int month, int day) {\n    int days = 0;\n    // From 1900 to year - 1\n    for (int y = 1900; y < year; y++) {\n        days += isLeapYear(y) ? 366 : 365;\n    }\n    // From month 1 to month -1\n    for (int m = 1; m < month; m++) {\n        int dim;\n        if (m == 2) {\n            dim = isLeapYear(year) ? 29 : 28;\n        } else if (m == 4 || m == 6 || m == 9 || m == 11) {\n            dim = 30;\n        } else {\n            dim = 31;\n        }\n        days += dim;\n    }\n    days += day - 1; // Since day 1 is the first day of the month\n    return days;\n}\n\nvoid daysToDate(int days, int& year, int& month, int& day) {\n    year = 1900;\n    while (true) {\n        int days_in_year = isLeapYear(year) ? 366 : 365;\n        if (days >= days_in_year) {\n            days -= days_in_year;\n            year++;\n        } else {\n            break;\n        }\n    }\n    month = 1;\n    while (true) {\n        int dim;\n        if (month == 2) {\n            dim = isLeapYear(year) ? 29 : 28;\n        } else if (month == 4 || month == 6 || month == 9 || month == 11) {\n            dim = 30;\n        } else {\n            dim = 31;\n        }\n        if (days >= dim) {\n            days -= dim;\n            month++;\n        } else {\n            break;\n        }\n    }\n    day = days + 1;\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    string type = opt<string>(\"type\", \"random\");\n\n    // Precompute total_days\n    int total_days = dateToDays(2039,1,1); // Total days up to 2038-12-31\n\n    if (type == \"random\") {\n        // Generate two random dates\n        int d1 = rnd.next(0, total_days - 1);\n        int d2 = rnd.next(0, total_days - 1);\n\n        int y1, m1, day1;\n        daysToDate(d1, y1, m1, day1);\n\n        int y2, m2, day2;\n        daysToDate(d2, y2, m2, day2);\n\n        printf(\"%04d:%02d:%02d\\n\", y1, m1, day1);\n        printf(\"%04d:%02d:%02d\\n\", y2, m2, day2);\n    } else if (type == \"same_date\") {\n        // Generate one random date, print twice\n        int d1 = rnd.next(0, total_days - 1);\n        int y1, m1, day1;\n        daysToDate(d1, y1, m1, day1);\n\n        printf(\"%04d:%02d:%02d\\n\", y1, m1, day1);\n        printf(\"%04d:%02d:%02d\\n\", y1, m1, day1);\n    } else if (type == \"adjacent_dates\") {\n        // Generate a random date between 1900-01-01 and 2038-12-30\n        int d1 = rnd.next(0, total_days - 2); // Ensure d1 + 1 is within range\n        int d2 = d1 + 1;\n\n        int y1, m1, day1;\n        daysToDate(d1, y1, m1, day1);\n\n        int y2, m2, day2;\n        daysToDate(d2, y2, m2, day2);\n\n        printf(\"%04d:%02d:%02d\\n\", y1, m1, day1);\n        printf(\"%04d:%02d:%02d\\n\", y2, m2, day2);\n    } else if (type == \"leap_year\") {\n        // Choose a random leap year between 1900 and 2038\n        vector<int> leap_years;\n        for (int y = 1900; y <= 2038; y++) {\n            if (isLeapYear(y)) {\n                leap_years.push_back(y);\n            }\n        }\n        int ly = leap_years[rnd.next(0, (int)leap_years.size() - 1)];\n        // Pick a date involving Feb 29\n        int y1 = ly;\n        int m1 = 2;\n        int day1 = 29;\n        // Second date can be random\n        int d2 = rnd.next(0, total_days - 1);\n        int y2, m2, day2;\n        daysToDate(d2, y2, m2, day2);\n        printf(\"%04d:%02d:%02d\\n\", y1, m1, day1);\n        printf(\"%04d:%02d:%02d\\n\", y2, m2, day2);\n    } else if (type == \"non_leap_century\") {\n        int y1 = 1900;\n        int m1 = rnd.next(1,12);\n        int day1;\n        if (m1 == 2) {\n            day1 = rnd.next(1, 28);  // Non-leap year\n        } else {\n            int dim;\n            if (m1 == 4 || m1 ==6 || m1 ==9 || m1 ==11) dim=30;\n            else dim=31;\n            day1 = rnd.next(1, dim);\n        }\n        int d2 = rnd.next(0, total_days -1);\n        int y2, m2, day2;\n        daysToDate(d2, y2, m2, day2);\n        printf(\"%04d:%02d:%02d\\n\", y1, m1, day1);\n        printf(\"%04d:%02d:%02d\\n\", y2, m2, day2);\n    } else if (type == \"leap_century\") {  // Year 2000\n        int y1 = 2000;\n        int m1 = rnd.next(1,12);\n        int day1;\n        if (m1 == 2) {\n            day1 = rnd.next(1, 29);  // Leap year\n        } else {\n            int dim;\n            if (m1 == 4 || m1 ==6 || m1 ==9 || m1 ==11) dim=30;\n            else dim=31;\n            day1 = rnd.next(1, dim);\n        }\n        int d2 = rnd.next(0, total_days -1);\n        int y2, m2, day2;\n        daysToDate(d2, y2, m2, day2);\n        printf(\"%04d:%02d:%02d\\n\", y1, m1, day1);\n        printf(\"%04d:%02d:%02d\\n\", y2, m2, day2);\n    } else if (type == \"boundary\") {\n        // Use dates 1900-01-01 and 2038-12-31\n        printf(\"1900:01:01\\n\");\n        printf(\"2038:12:31\\n\");\n    } else if (type == \"reverse_dates\") {\n        // Generate two random dates, ensure first is after second\n        int d1 = rnd.next(0, total_days -1);\n        int d2 = rnd.next(0, total_days -1);\n        if (d1 < d2) swap(d1, d2);\n        int y1, m1, day1;\n        daysToDate(d1, y1, m1, day1);\n        int y2, m2, day2;\n        daysToDate(d2, y2, m2, day2);\n        printf(\"%04d:%02d:%02d\\n\", y1, m1, day1);\n        printf(\"%04d:%02d:%02d\\n\", y2, m2, day2);        \n    } else if (type == \"maximum_interval\") {\n        printf(\"1900:01:01\\n\");\n        printf(\"2038:12:31\\n\");\n    } else if (type == \"minimum_interval\") {\n        // Dates are one day apart\n        int d1 = rnd.next(0, total_days - 2);\n        int d2 = d1 + 1;\n        int y1, m1, day1;\n        daysToDate(d1, y1, m1, day1);\n        int y2, m2, day2;\n        daysToDate(d2, y2, m2, day2);\n        printf(\"%04d:%02d:%02d\\n\", y1, m1, day1);\n        printf(\"%04d:%02d:%02d\\n\", y2, m2, day2);\n    } else if (type == \"feb29_leap_year\") {\n        vector<int> leap_years;\n        for (int y = 1900; y <= 2038; y++) {\n            if (isLeapYear(y)) {\n                leap_years.push_back(y);\n            }\n        }\n        int ly = leap_years[rnd.next(0, (int)leap_years.size() - 1)];\n        int y1 = ly;\n        int m1 = 2;\n        int day1 = 29;\n        int y2 = ly;\n        int m2 = 3;\n        int day2 = 1;\n        printf(\"%04d:%02d:%02d\\n\", y1, m1, day1);\n        printf(\"%04d:%02d:%02d\\n\", y2, m2, day2);\n    } else if (type == \"feb28_non_leap_year\") {\n        // Choose a non-leap year\n        vector<int> non_leap_years;\n        for (int y = 1900; y <= 2038; y++) {\n            if (!isLeapYear(y)) {\n                non_leap_years.push_back(y);\n            }\n        }\n        int y = non_leap_years[rnd.next(0, (int)non_leap_years.size() -1)];\n        int y1 = y;\n        int m1 = 2;\n        int day1 = 28;\n        int y2 = y;\n        int m2 = 3;\n        int day2 = 1;\n        printf(\"%04d:%02d:%02d\\n\", y1, m1, day1);\n        printf(\"%04d:%02d:%02d\\n\", y2, m2, day2);\n    } else {\n        // Default to random\n        int d1 = rnd.next(0, total_days - 1);\n        int d2 = rnd.next(0, total_days - 1);\n\n        int y1, m1, day1;\n        daysToDate(d1, y1, m1, day1);\n\n        int y2, m2, day2;\n        daysToDate(d2, y2, m2, day2);\n\n        printf(\"%04d:%02d:%02d\\n\", y1, m1, day1);\n        printf(\"%04d:%02d:%02d\\n\", y2, m2, day2);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -type random\n./gen -type random\n./gen -type random\n./gen -type random\n./gen -type random\n\n./gen -type same_date\n./gen -type adjacent_dates\n./gen -type leap_year\n./gen -type non_leap_century\n./gen -type leap_century\n./gen -type boundary\n./gen -type reverse_dates\n./gen -type maximum_interval\n./gen -type minimum_interval\n./gen -type feb29_leap_year\n./gen -type feb28_non_leap_year\n\n./gen -type random\n./gen -type random\n./gen -type reverse_dates\n./gen -type random\n./gen -type random\n./gen -type leap_year\n./gen -type non_leap_century\n./gen -type leap_century\n./gen -type boundary\n\n./gen -type random\n./gen -type random\n./gen -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:05:33.938703",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "304/C",
      "title": "C. Тройка счастливых перестановок",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест2 секунды",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеВ первой строке содержится единственное целое число n (1 ≤ n ≤ 105).",
      "output_spec": "Выходные данныеЕсли не существует Счастливой Тройки Перестановок длины n, выведите -1.В противном случае следует вывести три строки. В каждой строке содержится по n целых чисел через пробел. В первой строке надо вывести перестановку a, во второй — перестановку b, в третьей — перестановку c.Если ответов несколько, выведите любой.",
      "sample_tests": "ПримерыВходные данныеСкопировать5Выходные данныеСкопировать1 4 3 2 01 0 2 4 32 4 0 1 3Входные данныеСкопировать2Выходные данныеСкопировать-1",
      "description": "C. Тройка счастливых перестановок\n\nограничение по времени на тест2 секунды\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвыводstdout\n\nВходные данныеВ первой строке содержится единственное целое число n (1 ≤ n ≤ 105).\n\nВходные данные\n\nВыходные данныеЕсли не существует Счастливой Тройки Перестановок длины n, выведите -1.В противном случае следует вывести три строки. В каждой строке содержится по n целых чисел через пробел. В первой строке надо вывести перестановку a, во второй — перестановку b, в третьей — перестановку c.Если ответов несколько, выведите любой.\n\nВыходные данные\n\nВходные данныеСкопировать5Выходные данныеСкопировать1 4 3 2 01 0 2 4 32 4 0 1 3Входные данныеСкопировать2Выходные данныеСкопировать-1\n\nВходные данныеСкопировать5\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать1 4 3 2 01 0 2 4 32 4 0 1 3\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать2\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать-1\n\nВыходные данныеСкопировать\n\nСкопировать\n\nПримечаниеВ примере 1, тройка перестановок ([1, 4, 3, 2, 0], [1, 0, 2, 4, 3], [2, 4, 0, 1, 3]) является счастливой, так как выполняются следующие условия:  ;  ;  ;  ;  . В примере 2 легко заметить, что счастливых троек перестановок вообще нет.",
      "solutions": [
        {
          "title": "Codeforces Round #183 - Codeforces",
          "content": "Три промаха друг за другом, и вот я мигом вернулся в желтый цвет...Раунд Codeforces Round #183 пройдет в воскресенье, 12 мая, в 17:00 MSK (21:00 CST). Сразу после раунда Google Code Jam Round 1C.Авторы раунда: Yuzhou Gu sevenkplus (Задачи B и E) Yuping Luo roosephu (Задачи A и D) Jiatai Huang CMHJT (Задача C) Тестеры:YuukaKazami, havaliza, Velicue и я.Мы благодарим Геральда Агапова (Gerald) за помощь и советы по задачам, Delinur за помощь с переводом задач на русский и MikeMirzayanov, разработавшего такую мощную платформу.Настоятельно рекомендуем Вам просмотреть все пять задач, хотя бы одна Вам обязательно придется по нраву.И еще кое-что. В этот раз будет динамическое распределение баллов по задачам, тем не менее задачи расположены в порядке предполагаемой сложности.Удачи!",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/7499",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 783
        },
        {
          "title": "Codeforces Round #183 Editorial - Codeforces",
          "content": "Overview ...。。。(; Д ;) 。Tutorial ... Problem 2A. Pythagorean Theorem II Math, implementationThis problem can be solve by brute-force, but it come up with a nicer solution if we involve some math.Check the following article if you are interested.http://en.wikipedia.org/wiki/Pythagorean_triple#Generating_a_triple Problem 2B. Calender Math, implementationThis problem can be solve by brute-force, but it come up with a nicer solution if we involve some math.Check kabar's code if you are interested.http://codeforces.com/contest/304/submission/3715756 Problem A. Lucky Permutation Triple Math, Constructive algorithms, Congruent when n is odd, A[i] = B[i] = i when n is even, there is no solution. So why? Because: S = \\Sum_{i=0}^{n-1} i = n/2 (mod n) but 2*S = 0 (mod n)See also at:http://codeforces.com/blog/entry/7499#comment-133446 Problem B. Rectangle Puzzle II Math, GeometryGive you n, m, x, y, a, b.Find a maximum sub-rectangle within (0, 0) — (n, m), so that it contains the given point(x, y) and its length-width radio is exactly (a, b). If there are multiple solutions, find the rectangle which is closest to (x, y). If there are still multiple solutions, find the lexicographically minimum one.Split the problem into x-axis and y-axis. Then you can solve the sub tasks in O(1). d = gcd(a,b)\na /= d\nb /= d\nt = min(n/a, m/b)\na *= t\nb *= tBe careful, when the length is outside the original rectangle. Problem C. Minimum Modular Math, Graph theory, Brute-force, CongruentIt is hard to solve this problem at once, so at first, let us consider on k = 0, this easier case can be solved by enumerate on the ans. Let us define a bool array diff[], which diff[x] is weather there are two number, ai, aj, such that abs(ai - aj) = x.So ans is legal <=> diff[ans], diff[2*ans] … are false.The time-complexity O(n2 + mlogm). Here m is the maximum ai.Consider on k > 0, we need to know how many pairs which has difference x. Store them invector<pair <int, int> > diff[x];Then use a dsu to maintain the how many a_i are congruent when enumerate on the ans. Problem D. Rotatable Number Math, Number theory(Coming Soon...)http://codeforces.com/blog/entry/7499#comment-133342 Problem E. Random Ranking Math, Probability(Coming After D...)http://codeforces.com/blog/entry/7499#comment-133488",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/7641",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.6,
            "reason": "宽松匹配: 包含题目编号 304 和字母"
          },
          "content_length": 2283
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #183 - Codeforces - Code 1",
          "code": "from datetime import date\n\na1 = map(int, raw_input().split(\":\"))\na2 = map(int, raw_input().split(\":\"))\n\nprint abs((date(a1[0], a1[1], a1[2]) - date(a2[0], a2[1], a2[2])).days)",
          "language": "Python",
          "source": "https://codeforces.com/blog/entry/7499",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #183 - Codeforces - Code 2",
          "code": "from datetime import date\n\na1 = map(int, raw_input().split(\":\"))\na2 = map(int, raw_input().split(\":\"))\n\nprint abs((date(a1[0], a1[1], a1[2]) - date(a2[0], a2[1], a2[2])).days)",
          "language": "Python",
          "source": "https://codeforces.com/blog/entry/7499",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #183 - Codeforces - Code 3",
          "code": "import java.math.BigInteger;\n\npublic class D {\n\n\tpublic static void main(String[] args){\n\t\tBigInteger.valueOf(3).isProbablePrime(1);\n\t}\n\n}",
          "language": "Python",
          "source": "https://codeforces.com/blog/entry/7499",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #183 - Codeforces - Code 4",
          "code": "import java.math.BigInteger;\n\npublic class D {\n\n\tpublic static void main(String[] args){\n\t\tBigInteger.valueOf(3).isProbablePrime(1);\n\t}\n\n}",
          "language": "Python",
          "source": "https://codeforces.com/blog/entry/7499",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #183 - Codeforces - Code 5",
          "code": "if (l[i] <= L && r[i] >= R)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7499",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #183 Editorial - Codeforces - Code 1",
          "code": "d = gcd(a,b)\na /= d\nb /= d\nt = min(n/a, m/b)\na *= t\nb *= t",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7641",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #183 Editorial - Codeforces - Code 2",
          "code": "d = gcd(a,b)\na /= d\nb /= d\nt = min(n/a, m/b)\na *= t\nb *= t",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7641",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #183 Editorial - Codeforces - Code 3",
          "code": "vector<pair <int, int> > diff[x];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7641",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]){\n    registerTestlibCmd(argc, argv);\n\n    int n = inf.readInt();\n\n    int first_token = ouf.readInt();\n\n    if (first_token == -1){\n        // contestant outputs -1\n        ouf.skipBlanks();\n        if (!ouf.seekEof())\n            quitf(_wa, \"Extra output after -1\");\n        if (n % 2 == 0){\n            // no solution exists, contestant is correct\n            quitf(_ok, \"No solution exists, contestant correctly outputs -1\");\n        }else{\n            // solution exists\n            quitf(_wa, \"Solution exists, but contestant outputs -1\");\n        }\n    } else {\n        // contestant outputs something other than -1\n\n        // Initialize vectors\n        vector<int> a(n);\n        a[0] = first_token;\n        for (int i = 1; i < n; i++) {\n            a[i] = ouf.readInt(0, n - 1, format(\"a[%d]\", i + 1).c_str());\n        }\n        set<int> sa(a.begin(), a.end());\n        if ((int)sa.size() != n){\n            quitf(_wa, \"First line is not a permutation\");\n        }\n        // Read second line\n        vector<int> b(n);\n        for(int i=0; i<n; ++i){\n            b[i] = ouf.readInt(0, n-1, format(\"b[%d]\", i + 1).c_str());\n        }\n        set<int> sb(b.begin(), b.end());\n        if ((int)sb.size() != n){\n            quitf(_wa, \"Second line is not a permutation\");\n        }\n        // Read third line\n        vector<int> c(n);\n        for(int i=0; i<n; ++i){\n            c[i] = ouf.readInt(0, n-1, format(\"c[%d]\", i + 1).c_str());\n        }\n        set<int> sc(c.begin(), c.end());\n        if ((int)sc.size() != n){\n            quitf(_wa, \"Third line is not a permutation\");\n        }\n        // Check modular condition\n        for(int i=0; i<n; ++i){\n            if ((a[i] + b[i]) % n != c[i]){\n                quitf(_wa, \"At position %d, (a[%d] + b[%d]) %% n != c[%d]\", i+1,i+1,i+1,i+1);\n            }\n        }\n        // Check for extra output\n        ouf.skipBlanks();\n        if (!ouf.seekEof()){\n            quitf(_wa, \"Extra output after third permutation\");\n        }\n        // Check if solution should exist\n        if (n%2 == 0){\n            quitf(_wa, \"No solution exists for n = %d, but contestant outputs one\", n);\n        }\n        quitf(_ok, \"Found a valid solution\");\n    }\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\", -1);\n    string type = opt<string>(\"type\", \"random\");\n\n    if (n == -1) {\n        if (type == \"small\") {\n            n = rnd.next(1, 10);\n        } else if (type == \"medium\") {\n            n = rnd.next(11, 1000);\n        } else if (type == \"large\") {\n            n = rnd.next(1001, 99999);\n        } else if (type == \"max\") {\n            n = 100000;\n        } else if (type == \"exists\") {\n            // Generate odd n where it's assumed a solution exists\n            n = rnd.next(1, 50000) * 2 + 1;\n        } else if (type == \"noexists\") {\n            // Generate even n where it's assumed no solution exists\n            n = rnd.next(1, 50000) * 2;\n        } else if (type == \"random\") {\n            n = rnd.next(1, 100000);\n        } else {\n            n = rnd.next(1, 100000);\n        }\n    }\n\n    printf(\"%d\\n\", n);\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\", -1);\n    string type = opt<string>(\"type\", \"random\");\n\n    if (n == -1) {\n        if (type == \"small\") {\n            n = rnd.next(1, 10);\n        } else if (type == \"medium\") {\n            n = rnd.next(11, 1000);\n        } else if (type == \"large\") {\n            n = rnd.next(1001, 99999);\n        } else if (type == \"max\") {\n            n = 100000;\n        } else if (type == \"exists\") {\n            // Generate odd n where it's assumed a solution exists\n            n = rnd.next(1, 50000) * 2 + 1;\n        } else if (type == \"noexists\") {\n            // Generate even n where it's assumed no solution exists\n            n = rnd.next(1, 50000) * 2;\n        } else if (type == \"random\") {\n            n = rnd.next(1, 100000);\n        } else {\n            n = rnd.next(1, 100000);\n        }\n    }\n\n    printf(\"%d\\n\", n);\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1\n./gen -n 2\n./gen -n 3\n./gen -n 4\n./gen -n 5\n./gen -n 6\n./gen -n 7\n./gen -n 8\n./gen -n 9\n./gen -n 10\n\n./gen -n 20\n./gen -n 50\n./gen -n 100\n./gen -n 200\n./gen -n 500\n./gen -n 1000\n./gen -n 2000\n./gen -n 5000\n./gen -n 10000\n./gen -n 20000\n./gen -n 50000\n./gen -n 99999\n./gen -n 100000\n\n./gen -type small\n./gen -type small\n./gen -type medium\n./gen -type medium\n./gen -type large\n./gen -type large\n./gen -type random\n./gen -type random\n\n./gen -type exists\n./gen -type exists\n./gen -type noexists\n./gen -type noexists\n\n./gen -n 12345\n./gen -n 54321\n./gen -n 99961\n./gen -n 99971\n./gen -n 99989\n./gen -n 99998\n./gen -n 99999\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:05:36.233548",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "304/D",
      "title": "D. Rectangle Puzzle II",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains six integers n, m, x, y, a, b (1 ≤ n, m ≤ 109, 0 ≤ x ≤ n, 0 ≤ y ≤ m, 1 ≤ a ≤ n, 1 ≤ b ≤ m).",
      "output_spec": "OutputPrint four integers x1, y1, x2, y2, which represent the founded sub-rectangle whose left-bottom point is (x1, y1) and right-up point is (x2, y2).",
      "sample_tests": "ExamplesInputCopy9 9 5 5 2 1OutputCopy1 3 9 7InputCopy100 100 52 50 46 56OutputCopy17 8 86 92",
      "description": "D. Rectangle Puzzle II\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains six integers n, m, x, y, a, b (1 ≤ n, m ≤ 109, 0 ≤ x ≤ n, 0 ≤ y ≤ m, 1 ≤ a ≤ n, 1 ≤ b ≤ m).\n\nOutputPrint four integers x1, y1, x2, y2, which represent the founded sub-rectangle whose left-bottom point is (x1, y1) and right-up point is (x2, y2).\n\nInputCopy9 9 5 5 2 1OutputCopy1 3 9 7InputCopy100 100 52 50 46 56OutputCopy17 8 86 92\n\nInputCopy9 9 5 5 2 1\n\nOutputCopy1 3 9 7\n\nInputCopy100 100 52 50 46 56\n\nOutputCopy17 8 86 92",
      "solutions": [
        {
          "title": "Codeforces Round #183 - Codeforces",
          "content": "Three drops in a line, back to yellow so quickly ...Anyway, Codeforces Round #183 will be take place on Sunday, May 12th at 17:00 MSK(21:00 CST). Right after the Google Code Jam Round 1C.Setters are: Yuzhou Gu sevenkplus (For Problem B && E) Yuping Luo roosephu (For Problem A && D) Jiatai Huang CMHJT (Problem C) Testers are YuukaKazami, havaliza, Velicue && me.We gratefully acknowledge Gerald Agapov(Gerald) for his help in giving advise about the problems, Delinur for her help in translating the problems to Russian, and MikeMirzayanov, who has designed such a powerful platform.We strongly recommend you to take a glance over all five problems, there must be one suitable to your taste.Oh one more thing, this time, scoring will be dynamic, but problems are sorted by increasing order of their difficulty as usual.Good Luck!",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/7499",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 830
        },
        {
          "title": "Codeforces Round #183 Editorial - Codeforces",
          "content": "Overview ...。。。(; Д ;) 。Tutorial ... Problem 2A. Pythagorean Theorem II Math, implementationThis problem can be solve by brute-force, but it come up with a nicer solution if we involve some math.Check the following article if you are interested.http://en.wikipedia.org/wiki/Pythagorean_triple#Generating_a_triple Problem 2B. Calender Math, implementationThis problem can be solve by brute-force, but it come up with a nicer solution if we involve some math.Check kabar's code if you are interested.http://codeforces.com/contest/304/submission/3715756 Problem A. Lucky Permutation Triple Math, Constructive algorithms, Congruent when n is odd, A[i] = B[i] = i when n is even, there is no solution. So why? Because: S = \\Sum_{i=0}^{n-1} i = n/2 (mod n) but 2*S = 0 (mod n)See also at:http://codeforces.com/blog/entry/7499#comment-133446 Problem B. Rectangle Puzzle II Math, GeometryGive you n, m, x, y, a, b.Find a maximum sub-rectangle within (0, 0) — (n, m), so that it contains the given point(x, y) and its length-width radio is exactly (a, b). If there are multiple solutions, find the rectangle which is closest to (x, y). If there are still multiple solutions, find the lexicographically minimum one.Split the problem into x-axis and y-axis. Then you can solve the sub tasks in O(1). d = gcd(a,b)\na /= d\nb /= d\nt = min(n/a, m/b)\na *= t\nb *= tBe careful, when the length is outside the original rectangle. Problem C. Minimum Modular Math, Graph theory, Brute-force, CongruentIt is hard to solve this problem at once, so at first, let us consider on k = 0, this easier case can be solved by enumerate on the ans. Let us define a bool array diff[], which diff[x] is weather there are two number, ai, aj, such that abs(ai - aj) = x.So ans is legal <=> diff[ans], diff[2*ans] … are false.The time-complexity O(n2 + mlogm). Here m is the maximum ai.Consider on k > 0, we need to know how many pairs which has difference x. Store them invector<pair <int, int> > diff[x];Then use a dsu to maintain the how many a_i are congruent when enumerate on the ans. Problem D. Rotatable Number Math, Number theory(Coming Soon...)http://codeforces.com/blog/entry/7499#comment-133342 Problem E. Random Ranking Math, Probability(Coming After D...)http://codeforces.com/blog/entry/7499#comment-133488",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/7641",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.6,
            "reason": "宽松匹配: 包含题目编号 304 和字母"
          },
          "content_length": 2283
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #183 - Codeforces - Code 1",
          "code": "from datetime import date\n\na1 = map(int, raw_input().split(\":\"))\na2 = map(int, raw_input().split(\":\"))\n\nprint abs((date(a1[0], a1[1], a1[2]) - date(a2[0], a2[1], a2[2])).days)",
          "language": "Python",
          "source": "https://codeforces.com/blog/entry/7499",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #183 - Codeforces - Code 2",
          "code": "from datetime import date\n\na1 = map(int, raw_input().split(\":\"))\na2 = map(int, raw_input().split(\":\"))\n\nprint abs((date(a1[0], a1[1], a1[2]) - date(a2[0], a2[1], a2[2])).days)",
          "language": "Python",
          "source": "https://codeforces.com/blog/entry/7499",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #183 - Codeforces - Code 3",
          "code": "if (l[i] <= L && r[i] >= R)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7499",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #183 Editorial - Codeforces - Code 1",
          "code": "d = gcd(a,b)\na /= d\nb /= d\nt = min(n/a, m/b)\na *= t\nb *= t",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7641",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #183 Editorial - Codeforces - Code 2",
          "code": "d = gcd(a,b)\na /= d\nb /= d\nt = min(n/a, m/b)\na *= t\nb *= t",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7641",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #183 Editorial - Codeforces - Code 3",
          "code": "vector<pair <int, int> > diff[x];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7641",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 1000000000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 1000000000, \"m\");\n    inf.readSpace();\n    int x = inf.readInt(0, n, \"x\");\n    inf.readSpace();\n    int y = inf.readInt(0, m, \"y\");\n    inf.readSpace();\n    int a = inf.readInt(1, n, \"a\");\n    inf.readSpace();\n    int b = inf.readInt(1, m, \"b\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 1000000000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 1000000000, \"m\");\n    inf.readSpace();\n    int x = inf.readInt(0, n, \"x\");\n    inf.readSpace();\n    int y = inf.readInt(0, m, \"y\");\n    inf.readSpace();\n    int a = inf.readInt(1, n, \"a\");\n    inf.readSpace();\n    int b = inf.readInt(1, m, \"b\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 1000000000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 1000000000, \"m\");\n    inf.readSpace();\n    int x = inf.readInt(0, n, \"x\");\n    inf.readSpace();\n    int y = inf.readInt(0, m, \"y\");\n    inf.readSpace();\n    int a = inf.readInt(1, n, \"a\");\n    inf.readSpace();\n    int b = inf.readInt(1, m, \"b\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\", -1); // grid width\n    int m = opt<int>(\"m\", -1); // grid height\n    int x = opt<int>(\"x\", -1); // x-coordinate of the point\n    int y = opt<int>(\"y\", -1); // y-coordinate of the point\n    int a = opt<int>(\"a\", -1); // length ratio numerator\n    int b = opt<int>(\"b\", -1); // length ratio denominator\n    string type = opt<string>(\"type\", \"random\");\n\n    // Set default n and m if not provided\n    if (n == -1) n = rnd.next(1, 1000000000);\n    if (m == -1) m = rnd.next(1, 1000000000);\n\n    if (type == \"small\") {\n        n = rnd.next(1, 10);\n        m = rnd.next(1, 10);\n        x = rnd.next(0, n);\n        y = rnd.next(0, m);\n        a = rnd.next(1, n);\n        b = rnd.next(1, m);\n    } else if (type == \"edge_x\") {\n        x = rnd.next(0, 1) == 0 ? 0 : n;\n        if (y == -1) y = rnd.next(0, m);\n        if (a == -1) a = rnd.next(1, n);\n        if (b == -1) b = rnd.next(1, m);\n    } else if (type == \"edge_y\") {\n        y = rnd.next(0, 1) == 0 ? 0 : m;\n        if (x == -1) x = rnd.next(0, n);\n        if (a == -1) a = rnd.next(1, n);\n        if (b == -1) b = rnd.next(1, m);\n    } else if (type == \"corner\") {\n        x = rnd.next(0, 1) == 0 ? 0 : n;\n        y = rnd.next(0, 1) == 0 ? 0 : m;\n        if (a == -1) a = rnd.next(1, n);\n        if (b == -1) b = rnd.next(1, m);\n    } else if (type == \"center\") {\n        x = n / 2;\n        y = m / 2;\n        if (a == -1) a = rnd.next(1, n);\n        if (b == -1) b = rnd.next(1, m);\n    } else if (type == \"max\") {\n        n = 1000000000;\n        m = 1000000000;\n        x = rnd.next(0, n);\n        y = rnd.next(0, m);\n        a = rnd.next(1, n);\n        b = rnd.next(1, m);\n    } else if (type == \"ratio_large\") {\n        if (a == -1) a = rnd.next(max(1, n / 2), n);\n        if (b == -1) b = rnd.next(max(1, m / 2), m);\n        if (x == -1) x = rnd.next(0, n);\n        if (y == -1) y = rnd.next(0, m);\n    } else if (type == \"ratio_one\") {\n        a = 1;\n        b = 1;\n        if (x == -1) x = rnd.next(0, n);\n        if (y == -1) y = rnd.next(0, m);\n    } else if (type == \"aspect_ratio_extreme\") {\n        if (rnd.next(0, 1)) {\n            a = 1;\n            b = m;\n        } else {\n            a = n;\n            b = 1;\n        }\n        if (x == -1) x = rnd.next(0, n);\n        if (y == -1) y = rnd.next(0, m);\n    } else if (type == \"random\") {\n        if (x == -1) x = rnd.next(0, n);\n        if (y == -1) y = rnd.next(0, m);\n        if (a == -1) a = rnd.next(1, n);\n        if (b == -1) b = rnd.next(1, m);\n    } else if (type == \"special\") {\n        // Special case where the ratio matches the grid size\n        a = n;\n        b = m;\n        x = n / 2;\n        y = m / 2;\n    } else {\n        // Default is random\n        if (x == -1) x = rnd.next(0, n);\n        if (y == -1) y = rnd.next(0, m);\n        if (a == -1) a = rnd.next(1, n);\n        if (b == -1) b = rnd.next(1, m);\n    }\n\n    // Now ensure all variables are within constraints\n    ensure(1 <= n && n <= 1000000000);\n    ensure(1 <= m && m <= 1000000000);\n    ensure(0 <= x && x <= n);\n    ensure(0 <= y && y <= m);\n    ensure(1 <= a && a <= n);\n    ensure(1 <= b && b <= m);\n\n    // Output\n    printf(\"%d %d %d %d %d %d\\n\", n, m, x, y, a, b);\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\", -1); // grid width\n    int m = opt<int>(\"m\", -1); // grid height\n    int x = opt<int>(\"x\", -1); // x-coordinate of the point\n    int y = opt<int>(\"y\", -1); // y-coordinate of the point\n    int a = opt<int>(\"a\", -1); // length ratio numerator\n    int b = opt<int>(\"b\", -1); // length ratio denominator\n    string type = opt<string>(\"type\", \"random\");\n\n    // Set default n and m if not provided\n    if (n == -1) n = rnd.next(1, 1000000000);\n    if (m == -1) m = rnd.next(1, 1000000000);\n\n    if (type == \"small\") {\n        n = rnd.next(1, 10);\n        m = rnd.next(1, 10);\n        x = rnd.next(0, n);\n        y = rnd.next(0, m);\n        a = rnd.next(1, n);\n        b = rnd.next(1, m);\n    } else if (type == \"edge_x\") {\n        x = rnd.next(0, 1) == 0 ? 0 : n;\n        if (y == -1) y = rnd.next(0, m);\n        if (a == -1) a = rnd.next(1, n);\n        if (b == -1) b = rnd.next(1, m);\n    } else if (type == \"edge_y\") {\n        y = rnd.next(0, 1) == 0 ? 0 : m;\n        if (x == -1) x = rnd.next(0, n);\n        if (a == -1) a = rnd.next(1, n);\n        if (b == -1) b = rnd.next(1, m);\n    } else if (type == \"corner\") {\n        x = rnd.next(0, 1) == 0 ? 0 : n;\n        y = rnd.next(0, 1) == 0 ? 0 : m;\n        if (a == -1) a = rnd.next(1, n);\n        if (b == -1) b = rnd.next(1, m);\n    } else if (type == \"center\") {\n        x = n / 2;\n        y = m / 2;\n        if (a == -1) a = rnd.next(1, n);\n        if (b == -1) b = rnd.next(1, m);\n    } else if (type == \"max\") {\n        n = 1000000000;\n        m = 1000000000;\n        x = rnd.next(0, n);\n        y = rnd.next(0, m);\n        a = rnd.next(1, n);\n        b = rnd.next(1, m);\n    } else if (type == \"ratio_large\") {\n        if (a == -1) a = rnd.next(max(1, n / 2), n);\n        if (b == -1) b = rnd.next(max(1, m / 2), m);\n        if (x == -1) x = rnd.next(0, n);\n        if (y == -1) y = rnd.next(0, m);\n    } else if (type == \"ratio_one\") {\n        a = 1;\n        b = 1;\n        if (x == -1) x = rnd.next(0, n);\n        if (y == -1) y = rnd.next(0, m);\n    } else if (type == \"aspect_ratio_extreme\") {\n        if (rnd.next(0, 1)) {\n            a = 1;\n            b = m;\n        } else {\n            a = n;\n            b = 1;\n        }\n        if (x == -1) x = rnd.next(0, n);\n        if (y == -1) y = rnd.next(0, m);\n    } else if (type == \"random\") {\n        if (x == -1) x = rnd.next(0, n);\n        if (y == -1) y = rnd.next(0, m);\n        if (a == -1) a = rnd.next(1, n);\n        if (b == -1) b = rnd.next(1, m);\n    } else if (type == \"special\") {\n        // Special case where the ratio matches the grid size\n        a = n;\n        b = m;\n        x = n / 2;\n        y = m / 2;\n    } else {\n        // Default is random\n        if (x == -1) x = rnd.next(0, n);\n        if (y == -1) y = rnd.next(0, m);\n        if (a == -1) a = rnd.next(1, n);\n        if (b == -1) b = rnd.next(1, m);\n    }\n\n    // Now ensure all variables are within constraints\n    ensure(1 <= n && n <= 1000000000);\n    ensure(1 <= m && m <= 1000000000);\n    ensure(0 <= x && x <= n);\n    ensure(0 <= y && y <= m);\n    ensure(1 <= a && a <= n);\n    ensure(1 <= b && b <= m);\n\n    // Output\n    printf(\"%d %d %d %d %d %d\\n\", n, m, x, y, a, b);\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 9 -m 9 -x 5 -y 5 -a 2 -b 1\n./gen -n 100 -m 100 -x 52 -y 50 -a 46 -b 56\n\n./gen -type small\n./gen -type small\n./gen -type small\n\n./gen -type edge_x\n./gen -type edge_y\n./gen -type corner\n./gen -type corner\n\n./gen -type center\n./gen -type center\n\n./gen -type max\n./gen -type max\n\n./gen -type ratio_large\n./gen -type ratio_large\n\n./gen -type ratio_one\n./gen -type ratio_one\n\n./gen -type aspect_ratio_extreme\n./gen -type aspect_ratio_extreme\n\n./gen -type special\n\n./gen -type random -n 1000000000 -m 1000000000\n./gen -type random -n 1000000000 -m 1000000000\n\n./gen -type random -n 1 -m 1000000000\n./gen -type random -n 1000000000 -m 1\n\n./gen -type random -n 1000000 -m 1000000\n\n./gen -type random\n./gen -type random\n\n./gen -n 1000000000 -m 1000000000 -x 0 -y 0 -a 1 -b 1\n\n./gen -n 1000000000 -m 1000000000 -x 1000000000 -y 1000000000 -a 1000000000 -b 1000000000\n\n./gen -n 1 -m 1 -x 0 -y 0 -a 1 -b 1\n\n./gen -n 2 -m 3 -x 1 -y 1 -a 2 -b 3\n\n./gen -type small\n\n./gen -type max\n\n./gen -type aspect_ratio_extreme\n\n./gen -type random\n\n./gen -type ratio_large\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:05:37.951698",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "304/E",
      "title": "E. Minimum Modular",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains two integers n and k (1  ≤ n  ≤ 5000, 0 ≤ k ≤ 4), which we have mentioned above. The second line contains n distinct integers a1, a2, ..., an (0 ≤ ai ≤ 106).",
      "output_spec": "OutputPrint a single positive integer — the minimum m.",
      "sample_tests": "ExamplesInputCopy7 00 2 3 6 7 12 18OutputCopy13InputCopy7 10 2 3 6 7 12 18OutputCopy7",
      "description": "E. Minimum Modular\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains two integers n and k (1  ≤ n  ≤ 5000, 0 ≤ k ≤ 4), which we have mentioned above. The second line contains n distinct integers a1, a2, ..., an (0 ≤ ai ≤ 106).\n\nOutputPrint a single positive integer — the minimum m.\n\nInputCopy7 00 2 3 6 7 12 18OutputCopy13InputCopy7 10 2 3 6 7 12 18OutputCopy7\n\nInputCopy7 00 2 3 6 7 12 18\n\nOutputCopy13\n\nInputCopy7 10 2 3 6 7 12 18\n\nOutputCopy7",
      "solutions": [
        {
          "title": "Codeforces Round #183 - Codeforces",
          "content": "Three drops in a line, back to yellow so quickly ...Anyway, Codeforces Round #183 will be take place on Sunday, May 12th at 17:00 MSK(21:00 CST). Right after the Google Code Jam Round 1C.Setters are: Yuzhou Gu sevenkplus (For Problem B && E) Yuping Luo roosephu (For Problem A && D) Jiatai Huang CMHJT (Problem C) Testers are YuukaKazami, havaliza, Velicue && me.We gratefully acknowledge Gerald Agapov(Gerald) for his help in giving advise about the problems, Delinur for her help in translating the problems to Russian, and MikeMirzayanov, who has designed such a powerful platform.We strongly recommend you to take a glance over all five problems, there must be one suitable to your taste.Oh one more thing, this time, scoring will be dynamic, but problems are sorted by increasing order of their difficulty as usual.Good Luck!",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/7499",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 830
        },
        {
          "title": "Codeforces Round #183 Editorial - Codeforces",
          "content": "Overview ...。。。(; Д ;) 。Tutorial ... Problem 2A. Pythagorean Theorem II Math, implementationThis problem can be solve by brute-force, but it come up with a nicer solution if we involve some math.Check the following article if you are interested.http://en.wikipedia.org/wiki/Pythagorean_triple#Generating_a_triple Problem 2B. Calender Math, implementationThis problem can be solve by brute-force, but it come up with a nicer solution if we involve some math.Check kabar's code if you are interested.http://codeforces.com/contest/304/submission/3715756 Problem A. Lucky Permutation Triple Math, Constructive algorithms, Congruent when n is odd, A[i] = B[i] = i when n is even, there is no solution. So why? Because: S = \\Sum_{i=0}^{n-1} i = n/2 (mod n) but 2*S = 0 (mod n)See also at:http://codeforces.com/blog/entry/7499#comment-133446 Problem B. Rectangle Puzzle II Math, GeometryGive you n, m, x, y, a, b.Find a maximum sub-rectangle within (0, 0) — (n, m), so that it contains the given point(x, y) and its length-width radio is exactly (a, b). If there are multiple solutions, find the rectangle which is closest to (x, y). If there are still multiple solutions, find the lexicographically minimum one.Split the problem into x-axis and y-axis. Then you can solve the sub tasks in O(1). d = gcd(a,b)\na /= d\nb /= d\nt = min(n/a, m/b)\na *= t\nb *= tBe careful, when the length is outside the original rectangle. Problem C. Minimum Modular Math, Graph theory, Brute-force, CongruentIt is hard to solve this problem at once, so at first, let us consider on k = 0, this easier case can be solved by enumerate on the ans. Let us define a bool array diff[], which diff[x] is weather there are two number, ai, aj, such that abs(ai - aj) = x.So ans is legal <=> diff[ans], diff[2*ans] … are false.The time-complexity O(n2 + mlogm). Here m is the maximum ai.Consider on k > 0, we need to know how many pairs which has difference x. Store them invector<pair <int, int> > diff[x];Then use a dsu to maintain the how many a_i are congruent when enumerate on the ans. Problem D. Rotatable Number Math, Number theory(Coming Soon...)http://codeforces.com/blog/entry/7499#comment-133342 Problem E. Random Ranking Math, Probability(Coming After D...)http://codeforces.com/blog/entry/7499#comment-133488",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/7641",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.6,
            "reason": "宽松匹配: 包含题目编号 304 和字母"
          },
          "content_length": 2283
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #183 - Codeforces - Code 1",
          "code": "from datetime import date\n\na1 = map(int, raw_input().split(\":\"))\na2 = map(int, raw_input().split(\":\"))\n\nprint abs((date(a1[0], a1[1], a1[2]) - date(a2[0], a2[1], a2[2])).days)",
          "language": "Python",
          "source": "https://codeforces.com/blog/entry/7499",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #183 - Codeforces - Code 2",
          "code": "from datetime import date\n\na1 = map(int, raw_input().split(\":\"))\na2 = map(int, raw_input().split(\":\"))\n\nprint abs((date(a1[0], a1[1], a1[2]) - date(a2[0], a2[1], a2[2])).days)",
          "language": "Python",
          "source": "https://codeforces.com/blog/entry/7499",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #183 - Codeforces - Code 3",
          "code": "if (l[i] <= L && r[i] >= R)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7499",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #183 Editorial - Codeforces - Code 1",
          "code": "d = gcd(a,b)\na /= d\nb /= d\nt = min(n/a, m/b)\na *= t\nb *= t",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7641",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #183 Editorial - Codeforces - Code 2",
          "code": "d = gcd(a,b)\na /= d\nb /= d\nt = min(n/a, m/b)\na *= t\nb *= t",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7641",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #183 Editorial - Codeforces - Code 3",
          "code": "vector<pair <int, int> > diff[x];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7641",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    \n    int n = inf.readInt(1, 5000, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(0, 4, \"k\");\n    inf.readEoln();\n    \n    vector<int> a = inf.readInts(n, 0, 1000000, \"a_i\");\n    inf.readEoln();\n\n    set<int> s(a.begin(), a.end());\n    ensuref((int)s.size() == n, \"All ai must be distinct\");\n    \n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    \n    int n = inf.readInt(1, 5000, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(0, 4, \"k\");\n    inf.readEoln();\n    \n    vector<int> a = inf.readInts(n, 0, 1000000, \"a_i\");\n    inf.readEoln();\n\n    set<int> s(a.begin(), a.end());\n    ensuref((int)s.size() == n, \"All ai must be distinct\");\n    \n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    \n    int n = inf.readInt(1, 5000, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(0, 4, \"k\");\n    inf.readEoln();\n    \n    vector<int> a = inf.readInts(n, 0, 1000000, \"a_i\");\n    inf.readEoln();\n\n    set<int> s(a.begin(), a.end());\n    ensuref((int)s.size() == n, \"All ai must be distinct\");\n    \n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int k = opt<int>(\"k\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> a(n);\n\n    if (type == \"random\") {\n        // Generate n unique random integers from 0 to 1e6\n        set<int> used;\n        for (int i = 0; i < n; ++i) {\n            int x;\n            do {\n                x = rnd.next(0, 1000000);\n            } while (used.count(x));\n            used.insert(x);\n            a[i] = x;\n        }\n    } else if (type == \"minimal_m_small\") {\n        // Generate a test case where minimal m is small\n        // Let's set m = 5\n        int m = 5;\n        int cnt = 0;\n        map<int, vector<int>> rem_groups;\n        // First, generate numbers with unique remainders modulo m\n        for (int r = 1; r < m && cnt < n - (k + 1); ++r) {\n            int base = rnd.next(0, 1000000 / m) * m + r;\n            rem_groups[r].push_back(base);\n            cnt++;\n        }\n        // Now, add k + 1 numbers all with the same remainder\n        int same_rem = 0;\n        int base = rnd.next(0, 1000000 / m) * m + same_rem;\n        for (int i = 0; i < k + 1; ++i) {\n            rem_groups[same_rem].push_back(base + i * m + 1);\n            cnt++;\n        }\n        // Compile all numbers\n        vector<int> nums;\n        for (auto &p : rem_groups) {\n            nums.insert(nums.end(), p.second.begin(), p.second.end());\n        }\n        // If not enough numbers, add more unique numbers\n        while ((int)nums.size() < n) {\n            int x;\n            do {\n                x = rnd.next(0, 1000000);\n            } while (find(nums.begin(), nums.end(), x) != nums.end());\n            nums.push_back(x);\n        }\n        shuffle(nums.begin(), nums.end());\n        nums.resize(n);\n        a = nums;\n    } else if (type == \"minimal_m_large\") {\n        // Generate numbers with small differences to make minimal m large\n        int start = rnd.next(n, 1000000);\n        for (int i = 0; i < n; ++i) {\n            a[i] = start - i;\n        }\n    } else if (type == \"k_remove\") {\n        // Generate numbers where unless k elements are removed, remainders modulo m will conflict\n        // Let's pick m = 10\n        int m = 10;\n        int repeats = k + 1;\n        vector<int> nums;\n        // Generate k + 1 numbers with the same remainder\n        int rem = 0;\n        for (int i = 0; i < repeats; ++i) {\n            int x = rnd.next(0, 1000000 / m) * m + rem + i;\n            nums.push_back(x);\n        }\n        // Generate numbers with distinct remainders modulo m\n        for (int r = 1; r < m && (int)nums.size() < n; ++r) {\n            int x = rnd.next(0, 1000000 / m) * m + r;\n            nums.push_back(x);\n        }\n        // If we still need more numbers, generate random unique numbers\n        while ((int)nums.size() < n) {\n            int x;\n            do {\n                x = rnd.next(0, 1000000);\n            } while (find(nums.begin(), nums.end(), x) != nums.end());\n            nums.push_back(x);\n        }\n        shuffle(nums.begin(), nums.end());\n        nums.resize(n);\n        a = nums;\n    } else {\n        // Default random\n        set<int> used;\n        for (int i = 0; i < n; ++i) {\n            int x;\n            do {\n                x = rnd.next(0, 1000000);\n            } while (used.count(x));\n            used.insert(x);\n            a[i] = x;\n        }\n    }\n\n    printf(\"%d %d\\n\", n, k);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d%c\", a[i], i+1 == n ? '\\n' : ' ');\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int k = opt<int>(\"k\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> a(n);\n\n    if (type == \"random\") {\n        // Generate n unique random integers from 0 to 1e6\n        set<int> used;\n        for (int i = 0; i < n; ++i) {\n            int x;\n            do {\n                x = rnd.next(0, 1000000);\n            } while (used.count(x));\n            used.insert(x);\n            a[i] = x;\n        }\n    } else if (type == \"minimal_m_small\") {\n        // Generate a test case where minimal m is small\n        // Let's set m = 5\n        int m = 5;\n        int cnt = 0;\n        map<int, vector<int>> rem_groups;\n        // First, generate numbers with unique remainders modulo m\n        for (int r = 1; r < m && cnt < n - (k + 1); ++r) {\n            int base = rnd.next(0, 1000000 / m) * m + r;\n            rem_groups[r].push_back(base);\n            cnt++;\n        }\n        // Now, add k + 1 numbers all with the same remainder\n        int same_rem = 0;\n        int base = rnd.next(0, 1000000 / m) * m + same_rem;\n        for (int i = 0; i < k + 1; ++i) {\n            rem_groups[same_rem].push_back(base + i * m + 1);\n            cnt++;\n        }\n        // Compile all numbers\n        vector<int> nums;\n        for (auto &p : rem_groups) {\n            nums.insert(nums.end(), p.second.begin(), p.second.end());\n        }\n        // If not enough numbers, add more unique numbers\n        while ((int)nums.size() < n) {\n            int x;\n            do {\n                x = rnd.next(0, 1000000);\n            } while (find(nums.begin(), nums.end(), x) != nums.end());\n            nums.push_back(x);\n        }\n        shuffle(nums.begin(), nums.end());\n        nums.resize(n);\n        a = nums;\n    } else if (type == \"minimal_m_large\") {\n        // Generate numbers with small differences to make minimal m large\n        int start = rnd.next(n, 1000000);\n        for (int i = 0; i < n; ++i) {\n            a[i] = start - i;\n        }\n    } else if (type == \"k_remove\") {\n        // Generate numbers where unless k elements are removed, remainders modulo m will conflict\n        // Let's pick m = 10\n        int m = 10;\n        int repeats = k + 1;\n        vector<int> nums;\n        // Generate k + 1 numbers with the same remainder\n        int rem = 0;\n        for (int i = 0; i < repeats; ++i) {\n            int x = rnd.next(0, 1000000 / m) * m + rem + i;\n            nums.push_back(x);\n        }\n        // Generate numbers with distinct remainders modulo m\n        for (int r = 1; r < m && (int)nums.size() < n; ++r) {\n            int x = rnd.next(0, 1000000 / m) * m + r;\n            nums.push_back(x);\n        }\n        // If we still need more numbers, generate random unique numbers\n        while ((int)nums.size() < n) {\n            int x;\n            do {\n                x = rnd.next(0, 1000000);\n            } while (find(nums.begin(), nums.end(), x) != nums.end());\n            nums.push_back(x);\n        }\n        shuffle(nums.begin(), nums.end());\n        nums.resize(n);\n        a = nums;\n    } else {\n        // Default random\n        set<int> used;\n        for (int i = 0; i < n; ++i) {\n            int x;\n            do {\n                x = rnd.next(0, 1000000);\n            } while (used.count(x));\n            used.insert(x);\n            a[i] = x;\n        }\n    }\n\n    printf(\"%d %d\\n\", n, k);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d%c\", a[i], i+1 == n ? '\\n' : ' ');\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -k 0 -type random\n./gen -n 1 -k 1 -type random\n\n./gen -n 2 -k 0 -type random\n./gen -n 2 -k 4 -type random\n\n./gen -n 5 -k 0 -type random\n./gen -n 5 -k 2 -type random\n./gen -n 5 -k 4 -type random\n\n./gen -n 5 -k 0 -type minimal_m_small\n./gen -n 5 -k 4 -type minimal_m_small\n\n./gen -n 5 -k 0 -type minimal_m_large\n./gen -n 5 -k 4 -type minimal_m_large\n\n./gen -n 5 -k 0 -type k_remove\n./gen -n 5 -k 4 -type k_remove\n\n./gen -n 50 -k 0 -type random\n./gen -n 50 -k 4 -type random\n\n./gen -n 50 -k 0 -type minimal_m_small\n./gen -n 50 -k 4 -type minimal_m_small\n\n./gen -n 50 -k 0 -type minimal_m_large\n./gen -n 50 -k 4 -type minimal_m_large\n\n./gen -n 50 -k 0 -type k_remove\n./gen -n 50 -k 4 -type k_remove\n\n./gen -n 5000 -k 0 -type random\n./gen -n 5000 -k 4 -type random\n\n./gen -n 5000 -k 0 -type minimal_m_small\n./gen -n 5000 -k 4 -type minimal_m_small\n\n./gen -n 5000 -k 0 -type minimal_m_large\n./gen -n 5000 -k 4 -type minimal_m_large\n\n./gen -n 5000 -k 0 -type k_remove\n./gen -n 5000 -k 4 -type k_remove\n\n./gen -n 3000 -k 2 -type random\n./gen -n 3000 -k 2 -type minimal_m_small\n./gen -n 3000 -k 2 -type minimal_m_large\n./gen -n 3000 -k 2 -type k_remove\n\n./gen -n 1000 -k 0 -type random\n./gen -n 1000 -k 4 -type random\n\n./gen -n 1000 -k 0 -type minimal_m_small\n./gen -n 1000 -k 4 -type minimal_m_small\n\n./gen -n 1000 -k 0 -type minimal_m_large\n./gen -n 1000 -k 4 -type minimal_m_large\n\n./gen -n 1000 -k 0 -type k_remove\n./gen -n 1000 -k 4 -type k_remove\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:05:39.872505",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "305/A",
      "title": "A. Strange Addition",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first input line contains integer k (1 ≤ k ≤ 100) — the number of integers.The second line contains k distinct space-separated integers d1, d2, ..., dk (0 ≤ di ≤ 100).",
      "output_spec": "OutputIn the first line print a single integer n the maximum number of the chosen integers. In the second line print n distinct non-negative integers — the required integers.If there are multiple solutions, print any of them. You can print the numbers in any order.",
      "sample_tests": "ExamplesInputCopy4100 10 1 0OutputCopy40 1 10 100 InputCopy32 70 3OutputCopy22 70",
      "description": "A. Strange Addition\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first input line contains integer k (1 ≤ k ≤ 100) — the number of integers.The second line contains k distinct space-separated integers d1, d2, ..., dk (0 ≤ di ≤ 100).\n\nOutputIn the first line print a single integer n the maximum number of the chosen integers. In the second line print n distinct non-negative integers — the required integers.If there are multiple solutions, print any of them. You can print the numbers in any order.\n\nInputCopy4100 10 1 0OutputCopy40 1 10 100 InputCopy32 70 3OutputCopy22 70\n\nInputCopy4100 10 1 0\n\nOutputCopy40 1 10 100\n\nInputCopy32 70 3\n\nOutputCopy22 70",
      "solutions": [
        {
          "title": "Codeforces Round #184 (Div. 2) - Codeforces",
          "content": "Hello!A few hours later, on May 19th at 17:00 MSK, you are lucky to participate in Codeforces Round #184 for Div. 2 participants. Traditionally, Div. 1 participants can take part out of the competition.Problems have been prepared by: Gridnev Vitaliy (gridnevvvit), Ignatyev Alexander (aiMR). It’s our second round and I hope not last. We want to thank Gerald Agapov(Gerald) for help in preparation of this round, Michael Mirzayanov(MikeMirzayanov) for marvelous Codeforces and Polygon systems, Mary Belova(Delinur) for translating the problems.We hope you will like these problems, and that it will be fun to solve them. Also we strongly recommend you to read all the problems.We wish everyone good luck and high rating!UPD1: Scoring will be standart: 500, 1000, 1500, 2000, 2500.UPD2: EditorialUPD3: Congratulations to winners: SillyHook06 hyplymac HAPKOMAH",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/7708",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 858
        },
        {
          "title": "Codeforces Round #184 (Div. 2) - Codeforces",
          "content": "Hello!A few hours later, on May 19th at 17:00 MSK, you are lucky to participate in Codeforces Round #184 for Div. 2 participants. Traditionally, Div. 1 participants can take part out of the competition.Problems have been prepared by: Gridnev Vitaliy (gridnevvvit), Ignatyev Alexander (aiMR). It’s our second round and I hope not last. We want to thank Gerald Agapov(Gerald) for help in preparation of this round, Michael Mirzayanov(MikeMirzayanov) for marvelous Codeforces and Polygon systems, Mary Belova(Delinur) for translating the problems.We hope you will like these problems, and that it will be fun to solve them. Also we strongly recommend you to read all the problems.We wish everyone good luck and high rating!UPD1: Scoring will be standart: 500, 1000, 1500, 2000, 2500.UPD2: EditorialUPD3: Congratulations to winners: SillyHook06 hyplymac HAPKOMAH",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/7708",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 858
        },
        {
          "title": "Editorial Codeforces Round #184 (Div.2) - Codeforces",
          "content": "305A - Strange AdditionAll you have to do is implement following algorithm: If we have numbers 0 or 100, we take them to needed subset. If we got number greater than 0 and less than 10, we take it. If we got number divisible by 10 we take it. In case we have no numbers of second and third type, we take a number that is not divisible by 10 Solution305B - Continued FractionsThere are at most two ways to represent rational fraction as continued. Using Euclid algorithm you can do that for and then check equality of corresponding ai.Solution305C - Ivan and Powers of TwoFirst of all, let's carry over all powers of two in the following way: if we have ai = aj, i ≠ j, carry 1 to ai + 1. Now as all of ai are distinct, the answer is max(ai) — cnt(ai) + 1, where max(ai) — maximal value of ai,cnt(ai) — size of aSolution305D - Olya and GraphFirst of all let's consider a graph on a number line. It's neccesary to have edges i -  > i + 1(first type). Also you can edges like i -  > i + k + 1 (second type). Other edges are forbidden. This allows us to understand whether the answer is 0 or not. Also answer is 0 when all edges of second type doesn't intersect, considering them to be segments of number line, except when k ≥ n - 1 — in this case answer is 1. Now we know that answer != 0. Frow all edges we have let's use only second type edges. If there aren't any of this edges we can add 1 to the answer, because of possibility of adding 0 edges to graph. For every vertex i, that has possibility of adding second type edges, let's add to answer 2cnt, cnt — amount of vertexes on [i, min(i + k, n — k — 1)] without edges of second type out of them. Also it is necessary for all the second type edges to start in this segment.Solution O(n + m) Solution O(m + log(n))305E - Playing with StringLet's consider substring of s s[i... j], that all characters from i to j are palindrome centers, and i - 1, j + 1 are not. Every such substring can be treated independently from the others, and as we don't need to know it'sstructure let's consider only it length len. Let's calculate grundy[len] — Grundy function. If we want to cut character at position i 0 ≤ i < len then our game splits in to independent ones: first will have length i - 1, second — len - i - 2, as s[i - 1] and s[i + 1] are not centers of palindrome any more.Solution",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/7712",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 305\\s*A"
          },
          "content_length": 2330
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #184 (Div. 2) - Codeforces - Code 1",
          "code": "Vasya can only sum pairs of integers (a, b), such that for \nany decimal place at least one number has digit 0 in this place",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7708",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #184 (Div. 2) - Codeforces - Code 2",
          "code": "Vasya can only sum pairs of integers (a, b), such that for \nany decimal place at least one number has digit 0 in this place",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7708",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #184 (Div. 2) - Codeforces - Code 1",
          "code": "Vasya can only sum pairs of integers (a, b), such that for \nany decimal place at least one number has digit 0 in this place",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7708",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #184 (Div. 2) - Codeforces - Code 2",
          "code": "Vasya can only sum pairs of integers (a, b), such that for \nany decimal place at least one number has digit 0 in this place",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7708",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int k = inf.readInt(1, 100, \"k\");\n    inf.readEoln();\n\n    vector<int> d = inf.readInts(k, 0, 100, \"d\");\n    inf.readEoln();\n\n    set<int> d_set(d.begin(), d.end());\n    ensuref((int)d_set.size() == k, \"All di must be distinct\");\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int k = inf.readInt(1, 100, \"k\");\n    inf.readEoln();\n\n    vector<int> d = inf.readInts(k, 0, 100, \"d\");\n    inf.readEoln();\n\n    set<int> d_set(d.begin(), d.end());\n    ensuref((int)d_set.size() == k, \"All di must be distinct\");\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int k = inf.readInt(1, 100, \"k\");\n    inf.readEoln();\n\n    vector<int> d = inf.readInts(k, 0, 100, \"d\");\n    inf.readEoln();\n\n    set<int> d_set(d.begin(), d.end());\n    ensuref((int)d_set.size() == k, \"All di must be distinct\");\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\n/**\n * This function checks whether Vasya can sum the numbers a and b.\n * It returns true if, for every decimal place, at least one of a or b has digit 0.\n */\nbool can_sum(int a, int b) {\n    for (int pos = 0; pos < 3; ++pos) {\n        int digit_a = (a / (int)(pow(10, pos))) % 10;\n        int digit_b = (b / (int)(pow(10, pos))) % 10;\n        if (digit_a != 0 && digit_b != 0) {\n            return false;\n        }\n    }\n    return true;\n}\n\n/**\n * This function reads the answer from the given stream, validates it,\n * and stores the number of selected integers and their values.\n * If the answer is invalid, it reports an error using stream.quitf().\n */\nvoid readAns(InStream& stream, int& n, vector<int>& numbers, const set<int>& di_set, int k) {\n    n = stream.readInt(0, k, \"n\");\n    if (n == 0) {\n        return;\n    }\n    numbers.resize(n);\n    set<int> used_numbers;\n    for (int i = 0; i < n; ++i) {\n        numbers[i] = stream.readInt(0, 100, format(\"numbers[%d]\", i + 1).c_str());\n        if (di_set.find(numbers[i]) == di_set.end()) {\n            stream.quitf(_wa, \"number %d is not from the original set\", numbers[i]);\n        }\n        if (used_numbers.find(numbers[i]) != used_numbers.end()) {\n            stream.quitf(_wa, \"number %d is used more than once\", numbers[i]);\n        }\n        used_numbers.insert(numbers[i]);\n    }\n    // Validate that any pair of numbers can be summed by Vasya\n    for (int i = 0; i < n; ++i) {\n        for (int j = i + 1; j < n; ++j) {\n            if (!can_sum(numbers[i], numbers[j])) {\n                stream.quitf(_wa, \"numbers %d and %d cannot be summed according to the rule\", numbers[i], numbers[j]);\n            }\n        }\n    }\n}\n\nint main(int argc, char* argv[]) {\n    registerTestlibCmd(argc, argv);\n\n    // Read k and the set of integers di from the input file\n    int k = inf.readInt();\n    vector<int> di(k);\n    set<int> di_set;\n    for (int i = 0; i < k; ++i) {\n        di[i] = inf.readInt(0, 100);\n        di_set.insert(di[i]);\n    }\n\n    // Read the jury's answer\n    int n_ans;\n    vector<int> numbers_ans;\n    readAns(ans, n_ans, numbers_ans, di_set, k);\n\n    // Read the contestant's output and validate it\n    int n_ouf;\n    vector<int> numbers_ouf;\n    readAns(ouf, n_ouf, numbers_ouf, di_set, k);\n\n    // Compare the contestant's n with the jury's n\n    if (n_ouf > n_ans) {\n        quitf(_fail, \"Participant's n=%d is greater than jury's n=%d\", n_ouf, n_ans);\n    } else if (n_ouf < n_ans) {\n        quitf(_wa, \"Participant's n=%d is less than expected n=%d\", n_ouf, n_ans);\n    } else {\n        quitf(_ok, \"Correct answer with n=%d\", n_ouf);\n    }\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int k = opt<int>(\"k\"); // Number of integers\n    string type = opt<string>(\"type\", \"random\"); // Type of test case\n\n    vector<int> di;\n\n    if (type == \"random\") {\n        // Generate k distinct random integers in [0,100]\n        set<int> s;\n        while (int(s.size()) < k) {\n            int x = rnd.next(0, 100);\n            s.insert(x);\n        }\n        di.assign(s.begin(), s.end());\n        shuffle(di.begin(), di.end());\n\n    } else if (type == \"no_zeros\") {\n        // Generate k distinct numbers in [1,100], with no zeros in their digits\n        vector<int> candidates;\n        for (int i = 1; i <= 100; ++i) {\n            string s = to_string(i);\n            if (s.find('0') == string::npos) {\n                candidates.push_back(i);\n            }\n        }\n        shuffle(candidates.begin(), candidates.end());\n        k = min(k, int(candidates.size()));\n        di.assign(candidates.begin(), candidates.begin() + k);\n\n    } else if (type == \"has_zeros\") {\n        // Generate k distinct numbers in [0,100], that have zeros in their digits\n        vector<int> candidates;\n        for (int i = 0; i <= 100; ++i) {\n            string s = to_string(i);\n            if (s.find('0') != string::npos) {\n                candidates.push_back(i);\n            }\n        }\n        shuffle(candidates.begin(), candidates.end());\n        k = min(k, int(candidates.size()));\n        di.assign(candidates.begin(), candidates.begin() + k);\n\n    } else if (type == \"max_n\") {\n        // Generate k numbers so that n is maximized\n        vector<int> nums = {0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100};\n        shuffle(nums.begin(), nums.end());\n        k = min(k, int(nums.size()));\n        di.assign(nums.begin(), nums.begin() + k);\n\n    } else if (type == \"min_n\") {\n        // Generate k numbers so that n is minimized\n        vector<int> candidates;\n        for (int i = 1; i <= 100; ++i) {\n            string s = to_string(i);\n            if (s.find('0') == string::npos) {\n                candidates.push_back(i);\n            }\n        }\n        shuffle(candidates.begin(), candidates.end());\n        k = min(k, int(candidates.size()));\n        di.assign(candidates.begin(), candidates.begin() + k);\n\n    } else if (type == \"mixed\") {\n        // Generate a mix of numbers with and without zeros\n        vector<int> candidates_with_zeros;\n        vector<int> candidates_without_zeros;\n        for (int i = 0; i <= 100; ++i) {\n            string s = to_string(i);\n            if (s.find('0') != string::npos) {\n                candidates_with_zeros.push_back(i);\n            } else {\n                candidates_without_zeros.push_back(i);\n            }\n        }\n        shuffle(candidates_with_zeros.begin(), candidates_with_zeros.end());\n        shuffle(candidates_without_zeros.begin(), candidates_without_zeros.end());\n\n        int k1 = k / 2;\n        int k2 = k - k1;\n        k1 = min(k1, int(candidates_with_zeros.size()));\n        k2 = min(k2, int(candidates_without_zeros.size()));\n        di.insert(di.end(), candidates_with_zeros.begin(), candidates_with_zeros.begin() + k1);\n        di.insert(di.end(), candidates_without_zeros.begin(), candidates_without_zeros.begin() + k2);\n        shuffle(di.begin(), di.end());\n\n    } else if (type == \"single_digit\") {\n        // Generate k distinct single-digit numbers (0 to 9)\n        vector<int> candidates;\n        for (int i = 0; i <= 9; ++i) {\n            candidates.push_back(i);\n        }\n        shuffle(candidates.begin(), candidates.end());\n        k = min(k, int(candidates.size()));\n        di.assign(candidates.begin(), candidates.begin() + k);\n\n    } else if (type == \"max_k\") {\n        // Set k to 100, generate numbers from 1 to 100\n        k = 100;\n        di.clear();\n        for (int i = 1; i <= 100; ++i) {\n            di.push_back(i);\n        }\n        shuffle(di.begin(), di.end());\n\n    } else {\n        // Default random\n        set<int> s;\n        while (int(s.size()) < k) {\n            int x = rnd.next(0,100);\n            s.insert(x);\n        }\n        di.assign(s.begin(), s.end());\n        shuffle(di.begin(), di.end());\n    }\n\n    // Output\n    printf(\"%d\\n\", k);\n    for(int i = 0; i < k; ++i) {\n        printf(\"%d%c\", di[i], i+1 == k ? '\\n' : ' ');\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int k = opt<int>(\"k\"); // Number of integers\n    string type = opt<string>(\"type\", \"random\"); // Type of test case\n\n    vector<int> di;\n\n    if (type == \"random\") {\n        // Generate k distinct random integers in [0,100]\n        set<int> s;\n        while (int(s.size()) < k) {\n            int x = rnd.next(0, 100);\n            s.insert(x);\n        }\n        di.assign(s.begin(), s.end());\n        shuffle(di.begin(), di.end());\n\n    } else if (type == \"no_zeros\") {\n        // Generate k distinct numbers in [1,100], with no zeros in their digits\n        vector<int> candidates;\n        for (int i = 1; i <= 100; ++i) {\n            string s = to_string(i);\n            if (s.find('0') == string::npos) {\n                candidates.push_back(i);\n            }\n        }\n        shuffle(candidates.begin(), candidates.end());\n        k = min(k, int(candidates.size()));\n        di.assign(candidates.begin(), candidates.begin() + k);\n\n    } else if (type == \"has_zeros\") {\n        // Generate k distinct numbers in [0,100], that have zeros in their digits\n        vector<int> candidates;\n        for (int i = 0; i <= 100; ++i) {\n            string s = to_string(i);\n            if (s.find('0') != string::npos) {\n                candidates.push_back(i);\n            }\n        }\n        shuffle(candidates.begin(), candidates.end());\n        k = min(k, int(candidates.size()));\n        di.assign(candidates.begin(), candidates.begin() + k);\n\n    } else if (type == \"max_n\") {\n        // Generate k numbers so that n is maximized\n        vector<int> nums = {0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100};\n        shuffle(nums.begin(), nums.end());\n        k = min(k, int(nums.size()));\n        di.assign(nums.begin(), nums.begin() + k);\n\n    } else if (type == \"min_n\") {\n        // Generate k numbers so that n is minimized\n        vector<int> candidates;\n        for (int i = 1; i <= 100; ++i) {\n            string s = to_string(i);\n            if (s.find('0') == string::npos) {\n                candidates.push_back(i);\n            }\n        }\n        shuffle(candidates.begin(), candidates.end());\n        k = min(k, int(candidates.size()));\n        di.assign(candidates.begin(), candidates.begin() + k);\n\n    } else if (type == \"mixed\") {\n        // Generate a mix of numbers with and without zeros\n        vector<int> candidates_with_zeros;\n        vector<int> candidates_without_zeros;\n        for (int i = 0; i <= 100; ++i) {\n            string s = to_string(i);\n            if (s.find('0') != string::npos) {\n                candidates_with_zeros.push_back(i);\n            } else {\n                candidates_without_zeros.push_back(i);\n            }\n        }\n        shuffle(candidates_with_zeros.begin(), candidates_with_zeros.end());\n        shuffle(candidates_without_zeros.begin(), candidates_without_zeros.end());\n\n        int k1 = k / 2;\n        int k2 = k - k1;\n        k1 = min(k1, int(candidates_with_zeros.size()));\n        k2 = min(k2, int(candidates_without_zeros.size()));\n        di.insert(di.end(), candidates_with_zeros.begin(), candidates_with_zeros.begin() + k1);\n        di.insert(di.end(), candidates_without_zeros.begin(), candidates_without_zeros.begin() + k2);\n        shuffle(di.begin(), di.end());\n\n    } else if (type == \"single_digit\") {\n        // Generate k distinct single-digit numbers (0 to 9)\n        vector<int> candidates;\n        for (int i = 0; i <= 9; ++i) {\n            candidates.push_back(i);\n        }\n        shuffle(candidates.begin(), candidates.end());\n        k = min(k, int(candidates.size()));\n        di.assign(candidates.begin(), candidates.begin() + k);\n\n    } else if (type == \"max_k\") {\n        // Set k to 100, generate numbers from 1 to 100\n        k = 100;\n        di.clear();\n        for (int i = 1; i <= 100; ++i) {\n            di.push_back(i);\n        }\n        shuffle(di.begin(), di.end());\n\n    } else {\n        // Default random\n        set<int> s;\n        while (int(s.size()) < k) {\n            int x = rnd.next(0,100);\n            s.insert(x);\n        }\n        di.assign(s.begin(), s.end());\n        shuffle(di.begin(), di.end());\n    }\n\n    // Output\n    printf(\"%d\\n\", k);\n    for(int i = 0; i < k; ++i) {\n        printf(\"%d%c\", di[i], i+1 == k ? '\\n' : ' ');\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -k 1 -type random\n./gen -k 100 -type random\n./gen -k 50 -type random\n./gen -k 99 -type no_zeros\n./gen -k 90 -type no_zeros\n./gen -k 10 -type no_zeros\n./gen -k 11 -type has_zeros\n./gen -k 10 -type has_zeros\n./gen -k 11 -type max_n\n./gen -k 10 -type max_n\n./gen -k 10 -type min_n\n./gen -k 50 -type min_n\n./gen -k 15 -type mixed\n./gen -k 30 -type mixed\n./gen -k 9 -type single_digit\n./gen -k 10 -type single_digit\n./gen -k 100 -type max_k\n./gen -k 100 -type max_n\n./gen -k 100 -type min_n\n./gen -k 15 -type random\n./gen -k 30 -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:05:42.274922",
        "total_tutorials": 3,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "305/B",
      "title": "B. Continued Fractions",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains two space-separated integers p, q (1 ≤ q ≤ p ≤ 1018) — the numerator and the denominator of the first fraction.The second line contains integer n (1 ≤ n ≤ 90) — the height of the second fraction. The third line contains n space-separated integers a1, a2, ..., an (1 ≤ ai ≤ 1018) — the continued fraction.Please, do not use the %lld specifier to read or write 64-bit integers in С++. It is preferred to use the cin, cout streams or the %I64d specifier.",
      "output_spec": "OutputPrint \"YES\" if these fractions are equal and \"NO\" otherwise.",
      "sample_tests": "ExamplesInputCopy9 422 4OutputCopyYESInputCopy9 432 3 1OutputCopyYESInputCopy9 431 2 4OutputCopyNO",
      "description": "B. Continued Fractions\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains two space-separated integers p, q (1 ≤ q ≤ p ≤ 1018) — the numerator and the denominator of the first fraction.The second line contains integer n (1 ≤ n ≤ 90) — the height of the second fraction. The third line contains n space-separated integers a1, a2, ..., an (1 ≤ ai ≤ 1018) — the continued fraction.Please, do not use the %lld specifier to read or write 64-bit integers in С++. It is preferred to use the cin, cout streams or the %I64d specifier.\n\nOutputPrint \"YES\" if these fractions are equal and \"NO\" otherwise.\n\nInputCopy9 422 4OutputCopyYESInputCopy9 432 3 1OutputCopyYESInputCopy9 431 2 4OutputCopyNO\n\nInputCopy9 422 4\n\nOutputCopyYES\n\nInputCopy9 432 3 1\n\nOutputCopyYES\n\nInputCopy9 431 2 4\n\nOutputCopyNO\n\nNoteIn the first sample .In the second sample .In the third sample .",
      "solutions": [
        {
          "title": "Codeforces Round #184 (Div. 2) - Codeforces",
          "content": "Hello!A few hours later, on May 19th at 17:00 MSK, you are lucky to participate in Codeforces Round #184 for Div. 2 participants. Traditionally, Div. 1 participants can take part out of the competition.Problems have been prepared by: Gridnev Vitaliy (gridnevvvit), Ignatyev Alexander (aiMR). It’s our second round and I hope not last. We want to thank Gerald Agapov(Gerald) for help in preparation of this round, Michael Mirzayanov(MikeMirzayanov) for marvelous Codeforces and Polygon systems, Mary Belova(Delinur) for translating the problems.We hope you will like these problems, and that it will be fun to solve them. Also we strongly recommend you to read all the problems.We wish everyone good luck and high rating!UPD1: Scoring will be standart: 500, 1000, 1500, 2000, 2500.UPD2: EditorialUPD3: Congratulations to winners: SillyHook06 hyplymac HAPKOMAH",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/7708",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 858
        },
        {
          "title": "Codeforces Round #184 (Div. 2) - Codeforces",
          "content": "Hello!A few hours later, on May 19th at 17:00 MSK, you are lucky to participate in Codeforces Round #184 for Div. 2 participants. Traditionally, Div. 1 participants can take part out of the competition.Problems have been prepared by: Gridnev Vitaliy (gridnevvvit), Ignatyev Alexander (aiMR). It’s our second round and I hope not last. We want to thank Gerald Agapov(Gerald) for help in preparation of this round, Michael Mirzayanov(MikeMirzayanov) for marvelous Codeforces and Polygon systems, Mary Belova(Delinur) for translating the problems.We hope you will like these problems, and that it will be fun to solve them. Also we strongly recommend you to read all the problems.We wish everyone good luck and high rating!UPD1: Scoring will be standart: 500, 1000, 1500, 2000, 2500.UPD2: EditorialUPD3: Congratulations to winners: SillyHook06 hyplymac HAPKOMAH",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/7708",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 858
        },
        {
          "title": "Editorial Codeforces Round #184 (Div.2) - Codeforces",
          "content": "305A - Strange AdditionAll you have to do is implement following algorithm: If we have numbers 0 or 100, we take them to needed subset. If we got number greater than 0 and less than 10, we take it. If we got number divisible by 10 we take it. In case we have no numbers of second and third type, we take a number that is not divisible by 10 Solution305B - Continued FractionsThere are at most two ways to represent rational fraction as continued. Using Euclid algorithm you can do that for and then check equality of corresponding ai.Solution305C - Ivan and Powers of TwoFirst of all, let's carry over all powers of two in the following way: if we have ai = aj, i ≠ j, carry 1 to ai + 1. Now as all of ai are distinct, the answer is max(ai) — cnt(ai) + 1, where max(ai) — maximal value of ai,cnt(ai) — size of aSolution305D - Olya and GraphFirst of all let's consider a graph on a number line. It's neccesary to have edges i -  > i + 1(first type). Also you can edges like i -  > i + k + 1 (second type). Other edges are forbidden. This allows us to understand whether the answer is 0 or not. Also answer is 0 when all edges of second type doesn't intersect, considering them to be segments of number line, except when k ≥ n - 1 — in this case answer is 1. Now we know that answer != 0. Frow all edges we have let's use only second type edges. If there aren't any of this edges we can add 1 to the answer, because of possibility of adding 0 edges to graph. For every vertex i, that has possibility of adding second type edges, let's add to answer 2cnt, cnt — amount of vertexes on [i, min(i + k, n — k — 1)] without edges of second type out of them. Also it is necessary for all the second type edges to start in this segment.Solution O(n + m) Solution O(m + log(n))305E - Playing with StringLet's consider substring of s s[i... j], that all characters from i to j are palindrome centers, and i - 1, j + 1 are not. Every such substring can be treated independently from the others, and as we don't need to know it'sstructure let's consider only it length len. Let's calculate grundy[len] — Grundy function. If we want to cut character at position i 0 ≤ i < len then our game splits in to independent ones: first will have length i - 1, second — len - i - 2, as s[i - 1] and s[i + 1] are not centers of palindrome any more.Solution",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/7712",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 305\\s*B"
          },
          "content_length": 2330
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #184 (Div. 2) - Codeforces - Code 1",
          "code": "Vasya can only sum pairs of integers (a, b), such that for \nany decimal place at least one number has digit 0 in this place",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7708",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #184 (Div. 2) - Codeforces - Code 2",
          "code": "Vasya can only sum pairs of integers (a, b), such that for \nany decimal place at least one number has digit 0 in this place",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7708",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #184 (Div. 2) - Codeforces - Code 1",
          "code": "Vasya can only sum pairs of integers (a, b), such that for \nany decimal place at least one number has digit 0 in this place",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7708",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #184 (Div. 2) - Codeforces - Code 2",
          "code": "Vasya can only sum pairs of integers (a, b), such that for \nany decimal place at least one number has digit 0 in this place",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7708",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    const long long MAX_PQ = 1000000000000000000LL;\n    const long long MAX_AI = 1000000000000000000LL;\n\n    // Read p\n    long long p = inf.readLong(1LL, MAX_PQ, \"p\");\n    inf.readSpace();\n    // Read q\n    long long q = inf.readLong(1LL, p, \"q\");\n    inf.readEoln();\n\n    // Read n\n    int n = inf.readInt(1, 90, \"n\");\n    inf.readEoln();\n\n    // Read a_i\n    vector<long long> a = inf.readLongs(n, 1LL, MAX_AI, \"a_i\");\n    inf.readEoln();\n\n    // Ensure EOF\n    inf.readEof();\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    const long long MAX_PQ = 1000000000000000000LL;\n    const long long MAX_AI = 1000000000000000000LL;\n\n    // Read p\n    long long p = inf.readLong(1LL, MAX_PQ, \"p\");\n    inf.readSpace();\n    // Read q\n    long long q = inf.readLong(1LL, p, \"q\");\n    inf.readEoln();\n\n    // Read n\n    int n = inf.readInt(1, 90, \"n\");\n    inf.readEoln();\n\n    // Read a_i\n    vector<long long> a = inf.readLongs(n, 1LL, MAX_AI, \"a_i\");\n    inf.readEoln();\n\n    // Ensure EOF\n    inf.readEof();\n\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    const long long MAX_PQ = 1000000000000000000LL;\n    const long long MAX_AI = 1000000000000000000LL;\n\n    // Read p\n    long long p = inf.readLong(1LL, MAX_PQ, \"p\");\n    inf.readSpace();\n    // Read q\n    long long q = inf.readLong(1LL, p, \"q\");\n    inf.readEoln();\n\n    // Read n\n    int n = inf.readInt(1, 90, \"n\");\n    inf.readEoln();\n\n    // Read a_i\n    vector<long long> a = inf.readLongs(n, 1LL, MAX_AI, \"a_i\");\n    inf.readEoln();\n\n    // Ensure EOF\n    inf.readEof();\n\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n#include <string>\r\n\r\nusing namespace std;\r\n\r\nconst string YES = \"YES\";\r\nconst string NO = \"NO\";\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"%s\", (\"multiple \" + YES + \"/\" + NO + \" (case insensitive)\").c_str());\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int index = 0, yesCount = 0, noCount = 0;\r\n    string pa;\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        index++;\r\n        string ja = upperCase(ans.readToken());\r\n        pa = upperCase(ouf.readToken());\r\n\r\n        if (ja != YES && ja != NO)\r\n            quitf(_fail, \"%s or %s expected in answer, but %s found [%d%s token]\",\r\n                  YES.c_str(), NO.c_str(), compress(ja).c_str(), index, englishEnding(index).c_str());\r\n\r\n        if (pa == YES)\r\n            yesCount++;\r\n        else if (pa == NO)\r\n            noCount++;\r\n        else\r\n            quitf(_pe, \"%s or %s expected, but %s found [%d%s token]\",\r\n                  YES.c_str(), NO.c_str(), compress(pa).c_str(), index, englishEnding(index).c_str());\r\n\r\n        if (ja != pa)\r\n            quitf(_wa, \"expected %s, found %s [%d%s token]\",\r\n                  compress(ja).c_str(), compress(pa).c_str(), index, englishEnding(index).c_str());\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n    while (!ans.seekEof()) {\r\n        ans.readToken();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n    while (!ouf.seekEof()) {\r\n        ouf.readToken();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              index + extraInAnsCount, index);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              index + extraInOufCount, index);\r\n\r\n    if (index == 0)\r\n        quitf(_ok, \"Empty output\");\r\n    else if (index == 1)\r\n        quitf(_ok, \"%s\", pa.c_str());\r\n    else\r\n        quitf(_ok, \"%d token(s): yes count is %d, no count is %d\", index, yesCount, noCount);\r\n\r\n    quitf(_fail, \"Impossible case\");\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nusing ll = long long;\n\nvoid printll(ll n) {\n    printf(\"%lld\", n);\n}\n\nvector<ll> fraction_to_continued_fraction(ll p, ll q) {\n    vector<ll> cf;\n    while (q != 0) {\n        ll a = p / q;\n        cf.push_back(a);\n        ll r = p % q;\n        p = q;\n        q = r;\n    }\n    return cf;\n}\n\npair<ll, ll> continued_fraction_to_fraction(const vector<ll>& cf) {\n    int n = cf.size();\n    ll num = cf.back();\n    ll den = 1;\n\n    for (int i = n - 2; i >= 0; --i) {\n        ll a = cf[i];\n        // Prevent overflow\n        if (a > (ll)1e9 || num > (ll)1e9 || den > (ll)1e9) {\n            return { (ll)1e18+1, (ll)1e18+1 }; // Indicate overflow\n        }\n\n        ll temp_num = a * num + den;\n        den = num;\n        num = temp_num;\n\n        // Simplify fraction\n        ll g = __gcd(num, den);\n        num /= g;\n        den /= g;\n\n        if (num > (ll)1e18 || den > (ll)1e18) {\n            return { (ll)1e18+1, (ll)1e18+1 }; // Indicate overflow\n        }\n    }\n    return {num, den};\n}\n\nvoid simplify(ll &num, ll &den) {\n    ll g = __gcd(num, den);\n    num /= g;\n    den /= g;\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\", -1);\n    string type = opt<string>(\"type\", \"equal\");\n\n    if (type == \"equal\") {\n        // Generate random p and q\n        ll p = rnd.next(1LL, (ll)1e18);\n        ll q = rnd.next(1LL, p);\n\n        simplify(p, q);\n\n        vector<ll> cf = fraction_to_continued_fraction(p, q);\n\n        if (n != -1 && n != (int)cf.size()) {\n            // Cannot adjust n, proceed with actual size\n            n = cf.size();\n        } else {\n            n = cf.size();\n        }\n\n        // Output p and q\n        printll(p);\n        printf(\" \");\n        printll(q);\n        printf(\"\\n\");\n\n        // Output n\n        printf(\"%d\\n\", n);\n\n        // Output sequence cf\n        for (int i = 0; i < n; ++i) {\n            printll(cf[i]);\n            if (i < n -1)\n                printf(\" \");\n        }\n        printf(\"\\n\");\n    } else if (type == \"notequal\") {\n        // Generate random p and q\n        ll p = rnd.next(1LL, (ll)1e18);\n        ll q = rnd.next(1LL, p);\n\n        simplify(p, q);\n\n        if (n == -1)\n            n = rnd.next(1, 90);\n\n        vector<ll> cf(n);\n        for (int i = 0; i < n; ++i) {\n            cf[i] = rnd.next(1LL, (ll)1e6); // Use smaller a_i to prevent overflow\n        }\n\n        pair<ll, ll> frac_cf = continued_fraction_to_fraction(cf);\n        simplify(frac_cf.first, frac_cf.second);\n\n        if (frac_cf.first == p && frac_cf.second == q) {\n            // Make cf different\n            cf[0]++;\n        }\n\n        // Output p and q\n        printll(p);\n        printf(\" \");\n        printll(q);\n        printf(\"\\n\");\n\n        // Output n\n        printf(\"%d\\n\", n);\n\n        // Output sequence cf\n        for (int i = 0; i < n; ++i) {\n            printll(cf[i]);\n            if (i < n -1)\n                printf(\" \");\n        }\n        printf(\"\\n\");\n    } else if (type == \"max_equal\") {\n        // Max values test case\n        ll p = (ll)1e18;\n        ll q = 1;\n\n        vector<ll> cf = { (ll)1e18 };\n\n        // Output p and q\n        printll(p);\n        printf(\" \");\n        printll(q);\n        printf(\"\\n\");\n\n        // Output n\n        printf(\"1\\n\");\n\n        // Output sequence\n        printll((ll)1e18);\n        printf(\"\\n\");\n    } else if (type == \"min_equal\") {\n        // Min values test case\n        ll p = 1;\n        ll q = 1;\n\n        vector<ll> cf = { 1 };\n\n        // Output p and q\n        printll(p);\n        printf(\" \");\n        printll(q);\n        printf(\"\\n\");\n\n        // Output n\n        printf(\"1\\n\");\n\n        // Output sequence\n        printll(1);\n        printf(\"\\n\");\n    }\n\n    // Additional types can be added here as needed\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nusing ll = long long;\n\nvoid printll(ll n) {\n    printf(\"%lld\", n);\n}\n\nvector<ll> fraction_to_continued_fraction(ll p, ll q) {\n    vector<ll> cf;\n    while (q != 0) {\n        ll a = p / q;\n        cf.push_back(a);\n        ll r = p % q;\n        p = q;\n        q = r;\n    }\n    return cf;\n}\n\npair<ll, ll> continued_fraction_to_fraction(const vector<ll>& cf) {\n    int n = cf.size();\n    ll num = cf.back();\n    ll den = 1;\n\n    for (int i = n - 2; i >= 0; --i) {\n        ll a = cf[i];\n        // Prevent overflow\n        if (a > (ll)1e9 || num > (ll)1e9 || den > (ll)1e9) {\n            return { (ll)1e18+1, (ll)1e18+1 }; // Indicate overflow\n        }\n\n        ll temp_num = a * num + den;\n        den = num;\n        num = temp_num;\n\n        // Simplify fraction\n        ll g = __gcd(num, den);\n        num /= g;\n        den /= g;\n\n        if (num > (ll)1e18 || den > (ll)1e18) {\n            return { (ll)1e18+1, (ll)1e18+1 }; // Indicate overflow\n        }\n    }\n    return {num, den};\n}\n\nvoid simplify(ll &num, ll &den) {\n    ll g = __gcd(num, den);\n    num /= g;\n    den /= g;\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\", -1);\n    string type = opt<string>(\"type\", \"equal\");\n\n    if (type == \"equal\") {\n        // Generate random p and q\n        ll p = rnd.next(1LL, (ll)1e18);\n        ll q = rnd.next(1LL, p);\n\n        simplify(p, q);\n\n        vector<ll> cf = fraction_to_continued_fraction(p, q);\n\n        if (n != -1 && n != (int)cf.size()) {\n            // Cannot adjust n, proceed with actual size\n            n = cf.size();\n        } else {\n            n = cf.size();\n        }\n\n        // Output p and q\n        printll(p);\n        printf(\" \");\n        printll(q);\n        printf(\"\\n\");\n\n        // Output n\n        printf(\"%d\\n\", n);\n\n        // Output sequence cf\n        for (int i = 0; i < n; ++i) {\n            printll(cf[i]);\n            if (i < n -1)\n                printf(\" \");\n        }\n        printf(\"\\n\");\n    } else if (type == \"notequal\") {\n        // Generate random p and q\n        ll p = rnd.next(1LL, (ll)1e18);\n        ll q = rnd.next(1LL, p);\n\n        simplify(p, q);\n\n        if (n == -1)\n            n = rnd.next(1, 90);\n\n        vector<ll> cf(n);\n        for (int i = 0; i < n; ++i) {\n            cf[i] = rnd.next(1LL, (ll)1e6); // Use smaller a_i to prevent overflow\n        }\n\n        pair<ll, ll> frac_cf = continued_fraction_to_fraction(cf);\n        simplify(frac_cf.first, frac_cf.second);\n\n        if (frac_cf.first == p && frac_cf.second == q) {\n            // Make cf different\n            cf[0]++;\n        }\n\n        // Output p and q\n        printll(p);\n        printf(\" \");\n        printll(q);\n        printf(\"\\n\");\n\n        // Output n\n        printf(\"%d\\n\", n);\n\n        // Output sequence cf\n        for (int i = 0; i < n; ++i) {\n            printll(cf[i]);\n            if (i < n -1)\n                printf(\" \");\n        }\n        printf(\"\\n\");\n    } else if (type == \"max_equal\") {\n        // Max values test case\n        ll p = (ll)1e18;\n        ll q = 1;\n\n        vector<ll> cf = { (ll)1e18 };\n\n        // Output p and q\n        printll(p);\n        printf(\" \");\n        printll(q);\n        printf(\"\\n\");\n\n        // Output n\n        printf(\"1\\n\");\n\n        // Output sequence\n        printll((ll)1e18);\n        printf(\"\\n\");\n    } else if (type == \"min_equal\") {\n        // Min values test case\n        ll p = 1;\n        ll q = 1;\n\n        vector<ll> cf = { 1 };\n\n        // Output p and q\n        printll(p);\n        printf(\" \");\n        printll(q);\n        printf(\"\\n\");\n\n        // Output n\n        printf(\"1\\n\");\n\n        // Output sequence\n        printll(1);\n        printf(\"\\n\");\n    }\n\n    // Additional types can be added here as needed\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -type equal\n./gen -type notequal\n\n./gen -n 1 -type equal\n./gen -n 1 -type notequal\n\n./gen -n 2 -type equal\n./gen -n 2 -type notequal\n\n./gen -n 5 -type equal\n./gen -n 5 -type notequal\n\n./gen -n 10 -type equal\n./gen -n 10 -type notequal\n\n./gen -n 20 -type equal\n./gen -n 20 -type notequal\n\n./gen -n 50 -type equal\n./gen -n 50 -type notequal\n\n./gen -n 90 -type equal\n./gen -n 90 -type notequal\n\n./gen -type min_equal\n./gen -type min_notequal\n\n./gen -type max_equal\n./gen -type max_notequal\n\n./gen -n 15 -type equal\n./gen -n 15 -type notequal\n\n./gen -n 30 -type equal\n./gen -n 30 -type notequal\n\n./gen -n 70 -type equal\n./gen -n 70 -type notequal\n\n./gen -n 90 -type equal\n./gen -n 90 -type notequal\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:05:44.508156",
        "total_tutorials": 3,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "305/C",
      "title": "C. Ivan and Powers of Two",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test0.5 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains integer n (1 ≤ n ≤ 105). The second input line contains n space-separated integers a1, a2, ..., an (0 ≤ ai ≤ 2·109). It is guaranteed that a1 ≤ a2 ≤ ... ≤ an.",
      "output_spec": "OutputPrint a single integer — the answer to the problem.",
      "sample_tests": "ExamplesInputCopy40 1 1 1OutputCopy0InputCopy13OutputCopy3",
      "description": "C. Ivan and Powers of Two\n\ntime limit per test0.5 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains integer n (1 ≤ n ≤ 105). The second input line contains n space-separated integers a1, a2, ..., an (0 ≤ ai ≤ 2·109). It is guaranteed that a1 ≤ a2 ≤ ... ≤ an.\n\nOutputPrint a single integer — the answer to the problem.\n\nInputCopy40 1 1 1OutputCopy0InputCopy13OutputCopy3\n\nInputCopy40 1 1 1\n\nOutputCopy0\n\nInputCopy13\n\nOutputCopy3\n\nNoteIn the first sample you do not need to add anything, the sum of numbers already equals 23 - 1 = 7.In the second sample you need to add numbers 20, 21, 22.",
      "solutions": [
        {
          "title": "Codeforces Round #184 (Div. 2) - Codeforces",
          "content": "Hello!A few hours later, on May 19th at 17:00 MSK, you are lucky to participate in Codeforces Round #184 for Div. 2 participants. Traditionally, Div. 1 participants can take part out of the competition.Problems have been prepared by: Gridnev Vitaliy (gridnevvvit), Ignatyev Alexander (aiMR). It’s our second round and I hope not last. We want to thank Gerald Agapov(Gerald) for help in preparation of this round, Michael Mirzayanov(MikeMirzayanov) for marvelous Codeforces and Polygon systems, Mary Belova(Delinur) for translating the problems.We hope you will like these problems, and that it will be fun to solve them. Also we strongly recommend you to read all the problems.We wish everyone good luck and high rating!UPD1: Scoring will be standart: 500, 1000, 1500, 2000, 2500.UPD2: EditorialUPD3: Congratulations to winners: SillyHook06 hyplymac HAPKOMAH",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/7708",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 858
        },
        {
          "title": "Codeforces Round #184 (Div. 2) - Codeforces",
          "content": "Hello!A few hours later, on May 19th at 17:00 MSK, you are lucky to participate in Codeforces Round #184 for Div. 2 participants. Traditionally, Div. 1 participants can take part out of the competition.Problems have been prepared by: Gridnev Vitaliy (gridnevvvit), Ignatyev Alexander (aiMR). It’s our second round and I hope not last. We want to thank Gerald Agapov(Gerald) for help in preparation of this round, Michael Mirzayanov(MikeMirzayanov) for marvelous Codeforces and Polygon systems, Mary Belova(Delinur) for translating the problems.We hope you will like these problems, and that it will be fun to solve them. Also we strongly recommend you to read all the problems.We wish everyone good luck and high rating!UPD1: Scoring will be standart: 500, 1000, 1500, 2000, 2500.UPD2: EditorialUPD3: Congratulations to winners: SillyHook06 hyplymac HAPKOMAH",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/7708",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 858
        },
        {
          "title": "Editorial Codeforces Round #184 (Div.2) - Codeforces",
          "content": "305A - Strange AdditionAll you have to do is implement following algorithm: If we have numbers 0 or 100, we take them to needed subset. If we got number greater than 0 and less than 10, we take it. If we got number divisible by 10 we take it. In case we have no numbers of second and third type, we take a number that is not divisible by 10 Solution305B - Continued FractionsThere are at most two ways to represent rational fraction as continued. Using Euclid algorithm you can do that for and then check equality of corresponding ai.Solution305C - Ivan and Powers of TwoFirst of all, let's carry over all powers of two in the following way: if we have ai = aj, i ≠ j, carry 1 to ai + 1. Now as all of ai are distinct, the answer is max(ai) — cnt(ai) + 1, where max(ai) — maximal value of ai,cnt(ai) — size of aSolution305D - Olya and GraphFirst of all let's consider a graph on a number line. It's neccesary to have edges i -  > i + 1(first type). Also you can edges like i -  > i + k + 1 (second type). Other edges are forbidden. This allows us to understand whether the answer is 0 or not. Also answer is 0 when all edges of second type doesn't intersect, considering them to be segments of number line, except when k ≥ n - 1 — in this case answer is 1. Now we know that answer != 0. Frow all edges we have let's use only second type edges. If there aren't any of this edges we can add 1 to the answer, because of possibility of adding 0 edges to graph. For every vertex i, that has possibility of adding second type edges, let's add to answer 2cnt, cnt — amount of vertexes on [i, min(i + k, n — k — 1)] without edges of second type out of them. Also it is necessary for all the second type edges to start in this segment.Solution O(n + m) Solution O(m + log(n))305E - Playing with StringLet's consider substring of s s[i... j], that all characters from i to j are palindrome centers, and i - 1, j + 1 are not. Every such substring can be treated independently from the others, and as we don't need to know it'sstructure let's consider only it length len. Let's calculate grundy[len] — Grundy function. If we want to cut character at position i 0 ≤ i < len then our game splits in to independent ones: first will have length i - 1, second — len - i - 2, as s[i - 1] and s[i + 1] are not centers of palindrome any more.Solution",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/7712",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 305\\s*C"
          },
          "content_length": 2330
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #184 (Div. 2) - Codeforces - Code 1",
          "code": "Vasya can only sum pairs of integers (a, b), such that for \nany decimal place at least one number has digit 0 in this place",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7708",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #184 (Div. 2) - Codeforces - Code 2",
          "code": "Vasya can only sum pairs of integers (a, b), such that for \nany decimal place at least one number has digit 0 in this place",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7708",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #184 (Div. 2) - Codeforces - Code 1",
          "code": "Vasya can only sum pairs of integers (a, b), such that for \nany decimal place at least one number has digit 0 in this place",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7708",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #184 (Div. 2) - Codeforces - Code 2",
          "code": "Vasya can only sum pairs of integers (a, b), such that for \nany decimal place at least one number has digit 0 in this place",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7708",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n\n    // Read n integers a_i in the range [0, 2e9]\n    vector<int> a = inf.readInts(n, 0, 2000000000);\n    inf.readEoln();\n\n    // Check that the array is sorted in non-decreasing order\n    for (int i = 1; i < n; ++i) {\n        ensuref(a[i - 1] <= a[i],\n                \"Array 'a' must be sorted in non-decreasing order: a[%d]=%d > a[%d]=%d\",\n                i, a[i - 1], i + 1, a[i]);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n\n    // Read n integers a_i in the range [0, 2e9]\n    vector<int> a = inf.readInts(n, 0, 2000000000);\n    inf.readEoln();\n\n    // Check that the array is sorted in non-decreasing order\n    for (int i = 1; i < n; ++i) {\n        ensuref(a[i - 1] <= a[i],\n                \"Array 'a' must be sorted in non-decreasing order: a[%d]=%d > a[%d]=%d\",\n                i, a[i - 1], i + 1, a[i]);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n\n    // Read n integers a_i in the range [0, 2e9]\n    vector<int> a = inf.readInts(n, 0, 2000000000);\n    inf.readEoln();\n\n    // Check that the array is sorted in non-decreasing order\n    for (int i = 1; i < n; ++i) {\n        ensuref(a[i - 1] <= a[i],\n                \"Array 'a' must be sorted in non-decreasing order: a[%d]=%d > a[%d]=%d\",\n                i, a[i - 1], i + 1, a[i]);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    // n: number of elements\n    // type: controls how we construct the non-decreasing array\n    //   \"all_zero\"        => all elements are 0\n    //   \"all_same\"        => all elements are the same random value\n    //   \"strict_increasing\" => strictly increasing sequence within [0..2e9]\n    //   \"random\"          => randomly generated values, then sorted\n    // If no type is provided, defaults to \"random\".\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    // Prepare a container for the array\n    vector<long long> arr(n, 0LL);\n\n    if (type == \"all_zero\") {\n        // Already initialized with 0\n    } \n    else if (type == \"all_same\") {\n        // Choose a random value in [0..2e9]\n        long long x = rnd.next((long long)2e9 + 1);\n        for (int i = 0; i < n; i++) {\n            arr[i] = x;\n        }\n    } \n    else if (type == \"strict_increasing\") {\n        // Generate strictly increasing sequence that stays within [0..2e9]\n        // Let the starting point s be in [0..(2e9 - n + 1)] so that s + (n-1) <= 2e9\n        long long limit = (long long)2e9 - (long long)n + 1;\n        if (limit < 0) {\n            // If n is very large, clamp the sequence at 2e9 for the last elements\n            // (But n up to 1e5 is safe, so normally no clamp needed unless n=2e9+something, not in problem constraints.)\n            // We'll just handle the rare corner: place them all at 2e9 if limit < 0\n            for (int i = 0; i < n; i++) {\n                arr[i] = 2000000000LL;\n            }\n        } else {\n            long long s = rnd.next(limit + 1);\n            for (int i = 0; i < n; i++) {\n                arr[i] = s + i; \n            }\n        }\n    } \n    else {\n        // type == \"random\" or anything else => random non-decreasing array\n        // Generate random values in [0..2e9], then sort\n        for (int i = 0; i < n; i++) {\n            arr[i] = rnd.next((long long)2e9 + 1);\n        }\n        sort(arr.begin(), arr.end());\n    }\n\n    // Output:\n    // First line: n\n    // Second line: n space-separated integers (non-decreasing, as required).\n    cout << n << \"\\n\";\n    for (int i = 0; i < n; i++) {\n        cout << arr[i] << (i + 1 < n ? ' ' : '\\n');\n    }\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    // n: number of elements\n    // type: controls how we construct the non-decreasing array\n    //   \"all_zero\"        => all elements are 0\n    //   \"all_same\"        => all elements are the same random value\n    //   \"strict_increasing\" => strictly increasing sequence within [0..2e9]\n    //   \"random\"          => randomly generated values, then sorted\n    // If no type is provided, defaults to \"random\".\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    // Prepare a container for the array\n    vector<long long> arr(n, 0LL);\n\n    if (type == \"all_zero\") {\n        // Already initialized with 0\n    } \n    else if (type == \"all_same\") {\n        // Choose a random value in [0..2e9]\n        long long x = rnd.next((long long)2e9 + 1);\n        for (int i = 0; i < n; i++) {\n            arr[i] = x;\n        }\n    } \n    else if (type == \"strict_increasing\") {\n        // Generate strictly increasing sequence that stays within [0..2e9]\n        // Let the starting point s be in [0..(2e9 - n + 1)] so that s + (n-1) <= 2e9\n        long long limit = (long long)2e9 - (long long)n + 1;\n        if (limit < 0) {\n            // If n is very large, clamp the sequence at 2e9 for the last elements\n            // (But n up to 1e5 is safe, so normally no clamp needed unless n=2e9+something, not in problem constraints.)\n            // We'll just handle the rare corner: place them all at 2e9 if limit < 0\n            for (int i = 0; i < n; i++) {\n                arr[i] = 2000000000LL;\n            }\n        } else {\n            long long s = rnd.next(limit + 1);\n            for (int i = 0; i < n; i++) {\n                arr[i] = s + i; \n            }\n        }\n    } \n    else {\n        // type == \"random\" or anything else => random non-decreasing array\n        // Generate random values in [0..2e9], then sort\n        for (int i = 0; i < n; i++) {\n            arr[i] = rnd.next((long long)2e9 + 1);\n        }\n        sort(arr.begin(), arr.end());\n    }\n\n    // Output:\n    // First line: n\n    // Second line: n space-separated integers (non-decreasing, as required).\n    cout << n << \"\\n\";\n    for (int i = 0; i < n; i++) {\n        cout << arr[i] << (i + 1 < n ? ' ' : '\\n');\n    }\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -type all_zero\n./gen -n 1 -type all_same\n./gen -n 1 -type strict_increasing\n./gen -n 1 -type random\n\n./gen -n 2 -type all_zero\n./gen -n 2 -type all_same\n./gen -n 2 -type strict_increasing\n./gen -n 2 -type random\n\n./gen -n 5 -type all_zero\n./gen -n 5 -type all_same\n./gen -n 5 -type strict_increasing\n./gen -n 5 -type random\n\n./gen -n 10 -type all_zero\n./gen -n 10 -type all_same\n./gen -n 10 -type strict_increasing\n./gen -n 10 -type random\n\n./gen -n 100 -type all_zero\n./gen -n 100 -type all_same\n./gen -n 100 -type strict_increasing\n./gen -n 100 -type random\n\n./gen -n 100000 -type all_zero\n./gen -n 100000 -type all_same\n./gen -n 100000 -type strict_increasing\n./gen -n 100000 -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:05:46.345550",
        "total_tutorials": 3,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "305/D",
      "title": "D. Оля и граф",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест2 секунды",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеВ первой строке записаны три целых числа через пробел n, m, k (2 ≤ n ≤ 106, 0 ≤ m ≤ 105, 1 ≤ k ≤ 106).Во последующих m строках записано описание ребер изначального графа. В i-ой строке записана пара целых чисел через пробел ui, vi (1 ≤ ui < vi ≤ n) — номера вершин, между которыми есть ориентированное ребро из ui в vi. Гарантируется, что между любой парой вершин ui, vi существует не более одного ребра. Также гарантируется, что ребра графа записаны в порядке неубывания величин ui. Если из вершины ui имеется несколько ребер, то гарантируется, что эти ребра заданы в порядке возрастания величин vi.",
      "output_spec": "Выходные данныеВыведите единственное целое число — ответ на задачу по модулю 1000000007 (109 + 7).",
      "sample_tests": "ПримерыВходные данныеСкопировать7 8 21 22 33 43 64 54 75 66 7Выходные данныеСкопировать2Входные данныеСкопировать7 0 2Выходные данныеСкопировать12Входные данныеСкопировать7 2 11 33 5Выходные данныеСкопировать0",
      "description": "D. Оля и граф\n\nограничение по времени на тест2 секунды\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвыводstdout\n\nВходные данныеВ первой строке записаны три целых числа через пробел n, m, k (2 ≤ n ≤ 106, 0 ≤ m ≤ 105, 1 ≤ k ≤ 106).Во последующих m строках записано описание ребер изначального графа. В i-ой строке записана пара целых чисел через пробел ui, vi (1 ≤ ui < vi ≤ n) — номера вершин, между которыми есть ориентированное ребро из ui в vi. Гарантируется, что между любой парой вершин ui, vi существует не более одного ребра. Также гарантируется, что ребра графа записаны в порядке неубывания величин ui. Если из вершины ui имеется несколько ребер, то гарантируется, что эти ребра заданы в порядке возрастания величин vi.\n\nВходные данные\n\nВыходные данныеВыведите единственное целое число — ответ на задачу по модулю 1000000007 (109 + 7).\n\nВыходные данные\n\nВходные данныеСкопировать7 8 21 22 33 43 64 54 75 66 7Выходные данныеСкопировать2Входные данныеСкопировать7 0 2Выходные данныеСкопировать12Входные данныеСкопировать7 2 11 33 5Выходные данныеСкопировать0\n\nВходные данныеСкопировать7 8 21 22 33 43 64 54 75 66 7\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать2\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать7 0 2\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать12\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать7 2 11 33 5\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать0\n\nВыходные данныеСкопировать\n\nСкопировать\n\nПримечаниеВ первом примере есть два способа: первый — это ничего не добавлять, второй — добавить единственное ребро из вершины 2 в вершину 5.",
      "solutions": [
        {
          "title": "Codeforces Round #184 (Div. 2) - Codeforces",
          "content": "Всем привет!Очень скоро, 19 мая в 17:00 MSK, состоится очередной Codeforces Round #184 для участников Div. 2. Как обычно, Div. 1 участники смогут поучаствовать в этом раунде вне конкурса.Задачи были подготовлены группой авторов в составе: Гриднев Виталий (gridnevvvit), Игнатьев Александр (aiMR). Это наш второй раунд, и мы надеемся, что не последний. Выражаем благодарность Геральду Агапову(Gerald) за помощь в подготовке задач, Михаилу Мирзаянову(MikeMirzayanov) за замечательные системы Codeforces и Polygon, Марии Беловой(Delinur) за перевод задач на английский язык.Мы надеемся, что Вам понравятся наши задачи, и вы получите удовольствие от их решения. Настоятельно рекомендую Вам прочесть условия всех задач! Всем удачи и высокого рейтинга!UPD1: Распределение баллов будет стандартным: 500, 1000, 1500, 2000, 2500.UPD2: Разбор задачUPD3: Поздравляем победителей: SillyHook06 hyplymac HAPKOMAH",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/7708",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 898
        },
        {
          "title": "Codeforces Round #184 (Div. 2) - Codeforces",
          "content": "Всем привет!Очень скоро, 19 мая в 17:00 MSK, состоится очередной Codeforces Round #184 для участников Div. 2. Как обычно, Div. 1 участники смогут поучаствовать в этом раунде вне конкурса.Задачи были подготовлены группой авторов в составе: Гриднев Виталий (gridnevvvit), Игнатьев Александр (aiMR). Это наш второй раунд, и мы надеемся, что не последний. Выражаем благодарность Геральду Агапову(Gerald) за помощь в подготовке задач, Михаилу Мирзаянову(MikeMirzayanov) за замечательные системы Codeforces и Polygon, Марии Беловой(Delinur) за перевод задач на английский язык.Мы надеемся, что Вам понравятся наши задачи, и вы получите удовольствие от их решения. Настоятельно рекомендую Вам прочесть условия всех задач! Всем удачи и высокого рейтинга!UPD1: Распределение баллов будет стандартным: 500, 1000, 1500, 2000, 2500.UPD2: Разбор задачUPD3: Поздравляем победителей: SillyHook06 hyplymac HAPKOMAH",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/7708",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 898
        },
        {
          "title": "Разбор Codeforces Round #184 (Div.2) - Codeforces",
          "content": "305A - Странное сложениеПростая задача на реализацию. Если у нас есть в множестве числа 0 или 100, то обязательно возьмем их в подмножество. Если у нас есть число, отличное от 0 и меньшее 10, возьмем его в подмножество. Если у нас число, отличное от 0 и 100, которое делится на 10 без остатка, тоже возьмем его. Если у нас есть число, отличное от чисел, описанных в пунктах 1 - 3 и в изначальном множестве нет чисел из пункта 2 и 3, то возьмем одно такое число. Решение305B - Цепные дробиУказанные ограничения позволяют нам говорить, что представление рациональной дроби в конечную цепную почти единственно. Вернее их не больше чем 2. Поэтому построим жадно представление рациональной дроби в конечную цепную, и проверим, совпадают ли они.Решение305C - Иван и степени двойкиВо-первых, выполним все возможные переносы по степеням. Более формально, если у нас пара чисел, ai = aj, i ≠ j, заменим ее на одно число ai + 1. Теперь, когда все ai различны, то ответ очевиден — max(ai) — cnt(ai) + 1, где max(ai) — максимальное число в массиве, cnt(ai) — количество чисел в массивеРешение305D - Оля и графВо-первых, удобно расположить все вершины на координатной прямой. Далее в графе обязательно нужны ребра из i -  > i + 1. Кроме этого, в граф можно добавлять ребра из i -  > i + k + 1 (ребра типа 2). Не трудно доказать, что других ребер добавлять нельзя. Сразу считаем ребра, и определим, ответ 0 или != 0 . Далее ответ 0 еще тогда, когда все ребра 2 типа не имееют общего пересечения, если рассматривать как отрезки на координатной прямой. Причем это верно почти всегда, кроме случаев когда k ≥ n - 1. В этих случаях, ответ всегда 1. Теперь ответ != 0. Из всех ребер которые у нас есть, оставим только ребра типа 2. Если ребер типа 2 нет, то прибавим к ответу 1, так как мы сейчас можем ничего не добавлять. Иначе переберем вершину i, из которой мы проведем ребро 2 типа и аккуратно прибавим к ответу величину 2cnt, cnt — это количество вершин на промежутке от [i, min(i + k, n — k — 1)] из которых не исходят ребра. Причем важно, чтобы все имеющиеся ребра были на этом промежутке. Таким образом, это решение за O(n + m). Отмечу, что у этой задачи есть решение за O(m + log(n)). Однако, заходит и O(n + m).Решение O(n + m) Решение O(m + log(n))305E - Игра со строкойЧтобы решить эту задачу, необходимы некоторые знания по теории игр. Рассмотрим некоторую подстроку строки s s[i... j], такую, что все символы с i по j являются центрами палиндромов, а символы i - 1, j + 1 уже нет. Утверждается, что такую подстроку можно рассмотреть отдельно. Каждую такую подстрочку нетрудно закодировать единственным числом: len — просто количество символов в ней. И так, будем считать grundy[len] — значение функции Гранди. Пусть мы решили удалить символ в позиции 0 ≤ i < len. Тогда нетрудно понять, что игра распадется на 2 независимых игры: У первой игры будет длина i - 1, а у второй len - i - 2, так как соседние к i символы перестанут быть центрами. Таким образом, получим решение за O(n2). Скажу, что еще есть решение за O(n), но опять таки, это уже не требовалось.Решение",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/7712",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 305\\s*D"
          },
          "content_length": 3061
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #184 (Div. 2) - Codeforces - Code 1",
          "code": "Настоятельно рекомендую прочитать условия ВСЕХ задач",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7708",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #184 (Div. 2) - Codeforces - Code 2",
          "code": "Vasya can only sum pairs of integers (a, b), such that for \nany decimal place at least one number has digit 0 in this place",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7708",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #184 (Div. 2) - Codeforces - Code 3",
          "code": "Vasya can only sum pairs of integers (a, b), such that for \nany decimal place at least one number has digit 0 in this place",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7708",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #184 (Div. 2) - Codeforces - Code 1",
          "code": "Настоятельно рекомендую прочитать условия ВСЕХ задач",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7708",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #184 (Div. 2) - Codeforces - Code 2",
          "code": "Vasya can only sum pairs of integers (a, b), such that for \nany decimal place at least one number has digit 0 in this place",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7708",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #184 (Div. 2) - Codeforces - Code 3",
          "code": "Vasya can only sum pairs of integers (a, b), such that for \nany decimal place at least one number has digit 0 in this place",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7708",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(2, 1000000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(0, 100000, \"m\");\n    inf.readSpace();\n    int k = inf.readInt(1, 1000000, \"k\");\n    inf.readEoln();\n\n    set<pair<int, int>> edges;\n\n    int prev_ui = -1;\n    int prev_vi = -1;\n\n    for (int i = 0; i < m; i++) {\n        int ui = inf.readInt(1, n - 1, \"ui\");\n        inf.readSpace();\n        int vi = inf.readInt(ui + 1, n, \"vi\");\n        inf.readEoln();\n\n        ensuref(ui < vi, \"Edge must satisfy ui < vi, but ui=%d, vi=%d\", ui, vi);\n\n        if (i > 0) {\n            ensuref(ui >= prev_ui, \"Edges must be sorted in non-decreasing order of ui\");\n\n            if (ui == prev_ui) {\n                ensuref(vi > prev_vi, \"For the same ui=%d, vi must be in increasing order, previous vi=%d, current vi=%d\", ui, prev_vi, vi);\n            }\n        }\n\n        pair<int, int> edge = make_pair(ui, vi);\n        ensuref(edges.count(edge) == 0, \"Edge between ui=%d and vi=%d appears more than once\", ui, vi);\n        edges.insert(edge);\n\n        prev_ui = ui;\n        prev_vi = vi;\n    }\n\n    inf.readEof();\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(2, 1000000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(0, 100000, \"m\");\n    inf.readSpace();\n    int k = inf.readInt(1, 1000000, \"k\");\n    inf.readEoln();\n\n    set<pair<int, int>> edges;\n\n    int prev_ui = -1;\n    int prev_vi = -1;\n\n    for (int i = 0; i < m; i++) {\n        int ui = inf.readInt(1, n - 1, \"ui\");\n        inf.readSpace();\n        int vi = inf.readInt(ui + 1, n, \"vi\");\n        inf.readEoln();\n\n        ensuref(ui < vi, \"Edge must satisfy ui < vi, but ui=%d, vi=%d\", ui, vi);\n\n        if (i > 0) {\n            ensuref(ui >= prev_ui, \"Edges must be sorted in non-decreasing order of ui\");\n\n            if (ui == prev_ui) {\n                ensuref(vi > prev_vi, \"For the same ui=%d, vi must be in increasing order, previous vi=%d, current vi=%d\", ui, prev_vi, vi);\n            }\n        }\n\n        pair<int, int> edge = make_pair(ui, vi);\n        ensuref(edges.count(edge) == 0, \"Edge between ui=%d and vi=%d appears more than once\", ui, vi);\n        edges.insert(edge);\n\n        prev_ui = ui;\n        prev_vi = vi;\n    }\n\n    inf.readEof();\n\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(2, 1000000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(0, 100000, \"m\");\n    inf.readSpace();\n    int k = inf.readInt(1, 1000000, \"k\");\n    inf.readEoln();\n\n    set<pair<int, int>> edges;\n\n    int prev_ui = -1;\n    int prev_vi = -1;\n\n    for (int i = 0; i < m; i++) {\n        int ui = inf.readInt(1, n - 1, \"ui\");\n        inf.readSpace();\n        int vi = inf.readInt(ui + 1, n, \"vi\");\n        inf.readEoln();\n\n        ensuref(ui < vi, \"Edge must satisfy ui < vi, but ui=%d, vi=%d\", ui, vi);\n\n        if (i > 0) {\n            ensuref(ui >= prev_ui, \"Edges must be sorted in non-decreasing order of ui\");\n\n            if (ui == prev_ui) {\n                ensuref(vi > prev_vi, \"For the same ui=%d, vi must be in increasing order, previous vi=%d, current vi=%d\", ui, prev_vi, vi);\n            }\n        }\n\n        pair<int, int> edge = make_pair(ui, vi);\n        ensuref(edges.count(edge) == 0, \"Edge between ui=%d and vi=%d appears more than once\", ui, vi);\n        edges.insert(edge);\n\n        prev_ui = ui;\n        prev_vi = vi;\n    }\n\n    inf.readEof();\n\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int k = opt<int>(\"k\");\n    string type = opt<string>(\"type\", \"random\"); // default type is random\n    int m = 0; // Initialize m to 0\n\n    vector<pair<int, int>> edges;\n\n    if (type == \"empty\") {\n        m = 0;\n        // Do nothing\n    } else if (type == \"chain\") {\n        // Edge from i to i + 1\n        m = n - 1;\n        for (int i = 1; i <= n - 1; i++) {\n            edges.push_back({i, i + 1});\n        }\n    } else if (type == \"star\") {\n        // Edges from 1 to all other vertices\n        m = n - 1;\n        for (int i = 2; i <= n; i++) {\n            edges.push_back({1, i});\n        }\n    } else if (type == \"full\") {\n        // For small n only\n        if (n > 500) {\n            fprintf(stderr, \"Full graph type cannot be generated for n > 500\\n\");\n            return 1;\n        }\n        for (int u = 1; u <= n - 1; u++) {\n            for (int v = u + 1; v <= n; v++) {\n                edges.push_back({u, v});\n            }\n        }\n        m = edges.size();\n        if (m > 1e5) {\n            fprintf(stderr, \"Number of edges exceeds 1e5 for full graph\\n\");\n            return 1;\n        }\n    } else if (type == \"random\") {\n        int m_input = opt<int>(\"m\", 0);\n        m_input = min(m_input, (int)((long long)n * (n - 1) / 2));\n        m_input = min(m_input, (int)1e5);\n        m = m_input;\n\n        set<pair<int, int>> edges_set;\n        while ((int)edges_set.size() < m) {\n            int u = rnd.next(1, n - 1);\n            int v = rnd.next(u + 1, n);\n            edges_set.insert({u, v});\n        }\n        edges = vector<pair<int, int>>(edges_set.begin(), edges_set.end());\n    } else {\n        fprintf(stderr, \"Unknown graph type: %s\\n\", type.c_str());\n        return 1;\n    }\n\n    // Now, sort edges according to constraints\n    sort(edges.begin(), edges.end());\n\n    // Output according to problem's input format\n    printf(\"%d %d %d\\n\", n, m, k);\n    for (int i = 0; i < m; i++) {\n        printf(\"%d %d\\n\", edges[i].first, edges[i].second);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int k = opt<int>(\"k\");\n    string type = opt<string>(\"type\", \"random\"); // default type is random\n    int m = 0; // Initialize m to 0\n\n    vector<pair<int, int>> edges;\n\n    if (type == \"empty\") {\n        m = 0;\n        // Do nothing\n    } else if (type == \"chain\") {\n        // Edge from i to i + 1\n        m = n - 1;\n        for (int i = 1; i <= n - 1; i++) {\n            edges.push_back({i, i + 1});\n        }\n    } else if (type == \"star\") {\n        // Edges from 1 to all other vertices\n        m = n - 1;\n        for (int i = 2; i <= n; i++) {\n            edges.push_back({1, i});\n        }\n    } else if (type == \"full\") {\n        // For small n only\n        if (n > 500) {\n            fprintf(stderr, \"Full graph type cannot be generated for n > 500\\n\");\n            return 1;\n        }\n        for (int u = 1; u <= n - 1; u++) {\n            for (int v = u + 1; v <= n; v++) {\n                edges.push_back({u, v});\n            }\n        }\n        m = edges.size();\n        if (m > 1e5) {\n            fprintf(stderr, \"Number of edges exceeds 1e5 for full graph\\n\");\n            return 1;\n        }\n    } else if (type == \"random\") {\n        int m_input = opt<int>(\"m\", 0);\n        m_input = min(m_input, (int)((long long)n * (n - 1) / 2));\n        m_input = min(m_input, (int)1e5);\n        m = m_input;\n\n        set<pair<int, int>> edges_set;\n        while ((int)edges_set.size() < m) {\n            int u = rnd.next(1, n - 1);\n            int v = rnd.next(u + 1, n);\n            edges_set.insert({u, v});\n        }\n        edges = vector<pair<int, int>>(edges_set.begin(), edges_set.end());\n    } else {\n        fprintf(stderr, \"Unknown graph type: %s\\n\", type.c_str());\n        return 1;\n    }\n\n    // Now, sort edges according to constraints\n    sort(edges.begin(), edges.end());\n\n    // Output according to problem's input format\n    printf(\"%d %d %d\\n\", n, m, k);\n    for (int i = 0; i < m; i++) {\n        printf(\"%d %d\\n\", edges[i].first, edges[i].second);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 2 -k 1 -type chain\n./gen -n 2 -k 2 -type chain\n./gen -n 2 -k 1 -type empty\n\n./gen -n 10 -k 5 -type chain\n./gen -n 10 -k 5 -type star\n./gen -n 10 -k 5 -type random -m 0\n./gen -n 10 -k 5 -type random -m 20\n\n./gen -n 100 -k 10 -type chain\n./gen -n 100 -k 10 -type star\n./gen -n 100 -k 10 -type random -m 1000\n\n./gen -n 1000 -k 100 -type chain\n./gen -n 1000 -k 100 -type random -m 10000\n\n./gen -n 10000 -k 200 -type chain\n./gen -n 10000 -k 200 -type star\n./gen -n 10000 -k 200 -type random -m 50000\n\n./gen -n 100000 -k 1000 -type chain\n./gen -n 100000 -k 1000 -type random -m 100000\n\n./gen -n 200000 -k 100000 -type chain\n./gen -n 200000 -k 100000 -type random -m 100000\n\n./gen -n 300000 -k 150000 -type random -m 100000\n\n./gen -n 500000 -k 250000 -type random -m 100000\n\n./gen -n 1000000 -k 500000 -type chain\n\n./gen -n 1000000 -k 999999 -type random -m 100000\n\n# Full graph for small n\n./gen -n 100 -k 50 -type full\n\n./gen -n 300 -k 50 -type full\n\n# Edge case where k = 1\n./gen -n 1000000 -k 1 -type chain\n\n./gen -n 1000000 -k 1 -type random -m 100000\n\n# Edge case where k = n - 1\n./gen -n 1000000 -k 999999 -type chain\n\n./gen -n 1000000 -k 999999 -type random -m 100000\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:05:48.280441",
        "total_tutorials": 3,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "305/E",
      "title": "E. Playing with String",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains string s (1 ≤ |s| ≤ 5000). It is guaranteed that string s only contains lowercase English letters.",
      "output_spec": "OutputIf the second player wins, print in the single line \"Second\" (without the quotes). Otherwise, print in the first line \"First\" (without the quotes), and in the second line print the minimal possible winning move — integer i (1 ≤ i ≤ |s|).",
      "sample_tests": "ExamplesInputCopyabacabaOutputCopyFirst2InputCopyabcdeOutputCopySecond",
      "description": "E. Playing with String\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains string s (1 ≤ |s| ≤ 5000). It is guaranteed that string s only contains lowercase English letters.\n\nOutputIf the second player wins, print in the single line \"Second\" (without the quotes). Otherwise, print in the first line \"First\" (without the quotes), and in the second line print the minimal possible winning move — integer i (1 ≤ i ≤ |s|).\n\nInputCopyabacabaOutputCopyFirst2InputCopyabcdeOutputCopySecond\n\nInputCopyabacaba\n\nOutputCopyFirst2\n\nInputCopyabcde\n\nOutputCopySecond\n\nNoteIn the first sample the first player has multiple winning moves. But the minimum one is to cut the character in position 2. In the second sample the first player has no available moves.",
      "solutions": [
        {
          "title": "Codeforces Round #184 (Div. 2) - Codeforces",
          "content": "Hello!A few hours later, on May 19th at 17:00 MSK, you are lucky to participate in Codeforces Round #184 for Div. 2 participants. Traditionally, Div. 1 participants can take part out of the competition.Problems have been prepared by: Gridnev Vitaliy (gridnevvvit), Ignatyev Alexander (aiMR). It’s our second round and I hope not last. We want to thank Gerald Agapov(Gerald) for help in preparation of this round, Michael Mirzayanov(MikeMirzayanov) for marvelous Codeforces and Polygon systems, Mary Belova(Delinur) for translating the problems.We hope you will like these problems, and that it will be fun to solve them. Also we strongly recommend you to read all the problems.We wish everyone good luck and high rating!UPD1: Scoring will be standart: 500, 1000, 1500, 2000, 2500.UPD2: EditorialUPD3: Congratulations to winners: SillyHook06 hyplymac HAPKOMAH",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/7708",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 858
        },
        {
          "title": "Codeforces Round #184 (Div. 2) - Codeforces",
          "content": "Hello!A few hours later, on May 19th at 17:00 MSK, you are lucky to participate in Codeforces Round #184 for Div. 2 participants. Traditionally, Div. 1 participants can take part out of the competition.Problems have been prepared by: Gridnev Vitaliy (gridnevvvit), Ignatyev Alexander (aiMR). It’s our second round and I hope not last. We want to thank Gerald Agapov(Gerald) for help in preparation of this round, Michael Mirzayanov(MikeMirzayanov) for marvelous Codeforces and Polygon systems, Mary Belova(Delinur) for translating the problems.We hope you will like these problems, and that it will be fun to solve them. Also we strongly recommend you to read all the problems.We wish everyone good luck and high rating!UPD1: Scoring will be standart: 500, 1000, 1500, 2000, 2500.UPD2: EditorialUPD3: Congratulations to winners: SillyHook06 hyplymac HAPKOMAH",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/7708",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 858
        },
        {
          "title": "Editorial Codeforces Round #184 (Div.2) - Codeforces",
          "content": "305A - Strange AdditionAll you have to do is implement following algorithm: If we have numbers 0 or 100, we take them to needed subset. If we got number greater than 0 and less than 10, we take it. If we got number divisible by 10 we take it. In case we have no numbers of second and third type, we take a number that is not divisible by 10 Solution305B - Continued FractionsThere are at most two ways to represent rational fraction as continued. Using Euclid algorithm you can do that for and then check equality of corresponding ai.Solution305C - Ivan and Powers of TwoFirst of all, let's carry over all powers of two in the following way: if we have ai = aj, i ≠ j, carry 1 to ai + 1. Now as all of ai are distinct, the answer is max(ai) — cnt(ai) + 1, where max(ai) — maximal value of ai,cnt(ai) — size of aSolution305D - Olya and GraphFirst of all let's consider a graph on a number line. It's neccesary to have edges i -  > i + 1(first type). Also you can edges like i -  > i + k + 1 (second type). Other edges are forbidden. This allows us to understand whether the answer is 0 or not. Also answer is 0 when all edges of second type doesn't intersect, considering them to be segments of number line, except when k ≥ n - 1 — in this case answer is 1. Now we know that answer != 0. Frow all edges we have let's use only second type edges. If there aren't any of this edges we can add 1 to the answer, because of possibility of adding 0 edges to graph. For every vertex i, that has possibility of adding second type edges, let's add to answer 2cnt, cnt — amount of vertexes on [i, min(i + k, n — k — 1)] without edges of second type out of them. Also it is necessary for all the second type edges to start in this segment.Solution O(n + m) Solution O(m + log(n))305E - Playing with StringLet's consider substring of s s[i... j], that all characters from i to j are palindrome centers, and i - 1, j + 1 are not. Every such substring can be treated independently from the others, and as we don't need to know it'sstructure let's consider only it length len. Let's calculate grundy[len] — Grundy function. If we want to cut character at position i 0 ≤ i < len then our game splits in to independent ones: first will have length i - 1, second — len - i - 2, as s[i - 1] and s[i + 1] are not centers of palindrome any more.Solution",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/7712",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 305\\s*E"
          },
          "content_length": 2330
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #184 (Div. 2) - Codeforces - Code 1",
          "code": "Vasya can only sum pairs of integers (a, b), such that for \nany decimal place at least one number has digit 0 in this place",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7708",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #184 (Div. 2) - Codeforces - Code 2",
          "code": "Vasya can only sum pairs of integers (a, b), such that for \nany decimal place at least one number has digit 0 in this place",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7708",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #184 (Div. 2) - Codeforces - Code 1",
          "code": "Vasya can only sum pairs of integers (a, b), such that for \nany decimal place at least one number has digit 0 in this place",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7708",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #184 (Div. 2) - Codeforces - Code 2",
          "code": "Vasya can only sum pairs of integers (a, b), such that for \nany decimal place at least one number has digit 0 in this place",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7708",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    string s = inf.readLine(\"[a-z]{1,5000}\", \"s\");\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    string s = inf.readLine(\"[a-z]{1,5000}\", \"s\");\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    string s = inf.readLine(\"[a-z]{1,5000}\", \"s\");\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare sequences of tokens\");\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string j, p;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n\r\n        ans.readWordTo(j);\r\n        ouf.readWordTo(p);\r\n\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s words differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  compress(j).c_str(), compress(p).c_str());\r\n    }\r\n\r\n    if (ans.seekEof() && ouf.seekEof()) {\r\n        if (n == 1)\r\n            quitf(_ok, \"\\\"%s\\\"\", compress(j).c_str());\r\n        else\r\n            quitf(_ok, \"%d tokens\", n);\r\n    } else {\r\n        if (ans.seekEof())\r\n            quitf(_wa, \"Participant output contains extra tokens\");\r\n        else\r\n            quitf(_wa, \"Unexpected EOF in the participants output\");\r\n    }\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    string s(n, ' ');\n\n    if(type == \"random\") {\n        for(int i = 0; i < n; ++i) {\n            s[i] = rnd.next('a', 'z');\n        }\n    } else if(type == \"no_moves\") {\n        if (n >= 1) {\n            s[0] = rnd.next('a', 'z');\n        }\n        if (n >= 2) {\n            s[1] = rnd.next('a', 'z');\n        }\n        for(int i = 1; i < n - 1; ++i) {\n            char c;\n            do {\n                c = rnd.next('a', 'z');\n            } while(c == s[i - 1]);\n            s[i + 1] = c;\n        }\n    } else if(type == \"palindrome\") {\n        for(int i = 0; i <= (n - 1) / 2; ++i) {\n            s[i] = rnd.next('a', 'z');\n            s[n - 1 - i] = s[i];\n        }\n    } else if(type == \"single_move\") {\n        if(n < 3) {\n            cerr << \"n must be at least 3 for 'single_move' type\" << endl;\n            exit(1);\n        }\n        int target_pos = rnd.next(1, n - 2);\n        s[0] = rnd.next('a', 'z');\n        s[1] = rnd.next('a', 'z');\n\n        for(int i = 1; i < n - 1; ++i) {\n            if(i == target_pos) {\n                s[i + 1] = s[i - 1];\n            } else {\n                char c;\n                do {\n                    c = rnd.next('a', 'z');\n                } while(c == s[i - 1]);\n                s[i + 1] = c;\n            }\n        }\n    } else {\n        cerr << \"Unknown type: \" << type << endl;\n        exit(1);\n    }\n\n    cout << s << endl;\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    string s(n, ' ');\n\n    if(type == \"random\") {\n        for(int i = 0; i < n; ++i) {\n            s[i] = rnd.next('a', 'z');\n        }\n    } else if(type == \"no_moves\") {\n        if (n >= 1) {\n            s[0] = rnd.next('a', 'z');\n        }\n        if (n >= 2) {\n            s[1] = rnd.next('a', 'z');\n        }\n        for(int i = 1; i < n - 1; ++i) {\n            char c;\n            do {\n                c = rnd.next('a', 'z');\n            } while(c == s[i - 1]);\n            s[i + 1] = c;\n        }\n    } else if(type == \"palindrome\") {\n        for(int i = 0; i <= (n - 1) / 2; ++i) {\n            s[i] = rnd.next('a', 'z');\n            s[n - 1 - i] = s[i];\n        }\n    } else if(type == \"single_move\") {\n        if(n < 3) {\n            cerr << \"n must be at least 3 for 'single_move' type\" << endl;\n            exit(1);\n        }\n        int target_pos = rnd.next(1, n - 2);\n        s[0] = rnd.next('a', 'z');\n        s[1] = rnd.next('a', 'z');\n\n        for(int i = 1; i < n - 1; ++i) {\n            if(i == target_pos) {\n                s[i + 1] = s[i - 1];\n            } else {\n                char c;\n                do {\n                    c = rnd.next('a', 'z');\n                } while(c == s[i - 1]);\n                s[i + 1] = c;\n            }\n        }\n    } else {\n        cerr << \"Unknown type: \" << type << endl;\n        exit(1);\n    }\n\n    cout << s << endl;\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -type random\n./gen -n 2 -type random\n./gen -n 3 -type random\n./gen -n 10 -type random\n./gen -n 100 -type random\n./gen -n 1000 -type random\n./gen -n 5000 -type random\n\n./gen -n 1 -type no_moves\n./gen -n 2 -type no_moves\n./gen -n 3 -type no_moves\n./gen -n 10 -type no_moves\n./gen -n 100 -type no_moves\n./gen -n 1000 -type no_moves\n./gen -n 5000 -type no_moves\n\n./gen -n 1 -type palindrome\n./gen -n 2 -type palindrome\n./gen -n 3 -type palindrome\n./gen -n 10 -type palindrome\n./gen -n 100 -type palindrome\n./gen -n 999 -type palindrome\n./gen -n 5000 -type palindrome\n\n./gen -n 3 -type single_move\n./gen -n 10 -type single_move\n./gen -n 100 -type single_move\n./gen -n 1000 -type single_move\n./gen -n 5000 -type single_move\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:05:50.487817",
        "total_tutorials": 3,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "306/A",
      "title": "A. Candies",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe single line of the input contains a pair of space-separated positive integers n, m (1 ≤ n, m ≤ 100;n ≥ m) — the number of candies and the number of Polycarpus's friends.",
      "output_spec": "OutputPrint the required sequence a1, a2, ..., am, where ai is the number of candies in the i-th friend's present. All numbers ai must be positive integers, total up to n, the maximum one should differ from the minimum one by the smallest possible value.",
      "sample_tests": "ExamplesInputCopy12 3OutputCopy4 4 4 InputCopy15 4OutputCopy3 4 4 4 InputCopy18 7OutputCopy2 2 2 3 3 3 3",
      "description": "time limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe single line of the input contains a pair of space-separated positive integers n, m (1 ≤ n, m ≤ 100;n ≥ m) — the number of candies and the number of Polycarpus's friends.\n\nOutputPrint the required sequence a1, a2, ..., am, where ai is the number of candies in the i-th friend's present. All numbers ai must be positive integers, total up to n, the maximum one should differ from the minimum one by the smallest possible value.\n\nInputCopy12 3OutputCopy4 4 4 InputCopy15 4OutputCopy3 4 4 4 InputCopy18 7OutputCopy2 2 2 3 3 3 3\n\nInputCopy12 3\n\nOutputCopy4 4 4\n\nInputCopy15 4\n\nOutputCopy3 4 4 4\n\nInputCopy18 7\n\nOutputCopy2 2 2 3 3 3 3\n\nNotePrint ai in any order, separate the numbers by spaces.",
      "solutions": [
        {
          "title": "Testing Round #6 - Codeforces",
          "content": "Testing Round 6 starts on May 11, 2013, 20:00 (UTC). Our goal is to test the platform after recent improvements. All of them are in the Codeforces backend, but they affect many lines of the code.I invite you to take part in the round. It will be Div. 2 + unofficials from Div. 1. It will contain four-five obsolescent problems. But I think it will be interesting for many of you. The problems contain very weak pretests to force more hacks. It will be unrated round.Many thanks to participants!P.S. As it is testing round, we do not guarantee stable work and so on.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/7628",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 565
        }
      ],
      "code_examples": [
        {
          "title": "Testing Round #6 - Codeforces - Code 1",
          "code": "3 * 2 * 2 = 12",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7628",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 100, \"m\");\n    inf.readEoln();\n\n    ensuref(n >= m, \"n (%d) must be greater than or equal to m (%d)\", n, m);\n\n    inf.readEof();\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 100, \"m\");\n    inf.readEoln();\n\n    ensuref(n >= m, \"n (%d) must be greater than or equal to m (%d)\", n, m);\n\n    inf.readEof();\n\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 100, \"m\");\n    inf.readEoln();\n\n    ensuref(n >= m, \"n (%d) must be greater than or equal to m (%d)\", n, m);\n\n    inf.readEof();\n\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nint main(int argc, char* argv[]) {\n    registerTestlibCmd(argc, argv);\n\n    int n = inf.readInt(); // Read n\n    int m = inf.readInt(); // Read m\n\n    // Calculate the minimal possible difference between maximum and minimum ai\n    int min_ai_needed = n / m;                   // Floor of n/m\n    int max_ai_needed = (n + m - 1) / m;         // Ceiling of n/m\n    int D_needed = max_ai_needed - min_ai_needed;\n\n    // Read participant's output\n    std::vector<int> ai = ouf.readInts(m, 1, n, \"ai\");\n\n    // Check if sum of ai equals n\n    int total = std::accumulate(ai.begin(), ai.end(), 0);\n    if (total != n)\n        quitf(_wa, \"The sum of ai is %d, but expected %d\", total, n);\n\n    // Check that all ai are positive integers\n    if (*std::min_element(ai.begin(), ai.end()) <= 0)\n        quitf(_wa, \"All ai must be positive integers\");\n\n    // Check that difference between max and min ai is minimized\n    int max_ai = *std::max_element(ai.begin(), ai.end());\n    int min_ai = *std::min_element(ai.begin(), ai.end());\n    int diff = max_ai - min_ai;\n    if (diff != D_needed)\n        quitf(_wa, \"The difference between max and min ai is %d, but expected %d\", diff, D_needed);\n\n    // Check for extra tokens in the output\n    ouf.skipBlanks();\n    if (!ouf.seekEof())\n        quitf(_wa, \"Extra tokens found in the output\");\n\n    // Accepted\n    quitf(_ok, \"The answer is correct\");\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    string type = opt<string>(\"type\", \"random\");\n    int n = opt<int>(\"n\", -1);\n    int m = opt<int>(\"m\", -1);\n\n    if (type == \"min\") {\n        n = 1; m = 1;\n    } else if (type == \"max\") {\n        n = 100; m = 100;\n    } else if (type == \"n_eq_m\") {\n        if (n == -1)\n            n = rnd.next(1, 100);\n        m = n;\n    } else if (type == \"divisible\") {\n        if (n == -1)\n            n = rnd.next(1, 100);\n        if (m == -1)\n            m = rnd.next(1, n);\n        n = (n / m) * m; // make n divisible by m\n        if (n == 0) n = m; // ensure n ≥ m ≥1\n    } else if (type == \"nondivisible\") {\n        if (n == -1)\n            n = rnd.next(1, 100);\n        if (m == -1)\n            m = rnd.next(1, n);\n        // adjust n to not be divisible by m\n        if (n % m == 0) {\n            if (n + 1 <= 100) n++;\n            else if (n - 1 >= m) n--;\n            else n = m + 1; // ensure n ≥ m + 1\n        }\n    } else if (type == \"n_greater_m_min\") {\n        if (m == -1)\n            m = rnd.next(1, 99); // m from 1 to 99\n        n = m + 1;\n    } else if (type == \"n_is_double_m\") {\n        if (m == -1)\n            m = rnd.next(1, 50); // m from 1 to 50\n        n = 2 * m;\n    } else {\n        // default: random\n        if (n == -1)\n            n = rnd.next(1, 100);\n        if (m == -1)\n            m = rnd.next(1, n);\n    }\n\n    // Now, make sure that n and m are within bounds\n    n = max(1, min(n, 100));\n    m = max(1, min(m, n));\n\n    // Output n and m\n    printf(\"%d %d\\n\", n, m);\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    string type = opt<string>(\"type\", \"random\");\n    int n = opt<int>(\"n\", -1);\n    int m = opt<int>(\"m\", -1);\n\n    if (type == \"min\") {\n        n = 1; m = 1;\n    } else if (type == \"max\") {\n        n = 100; m = 100;\n    } else if (type == \"n_eq_m\") {\n        if (n == -1)\n            n = rnd.next(1, 100);\n        m = n;\n    } else if (type == \"divisible\") {\n        if (n == -1)\n            n = rnd.next(1, 100);\n        if (m == -1)\n            m = rnd.next(1, n);\n        n = (n / m) * m; // make n divisible by m\n        if (n == 0) n = m; // ensure n ≥ m ≥1\n    } else if (type == \"nondivisible\") {\n        if (n == -1)\n            n = rnd.next(1, 100);\n        if (m == -1)\n            m = rnd.next(1, n);\n        // adjust n to not be divisible by m\n        if (n % m == 0) {\n            if (n + 1 <= 100) n++;\n            else if (n - 1 >= m) n--;\n            else n = m + 1; // ensure n ≥ m + 1\n        }\n    } else if (type == \"n_greater_m_min\") {\n        if (m == -1)\n            m = rnd.next(1, 99); // m from 1 to 99\n        n = m + 1;\n    } else if (type == \"n_is_double_m\") {\n        if (m == -1)\n            m = rnd.next(1, 50); // m from 1 to 50\n        n = 2 * m;\n    } else {\n        // default: random\n        if (n == -1)\n            n = rnd.next(1, 100);\n        if (m == -1)\n            m = rnd.next(1, n);\n    }\n\n    // Now, make sure that n and m are within bounds\n    n = max(1, min(n, 100));\n    m = max(1, min(m, n));\n\n    // Output n and m\n    printf(\"%d %d\\n\", n, m);\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -type min\n\n./gen -type max\n\n./gen -type n_eq_m\n\n./gen -type divisible\n\n./gen -type divisible -n 50\n\n./gen -type nondivisible\n\n./gen -type n_greater_m_min\n\n./gen -type n_greater_m_min -m 1\n\n./gen -type n_is_double_m\n\n./gen -type n_is_double_m -m 30\n\n./gen -type random\n\n./gen -type random\n\n./gen -type random\n\n./gen -type divisible\n\n./gen -type divisible\n\n./gen -type nondivisible\n\n./gen -type nondivisible\n\n./gen -type n_eq_m\n\n./gen -type n_eq_m -n 100\n\n./gen -type random -n 100 -m 1\n\n./gen -type random -n 100\n\n./gen -type random -m 100\n\n./gen -type n_eq_m -n 1\n\n./gen -type n_eq_m -n 100\n\n./gen -type n_greater_m_min -m 99\n\n./gen -type random\n\n./gen -type n_is_double_m -m 50\n\n./gen -type nondivisible -n 100 -m 99\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:05:52.046529",
        "total_tutorials": 1,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "306/B",
      "title": "B. Оптимизатор",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест3 секунды",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеВ первой строке записаны целые числа n и m (1 ≤ n ≤ 2·106, 1 ≤ m ≤ 2·105) — количество байт (ячеек памяти) и количество инструкций в программе Поликарпа. Далее следуют m строк, каждая из которых содержит пару целых чисел ai, li (1 ≤ ai ≤ n, 1 ≤ li ≤ n - ai + 1).",
      "output_spec": "Выходные данныеВ первую строку выведите искомое максимальное количество инструкций, которые можно удалить из программы. Во вторую строку выведите номера инструкций. Инструкции нумеруются от 1 до m в порядке их появления во входных данных. Если решений несколько, выведите любое.",
      "sample_tests": "ПримерыВходные данныеСкопировать10 43 33 14 19 2Выходные данныеСкопировать22 3 Входные данныеСкопировать1 11 1Выходные данныеСкопировать0",
      "description": "B. Оптимизатор\n\nограничение по времени на тест3 секунды\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвыводstdout\n\nВходные данныеВ первой строке записаны целые числа n и m (1 ≤ n ≤ 2·106, 1 ≤ m ≤ 2·105) — количество байт (ячеек памяти) и количество инструкций в программе Поликарпа. Далее следуют m строк, каждая из которых содержит пару целых чисел ai, li (1 ≤ ai ≤ n, 1 ≤ li ≤ n - ai + 1).\n\nВходные данные\n\nВыходные данныеВ первую строку выведите искомое максимальное количество инструкций, которые можно удалить из программы. Во вторую строку выведите номера инструкций. Инструкции нумеруются от 1 до m в порядке их появления во входных данных. Если решений несколько, выведите любое.\n\nВыходные данные\n\nВходные данныеСкопировать10 43 33 14 19 2Выходные данныеСкопировать22 3 Входные данныеСкопировать1 11 1Выходные данныеСкопировать0\n\nВходные данныеСкопировать10 43 33 14 19 2\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать22 3\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать1 11 1\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать0\n\nВыходные данныеСкопировать\n\nСкопировать",
      "solutions": [
        {
          "title": "Testing Round #6 - Codeforces",
          "content": "12-го мая 2013 в 00:00 (да-да, в полночь!) состоится Testing Round 6. Цель этого раунда — хорошенько протестировать платформу. Недавно были сделаны некоторые улучшения/нововведения. Все изменения лежат в недрах бэкенда Codeforces и не будут сильно заметны участникам, однако они затрагивают довольно большое количество кода.Приглашаю вас принять участие. Раунд будет происходить по схеме Div.2 + неофициальное участие Div.1. Он будет состоять из четырех-пяти задач, как определенная разминка — будет интересно всем. Я попрошу не участвовать тем, кто живет в Саратове — вам эти задачи могут оказаться знакомы. Претесты в задачах будут необычно слабыми, чтобы спровоцировать побольше взломов. Конечно, раунд не будет влиять на рейтинг.Спасибо всем, кто примет участие!P.S. Такое странно время выбрано не случайно — в выходные лучше всего работать по ночам!",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/7628",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 854
        }
      ],
      "code_examples": [
        {
          "title": "Testing Round #6 - Codeforces - Code 1",
          "code": "0.0000000000 0.0000000000\n999.1250000000 0.0000000000\n998.8750000000 999.2500000000\n0.0000000000 999.0000000000",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7628",
          "author": "jiangly"
        },
        {
          "title": "Testing Round #6 - Codeforces - Code 2",
          "code": "0.0000000000 0.0000000000\n999.1250000000 0.0000000000\n998.8750000000 999.2500000000\n0.0000000000 999.0000000000",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7628",
          "author": "jiangly"
        },
        {
          "title": "Testing Round #6 - Codeforces - Code 3",
          "code": "A(  0.0000000000,   0.0000000000)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7628",
          "author": "jiangly"
        },
        {
          "title": "Testing Round #6 - Codeforces - Code 4",
          "code": "B(999.1250000000,   0.0000000000)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7628",
          "author": "jiangly"
        },
        {
          "title": "Testing Round #6 - Codeforces - Code 5",
          "code": "C(998.8750000000, 999.2500000000)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7628",
          "author": "jiangly"
        },
        {
          "title": "Testing Round #6 - Codeforces - Code 6",
          "code": "D(  0.0000000000, 999.0000000000)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7628",
          "author": "jiangly"
        },
        {
          "title": "Testing Round #6 - Codeforces - Code 7",
          "code": "999.0000000000 1.5705460452\n998.8750312852 1.5707964207\n999.2500312735 1.5710465144\n999.1250000000 1.5707963268",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7628",
          "author": "jiangly"
        },
        {
          "title": "Testing Round #6 - Codeforces - Code 8",
          "code": "10 3\n1 4\n2 4\n5 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7628",
          "author": "jiangly"
        },
        {
          "title": "Testing Round #6 - Codeforces - Code 9",
          "code": "10 3\n1 4\n2 4\n5 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7628",
          "author": "jiangly"
        },
        {
          "title": "Testing Round #6 - Codeforces - Code 10",
          "code": "3 * 2 * 2 = 12",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7628",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 2000000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 200000, \"m\");\n    inf.readEoln();\n\n    for (int i = 0; i < m; ++i) {\n        int a_i = inf.readInt(1, n, \"a_i\");\n        inf.readSpace();\n        int l_i = inf.readInt(1, n - a_i + 1, \"l_i\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 2000000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 200000, \"m\");\n    inf.readEoln();\n\n    for (int i = 0; i < m; ++i) {\n        int a_i = inf.readInt(1, n, \"a_i\");\n        inf.readSpace();\n        int l_i = inf.readInt(1, n - a_i + 1, \"l_i\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 2000000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 200000, \"m\");\n    inf.readEoln();\n\n    for (int i = 0; i < m; ++i) {\n        int a_i = inf.readInt(1, n, \"a_i\");\n        inf.readSpace();\n        int l_i = inf.readInt(1, n - a_i + 1, \"l_i\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\n/*\n   We have an original list of m \"set13\" instructions, each covering a\n   range [a_i, a_i + l_i - 1] in memory from 1 to n. After applying all\n   instructions in order, some subset of cells end up set to 13.\n\n   A valid optimized solution must remove a subset of instructions but still\n   produce exactly the same set of 13-cells as before (no more, no fewer).\n   Additionally, it must remove the *maximum possible* number of instructions\n   to be considered correct.\n\n   We implement a checker that:\n\n   1) Reads the input (n, m, and the m instructions).\n   2) Computes originalUsed[], a boolean array of length n, marking which cells\n      end up set to 13 after applying *all* instructions.\n   3) Reads the jury's (correct) answer from ans, checks it, and records how\n      many instructions the jury removes (jansRem).\n   4) Reads the participant's answer from ouf, checks it, and records how many\n      instructions the participant removes (pansRem).\n   5) Compares jansRem and pansRem:\n      - If pansRem < jansRem => the participant has not removed as many as the jury => _wa.\n      - If pansRem == jansRem => _ok.\n      - If pansRem > jansRem => _fail (the participant claims a strictly better solution than jury).\n*/\n\nstatic const char* WRONG_SUBSET_MSG = \"The memory coverage after applying the chosen subset of instructions differs from the original coverage\";\n\n// We'll store the instructions in a vector\nvector<pair<int,int>> instructions; // each pair is (a_i, l_i)\nint n, m;\n\n// originalUsed[i] will tell whether cell i (1-based) ends up with 13\n// after applying all instructions\nvector<bool> originalUsed;\n\n// This function computes the boolean coverage array for a given subset described by 'removed[]'\nvector<bool> computeCoverage(const vector<bool> &removed) {\n    // We'll use a difference array approach to handle up to n=2e6 efficiently\n    // diff[i] = +1 if an instruction starts at i, -1 if an instruction ends just before i\n    // Then prefix sum to determine how many instructions are covering position i at the end.\n    // coverage[i] > 0  => that cell i is set to 13.\n\n    vector<int> diff(n+2, 0); // we only need up to n+1 safely; using +2 just in case\n\n    for (int i = 0; i < m; i++) {\n        if (!removed[i]) {\n            int a = instructions[i].first;\n            int l = instructions[i].second;\n            diff[a]++;\n            // the last covered cell is (a + l - 1)\n            int endPos = a + l; // we'll do -- at this index\n            diff[endPos]--;\n        }\n    }\n\n    vector<bool> used(n+1, false);\n    int coverage = 0;\n    for (int i = 1; i <= n; i++) {\n        coverage += diff[i];\n        used[i] = (coverage > 0);\n    }\n    return used;\n}\n\nstruct AnswerInfo {\n    long long removedCount;\n};\n\n// Reads and checks one answer (either jury's or participant's).\n// Returns the number of removed instructions.\nAnswerInfo readAnswer(InStream &stream, const vector<bool> &origUsed, bool isJury) {\n    // read how many instructions they remove\n    long long x = stream.readLong(0, m, \"number of removed instructions\");\n\n    // read the distinct indices of removed instructions\n    vector<bool> removed(m, false);\n    if (x > 0) {\n        // read x distinct integers from 1..m\n        // store them in removed[]\n        // also check for duplicates\n        set<int> usedIds;\n        for (int i = 0; i < x; i++){\n            int idx = stream.readInt(1, m, \"removed instruction index\");\n            if (usedIds.count(idx)) {\n                stream.quitf(_wa, \"duplicate instruction index %d\", idx);\n            }\n            usedIds.insert(idx);\n        }\n        // mark them in removed[]\n        for (int idx: usedIds) removed[idx - 1] = true; // shift to 0-based\n    }\n\n    // now compute coverage for the remaining instructions\n    vector<bool> newUsed = computeCoverage(removed);\n\n    // compare with original coverage\n    for (int i = 1; i <= n; i++) {\n        if (origUsed[i] != newUsed[i]) {\n            if (isJury) {\n                // if jury's answer is wrong => _fail\n                stream.quitf(_fail,\n                    \"%s at cell %d (jury's coverage=%d, expected=%d)\",\n                    WRONG_SUBSET_MSG, i, newUsed[i], origUsed[i]);\n            } else {\n                // if participant's answer is wrong => _wa\n                stream.quitf(_wa,\n                    \"%s at cell %d (participant coverage=%d, expected=%d)\",\n                    WRONG_SUBSET_MSG, i, newUsed[i], origUsed[i]);\n            }\n        }\n    }\n\n    AnswerInfo ret;\n    ret.removedCount = x;\n    return ret;\n}\n\nint main(int argc, char* argv[]) {\n    registerTestlibCmd(argc, argv);\n\n    // 1) Read input\n    n = inf.readInt(); // 1 <= n <= 2e6\n    m = inf.readInt(); // 1 <= m <= 2e5\n    instructions.resize(m);\n    for (int i = 0; i < m; i++) {\n        int a = inf.readInt();  // 1 <= a <= n\n        int l = inf.readInt();  // 1 <= l <= n - a + 1\n        instructions[i] = make_pair(a, l);\n    }\n\n    // 2) Compute the final coverage after all instructions => originalUsed[]\n    {\n        vector<int> diff(n+2, 0);\n        for (int i = 0; i < m; i++) {\n            int a = instructions[i].first;\n            int l = instructions[i].second;\n            diff[a]++;\n            diff[a + l]--;\n        }\n        originalUsed.resize(n+1, false);\n        int coverage = 0;\n        for (int i = 1; i <= n; i++) {\n            coverage += diff[i];\n            originalUsed[i] = (coverage > 0);\n        }\n    }\n\n    // 3) Read jury's answer from ans\n    AnswerInfo juryAns = readAnswer(ans, originalUsed, /*isJury=*/true);\n\n    // 4) Read participant's answer from ouf\n    AnswerInfo partAns = readAnswer(ouf, originalUsed, /*isJury=*/false);\n\n    // 5) Compare how many instructions they removed\n    if (partAns.removedCount < juryAns.removedCount) {\n        quitf(_wa,\n              \"Participant removed fewer instructions than jury's solution (%lld < %lld). Not maximum.\",\n              partAns.removedCount, juryAns.removedCount);\n    } else if (partAns.removedCount == juryAns.removedCount) {\n        quitf(_ok,\n              \"Correct. Number of removed instructions = %lld.\",\n              partAns.removedCount);\n    } else {\n        // partAns.removedCount > juryAns.removedCount\n        quitf(_fail,\n              \"Participant's solution removes more instructions (%lld) than jury's solution (%lld).\",\n              partAns.removedCount, juryAns.removedCount);\n    }\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string type = opt<string>(\"type\", \"random\");\n\n    printf(\"%d %d\\n\", n, m);\n\n    vector<int> a(m), l(m);\n\n    if (type == \"random\") {\n        for (int i = 0; i < m; ++i) {\n            a[i] = rnd.next(1, n);\n            l[i] = rnd.next(1, n - a[i] +1);\n        }\n    } else if (type == \"nested\") {\n        int curr_start = 1;\n        int curr_end = n;\n        for (int i = 0; i < m; ++i) {\n            a[i] = curr_start;\n            l[i] = curr_end - curr_start +1;\n            if (curr_start < curr_end) {\n                curr_start += rnd.next(0, 10);\n                curr_end -= rnd.next(0, 10);\n                if (curr_start > curr_end) {\n                    curr_start = 1;\n                    curr_end = n;\n                }\n            }\n        }\n    } else if (type == \"chain\") {\n        int curr_pos = 1;\n        for (int i = 0; i < m; ++i) {\n            if (curr_pos > n)\n                curr_pos = 1;\n            a[i] = curr_pos;\n            l[i] = 1;\n            curr_pos += 1;\n        }\n    } else if (type == \"full\") {\n        for (int i = 0; i < m; ++i) {\n            a[i] = 1;\n            l[i] = n;\n        }\n    } else if (type == \"single_byte\") {\n        for (int i = 0; i < m; ++i) {\n            a[i] = rnd.next(1, n);\n            l[i] = 1;\n        }\n    } else if (type == \"overlap\") {\n        int max_range = max(n / 10, 1);\n        for (int i = 0; i < m; ++i) {\n            int start = rnd.next(1, n - max_range +1);\n            int len = rnd.next(1, max_range);\n            a[i] = start;\n            l[i] = len;\n        }\n    } else if (type == \"same_range\") {\n        int a_val = rnd.next(1, n);\n        int l_val = rnd.next(1, n - a_val +1);\n        for (int i = 0; i < m; ++i) {\n            a[i] = a_val;\n            l[i] = l_val;\n        }\n    } else if (type == \"contained\") {\n        int curr_start = 1;\n        int curr_end = n;\n        for (int i = 0; i < m; ++i) {\n            a[i] = curr_start;\n            l[i] = curr_end - curr_start +1;\n            if (curr_start < curr_end) {\n                curr_start += rnd.next(1, (n / m) + 1);\n                // Ensure that l[i] >=1\n                if (curr_start > curr_end) {\n                    curr_start = rnd.next(1, n);\n                    curr_end = n;\n                }\n            }\n        }\n    } else {\n        fprintf(stderr, \"Unknown type: %s\\n\", type.c_str());\n        exit(1);\n    }\n\n    // Output the instructions\n    for (int i = 0; i < m; ++i) {\n        printf(\"%d %d\\n\", a[i], l[i]);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string type = opt<string>(\"type\", \"random\");\n\n    printf(\"%d %d\\n\", n, m);\n\n    vector<int> a(m), l(m);\n\n    if (type == \"random\") {\n        for (int i = 0; i < m; ++i) {\n            a[i] = rnd.next(1, n);\n            l[i] = rnd.next(1, n - a[i] +1);\n        }\n    } else if (type == \"nested\") {\n        int curr_start = 1;\n        int curr_end = n;\n        for (int i = 0; i < m; ++i) {\n            a[i] = curr_start;\n            l[i] = curr_end - curr_start +1;\n            if (curr_start < curr_end) {\n                curr_start += rnd.next(0, 10);\n                curr_end -= rnd.next(0, 10);\n                if (curr_start > curr_end) {\n                    curr_start = 1;\n                    curr_end = n;\n                }\n            }\n        }\n    } else if (type == \"chain\") {\n        int curr_pos = 1;\n        for (int i = 0; i < m; ++i) {\n            if (curr_pos > n)\n                curr_pos = 1;\n            a[i] = curr_pos;\n            l[i] = 1;\n            curr_pos += 1;\n        }\n    } else if (type == \"full\") {\n        for (int i = 0; i < m; ++i) {\n            a[i] = 1;\n            l[i] = n;\n        }\n    } else if (type == \"single_byte\") {\n        for (int i = 0; i < m; ++i) {\n            a[i] = rnd.next(1, n);\n            l[i] = 1;\n        }\n    } else if (type == \"overlap\") {\n        int max_range = max(n / 10, 1);\n        for (int i = 0; i < m; ++i) {\n            int start = rnd.next(1, n - max_range +1);\n            int len = rnd.next(1, max_range);\n            a[i] = start;\n            l[i] = len;\n        }\n    } else if (type == \"same_range\") {\n        int a_val = rnd.next(1, n);\n        int l_val = rnd.next(1, n - a_val +1);\n        for (int i = 0; i < m; ++i) {\n            a[i] = a_val;\n            l[i] = l_val;\n        }\n    } else if (type == \"contained\") {\n        int curr_start = 1;\n        int curr_end = n;\n        for (int i = 0; i < m; ++i) {\n            a[i] = curr_start;\n            l[i] = curr_end - curr_start +1;\n            if (curr_start < curr_end) {\n                curr_start += rnd.next(1, (n / m) + 1);\n                // Ensure that l[i] >=1\n                if (curr_start > curr_end) {\n                    curr_start = rnd.next(1, n);\n                    curr_end = n;\n                }\n            }\n        }\n    } else {\n        fprintf(stderr, \"Unknown type: %s\\n\", type.c_str());\n        exit(1);\n    }\n\n    // Output the instructions\n    for (int i = 0; i < m; ++i) {\n        printf(\"%d %d\\n\", a[i], l[i]);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Small n and m, minimal cases\n./gen -n 1 -m 1 -type random\n./gen -n 1 -m 1 -type full\n./gen -n 1 -m 1 -type same_range\n\n# Small n and m, edge cases\n./gen -n 2 -m 1 -type nested\n./gen -n 2 -m 2 -type chain\n./gen -n 10 -m 15 -type overlap\n./gen -n 10 -m 20 -type contained\n\n# Medium n and m\n./gen -n 1000 -m 100 -type random\n./gen -n 1000 -m 100 -type nested\n./gen -n 1000 -m 100 -type chain\n./gen -n 1000 -m 100 -type single_byte\n./gen -n 1000 -m 100 -type overlap\n./gen -n 1000 -m 100 -type same_range\n./gen -n 1000 -m 100 -type contained\n\n# Large n, small m\n./gen -n 2000000 -m 10 -type random\n./gen -n 2000000 -m 10 -type full\n./gen -n 2000000 -m 10 -type single_byte\n\n# Large n and m\n./gen -n 2000000 -m 200000 -type random\n./gen -n 2000000 -m 200000 -type nested\n./gen -n 2000000 -m 200000 -type chain\n./gen -n 2000000 -m 200000 -type overlap\n./gen -n 2000000 -m 200000 -type same_range\n./gen -n 2000000 -m 200000 -type contained\n\n# Maximal m and n\n./gen -n 2000000 -m 200000 -type full\n\n# Small n, large m\n./gen -n 5 -m 200000 -type random\n./gen -n 5 -m 200000 -type same_range\n\n# Edge cases with maximal instruction count\n./gen -n 10 -m 200000 -type chain\n./gen -n 10 -m 200000 -type overlap\n\n# Medium n with varying m\n./gen -n 100000 -m 50000 -type random\n./gen -n 100000 -m 50000 -type nested\n./gen -n 100000 -m 50000 -type contained\n\n# Testing single-byte instructions at large scale\n./gen -n 1000000 -m 100000 -type single_byte\n\n# Testing overlapping ranges thoroughly\n./gen -n 500000 -m 200000 -type overlap\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:05:53.935928",
        "total_tutorials": 1,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "306/C",
      "title": "C. White, Black and White Again",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test3 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe single line of the input contains integers n, w and b (3 ≤ n ≤ 4000, 2 ≤ w ≤ 4000, 1 ≤ b ≤ 4000) — the number of days, the number of good events and the number of not-so-good events. It is guaranteed that w + b ≥ n.",
      "output_spec": "OutputPrint the required number of ways modulo 1000000009 (109 + 9).",
      "sample_tests": "ExamplesInputCopy3 2 1OutputCopy2InputCopy4 2 2OutputCopy4InputCopy3 2 2OutputCopy4",
      "description": "C. White, Black and White Again\n\ntime limit per test3 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe single line of the input contains integers n, w and b (3 ≤ n ≤ 4000, 2 ≤ w ≤ 4000, 1 ≤ b ≤ 4000) — the number of days, the number of good events and the number of not-so-good events. It is guaranteed that w + b ≥ n.\n\nOutputPrint the required number of ways modulo 1000000009 (109 + 9).\n\nInputCopy3 2 1OutputCopy2InputCopy4 2 2OutputCopy4InputCopy3 2 2OutputCopy4\n\nInputCopy3 2 1\n\nOutputCopy2\n\nInputCopy4 2 2\n\nOutputCopy4\n\nInputCopy3 2 2\n\nOutputCopy4\n\nNoteWe'll represent the good events by numbers starting from 1 and the not-so-good events — by letters starting from 'a'. Vertical lines separate days.In the first sample the possible ways are: \"1|a|2\" and \"2|a|1\". In the second sample the possible ways are: \"1|a|b|2\", \"2|a|b|1\", \"1|b|a|2\" and \"2|b|a|1\". In the third sample the possible ways are: \"1|ab|2\", \"2|ab|1\", \"1|ba|2\" and \"2|ba|1\".",
      "solutions": [
        {
          "title": "Testing Round #6 - Codeforces",
          "content": "Testing Round 6 starts on May 11, 2013, 20:00 (UTC). Our goal is to test the platform after recent improvements. All of them are in the Codeforces backend, but they affect many lines of the code.I invite you to take part in the round. It will be Div. 2 + unofficials from Div. 1. It will contain four-five obsolescent problems. But I think it will be interesting for many of you. The problems contain very weak pretests to force more hacks. It will be unrated round.Many thanks to participants!P.S. As it is testing round, we do not guarantee stable work and so on.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/7628",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 565
        }
      ],
      "code_examples": [
        {
          "title": "Testing Round #6 - Codeforces - Code 1",
          "code": "3 * 2 * 2 = 12",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7628",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(3, 4000, \"n\");\n    inf.readSpace();\n    int w = inf.readInt(2, 4000, \"w\");\n    inf.readSpace();\n    int b = inf.readInt(1, 4000, \"b\");\n    inf.readEoln();\n\n    ensuref(w + b >= n, \"Constraint violated: w + b >= n, w = %d, b = %d, n = %d\", w, b, n);\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(3, 4000, \"n\");\n    inf.readSpace();\n    int w = inf.readInt(2, 4000, \"w\");\n    inf.readSpace();\n    int b = inf.readInt(1, 4000, \"b\");\n    inf.readEoln();\n\n    ensuref(w + b >= n, \"Constraint violated: w + b >= n, w = %d, b = %d, n = %d\", w, b, n);\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(3, 4000, \"n\");\n    inf.readSpace();\n    int w = inf.readInt(2, 4000, \"w\");\n    inf.readSpace();\n    int b = inf.readInt(1, 4000, \"b\");\n    inf.readEoln();\n\n    ensuref(w + b >= n, \"Constraint violated: w + b >= n, w = %d, b = %d, n = %d\", w, b, n);\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\", -1);\n    int w = opt<int>(\"w\", -1);\n    int b = opt<int>(\"b\", -1);\n\n    string type = opt<string>(\"type\", \"random\");\n\n    if (n == -1) {\n        n = rnd.next(3, 4000);\n    }\n\n    if (type == \"sample1\") {\n        n = 3; w = 2; b = 1;\n    } else if (type == \"sample2\") {\n        n = 4; w = 2; b = 2;\n    } else if (type == \"sample3\") {\n        n = 3; w = 2; b = 2;\n    } else if (type == \"min_events\") {\n        w = 2; b = 1;\n    } else if (type == \"max_events\") {\n        w = 4000; b = 4000; n = 4000;\n    } else if (type == \"max_n\") {\n        n = 4000;\n    } else if (type == \"w_plus_b_equals_n\") {\n        if (n == -1) n = rnd.next(3,4000);\n        w = rnd.next(2, n - 1);\n        b = n - w;\n    } else if (type == \"balanced\") {\n        if (n == -1) n = rnd.next(3,4000);\n        int total_events = rnd.next(n, min(4000, n*2));\n        w = total_events / 2;\n        if (w < 2) w = 2;\n        b = total_events - w;\n        if (b < 1) b = 1;\n    } else if (type == \"unbalanced_w_large\") {\n        if (n == -1) n = rnd.next(3, 3999);\n        w = 4000;\n        b = max(1, n - w);\n    } else if (type == \"unbalanced_b_large\") {\n        if (n == -1) n = rnd.next(3, 3999);\n        b = 4000;\n        w = max(2, n - b);\n    } else if (type == \"max_w\") {\n        w = 4000;\n        b = rnd.next(1, 4000);\n    } else if (type == \"max_b\") {\n        b = 4000;\n        w = rnd.next(2, 4000);\n    } else if (type == \"random\") {\n        w = rnd.next(2, 4000);\n        b = rnd.next(1, 4000);\n    }\n\n    // Ensure w and b are set\n    if (w == -1) {\n        w = rnd.next(2, 4000);\n    }\n    if (b == -1) {\n        b = rnd.next(1, 4000);\n    }\n\n    // Ensure constraints\n    n = min(max(n, 3), 4000);\n    w = min(max(w, 2), 4000);\n    b = min(max(b, 1), 4000);\n\n    if (w + b < n) {\n        w += n - (w + b);\n        if (w > 4000) {\n            b += w - 4000;\n            w = 4000;\n            b = min(b, 4000);\n        }\n    }\n\n    printf(\"%d %d %d\\n\", n, w, b);\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\", -1);\n    int w = opt<int>(\"w\", -1);\n    int b = opt<int>(\"b\", -1);\n\n    string type = opt<string>(\"type\", \"random\");\n\n    if (n == -1) {\n        n = rnd.next(3, 4000);\n    }\n\n    if (type == \"sample1\") {\n        n = 3; w = 2; b = 1;\n    } else if (type == \"sample2\") {\n        n = 4; w = 2; b = 2;\n    } else if (type == \"sample3\") {\n        n = 3; w = 2; b = 2;\n    } else if (type == \"min_events\") {\n        w = 2; b = 1;\n    } else if (type == \"max_events\") {\n        w = 4000; b = 4000; n = 4000;\n    } else if (type == \"max_n\") {\n        n = 4000;\n    } else if (type == \"w_plus_b_equals_n\") {\n        if (n == -1) n = rnd.next(3,4000);\n        w = rnd.next(2, n - 1);\n        b = n - w;\n    } else if (type == \"balanced\") {\n        if (n == -1) n = rnd.next(3,4000);\n        int total_events = rnd.next(n, min(4000, n*2));\n        w = total_events / 2;\n        if (w < 2) w = 2;\n        b = total_events - w;\n        if (b < 1) b = 1;\n    } else if (type == \"unbalanced_w_large\") {\n        if (n == -1) n = rnd.next(3, 3999);\n        w = 4000;\n        b = max(1, n - w);\n    } else if (type == \"unbalanced_b_large\") {\n        if (n == -1) n = rnd.next(3, 3999);\n        b = 4000;\n        w = max(2, n - b);\n    } else if (type == \"max_w\") {\n        w = 4000;\n        b = rnd.next(1, 4000);\n    } else if (type == \"max_b\") {\n        b = 4000;\n        w = rnd.next(2, 4000);\n    } else if (type == \"random\") {\n        w = rnd.next(2, 4000);\n        b = rnd.next(1, 4000);\n    }\n\n    // Ensure w and b are set\n    if (w == -1) {\n        w = rnd.next(2, 4000);\n    }\n    if (b == -1) {\n        b = rnd.next(1, 4000);\n    }\n\n    // Ensure constraints\n    n = min(max(n, 3), 4000);\n    w = min(max(w, 2), 4000);\n    b = min(max(b, 1), 4000);\n\n    if (w + b < n) {\n        w += n - (w + b);\n        if (w > 4000) {\n            b += w - 4000;\n            w = 4000;\n            b = min(b, 4000);\n        }\n    }\n\n    printf(\"%d %d %d\\n\", n, w, b);\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 3 -w 2 -b 1\n./gen -n 4 -w 2 -b 2\n./gen -n 3 -w 2 -b 2\n\n./gen -n 3 -type min_events\n./gen -n 3 -type unbalanced_w_large\n./gen -n 3 -type unbalanced_b_large\n./gen -n 3 -type balanced\n./gen -n 3 -type w_plus_b_equals_n\n\n./gen -n 4000 -w 4000 -b 4000\n./gen -n 4000 -type max_events\n./gen -n 4000 -type unbalanced_w_large\n./gen -n 4000 -type unbalanced_b_large\n./gen -n 4000 -type balanced\n\n./gen -n 2000 -type w_plus_b_equals_n\n./gen -n 4000 -type w_plus_b_equals_n\n\n./gen -n 4 -w 2 -b 4000\n./gen -n 4 -w 4000 -b 1\n\n./gen -n 1000 -type random\n./gen -n 2000 -type random\n./gen -n 3000 -type random\n./gen -n 4000 -type random\n\n./gen -n 3 -w 2 -b 1\n./gen -n 3 -w 2 -b 3999\n./gen -n 4000 -w 2 -b 3998\n\n./gen -n 3999 -w 3999 -b 1\n./gen -n 3999 -w 1 -b 3999\n\n./gen -n 1000 -type balanced\n./gen -n 2000 -type balanced\n./gen -n 3000 -type balanced\n./gen -n 4000 -type balanced\n\n./gen -n 4000 -type max_w\n\n./gen -n 4000 -type max_b\n\n./gen -n 4000 -w 2 -b 1\n\n# Random test cases\n./gen -type random\n./gen -type random\n./gen -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:05:55.861647",
        "total_tutorials": 1,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "306/D",
      "title": "D. Polygon",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe input contains a single integer n (3 ≤ n ≤ 100) — the number of the polygon vertexes.",
      "output_spec": "OutputPrint n lines, containing the coordinates of the vertexes of the n-gon \"xi yi\" in the counter clockwise order. The coordinates of the vertexes shouldn't exceed 106 in their absolute value. The side lengths should fit within limits [1, 1000] (not necessarily integer). Mutual comparing sides and angles of your polygon during the test will go with precision of 10 - 3.If there is no solution, print \"No solution\" (without the quotes).",
      "sample_tests": "ExamplesInputCopy8OutputCopy1.000 0.0007.000 0.0009.000 2.0009.000 3.0005.000 7.0003.000 7.0000.000 4.0000.000 1.000",
      "description": "time limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe input contains a single integer n (3 ≤ n ≤ 100) — the number of the polygon vertexes.\n\nOutputPrint n lines, containing the coordinates of the vertexes of the n-gon \"xi yi\" in the counter clockwise order. The coordinates of the vertexes shouldn't exceed 106 in their absolute value. The side lengths should fit within limits [1, 1000] (not necessarily integer). Mutual comparing sides and angles of your polygon during the test will go with precision of 10 - 3.If there is no solution, print \"No solution\" (without the quotes).\n\nInputCopy8OutputCopy1.000 0.0007.000 0.0009.000 2.0009.000 3.0005.000 7.0003.000 7.0000.000 4.0000.000 1.000\n\nOutputCopy1.000 0.0007.000 0.0009.000 2.0009.000 3.0005.000 7.0003.000 7.0000.000 4.0000.000 1.000",
      "solutions": [
        {
          "title": "Testing Round #6 - Codeforces",
          "content": "Testing Round 6 starts on May 11, 2013, 20:00 (UTC). Our goal is to test the platform after recent improvements. All of them are in the Codeforces backend, but they affect many lines of the code.I invite you to take part in the round. It will be Div. 2 + unofficials from Div. 1. It will contain four-five obsolescent problems. But I think it will be interesting for many of you. The problems contain very weak pretests to force more hacks. It will be unrated round.Many thanks to participants!P.S. As it is testing round, we do not guarantee stable work and so on.",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/7628",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 565
        }
      ],
      "code_examples": [
        {
          "title": "Testing Round #6 - Codeforces - Code 1",
          "code": "3 * 2 * 2 = 12",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7628",
          "author": "Qingyu"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(3, 100, \"n\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(3, 100, \"n\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(3, 100, \"n\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint n;\n\nint main(int argc, char* argv[]) {\n    registerTestlibCmd(argc, argv);\n\n    n = inf.readInt(3, 100, \"n\");\n\n    vector<double> x, y;\n    bool noSolution = false;\n\n    // Try to read n lines containing coordinates\n    for (int i = 0; i < n; i++) {\n        if (ouf.eof()) {\n            // Not enough coordinates\n            if (i == 0) {\n                // No output at all\n                quitf(_wa, \"No output\");\n            } else {\n                quitf(_wa, \"Expected %d coordinates, but only %d lines were given\", n, i);\n            }\n        }\n\n        string line = ouf.readLine();\n\n        // Try to read two doubles from line\n        stringstream ss(line);\n        double xi, yi;\n        if (!(ss >> xi >> yi)) {\n            // Could not read two doubles\n            if (i == 0) {\n                string token = line;\n                transform(token.begin(), token.end(), token.begin(), ::tolower);\n                if (token == \"no\" || token == \"no solution\") {\n                    if (n <= 4) {\n                        // Acceptable\n                        quitf(_ok, \"No solution for n = %d\", n);\n                    } else {\n                        quitf(_wa, \"Solution exists for n = %d\", n);\n                    }\n                } else {\n                    quitf(_wa, \"Invalid output: \\\"%s\\\"\", line.c_str());\n                }\n            } else {\n                quitf(_wa, \"Invalid coordinates at line %d: \\\"%s\\\"\", i + 1, line.c_str());\n            }\n        } else {\n            x.push_back(xi);\n            y.push_back(yi);\n            // Check coordinate bounds\n            if (fabs(xi) > 1e6 + 1e-8 || fabs(yi) > 1e6 + 1e-8) {\n                quitf(_wa, \"Coordinate out of bounds at line %d: x = %f, y = %f\", i + 1, xi, yi);\n            }\n        }\n    }\n\n    // Check for extra output\n    if (!ouf.seekEof()) {\n        quitf(_wa, \"Extra output detected after the %d coordinates\", n);\n    }\n\n    // Now verify the polygon\n\n    // Compute side lengths\n    vector<double> side_lengths(n);\n    for (int i = 0; i < n; i++) {\n        int j = (i + 1) % n;\n        double dx = x[j] - x[i];\n        double dy = y[j] - y[i];\n        side_lengths[i] = sqrt(dx * dx + dy * dy);\n        if (side_lengths[i] < 1.0 - 1e-8 || side_lengths[i] > 1000.0 + 1e-8) {\n            quitf(_wa, \"Side length[%d] = %0.6f not in [1, 1000]\", i + 1, side_lengths[i]);\n        }\n    }\n\n    // Check that all sides are different within precision 1e-3\n    for (int i = 0; i < n; i++) {\n        for (int j = i + 1; j < n; j++) {\n            if (fabs(side_lengths[i] - side_lengths[j]) <= 1e-3) {\n                quitf(_wa, \"Sides %d and %d are equal within precision 1e-3: %0.6f == %0.6f\", i + 1, j + 1, side_lengths[i], side_lengths[j]);\n            }\n        }\n    }\n\n    // Check convexity\n    double sign = 0;\n    for (int i = 0; i < n; i++) {\n        int prev = (i - 1 + n) % n;\n        int next = (i + 1) % n;\n        double x1 = x[i] - x[prev];\n        double y1 = y[i] - y[prev];\n        double x2 = x[next] - x[i];\n        double y2 = y[next] - y[i];\n        double cross = x1 * y2 - x2 * y1;\n        if (i == 0) {\n            sign = cross;\n        } else {\n            if (sign * cross < -1e-8) {\n                quitf(_wa, \"Polygon is not convex at vertex %d\", i + 1);\n            }\n        }\n    }\n\n    // Compute angles\n    vector<double> angles(n);\n    for (int i = 0; i < n; i++) {\n        int prev = (i - 1 + n) % n;\n        int next = (i + 1) % n;\n        double x1 = x[prev] - x[i];\n        double y1 = y[prev] - y[i];\n        double x2 = x[next] - x[i];\n        double y2 = y[next] - y[i];\n        double dot = x1 * x2 + y1 * y2;\n        double len1 = sqrt(x1 * x1 + y1 * y1);\n        double len2 = sqrt(x2 * x2 + y2 * y2);\n        double costheta = dot / (len1 * len2);\n        costheta = max(-1.0, min(1.0, costheta));\n        double theta = acos(costheta);\n        angles[i] = theta;\n    }\n\n    // Check that all angles are equal within precision 1e-3\n    double min_angle = *min_element(angles.begin(), angles.end());\n    double max_angle = *max_element(angles.begin(), angles.end());\n    if (max_angle - min_angle > 1e-3) {\n        quitf(_wa, \"Angles are not equal within precision 1e-3\");\n    }\n\n    // All checks passed\n    quitf(_ok, \"Correct polygon for n = %d\", n);\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\", 0);\n    string type = opt<string>(\"type\", \"random\");\n\n    if (type == \"random\") {\n        if (n == 0) {\n            n = rnd.next(3, 100);\n        }\n    } else if (type == \"possible\") {\n        if (n == 0) {\n            n = rnd.next(6, 100);\n        } else if (n < 6 || n > 100) {\n            n = 6;\n        }\n    } else if (type == \"impossible\") {\n        if (n == 0) {\n            n = rnd.next(3, 5);\n        } else if (n < 3 || n > 5) {\n            n = 5;\n        }\n    }\n\n    printf(\"%d\\n\", n);\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\", 0);\n    string type = opt<string>(\"type\", \"random\");\n\n    if (type == \"random\") {\n        if (n == 0) {\n            n = rnd.next(3, 100);\n        }\n    } else if (type == \"possible\") {\n        if (n == 0) {\n            n = rnd.next(6, 100);\n        } else if (n < 6 || n > 100) {\n            n = 6;\n        }\n    } else if (type == \"impossible\") {\n        if (n == 0) {\n            n = rnd.next(3, 5);\n        } else if (n < 3 || n > 5) {\n            n = 5;\n        }\n    }\n\n    printf(\"%d\\n\", n);\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -type impossible -n 3\n./gen -type impossible -n 4\n./gen -type impossible -n 5\n\n./gen -type possible -n 6\n./gen -type possible -n 7\n./gen -type possible -n 8\n./gen -type possible -n 9\n./gen -type possible -n 10\n\n./gen -type possible -n 100\n./gen -type possible -n 50\n./gen -type possible -n 75\n\n./gen -type possible\n./gen -type possible\n./gen -type possible\n\n./gen -type impossible\n./gen -type impossible\n./gen -type impossible\n\n./gen -type random\n./gen -type random\n./gen -type random\n\n./gen -n 3\n./gen -n 4\n./gen -n 5\n./gen -n 6\n./gen -n 7\n./gen -n 50\n./gen -n 99\n./gen -n 100\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:05:57.899026",
        "total_tutorials": 1,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "309/A",
      "title": "A. Morning run",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line of the input contains three integers n, l, t (1 ≤ n ≤ 106, 1 ≤ l ≤ 109, 1 ≤ t ≤ 109). The next line contains n distinct integers a1, a2, ..., an (0 ≤ a1 < a2 < ... < an < l), here ai is the clockwise distance from the start line to the i-th runner's starting position.",
      "output_spec": "OutputPrint a single real number — the answer to the problem with absolute or relative error of at most 10 - 6.",
      "sample_tests": "ExamplesInputCopy2 5 10 2OutputCopy0.2500000000InputCopy3 7 30 1 6OutputCopy1.5000000000",
      "description": "A. Morning run\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line of the input contains three integers n, l, t (1 ≤ n ≤ 106, 1 ≤ l ≤ 109, 1 ≤ t ≤ 109). The next line contains n distinct integers a1, a2, ..., an (0 ≤ a1 < a2 < ... < an < l), here ai is the clockwise distance from the start line to the i-th runner's starting position.\n\nOutputPrint a single real number — the answer to the problem with absolute or relative error of at most 10 - 6.\n\nInputCopy2 5 10 2OutputCopy0.2500000000InputCopy3 7 30 1 6OutputCopy1.5000000000\n\nInputCopy2 5 10 2\n\nOutputCopy0.2500000000\n\nInputCopy3 7 30 1 6\n\nOutputCopy1.5000000000\n\nNoteThere are two runners in the first example. If the first runner run clockwise direction, then in 1 time unit he will be 1m away from the start line. If the second runner run counter-clockwise direction then in 1 time unit he will be also 1m away from the start line. And it is the only possible way to meet. We assume that each running direction is equiprobable, so the answer for the example is equal to 0.5·0.5 = 0.25.",
      "solutions": [
        {
          "title": "Croc Champ 2013 — Finals - Codeforces",
          "content": "Today it will be Croc Champ 2013 Finals! Good luck to all participants. And to those who don't participate — enjoy the interesting competition.Yesterday have finished the trial contest and Code Game Challenge. The winner of Code Game Challenge is ... tourist!Also pay attention to the Croc Champ 2013 - Finals (online version, Div. 1). It will be a rated round. Note: it will be slightly unsual because we will not hide the standings of the official contest. So some information about difficulties of the problems will be known before the round. The contest duration is 2.5 hours.Good luck to everyone!The contest has been finished. The winners are: tourist Egor eatmore Final standings",
          "author": "MikeMirzayanov",
          "url": "https://codeforces.com/blog/entry/7693",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 686
        },
        {
          "title": "Croc Champ 2013 — Final Round — Editorial - Codeforces",
          "content": "Problem A. Morning runWe were asked to find the expected value of meetings between the runners. How to do that? As the first step, expected value is lineal, so we can split the initial problems into the different ones: find the expected value of meetings between the fixed pair of runners. We will solve these problems. To do that we need to make some observations: Let x be the distance between the two runners and they run face to face for infinite amount of time (probability of that obviously equals to 0.5·0.5 = 0.25). Then the first meeting will happen at time , the next one — , the next — and so on. Let us assume that every run ran for l time units. Then if two runners meet — they meet exactly two times. The probability of the meeting equals to 0.5, because in two cases they run in the same direction and in two cases in the different ones. We will build our solution based on these two observations. As the first step let us represent t as t = k·l + p, where 0 ≤ p < l. Then each runner will run k full laps. What does that mean? Because we have pairs of runners, then in those k laps each pair will have 2k meetings with probability equals to 0.5. So, we need to add to the answer.Now we need to take into account p seconds of running. Let us assume that the distance between two runners is x and they run towards each other. Then they will meet if , or x ≤ 2t. They will meet once more if , ir x ≤ 2t - l. They cannot meet more than twice, because p < l.Let us fix one of the runners, then using binary search we can find all other runners at distance no more than x from the fixed one. Let us choose x as x = 2t, and then the number of runners at the distance no more than x stands for the number of runners which meet with the fixed one at least once. If x = 2t - l, we will find the number of runners which meet with the fixed one exactly two times. Multiplying these numbers by 0.25 — probability of the meeting, and add it to the answer.The complexity of this solution is . We can reduce it using two pointers method.Problem B. Context AdvertisingWe were asked to find the maximal number of words we can fit into the block of size r × c. Let's first solve such problem: what is the maximal number of consecutive words which can fit in a row of lenth c, if the first word has index i. We can solve it using binary search or moving the pointer. Now let us build a graph, where vertices are the words and there is a directional edge between i and j, if words from i to j - 1 fit in one row of length c, but words from i to j don't. The weight of the edge is j - i. The we have the following problem: we need to find the path of length k, which has the maximal weight. Easy to solve it with complexity saving weights of all the paths with lengthes equal to the powers of two, or in O(n) time using dfs.The other problems competitors faced — that we were asked to print the whole text, not only the length.Problem C. Memory for ArraysWe were asked to find the maximal number of arrays we can fit into the memory. A small observation first, let the answer be k, then one of the optimal solutions fits the k smallest arrays into the memory. We can assume that we have arrays of size 1 and we want to arrange the memory for the maximal arrays as possible. Then if we have parts of memory of odd size, if we fit array of size 1 at this part we will obtain part of even size. From other hand, if we put arrays of bigger size we will not change the parity and if we don't fill it with arrays of size one and initially it's of odd size then in the end we will have at least one empty cell. So it's reasonable to put the arrays of size one into the memory of odd size. Let's do it until we can do it. We have three possible situations: We don't have memory parts of odd size anymore. We don't have arrays of size 1 anymore. We don't have neither arrays of size 1 neither memory parts of size 1. Let us start from the first case. Suppose that there are some arrays of size 1 left, but there are no memory parts of odd size. Easy to see then in such case we need to group arrays of size 1 in pairs and then consider them as the same array. So we can divide every number by two and reduce the problem to the initial one.In the second case if we divide every number by two we will obtain the same problem (and that cannot increase the answer).The third case is similar to the second one.When implementing this we need to remember that first we have to fill the memory with arrays which are build from the maximal numbers of initial arrays.The complexity of the given algorithm is .Problem D. Tennis RacketsWe were asked to find the number of obtuse triangles which satisfy the problem statement. Author's solution has complexity O(n2), but it has some optimizations, so it easily works under the TL.Every triangle has only one obtuse angle. Due to symmetry reasons we can fix one of the sides and assume that obtuse angle is tangent to this side. Then we only need to find the number of such triangles and multiple the answer by 3.Every side is also symmetric, so we can consider only one half of it and then multiple the answer by 2.Let us assume that vertex A of the triangle has coordinates (0,0). Vertex B (0,) and C(2,0). Then we can find the coordinates of every single point at each of the sides and apply cosine theorem. We obtain the inequality which guarantee us that the triangle is obtuse. It can be written in many ways, on of them is following: If 1 ≤ i, j, k ≤ n — indices of points which are fixed at each of the sides, then triangle is obtuse iff: f(i, j, k) = 2i2 - i(n + 1) + 2j(n + 1) - ij - k(i + j) < 0. We can see that monotonically increases, so we can use moving pointer method applied to variable k. Then just go over all i from m + 1 to , then j from m + 1 till upper bound for k is less than or equal to n - m + 1 and just sum the results.We should mention that all of the operations have to be done in int type, it significantly increases the speed.Problem E. SheepAuthor's supposed greedy algorithm as a solution for this problem. Let us follow this algorithm. Let us create to label for every interval Positionv and MaximalPositionv.Positionv — stands for position of v in the required permutation.MaximalPositionv — stands for maximal possible position of v in the particular moment of the algorithm.Also let's consider count as a counter with initial value of 0 and set of unprocessed vertices S. The algorithm is following. Using binary search we find the maximal possible distance between the farthest sheep. And then check whether exists the permutation with maximal distance no more than K. Sort all the intervals in the increasing order of ri. Positioni = 0, 1 ≤ i ≤ n, MaximalPositioni = n, 1 ≤ i ≤ n, current = 1, count = 0. Do count = count + 1, Positioncurrent = count, erase current from S, if S — is empty, required permutation has been found. Look at every interval connected to current, and update MaximalPositionv = min(MaximalPositionv, Positioncurrent + K) Build sets S(count, j) = {v|MaximalPositionv ≤ count + j}. If for every j ≥ K - count + 1 holds |S(count, j)| ≤ j go to the step 7, otherwise there is no such permutation. Choose the minimal j such that |S(count, j)| = j. Choose from it the interval with the smallest ri and consider it as a new value for current, go to the step 4. First let us discuss the complexity. Let us fix K (in total there are iterations with fixed K).Every step from 4 to 7 will be done at most n times (every time size of S decreases by one). Every step can be implemented in O(n) time. The most difficult one — step 6. But we can see that it's not necessary to actually build the sets, all we need to know — their sizes. This can be done in linear time just counting the number of intervals that MaximalPositionv = i. Let if be Ci — then size of S(count, j) equals to C1 + C2 + ... + Ccount + j, which can be easily calculated with partial sums.Now let us discuss why this algorithm works. If we have Position labels for every interval — we obviously have the solution. Now let us assume that we ended up earlier. Then we will show that there is no such permutation. If algorithm ended, it means that for some count (consider the smallest such count), exists j0, that |S(count, j0)| > j0 at this step. Then |S(count, k)| > k. Let us prove that from contradiction. From the definition of count we have |S(count - 1, j)| ≤ j for every j ≥ k - count + 2. Then |S(count, j)| = |S(count - 1, j + 1)| - 1 ≤ j for every j ≤ k - 1. And S(count, j) = S(count, k) for k ≤ j < n - count = |S(count, j)| = |S(count, k)| ≤ j. Finally |S(count, n - count)| = n - count. Then |S(count, j)| ≤ j for every j, so we obtain contradiction. That means if algorithm stops at step 6 we have |S(count, k)| > k. So exist at least k + 1 interval, which still don't have assigned label Position and they should be assigned after count. So one of the intervals in S(count, k) has to have the value of Position at least count + k + 1. But every intervals in S(count, k) connected to at least one interval with Position ≤ count. So, we obtain that there is now such permutation.Editorial was prepared by sdya and Seyaua.",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/7749",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 9178
        }
      ],
      "code_examples": [
        {
          "title": "Croc Champ 2013 — Finals - Codeforces - Code 1",
          "code": "cin.sync_with_stdio(false);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7693",
          "author": "MikeMirzayanov"
        },
        {
          "title": "Croc Champ 2013 — Finals - Codeforces - Code 2",
          "code": "2 3\n4 6\n0 2 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7693",
          "author": "MikeMirzayanov"
        },
        {
          "title": "Croc Champ 2013 — Finals - Codeforces - Code 3",
          "code": "2 3\n4 6\n0 2 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7693",
          "author": "MikeMirzayanov"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    // Read n, l, t from the first line\n    int n = inf.readInt(1, 1000000, \"n\");\n    inf.readSpace();\n    int l = inf.readInt(1, 1000000000, \"l\");\n    inf.readSpace();\n    int t = inf.readInt(1, 1000000000, \"t\");\n    inf.readEoln();\n\n    // Read the starting positions a_i\n    int prev_a = inf.readInt(0, l - 1, \"a1\"); // Read the first a1\n\n    for (int i = 1; i < n; ++i) {\n        inf.readSpace(); // Expect a space between numbers\n        int a_i = inf.readInt(0, l - 1); // Read the next a_i\n\n        // Ensure that a_i > prev_a\n        ensuref(a_i > prev_a,\n            \"a[%d]=%d is not greater than previous a[%d]=%d\",\n            i + 1, a_i, i, prev_a);\n\n        prev_a = a_i; // Update prev_a for the next iteration\n    }\n    inf.readEoln(); // Ensure the line ends after reading all a_i\n\n    // Ensure there is nothing more in the input\n    inf.readEof();\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    // Read n, l, t from the first line\n    int n = inf.readInt(1, 1000000, \"n\");\n    inf.readSpace();\n    int l = inf.readInt(1, 1000000000, \"l\");\n    inf.readSpace();\n    int t = inf.readInt(1, 1000000000, \"t\");\n    inf.readEoln();\n\n    // Read the starting positions a_i\n    int prev_a = inf.readInt(0, l - 1, \"a1\"); // Read the first a1\n\n    for (int i = 1; i < n; ++i) {\n        inf.readSpace(); // Expect a space between numbers\n        int a_i = inf.readInt(0, l - 1); // Read the next a_i\n\n        // Ensure that a_i > prev_a\n        ensuref(a_i > prev_a,\n            \"a[%d]=%d is not greater than previous a[%d]=%d\",\n            i + 1, a_i, i, prev_a);\n\n        prev_a = a_i; // Update prev_a for the next iteration\n    }\n    inf.readEoln(); // Ensure the line ends after reading all a_i\n\n    // Ensure there is nothing more in the input\n    inf.readEof();\n\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    // Read n, l, t from the first line\n    int n = inf.readInt(1, 1000000, \"n\");\n    inf.readSpace();\n    int l = inf.readInt(1, 1000000000, \"l\");\n    inf.readSpace();\n    int t = inf.readInt(1, 1000000000, \"t\");\n    inf.readEoln();\n\n    // Read the starting positions a_i\n    int prev_a = inf.readInt(0, l - 1, \"a1\"); // Read the first a1\n\n    for (int i = 1; i < n; ++i) {\n        inf.readSpace(); // Expect a space between numbers\n        int a_i = inf.readInt(0, l - 1); // Read the next a_i\n\n        // Ensure that a_i > prev_a\n        ensuref(a_i > prev_a,\n            \"a[%d]=%d is not greater than previous a[%d]=%d\",\n            i + 1, a_i, i, prev_a);\n\n        prev_a = a_i; // Update prev_a for the next iteration\n    }\n    inf.readEoln(); // Ensure the line ends after reading all a_i\n\n    // Ensure there is nothing more in the input\n    inf.readEof();\n\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nconst double EPS = 1E-6;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare two sequences of doubles, max absolute or relative  error = %.7f\", EPS);\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    double j = 0, p = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        n++;\r\n        j = ans.readDouble();\r\n        p = ouf.readDouble();\r\n        if (!doubleCompare(j, p, EPS)) {\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%.7f', found: '%.7f', error = '%.7f'\",\r\n                  n, englishEnding(n).c_str(), j, p, doubleDelta(j, p));\r\n        }\r\n    }\r\n\r\n    if (n == 1)\r\n        quitf(_ok, \"found '%.7f', expected '%.7f', error '%.7f'\", p, j, doubleDelta(j, p));\r\n\r\n    quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    // Read parameters\n    int n = opt<int>(\"n\");\n    int l = opt<int>(\"l\");\n    int t = opt<int>(\"t\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> positions;\n\n    if (type == \"min_n\") {\n        // n is minimum\n        n = 1;\n        positions.push_back(0);\n    } else if (type == \"max_n\") {\n        // n is maximum\n        n = 1000000;\n        positions.resize(n);\n        for (int i = 0; i < n; ++i) {\n            positions[i] = (long long)i * (l - 1) / (n - 1);\n        }\n    } else if (type == \"equal_spacing\") {\n        // Positions are equally spaced\n        positions.resize(n);\n        for (int i = 0; i < n; ++i) {\n            positions[i] = (long long)i * l / n;\n            if (positions[i] >= l) positions[i] = l - 1;\n        }\n    } else if (type == \"clustered\") {\n        // Positions are clustered\n        int clusters = opt<int>(\"clusters\", 10);\n        int cluster_size = n / clusters;\n        int remaining = n % clusters;\n        positions.resize(n);\n        int idx = 0;\n        int pos = 0;\n        for (int c = 0; c < clusters; ++c) {\n            for (int i = 0; i < cluster_size; ++i) {\n                positions[idx++] = pos;\n                pos++;\n            }\n            pos += l / clusters;\n        }\n        // Any remaining positions\n        while (idx < n) {\n            positions[idx++] = pos++;\n        }\n        // Ensure positions are within [0, l -1]\n        for (int i = 0; i < n; ++i) {\n            if (positions[i] >= l) {\n                positions[i] = l - 1;\n            }\n        }\n        // Remove duplicates if any and sort\n        sort(positions.begin(), positions.end());\n        positions.erase(unique(positions.begin(), positions.end()), positions.end());\n        n = positions.size();\n    } else if (type == \"close_positions\") {\n        // Positions are very close to each other\n        positions.resize(n);\n        for (int i = 0; i < n; ++i) {\n            positions[i] = i;\n        }\n    } else if (type == \"far_positions\") {\n        // Positions are as far apart as possible\n        positions.resize(n);\n        for (int i = 0; i < n; ++i) {\n            positions[i] = (long long)i * (l - 1) / (n - 1);\n        }\n    } else if (type == \"near_zero\") {\n        // Positions are near zero\n        positions.resize(n);\n        for (int i = 0; i < n; ++i) {\n            positions[i] = i;\n        }\n    } else if (type == \"near_l\") {\n        // Positions are near l - 1\n        positions.resize(n);\n        for (int i = 0; i < n; ++i) {\n            positions[i] = l - n + i;\n            if (positions[i] >= l) positions[i] = l - 1;\n        }\n    } else {\n        // Default: random positions\n        set<int> pos_set;\n        while ((int)pos_set.size() < n) {\n            int pos = rnd.next(0, l - 1);\n            pos_set.insert(pos);\n        }\n        positions.assign(pos_set.begin(), pos_set.end());\n    }\n\n    // Ensure positions are sorted and distinct\n    sort(positions.begin(), positions.end());\n    n = positions.size();\n\n    // Output\n    printf(\"%d %d %d\\n\", n, l, t);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d\", positions[i]);\n        if (i < n - 1) printf(\" \");\n    }\n    printf(\"\\n\");\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    // Read parameters\n    int n = opt<int>(\"n\");\n    int l = opt<int>(\"l\");\n    int t = opt<int>(\"t\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> positions;\n\n    if (type == \"min_n\") {\n        // n is minimum\n        n = 1;\n        positions.push_back(0);\n    } else if (type == \"max_n\") {\n        // n is maximum\n        n = 1000000;\n        positions.resize(n);\n        for (int i = 0; i < n; ++i) {\n            positions[i] = (long long)i * (l - 1) / (n - 1);\n        }\n    } else if (type == \"equal_spacing\") {\n        // Positions are equally spaced\n        positions.resize(n);\n        for (int i = 0; i < n; ++i) {\n            positions[i] = (long long)i * l / n;\n            if (positions[i] >= l) positions[i] = l - 1;\n        }\n    } else if (type == \"clustered\") {\n        // Positions are clustered\n        int clusters = opt<int>(\"clusters\", 10);\n        int cluster_size = n / clusters;\n        int remaining = n % clusters;\n        positions.resize(n);\n        int idx = 0;\n        int pos = 0;\n        for (int c = 0; c < clusters; ++c) {\n            for (int i = 0; i < cluster_size; ++i) {\n                positions[idx++] = pos;\n                pos++;\n            }\n            pos += l / clusters;\n        }\n        // Any remaining positions\n        while (idx < n) {\n            positions[idx++] = pos++;\n        }\n        // Ensure positions are within [0, l -1]\n        for (int i = 0; i < n; ++i) {\n            if (positions[i] >= l) {\n                positions[i] = l - 1;\n            }\n        }\n        // Remove duplicates if any and sort\n        sort(positions.begin(), positions.end());\n        positions.erase(unique(positions.begin(), positions.end()), positions.end());\n        n = positions.size();\n    } else if (type == \"close_positions\") {\n        // Positions are very close to each other\n        positions.resize(n);\n        for (int i = 0; i < n; ++i) {\n            positions[i] = i;\n        }\n    } else if (type == \"far_positions\") {\n        // Positions are as far apart as possible\n        positions.resize(n);\n        for (int i = 0; i < n; ++i) {\n            positions[i] = (long long)i * (l - 1) / (n - 1);\n        }\n    } else if (type == \"near_zero\") {\n        // Positions are near zero\n        positions.resize(n);\n        for (int i = 0; i < n; ++i) {\n            positions[i] = i;\n        }\n    } else if (type == \"near_l\") {\n        // Positions are near l - 1\n        positions.resize(n);\n        for (int i = 0; i < n; ++i) {\n            positions[i] = l - n + i;\n            if (positions[i] >= l) positions[i] = l - 1;\n        }\n    } else {\n        // Default: random positions\n        set<int> pos_set;\n        while ((int)pos_set.size() < n) {\n            int pos = rnd.next(0, l - 1);\n            pos_set.insert(pos);\n        }\n        positions.assign(pos_set.begin(), pos_set.end());\n    }\n\n    // Ensure positions are sorted and distinct\n    sort(positions.begin(), positions.end());\n    n = positions.size();\n\n    // Output\n    printf(\"%d %d %d\\n\", n, l, t);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d\", positions[i]);\n        if (i < n - 1) printf(\" \");\n    }\n    printf(\"\\n\");\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Test case with minimum n\n./gen -n 1 -l 1 -t 1 -type min_n\n./gen -n 1 -l 10 -t 1 -type min_n\n./gen -n 1 -l 1000000000 -t 1000000000 -type min_n\n\n# Test cases with small n and close positions\n./gen -n 2 -l 10 -t 5 -type close_positions\n./gen -n 5 -l 100 -t 10 -type close_positions\n\n# Test case with maximum n\n./gen -n 1000000 -l 1000000000 -t 1000000000 -type max_n\n\n# Test cases with equally spaced positions\n./gen -n 10 -l 100 -t 10 -type equal_spacing\n./gen -n 1000 -l 1000 -t 500 -type equal_spacing\n./gen -n 100000 -l 1000000 -t 1000000 -type equal_spacing\n\n# Random test cases with varying parameters\n./gen -n 100000 -l 1000000000 -t 1000000000 -type random\n./gen -n 10 -l 50 -t 25 -type random\n./gen -n 500000 -l 1000000000 -t 1 -type random\n\n# Test cases with close positions and maximum n\n./gen -n 1000000 -l 1000000000 -t 1 -type close_positions\n./gen -n 1000000 -l 1000000000 -t 1000000000 -type close_positions\n\n# Test cases with far positions\n./gen -n 1000000 -l 1000000000 -t 1000000000 -type far_positions\n\n# Clustered positions with varying cluster counts\n./gen -n 100 -l 1000 -t 1000000000 -type clustered -clusters 2\n./gen -n 100 -l 1000 -t 1000000000 -type clustered -clusters 10\n./gen -n 1000 -l 1000 -t 1000000000 -type clustered -clusters 50\n./gen -n 1000000 -l 1000000000 -t 1000000000 -type clustered -clusters 100\n./gen -n 1000000 -l 1000000000 -t 10 -type clustered -clusters 1000\n\n# Test cases with positions near zero\n./gen -n 1000000 -l 1000000000 -t 1000000000 -type near_zero\n\n# Test cases with positions near l - 1\n./gen -n 1000000 -l 1000000000 -t 1000000000 -type near_l\n\n# Random small test cases\n./gen -n 10 -l 10 -t 1000000000 -type random\n./gen -n 10 -l 1000000000 -t 1 -type random\n./gen -n 10 -l 1000000000 -t 1000000000 -type random\n\n# Test cases with small l\n./gen -n 1000000 -l 2 -t 1 -type close_positions\n\n# Test cases with t = 0\n./gen -n 100000 -l 1000000000 -t 0 -type random\n\n# Test cases with maximum t\n./gen -n 100000 -l 1000000000 -t 1000000000 -type random\n\n# Edge cases with large n and small t\n./gen -n 1000000 -l 1000000000 -t 1 -type near_zero\n./gen -n 1000000 -l 1000000000 -t 1 -type near_l\n\n# More clustered test cases\n./gen -n 500000 -l 500000000 -t 500000000 -type clustered -clusters 500\n\n# Test cases with varying l and t\n./gen -n 1000000 -l 999999937 -t 999999937 -type random\n./gen -n 999999 -l 1000000000 -t 123456789 -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:05:59.719050",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "309/B",
      "title": "B. Context Advertising",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first input line contains three integers n, r, c (1 ≤ n, r, c ≤ 106; r × c ≤ 106). The next line contains a text, consisting of n words. The words consist only of lowercase English letters and are not empty. The words in the lines are separated by single spaces. The total number of characters in all words doesn't exceed 5·106.",
      "output_spec": "OutputPrint at most r lines, in each line print at most c characters — the optimal advertisement banner. If there are multiple advertisement banners, print any of them. Note that some lines of the banner can be empty. You are allowed not to print such lines.",
      "sample_tests": "ExamplesInputCopy9 4 12this is a sample text for croc final roundOutputCopythis is asample textfor crocfinal roundInputCopy9 1 9this is a sample text for croc final roundOutputCopythis is aInputCopy6 2 3croc a a a croc aOutputCopya aaInputCopy2 2 5first secondOutputCopyfirst",
      "description": "B. Context Advertising\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first input line contains three integers n, r, c (1 ≤ n, r, c ≤ 106; r × c ≤ 106). The next line contains a text, consisting of n words. The words consist only of lowercase English letters and are not empty. The words in the lines are separated by single spaces. The total number of characters in all words doesn't exceed 5·106.\n\nOutputPrint at most r lines, in each line print at most c characters — the optimal advertisement banner. If there are multiple advertisement banners, print any of them. Note that some lines of the banner can be empty. You are allowed not to print such lines.\n\nInputCopy9 4 12this is a sample text for croc final roundOutputCopythis is asample textfor crocfinal roundInputCopy9 1 9this is a sample text for croc final roundOutputCopythis is aInputCopy6 2 3croc a a a croc aOutputCopya aaInputCopy2 2 5first secondOutputCopyfirst\n\nInputCopy9 4 12this is a sample text for croc final round\n\nOutputCopythis is asample textfor crocfinal round\n\nInputCopy9 1 9this is a sample text for croc final round\n\nOutputCopythis is a\n\nInputCopy6 2 3croc a a a croc a\n\nOutputCopya aa\n\nInputCopy2 2 5first second\n\nOutputCopyfirst",
      "solutions": [
        {
          "title": "Croc Champ 2013 — Finals - Codeforces",
          "content": "Today it will be Croc Champ 2013 Finals! Good luck to all participants. And to those who don't participate — enjoy the interesting competition.Yesterday have finished the trial contest and Code Game Challenge. The winner of Code Game Challenge is ... tourist!Also pay attention to the Croc Champ 2013 - Finals (online version, Div. 1). It will be a rated round. Note: it will be slightly unsual because we will not hide the standings of the official contest. So some information about difficulties of the problems will be known before the round. The contest duration is 2.5 hours.Good luck to everyone!The contest has been finished. The winners are: tourist Egor eatmore Final standings",
          "author": "MikeMirzayanov",
          "url": "https://codeforces.com/blog/entry/7693",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 686
        },
        {
          "title": "Croc Champ 2013 — Final Round — Editorial - Codeforces",
          "content": "Problem A. Morning runWe were asked to find the expected value of meetings between the runners. How to do that? As the first step, expected value is lineal, so we can split the initial problems into the different ones: find the expected value of meetings between the fixed pair of runners. We will solve these problems. To do that we need to make some observations: Let x be the distance between the two runners and they run face to face for infinite amount of time (probability of that obviously equals to 0.5·0.5 = 0.25). Then the first meeting will happen at time , the next one — , the next — and so on. Let us assume that every run ran for l time units. Then if two runners meet — they meet exactly two times. The probability of the meeting equals to 0.5, because in two cases they run in the same direction and in two cases in the different ones. We will build our solution based on these two observations. As the first step let us represent t as t = k·l + p, where 0 ≤ p < l. Then each runner will run k full laps. What does that mean? Because we have pairs of runners, then in those k laps each pair will have 2k meetings with probability equals to 0.5. So, we need to add to the answer.Now we need to take into account p seconds of running. Let us assume that the distance between two runners is x and they run towards each other. Then they will meet if , or x ≤ 2t. They will meet once more if , ir x ≤ 2t - l. They cannot meet more than twice, because p < l.Let us fix one of the runners, then using binary search we can find all other runners at distance no more than x from the fixed one. Let us choose x as x = 2t, and then the number of runners at the distance no more than x stands for the number of runners which meet with the fixed one at least once. If x = 2t - l, we will find the number of runners which meet with the fixed one exactly two times. Multiplying these numbers by 0.25 — probability of the meeting, and add it to the answer.The complexity of this solution is . We can reduce it using two pointers method.Problem B. Context AdvertisingWe were asked to find the maximal number of words we can fit into the block of size r × c. Let's first solve such problem: what is the maximal number of consecutive words which can fit in a row of lenth c, if the first word has index i. We can solve it using binary search or moving the pointer. Now let us build a graph, where vertices are the words and there is a directional edge between i and j, if words from i to j - 1 fit in one row of length c, but words from i to j don't. The weight of the edge is j - i. The we have the following problem: we need to find the path of length k, which has the maximal weight. Easy to solve it with complexity saving weights of all the paths with lengthes equal to the powers of two, or in O(n) time using dfs.The other problems competitors faced — that we were asked to print the whole text, not only the length.Problem C. Memory for ArraysWe were asked to find the maximal number of arrays we can fit into the memory. A small observation first, let the answer be k, then one of the optimal solutions fits the k smallest arrays into the memory. We can assume that we have arrays of size 1 and we want to arrange the memory for the maximal arrays as possible. Then if we have parts of memory of odd size, if we fit array of size 1 at this part we will obtain part of even size. From other hand, if we put arrays of bigger size we will not change the parity and if we don't fill it with arrays of size one and initially it's of odd size then in the end we will have at least one empty cell. So it's reasonable to put the arrays of size one into the memory of odd size. Let's do it until we can do it. We have three possible situations: We don't have memory parts of odd size anymore. We don't have arrays of size 1 anymore. We don't have neither arrays of size 1 neither memory parts of size 1. Let us start from the first case. Suppose that there are some arrays of size 1 left, but there are no memory parts of odd size. Easy to see then in such case we need to group arrays of size 1 in pairs and then consider them as the same array. So we can divide every number by two and reduce the problem to the initial one.In the second case if we divide every number by two we will obtain the same problem (and that cannot increase the answer).The third case is similar to the second one.When implementing this we need to remember that first we have to fill the memory with arrays which are build from the maximal numbers of initial arrays.The complexity of the given algorithm is .Problem D. Tennis RacketsWe were asked to find the number of obtuse triangles which satisfy the problem statement. Author's solution has complexity O(n2), but it has some optimizations, so it easily works under the TL.Every triangle has only one obtuse angle. Due to symmetry reasons we can fix one of the sides and assume that obtuse angle is tangent to this side. Then we only need to find the number of such triangles and multiple the answer by 3.Every side is also symmetric, so we can consider only one half of it and then multiple the answer by 2.Let us assume that vertex A of the triangle has coordinates (0,0). Vertex B (0,) and C(2,0). Then we can find the coordinates of every single point at each of the sides and apply cosine theorem. We obtain the inequality which guarantee us that the triangle is obtuse. It can be written in many ways, on of them is following: If 1 ≤ i, j, k ≤ n — indices of points which are fixed at each of the sides, then triangle is obtuse iff: f(i, j, k) = 2i2 - i(n + 1) + 2j(n + 1) - ij - k(i + j) < 0. We can see that monotonically increases, so we can use moving pointer method applied to variable k. Then just go over all i from m + 1 to , then j from m + 1 till upper bound for k is less than or equal to n - m + 1 and just sum the results.We should mention that all of the operations have to be done in int type, it significantly increases the speed.Problem E. SheepAuthor's supposed greedy algorithm as a solution for this problem. Let us follow this algorithm. Let us create to label for every interval Positionv and MaximalPositionv.Positionv — stands for position of v in the required permutation.MaximalPositionv — stands for maximal possible position of v in the particular moment of the algorithm.Also let's consider count as a counter with initial value of 0 and set of unprocessed vertices S. The algorithm is following. Using binary search we find the maximal possible distance between the farthest sheep. And then check whether exists the permutation with maximal distance no more than K. Sort all the intervals in the increasing order of ri. Positioni = 0, 1 ≤ i ≤ n, MaximalPositioni = n, 1 ≤ i ≤ n, current = 1, count = 0. Do count = count + 1, Positioncurrent = count, erase current from S, if S — is empty, required permutation has been found. Look at every interval connected to current, and update MaximalPositionv = min(MaximalPositionv, Positioncurrent + K) Build sets S(count, j) = {v|MaximalPositionv ≤ count + j}. If for every j ≥ K - count + 1 holds |S(count, j)| ≤ j go to the step 7, otherwise there is no such permutation. Choose the minimal j such that |S(count, j)| = j. Choose from it the interval with the smallest ri and consider it as a new value for current, go to the step 4. First let us discuss the complexity. Let us fix K (in total there are iterations with fixed K).Every step from 4 to 7 will be done at most n times (every time size of S decreases by one). Every step can be implemented in O(n) time. The most difficult one — step 6. But we can see that it's not necessary to actually build the sets, all we need to know — their sizes. This can be done in linear time just counting the number of intervals that MaximalPositionv = i. Let if be Ci — then size of S(count, j) equals to C1 + C2 + ... + Ccount + j, which can be easily calculated with partial sums.Now let us discuss why this algorithm works. If we have Position labels for every interval — we obviously have the solution. Now let us assume that we ended up earlier. Then we will show that there is no such permutation. If algorithm ended, it means that for some count (consider the smallest such count), exists j0, that |S(count, j0)| > j0 at this step. Then |S(count, k)| > k. Let us prove that from contradiction. From the definition of count we have |S(count - 1, j)| ≤ j for every j ≥ k - count + 2. Then |S(count, j)| = |S(count - 1, j + 1)| - 1 ≤ j for every j ≤ k - 1. And S(count, j) = S(count, k) for k ≤ j < n - count = |S(count, j)| = |S(count, k)| ≤ j. Finally |S(count, n - count)| = n - count. Then |S(count, j)| ≤ j for every j, so we obtain contradiction. That means if algorithm stops at step 6 we have |S(count, k)| > k. So exist at least k + 1 interval, which still don't have assigned label Position and they should be assigned after count. So one of the intervals in S(count, k) has to have the value of Position at least count + k + 1. But every intervals in S(count, k) connected to at least one interval with Position ≤ count. So, we obtain that there is now such permutation.Editorial was prepared by sdya and Seyaua.",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/7749",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 9178
        }
      ],
      "code_examples": [
        {
          "title": "Croc Champ 2013 — Finals - Codeforces - Code 1",
          "code": "cin.sync_with_stdio(false);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7693",
          "author": "MikeMirzayanov"
        },
        {
          "title": "Croc Champ 2013 — Finals - Codeforces - Code 2",
          "code": "2 3\n4 6\n0 2 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7693",
          "author": "MikeMirzayanov"
        },
        {
          "title": "Croc Champ 2013 — Finals - Codeforces - Code 3",
          "code": "2 3\n4 6\n0 2 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7693",
          "author": "MikeMirzayanov"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 1000000, \"n\");\n    inf.readSpace();\n    int r = inf.readInt(1, 1000000, \"r\");\n    inf.readSpace();\n    int c = inf.readInt(1, 1000000, \"c\");\n    inf.readEoln();\n    ensuref(1LL * r * c <= 1000000LL, \"r * c must be ≤ 1e6, but r = %d, c = %d, product = %lld\", r, c, 1LL * r * c);\n\n    long long totalLength = 0;\n    for (int i = 0; i < n; i++) {\n        string word = inf.readToken(\"[a-z]+\", \"word\");\n        totalLength += word.length();\n        if (i != n - 1) {\n            inf.readChar(' ');\n        } else {\n            inf.readEoln();\n        }\n    }\n    ensuref(totalLength <= 5000000LL, \"Total number of characters in all words (%lld) must be ≤ 5e6\", totalLength);\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 1000000, \"n\");\n    inf.readSpace();\n    int r = inf.readInt(1, 1000000, \"r\");\n    inf.readSpace();\n    int c = inf.readInt(1, 1000000, \"c\");\n    inf.readEoln();\n    ensuref(1LL * r * c <= 1000000LL, \"r * c must be ≤ 1e6, but r = %d, c = %d, product = %lld\", r, c, 1LL * r * c);\n\n    long long totalLength = 0;\n    for (int i = 0; i < n; i++) {\n        string word = inf.readToken(\"[a-z]+\", \"word\");\n        totalLength += word.length();\n        if (i != n - 1) {\n            inf.readChar(' ');\n        } else {\n            inf.readEoln();\n        }\n    }\n    ensuref(totalLength <= 5000000LL, \"Total number of characters in all words (%lld) must be ≤ 5e6\", totalLength);\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 1000000, \"n\");\n    inf.readSpace();\n    int r = inf.readInt(1, 1000000, \"r\");\n    inf.readSpace();\n    int c = inf.readInt(1, 1000000, \"c\");\n    inf.readEoln();\n    ensuref(1LL * r * c <= 1000000LL, \"r * c must be ≤ 1e6, but r = %d, c = %d, product = %lld\", r, c, 1LL * r * c);\n\n    long long totalLength = 0;\n    for (int i = 0; i < n; i++) {\n        string word = inf.readToken(\"[a-z]+\", \"word\");\n        totalLength += word.length();\n        if (i != n - 1) {\n            inf.readChar(' ');\n        } else {\n            inf.readEoln();\n        }\n    }\n    ensuref(totalLength <= 5000000LL, \"Total number of characters in all words (%lld) must be ≤ 5e6\", totalLength);\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<string> text_words;\nint n, r, c;\n\nint readAns(InStream& stream) {\n    vector<string> ans_words; // the words from the answer\n    int num_lines = 0;\n    string line;\n    while (!stream.eof() && num_lines < r) {\n        line = stream.readLine();\n        num_lines++;\n\n        // Remove leading and trailing spaces\n        size_t start = line.find_first_not_of(\" \\t\");\n        size_t end = line.find_last_not_of(\" \\t\");\n\n        if (start == string::npos) {\n            // Line is empty or only spaces\n            line = \"\";\n        } else {\n            line = line.substr(start, end - start + 1);\n        }\n\n        // Now check length of line\n        if ((int)line.size() > c) {\n            stream.quitf(_wa, \"Line %d is longer than allowed (%d > %d)\", num_lines, (int)line.size(), c);\n        }\n\n        // Now extract words from line\n        // Split by spaces (multiple spaces allowed)\n        istringstream iss(line);\n        string word;\n        while (iss >> word) {\n            ans_words.push_back(word);\n        }\n    }\n\n    // Now we need to check that ans_words is a consecutive subsequence of text_words\n    int max_start = n - (int)ans_words.size();\n    bool found = false;\n    for (int start = 0; start <= max_start; ++start) {\n        bool match = true;\n        for (int i = 0; i < (int)ans_words.size(); ++i) {\n            if (ans_words[i] != text_words[start + i]) {\n                match = false;\n                break;\n            }\n        }\n        if (match) {\n            found = true;\n            break;\n        }\n    }\n\n    if (!found) {\n        stream.quitf(_wa, \"The words in the answer are not a consecutive subsequence of the original text\");\n    }\n\n    return (int)ans_words.size();\n}\n\nint main(int argc, char* argv[]) {\n    registerTestlibCmd(argc, argv);\n\n    // Read the input data\n    n = inf.readInt();\n    r = inf.readInt();\n    c = inf.readInt();\n\n    for (int i = 0; i < n; i++) {\n        string word = inf.readToken();\n        text_words.push_back(word);\n    }\n\n    // Read jury's answer\n    int jans = readAns(ans);\n\n    // Read contestant's answer and check validity\n    int pans = readAns(ouf);\n\n    if (pans < jans) {\n        quitf(_wa, \"Contestant's answer uses fewer words (%d) than expected (%d)\", pans, jans);\n    } else if (pans == jans) {\n        quitf(_ok, \"Expected number of words used: %d\", pans);\n    } else {\n        // Participant has a better answer\n        quitf(_fail, \"Participant's answer uses more words (%d) than jury's answer (%d)\", pans, jans);\n    }\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int r = opt<int>(\"r\");\n    int c = opt<int>(\"c\");\n    string word_length_type = opt<string>(\"word_length_type\", \"random\");\n    string word_content_type = opt<string>(\"word_content_type\", \"random\");\n\n    vector<string> words;\n    int total_length = 0;\n    int max_total_length = 5 * 1000000; // 5 million\n    int max_word_length = c;\n\n    for (int i = 0; i < n; ++i) {\n        int len;\n        if (word_length_type == \"min_length\") {\n            len = 1;\n        } else if (word_length_type == \"max_length\") {\n            len = c;\n        } else if (word_length_type == \"random_length\") {\n            len = rnd.next(1, c);\n        } else if (word_length_type == \"one_line\") {\n            len = rnd.next(max(1, c / 2), c);\n        } else if (word_length_type == \"varying_length\") {\n            len = rnd.next(1, c);\n        } else {\n            // Default to random length\n            len = rnd.next(1, c);\n        }\n\n        // Ensure len is between 1 and c\n        len = max(1, min(len, c));\n\n        // Generate word content based on word_content_type\n        string word = \"\";\n        if (word_content_type == \"same_word\") {\n            char ch = 'a';\n            word = string(len, ch);\n        } else if (word_content_type == \"random_letters\") {\n            for (int j = 0; j < len; ++j) {\n                word += (char)('a' + rnd.next(26));\n            }\n        } else if (word_content_type == \"palindrome\") {\n            string half = \"\";\n            for (int j = 0; j < (len + 1) / 2; ++j) {\n                half += (char)('a' + rnd.next(26));\n            }\n            word = half;\n            for (int j = len / 2 - 1; j >= 0; --j) {\n                word += half[j];\n            }\n        } else if (word_content_type == \"single_letter\") {\n            char ch = 'a' + rnd.next(26);\n            word = string(len, ch);\n        } else {\n            // Default to random letters\n            for (int j = 0; j < len; ++j) {\n                word += (char)('a' + rnd.next(26));\n            }\n        }\n\n        // Check total length including spaces\n        int additional_length = len + (i > 0 ? 1 : 0); // Include space if not the first word\n        if (total_length + additional_length > max_total_length) {\n            break; // Can't add more words without exceeding total length limit\n        }\n\n        words.push_back(word);\n        total_length += additional_length;\n    }\n\n    n = words.size();\n\n    printf(\"%d %d %d\\n\", n, r, c);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%s\", words[i].c_str());\n        if (i != n - 1) printf(\" \");\n    }\n    printf(\"\\n\");\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int r = opt<int>(\"r\");\n    int c = opt<int>(\"c\");\n    string word_length_type = opt<string>(\"word_length_type\", \"random\");\n    string word_content_type = opt<string>(\"word_content_type\", \"random\");\n\n    vector<string> words;\n    int total_length = 0;\n    int max_total_length = 5 * 1000000; // 5 million\n    int max_word_length = c;\n\n    for (int i = 0; i < n; ++i) {\n        int len;\n        if (word_length_type == \"min_length\") {\n            len = 1;\n        } else if (word_length_type == \"max_length\") {\n            len = c;\n        } else if (word_length_type == \"random_length\") {\n            len = rnd.next(1, c);\n        } else if (word_length_type == \"one_line\") {\n            len = rnd.next(max(1, c / 2), c);\n        } else if (word_length_type == \"varying_length\") {\n            len = rnd.next(1, c);\n        } else {\n            // Default to random length\n            len = rnd.next(1, c);\n        }\n\n        // Ensure len is between 1 and c\n        len = max(1, min(len, c));\n\n        // Generate word content based on word_content_type\n        string word = \"\";\n        if (word_content_type == \"same_word\") {\n            char ch = 'a';\n            word = string(len, ch);\n        } else if (word_content_type == \"random_letters\") {\n            for (int j = 0; j < len; ++j) {\n                word += (char)('a' + rnd.next(26));\n            }\n        } else if (word_content_type == \"palindrome\") {\n            string half = \"\";\n            for (int j = 0; j < (len + 1) / 2; ++j) {\n                half += (char)('a' + rnd.next(26));\n            }\n            word = half;\n            for (int j = len / 2 - 1; j >= 0; --j) {\n                word += half[j];\n            }\n        } else if (word_content_type == \"single_letter\") {\n            char ch = 'a' + rnd.next(26);\n            word = string(len, ch);\n        } else {\n            // Default to random letters\n            for (int j = 0; j < len; ++j) {\n                word += (char)('a' + rnd.next(26));\n            }\n        }\n\n        // Check total length including spaces\n        int additional_length = len + (i > 0 ? 1 : 0); // Include space if not the first word\n        if (total_length + additional_length > max_total_length) {\n            break; // Can't add more words without exceeding total length limit\n        }\n\n        words.push_back(word);\n        total_length += additional_length;\n    }\n\n    n = words.size();\n\n    printf(\"%d %d %d\\n\", n, r, c);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%s\", words[i].c_str());\n        if (i != n - 1) printf(\" \");\n    }\n    printf(\"\\n\");\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Minimal case\n./gen -n 1 -r 1 -c 1 -word_length_type min_length -word_content_type same_word\n\n# Maximal word length\n./gen -n 5 -r 1 -c 1000000 -word_length_type max_length -word_content_type random_letters\n\n# Maximum number of words with minimal length\n./gen -n 1000000 -r 1 -c 1 -word_length_type min_length -word_content_type same_word\n\n# Words fit in one line\n./gen -n 10000 -r 1000 -c 1000 -word_length_type one_line -word_content_type random_letters\n\n# Words of varying lengths from 1 to c\n./gen -n 100000 -r 1000 -c 1000 -word_length_type varying_length -word_content_type random_letters\n\n# Maximum r with c equal to 1\n./gen -n 1000000 -r 1000000 -c 1 -word_length_type min_length -word_content_type random_letters\n\n# Maximum c with minimal r\n./gen -n 5 -r 1 -c 1000000 -word_length_type max_length -word_content_type random_letters\n\n# Maximum n with moderate r and c\n./gen -n 1000000 -r 1000 -c 1000 -word_length_type random_length -word_content_type random_letters\n\n# All words are palindromes\n./gen -n 10000 -r 1000 -c 1000 -word_length_type varying_length -word_content_type palindrome\n\n# All words are the same single letter\n./gen -n 500000 -r 1000 -c 1000 -word_length_type varying_length -word_content_type single_letter\n\n# Words of minimal length with moderate c\n./gen -n 1000000 -r 1000 -c 1000 -word_length_type min_length -word_content_type same_word\n\n# Words of maximum length with moderate c\n./gen -n 5000 -r 1000 -c 1000 -word_length_type max_length -word_content_type random_letters\n\n# Words of length c - 1\n./gen -n 5000 -r 1000 -c 1000 -word_length_type max_length -word_content_type random_letters\n\n# Random word lengths with total length close to 5e6\n./gen -n 100000 -r 1000 -c 1000 -word_length_type random_length -word_content_type random_letters\n\n# Minimal n and maximal c\n./gen -n 1 -r 1 -c 1000000 -word_length_type max_length -word_content_type random_letters\n\n# Minimal r and c with moderate n\n./gen -n 100 -r 1 -c 1 -word_length_type min_length -word_content_type random_letters\n\n# Maximum r with small c\n./gen -n 1000000 -r 1000000 -c 1 -word_length_type min_length -word_content_type single_letter\n\n# Maximum c with small n\n./gen -n 5 -r 1 -c 1000000 -word_length_type max_length -word_content_type same_word\n\n# r × c equals 1e6\n./gen -n 1000 -r 1000 -c 1000 -word_length_type varying_length -word_content_type random_letters\n\n# n × average word length equals 5e6\n./gen -n 1000000 -r 1000 -c 1000 -word_length_type varying_length -word_content_type random_letters\n\n# Words of length equal to c\n./gen -n 5000 -r 1000 -c 1000 -word_length_type max_length -word_content_type random_letters\n\n# Words of length around c/2\n./gen -n 10000 -r 1000 -c 1000 -word_length_type one_line -word_content_type random_letters\n\n# Words with length c - 1\n./gen -n 10000 -r 1000 -c 1000 -word_length_type max_length -word_content_type random_letters\n\n# Words of lengths from c/2 to c\n./gen -n 10000 -r 1000 -c 1000 -word_length_type varying_length -word_content_type random_letters\n\n# Small c with moderate n and r\n./gen -n 100000 -r 10000 -c 10 -word_length_type min_length -word_content_type random_letters\n\n# Small r with moderate n and large c\n./gen -n 100000 -r 10 -c 100000 -word_length_type max_length -word_content_type random_letters\n\n# Moderate n, r, and c\n./gen -n 10000 -r 100 -c 1000 -word_length_type varying_length -word_content_type random_letters\n\n# Maximize total character count\n./gen -n 500000 -r 1000 -c 1000 -word_length_type varying_length -word_content_type random_letters\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:06:01.310037",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "309/C",
      "title": "C. Память для массивов",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест2 секунды",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеВ первой строке входных данных записано два целых числа n и m (1 ≤ n, m ≤ 106). В следующей строке записаны n целых чисел a1, a2, ..., an (1 ≤ ai ≤ 109). В следующей строке записаны m целых чисел b1, b2, ..., bm (1 ≤ 2bi ≤ 109).",
      "output_spec": "Выходные данныеВыведите единственное целое число — ответ на задачу.",
      "sample_tests": "ПримерыВходные данныеСкопировать5 38 4 3 2 23 2 2Выходные данныеСкопировать2Входные данныеСкопировать10 61 1 1 1 1 1 1 1 1 10 0 0 0 0 0Выходные данныеСкопировать6",
      "description": "C. Память для массивов\n\nограничение по времени на тест2 секунды\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвыводstdout\n\nВходные данныеВ первой строке входных данных записано два целых числа n и m (1 ≤ n, m ≤ 106). В следующей строке записаны n целых чисел a1, a2, ..., an (1 ≤ ai ≤ 109). В следующей строке записаны m целых чисел b1, b2, ..., bm (1 ≤ 2bi ≤ 109).\n\nВходные данные\n\nВыходные данныеВыведите единственное целое число — ответ на задачу.\n\nВыходные данные\n\nВходные данныеСкопировать5 38 4 3 2 23 2 2Выходные данныеСкопировать2Входные данныеСкопировать10 61 1 1 1 1 1 1 1 1 10 0 0 0 0 0Выходные данныеСкопировать6\n\nВходные данныеСкопировать5 38 4 3 2 23 2 2\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать2\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать10 61 1 1 1 1 1 1 1 1 10 0 0 0 0 0\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать6\n\nВыходные данныеСкопировать\n\nСкопировать\n\nПримечаниеВ первом примере даны участки памяти размерами 8, 4, 3, 2 и 2 и массивы размерами 8, 4, 4. Существует несколько способов получить ответ 2: можно разместить массив размера 8 на участке памяти размера 8, а один из массивов размера 4 на участке памяти размера 4, другой вариант — разместить два массива размера 4 на одном участке памяти размера 8.Во втором примере у нас дано 10 участков памяти размера 1 и 6 массивов размера 1. Мы можем выбрать любые 6 участков памяти и разместить в них все имеющиеся массивы.",
      "solutions": [
        {
          "title": "Чемпионат КРОК 2013 — Финал - Codeforces",
          "content": "Уже совсем скоро в офисе компании КРОК состоится финал чемпионата. Позади день с пробным туром и Code Game Challenge. В суровой борьбе убедительную победу в Code Game Challenge одержал tourist!Кроме того сегодня состоится онлайн-раунд по задачам финала, этот раунд начнется в 19:00 и будет идти 2.5 часа. По результатам раунда будет обновлен рейтинг. Обратите внимание, что к этому времени будут доступны результаты финала, так что участники онлайн-раунда будут лучше представлять предполагаемую сложность задач.Всем удачи!Соревнование закончено. Победителями стали: tourist Egor eatmore Полные результаты",
          "author": "MikeMirzayanov",
          "url": "https://codeforces.com/blog/entry/7693",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 605
        },
        {
          "title": "Чемпионат КРОК 2013 — Финальный раунд — Разбор - Codeforces",
          "content": "Задача A. Утренний бегВ задаче требовалось найти математическое ожидание количества встреч между бегунами. Как это делать? Для начала, вспомним, что математическое ожидание линейно, поэтому исходная задача эквивалентна следующей: найти сумму математического ожидания количества встреч между каждой парой бегунов. Будем решать задачу именно в этой формулировке. Сделаем несколько наблюдений: Пусть расстояние между двумя фиксированными бегунами ровно x и они бегут навстречу друг другу бесконечно (вероятность того, что они бегут навстречу, как нетрудно видеть, равняется 0.5·0.5 = 0.25). Тогда первая встреча произойдет в момент времени , следующая — , следующая — и так далее. Пусть каждый из бегунов бежал ровно l единиц времени. Тогда, если два бегуна встречаются, то они встречаются ровно 2 раза. Вероятность того, что два бегуна встретятся составляет 0.5, так как в двух случаях из четырех они бегут навстречу друг другу, а в оставшихся двух случаях бегут в одном направлении. На основании этих наблюдений будем строить решение. Для начала разобьем t как t = k·l + p, где 0 ≤ p < l. Тогда, каждый из бегунов пробежит ровно k полных кругов. Что это означает? Так как всего пар бегунов ровно , то за k кругов в каждой из пар с вероятностью 0.5 произойдет ровно 2k встреч. Значит, к ответу нужно добавить .Теперь как-то нужно обработать оставшиеся p секунд бега. Предположим, что расстояние между двумя бегунами ровно x и они бегут это расстояние навстречу друг другу. Тогда, между ними произойдет встреча, если , или x ≤ 2t. Между ними произойдет вторая встреча, если , или x ≤ 2t - l. Больше двух встреч произойти не может, так как p < l.Зафиксируем какого-нибудь бегуна, тогда с помощью двоичного поиска мы можем найти количество бегунов, которые находятся на расстоянии не более x от данного. Выберем границу x как x = 2t, и тогда количество бегунов на расстоянии не более x будет означать количество бегунов, которые встретятся с зафиксированным. Если же мы выберем x = 2t - l, то сможем найти количество бегунов, с которыми произойдет вторая встреча. Умножаем полученные количества на 0.25 — вероятность встречи бегунов, и добавляем к ответу.Сложность такого решения составляет . Ее можно улучшить, если вместо двоичного поиска использовать метод двух указателей.Задача B. Контекстная рекламаВ задаче требовалось найти максимальное количество слов, которое можно разместить в блоке размера r × c. Решим сначала следующую задачу: какое максимальное количество подряд идущих слов поместится в строке длины c, если первое слово имеет индекс i. Такую задачу можно решать двоичным поиском, или двигая указатель. Теперь создадим граф, где вершинами будут слова, а ориентированные ребра будут соединять вершины i и j, если слова с i по j - 1 помещаются в одну строку длины c, а слова с i по j уже не помещаются. Весом ребра будет величина j - i. Тогда исходную задачу можно переформулировать в терминах данного графа: требуется найти путь длины k, который имеет наибольший вес. Такую задачу можно решать со сложностью используя метод двоичного подъема, или за O(n) при помощи поиска в глубину.Сложности реализации были в том, что нужно было выводить не искомое максимальное количество слов, а полный текст, а так же в том, что требовалось работать со строками, а не с числами.Задача C. Память для массивовЗдесь нужно было найти максимальное количество массивов, которое можно разместить в имеющейся памяти. Для начала отметим следующее: пусть ответ на задачу — это число k, тогда одним из оптимальных решений будет размещение k самых маленьких по размеру массивов в памяти. Без ограничения общности, будем считать, что у нас есть массивы размера 1 и мы хотим их разместить, при этом, разместить их как можно больше. Тогда, если у нас есть участки памяти нечетного размера, то при размещении массива размера 1 на таком участке, мы получим участок памяти четного размера. С другой стороны, если размещать на участке массивы другого размера, то четность не поменяется, и если на участке не будет размещено ни одного массива размера 1, то в самом конце в нем будет хотя бы одна свободная ячейка. Значит, выгодно размещать массивы размера 1 на участках памяти нечетного размера. Сделаем это, пока можем. Возможны три ситуации: У нас закончились участки памяти нечетного размера. У нас закончились массивы размера 1. У нас закончились и участки памяти нечетного размера и массивы размера 1. Начнем с первого случая. Пусть у нас остались массивы размера 1, но не осталось участков памяти нечетного размера. В оптимальном решении выгодно продолжать размещать массивы размера 1. При этом, если мы разместим их в участках памяти четного размера, то мы поменяем четность размера участка памяти, а как написано выше, это может привести к тому, что в конце процесса хотя бы одна свободная ячейка на участке памяти. Из этого можно сделать вывод, что невыгодно размещать массивы размера 1 по одному на участок. Выгодно объединить их в массивы размера 2 и размещать вместе. Сделаем это. После этого, разделим все имеющиеся числа на 2 и придем к изначальной задаче.Во втором случае, если мы сразу разделим все имеющиеся числа целочисленно на 2, и решим изначальную задачу, то ответ мы не ухудшим.Третий случай аналогичен второму.Следует отметить, что после сведения задачи к аналогичной, нам требуется помнить, что всегда выгоднее размещать те массивы, которые были собраны из наибольшего количества массивов.Сложность данного решения составляет .Задача D. Теннисные ракеткиУчастникам требовалось найти количество тупоугольных треугольников на данных вершинах, удовлетворяющих некоторым условиям. Сразу отметим, что авторское решение имеет сложность O(n2), но имеет ряд оптимизаций, благодаря чему решение укладывается в TL с большим запасом.Каждый тупоугольный треугольник имеет ровно один тупой угол. В силу симметрии задачи без ограничения общности мы можем зафиксировать сторону и считать, что тупой угол прилегает к этой стороне. Тогда, нам нужно посчитать ответ лишь для одной стороны, а в конце умножить его на 3.Так как каждая сторона симметрична, то можем рассматривать лишь половину стороны, а после этого умножить ответ на 2.Введем координаты, так что вершина A треугольника имеет координаты (0,0). Вершина B (0,) и C(2,0). Тогда найдем координаты каждой из точек на сторонах и выпишем теорему косинусов. Получим некое соотношение, которое гарантирует нам, что треугольник будет тупоугольным. Один из возможных его видов таков: Если 1 ≤ i, j, k ≤ n — номера точек зафиксированных на сторонах, то треугольник тупоугольный тогда и только тогда, когда: f(i, j, k) = 2i2 - i(n + 1) + 2j(n + 1) - ij - k(i + j) < 0. Заметим, что возрастает, поэтому можем использовать метод двигающегося указателя для перебора k. Тогда просто переберем i от m + 1 до , затем j от m + 1 до тех пор, пока верхняя граница для k не превосходит n - m + 1 и будем суммировать результаты.Отметим, что все результаты нужно делать в типе int, что существенно ускоряет решение.Задача E. ОвечкиЭту задачу предлагается решать жадно. Будем следовать следующему алгоритму. Создадим для каждого отрезка 2 пометки Positionv и MaximalPositionv.Positionv — соответствует позиции v в искомой перестановке.MaximalPositionv — соответствует максимальной допустимой позиции v в текущий. момент.Пусть у нас также имеется счетчик count изначально равный 0 и множество необработанных вершин S. Будем действовать по следующему алгоритму. Двоичным поиском ищем минимальное возможное расстояние между самыми удаленными соединенными овцами. Для фиксированного расстояния K проверяем существует ли перестановка. Отсортируем все отрезки по возрастанию ri. Positioni = 0, 1 ≤ i ≤ n, MaximalPositioni = n, 1 ≤ i ≤ n, current = 1, count = 0. Выполнить count = count + 1, Positioncurrent = count, удаляем current из S, если S — пустое, то требуемая перестановка найдена. Перебираем все отрезки, которые соединены с current, и обновляем MaximalPositionv = min(MaximalPositionv, Positioncurrent + K) Строим множества S(count, j) = {v|MaximalPositionv ≤ count + j}. Если для всех j ≥ K - count + 1 выполнено |S(count, j)| ≤ j то переходим к шагу 7, иначе выводим, что искомой перестановки не существует. Ищем минимальное j такое что |S(count, j)| = j. Выбираем оттуда вершину с наименьшим ri и берем ее в качестве нового значения current, переходим к шагу 4. Сначала обоснуем время работы представленного алгоритма. Зафиксируем расстояние K (всего будет итераций с фиксированным K).Заметим, что шаги с 4 по 7 в худшем случае выполняются ровно n раз (каждый раз размер множества S уменьшается на 1). Каждый из шагов можно реализовать так, чтобы он выполнялся за O(n). Самый сложный шаг — это шаг 6. Но заметим, что нам не требуется явно строить эти множества, достаточно знать лишь их размеры. А это мы можем сделать за линейное время, просто посчитав сколько существует таких элементов, что MaximalPositionv = i. Обозначим это число через Ci — тогда размер множества S(count, j) равен C1 + C2 + ... + Ccount + j, что легко подсчитать при помощи массива частичных сумм.Обоснуем теперь корректность алгоритма. Если алгоритм расставил позиции для всех вершин, то очевидно, что имеет требуемую перестановку. Предположим, что алгоритм заканчивает свое выполнение до того, как мы расставили все позиции, покажем, что тогда не существует искомой перестановки. Есть алгоритм закончил свое выполнение, это означает, что для некоторого count (рассмотрим найменьшее такое count), что есть такое j0, что |S(count, j0)| > j0 на этом шаге. Покажем, что тогда |S(count, k)| > k. Докажем это от противного. Предположим, что это не так. Из определения count имеем |S(count - 1, j)| ≤ j для всех j ≥ k - count + 2. Тогда |S(count, j)| = |S(count - 1, j + 1)| - 1 ≤ j для всех j ≤ k - 1. При этом, S(count, j) = S(count, k) для k ≤ j < n - count = |S(count, j)| = |S(count, k)| ≤ j. В итоге |S(count, n - count)| = n - count. Тогда |S(count, j)| ≤ j для всех j, следовательно имеем противоречие. Значит, алгоритм преращает свою работу на шаге 6, |S(count, k)| > k. Это означает, что существует как минимум k + 1 вершина, которая до сих пор не имеет назначенной позиции после вершины, которая была отмечена как count. Значит, одна из вершин в S(count, k) должна быть с Position как минимум count + k + 1. Но все вершины в S(count, k) соединены с как минимум одной вeршиной с Position ≤ count. Следовательно, получаем, что искомомй перестановки не существует.Разбор задач был подготовлен sdya и Seyaua.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/7749",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 10415
        }
      ],
      "code_examples": [
        {
          "title": "Чемпионат КРОК 2013 — Финал - Codeforces - Code 1",
          "code": "cin.sync_with_stdio(false);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7693",
          "author": "MikeMirzayanov"
        },
        {
          "title": "Чемпионат КРОК 2013 — Финал - Codeforces - Code 2",
          "code": "2 3\n4 6\n0 2 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7693",
          "author": "MikeMirzayanov"
        },
        {
          "title": "Чемпионат КРОК 2013 — Финал - Codeforces - Code 3",
          "code": "2 3\n4 6\n0 2 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7693",
          "author": "MikeMirzayanov"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 1000000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 1000000, \"m\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, 1, 1000000000, \"a_i\");\n    inf.readEoln();\n\n    vector<int> b = inf.readInts(m, 1, 60, \"b_j\");\n    inf.readEoln();\n\n    for (int i = 0; i < m; i++) {\n        long long s = 1LL << b[i];\n        ensuref(s <= 1000000000LL, \"2^%d is %lld, which is greater than 1e9\", b[i], s);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 1000000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 1000000, \"m\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, 1, 1000000000, \"a_i\");\n    inf.readEoln();\n\n    vector<int> b = inf.readInts(m, 1, 60, \"b_j\");\n    inf.readEoln();\n\n    for (int i = 0; i < m; i++) {\n        long long s = 1LL << b[i];\n        ensuref(s <= 1000000000LL, \"2^%d is %lld, which is greater than 1e9\", b[i], s);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 1000000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 1000000, \"m\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, 1, 1000000000, \"a_i\");\n    inf.readEoln();\n\n    vector<int> b = inf.readInts(m, 1, 60, \"b_j\");\n    inf.readEoln();\n\n    for (int i = 0; i < m; i++) {\n        long long s = 1LL << b[i];\n        ensuref(s <= 1000000000LL, \"2^%d is %lld, which is greater than 1e9\", b[i], s);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> a(n);\n    vector<int> b(m);\n\n    if(type == \"max_sizes\") {\n        // Clusters and arrays have maximum sizes\n        for(int i = 0; i < n; ++i) {\n            a[i] = 1000000000;\n        }\n        for(int i = 0; i < m; ++i) {\n            b[i] = 29; // 2^29 = 536870912 ≤ 1e9\n        }\n    }\n    else if(type == \"min_sizes\") {\n        // Clusters and arrays have minimum sizes\n        for(int i = 0; i < n; ++i) {\n            a[i] = 1;\n        }\n        for(int i = 0; i < m; ++i) {\n            b[i] = 0; // 2^0 = 1\n        }\n    }\n    else if(type == \"clusters_large\") {\n        // Large clusters, small arrays\n        for(int i = 0; i < n; ++i) {\n            a[i] = 1000000000;\n        }\n        for(int i = 0; i < m; ++i) {\n            b[i] = rnd.next(0, 10); // Small arrays\n        }\n    }\n    else if(type == \"arrays_large\") {\n        // Small clusters, large arrays\n        for(int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, 10000); // Small clusters\n        }\n        for(int i = 0; i < m; ++i) {\n            b[i] = 29; // Large arrays\n        }\n    }\n    else if(type == \"clusters_equal\") {\n        // Clusters have equal sizes\n        int size = rnd.next(1, 1000000000);\n        for(int i = 0; i < n; ++i) {\n            a[i] = size;\n        }\n        for(int i = 0; i < m; ++i) {\n            b[i] = rnd.next(0, 29);\n        }\n    }\n    else if(type == \"arrays_equal\") {\n        // Arrays have equal sizes\n        for(int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, 1000000000);\n        }\n        int b_value = rnd.next(0, 29);\n        for(int i = 0; i < m; ++i) {\n            b[i] = b_value;\n        }\n    }\n    else if(type == \"clusters_min\") {\n        // Clusters have minimum sizes\n        for(int i = 0; i < n; ++i) {\n            a[i] = 1;\n        }\n        for(int i = 0; i < m; ++i) {\n            b[i] = rnd.next(0, 29);\n        }\n    }\n    else if(type == \"clusters_max\") {\n        // Clusters have maximum sizes\n        for(int i = 0; i < n; ++i) {\n            a[i] = 1000000000;\n        }\n        for(int i = 0; i < m; ++i) {\n            b[i] = rnd.next(0, 29);\n        }\n    }\n    else if(type == \"arrays_min\") {\n        // Arrays have minimum sizes\n        for(int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, 1000000000);\n        }\n        for(int i = 0; i < m; ++i) {\n            b[i] = 0;\n        }\n    }\n    else if(type == \"arrays_max\") {\n        // Arrays have maximum sizes\n        for(int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, 1000000000);\n        }\n        for(int i = 0; i < m; ++i) {\n            b[i] = 29;\n        }\n    }\n    else if(type == \"random\") {\n        // Completely random sizes\n        for(int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, 1000000000);\n        }\n        for(int i = 0; i < m; ++i) {\n            b[i] = rnd.next(0, 29);\n        }\n    }\n    else if(type == \"worst_case\") {\n        // Worst case scenario\n        for(int i = 0; i < n; ++i) {\n            a[i] = 1;\n        }\n        for(int i = 0; i < m; ++i) {\n            b[i] = 1;\n        }\n    }\n    else {\n        // Default case is random\n        for(int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, 1000000000);\n        }\n        for(int i = 0; i < m; ++i) {\n            b[i] = rnd.next(0, 29);\n        }\n    }\n\n    // Output n and m\n    printf(\"%d %d\\n\", n, m);\n    // Output the a_i\n    for(int i = 0; i < n; ++i) {\n        printf(\"%d%c\", a[i], i == n - 1 ? '\\n' : ' ');\n    }\n    // Output the b_j\n    for(int i = 0; i < m; ++i) {\n        printf(\"%d%c\", b[i], i == m - 1 ? '\\n' : ' ');\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> a(n);\n    vector<int> b(m);\n\n    if(type == \"max_sizes\") {\n        // Clusters and arrays have maximum sizes\n        for(int i = 0; i < n; ++i) {\n            a[i] = 1000000000;\n        }\n        for(int i = 0; i < m; ++i) {\n            b[i] = 29; // 2^29 = 536870912 ≤ 1e9\n        }\n    }\n    else if(type == \"min_sizes\") {\n        // Clusters and arrays have minimum sizes\n        for(int i = 0; i < n; ++i) {\n            a[i] = 1;\n        }\n        for(int i = 0; i < m; ++i) {\n            b[i] = 0; // 2^0 = 1\n        }\n    }\n    else if(type == \"clusters_large\") {\n        // Large clusters, small arrays\n        for(int i = 0; i < n; ++i) {\n            a[i] = 1000000000;\n        }\n        for(int i = 0; i < m; ++i) {\n            b[i] = rnd.next(0, 10); // Small arrays\n        }\n    }\n    else if(type == \"arrays_large\") {\n        // Small clusters, large arrays\n        for(int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, 10000); // Small clusters\n        }\n        for(int i = 0; i < m; ++i) {\n            b[i] = 29; // Large arrays\n        }\n    }\n    else if(type == \"clusters_equal\") {\n        // Clusters have equal sizes\n        int size = rnd.next(1, 1000000000);\n        for(int i = 0; i < n; ++i) {\n            a[i] = size;\n        }\n        for(int i = 0; i < m; ++i) {\n            b[i] = rnd.next(0, 29);\n        }\n    }\n    else if(type == \"arrays_equal\") {\n        // Arrays have equal sizes\n        for(int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, 1000000000);\n        }\n        int b_value = rnd.next(0, 29);\n        for(int i = 0; i < m; ++i) {\n            b[i] = b_value;\n        }\n    }\n    else if(type == \"clusters_min\") {\n        // Clusters have minimum sizes\n        for(int i = 0; i < n; ++i) {\n            a[i] = 1;\n        }\n        for(int i = 0; i < m; ++i) {\n            b[i] = rnd.next(0, 29);\n        }\n    }\n    else if(type == \"clusters_max\") {\n        // Clusters have maximum sizes\n        for(int i = 0; i < n; ++i) {\n            a[i] = 1000000000;\n        }\n        for(int i = 0; i < m; ++i) {\n            b[i] = rnd.next(0, 29);\n        }\n    }\n    else if(type == \"arrays_min\") {\n        // Arrays have minimum sizes\n        for(int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, 1000000000);\n        }\n        for(int i = 0; i < m; ++i) {\n            b[i] = 0;\n        }\n    }\n    else if(type == \"arrays_max\") {\n        // Arrays have maximum sizes\n        for(int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, 1000000000);\n        }\n        for(int i = 0; i < m; ++i) {\n            b[i] = 29;\n        }\n    }\n    else if(type == \"random\") {\n        // Completely random sizes\n        for(int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, 1000000000);\n        }\n        for(int i = 0; i < m; ++i) {\n            b[i] = rnd.next(0, 29);\n        }\n    }\n    else if(type == \"worst_case\") {\n        // Worst case scenario\n        for(int i = 0; i < n; ++i) {\n            a[i] = 1;\n        }\n        for(int i = 0; i < m; ++i) {\n            b[i] = 1;\n        }\n    }\n    else {\n        // Default case is random\n        for(int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, 1000000000);\n        }\n        for(int i = 0; i < m; ++i) {\n            b[i] = rnd.next(0, 29);\n        }\n    }\n\n    // Output n and m\n    printf(\"%d %d\\n\", n, m);\n    // Output the a_i\n    for(int i = 0; i < n; ++i) {\n        printf(\"%d%c\", a[i], i == n - 1 ? '\\n' : ' ');\n    }\n    // Output the b_j\n    for(int i = 0; i < m; ++i) {\n        printf(\"%d%c\", b[i], i == m - 1 ? '\\n' : ' ');\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -m 1 -type min_sizes\n./gen -n 1 -m 1 -type max_sizes\n\n./gen -n 5 -m 5 -type min_sizes\n./gen -n 5 -m 5 -type max_sizes\n\n./gen -n 10 -m 10 -type clusters_large\n./gen -n 10 -m 10 -type arrays_large\n\n./gen -n 50 -m 50 -type random\n./gen -n 500 -m 500 -type random\n./gen -n 5000 -m 5000 -type random\n./gen -n 50000 -m 50000 -type random\n\n./gen -n 1000 -m 1000 -type clusters_equal\n./gen -n 1000 -m 1000 -type arrays_equal\n\n./gen -n 100000 -m 100000 -type clusters_min\n./gen -n 100000 -m 100000 -type clusters_max\n\n./gen -n 1000000 -m 1000000 -type arrays_min\n./gen -n 1000000 -m 1000000 -type arrays_max\n\n./gen -n 1000000 -m 1000000 -type random\n\n./gen -n 1000000 -m 1000000 -type worst_case\n\n./gen -n 500000 -m 500000 -type clusters_large\n./gen -n 500000 -m 500000 -type arrays_large\n\n./gen -n 500000 -m 500000 -type clusters_equal\n./gen -n 500000 -m 500000 -type arrays_equal\n\n./gen -n 2 -m 1000000 -type clusters_large\n./gen -n 1000000 -m 2 -type arrays_large\n\n./gen -n 999999 -m 999999 -type random\n\n./gen -n 100 -m 1000000 -type arrays_min\n\n./gen -n 1000000 -m 1000000 -type clusters_min\n./gen -n 1000000 -m 1000000 -type clusters_max\n./gen -n 1 -m 1000000 -type clusters_large\n./gen -n 1000000 -m 1 -type arrays_large\n./gen -n 1000 -m 100000 -type clusters_large\n./gen -n 100000 -m 1000 -type arrays_large\n./gen -n 1000000 -m 1000000 -type arrays_equal\n./gen -n 1000000 -m 1000000 -type clusters_equal\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:06:03.123712",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "309/D",
      "title": "D. Tennis Rackets",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test3 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first and the only input line contains two integers n, m .",
      "output_spec": "OutputPrint a single number — the answer to the problem.",
      "sample_tests": "ExamplesInputCopy3 0OutputCopy9InputCopy4 0OutputCopy24InputCopy10 1OutputCopy210InputCopy8 4OutputCopy0",
      "description": "D. Tennis Rackets\n\ntime limit per test3 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first and the only input line contains two integers n, m .\n\nOutputPrint a single number — the answer to the problem.\n\nInputCopy3 0OutputCopy9InputCopy4 0OutputCopy24InputCopy10 1OutputCopy210InputCopy8 4OutputCopy0\n\nInputCopy3 0\n\nOutputCopy9\n\nInputCopy4 0\n\nOutputCopy24\n\nInputCopy10 1\n\nOutputCopy210\n\nInputCopy8 4\n\nOutputCopy0\n\nNoteFor the following picture n = 8, m = 2. White circles are the holes for ventilation, red circles — holes for net stretching. One of the possible obtuse triangles is painted red.",
      "solutions": [
        {
          "title": "Croc Champ 2013 — Finals - Codeforces",
          "content": "Today it will be Croc Champ 2013 Finals! Good luck to all participants. And to those who don't participate — enjoy the interesting competition.Yesterday have finished the trial contest and Code Game Challenge. The winner of Code Game Challenge is ... tourist!Also pay attention to the Croc Champ 2013 - Finals (online version, Div. 1). It will be a rated round. Note: it will be slightly unsual because we will not hide the standings of the official contest. So some information about difficulties of the problems will be known before the round. The contest duration is 2.5 hours.Good luck to everyone!The contest has been finished. The winners are: tourist Egor eatmore Final standings",
          "author": "MikeMirzayanov",
          "url": "https://codeforces.com/blog/entry/7693",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 686
        },
        {
          "title": "Croc Champ 2013 — Final Round — Editorial - Codeforces",
          "content": "Problem A. Morning runWe were asked to find the expected value of meetings between the runners. How to do that? As the first step, expected value is lineal, so we can split the initial problems into the different ones: find the expected value of meetings between the fixed pair of runners. We will solve these problems. To do that we need to make some observations: Let x be the distance between the two runners and they run face to face for infinite amount of time (probability of that obviously equals to 0.5·0.5 = 0.25). Then the first meeting will happen at time , the next one — , the next — and so on. Let us assume that every run ran for l time units. Then if two runners meet — they meet exactly two times. The probability of the meeting equals to 0.5, because in two cases they run in the same direction and in two cases in the different ones. We will build our solution based on these two observations. As the first step let us represent t as t = k·l + p, where 0 ≤ p < l. Then each runner will run k full laps. What does that mean? Because we have pairs of runners, then in those k laps each pair will have 2k meetings with probability equals to 0.5. So, we need to add to the answer.Now we need to take into account p seconds of running. Let us assume that the distance between two runners is x and they run towards each other. Then they will meet if , or x ≤ 2t. They will meet once more if , ir x ≤ 2t - l. They cannot meet more than twice, because p < l.Let us fix one of the runners, then using binary search we can find all other runners at distance no more than x from the fixed one. Let us choose x as x = 2t, and then the number of runners at the distance no more than x stands for the number of runners which meet with the fixed one at least once. If x = 2t - l, we will find the number of runners which meet with the fixed one exactly two times. Multiplying these numbers by 0.25 — probability of the meeting, and add it to the answer.The complexity of this solution is . We can reduce it using two pointers method.Problem B. Context AdvertisingWe were asked to find the maximal number of words we can fit into the block of size r × c. Let's first solve such problem: what is the maximal number of consecutive words which can fit in a row of lenth c, if the first word has index i. We can solve it using binary search or moving the pointer. Now let us build a graph, where vertices are the words and there is a directional edge between i and j, if words from i to j - 1 fit in one row of length c, but words from i to j don't. The weight of the edge is j - i. The we have the following problem: we need to find the path of length k, which has the maximal weight. Easy to solve it with complexity saving weights of all the paths with lengthes equal to the powers of two, or in O(n) time using dfs.The other problems competitors faced — that we were asked to print the whole text, not only the length.Problem C. Memory for ArraysWe were asked to find the maximal number of arrays we can fit into the memory. A small observation first, let the answer be k, then one of the optimal solutions fits the k smallest arrays into the memory. We can assume that we have arrays of size 1 and we want to arrange the memory for the maximal arrays as possible. Then if we have parts of memory of odd size, if we fit array of size 1 at this part we will obtain part of even size. From other hand, if we put arrays of bigger size we will not change the parity and if we don't fill it with arrays of size one and initially it's of odd size then in the end we will have at least one empty cell. So it's reasonable to put the arrays of size one into the memory of odd size. Let's do it until we can do it. We have three possible situations: We don't have memory parts of odd size anymore. We don't have arrays of size 1 anymore. We don't have neither arrays of size 1 neither memory parts of size 1. Let us start from the first case. Suppose that there are some arrays of size 1 left, but there are no memory parts of odd size. Easy to see then in such case we need to group arrays of size 1 in pairs and then consider them as the same array. So we can divide every number by two and reduce the problem to the initial one.In the second case if we divide every number by two we will obtain the same problem (and that cannot increase the answer).The third case is similar to the second one.When implementing this we need to remember that first we have to fill the memory with arrays which are build from the maximal numbers of initial arrays.The complexity of the given algorithm is .Problem D. Tennis RacketsWe were asked to find the number of obtuse triangles which satisfy the problem statement. Author's solution has complexity O(n2), but it has some optimizations, so it easily works under the TL.Every triangle has only one obtuse angle. Due to symmetry reasons we can fix one of the sides and assume that obtuse angle is tangent to this side. Then we only need to find the number of such triangles and multiple the answer by 3.Every side is also symmetric, so we can consider only one half of it and then multiple the answer by 2.Let us assume that vertex A of the triangle has coordinates (0,0). Vertex B (0,) and C(2,0). Then we can find the coordinates of every single point at each of the sides and apply cosine theorem. We obtain the inequality which guarantee us that the triangle is obtuse. It can be written in many ways, on of them is following: If 1 ≤ i, j, k ≤ n — indices of points which are fixed at each of the sides, then triangle is obtuse iff: f(i, j, k) = 2i2 - i(n + 1) + 2j(n + 1) - ij - k(i + j) < 0. We can see that monotonically increases, so we can use moving pointer method applied to variable k. Then just go over all i from m + 1 to , then j from m + 1 till upper bound for k is less than or equal to n - m + 1 and just sum the results.We should mention that all of the operations have to be done in int type, it significantly increases the speed.Problem E. SheepAuthor's supposed greedy algorithm as a solution for this problem. Let us follow this algorithm. Let us create to label for every interval Positionv and MaximalPositionv.Positionv — stands for position of v in the required permutation.MaximalPositionv — stands for maximal possible position of v in the particular moment of the algorithm.Also let's consider count as a counter with initial value of 0 and set of unprocessed vertices S. The algorithm is following. Using binary search we find the maximal possible distance between the farthest sheep. And then check whether exists the permutation with maximal distance no more than K. Sort all the intervals in the increasing order of ri. Positioni = 0, 1 ≤ i ≤ n, MaximalPositioni = n, 1 ≤ i ≤ n, current = 1, count = 0. Do count = count + 1, Positioncurrent = count, erase current from S, if S — is empty, required permutation has been found. Look at every interval connected to current, and update MaximalPositionv = min(MaximalPositionv, Positioncurrent + K) Build sets S(count, j) = {v|MaximalPositionv ≤ count + j}. If for every j ≥ K - count + 1 holds |S(count, j)| ≤ j go to the step 7, otherwise there is no such permutation. Choose the minimal j such that |S(count, j)| = j. Choose from it the interval with the smallest ri and consider it as a new value for current, go to the step 4. First let us discuss the complexity. Let us fix K (in total there are iterations with fixed K).Every step from 4 to 7 will be done at most n times (every time size of S decreases by one). Every step can be implemented in O(n) time. The most difficult one — step 6. But we can see that it's not necessary to actually build the sets, all we need to know — their sizes. This can be done in linear time just counting the number of intervals that MaximalPositionv = i. Let if be Ci — then size of S(count, j) equals to C1 + C2 + ... + Ccount + j, which can be easily calculated with partial sums.Now let us discuss why this algorithm works. If we have Position labels for every interval — we obviously have the solution. Now let us assume that we ended up earlier. Then we will show that there is no such permutation. If algorithm ended, it means that for some count (consider the smallest such count), exists j0, that |S(count, j0)| > j0 at this step. Then |S(count, k)| > k. Let us prove that from contradiction. From the definition of count we have |S(count - 1, j)| ≤ j for every j ≥ k - count + 2. Then |S(count, j)| = |S(count - 1, j + 1)| - 1 ≤ j for every j ≤ k - 1. And S(count, j) = S(count, k) for k ≤ j < n - count = |S(count, j)| = |S(count, k)| ≤ j. Finally |S(count, n - count)| = n - count. Then |S(count, j)| ≤ j for every j, so we obtain contradiction. That means if algorithm stops at step 6 we have |S(count, k)| > k. So exist at least k + 1 interval, which still don't have assigned label Position and they should be assigned after count. So one of the intervals in S(count, k) has to have the value of Position at least count + k + 1. But every intervals in S(count, k) connected to at least one interval with Position ≤ count. So, we obtain that there is now such permutation.Editorial was prepared by sdya and Seyaua.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/7749",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 9178
        }
      ],
      "code_examples": [
        {
          "title": "Croc Champ 2013 — Finals - Codeforces - Code 1",
          "code": "cin.sync_with_stdio(false);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7693",
          "author": "MikeMirzayanov"
        },
        {
          "title": "Croc Champ 2013 — Finals - Codeforces - Code 2",
          "code": "2 3\n4 6\n0 2 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7693",
          "author": "MikeMirzayanov"
        },
        {
          "title": "Croc Champ 2013 — Finals - Codeforces - Code 3",
          "code": "2 3\n4 6\n0 2 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7693",
          "author": "MikeMirzayanov"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(0, n, \"m\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(0, n, \"m\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(0, n, \"m\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\", 0);\n\n    ensure(0 <= m && m < n); // Ensure that 0 ≤ m < n\n\n    printf(\"%d %d\\n\", n, m);\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\", 0);\n\n    ensure(0 <= m && m < n); // Ensure that 0 ≤ m < n\n\n    printf(\"%d %d\\n\", n, m);\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -m 0\n./gen -n 2 -m 0\n./gen -n 2 -m 1\n./gen -n 3 -m 0\n./gen -n 3 -m 1\n./gen -n 3 -m 2\n./gen -n 10 -m 0\n./gen -n 10 -m 1\n./gen -n 10 -m 5\n./gen -n 10 -m 9\n./gen -n 100 -m 0\n./gen -n 100 -m 50\n./gen -n 100 -m 99\n./gen -n 1000 -m 0\n./gen -n 1000 -m 100\n./gen -n 1000 -m 999\n./gen -n 100000 -m 0\n./gen -n 100000 -m 10000\n./gen -n 100000 -m 99999\n./gen -n 1000000 -m 0\n./gen -n 1000000 -m 1\n./gen -n 1000000 -m 500000\n./gen -n 1000000 -m 999999\n./gen -n 999999999 -m 0\n./gen -n 999999999 -m 1\n./gen -n 999999999 -m 499999999\n./gen -n 999999999 -m 999999998\n./gen -n 1000000000 -m 0\n./gen -n 1000000000 -m 1\n./gen -n 1000000000 -m 500000000\n./gen -n 1000000000 -m 999999999\n./gen -n 1000000000 -m 999999990\n./gen -n 234567890 -m 123456789\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:06:05.421934",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "309/E",
      "title": "E. Sheep",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first input line contains one integer n (1 ≤ n ≤ 2000). Each of the following n lines contains two integers li and ri (1 ≤ li, ri ≤ 109; li ≤ ri).",
      "output_spec": "OutputIn the single output line print n space-separated numbers — the sought arrangement of the sheep. The i-th value in the line must represent the number of the sheep that took the i-th place from left in the optimal arrangement line. If there are multiple optimal arrangements, print any of them.",
      "sample_tests": "ExamplesInputCopy31 35 72 4OutputCopy1 3 2InputCopy51 52 43 61 72 6OutputCopy2 1 3 5 4InputCopy41 34 65 72 3OutputCopy1 4 2 3",
      "description": "time limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first input line contains one integer n (1 ≤ n ≤ 2000). Each of the following n lines contains two integers li and ri (1 ≤ li, ri ≤ 109; li ≤ ri).\n\nOutputIn the single output line print n space-separated numbers — the sought arrangement of the sheep. The i-th value in the line must represent the number of the sheep that took the i-th place from left in the optimal arrangement line. If there are multiple optimal arrangements, print any of them.\n\nInputCopy31 35 72 4OutputCopy1 3 2InputCopy51 52 43 61 72 6OutputCopy2 1 3 5 4InputCopy41 34 65 72 3OutputCopy1 4 2 3\n\nInputCopy31 35 72 4\n\nOutputCopy1 3 2\n\nInputCopy51 52 43 61 72 6\n\nOutputCopy2 1 3 5 4\n\nInputCopy41 34 65 72 3\n\nOutputCopy1 4 2 3",
      "solutions": [
        {
          "title": "Croc Champ 2013 — Finals - Codeforces",
          "content": "Today it will be Croc Champ 2013 Finals! Good luck to all participants. And to those who don't participate — enjoy the interesting competition.Yesterday have finished the trial contest and Code Game Challenge. The winner of Code Game Challenge is ... tourist!Also pay attention to the Croc Champ 2013 - Finals (online version, Div. 1). It will be a rated round. Note: it will be slightly unsual because we will not hide the standings of the official contest. So some information about difficulties of the problems will be known before the round. The contest duration is 2.5 hours.Good luck to everyone!The contest has been finished. The winners are: tourist Egor eatmore Final standings",
          "author": "MikeMirzayanov",
          "url": "https://codeforces.com/blog/entry/7693",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 686
        },
        {
          "title": "Croc Champ 2013 — Final Round — Editorial - Codeforces",
          "content": "Problem A. Morning runWe were asked to find the expected value of meetings between the runners. How to do that? As the first step, expected value is lineal, so we can split the initial problems into the different ones: find the expected value of meetings between the fixed pair of runners. We will solve these problems. To do that we need to make some observations: Let x be the distance between the two runners and they run face to face for infinite amount of time (probability of that obviously equals to 0.5·0.5 = 0.25). Then the first meeting will happen at time , the next one — , the next — and so on. Let us assume that every run ran for l time units. Then if two runners meet — they meet exactly two times. The probability of the meeting equals to 0.5, because in two cases they run in the same direction and in two cases in the different ones. We will build our solution based on these two observations. As the first step let us represent t as t = k·l + p, where 0 ≤ p < l. Then each runner will run k full laps. What does that mean? Because we have pairs of runners, then in those k laps each pair will have 2k meetings with probability equals to 0.5. So, we need to add to the answer.Now we need to take into account p seconds of running. Let us assume that the distance between two runners is x and they run towards each other. Then they will meet if , or x ≤ 2t. They will meet once more if , ir x ≤ 2t - l. They cannot meet more than twice, because p < l.Let us fix one of the runners, then using binary search we can find all other runners at distance no more than x from the fixed one. Let us choose x as x = 2t, and then the number of runners at the distance no more than x stands for the number of runners which meet with the fixed one at least once. If x = 2t - l, we will find the number of runners which meet with the fixed one exactly two times. Multiplying these numbers by 0.25 — probability of the meeting, and add it to the answer.The complexity of this solution is . We can reduce it using two pointers method.Problem B. Context AdvertisingWe were asked to find the maximal number of words we can fit into the block of size r × c. Let's first solve such problem: what is the maximal number of consecutive words which can fit in a row of lenth c, if the first word has index i. We can solve it using binary search or moving the pointer. Now let us build a graph, where vertices are the words and there is a directional edge between i and j, if words from i to j - 1 fit in one row of length c, but words from i to j don't. The weight of the edge is j - i. The we have the following problem: we need to find the path of length k, which has the maximal weight. Easy to solve it with complexity saving weights of all the paths with lengthes equal to the powers of two, or in O(n) time using dfs.The other problems competitors faced — that we were asked to print the whole text, not only the length.Problem C. Memory for ArraysWe were asked to find the maximal number of arrays we can fit into the memory. A small observation first, let the answer be k, then one of the optimal solutions fits the k smallest arrays into the memory. We can assume that we have arrays of size 1 and we want to arrange the memory for the maximal arrays as possible. Then if we have parts of memory of odd size, if we fit array of size 1 at this part we will obtain part of even size. From other hand, if we put arrays of bigger size we will not change the parity and if we don't fill it with arrays of size one and initially it's of odd size then in the end we will have at least one empty cell. So it's reasonable to put the arrays of size one into the memory of odd size. Let's do it until we can do it. We have three possible situations: We don't have memory parts of odd size anymore. We don't have arrays of size 1 anymore. We don't have neither arrays of size 1 neither memory parts of size 1. Let us start from the first case. Suppose that there are some arrays of size 1 left, but there are no memory parts of odd size. Easy to see then in such case we need to group arrays of size 1 in pairs and then consider them as the same array. So we can divide every number by two and reduce the problem to the initial one.In the second case if we divide every number by two we will obtain the same problem (and that cannot increase the answer).The third case is similar to the second one.When implementing this we need to remember that first we have to fill the memory with arrays which are build from the maximal numbers of initial arrays.The complexity of the given algorithm is .Problem D. Tennis RacketsWe were asked to find the number of obtuse triangles which satisfy the problem statement. Author's solution has complexity O(n2), but it has some optimizations, so it easily works under the TL.Every triangle has only one obtuse angle. Due to symmetry reasons we can fix one of the sides and assume that obtuse angle is tangent to this side. Then we only need to find the number of such triangles and multiple the answer by 3.Every side is also symmetric, so we can consider only one half of it and then multiple the answer by 2.Let us assume that vertex A of the triangle has coordinates (0,0). Vertex B (0,) and C(2,0). Then we can find the coordinates of every single point at each of the sides and apply cosine theorem. We obtain the inequality which guarantee us that the triangle is obtuse. It can be written in many ways, on of them is following: If 1 ≤ i, j, k ≤ n — indices of points which are fixed at each of the sides, then triangle is obtuse iff: f(i, j, k) = 2i2 - i(n + 1) + 2j(n + 1) - ij - k(i + j) < 0. We can see that monotonically increases, so we can use moving pointer method applied to variable k. Then just go over all i from m + 1 to , then j from m + 1 till upper bound for k is less than or equal to n - m + 1 and just sum the results.We should mention that all of the operations have to be done in int type, it significantly increases the speed.Problem E. SheepAuthor's supposed greedy algorithm as a solution for this problem. Let us follow this algorithm. Let us create to label for every interval Positionv and MaximalPositionv.Positionv — stands for position of v in the required permutation.MaximalPositionv — stands for maximal possible position of v in the particular moment of the algorithm.Also let's consider count as a counter with initial value of 0 and set of unprocessed vertices S. The algorithm is following. Using binary search we find the maximal possible distance between the farthest sheep. And then check whether exists the permutation with maximal distance no more than K. Sort all the intervals in the increasing order of ri. Positioni = 0, 1 ≤ i ≤ n, MaximalPositioni = n, 1 ≤ i ≤ n, current = 1, count = 0. Do count = count + 1, Positioncurrent = count, erase current from S, if S — is empty, required permutation has been found. Look at every interval connected to current, and update MaximalPositionv = min(MaximalPositionv, Positioncurrent + K) Build sets S(count, j) = {v|MaximalPositionv ≤ count + j}. If for every j ≥ K - count + 1 holds |S(count, j)| ≤ j go to the step 7, otherwise there is no such permutation. Choose the minimal j such that |S(count, j)| = j. Choose from it the interval with the smallest ri and consider it as a new value for current, go to the step 4. First let us discuss the complexity. Let us fix K (in total there are iterations with fixed K).Every step from 4 to 7 will be done at most n times (every time size of S decreases by one). Every step can be implemented in O(n) time. The most difficult one — step 6. But we can see that it's not necessary to actually build the sets, all we need to know — their sizes. This can be done in linear time just counting the number of intervals that MaximalPositionv = i. Let if be Ci — then size of S(count, j) equals to C1 + C2 + ... + Ccount + j, which can be easily calculated with partial sums.Now let us discuss why this algorithm works. If we have Position labels for every interval — we obviously have the solution. Now let us assume that we ended up earlier. Then we will show that there is no such permutation. If algorithm ended, it means that for some count (consider the smallest such count), exists j0, that |S(count, j0)| > j0 at this step. Then |S(count, k)| > k. Let us prove that from contradiction. From the definition of count we have |S(count - 1, j)| ≤ j for every j ≥ k - count + 2. Then |S(count, j)| = |S(count - 1, j + 1)| - 1 ≤ j for every j ≤ k - 1. And S(count, j) = S(count, k) for k ≤ j < n - count = |S(count, j)| = |S(count, k)| ≤ j. Finally |S(count, n - count)| = n - count. Then |S(count, j)| ≤ j for every j, so we obtain contradiction. That means if algorithm stops at step 6 we have |S(count, k)| > k. So exist at least k + 1 interval, which still don't have assigned label Position and they should be assigned after count. So one of the intervals in S(count, k) has to have the value of Position at least count + k + 1. But every intervals in S(count, k) connected to at least one interval with Position ≤ count. So, we obtain that there is now such permutation.Editorial was prepared by sdya and Seyaua.",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/7749",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 9178
        }
      ],
      "code_examples": [
        {
          "title": "Croc Champ 2013 — Finals - Codeforces - Code 1",
          "code": "cin.sync_with_stdio(false);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7693",
          "author": "MikeMirzayanov"
        },
        {
          "title": "Croc Champ 2013 — Finals - Codeforces - Code 2",
          "code": "2 3\n4 6\n0 2 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7693",
          "author": "MikeMirzayanov"
        },
        {
          "title": "Croc Champ 2013 — Finals - Codeforces - Code 3",
          "code": "2 3\n4 6\n0 2 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7693",
          "author": "MikeMirzayanov"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 2000, \"n\");\n    inf.readEoln();\n\n    for (int i = 0; i < n; i++) {\n        int li = inf.readInt(1, 1000000000, \"li\");\n        inf.readSpace();\n        int ri = inf.readInt(1, 1000000000, \"ri\");\n        ensuref(li <= ri, \"li should be less than or equal to ri at line %d: li=%d ri=%d\", i + 2, li, ri);\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 2000, \"n\");\n    inf.readEoln();\n\n    for (int i = 0; i < n; i++) {\n        int li = inf.readInt(1, 1000000000, \"li\");\n        inf.readSpace();\n        int ri = inf.readInt(1, 1000000000, \"ri\");\n        ensuref(li <= ri, \"li should be less than or equal to ri at line %d: li=%d ri=%d\", i + 2, li, ri);\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 2000, \"n\");\n    inf.readEoln();\n\n    for (int i = 0; i < n; i++) {\n        int li = inf.readInt(1, 1000000000, \"li\");\n        inf.readSpace();\n        int ri = inf.readInt(1, 1000000000, \"ri\");\n        ensuref(li <= ri, \"li should be less than or equal to ri at line %d: li=%d ri=%d\", i + 2, li, ri);\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint n;\nvector<int> l, r;\nvector<vector<bool>> adj;\n\nint readAns(InStream& stream) {\n    vector<int> seq(n);\n    vector<bool> used(n, false);\n    for (int i = 0; i < n; i++) {\n        int x = stream.readInt(1, n, format(\"sheep number at position %d\", i + 1).c_str());\n        if (used[x - 1]) {\n            stream.quitf(_wa, \"sheep number %d occurs more than once\", x);\n        }\n        used[x - 1] = true;\n        seq[i] = x - 1; // zero-based index\n    }\n    // Compute positions\n    vector<int> pos(n);\n    for (int i = 0; i < n; i++) {\n        pos[seq[i]] = i;\n    }\n    // Calculate maximum distance between any tied sheep\n    int maxDist = 0;\n    for (int i = 0; i < n; i++) {\n        for (int j = i+1; j < n; j++) {\n            if (adj[seq[i]][seq[j]]) {\n                int dist = abs(pos[seq[i]] - pos[seq[j]]);\n                if (dist > maxDist) {\n                    maxDist = dist;\n                }\n            }\n        }\n    }\n    return maxDist;\n}\n\nint main(int argc, char* argv[]) {\n    registerTestlibCmd(argc, argv);\n\n    n = inf.readInt();\n    l.resize(n);\n    r.resize(n);\n    for (int i = 0; i < n; i++) {\n        l[i] = inf.readInt();\n        r[i] = inf.readInt();\n    }\n    // Build adjacency matrix of tied sheep\n    adj.assign(n, vector<bool>(n, false));\n    for (int i = 0; i < n; i++) {\n        adj[i][i] = true; // Each sheep is tied to itself\n        for (int j = i + 1; j < n; j++) {\n            if (max(l[i], l[j]) <= min(r[i], r[j])) {\n                adj[i][j] = adj[j][i] = true;\n            }\n        }\n    }\n\n    int jans = readAns(ans);\n    int pans = readAns(ouf);\n\n    if (pans > jans)\n        quitf(_wa, \"Wrong answer: maximum distance in contestant's output is %d, which is greater than minimal possible %d\", pans, jans);\n    else if (pans == jans)\n        quitf(_ok, \"Accepted: maximum distance is %d\", pans);\n    else\n        quitf(_fail, \"Participant's maximum distance %d is less than jury's minimal maximum distance %d\", pans, jans);\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<pair<int,int>> intervals(n);\n\n    if (type == \"random\") {\n        // Generate random intervals\n        for (int i = 0; i < n; ++i) {\n            int l = rnd.next(1, 1000000000);\n            int r = rnd.next(l, 1000000000);\n            intervals[i] = {l, r};\n        }\n    } else if (type == \"same_intervals\") {\n        // All sheep have the same interval\n        int l = rnd.next(1, 1000000000);\n        int r = rnd.next(l, 1000000000);\n        for (int i = 0; i < n; ++i) {\n            intervals[i] = {l, r};\n        }\n    } else if (type == \"completely_overlapping\") {\n        // All intervals overlap but are different\n        int lmin = rnd.next(1, 1000000000 - n);\n        int rmax = lmin + n;\n        for (int i = 0; i < n; ++i) {\n            int l = rnd.next(lmin, rmax - 1);\n            int r = rnd.next(l + 1, rmax);\n            intervals[i] = {l, r};\n        }\n    } else if (type == \"non_overlapping\") {\n        // All intervals do not overlap\n        int start = 1;\n        for (int i = 0; i < n; ++i) {\n            int l = start;\n            int r = l + rnd.next(0, 1000);\n            intervals[i] = {l, r};\n            start = r + 1;\n        }\n    } else if (type == \"chain_overlapping\") {\n        // Each interval overlaps only with the next one\n        int l = 1;\n        for (int i = 0; i < n; ++i) {\n            int li = l;\n            int ri = l + 1; // Overlaps with next interval\n            intervals[i] = {li, ri};\n            l += 1; // Next interval starts from l + 1\n        }\n    } else if (type == \"star_overlapping\") {\n        // Sheep 0 overlaps with all others, others do not overlap among themselves\n        int l_center = rnd.next(1, 1000000000 - n * 1000);\n        int r_center = l_center + n * 1000;\n        intervals[0] = {l_center, r_center};\n        int gap = 2;\n        int li = l_center + 1;\n        for (int i = 1; i < n; ++i) {\n            intervals[i] = {li, li};\n            li += gap;\n        }\n    } else if (type == \"sorted_by_l\") {\n        // Intervals sorted by l\n        int l = 1;\n        for (int i = 0; i < n; ++i) {\n            int li = l;\n            int ri = rnd.next(li, 1000000000);\n            intervals[i] = {li, ri};\n            l += rnd.next(1, 1000);\n        }\n    } else if (type == \"sorted_by_r\") {\n        // Intervals sorted by r\n        int r = 1000000000;\n        for (int i = 0; i < n; ++i) {\n            int ri = r;\n            int li = rnd.next(1, ri);\n            intervals[i] = {li, ri};\n            r -= rnd.next(1, 1000);\n            if (r < 1) r = 1;\n        }\n    } else if (type == \"large_numbers\") {\n        // Intervals with large numbers\n        for (int i = 0; i < n; ++i) {\n            int l = rnd.next(1000000000 - 10000, 1000000000);\n            int r = rnd.next(l, 1000000000);\n            intervals[i] = {l, r};\n        }\n    } else if (type == \"same_l\") {\n        // All intervals have the same l, varying r\n        int l = rnd.next(1, 1000000000 - 1000);\n        for (int i = 0; i < n; ++i) {\n            int r = rnd.next(l, 1000000000);\n            intervals[i] = {l, r};\n        }\n    } else if (type == \"same_r\") {\n        // All intervals have the same r, varying l\n        int r = rnd.next(1000, 1000000000);\n        for (int i = 0; i < n; ++i) {\n            int l = rnd.next(1, r);\n            intervals[i] = {l, r};\n        }\n    } else {\n        fprintf(stderr, \"Unknown type: %s\\n\", type.c_str());\n        return 1;\n    }\n\n    printf(\"%d\\n\", n);\n    for (const auto& p : intervals) {\n        printf(\"%d %d\\n\", p.first, p.second);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<pair<int,int>> intervals(n);\n\n    if (type == \"random\") {\n        // Generate random intervals\n        for (int i = 0; i < n; ++i) {\n            int l = rnd.next(1, 1000000000);\n            int r = rnd.next(l, 1000000000);\n            intervals[i] = {l, r};\n        }\n    } else if (type == \"same_intervals\") {\n        // All sheep have the same interval\n        int l = rnd.next(1, 1000000000);\n        int r = rnd.next(l, 1000000000);\n        for (int i = 0; i < n; ++i) {\n            intervals[i] = {l, r};\n        }\n    } else if (type == \"completely_overlapping\") {\n        // All intervals overlap but are different\n        int lmin = rnd.next(1, 1000000000 - n);\n        int rmax = lmin + n;\n        for (int i = 0; i < n; ++i) {\n            int l = rnd.next(lmin, rmax - 1);\n            int r = rnd.next(l + 1, rmax);\n            intervals[i] = {l, r};\n        }\n    } else if (type == \"non_overlapping\") {\n        // All intervals do not overlap\n        int start = 1;\n        for (int i = 0; i < n; ++i) {\n            int l = start;\n            int r = l + rnd.next(0, 1000);\n            intervals[i] = {l, r};\n            start = r + 1;\n        }\n    } else if (type == \"chain_overlapping\") {\n        // Each interval overlaps only with the next one\n        int l = 1;\n        for (int i = 0; i < n; ++i) {\n            int li = l;\n            int ri = l + 1; // Overlaps with next interval\n            intervals[i] = {li, ri};\n            l += 1; // Next interval starts from l + 1\n        }\n    } else if (type == \"star_overlapping\") {\n        // Sheep 0 overlaps with all others, others do not overlap among themselves\n        int l_center = rnd.next(1, 1000000000 - n * 1000);\n        int r_center = l_center + n * 1000;\n        intervals[0] = {l_center, r_center};\n        int gap = 2;\n        int li = l_center + 1;\n        for (int i = 1; i < n; ++i) {\n            intervals[i] = {li, li};\n            li += gap;\n        }\n    } else if (type == \"sorted_by_l\") {\n        // Intervals sorted by l\n        int l = 1;\n        for (int i = 0; i < n; ++i) {\n            int li = l;\n            int ri = rnd.next(li, 1000000000);\n            intervals[i] = {li, ri};\n            l += rnd.next(1, 1000);\n        }\n    } else if (type == \"sorted_by_r\") {\n        // Intervals sorted by r\n        int r = 1000000000;\n        for (int i = 0; i < n; ++i) {\n            int ri = r;\n            int li = rnd.next(1, ri);\n            intervals[i] = {li, ri};\n            r -= rnd.next(1, 1000);\n            if (r < 1) r = 1;\n        }\n    } else if (type == \"large_numbers\") {\n        // Intervals with large numbers\n        for (int i = 0; i < n; ++i) {\n            int l = rnd.next(1000000000 - 10000, 1000000000);\n            int r = rnd.next(l, 1000000000);\n            intervals[i] = {l, r};\n        }\n    } else if (type == \"same_l\") {\n        // All intervals have the same l, varying r\n        int l = rnd.next(1, 1000000000 - 1000);\n        for (int i = 0; i < n; ++i) {\n            int r = rnd.next(l, 1000000000);\n            intervals[i] = {l, r};\n        }\n    } else if (type == \"same_r\") {\n        // All intervals have the same r, varying l\n        int r = rnd.next(1000, 1000000000);\n        for (int i = 0; i < n; ++i) {\n            int l = rnd.next(1, r);\n            intervals[i] = {l, r};\n        }\n    } else {\n        fprintf(stderr, \"Unknown type: %s\\n\", type.c_str());\n        return 1;\n    }\n\n    printf(\"%d\\n\", n);\n    for (const auto& p : intervals) {\n        printf(\"%d %d\\n\", p.first, p.second);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Small n test cases with random intervals\n./gen -n 1 -type random\n./gen -n 2 -type random\n./gen -n 5 -type random\n./gen -n 10 -type random\n\n# Small n with specific types\n./gen -n 10 -type same_intervals\n./gen -n 10 -type completely_overlapping\n./gen -n 10 -type non_overlapping\n./gen -n 10 -type chain_overlapping\n./gen -n 10 -type star_overlapping\n./gen -n 10 -type sorted_by_l\n./gen -n 10 -type sorted_by_r\n\n# Medium n test cases\n./gen -n 1000 -type random\n./gen -n 1000 -type sorted_by_l\n./gen -n 1000 -type sorted_by_r\n./gen -n 1000 -type large_numbers\n\n# Maximum n test cases\n./gen -n 2000 -type random\n./gen -n 2000 -type same_intervals\n./gen -n 2000 -type completely_overlapping\n./gen -n 2000 -type non_overlapping\n./gen -n 2000 -type chain_overlapping\n./gen -n 2000 -type star_overlapping\n./gen -n 2000 -type sorted_by_l\n./gen -n 2000 -type sorted_by_r\n./gen -n 2000 -type large_numbers\n./gen -n 2000 -type same_l\n./gen -n 2000 -type same_r\n\n# Edge case: all intervals have length zero (li == ri)\n./gen -n 2000 -type same_intervals\n\n# Non-overlapping intervals\n./gen -n 2000 -type non_overlapping\n\n# Chain overlapping\n./gen -n 2000 -type chain_overlapping\n\n# Star overlapping with small n\n./gen -n 2 -type star_overlapping\n./gen -n 10 -type star_overlapping\n./gen -n 100 -type star_overlapping\n\n# Intervals with large numbers\n./gen -n 1000 -type large_numbers\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:06:07.349347",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "31/A",
      "title": "A. Эволюция червей",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест2 seconds",
      "memory_limit": "ограничение по памяти на тест256 megabytes",
      "input_spec": "Входные данныеВ первой строке записано целое число n (3 ≤ n ≤ 100) — количество видов червей. На следующей строке через пробел записано n целых чисел ai (1 ≤ ai ≤ 1000) — длины червей всех видов.",
      "output_spec": "Выходные данныеВыведите 3 различных целых числа i j k (1 ≤ i, j, k ≤ n) — номера видов червей, для которых выполняется ai = aj + ak. Если таких не существует, выведите -1. Если решений несколько, выведите любое. Допустимо, что aj = ak.",
      "sample_tests": "ПримерыВходные данныеСкопировать51 2 3 5 7Выходные данныеСкопировать3 2 1Входные данныеСкопировать51 8 1 5 1Выходные данныеСкопировать-1",
      "description": "A. Эволюция червей\n\nограничение по времени на тест2 seconds\n\nограничение по времени на тест\n\nограничение по памяти на тест256 megabytes\n\nограничение по памяти на тест\n\nвыводstdout\n\nВходные данныеВ первой строке записано целое число n (3 ≤ n ≤ 100) — количество видов червей. На следующей строке через пробел записано n целых чисел ai (1 ≤ ai ≤ 1000) — длины червей всех видов.\n\nВходные данные\n\nВыходные данныеВыведите 3 различных целых числа i j k (1 ≤ i, j, k ≤ n) — номера видов червей, для которых выполняется ai = aj + ak. Если таких не существует, выведите -1. Если решений несколько, выведите любое. Допустимо, что aj = ak.\n\nВыходные данные\n\nВходные данныеСкопировать51 2 3 5 7Выходные данныеСкопировать3 2 1Входные данныеСкопировать51 8 1 5 1Выходные данныеСкопировать-1\n\nВходные данныеСкопировать51 2 3 5 7\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать3 2 1\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать51 8 1 5 1\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать-1\n\nВыходные данныеСкопировать\n\nСкопировать",
      "solutions": [
        {
          "title": "Codeforces Beta Round 31 (Div. 2, Codeforces format) - Codeforces",
          "content": "Приветствую всех на Codeforces Beta Round 31 (Div. 2, Codeforces format)Раунд для вас готовили: Михаил Мирзаянов, Дмитрий Матов, Макс Иванов и я.Удачи!Артем Рахов и команда Codeforces",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/704",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.5,
            "reason": "宽松匹配: 包含题目编号 31"
          },
          "content_length": 183
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Beta Round 31 (Div. 2, Codeforces format) - Codeforces - Code 1",
          "code": "4\n1 5\n5 7\n6 9\n9 10",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/704",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Beta Round 31 (Div. 2, Codeforces format) - Codeforces - Code 2",
          "code": "10\n89959999998998796989",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/704",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Beta Round 31 (Div. 2, Codeforces format) - Codeforces - Code 3",
          "code": "10\n89959999998998796989",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/704",
          "author": "Qingyu"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(3, 100, \"n\");\n    inf.readEoln();\n    vector<int> a = inf.readInts(n, 1, 1000, \"ai\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(3, 100, \"n\");\n    inf.readEoln();\n    vector<int> a = inf.readInts(n, 1, 1000, \"ai\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(3, 100, \"n\");\n    inf.readEoln();\n    vector<int> a = inf.readInts(n, 1, 1000, \"ai\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]){\n    registerTestlibCmd(argc, argv);\n    int n = inf.readInt();\n    vector<int> a(n+1);\n    for (int i =1; i<=n; ++i)\n        a[i] = inf.readInt();\n\n    // Build sum_pairs: map sums to pairs of indices\n    unordered_map<int, vector<pair<int,int>>> sum_pairs;\n    for (int j=1; j<=n; ++j)\n        for (int k=j+1; k<=n; ++k)\n        {\n            int s = a[j] + a[k];\n            sum_pairs[s].push_back({j,k});\n            sum_pairs[s].push_back({k,j}); // Include both orders\n        }\n\n    // Check for existence of a valid triple\n    bool exists = false;\n    for (int i=1; i<=n; ++i)\n    {\n        int s = a[i];\n        if (sum_pairs.count(s))\n        {\n            for (auto p : sum_pairs[s])\n            {\n                int j = p.first;\n                int k = p.second;\n                if (i != j && i != k && j != k)\n                {\n                    exists = true;\n                    break;\n                }\n            }\n        }\n        if (exists) break;\n    }\n\n    // Read contestant's output\n    int x = ouf.readInt(-1, n, \"first output value\");\n    if (x == -1)\n    {\n        if (!exists)\n            quitf(_ok, \"Correctly output -1 when no solution exists.\");\n        else\n            quitf(_wa, \"Solution exists, but contestant output -1.\");\n    }\n    else\n    {\n        int y = ouf.readInt(1, n, \"second index\");\n        int z = ouf.readInt(1, n, \"third index\");\n        if (x == y || x == z || y == z)\n            quitf(_wa, \"Indices are not distinct.\");\n        if (x < 1 || x > n || y < 1 || y > n || z < 1 || z > n)\n            quitf(_wa, \"Indices are out of range.\");\n        if (a[x] != a[y] + a[z])\n            quitf(_wa, \"a[%d]=%d is not equal to a[%d]=%d + a[%d]=%d.\", x, a[x], y, a[y], z, a[z]);\n        else\n            quitf(_ok, \"Correct triple: a[%d]=%d equals a[%d]=%d + a[%d]=%d.\", x, a[x], y, a[y], z, a[z]);\n    }\n\n    // Ensure there is no extra output\n    ouf.skipBlanks();\n    if (!ouf.eof())\n        quitf(_wa, \"Extra output found.\");\n\n    return 0;\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]){\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random_with_solution\");\n\n    vector<int> a(n);\n\n    if(type == \"random_with_solution\"){\n        // Generate a random test case with a guaranteed solution\n        int i, j, k;\n        do{\n            i = rnd.next(0, n - 1);\n            j = rnd.next(0, n - 1);\n            k = rnd.next(0, n - 1);\n        } while(i == j || i == k || j == k);\n\n        int aj, ak, ai;\n        do{\n            aj = rnd.next(1, 500);\n            ak = rnd.next(1, 500);\n            ai = aj + ak;\n        } while(ai > 1000);\n\n        a[j] = aj;\n        a[k] = ak;\n        a[i] = ai;\n\n        for(int idx = 0; idx < n; ++idx){\n            if(idx != i && idx != j && idx != k)\n                a[idx] = rnd.next(1, 1000);\n        }\n    }\n    else if(type == \"random_no_solution\"){\n        // Generate a random test case with no solution\n        for(int idx = 0; idx < n; ++idx){\n            a[idx] = 2 * rnd.next(1, 499) + 1; // Odd numbers between 3 and 999\n        }\n    }\n    else if(type == \"max_no_solution\"){\n        // Generate a test case with maximum values and no solution\n        n = min(n, 100);\n        a.assign(n, 1000);\n    }\n    else if(type == \"min_no_solution\"){\n        // Generate a test case with minimum values and no solution\n        n = max(n, 3);\n        a.assign(n, 1);\n    }\n    else if(type == \"duplicates_with_solution\"){\n        // Generate a test case with duplicates and a solution\n        int i, j, k;\n        do{\n            i = rnd.next(0, n - 1);\n            j = rnd.next(0, n - 1);\n            k = rnd.next(0, n - 1);\n        } while(i == j || i == k || j == k);\n\n        a.assign(n, 250);\n        a[i] = 500; // ai = aj + ak\n    }\n    else if(type == \"duplicates_no_solution\"){\n        // Generate a test case with duplicates and no solution\n        int value = rnd.next(1, 1000);\n        a.assign(n, value);\n    }\n    else if(type == \"no_solution_progression\"){\n        // Generate a progression with no possible sums\n        int start = rnd.next(1, 1000 - (n - 1) * 2);\n        for(int idx = 0; idx < n; ++idx){\n            a[idx] = start + 2 * idx; // Even numbers\n        }\n    }\n    else if(type == \"special_case\"){\n        // Generate a special case where aj equals ak\n        int i, j, k;\n        do{\n            i = rnd.next(0, n - 1);\n            j = rnd.next(0, n - 1);\n        } while(i == j);\n        k = j; // aj and ak are equal\n\n        a[j] = 500;\n        a[k] = 500;\n        a[i] = 1000; // ai = aj + ak\n\n        for(int idx = 0; idx < n; ++idx){\n            if(idx != i && idx != j && idx != k){\n                a[idx] = rnd.next(1, 1000);\n            }\n        }\n    }\n    else{\n        // Default random test case\n        for(int idx = 0; idx < n; ++idx){\n            a[idx] = rnd.next(1, 1000);\n        }\n    }\n\n    // Output n\n    printf(\"%d\\n\", n);\n    // Output ai\n    for(int idx = 0; idx < n; ++idx){\n        if(idx > 0) printf(\" \");\n        printf(\"%d\", a[idx]);\n    }\n    printf(\"\\n\");\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]){\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random_with_solution\");\n\n    vector<int> a(n);\n\n    if(type == \"random_with_solution\"){\n        // Generate a random test case with a guaranteed solution\n        int i, j, k;\n        do{\n            i = rnd.next(0, n - 1);\n            j = rnd.next(0, n - 1);\n            k = rnd.next(0, n - 1);\n        } while(i == j || i == k || j == k);\n\n        int aj, ak, ai;\n        do{\n            aj = rnd.next(1, 500);\n            ak = rnd.next(1, 500);\n            ai = aj + ak;\n        } while(ai > 1000);\n\n        a[j] = aj;\n        a[k] = ak;\n        a[i] = ai;\n\n        for(int idx = 0; idx < n; ++idx){\n            if(idx != i && idx != j && idx != k)\n                a[idx] = rnd.next(1, 1000);\n        }\n    }\n    else if(type == \"random_no_solution\"){\n        // Generate a random test case with no solution\n        for(int idx = 0; idx < n; ++idx){\n            a[idx] = 2 * rnd.next(1, 499) + 1; // Odd numbers between 3 and 999\n        }\n    }\n    else if(type == \"max_no_solution\"){\n        // Generate a test case with maximum values and no solution\n        n = min(n, 100);\n        a.assign(n, 1000);\n    }\n    else if(type == \"min_no_solution\"){\n        // Generate a test case with minimum values and no solution\n        n = max(n, 3);\n        a.assign(n, 1);\n    }\n    else if(type == \"duplicates_with_solution\"){\n        // Generate a test case with duplicates and a solution\n        int i, j, k;\n        do{\n            i = rnd.next(0, n - 1);\n            j = rnd.next(0, n - 1);\n            k = rnd.next(0, n - 1);\n        } while(i == j || i == k || j == k);\n\n        a.assign(n, 250);\n        a[i] = 500; // ai = aj + ak\n    }\n    else if(type == \"duplicates_no_solution\"){\n        // Generate a test case with duplicates and no solution\n        int value = rnd.next(1, 1000);\n        a.assign(n, value);\n    }\n    else if(type == \"no_solution_progression\"){\n        // Generate a progression with no possible sums\n        int start = rnd.next(1, 1000 - (n - 1) * 2);\n        for(int idx = 0; idx < n; ++idx){\n            a[idx] = start + 2 * idx; // Even numbers\n        }\n    }\n    else if(type == \"special_case\"){\n        // Generate a special case where aj equals ak\n        int i, j, k;\n        do{\n            i = rnd.next(0, n - 1);\n            j = rnd.next(0, n - 1);\n        } while(i == j);\n        k = j; // aj and ak are equal\n\n        a[j] = 500;\n        a[k] = 500;\n        a[i] = 1000; // ai = aj + ak\n\n        for(int idx = 0; idx < n; ++idx){\n            if(idx != i && idx != j && idx != k){\n                a[idx] = rnd.next(1, 1000);\n            }\n        }\n    }\n    else{\n        // Default random test case\n        for(int idx = 0; idx < n; ++idx){\n            a[idx] = rnd.next(1, 1000);\n        }\n    }\n\n    // Output n\n    printf(\"%d\\n\", n);\n    // Output ai\n    for(int idx = 0; idx < n; ++idx){\n        if(idx > 0) printf(\" \");\n        printf(\"%d\", a[idx]);\n    }\n    printf(\"\\n\");\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 3 -type random_with_solution\n./gen -n 5 -type random_with_solution\n./gen -n 10 -type random_with_solution\n./gen -n 50 -type random_with_solution\n./gen -n 100 -type random_with_solution\n\n./gen -n 3 -type random_no_solution\n./gen -n 5 -type random_no_solution\n./gen -n 10 -type random_no_solution\n./gen -n 50 -type random_no_solution\n./gen -n 100 -type random_no_solution\n\n./gen -n 3 -type max_no_solution\n./gen -n 100 -type max_no_solution\n\n./gen -n 3 -type min_no_solution\n./gen -n 100 -type min_no_solution\n\n./gen -n 5 -type duplicates_with_solution\n./gen -n 10 -type duplicates_with_solution\n./gen -n 50 -type duplicates_with_solution\n./gen -n 100 -type duplicates_with_solution\n\n./gen -n 5 -type duplicates_no_solution\n./gen -n 10 -type duplicates_no_solution\n./gen -n 50 -type duplicates_no_solution\n./gen -n 100 -type duplicates_no_solution\n\n./gen -n 10 -type no_solution_progression\n./gen -n 50 -type no_solution_progression\n./gen -n 100 -type no_solution_progression\n\n./gen -n 5 -type special_case\n./gen -n 10 -type special_case\n./gen -n 50 -type special_case\n./gen -n 100 -type special_case\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:06:09.155585",
        "total_tutorials": 1,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "31/B",
      "title": "B. Sysadmin Bob",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test0.5 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains the list of addresses without separators. The length of this string is between 1 and 200, inclusive. The string consists only from small Latin letters and characters «@».",
      "output_spec": "OutputIf there is no list of the valid (according to the Berland rules) email addresses such that after removing all commas it coincides with the given string, output No solution. In the other case, output the list. The same address can be written in this list more than once. If there are several solutions, output any of them.",
      "sample_tests": "ExamplesInputCopya@aa@aOutputCopya@a,a@aInputCopya@a@aOutputCopyNo solutionInputCopy@aa@aOutputCopyNo solution",
      "description": "B. Sysadmin Bob\n\ntime limit per test0.5 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains the list of addresses without separators. The length of this string is between 1 and 200, inclusive. The string consists only from small Latin letters and characters «@».\n\nOutputIf there is no list of the valid (according to the Berland rules) email addresses such that after removing all commas it coincides with the given string, output No solution. In the other case, output the list. The same address can be written in this list more than once. If there are several solutions, output any of them.\n\nInputCopya@aa@aOutputCopya@a,a@aInputCopya@a@aOutputCopyNo solutionInputCopy@aa@aOutputCopyNo solution\n\nInputCopya@aa@a\n\nOutputCopya@a,a@a\n\nInputCopya@a@a\n\nOutputCopyNo solution\n\nInputCopy@aa@a\n\nOutputCopyNo solution",
      "solutions": [
        {
          "title": "Codeforces Beta Round 31 (Div. 2, Codeforces format) - Codeforces",
          "content": "Hello everyone on Codeforces Beta Round 31 (Div. 2, Codeforces format)Round was prepared by: Mike Mirzayanov, Dmitry Matov, Max Ivanov and me.Good luck!Artem Rakhov and Codeforces team",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/704",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.5,
            "reason": "宽松匹配: 包含题目编号 31"
          },
          "content_length": 184
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Beta Round 31 (Div. 2, Codeforces format) - Codeforces - Code 1",
          "code": "10\n89959999998998796989",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/704",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    string s = inf.readLine(\"[a-z@]+\", \"s\");\n    ensuref(1 <= (int)s.length() && (int)s.length() <= 200, \"Length of s must be between 1 and 200, but is %d\", (int)s.length());\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    string s = inf.readLine(\"[a-z@]+\", \"s\");\n    ensuref(1 <= (int)s.length() && (int)s.length() <= 200, \"Length of s must be between 1 and 200, but is %d\", (int)s.length());\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    string s = inf.readLine(\"[a-z@]+\", \"s\");\n    ensuref(1 <= (int)s.length() && (int)s.length() <= 200, \"Length of s must be between 1 and 200, but is %d\", (int)s.length());\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nbool isValidAddress(const string& s) {\n    int at_pos = s.find('@');\n    if (at_pos == string::npos) return false;\n    if (count(s.begin(), s.end(), '@') != 1) return false;\n    string A = s.substr(0, at_pos);\n    string B = s.substr(at_pos + 1);\n    if (A.empty() || B.empty()) return false;\n    for (char c : A + B) {\n        if (c < 'a' || c > 'z') return false;\n    }\n    return true;\n}\n\nbool existsSolution(const string& S) {\n    int n = S.size();\n    vector<bool> dp(n + 1, false);\n    dp[0] = true;\n    for (int i = 0; i < n; ++i) {\n        if (!dp[i]) continue;\n        for (int j = i + 1; j <= n; ++j) {\n            string s = S.substr(i, j - i);\n            if (isValidAddress(s)) {\n                dp[j] = true;\n            }\n        }\n    }\n    return dp[n];\n}\n\nint main(int argc, char* argv[]) {\n    registerTestlibCmd(argc, argv);\n    string S = inf.readString();\n\n    string output;\n    while (!ouf.seekEof()) {\n        string line = ouf.readLine();\n        output += line;\n    }\n    // Remove all whitespaces from output\n    output.erase(remove_if(output.begin(), output.end(), ::isspace), output.end());\n    if (output == \"Nosolution\") {\n        // Participant outputs 'No solution'\n        if (existsSolution(S)) {\n            quitf(_wa, \"Participant says 'No solution' but a solution exists\");\n        } else {\n            quitf(_ok, \"Correctly outputs 'No solution'\");\n        }\n    } else {\n        // Should be a list of addresses separated by commas\n        for (char c : output) {\n            if (!((c >= 'a' && c <= 'z') || c == '@' || c == ',')) {\n                quitf(_wa, \"Invalid character '%c' in output\", c);\n            }\n        }\n        vector<string> addresses;\n        size_t pos = 0;\n        while (pos <= output.size()) {\n            size_t comma_pos = output.find(',', pos);\n            if (comma_pos == string::npos) {\n                addresses.push_back(output.substr(pos));\n                break;\n            } else {\n                addresses.push_back(output.substr(pos, comma_pos - pos));\n                pos = comma_pos + 1;\n            }\n        }\n        if (addresses.empty()) {\n            quitf(_wa, \"No addresses found in output\");\n        }\n        // Validate each address\n        for (size_t i = 0; i < addresses.size(); ++i) {\n            string addr = addresses[i];\n            if (!isValidAddress(addr)) {\n                quitf(_wa, \"Invalid address: %s\", addr.c_str());\n            }\n        }\n        // Concatenate addresses and compare to S\n        string concatenated;\n        for (const string& addr : addresses) {\n            concatenated += addr;\n        }\n        if (concatenated != S) {\n            quitf(_wa, \"Concatenated addresses do not match the input string\");\n        }\n        quitf(_ok, \"Correct solution\");\n    }\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring random_lowercase_string(int len) {\n    string s;\n    for (int i = 0; i < len; ++i) {\n        char c = 'a' + rnd.next(26);\n        s += c;\n    }\n    return s;\n}\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\"); // Target length of S\n    string type = opt<string>(\"type\"); // 'valid' or 'invalid'\n\n    string S;\n\n    if (type == \"valid\") {\n        // Generate a list of email addresses, assemble them, remove commas.\n        vector<string> emails;\n        int total_length = 0;\n        int max_email_length = min(10, n); // To avoid overly long email addresses.\n        while (total_length < n) {\n            // Adjust lenA and lenB to ensure email length is at least 3 (minimum valid email 'a@a')\n            int max_len = min(max_email_length, n - total_length); // Max length we can use now\n            if (max_len < 3) {\n                // Can't generate more emails\n                break;\n            }\n            int email_len = rnd.next(3, max_len);\n            // We need lenA + lenB + 1 = email_len\n            int lenA = rnd.next(1, email_len - 2);\n            int lenB = email_len - lenA - 1;\n            string A = random_lowercase_string(lenA);\n            string B = random_lowercase_string(lenB);\n            string email = A + \"@\" + B;\n            emails.push_back(email);\n            total_length += email.size();\n        }\n\n        // Now assemble S\n        S = \"\";\n        for (size_t i = 0; i < emails.size(); ++i) {\n            S += emails[i];\n        }\n\n        // If total_length < n, we can pad S with letters\n        if ((int)S.size() < n) {\n            // Pad S with letters\n            int remaining = n - S.size();\n            S += random_lowercase_string(remaining);\n        }\n\n        // Ensure S length is at least 1 and at most 200\n        if (S.size() > 200) {\n            S = S.substr(0, 200);\n        }\n\n        printf(\"%s\\n\", S.c_str());\n\n    } else if (type == \"invalid\") {\n        // Generate S such that it cannot be partitioned into valid email addresses.\n        int choice = rnd.next(1, 4);\n        if (choice == 1) {\n            // No '@' signs\n            S = random_lowercase_string(n);\n        } else if (choice == 2) {\n            // All '@' signs\n            S = string(n, '@');\n        } else if (choice == 3) {\n            // Starts or ends with '@'\n            if (n >= 1) {\n                S = \"@\";\n                if (n > 1) {\n                    S += random_lowercase_string(n - 1);\n                }\n            } else {\n                S = \"@\";\n            }\n        } else {\n            // Place '@' signs such that it's impossible to partition S into valid email addresses\n            S = \"\";\n            int remaining = n;\n            while (remaining > 0) {\n                if (remaining >= 1) {\n                    int len = rnd.next(1, remaining);\n                    string subS;\n                    if (len == 1) {\n                        subS = \"@\";\n                    } else if (len == 2) {\n                        subS = \"@@\";\n                    } else {\n                        // Mix of letters and '@'\n                        subS = \"\";\n                        for (int i = 0; i < len; ++i) {\n                            if (rnd.next(0, 1)) {\n                                subS += '@';\n                            } else {\n                                subS += 'a' + rnd.next(26);\n                            }\n                        }\n                    }\n                    S += subS;\n                    remaining -= subS.size();\n                }\n            }\n        }\n\n        // Ensure S length is at most 200\n        if (S.size() > 200) {\n            S = S.substr(0, 200);\n        }\n\n        printf(\"%s\\n\", S.c_str());\n    } else {\n        // Unknown type\n        fprintf(stderr, \"Unknown type: %s\\n\", type.c_str());\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring random_lowercase_string(int len) {\n    string s;\n    for (int i = 0; i < len; ++i) {\n        char c = 'a' + rnd.next(26);\n        s += c;\n    }\n    return s;\n}\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\"); // Target length of S\n    string type = opt<string>(\"type\"); // 'valid' or 'invalid'\n\n    string S;\n\n    if (type == \"valid\") {\n        // Generate a list of email addresses, assemble them, remove commas.\n        vector<string> emails;\n        int total_length = 0;\n        int max_email_length = min(10, n); // To avoid overly long email addresses.\n        while (total_length < n) {\n            // Adjust lenA and lenB to ensure email length is at least 3 (minimum valid email 'a@a')\n            int max_len = min(max_email_length, n - total_length); // Max length we can use now\n            if (max_len < 3) {\n                // Can't generate more emails\n                break;\n            }\n            int email_len = rnd.next(3, max_len);\n            // We need lenA + lenB + 1 = email_len\n            int lenA = rnd.next(1, email_len - 2);\n            int lenB = email_len - lenA - 1;\n            string A = random_lowercase_string(lenA);\n            string B = random_lowercase_string(lenB);\n            string email = A + \"@\" + B;\n            emails.push_back(email);\n            total_length += email.size();\n        }\n\n        // Now assemble S\n        S = \"\";\n        for (size_t i = 0; i < emails.size(); ++i) {\n            S += emails[i];\n        }\n\n        // If total_length < n, we can pad S with letters\n        if ((int)S.size() < n) {\n            // Pad S with letters\n            int remaining = n - S.size();\n            S += random_lowercase_string(remaining);\n        }\n\n        // Ensure S length is at least 1 and at most 200\n        if (S.size() > 200) {\n            S = S.substr(0, 200);\n        }\n\n        printf(\"%s\\n\", S.c_str());\n\n    } else if (type == \"invalid\") {\n        // Generate S such that it cannot be partitioned into valid email addresses.\n        int choice = rnd.next(1, 4);\n        if (choice == 1) {\n            // No '@' signs\n            S = random_lowercase_string(n);\n        } else if (choice == 2) {\n            // All '@' signs\n            S = string(n, '@');\n        } else if (choice == 3) {\n            // Starts or ends with '@'\n            if (n >= 1) {\n                S = \"@\";\n                if (n > 1) {\n                    S += random_lowercase_string(n - 1);\n                }\n            } else {\n                S = \"@\";\n            }\n        } else {\n            // Place '@' signs such that it's impossible to partition S into valid email addresses\n            S = \"\";\n            int remaining = n;\n            while (remaining > 0) {\n                if (remaining >= 1) {\n                    int len = rnd.next(1, remaining);\n                    string subS;\n                    if (len == 1) {\n                        subS = \"@\";\n                    } else if (len == 2) {\n                        subS = \"@@\";\n                    } else {\n                        // Mix of letters and '@'\n                        subS = \"\";\n                        for (int i = 0; i < len; ++i) {\n                            if (rnd.next(0, 1)) {\n                                subS += '@';\n                            } else {\n                                subS += 'a' + rnd.next(26);\n                            }\n                        }\n                    }\n                    S += subS;\n                    remaining -= subS.size();\n                }\n            }\n        }\n\n        // Ensure S length is at most 200\n        if (S.size() > 200) {\n            S = S.substr(0, 200);\n        }\n\n        printf(\"%s\\n\", S.c_str());\n    } else {\n        // Unknown type\n        fprintf(stderr, \"Unknown type: %s\\n\", type.c_str());\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -type valid\n./gen -n 1 -type invalid\n\n./gen -n 2 -type valid\n./gen -n 2 -type invalid\n\n./gen -n 3 -type valid\n./gen -n 3 -type invalid\n\n./gen -n 5 -type valid\n./gen -n 5 -type invalid\n\n./gen -n 7 -type valid\n./gen -n 7 -type invalid\n\n./gen -n 9 -type valid\n./gen -n 9 -type invalid\n\n./gen -n 10 -type valid\n./gen -n 10 -type invalid\n\n./gen -n 15 -type valid\n./gen -n 15 -type invalid\n\n./gen -n 20 -type valid\n./gen -n 20 -type invalid\n\n./gen -n 25 -type valid\n./gen -n 25 -type invalid\n\n./gen -n 30 -type valid\n./gen -n 30 -type invalid\n\n./gen -n 40 -type valid\n./gen -n 40 -type invalid\n\n./gen -n 50 -type valid\n./gen -n 50 -type invalid\n\n./gen -n 60 -type valid\n./gen -n 60 -type invalid\n\n./gen -n 70 -type valid\n./gen -n 70 -type invalid\n\n./gen -n 80 -type valid\n./gen -n 80 -type invalid\n\n./gen -n 90 -type valid\n./gen -n 90 -type invalid\n\n./gen -n 100 -type valid\n./gen -n 100 -type invalid\n\n./gen -n 150 -type valid\n./gen -n 150 -type invalid\n\n./gen -n 198 -type valid\n./gen -n 198 -type invalid\n\n./gen -n 199 -type valid\n./gen -n 199 -type invalid\n\n./gen -n 200 -type valid\n./gen -n 200 -type invalid\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:06:11.334335",
        "total_tutorials": 1,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "31/C",
      "title": "C. Schedule",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains integer n (1 ≤ n ≤ 5000) — amount of groups, which have lessons in the room 31. Then n lines follow, each of them contains two integers li ri (1 ≤ li < ri ≤ 106) — starting and finishing times of lesson of the i-th group. It is possible that initially no two lessons intersect (see sample 1).",
      "output_spec": "OutputOutput integer k — amount of ways to cancel the lesson in exactly one group so that no two time periods of lessons of the remaining groups intersect. In the second line output k numbers — indexes of groups, where it is possible to cancel the lesson. Groups are numbered starting from 1 in the order that they were given in the input. Output the numbers in increasing order.",
      "sample_tests": "ExamplesInputCopy33 1020 301 3OutputCopy31 2 3 InputCopy43 1020 301 31 39OutputCopy14 InputCopy31 52 63 7OutputCopy0",
      "description": "C. Schedule\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains integer n (1 ≤ n ≤ 5000) — amount of groups, which have lessons in the room 31. Then n lines follow, each of them contains two integers li ri (1 ≤ li < ri ≤ 106) — starting and finishing times of lesson of the i-th group. It is possible that initially no two lessons intersect (see sample 1).\n\nOutputOutput integer k — amount of ways to cancel the lesson in exactly one group so that no two time periods of lessons of the remaining groups intersect. In the second line output k numbers — indexes of groups, where it is possible to cancel the lesson. Groups are numbered starting from 1 in the order that they were given in the input. Output the numbers in increasing order.\n\nInputCopy33 1020 301 3OutputCopy31 2 3 InputCopy43 1020 301 31 39OutputCopy14 InputCopy31 52 63 7OutputCopy0\n\nInputCopy33 1020 301 3\n\nOutputCopy31 2 3\n\nInputCopy43 1020 301 31 39\n\nOutputCopy14\n\nInputCopy31 52 63 7\n\nOutputCopy0",
      "solutions": [
        {
          "title": "Codeforces Beta Round 31 (Div. 2, Codeforces format) - Codeforces",
          "content": "Hello everyone on Codeforces Beta Round 31 (Div. 2, Codeforces format)Round was prepared by: Mike Mirzayanov, Dmitry Matov, Max Ivanov and me.Good luck!Artem Rakhov and Codeforces team",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/704",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.5,
            "reason": "宽松匹配: 包含题目编号 31"
          },
          "content_length": 184
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Beta Round 31 (Div. 2, Codeforces format) - Codeforces - Code 1",
          "code": "10\n89959999998998796989",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/704",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 5000, \"n\");\n    inf.readEoln();\n\n    for (int i = 0; i < n; ++i) {\n        int li = inf.readInt(1, 1000000, \"li\");\n        inf.readSpace();\n        int ri = inf.readInt(1, 1000000, \"ri\");\n        inf.readEoln();\n        ensuref(li < ri, \"li (%d) must be less than ri (%d)\", li, ri);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 5000, \"n\");\n    inf.readEoln();\n\n    for (int i = 0; i < n; ++i) {\n        int li = inf.readInt(1, 1000000, \"li\");\n        inf.readSpace();\n        int ri = inf.readInt(1, 1000000, \"ri\");\n        inf.readEoln();\n        ensuref(li < ri, \"li (%d) must be less than ri (%d)\", li, ri);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 5000, \"n\");\n    inf.readEoln();\n\n    for (int i = 0; i < n; ++i) {\n        int li = inf.readInt(1, 1000000, \"li\");\n        inf.readSpace();\n        int ri = inf.readInt(1, 1000000, \"ri\");\n        inf.readEoln();\n        ensuref(li < ri, \"li (%d) must be less than ri (%d)\", li, ri);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<pair<int,int>> intervals;\n\n    if (type == \"random\") {\n        for (int i = 0; i < n; ++i) {\n            int l = rnd.next(1, int(1e6) - 1);\n            int r = rnd.next(l + 1, int(1e6));\n            intervals.push_back({l, r});\n        }\n    } else if (type == \"all_overlapping\") {\n        int l = rnd.next(1, int(1e6) - n);\n        int r = l + rnd.next(1, int(1e6) - l);\n        for (int i = 0; i < n; ++i) {\n            intervals.push_back({l, r});\n        }\n    } else if (type == \"no_overlaps\") {\n        int l = 1;\n        int max_interval = int(1e6) / n;\n        for (int i = 0; i < n; ++i) {\n            int length = rnd.next(1, max_interval);\n            int r = l + length;\n            intervals.push_back({l, r});\n            l = r;\n        }\n    } else if (type == \"touching_intervals\") {\n        int l = 1;\n        int length = max(1, int(1e6) / n);\n        for (int i = 0; i < n; ++i) {\n            int r = l + length;\n            if (r > int(1e6)) r = int(1e6);\n            intervals.push_back({l, r});\n            l = r;\n        }\n    } else if (type == \"same_times\") {\n        int l = rnd.next(1, int(1e6) - 1);\n        int r = l + rnd.next(1, 100);\n        for (int i = 0; i < n; ++i) {\n            intervals.push_back({l, r});\n        }\n    } else if (type == \"nested_intervals\") {\n        int l = rnd.next(1, int(1e6) / 2);\n        int r = rnd.next(int(1e6) / 2, int(1e6));\n        for (int i = 0; i < n; ++i) {\n            intervals.push_back({l, r});\n            l += rnd.next(0, 5);\n            r -= rnd.next(0, 5);\n            if (l >= r) {\n                l = rnd.next(1, int(1e6) / 2);\n                r = rnd.next(int(1e6) / 2, int(1e6));\n            }\n        }\n    } else if (type == \"max_values\") {\n        for (int i = 0; i < n; ++i) {\n            int l = rnd.next(int(1e6) - 1000, int(1e6) - 1);\n            int r = int(1e6);\n            intervals.push_back({l, r});\n        }\n    } else {\n        // default random if type not recognized\n        for (int i = 0; i < n; ++i) {\n            int l = rnd.next(1, int(1e6) - 1);\n            int r = rnd.next(l + 1, int(1e6));\n            intervals.push_back({l, r});\n        }\n    }\n\n    // Output\n    printf(\"%d\\n\", n);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d %d\\n\", intervals[i].first, intervals[i].second);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<pair<int,int>> intervals;\n\n    if (type == \"random\") {\n        for (int i = 0; i < n; ++i) {\n            int l = rnd.next(1, int(1e6) - 1);\n            int r = rnd.next(l + 1, int(1e6));\n            intervals.push_back({l, r});\n        }\n    } else if (type == \"all_overlapping\") {\n        int l = rnd.next(1, int(1e6) - n);\n        int r = l + rnd.next(1, int(1e6) - l);\n        for (int i = 0; i < n; ++i) {\n            intervals.push_back({l, r});\n        }\n    } else if (type == \"no_overlaps\") {\n        int l = 1;\n        int max_interval = int(1e6) / n;\n        for (int i = 0; i < n; ++i) {\n            int length = rnd.next(1, max_interval);\n            int r = l + length;\n            intervals.push_back({l, r});\n            l = r;\n        }\n    } else if (type == \"touching_intervals\") {\n        int l = 1;\n        int length = max(1, int(1e6) / n);\n        for (int i = 0; i < n; ++i) {\n            int r = l + length;\n            if (r > int(1e6)) r = int(1e6);\n            intervals.push_back({l, r});\n            l = r;\n        }\n    } else if (type == \"same_times\") {\n        int l = rnd.next(1, int(1e6) - 1);\n        int r = l + rnd.next(1, 100);\n        for (int i = 0; i < n; ++i) {\n            intervals.push_back({l, r});\n        }\n    } else if (type == \"nested_intervals\") {\n        int l = rnd.next(1, int(1e6) / 2);\n        int r = rnd.next(int(1e6) / 2, int(1e6));\n        for (int i = 0; i < n; ++i) {\n            intervals.push_back({l, r});\n            l += rnd.next(0, 5);\n            r -= rnd.next(0, 5);\n            if (l >= r) {\n                l = rnd.next(1, int(1e6) / 2);\n                r = rnd.next(int(1e6) / 2, int(1e6));\n            }\n        }\n    } else if (type == \"max_values\") {\n        for (int i = 0; i < n; ++i) {\n            int l = rnd.next(int(1e6) - 1000, int(1e6) - 1);\n            int r = int(1e6);\n            intervals.push_back({l, r});\n        }\n    } else {\n        // default random if type not recognized\n        for (int i = 0; i < n; ++i) {\n            int l = rnd.next(1, int(1e6) - 1);\n            int r = rnd.next(l + 1, int(1e6));\n            intervals.push_back({l, r});\n        }\n    }\n\n    // Output\n    printf(\"%d\\n\", n);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d %d\\n\", intervals[i].first, intervals[i].second);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -type random\n./gen -n 2 -type random\n./gen -n 2 -type all_overlapping\n./gen -n 2 -type no_overlaps\n./gen -n 2 -type touching_intervals\n./gen -n 2 -type same_times\n./gen -n 2 -type nested_intervals\n./gen -n 2 -type max_values\n\n./gen -n 10 -type random\n./gen -n 10 -type all_overlapping\n./gen -n 10 -type no_overlaps\n./gen -n 10 -type touching_intervals\n./gen -n 10 -type same_times\n./gen -n 10 -type nested_intervals\n./gen -n 10 -type max_values\n\n./gen -n 100 -type random\n./gen -n 100 -type no_overlaps\n./gen -n 100 -type touching_intervals\n\n./gen -n 1000 -type random\n./gen -n 1000 -type all_overlapping\n./gen -n 1000 -type no_overlaps\n./gen -n 1000 -type touching_intervals\n./gen -n 1000 -type same_times\n./gen -n 1000 -type nested_intervals\n./gen -n 1000 -type max_values\n\n./gen -n 5000 -type random\n./gen -n 5000 -type all_overlapping\n./gen -n 5000 -type no_overlaps\n./gen -n 5000 -type touching_intervals\n./gen -n 5000 -type same_times\n./gen -n 5000 -type nested_intervals\n./gen -n 5000 -type max_values\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:06:13.210340",
        "total_tutorials": 1,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "31/D",
      "title": "D. Chocolate",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains 3 integers W, H and n (1 ≤ W, H, n ≤ 100) — width of the bar, height of the bar and amount of breaks. Each of the following n lines contains four integers xi, 1, yi, 1, xi, 2, yi, 2 — coordinates of the endpoints of the i-th break (0 ≤ xi, 1 ≤ xi, 2 ≤ W, 0 ≤ yi, 1 ≤ yi, 2 ≤ H, or xi, 1 = xi, 2, or yi, 1 = yi, 2). Breaks are given in arbitrary order.It is guaranteed that the set of breaks is correct, i.e. there is some order of the given breaks that each next break divides exactly one part of the bar into two non-empty parts.",
      "output_spec": "OutputOutput n + 1 numbers — areas of the resulting parts in the increasing order.",
      "sample_tests": "ExamplesInputCopy2 2 21 0 1 20 1 1 1OutputCopy1 1 2 InputCopy2 2 31 0 1 20 1 1 11 1 2 1OutputCopy1 1 1 1 InputCopy2 4 20 1 2 10 3 2 3OutputCopy2 2 4",
      "description": "D. Chocolate\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains 3 integers W, H and n (1 ≤ W, H, n ≤ 100) — width of the bar, height of the bar and amount of breaks. Each of the following n lines contains four integers xi, 1, yi, 1, xi, 2, yi, 2 — coordinates of the endpoints of the i-th break (0 ≤ xi, 1 ≤ xi, 2 ≤ W, 0 ≤ yi, 1 ≤ yi, 2 ≤ H, or xi, 1 = xi, 2, or yi, 1 = yi, 2). Breaks are given in arbitrary order.It is guaranteed that the set of breaks is correct, i.e. there is some order of the given breaks that each next break divides exactly one part of the bar into two non-empty parts.\n\nOutputOutput n + 1 numbers — areas of the resulting parts in the increasing order.\n\nInputCopy2 2 21 0 1 20 1 1 1OutputCopy1 1 2 InputCopy2 2 31 0 1 20 1 1 11 1 2 1OutputCopy1 1 1 1 InputCopy2 4 20 1 2 10 3 2 3OutputCopy2 2 4\n\nInputCopy2 2 21 0 1 20 1 1 1\n\nOutputCopy1 1 2\n\nInputCopy2 2 31 0 1 20 1 1 11 1 2 1\n\nOutputCopy1 1 1 1\n\nInputCopy2 4 20 1 2 10 3 2 3\n\nOutputCopy2 2 4",
      "solutions": [
        {
          "title": "Codeforces Beta Round 31 (Div. 2, Codeforces format) - Codeforces",
          "content": "Hello everyone on Codeforces Beta Round 31 (Div. 2, Codeforces format)Round was prepared by: Mike Mirzayanov, Dmitry Matov, Max Ivanov and me.Good luck!Artem Rakhov and Codeforces team",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/704",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.5,
            "reason": "宽松匹配: 包含题目编号 31"
          },
          "content_length": 184
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Beta Round 31 (Div. 2, Codeforces format) - Codeforces - Code 1",
          "code": "10\n89959999998998796989",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/704",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int W = inf.readInt(1, 100, \"W\");\n    inf.readSpace();\n    int H = inf.readInt(1, 100, \"H\");\n    inf.readSpace();\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readEoln();\n\n    for (int i = 0; i < n; ++i) {\n        int xi1 = inf.readInt(0, W, \"xi1\");\n        inf.readSpace();\n        int yi1 = inf.readInt(0, H, \"yi1\");\n        inf.readSpace();\n        int xi2 = inf.readInt(0, W, \"xi2\");\n        inf.readSpace();\n        int yi2 = inf.readInt(0, H, \"yi2\");\n        inf.readEoln();\n\n        ensuref(xi1 <= xi2, \"xi1 (%d) should be <= xi2 (%d)\", xi1, xi2);\n        ensuref(yi1 <= yi2, \"yi1 (%d) should be <= yi2 (%d)\", yi1, yi2);\n        ensuref(xi1 == xi2 || yi1 == yi2, \"Either xi1 (%d) == xi2 (%d) or yi1 (%d) == yi2 (%d)\", xi1, xi2, yi1, yi2);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int W = inf.readInt(1, 100, \"W\");\n    inf.readSpace();\n    int H = inf.readInt(1, 100, \"H\");\n    inf.readSpace();\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readEoln();\n\n    for (int i = 0; i < n; ++i) {\n        int xi1 = inf.readInt(0, W, \"xi1\");\n        inf.readSpace();\n        int yi1 = inf.readInt(0, H, \"yi1\");\n        inf.readSpace();\n        int xi2 = inf.readInt(0, W, \"xi2\");\n        inf.readSpace();\n        int yi2 = inf.readInt(0, H, \"yi2\");\n        inf.readEoln();\n\n        ensuref(xi1 <= xi2, \"xi1 (%d) should be <= xi2 (%d)\", xi1, xi2);\n        ensuref(yi1 <= yi2, \"yi1 (%d) should be <= yi2 (%d)\", yi1, yi2);\n        ensuref(xi1 == xi2 || yi1 == yi2, \"Either xi1 (%d) == xi2 (%d) or yi1 (%d) == yi2 (%d)\", xi1, xi2, yi1, yi2);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int W = inf.readInt(1, 100, \"W\");\n    inf.readSpace();\n    int H = inf.readInt(1, 100, \"H\");\n    inf.readSpace();\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readEoln();\n\n    for (int i = 0; i < n; ++i) {\n        int xi1 = inf.readInt(0, W, \"xi1\");\n        inf.readSpace();\n        int yi1 = inf.readInt(0, H, \"yi1\");\n        inf.readSpace();\n        int xi2 = inf.readInt(0, W, \"xi2\");\n        inf.readSpace();\n        int yi2 = inf.readInt(0, H, \"yi2\");\n        inf.readEoln();\n\n        ensuref(xi1 <= xi2, \"xi1 (%d) should be <= xi2 (%d)\", xi1, xi2);\n        ensuref(yi1 <= yi2, \"yi1 (%d) should be <= yi2 (%d)\", yi1, yi2);\n        ensuref(xi1 == xi2 || yi1 == yi2, \"Either xi1 (%d) == xi2 (%d) or yi1 (%d) == yi2 (%d)\", xi1, xi2, yi1, yi2);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    // Read parameters.\n    int W = opt<int>(\"W\");\n    int H = opt<int>(\"H\");\n    int n = opt<int>(\"n\");\n    // \"type\" can be \"vertical\", \"horizontal\", or \"random\" (default).\n    string type = opt<string>(\"type\", \"random\");\n\n    // We will store all possible valid break lines in this vector.\n    // Each line is represented by (x1, y1, x2, y2).\n    vector<array<int, 4>> lines;\n\n    // Helper lambda to add vertical lines x in [1..W-1], stored as (x,0,x,H).\n    auto addVerticalLines = [&](int countW) {\n        for (int x = 1; x < countW; x++) {\n            lines.push_back({x, 0, x, H});\n        }\n    };\n    // Helper lambda to add horizontal lines y in [1..H-1], stored as (0,y,W,y).\n    auto addHorizontalLines = [&](int countH) {\n        for (int y = 1; y < countH; y++) {\n            lines.push_back({0, y, W, y});\n        }\n    };\n\n    // Depending on \"type\", select which lines to add.\n    if (type == \"vertical\") {\n        // Only vertical lines\n        addVerticalLines(W);\n    }\n    else if (type == \"horizontal\") {\n        // Only horizontal lines\n        addHorizontalLines(H);\n    }\n    else {\n        // \"random\" (default) - add both vertical and horizontal lines\n        addVerticalLines(W);\n        addHorizontalLines(H);\n    }\n\n    // If we do not have enough distinct lines to pick n of them, we cannot proceed.\n    // (n <= 100 and W,H <= 100, so typically this is easy to satisfy if n <= (W-1 + H-1).)\n    if ((int)lines.size() < n) {\n        // Just print an error message to stderr (or you could exit gracefully).\n        cerr << \"Impossible to generate \" << n << \" distinct breaks for W=\" \n             << W << \" and H=\" << H << endl;\n        return 0;\n    }\n\n    // Randomly shuffle all candidate lines.\n    shuffle(lines.begin(), lines.end());\n\n    // Keep only the first n lines.\n    lines.resize(n);\n\n    // Shuffle again so the final order of breaks is random.\n    shuffle(lines.begin(), lines.end());\n\n    // Output the test case:\n    // First line: W H n\n    // Next n lines: each line describes one break (x1 y1 x2 y2).\n    cout << W << \" \" << H << \" \" << n << \"\\n\";\n    for (auto &b : lines) {\n        cout << b[0] << \" \" << b[1] << \" \" << b[2] << \" \" << b[3] << \"\\n\";\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    // Read parameters.\n    int W = opt<int>(\"W\");\n    int H = opt<int>(\"H\");\n    int n = opt<int>(\"n\");\n    // \"type\" can be \"vertical\", \"horizontal\", or \"random\" (default).\n    string type = opt<string>(\"type\", \"random\");\n\n    // We will store all possible valid break lines in this vector.\n    // Each line is represented by (x1, y1, x2, y2).\n    vector<array<int, 4>> lines;\n\n    // Helper lambda to add vertical lines x in [1..W-1], stored as (x,0,x,H).\n    auto addVerticalLines = [&](int countW) {\n        for (int x = 1; x < countW; x++) {\n            lines.push_back({x, 0, x, H});\n        }\n    };\n    // Helper lambda to add horizontal lines y in [1..H-1], stored as (0,y,W,y).\n    auto addHorizontalLines = [&](int countH) {\n        for (int y = 1; y < countH; y++) {\n            lines.push_back({0, y, W, y});\n        }\n    };\n\n    // Depending on \"type\", select which lines to add.\n    if (type == \"vertical\") {\n        // Only vertical lines\n        addVerticalLines(W);\n    }\n    else if (type == \"horizontal\") {\n        // Only horizontal lines\n        addHorizontalLines(H);\n    }\n    else {\n        // \"random\" (default) - add both vertical and horizontal lines\n        addVerticalLines(W);\n        addHorizontalLines(H);\n    }\n\n    // If we do not have enough distinct lines to pick n of them, we cannot proceed.\n    // (n <= 100 and W,H <= 100, so typically this is easy to satisfy if n <= (W-1 + H-1).)\n    if ((int)lines.size() < n) {\n        // Just print an error message to stderr (or you could exit gracefully).\n        cerr << \"Impossible to generate \" << n << \" distinct breaks for W=\" \n             << W << \" and H=\" << H << endl;\n        return 0;\n    }\n\n    // Randomly shuffle all candidate lines.\n    shuffle(lines.begin(), lines.end());\n\n    // Keep only the first n lines.\n    lines.resize(n);\n\n    // Shuffle again so the final order of breaks is random.\n    shuffle(lines.begin(), lines.end());\n\n    // Output the test case:\n    // First line: W H n\n    // Next n lines: each line describes one break (x1 y1 x2 y2).\n    cout << W << \" \" << H << \" \" << n << \"\\n\";\n    for (auto &b : lines) {\n        cout << b[0] << \" \" << b[1] << \" \" << b[2] << \" \" << b[3] << \"\\n\";\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Below are approximately 20 distinct commands illustrating how to run this generator.\n# Each command will print a single test case to standard output.\n\n./gen -W 2 -H 2 -n 1 -type vertical\n./gen -W 2 -H 2 -n 1 -type horizontal\n./gen -W 2 -H 2 -n 1 -type random\n\n./gen -W 3 -H 3 -n 2 -type vertical\n./gen -W 3 -H 3 -n 2 -type horizontal\n./gen -W 3 -H 3 -n 2 -type random\n\n./gen -W 5 -H 2 -n 1 -type horizontal\n./gen -W 5 -H 2 -n 2 -type random\n./gen -W 5 -H 5 -n 4 -type random\n\n./gen -W 7 -H 1 -n 1 -type vertical\n\n./gen -W 2 -H 7 -n 3 -type horizontal\n\n./gen -W 10 -H 10 -n 5 -type vertical\n./gen -W 10 -H 10 -n 5 -type horizontal\n./gen -W 10 -H 10 -n 5 -type random\n\n./gen -W 20 -H 10 -n 10 -type random\n\n./gen -W 30 -H 5 -n 4 -type random\n\n./gen -W 50 -H 50 -n 10 -type random\n\n./gen -W 99 -H 100 -n 10 -type random\n\n./gen -W 100 -H 100 -n 20 -type vertical\n./gen -W 100 -H 100 -n 20 -type horizontal\n./gen -W 100 -H 100 -n 50 -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:06:15.447213",
        "total_tutorials": 1,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "31/E",
      "title": "E. Телеигра",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест2 seconds",
      "memory_limit": "ограничение по памяти на тест256 megabytes",
      "input_spec": "Входные данныеВ первой строке записано число n (1 ≤ n ≤ 18). Во второй строке записано целое число ровно из 2n цифр — число A. Допускаются лидирующие нули.",
      "output_spec": "Выходные данныеВыведите строку из 2n символов «H» и «M» — последовательность ходов Гомера и Мардж, приводящую к максимальному суммарному выигрышу. Каждый игрок должен сделать ровно n ходов. Если решений несколько, выведите любое.",
      "sample_tests": "ПримерыВходные данныеСкопировать21234Выходные данныеСкопироватьHHMMВходные данныеСкопировать29911Выходные данныеСкопироватьHMHM",
      "description": "E. Телеигра\n\nограничение по времени на тест2 seconds\n\nограничение по времени на тест\n\nограничение по памяти на тест256 megabytes\n\nограничение по памяти на тест\n\nвыводstdout\n\nВходные данныеВ первой строке записано число n (1 ≤ n ≤ 18). Во второй строке записано целое число ровно из 2n цифр — число A. Допускаются лидирующие нули.\n\nВходные данные\n\nВыходные данныеВыведите строку из 2n символов «H» и «M» — последовательность ходов Гомера и Мардж, приводящую к максимальному суммарному выигрышу. Каждый игрок должен сделать ровно n ходов. Если решений несколько, выведите любое.\n\nВыходные данные\n\nВходные данныеСкопировать21234Выходные данныеСкопироватьHHMMВходные данныеСкопировать29911Выходные данныеСкопироватьHMHM\n\nВходные данныеСкопировать21234\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопироватьHHMM\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать29911\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопироватьHMHM\n\nВыходные данныеСкопировать\n\nСкопировать",
      "solutions": [
        {
          "title": "Codeforces Beta Round 31 (Div. 2, Codeforces format) - Codeforces",
          "content": "Приветствую всех на Codeforces Beta Round 31 (Div. 2, Codeforces format)Раунд для вас готовили: Михаил Мирзаянов, Дмитрий Матов, Макс Иванов и я.Удачи!Артем Рахов и команда Codeforces",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/704",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.5,
            "reason": "宽松匹配: 包含题目编号 31"
          },
          "content_length": 183
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Beta Round 31 (Div. 2, Codeforces format) - Codeforces - Code 1",
          "code": "4\n1 5\n5 7\n6 9\n9 10",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/704",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Beta Round 31 (Div. 2, Codeforces format) - Codeforces - Code 2",
          "code": "10\n89959999998998796989",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/704",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Beta Round 31 (Div. 2, Codeforces format) - Codeforces - Code 3",
          "code": "10\n89959999998998796989",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/704",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 18, \"n\");\n    inf.readEoln();\n    string regex_pattern = \"[0-9]{\" + to_string(2 * n) + \"}\";\n    string A = inf.readToken(regex_pattern, \"A\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 18, \"n\");\n    inf.readEoln();\n    string regex_pattern = \"[0-9]{\" + to_string(2 * n) + \"}\";\n    string A = inf.readToken(regex_pattern, \"A\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 18, \"n\");\n    inf.readEoln();\n    string regex_pattern = \"[0-9]{\" + to_string(2 * n) + \"}\";\n    string A = inf.readToken(regex_pattern, \"A\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nunsigned long long readAns(InStream& stream, int n, const string& A) {\n    string S = stream.readToken();\n    if ((int)S.size() != 2 * n) {\n        stream.quitf(_wa, \"Invalid move sequence length. Expected %d, found %d\", 2 * n, (int)S.size());\n    }\n    int countH = 0, countM = 0;\n    for (char c : S) {\n        if (c == 'H')\n            countH++;\n        else if (c == 'M')\n            countM++;\n        else {\n            stream.quitf(_wa, \"Invalid character '%c' in move sequence. Only 'H' and 'M' are allowed.\", c);\n        }\n    }\n    if (countH != n || countM != n) {\n        stream.quitf(_wa, \"Each player must make exactly n moves. Found %d moves for H and %d moves for M\", countH, countM);\n    }\n    // Simulate the game\n    string S1 = \"\", S2 = \"\";\n    int pos = 0;\n    for (char c : S) {\n        char digit = A[pos++];\n        if (c == 'H') {\n            S1 += digit;\n        } else {\n            S2 += digit;\n        }\n    }\n    // Convert S1 and S2 to numbers\n    unsigned long long num1 = strtoull(S1.c_str(), NULL, 10);\n    unsigned long long num2 = strtoull(S2.c_str(), NULL, 10);\n    // Compute total prize\n    unsigned long long total_prize = num1 + num2;\n    return total_prize;\n}\n\nint main(int argc, char* argv[]) {\n    registerTestlibCmd(argc, argv);\n\n    int n = inf.readInt(1, 18);\n    string A = inf.readToken();\n    if ((int)A.size() != 2 * n) {\n        quitf(_fail, \"Invalid length of number A in input. Expected %d, found %d\", 2 * n, (int)A.size());\n    }\n\n    // Read judge's answer\n    unsigned long long jans = readAns(ans, n, A);\n    // Read contestant's answer\n    unsigned long long pans = readAns(ouf, n, A);\n\n    if (pans < jans) {\n        quitf(_wa, \"Contestant's total prize (%llu) is less than judge's (%llu)\", pans, jans);\n    } else if (pans == jans) {\n        quitf(_ok, \"Total prize = %llu\", pans);\n    } else {\n        quitf(_fail, \"Contestant's total prize (%llu) is greater than judge's (%llu)\", pans, jans);\n    }\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    assert(1 <= n && n <= 18);\n\n    string A;\n\n    if (type == \"random\") {\n        // Generate random digits, possibly leading zeros.\n        for (int i = 0; i < 2 * n; ++i) {\n            char digit = '0' + rnd.next(10); // digits from '0' to '9'\n            A += digit;\n        }\n    }\n    else if (type == \"all_same_digit\") {\n        // Generate A consisting of the same digit\n        char digit = '0' + rnd.next(10);\n        for (int i = 0; i < 2 * n; ++i) {\n            A += digit;\n        }\n    }\n    else if (type == \"leading_zeros\") {\n        // Generate A starting with leading zeros\n        int num_leading_zeros = rnd.next(1, 2 * n - 1); // At least one leading zero, not all zeros\n        for (int i = 0; i < num_leading_zeros; ++i) {\n            A += '0';\n        }\n        for (int i = num_leading_zeros; i < 2 * n; ++i) {\n            A += '0' + rnd.next(1, 9);\n        }\n    }\n    else if (type == \"increasing\") {\n        // Generate A with increasing digits\n        int start_digit = rnd.next(0, 9);\n        int digit = start_digit;\n        for (int i = 0; i < 2 * n; ++i) {\n            A += '0' + digit;\n            digit = (digit + 1) % 10;\n        }\n    }\n    else if (type == \"decreasing\") {\n        // Generate A with decreasing digits\n        int start_digit = rnd.next(0, 9);\n        int digit = start_digit;\n        for (int i = 0; i < 2 * n; ++i) {\n            A += '0' + digit;\n            digit = (digit + 9) % 10; // Decrease digit modulo 10\n        }\n    }\n    else if (type == \"alternating\") {\n        // Generate A with alternating digits\n        int digit1 = rnd.next(0, 9);\n        int digit2 = rnd.next(0, 9);\n        if (digit1 == digit2) digit2 = (digit2 + 1) % 10; // Ensure digits are different\n        for (int i = 0; i < 2 * n; ++i) {\n            char digit = (i % 2 == 0) ? ('0' + digit1) : ('0' + digit2);\n            A += digit;\n        }\n    }\n    else if (type == \"max_total\") {\n        // Generate A to make the maximum possible total S1 + S2\n        // For example, make all digits '9'\n        for (int i = 0; i < 2 * n; ++i) {\n            A += '9';\n        }\n    }\n    else if (type == \"min_total\") {\n        // Generate A to make the minimum possible total S1 + S2\n        // For example, make all digits '0'\n        for (int i = 0; i < 2 * n; ++i) {\n            A += '0';\n        }\n    }\n    else {\n        // Default to random\n        for (int i = 0; i < 2 * n; ++i) {\n            char digit = '0' + rnd.next(10);\n            A += digit;\n        }\n    }\n\n    // Output n\n    printf(\"%d\\n\", n);\n    // Output A\n    printf(\"%s\\n\", A.c_str());\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    assert(1 <= n && n <= 18);\n\n    string A;\n\n    if (type == \"random\") {\n        // Generate random digits, possibly leading zeros.\n        for (int i = 0; i < 2 * n; ++i) {\n            char digit = '0' + rnd.next(10); // digits from '0' to '9'\n            A += digit;\n        }\n    }\n    else if (type == \"all_same_digit\") {\n        // Generate A consisting of the same digit\n        char digit = '0' + rnd.next(10);\n        for (int i = 0; i < 2 * n; ++i) {\n            A += digit;\n        }\n    }\n    else if (type == \"leading_zeros\") {\n        // Generate A starting with leading zeros\n        int num_leading_zeros = rnd.next(1, 2 * n - 1); // At least one leading zero, not all zeros\n        for (int i = 0; i < num_leading_zeros; ++i) {\n            A += '0';\n        }\n        for (int i = num_leading_zeros; i < 2 * n; ++i) {\n            A += '0' + rnd.next(1, 9);\n        }\n    }\n    else if (type == \"increasing\") {\n        // Generate A with increasing digits\n        int start_digit = rnd.next(0, 9);\n        int digit = start_digit;\n        for (int i = 0; i < 2 * n; ++i) {\n            A += '0' + digit;\n            digit = (digit + 1) % 10;\n        }\n    }\n    else if (type == \"decreasing\") {\n        // Generate A with decreasing digits\n        int start_digit = rnd.next(0, 9);\n        int digit = start_digit;\n        for (int i = 0; i < 2 * n; ++i) {\n            A += '0' + digit;\n            digit = (digit + 9) % 10; // Decrease digit modulo 10\n        }\n    }\n    else if (type == \"alternating\") {\n        // Generate A with alternating digits\n        int digit1 = rnd.next(0, 9);\n        int digit2 = rnd.next(0, 9);\n        if (digit1 == digit2) digit2 = (digit2 + 1) % 10; // Ensure digits are different\n        for (int i = 0; i < 2 * n; ++i) {\n            char digit = (i % 2 == 0) ? ('0' + digit1) : ('0' + digit2);\n            A += digit;\n        }\n    }\n    else if (type == \"max_total\") {\n        // Generate A to make the maximum possible total S1 + S2\n        // For example, make all digits '9'\n        for (int i = 0; i < 2 * n; ++i) {\n            A += '9';\n        }\n    }\n    else if (type == \"min_total\") {\n        // Generate A to make the minimum possible total S1 + S2\n        // For example, make all digits '0'\n        for (int i = 0; i < 2 * n; ++i) {\n            A += '0';\n        }\n    }\n    else {\n        // Default to random\n        for (int i = 0; i < 2 * n; ++i) {\n            char digit = '0' + rnd.next(10);\n            A += digit;\n        }\n    }\n\n    // Output n\n    printf(\"%d\\n\", n);\n    // Output A\n    printf(\"%s\\n\", A.c_str());\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -type random\n./gen -n 1 -type all_same_digit\n./gen -n 1 -type leading_zeros\n./gen -n 1 -type max_total\n./gen -n 1 -type min_total\n\n./gen -n 2 -type random\n./gen -n 2 -type leading_zeros\n./gen -n 2 -type alternating\n./gen -n 2 -type increasing\n./gen -n 2 -type decreasing\n\n./gen -n 5 -type random\n./gen -n 5 -type all_same_digit\n./gen -n 5 -type leading_zeros\n./gen -n 5 -type alternating\n./gen -n 5 -type increasing\n./gen -n 5 -type decreasing\n./gen -n 5 -type max_total\n./gen -n 5 -type min_total\n\n./gen -n 10 -type random\n./gen -n 10 -type all_same_digit\n./gen -n 10 -type leading_zeros\n./gen -n 10 -type alternating\n./gen -n 10 -type increasing\n./gen -n 10 -type decreasing\n./gen -n 10 -type max_total\n./gen -n 10 -type min_total\n\n./gen -n 15 -type random\n./gen -n 15 -type all_same_digit\n./gen -n 15 -type leading_zeros\n./gen -n 15 -type alternating\n./gen -n 15 -type increasing\n./gen -n 15 -type decreasing\n./gen -n 15 -type max_total\n./gen -n 15 -type min_total\n\n./gen -n 18 -type random\n./gen -n 18 -type all_same_digit\n./gen -n 18 -type leading_zeros\n./gen -n 18 -type alternating\n./gen -n 18 -type increasing\n./gen -n 18 -type decreasing\n./gen -n 18 -type max_total\n./gen -n 18 -type min_total\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:06:17.382056",
        "total_tutorials": 1,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "311/A",
      "title": "A. Ближайшая пара",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест2 секунды",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеВ первой строке записаны два целых числа через пробел — n и k (2 ≤ n ≤ 2000, 1 ≤ k ≤ 109).",
      "output_spec": "Выходные данныеЕсли данных, при которых код получит TLE (превышение лимита времени), не существует, выведите «no solution» (без кавычек); в противном случае, выведите n строк, так чтобы i-ая строка содержала два целых числа xi, yi (|xi|, |yi| ≤ 109) — координаты i-ой точки.Должны выполняться следующие условия:  Все точки должны быть различны.  |xi|, |yi| ≤ 109.  После запуска данного кода значение tot должно превосходить k.",
      "sample_tests": "ПримерыВходные данныеСкопировать4 3Выходные данныеСкопировать0 00 11 01 1Входные данныеСкопировать2 100Выходные данныеСкопироватьno solution",
      "description": "A. Ближайшая пара\n\nограничение по времени на тест2 секунды\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвыводstdout\n\nВходные данныеВ первой строке записаны два целых числа через пробел — n и k (2 ≤ n ≤ 2000, 1 ≤ k ≤ 109).\n\nВходные данные\n\nВыходные данныеЕсли данных, при которых код получит TLE (превышение лимита времени), не существует, выведите «no solution» (без кавычек); в противном случае, выведите n строк, так чтобы i-ая строка содержала два целых числа xi, yi (|xi|, |yi| ≤ 109) — координаты i-ой точки.Должны выполняться следующие условия:  Все точки должны быть различны.  |xi|, |yi| ≤ 109.  После запуска данного кода значение tot должно превосходить k.\n\nВыходные данные\n\nВходные данныеСкопировать4 3Выходные данныеСкопировать0 00 11 01 1Входные данныеСкопировать2 100Выходные данныеСкопироватьno solution\n\nВходные данныеСкопировать4 3\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать0 00 11 01 1\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать2 100\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопироватьno solution\n\nВыходные данныеСкопировать\n\nСкопировать",
      "solutions": [
        {
          "title": "Codeforces Round #185 - Codeforces",
          "content": "Всем привет!Раунд Codeforces Round #185 состоится в Воскресенье, 26 Мая, в 19:30 по московскому времени (23:30 по ЦПВ).Организатор раунда — zanoes, а задачи готовили: Div.1E и Div.2B —— zanoes (Жанг Гаощанг), Div.1D и Div.1A —— liouzhou_101 (Ванг Квишенг), Div.1C, Div.1B, Div.2A —— lydrainbowcat (Ли Юдонг) Тестеры — roosephu(Луо Юпинг), FredaShi (Ши Хаойе), sjynoi(Сун Джяю), sevenkplus(Гу Южу), MinakoKojima(Танг Фейху) и Riatre.Выражаем особую благодарность Gerald за помощь в подготовке раунда, MikeMirzayanov за классную платформу и Delinur за перевод.Распределение баллов будет стандартное, 500-1000-1500-2000-2500 в обоих дивизионах. Наверное, эти задачи проще задач из предыдущих китайских раундов :)Это наш первый раунд на Codeforces, надеюсь, он вам понравится. Высоких вам рейтингов и удачи!UPD: Мы очень сожалеем о нашей ошибке. Следующие слова были сказаны автором задачи div1A (div2C) liouzhou_101. http://codeforces.com/blog/entry/7773#comment-134702 . Конечно, это также моя ошибка и ошибка zanoes, что мы не прочитали этот чекер аккуратно и тем самым доставили проблемы Codeforces. Я приношу свои извинения за liouzhou_101, он очень старался сделать хороший контест во время подготовки раунда.UPD2: Раунд считается не рейтинговым.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/7773",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 1248
        },
        {
          "title": "Codeforces Round #185 Editorial - Codeforces",
          "content": "311A - Ближайшая параhttp://codeforces.com/blog/entry/7787311B - Транспортировка кошекP.S. I feel very sorry that I thought it was a traditional DP problem with only 800B code and didn't realize some participants were not familiar with such kind of problems, so I said it was easy. Let a[i] be the distance from hill 1 to hill i, s[i]=a[1]+a[2]+…+a[i].Firstly, we sort the cats by (Ti-a[i]). Then we can divide the cats into P consecutive parts, and plan a feeder for each part. Dynamic Programming can solve this problem.Let f[i,j] indicates the minimum sum of waiting time with i feeders and j cats.f[i,j] = f[i-1,k]+a[j]*(j-k)-s[j]+s[k] = a[j]*j-s[j] + f[i-1,k]+s[k]-a[j]*kThat’s O(PM^2). It’ll get TLE.Let p>q, if p is \"better\" than q, then:f[i-1,p]+s[p]-a[j]*p>f[i-1,q]+s[q]-a[j]*q(f[i-1,p]+s[p])-(f[i-1,q]+s[q])>a[j]*(p-q)g[p]-g[q]>a[j]*(p-q)So we can use Convex hull trick with a queue. Then we get O(MP), which can pass the problem.311C - Достать сокровищеFirstly, we solve such a problem: if we can go exactly k,k1,k2……or kp cells forward each step, what cells can we reach?We divide the H cells into k groups: Group 0,1……k-1. The i-th cell should be in Group (i mod k). If we reach Cell x in Group (x mod k), we can also reach Cell (x+kj , 1<=j<=p) in Group ((x+kj)mod k). If we reach Cell x in Group (x mod k), we can also reach Cell (x+k) in the same group. Let D[i] be the minimum cell we can reach in Group i. Then we can reach all the cells which number are bigger then D[i] in Group i. Regard the groups as points. Regard k,k1,k2……kp as edges. And use a Shortest-Path Algorithm to calculate all D[i]. Notice that there are at most 20 operations of type 1, we are able to run such an algorithm after each of these operations. The total time complexity is O(20*k*20*log(k)) with Dijkstra.Secondly, we build a binary-heap to solve operations of type 2 and 3. Type1 – If a D[i] becomes smaller, we put the new cells we can reach into the heap. Type2 – Decrease a value of a node in the heap, or a cell in the “Treasure Cell” array. Type3 – Ask the biggest node in the heap and delete it. These are basic operations of binary-heap. The time complexity is O(NlogN). In C++, you can also use priority_queue from STL and lazy-tags. So we can solve the whole problem in O(400klogk+NlogN).311D - Куб на отрезкеhttp://codeforces.com/blog/entry/7787311E - Биологhttp://codeforces.com/blog/entry/7847312A - Чье это предложение?We only need to find out if “miao.” is a prefix of the sentence, and if “lala.” is a suffix of the sentence. Pay attention to the situation when both conditions are satisfied.312B - Лучникиhttp://codeforces.com/blog/entry/7847",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/7785",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 311\\s*A"
          },
          "content_length": 2656
        },
        {
          "title": "Codeforces Round #185 Editorial (Div.1 A&D) - Codeforces",
          "content": "311A — The Closest PairP.S. I feel really guilty that I've made an awful mistake on the checker.We read the pseudo code carefully. If we ignore \"break\", tot will be up to .Consider whether we can make such inequality d ≤ p[j].x - p[i].x is always false. The obvious way is to make all points' x coordinates the same. And we can just choose n distinct numbers to be all points' y coordinate.Thus the problem is solved.311D — Interval CubingConsider a number x. If we apply an assignment x = x3, x becomes x3. If we apply such assignment once more, we will get (x3)3 = x32. If we apply such assignment k times, we will get x3k.Thus, we can get such a sequence a0 = x, a1 = x3, a2 = x32, ..., ak = x3k, ....Consider a prime p. From Fermat's Little Theorem, we can get xp - 1 = 1(mod p). Further more, we can get xy = xymod(p - 1)(mod p), here a mod b means the remainder of a divided by b.Fortunately, 348 = 1(mod (95542721 - 1)), thus, x3k = x3kmod48(mod p). In other words, ak = ak + 48, which means the cycle of the sequence is T = 48.Let's come back to the topic. Each time we run a 1-type query, for every i in the range [l, r], we apply such an assignment ai = ai3. At any moment some i has been applied 48 times such assignments, we can consider this i hasn't been applied any assignments before.We can use segment tree to solve this problem. Every node of the segment tree maintains some information: the times that we applied assignments in the node's whole range(it's a lazy tag), current sum of the node's corresponding range and the sum of the node's range after we applied assignments k(1 ≤ k < 48) times.In such a way, we can solve the problem in O(n·T + q·T·logn) time.If you do not realize how to maintain the segment tree clearly, you can view the code 3782263.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/7787",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 311\\s*A"
          },
          "content_length": 1775
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #185 - Codeforces - Code 1",
          "code": "I do not have time to participate in a number of competitions, this one I think I can get a better grade, yes I do , with good grade. But no rating changed.\nI may not to blame the one who hold the round, but I do not want this happen again.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7773",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #185 Editorial - Codeforces - Code 1",
          "code": "FOR i from 1 to n\n    PRINT (n-i,0)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7785",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #185 Editorial - Codeforces - Code 2",
          "code": "FOR i from 1 to n\n    PRINT (n-i,0)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7785",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(2, 2000, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(1, 1000000000, \"k\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(2, 2000, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(1, 1000000000, \"k\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(2, 2000, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(1, 1000000000, \"k\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nstatic long double distance2D(long long x1, long long y1, long long x2, long long y2) {\n    long long dx = x2 - x1;\n    long long dy = y2 - y1;\n    long double dist = sqrt((long double)dx * dx + (long double)dy * dy);\n    return dist;\n}\n\nint main(int argc, char* argv[]) {\n    registerTestlibCmd(argc, argv);\n\n    // 1. Read n and k from the input file.\n    int n = inf.readInt(2, 2000, \"n\");\n    long long k = inf.readLong(1, 1000000000LL, \"k\");\n\n    // 2. Read the first token of the contestant's output (if any).\n    if (!ouf.seekEof()) {\n        string firstToken = ouf.readToken();\n\n        // --- Case A: The output is \"no solution\" ---\n        if (firstToken == \"no\") {\n            // The next token must be \"solution\" if the user is claiming no solution\n            string secondToken = ouf.readToken();\n            if (secondToken != \"solution\") {\n                ouf.quitf(_wa, \"Expected 'no solution' but got 'no %s'\", secondToken.c_str());\n            }\n            // Must not have extra tokens\n            if (!ouf.seekEof()) {\n                ouf.quitf(_wa, \"Extra tokens after 'no solution'\");\n            }\n\n            // Now confirm if \"no solution\" is indeed correct or not\n            // The maximum possible tot is n*(n-1)/2 (if no break is ever triggered).\n            long long maxPossible = (long long)n * (n - 1) / 2;\n            if (maxPossible > k) {\n                ouf.quitf(_wa, \"A solution is possible (maxPossible=%lld > k=%lld), but contestant printed 'no solution'\",\n                          maxPossible, k);\n            } else {\n                // It's correct to say \"no solution\"\n                ouf.quitf(_ok, \"Correctly printed 'no solution'\");\n            }\n        }\n\n        // --- Case B: The output is a list of n points ---\n        // We have already read one token (which we expect to be x-coordinate of the 1st point).\n        // We will parse that token as an integer, then parse n-1 more pairs, for a total of n pairs.\n\n        // 2B(i). We must parse the first token as x0 in range.\n        //        Then parse another token right now as y0\n        //        Then parse the remaining 2*(n-1) tokens similarly.\n\n        // Rewind the first token as integer\n        long long xFirst;\n        // If reading the first token as integer fails, testlib will throw an error automatically\n        xFirst = stoi(firstToken);\n\n        if (xFirst < -1000000000LL || xFirst > 1000000000LL) {\n            ouf.quitf(_wa, \"First x-coordinate = %lld is out of range [-1e9, 1e9]\", xFirst);\n        }\n\n        // Read the y-coordinate for the first point\n        long long yFirst = ouf.readLong(-1000000000LL, 1000000000LL, \"y1\");\n\n        vector<pair<long long, long long>> points;\n        points.push_back({xFirst, yFirst});\n\n        for (int i = 2; i <= n; i++) {\n            long long x = ouf.readLong(-1000000000LL, 1000000000LL, (\"x\" + to_string(i)).c_str());\n            long long y = ouf.readLong(-1000000000LL, 1000000000LL, (\"y\" + to_string(i)).c_str());\n            points.push_back({x, y});\n        }\n\n        // Must not have extra tokens\n        if (!ouf.seekEof()) {\n            ouf.quitf(_wa, \"Extra tokens after reading %d points\", n);\n        }\n\n        // 2B(ii). Check distinctness\n        // A simple way is to use a set\n        set<pair<long long, long long>> st(points.begin(), points.end());\n        if ((int)st.size() != n) {\n            ouf.quitf(_wa, \"Points are not distinct\");\n        }\n\n        // 2B(iii). Replicate the pseudo-code to compute tot\n        // sort p[] by x ascending, then by y ascending\n        sort(points.begin(), points.end(), [&](auto &a, auto &b){\n            if (a.first != b.first) return a.first < b.first;\n            return a.second < b.second;\n        });\n\n        long double d = 1e18L; // INF\n        long long tot = 0LL;\n\n        for (int i = 0; i < n; i++) {\n            for (int j = i+1; j < n; j++) {\n                tot++;\n                // check if p[j].x - p[i].x >= d\n                long long diffX = points[j].first - points[i].first;\n                if ((long double)diffX >= d) {\n                    break; // out of the \"for j\" loop\n                }\n                long double dist = distance2D(points[i].first, points[i].second,\n                                               points[j].first, points[j].second);\n                if (dist < d) {\n                    d = dist;\n                }\n            }\n        }\n\n        // 2B(iv). Check tot > k\n        if (tot <= k) {\n            ouf.quitf(_wa, \"tot=%lld, but it must be greater than k=%lld\", tot, k);\n        } else {\n            ouf.quitf(_ok, \"tot=%lld > k=%lld\", tot, k);\n        }\n    }\n    else {\n        // The contestant gave no output at all...\n        ouf.quitf(_wa, \"No output found\");\n    }\n\n    return 0; // not reached\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\n/*\n   This generator creates a single test for the problem:\n   \"Given n and k (2 <= n <= 2000, 1 <= k <= 1e9), output one line with n and k.\"\n\n   We provide a variety of \"type\" modes to produce different (n, k) pairs,\n   aiming to catch incorrect contestants' solutions. The generator will be run\n   multiple times, each producing a single test case.  \n\n   Usage examples:\n     ./gen -n 10 -k 20\n     ./gen -type random\n     ./gen -type yes\n     ./gen -type no\n     ./gen -type borderline\n     ./gen -type small\n     ./gen -type large\n*/\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    // User-provided (n, k)\n    int userN = opt<int>(\"n\", -1);\n    long long userK = opt<long long>(\"k\", -1);\n    string type = opt<string>(\"type\", \"random\");\n\n    // If the user explicitly gave both n and k, just output them:\n    if (userN != -1 && userK != -1) {\n        // Ensure they satisfy constraints (2 <= n <= 2000, 1 <= k <= 1e9).\n        // In a real contest environment, we might want to check them carefully,\n        // but here we assume the problem setter provides valid values.\n        cout << userN << \" \" << userK << \"\\n\";\n        return 0;\n    }\n\n    // Otherwise, we generate (n, k) according to \"type\".\n    int n;\n    long long k;\n\n    // Helper function to pick a random integer in a closed range [L,R].\n    auto rndRange = [&](long long L, long long R) {\n        // testlib's rnd.next(x,y) is inclusive for integer generation in [x,y].\n        // So we can safely use it here.\n        return rnd.next((long long)L, (long long)R);\n    };\n\n    if (type == \"random\") {\n        // Fully random within constraints\n        n = rndRange(2, 2000);\n        k = rndRange(1, 1000000000LL);\n    }\n    else if (type == \"yes\") {\n        // Guarantee tot = n*(n-1)/2 > k\n        // So pick an n, then choose a k that is strictly less than that total\n        // (provided total <= 1e9).\n        // The maximum for n*(n-1)/2 with n=2000 is 1,999,000 which is < 1e9.\n        // We'll pick an n >= 3 to make sure total is at least 3.\n        n = rndRange(3, 2000);\n        long long totalPairs = (long long)n * (n - 1) / 2;\n        // We want 1 <= k < totalPairs. \n        // We'll pick something around the middle, or random in [1..totalPairs-1].\n        k = rndRange(1, totalPairs - 1);\n    }\n    else if (type == \"no\") {\n        // Guarantee tot = n*(n-1)/2 <= k\n        // So pick an n, then let k >= that total\n        // We can pick k up to 1e9\n        n = rndRange(2, 2000);\n        long long totalPairs = (long long)n * (n - 1) / 2;\n        // We want totalPairs <= k\n        // We'll choose k in [totalPairs, min(1e9, totalPairs+some margin)]\n        long long m = min(1000000000LL, totalPairs + 1000000LL); \n        // in case totalPairs is close to 1e9, this won't exceed 1e9\n        k = rndRange(totalPairs, m);\n    }\n    else if (type == \"borderline\") {\n        // Exactly tot = n*(n-1)/2 = k\n        // We'll choose some n >= 2, then k = that total\n        n = rndRange(2, 2000);\n        long long totalPairs = (long long)n * (n - 1) / 2;\n        k = totalPairs;\n    }\n    else if (type == \"small\") {\n        // Choose small n (like up to 10) and small k up to 100 \n        n = rndRange(2, 10);\n        k = rndRange(1, 100);\n    }\n    else if (type == \"large\") {\n        // Choose large n near 2000, and k up to 1e9\n        n = rndRange(1900, 2000);\n        k = rndRange(500000000LL, 1000000000LL);\n    }\n    else {\n        // Default fallback if an unexpected 'type' is provided\n        n = rndRange(2, 2000);\n        k = rndRange(1, 1000000000LL);\n    }\n\n    // Print the result:\n    cout << n << \" \" << k << \"\\n\";\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\n/*\n   This generator creates a single test for the problem:\n   \"Given n and k (2 <= n <= 2000, 1 <= k <= 1e9), output one line with n and k.\"\n\n   We provide a variety of \"type\" modes to produce different (n, k) pairs,\n   aiming to catch incorrect contestants' solutions. The generator will be run\n   multiple times, each producing a single test case.  \n\n   Usage examples:\n     ./gen -n 10 -k 20\n     ./gen -type random\n     ./gen -type yes\n     ./gen -type no\n     ./gen -type borderline\n     ./gen -type small\n     ./gen -type large\n*/\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    // User-provided (n, k)\n    int userN = opt<int>(\"n\", -1);\n    long long userK = opt<long long>(\"k\", -1);\n    string type = opt<string>(\"type\", \"random\");\n\n    // If the user explicitly gave both n and k, just output them:\n    if (userN != -1 && userK != -1) {\n        // Ensure they satisfy constraints (2 <= n <= 2000, 1 <= k <= 1e9).\n        // In a real contest environment, we might want to check them carefully,\n        // but here we assume the problem setter provides valid values.\n        cout << userN << \" \" << userK << \"\\n\";\n        return 0;\n    }\n\n    // Otherwise, we generate (n, k) according to \"type\".\n    int n;\n    long long k;\n\n    // Helper function to pick a random integer in a closed range [L,R].\n    auto rndRange = [&](long long L, long long R) {\n        // testlib's rnd.next(x,y) is inclusive for integer generation in [x,y].\n        // So we can safely use it here.\n        return rnd.next((long long)L, (long long)R);\n    };\n\n    if (type == \"random\") {\n        // Fully random within constraints\n        n = rndRange(2, 2000);\n        k = rndRange(1, 1000000000LL);\n    }\n    else if (type == \"yes\") {\n        // Guarantee tot = n*(n-1)/2 > k\n        // So pick an n, then choose a k that is strictly less than that total\n        // (provided total <= 1e9).\n        // The maximum for n*(n-1)/2 with n=2000 is 1,999,000 which is < 1e9.\n        // We'll pick an n >= 3 to make sure total is at least 3.\n        n = rndRange(3, 2000);\n        long long totalPairs = (long long)n * (n - 1) / 2;\n        // We want 1 <= k < totalPairs. \n        // We'll pick something around the middle, or random in [1..totalPairs-1].\n        k = rndRange(1, totalPairs - 1);\n    }\n    else if (type == \"no\") {\n        // Guarantee tot = n*(n-1)/2 <= k\n        // So pick an n, then let k >= that total\n        // We can pick k up to 1e9\n        n = rndRange(2, 2000);\n        long long totalPairs = (long long)n * (n - 1) / 2;\n        // We want totalPairs <= k\n        // We'll choose k in [totalPairs, min(1e9, totalPairs+some margin)]\n        long long m = min(1000000000LL, totalPairs + 1000000LL); \n        // in case totalPairs is close to 1e9, this won't exceed 1e9\n        k = rndRange(totalPairs, m);\n    }\n    else if (type == \"borderline\") {\n        // Exactly tot = n*(n-1)/2 = k\n        // We'll choose some n >= 2, then k = that total\n        n = rndRange(2, 2000);\n        long long totalPairs = (long long)n * (n - 1) / 2;\n        k = totalPairs;\n    }\n    else if (type == \"small\") {\n        // Choose small n (like up to 10) and small k up to 100 \n        n = rndRange(2, 10);\n        k = rndRange(1, 100);\n    }\n    else if (type == \"large\") {\n        // Choose large n near 2000, and k up to 1e9\n        n = rndRange(1900, 2000);\n        k = rndRange(500000000LL, 1000000000LL);\n    }\n    else {\n        // Default fallback if an unexpected 'type' is provided\n        n = rndRange(2, 2000);\n        k = rndRange(1, 1000000000LL);\n    }\n\n    // Print the result:\n    cout << n << \" \" << k << \"\\n\";\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Below are example commands to run this generator repeatedly,\n# each producing one test input (n, k) in different scenarios.\n# They do NOT redirect to a file. They simply print to stdout.\n\n# 1) Fixed small input\n./gen -n 2 -k 1\n\n# 2) Another fixed small input\n./gen -n 4 -k 3\n\n# 3) A borderline case where n=4 => totalPairs=6 => k=6\n./gen -n 4 -k 6\n\n# 4) \"borderline\" type (n*(n-1)/2 == k)\n./gen -type borderline\n\n# 5) Another \"borderline\"\n./gen -type borderline\n\n# 6) \"no\" type => n*(n-1)/2 <= k\n./gen -type no\n\n# 7) Another \"no\" type\n./gen -type no\n\n# 8) \"yes\" type => n*(n-1)/2 > k\n./gen -type yes\n\n# 9) Another \"yes\"\n./gen -type yes\n\n# 10) Random\n./gen -type random\n\n# 11) Another random\n./gen -type random\n\n# 12) Small\n./gen -type small\n\n# 13) Another small\n./gen -type small\n\n# 14) Large\n./gen -type large\n\n# 15) Another large\n./gen -type large\n\n# 16) Custom fixed near boundary\n./gen -n 2000 -k 1999000\n\n# 17) Another custom\n./gen -n 2000 -k 1999999\n\n# 18) Another custom\n./gen -n 1999 -k 1\n\n# 19) Next random to ensure coverage\n./gen -type random\n\n# 20) Final random\n./gen -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:06:19.059543",
        "total_tutorials": 3,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "311/B",
      "title": "B. Транспортировка кошек",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест2 секунды",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеВ первой строке входных данных содержится три целых числа n, m, p (2 ≤ n ≤ 105, 1 ≤ m ≤ 105, 1 ≤ p ≤ 100).Во второй строке содержится n - 1 положительных целых чисел d2, d3, ..., dn (1 ≤ di < 104).В каждой из следующих m строк содержится по два целых числа hi и ti (1 ≤ hi ≤ n, 0 ≤ ti ≤ 109).",
      "output_spec": "Выходные данныеВыведите целое число, минимальную сумму времен ожидания всех кошек.Пожалуйста, не используйте спецификатор %lld для чтения и записи 64-битных чисел на С++. Рекомендуется использовать потоки cin, cout или спецификатор %I64d.",
      "sample_tests": "ПримерыВходные данныеСкопировать4 6 21 3 51 02 14 91 102 103 12Выходные данныеСкопировать3",
      "description": "B. Транспортировка кошек\n\nограничение по времени на тест2 секунды\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвыводstdout\n\nВходные данныеВ первой строке входных данных содержится три целых числа n, m, p (2 ≤ n ≤ 105, 1 ≤ m ≤ 105, 1 ≤ p ≤ 100).Во второй строке содержится n - 1 положительных целых чисел d2, d3, ..., dn (1 ≤ di < 104).В каждой из следующих m строк содержится по два целых числа hi и ti (1 ≤ hi ≤ n, 0 ≤ ti ≤ 109).\n\nВходные данные\n\nВыходные данныеВыведите целое число, минимальную сумму времен ожидания всех кошек.Пожалуйста, не используйте спецификатор %lld для чтения и записи 64-битных чисел на С++. Рекомендуется использовать потоки cin, cout или спецификатор %I64d.\n\nВыходные данные\n\nВходные данныеСкопировать4 6 21 3 51 02 14 91 102 103 12Выходные данныеСкопировать3\n\nВходные данныеСкопировать4 6 21 3 51 02 14 91 102 103 12\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать3\n\nВыходные данныеСкопировать\n\nСкопировать",
      "solutions": [
        {
          "title": "Codeforces Round #185 - Codeforces",
          "content": "Всем привет!Раунд Codeforces Round #185 состоится в Воскресенье, 26 Мая, в 19:30 по московскому времени (23:30 по ЦПВ).Организатор раунда — zanoes, а задачи готовили: Div.1E и Div.2B —— zanoes (Жанг Гаощанг), Div.1D и Div.1A —— liouzhou_101 (Ванг Квишенг), Div.1C, Div.1B, Div.2A —— lydrainbowcat (Ли Юдонг) Тестеры — roosephu(Луо Юпинг), FredaShi (Ши Хаойе), sjynoi(Сун Джяю), sevenkplus(Гу Южу), MinakoKojima(Танг Фейху) и Riatre.Выражаем особую благодарность Gerald за помощь в подготовке раунда, MikeMirzayanov за классную платформу и Delinur за перевод.Распределение баллов будет стандартное, 500-1000-1500-2000-2500 в обоих дивизионах. Наверное, эти задачи проще задач из предыдущих китайских раундов :)Это наш первый раунд на Codeforces, надеюсь, он вам понравится. Высоких вам рейтингов и удачи!UPD: Мы очень сожалеем о нашей ошибке. Следующие слова были сказаны автором задачи div1A (div2C) liouzhou_101. http://codeforces.com/blog/entry/7773#comment-134702 . Конечно, это также моя ошибка и ошибка zanoes, что мы не прочитали этот чекер аккуратно и тем самым доставили проблемы Codeforces. Я приношу свои извинения за liouzhou_101, он очень старался сделать хороший контест во время подготовки раунда.UPD2: Раунд считается не рейтинговым.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/7773",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 1248
        },
        {
          "title": "codeforces.com | 524: A timeout occurred",
          "content": "codeforces.com | 524: A timeout occurred A timeout occurred Error code 524 Visit cloudflare.com for more information. 2025-08-23 03:21:38 UTC You Browser Working Singapore Cloudflare Working codeforces.com Host Error What happened? The origin web server timed out responding to this request.The likely cause is an overloaded background task, database or application, stressing the resources on the host web server. What can I do? If you're a visitor of this website: Please try again in a few minutes. If you're the owner of this website: Please refer to the Error 524 article: Contact your hosting provider; check for long-running processes or an overloaded web server. Use status polling of large HTTP processes to avoid this error. Run the long-running scripts on a grey-clouded subdomain. Enterprise customers can increase the timeout setting globally or for specific requests using Cache Rules. Cloudflare Ray ID: 973778ae5ec23f93 • Your IP: Click to reveal 137.132.214.135 • Performance &amp; security by Cloudflare",
          "author": "Unknown",
          "url": "https://codeforces.com/blog/entry/7785",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 1021
        },
        {
          "title": "Codeforces Round #185 Editorial (Div.1 A&D) - Codeforces",
          "content": "311A — The Closest PairP.S. I feel really guilty that I've made an awful mistake on the checker.We read the pseudo code carefully. If we ignore \"break\", tot will be up to .Consider whether we can make such inequality d ≤ p[j].x - p[i].x is always false. The obvious way is to make all points' x coordinates the same. And we can just choose n distinct numbers to be all points' y coordinate.Thus the problem is solved.311D — Interval CubingConsider a number x. If we apply an assignment x = x3, x becomes x3. If we apply such assignment once more, we will get (x3)3 = x32. If we apply such assignment k times, we will get x3k.Thus, we can get such a sequence a0 = x, a1 = x3, a2 = x32, ..., ak = x3k, ....Consider a prime p. From Fermat's Little Theorem, we can get xp - 1 = 1(mod p). Further more, we can get xy = xymod(p - 1)(mod p), here a mod b means the remainder of a divided by b.Fortunately, 348 = 1(mod (95542721 - 1)), thus, x3k = x3kmod48(mod p). In other words, ak = ak + 48, which means the cycle of the sequence is T = 48.Let's come back to the topic. Each time we run a 1-type query, for every i in the range [l, r], we apply such an assignment ai = ai3. At any moment some i has been applied 48 times such assignments, we can consider this i hasn't been applied any assignments before.We can use segment tree to solve this problem. Every node of the segment tree maintains some information: the times that we applied assignments in the node's whole range(it's a lazy tag), current sum of the node's corresponding range and the sum of the node's range after we applied assignments k(1 ≤ k < 48) times.In such a way, we can solve the problem in O(n·T + q·T·logn) time.If you do not realize how to maintain the segment tree clearly, you can view the code 3782263.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/7787",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.6,
            "reason": "宽松匹配: 包含题目编号 311 和字母"
          },
          "content_length": 1775
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #185 - Codeforces - Code 1",
          "code": "I do not have time to participate in a number of competitions, this one I think I can get a better grade, yes I do , with good grade. But no rating changed.\nI may not to blame the one who hold the round, but I do not want this happen again.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7773",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(2, 100000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 100000, \"m\");\n    inf.readSpace();\n    int p = inf.readInt(1, 100, \"p\");\n    inf.readEoln();\n\n    vector<int> d = inf.readInts(n - 1, 1, 9999, \"d\");\n    inf.readEoln();\n\n    for (int i = 0; i < m; i++) {\n        int hi = inf.readInt(1, n, \"hi\");\n        inf.readSpace();\n        int ti = inf.readInt(0, 1000000000, \"ti\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(2, 100000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 100000, \"m\");\n    inf.readSpace();\n    int p = inf.readInt(1, 100, \"p\");\n    inf.readEoln();\n\n    vector<int> d = inf.readInts(n - 1, 1, 9999, \"d\");\n    inf.readEoln();\n\n    for (int i = 0; i < m; i++) {\n        int hi = inf.readInt(1, n, \"hi\");\n        inf.readSpace();\n        int ti = inf.readInt(0, 1000000000, \"ti\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(2, 100000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 100000, \"m\");\n    inf.readSpace();\n    int p = inf.readInt(1, 100, \"p\");\n    inf.readEoln();\n\n    vector<int> d = inf.readInts(n - 1, 1, 9999, \"d\");\n    inf.readEoln();\n\n    for (int i = 0; i < m; i++) {\n        int hi = inf.readInt(1, n, \"hi\");\n        inf.readSpace();\n        int ti = inf.readInt(0, 1000000000, \"ti\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    // Read parameters\n    int n = opt<int>(\"n\");       // number of hills\n    int m = opt<int>(\"m\");       // number of cats\n    int p = opt<int>(\"p\");       // number of feeders\n    int tmax = opt<int>(\"tmax\", 1000000000); // max value for ti\n    int dmax = opt<int>(\"dmax\", 9999); // max value for di\n    string hill_type = opt<string>(\"hill_type\", \"random\");\n    string time_type = opt<string>(\"time_type\", \"random\");\n    string d_type = opt<string>(\"d_type\", \"random\");\n\n    // Now generate di\n    vector<int> d(n);\n    if(d_type == \"constant\") {\n        int d_val = opt<int>(\"d_val\", 1);\n        for(int i = 2; i <= n; i++) {\n            d[i-1] = d_val;\n        }\n    } else if(d_type == \"random\") {\n        int d_min = opt<int>(\"d_min\", 1);\n        for(int i = 2; i <= n; i++) {\n            d[i-1] = rnd.next(d_min, dmax);\n        }\n    } else if(d_type == \"increasing\") {\n        int d_min = opt<int>(\"d_min\", 1);\n        int d_increment = opt<int>(\"d_increment\", 1);\n        int d_val = d_min;\n        for(int i = 2; i <= n; i++) {\n            d[i-1] = d_val;\n            d_val += d_increment;\n            if(d_val > dmax) d_val = dmax;\n        }\n    } else if(d_type == \"decreasing\") {\n        int d_decrement = opt<int>(\"d_decrement\", 1);\n        int d_val = dmax;\n        for(int i = 2; i <= n; i++) {\n            d[i-1] = d_val;\n            d_val -= d_decrement;\n            if(d_val < 1) d_val = 1;\n        }\n    }\n\n    // Generate hi and ti\n    vector<int> hi(m);\n    vector<int> ti(m);\n\n    if(hill_type == \"random\") {\n        for(int i = 0; i < m; i++) {\n            hi[i] = rnd.next(1, n);\n        }\n    } else if(hill_type == \"hill_1\") {\n        for(int i = 0; i < m; i++) {\n            hi[i] = 1;\n        }\n    } else if(hill_type == \"hill_n\") {\n        for(int i = 0; i < m; i++) {\n            hi[i] = n;\n        }\n    } else if(hill_type == \"same\") {\n        int hill = opt<int>(\"hill\", n/2);\n        for(int i = 0; i < m; i++) {\n            hi[i] = hill;\n        }\n    } else if(hill_type == \"sequence\") {\n        for(int i = 0; i < m; i++) {\n            hi[i] = (i % n) + 1;\n        }\n    } else if(hill_type == \"reverse_sequence\") {\n        for(int i = 0; i < m; i++) {\n            hi[i] = n - (i % n);\n        }\n    }\n\n    if(time_type == \"random\") {\n        for(int i = 0; i < m; i++) {\n            ti[i] = rnd.next(0, tmax);\n        }\n    } else if(time_type == \"zero\") {\n        for(int i = 0; i < m; i++) {\n            ti[i] = 0;\n        }\n    } else if(time_type == \"max\") {\n        for(int i = 0; i < m; i++) {\n            ti[i] = tmax;\n        }\n    } else if(time_type == \"same\") {\n        int t_val = opt<int>(\"t\", 0);\n        for(int i = 0; i < m; i++) {\n            ti[i] = t_val;\n        }\n    } else if(time_type == \"increasing\") {\n        int t_start = opt<int>(\"t_start\", 0);\n        int t_step = opt<int>(\"t_step\", 1);\n        int t_val = t_start;\n        for(int i = 0; i < m; i++) {\n            ti[i] = t_val;\n            t_val += t_step;\n            if(t_val > tmax) t_val = tmax;\n        }\n    } else if(time_type == \"decreasing\") {\n        int t_start = tmax;\n        int t_step = opt<int>(\"t_step\", 1);\n        int t_val = t_start;\n        for(int i = 0; i < m; i++) {\n            ti[i] = t_val;\n            t_val -= t_step;\n            if(t_val < 0) t_val = 0;\n        }\n    }\n\n    // Output\n    printf(\"%d %d %d\\n\", n, m, p);\n\n    // Output distances: di for i = 2 to n\n    for(int i = 2; i <= n; i++) {\n        printf(\"%d\", d[i-1]);\n        if(i != n)\n            printf(\" \");\n        else\n            printf(\"\\n\");\n    }\n\n    for(int i = 0; i < m; i++) {\n        printf(\"%d %d\\n\", hi[i], ti[i]);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    // Read parameters\n    int n = opt<int>(\"n\");       // number of hills\n    int m = opt<int>(\"m\");       // number of cats\n    int p = opt<int>(\"p\");       // number of feeders\n    int tmax = opt<int>(\"tmax\", 1000000000); // max value for ti\n    int dmax = opt<int>(\"dmax\", 9999); // max value for di\n    string hill_type = opt<string>(\"hill_type\", \"random\");\n    string time_type = opt<string>(\"time_type\", \"random\");\n    string d_type = opt<string>(\"d_type\", \"random\");\n\n    // Now generate di\n    vector<int> d(n);\n    if(d_type == \"constant\") {\n        int d_val = opt<int>(\"d_val\", 1);\n        for(int i = 2; i <= n; i++) {\n            d[i-1] = d_val;\n        }\n    } else if(d_type == \"random\") {\n        int d_min = opt<int>(\"d_min\", 1);\n        for(int i = 2; i <= n; i++) {\n            d[i-1] = rnd.next(d_min, dmax);\n        }\n    } else if(d_type == \"increasing\") {\n        int d_min = opt<int>(\"d_min\", 1);\n        int d_increment = opt<int>(\"d_increment\", 1);\n        int d_val = d_min;\n        for(int i = 2; i <= n; i++) {\n            d[i-1] = d_val;\n            d_val += d_increment;\n            if(d_val > dmax) d_val = dmax;\n        }\n    } else if(d_type == \"decreasing\") {\n        int d_decrement = opt<int>(\"d_decrement\", 1);\n        int d_val = dmax;\n        for(int i = 2; i <= n; i++) {\n            d[i-1] = d_val;\n            d_val -= d_decrement;\n            if(d_val < 1) d_val = 1;\n        }\n    }\n\n    // Generate hi and ti\n    vector<int> hi(m);\n    vector<int> ti(m);\n\n    if(hill_type == \"random\") {\n        for(int i = 0; i < m; i++) {\n            hi[i] = rnd.next(1, n);\n        }\n    } else if(hill_type == \"hill_1\") {\n        for(int i = 0; i < m; i++) {\n            hi[i] = 1;\n        }\n    } else if(hill_type == \"hill_n\") {\n        for(int i = 0; i < m; i++) {\n            hi[i] = n;\n        }\n    } else if(hill_type == \"same\") {\n        int hill = opt<int>(\"hill\", n/2);\n        for(int i = 0; i < m; i++) {\n            hi[i] = hill;\n        }\n    } else if(hill_type == \"sequence\") {\n        for(int i = 0; i < m; i++) {\n            hi[i] = (i % n) + 1;\n        }\n    } else if(hill_type == \"reverse_sequence\") {\n        for(int i = 0; i < m; i++) {\n            hi[i] = n - (i % n);\n        }\n    }\n\n    if(time_type == \"random\") {\n        for(int i = 0; i < m; i++) {\n            ti[i] = rnd.next(0, tmax);\n        }\n    } else if(time_type == \"zero\") {\n        for(int i = 0; i < m; i++) {\n            ti[i] = 0;\n        }\n    } else if(time_type == \"max\") {\n        for(int i = 0; i < m; i++) {\n            ti[i] = tmax;\n        }\n    } else if(time_type == \"same\") {\n        int t_val = opt<int>(\"t\", 0);\n        for(int i = 0; i < m; i++) {\n            ti[i] = t_val;\n        }\n    } else if(time_type == \"increasing\") {\n        int t_start = opt<int>(\"t_start\", 0);\n        int t_step = opt<int>(\"t_step\", 1);\n        int t_val = t_start;\n        for(int i = 0; i < m; i++) {\n            ti[i] = t_val;\n            t_val += t_step;\n            if(t_val > tmax) t_val = tmax;\n        }\n    } else if(time_type == \"decreasing\") {\n        int t_start = tmax;\n        int t_step = opt<int>(\"t_step\", 1);\n        int t_val = t_start;\n        for(int i = 0; i < m; i++) {\n            ti[i] = t_val;\n            t_val -= t_step;\n            if(t_val < 0) t_val = 0;\n        }\n    }\n\n    // Output\n    printf(\"%d %d %d\\n\", n, m, p);\n\n    // Output distances: di for i = 2 to n\n    for(int i = 2; i <= n; i++) {\n        printf(\"%d\", d[i-1]);\n        if(i != n)\n            printf(\" \");\n        else\n            printf(\"\\n\");\n    }\n\n    for(int i = 0; i < m; i++) {\n        printf(\"%d %d\\n\", hi[i], ti[i]);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Small case with minimal values\n./gen -n 2 -m 1 -p 1 -d_type constant -d_val 1 -hill_type hill_1 -time_type zero\n\n# Maximal n and m, minimal p\n./gen -n 100000 -m 100000 -p 1 -d_type constant -d_val 1 -hill_type random -time_type random\n\n# Maximal n and m, maximal p\n./gen -n 100000 -m 100000 -p 100 -d_type constant -d_val 1 -hill_type random -time_type random\n\n# All cats at hill 1\n./gen -n 10 -m 100 -p 1 -d_type constant -d_val 1 -hill_type hill_1 -time_type random\n\n# All cats at hill n, time zero\n./gen -n 10 -m 100 -p 1 -d_type constant -d_val 1 -hill_type hill_n -time_type zero\n\n# All cats finish trips at time zero\n./gen -n 1000 -m 50000 -p 10 -d_type constant -d_val 1 -hill_type random -time_type zero\n\n# All cats finish trips at tmax\n./gen -n 1000 -m 50000 -p 10 -d_type constant -d_val 1 -hill_type random -time_type max\n\n# di increasing\n./gen -n 10000 -m 50000 -p 50 -d_type increasing -d_min 1 -d_increment 1 -hill_type random -time_type random\n\n# di decreasing\n./gen -n 10000 -m 50000 -p 50 -d_type decreasing -d_decrement 1 -dmax 9999 -hill_type random -time_type random\n\n# All cats finish trips at same time\n./gen -n 5000 -m 10000 -p 20 -d_type random -hill_type random -time_type same -t 1000000000\n\n# Cats at same hill (mid hill)\n./gen -n 10000 -m 100000 -p 30 -d_type constant -d_val 1 -hill_type same -hill 5000 -time_type random\n\n# Time increasing\n./gen -n 10000 -m 100000 -p 30 -d_type constant -d_val 1 -hill_type random -time_type increasing -t_start 0 -t_step 1\n\n# Time decreasing\n./gen -n 10000 -m 100000 -p 30 -d_type constant -d_val 1 -hill_type random -time_type decreasing -t_step 1\n\n# Cats at hills in sequence\n./gen -n 1000 -m 1000 -p 10 -d_type constant -d_val 1 -hill_type sequence -time_type random\n\n# Cats at hills in reverse sequence\n./gen -n 1000 -m 1000 -p 10 -d_type constant -d_val 1 -hill_type reverse_sequence -time_type random\n\n# Maximal distances\n./gen -n 100000 -m 100000 -p 50 -d_type constant -d_val 9999 -hill_type random -time_type random\n\n# Minimal distances\n./gen -n 100000 -m 100000 -p 50 -d_type constant -d_val 1 -hill_type random -time_type random\n\n# Mix of hill types and time types\n./gen -n 20000 -m 50000 -p 25 -d_type random -d_min 1 -dmax 9999 -hill_type random -time_type random\n\n# Large p\n./gen -n 100000 -m 100000 -p 100 -d_type constant -d_val 1 -hill_type random -time_type random\n\n# Small p\n./gen -n 100000 -m 100000 -p 1 -d_type constant -d_val 1 -hill_type random -time_type random\n\n# Cats finish trips at time in [0,tmax/2]\n./gen -n 50000 -m 100000 -p 50 -d_type random -hill_type random -time_type random -tmax 500000000\n\n# Cats finish trips at time in [tmax/2, tmax]\n./gen -n 50000 -m 100000 -p 50 -d_type random -hill_type random -time_type random -tmax 1000000000\n\n# Cats finish trips at time in [0, 100]\n./gen -n 10000 -m 100000 -p 20 -d_type constant -d_val 1 -hill_type random -time_type random -tmax 100\n\n# All together: Max n, m, p, distances, times\n./gen -n 100000 -m 100000 -p 100 -d_type constant -d_val 9999 -hill_type random -time_type random -tmax 1000000000\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:06:20.816664",
        "total_tutorials": 3,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "311/C",
      "title": "C. Fetch the Treasure",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test3 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line of the input contains four integers: h (1 ≤ h ≤ 1018), n, m (1 ≤ n, m ≤ 105) and k (1 ≤ k ≤ 104).Each of the next n lines contains two integers: ai (1 ≤ ai ≤ h), ci (1 ≤ ci ≤ 109). That means the i-th \"Treasure Cell\" is the ai-th cell and cost of the treasure in that cell is ci dollars. All the ai are distinct.Each of the next m lines is in one of the three following formats:  \"1 x\" — an operation of type 1, 1 ≤ x ≤ h;  \"2 x y\" — an operation of type 2, 1 ≤ x ≤ n, 0 ≤ y < cx;  \"3\" — an operation of type 3. There are at most 20 operations of type 1. It's guaranteed that at any moment treasure in each cell has positive value. It's guaranteed that all operations is correct (no operation can decrease the value of the taken tresure).Please, do not use the %lld specifier to read 64-bit integers in С++. It is preferred to use the cin, cout streams or the %I64d specifier.",
      "output_spec": "OutputFor each operation of type 3, output an integer indicates the value (in dollars) of the most valuable treasure among the \"Treasure Cells\" Freda can reach. If there is no such treasure, output 0.",
      "sample_tests": "ExamplesInputCopy10 3 5 25 507 608 1002 2 531 333OutputCopy5510050",
      "description": "C. Fetch the Treasure\n\ntime limit per test3 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line of the input contains four integers: h (1 ≤ h ≤ 1018), n, m (1 ≤ n, m ≤ 105) and k (1 ≤ k ≤ 104).Each of the next n lines contains two integers: ai (1 ≤ ai ≤ h), ci (1 ≤ ci ≤ 109). That means the i-th \"Treasure Cell\" is the ai-th cell and cost of the treasure in that cell is ci dollars. All the ai are distinct.Each of the next m lines is in one of the three following formats:  \"1 x\" — an operation of type 1, 1 ≤ x ≤ h;  \"2 x y\" — an operation of type 2, 1 ≤ x ≤ n, 0 ≤ y < cx;  \"3\" — an operation of type 3. There are at most 20 operations of type 1. It's guaranteed that at any moment treasure in each cell has positive value. It's guaranteed that all operations is correct (no operation can decrease the value of the taken tresure).Please, do not use the %lld specifier to read 64-bit integers in С++. It is preferred to use the cin, cout streams or the %I64d specifier.\n\nOutputFor each operation of type 3, output an integer indicates the value (in dollars) of the most valuable treasure among the \"Treasure Cells\" Freda can reach. If there is no such treasure, output 0.\n\nInputCopy10 3 5 25 507 608 1002 2 531 333OutputCopy5510050\n\nInputCopy10 3 5 25 507 608 1002 2 531 333\n\nOutputCopy5510050\n\nNoteIn the sample, there are 10 cells and 3 \"Treasure Cells\". The first \"Treasure Cell\" is cell 5, having 50 dollars tresure in it. The second \"Treasure Cell\" is cell 7, having 60 dollars tresure in it. The third \"Treasure Cell\" is cell 8, having 100 dollars tresure in it.At first, Freda can only reach cell 1, 3, 5, 7 and 9. In the first operation, we reduce the value in the second \"Treasure Cell\" from 60 to 55. Then the most valuable treasure among the \"Treasure Cells\" she can reach is max(50, 55) = 55. After the third operation, she can also go 3 cells forward each step, being able to reach cell 1, 3, 4, 5, 6, 7, 8, 9, 10. So the most valuable tresure is 100.Noticed that she took the 55 dollars and 100 dollars treasure away, so the last answer is 50.",
      "solutions": [
        {
          "title": "Codeforces Round #185 - Codeforces",
          "content": "Hello,everyone!Codeforces Round #185 will take place on Sunday, May 26th at 19:30MSK (23:30CST).This round is initiated by zanoes, and here are the problem setters: Div.1E & Div.2B —— zanoes (**Zhang Gaoxiang**) Div.1D & Div.1A —— liouzhou_101 (**Wang Qisheng**) Div.1C & Div.1B & Div.2A —— lydrainbowcat (**Li Yudong**) Testers are roosephu(Luo Yuping), FredaShi(Shi Haoyue), sjynoi(Sun Jiayu), sevenkplus(Gu Yuzhou), MinakoKojima(Tang Feihu) and Riatre.Especially thanks Gerald for helping us to prepare the round, MikeMirzayanov for the great platform and Delinur for translation.Score will be standard, 500-1000-1500-2000-2500 in both divisions. In our opinion, problems are easier than the past several rounds prepared by Chinese)This is our first Codeforces round, I hope you can enjoy it. Wish you high rating and good luck!UPD: We feel really sorry about the mistake we made. The following words were written by Div.1A (Div.2C)setter, liouzhou_101. http://codeforces.com/blog/entry/7773#comment-134702 . Meanwhile, It's also zanoes's and my fault that we didn't check his checker carefully, even brought troubles to Codeforces flat. I beg your forgive for liouzhou_101, for he also tried to prepare the round well these days. UPD2: The round will be unrated.Editorials will come out soon. Now you can find some of the editorials here: http://codeforces.com/blog/entry/7785Contest is over. Congratulations to the winners.Div.1 zfmdhy786 (I promise it's someone who pretends to be roosephu, and I've known who he is.) cp12321 RAD ACMonster kAc And ryz , cgy4ever, who passed problem E in the contest.Div.2 ymxlkAc sasha.sochka bohuss",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/7773",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1639
        },
        {
          "title": "Codeforces Round #185 Editorial - Codeforces",
          "content": "311A - Ближайшая параhttp://codeforces.com/blog/entry/7787311B - Транспортировка кошекP.S. I feel very sorry that I thought it was a traditional DP problem with only 800B code and didn't realize some participants were not familiar with such kind of problems, so I said it was easy. Let a[i] be the distance from hill 1 to hill i, s[i]=a[1]+a[2]+…+a[i].Firstly, we sort the cats by (Ti-a[i]). Then we can divide the cats into P consecutive parts, and plan a feeder for each part. Dynamic Programming can solve this problem.Let f[i,j] indicates the minimum sum of waiting time with i feeders and j cats.f[i,j] = f[i-1,k]+a[j]*(j-k)-s[j]+s[k] = a[j]*j-s[j] + f[i-1,k]+s[k]-a[j]*kThat’s O(PM^2). It’ll get TLE.Let p>q, if p is \"better\" than q, then:f[i-1,p]+s[p]-a[j]*p>f[i-1,q]+s[q]-a[j]*q(f[i-1,p]+s[p])-(f[i-1,q]+s[q])>a[j]*(p-q)g[p]-g[q]>a[j]*(p-q)So we can use Convex hull trick with a queue. Then we get O(MP), which can pass the problem.311C - Достать сокровищеFirstly, we solve such a problem: if we can go exactly k,k1,k2……or kp cells forward each step, what cells can we reach?We divide the H cells into k groups: Group 0,1……k-1. The i-th cell should be in Group (i mod k). If we reach Cell x in Group (x mod k), we can also reach Cell (x+kj , 1<=j<=p) in Group ((x+kj)mod k). If we reach Cell x in Group (x mod k), we can also reach Cell (x+k) in the same group. Let D[i] be the minimum cell we can reach in Group i. Then we can reach all the cells which number are bigger then D[i] in Group i. Regard the groups as points. Regard k,k1,k2……kp as edges. And use a Shortest-Path Algorithm to calculate all D[i]. Notice that there are at most 20 operations of type 1, we are able to run such an algorithm after each of these operations. The total time complexity is O(20*k*20*log(k)) with Dijkstra.Secondly, we build a binary-heap to solve operations of type 2 and 3. Type1 – If a D[i] becomes smaller, we put the new cells we can reach into the heap. Type2 – Decrease a value of a node in the heap, or a cell in the “Treasure Cell” array. Type3 – Ask the biggest node in the heap and delete it. These are basic operations of binary-heap. The time complexity is O(NlogN). In C++, you can also use priority_queue from STL and lazy-tags. So we can solve the whole problem in O(400klogk+NlogN).311D - Куб на отрезкеhttp://codeforces.com/blog/entry/7787311E - Биологhttp://codeforces.com/blog/entry/7847312A - Чье это предложение?We only need to find out if “miao.” is a prefix of the sentence, and if “lala.” is a suffix of the sentence. Pay attention to the situation when both conditions are satisfied.312B - Лучникиhttp://codeforces.com/blog/entry/7847",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/7785",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 311\\s*C"
          },
          "content_length": 2656
        },
        {
          "title": "Codeforces Round #185 Editorial (Div.1 A&D) - Codeforces",
          "content": "311A — The Closest PairP.S. I feel really guilty that I've made an awful mistake on the checker.We read the pseudo code carefully. If we ignore \"break\", tot will be up to .Consider whether we can make such inequality d ≤ p[j].x - p[i].x is always false. The obvious way is to make all points' x coordinates the same. And we can just choose n distinct numbers to be all points' y coordinate.Thus the problem is solved.311D — Interval CubingConsider a number x. If we apply an assignment x = x3, x becomes x3. If we apply such assignment once more, we will get (x3)3 = x32. If we apply such assignment k times, we will get x3k.Thus, we can get such a sequence a0 = x, a1 = x3, a2 = x32, ..., ak = x3k, ....Consider a prime p. From Fermat's Little Theorem, we can get xp - 1 = 1(mod p). Further more, we can get xy = xymod(p - 1)(mod p), here a mod b means the remainder of a divided by b.Fortunately, 348 = 1(mod (95542721 - 1)), thus, x3k = x3kmod48(mod p). In other words, ak = ak + 48, which means the cycle of the sequence is T = 48.Let's come back to the topic. Each time we run a 1-type query, for every i in the range [l, r], we apply such an assignment ai = ai3. At any moment some i has been applied 48 times such assignments, we can consider this i hasn't been applied any assignments before.We can use segment tree to solve this problem. Every node of the segment tree maintains some information: the times that we applied assignments in the node's whole range(it's a lazy tag), current sum of the node's corresponding range and the sum of the node's range after we applied assignments k(1 ≤ k < 48) times.In such a way, we can solve the problem in O(n·T + q·T·logn) time.If you do not realize how to maintain the segment tree clearly, you can view the code 3782263.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/7787",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.6,
            "reason": "宽松匹配: 包含题目编号 311 和字母"
          },
          "content_length": 1775
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #185 - Codeforces - Code 1",
          "code": "I do not have time to participate in a number of competitions, this one I think I can get a better grade, yes I do , with good grade. But no rating changed.\nI may not to blame the one who hold the round, but I do not want this happen again.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7773",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #185 Editorial - Codeforces - Code 1",
          "code": "FOR i from 1 to n\n    PRINT (n-i,0)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7785",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #185 Editorial - Codeforces - Code 2",
          "code": "FOR i from 1 to n\n    PRINT (n-i,0)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7785",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    // Read h, n, m, k\n    long long h = inf.readLong(1LL, 1e18, \"h\");\n    inf.readSpace();\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 100000, \"m\");\n    inf.readSpace();\n    int k = inf.readInt(1, 10000, \"k\");\n    inf.readEoln();\n\n    set<long long> treasure_cells;\n    vector<int> ci(n + 1); // 1-based indexing\n\n    for (int i = 1; i <= n; ++i) {\n        long long ai = inf.readLong(1LL, h, \"ai\");\n        inf.readSpace();\n        int ci_i = inf.readInt(1, 1000000000, \"ci\");\n        inf.readEoln();\n\n        ensuref(treasure_cells.find(ai) == treasure_cells.end(), \"Duplicate ai found: %lld\", ai);\n        treasure_cells.insert(ai);\n        ci[i] = ci_i;\n    }\n\n    int type1_count = 0;\n    for (int op = 1; op <= m; ++op) {\n        int op_type = inf.readInt(1, 3, \"op_type\");\n        if (op_type == 1) {\n            inf.readSpace();\n            long long x = inf.readLong(1LL, h, \"x\");\n            inf.readEoln();\n\n            ++type1_count;\n            ensuref(type1_count <= 20, \"More than 20 operations of type 1\");\n        } else if (op_type == 2) {\n            inf.readSpace();\n            int x = inf.readInt(1, n, \"x\");\n            inf.readSpace();\n            ensuref(ci[x] >= 1, \"Treasure in cell %d has non-positive value before operation\", x);\n            int y = inf.readInt(0, ci[x] - 1, \"y\");\n            inf.readEoln();\n\n            ci[x] -= y;\n            ensuref(ci[x] > 0, \"Treasure value in cell %d became non-positive after operation\", x);\n        } else if (op_type == 3) {\n            inf.readEoln();\n        } else {\n            // Should not happen since op_type ∈ [1,3]\n            ensuref(false, \"Invalid operation type: %d\", op_type);\n        }\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    // Read h, n, m, k\n    long long h = inf.readLong(1LL, 1e18, \"h\");\n    inf.readSpace();\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 100000, \"m\");\n    inf.readSpace();\n    int k = inf.readInt(1, 10000, \"k\");\n    inf.readEoln();\n\n    set<long long> treasure_cells;\n    vector<int> ci(n + 1); // 1-based indexing\n\n    for (int i = 1; i <= n; ++i) {\n        long long ai = inf.readLong(1LL, h, \"ai\");\n        inf.readSpace();\n        int ci_i = inf.readInt(1, 1000000000, \"ci\");\n        inf.readEoln();\n\n        ensuref(treasure_cells.find(ai) == treasure_cells.end(), \"Duplicate ai found: %lld\", ai);\n        treasure_cells.insert(ai);\n        ci[i] = ci_i;\n    }\n\n    int type1_count = 0;\n    for (int op = 1; op <= m; ++op) {\n        int op_type = inf.readInt(1, 3, \"op_type\");\n        if (op_type == 1) {\n            inf.readSpace();\n            long long x = inf.readLong(1LL, h, \"x\");\n            inf.readEoln();\n\n            ++type1_count;\n            ensuref(type1_count <= 20, \"More than 20 operations of type 1\");\n        } else if (op_type == 2) {\n            inf.readSpace();\n            int x = inf.readInt(1, n, \"x\");\n            inf.readSpace();\n            ensuref(ci[x] >= 1, \"Treasure in cell %d has non-positive value before operation\", x);\n            int y = inf.readInt(0, ci[x] - 1, \"y\");\n            inf.readEoln();\n\n            ci[x] -= y;\n            ensuref(ci[x] > 0, \"Treasure value in cell %d became non-positive after operation\", x);\n        } else if (op_type == 3) {\n            inf.readEoln();\n        } else {\n            // Should not happen since op_type ∈ [1,3]\n            ensuref(false, \"Invalid operation type: %d\", op_type);\n        }\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    // Read h, n, m, k\n    long long h = inf.readLong(1LL, 1e18, \"h\");\n    inf.readSpace();\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 100000, \"m\");\n    inf.readSpace();\n    int k = inf.readInt(1, 10000, \"k\");\n    inf.readEoln();\n\n    set<long long> treasure_cells;\n    vector<int> ci(n + 1); // 1-based indexing\n\n    for (int i = 1; i <= n; ++i) {\n        long long ai = inf.readLong(1LL, h, \"ai\");\n        inf.readSpace();\n        int ci_i = inf.readInt(1, 1000000000, \"ci\");\n        inf.readEoln();\n\n        ensuref(treasure_cells.find(ai) == treasure_cells.end(), \"Duplicate ai found: %lld\", ai);\n        treasure_cells.insert(ai);\n        ci[i] = ci_i;\n    }\n\n    int type1_count = 0;\n    for (int op = 1; op <= m; ++op) {\n        int op_type = inf.readInt(1, 3, \"op_type\");\n        if (op_type == 1) {\n            inf.readSpace();\n            long long x = inf.readLong(1LL, h, \"x\");\n            inf.readEoln();\n\n            ++type1_count;\n            ensuref(type1_count <= 20, \"More than 20 operations of type 1\");\n        } else if (op_type == 2) {\n            inf.readSpace();\n            int x = inf.readInt(1, n, \"x\");\n            inf.readSpace();\n            ensuref(ci[x] >= 1, \"Treasure in cell %d has non-positive value before operation\", x);\n            int y = inf.readInt(0, ci[x] - 1, \"y\");\n            inf.readEoln();\n\n            ci[x] -= y;\n            ensuref(ci[x] > 0, \"Treasure value in cell %d became non-positive after operation\", x);\n        } else if (op_type == 3) {\n            inf.readEoln();\n        } else {\n            // Should not happen since op_type ∈ [1,3]\n            ensuref(false, \"Invalid operation type: %d\", op_type);\n        }\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\n/*\n * This generator creates test data for the described problem:\n *   h (1 ≤ h ≤ 10^18), n, m (1 ≤ n, m ≤ 10^5), k (1 ≤ k ≤ 10^4), \n *   distinct ai (1 ≤ ai ≤ h), and ci (1 ≤ ci ≤ 10^9).\n *   Then m operations follow:\n *     1) \"1 x\" with (1 ≤ x ≤ h),\n *     2) \"2 x y\" with (1 ≤ x ≤ n), (0 ≤ y < c_x),\n *     3) \"3\".\n *   We ensure at most 20 ops of type 1 and keep c_x positive.\n */\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    // Required command-line arguments.\n    // e.g. ./gen -h 1000 -n 5 -m 10 -k 2 -type random\n    long long h = opt<long long>(\"h\", 1000LL); // default = 1000 if not provided\n    int n = opt<int>(\"n\", 5);                  // default = 5\n    int m = opt<int>(\"m\", 10);                 // default = 10\n    long long k = opt<long long>(\"k\", 2LL);    // default = 2\n    string testType = opt<string>(\"type\", \"random\"); \n\n    // -------------------\n    // 1) Output line: h, n, m, k\n    // -------------------\n    cout << h << \" \" << n << \" \" << m << \" \" << k << \"\\n\";\n\n    // -------------------\n    // 2) Generate distinct cells a_i and random values c_i.\n    // -------------------\n    // Make sure we have n distinct positions in [1..h].\n    // If n > h, this is impossible, but let's assume valid arguments. \n    // We'll do a generic approach: pick n distinct numbers from [1..h].\n    // If h is extremely large, testlib's rnd.next(long long) supports up to 2^63-1.\n    // We'll generate positions straightforwardly but carefully.\n\n    // Collect distinct positions:\n    // Strategy: to avoid slow repeated checking for large n, pick random using a set or\n    // reservoir sample approach if needed. Here, we do a simple approach with a set\n    // if n is not too large. (This is just an example.)\n\n    set<long long> usedCells;\n    while ((int)usedCells.size() < n) {\n        long long candidate = rnd.next(h) + 1; // in [1..h]\n        usedCells.insert(candidate);\n    }\n    // Put them in a vector\n    vector<long long> A(usedCells.begin(), usedCells.end());\n\n    // Generate c_i in [1..10^9]\n    // We'll keep them in an array so we can update them for type-2 ops.\n    vector<long long> C(n);\n    for (int i = 0; i < n; i++) {\n        // Depending on testType, we might want special patterns:\n        if (testType == \"all1\") {\n            C[i] = 1;  \n        } else {\n            // random in [1..10^9]\n            C[i] = rnd.next(1, 1000000000);\n        }\n    }\n\n    // Output the n lines: (a_i, c_i)\n    // a_i are distinct by construction.\n    for (int i = 0; i < n; i++) {\n        cout << A[i] << \" \" << C[i] << \"\\n\";\n    }\n\n    // -------------------\n    // 3) Generate m operations.\n    //  - At most 20 type-1 ops\n    //  - \"2 x y\" must satisfy: 1 ≤ x ≤ n, 0 ≤ y < c_x\n    //    we must keep c_x positive after each type-2\n    //  - \"3\" can appear any number of times\n    //  - We preserve correctness\n    // -------------------\n\n    // Decide how many type-1 ops we'll have total (cannot exceed 20).\n    // For example, pick a small random up to min(20, m).\n    int t1ops = (m <= 20 ? rnd.next(0, m) : rnd.next(0, 20));\n    int performed1 = 0; // track how many type-1 ops used.\n\n    // We'll produce m operations sequentially.\n    // We'll do a random approach:\n    //   - pick an operation type among {1,2,3}, adjusting for constraints\n    //   - create a valid operation line\n    //   - keep track of c_x for type-2 changes\n    for (int i = 0; i < m; i++) {\n        // Weighted random to choose an op: we'll try an approach:\n        //   if we still can produce type-1, it has some small chance\n        //   type-2 and type-3 share the rest\n        // This is just an example strategy, can be refined.\n\n        int opType = 3; // default is 3\n        int r = rnd.next(100);\n        if (r < 20 && performed1 < t1ops) {\n            opType = 1; \n        } else if (r < 60) {\n            opType = 2; \n        } \n        // We'll see if we can do a valid type-2; if not, we fallback to 3 or 1.\n\n        if (opType == 1) {\n            // produce \"1 x\" with (1 ≤ x ≤ h)\n            // pick x in [1..h]\n            long long x = rnd.next(h) + 1;\n            cout << \"1 \" << x << \"\\n\";\n            performed1++;\n        }\n        else if (opType == 2) {\n            // need to pick x in [1..n] with c_x[x-1] >= 1\n            // and y in [0.. c_x - 1]. But c_x must remain >=1 if the problem\n            // demands strictly positive after the operation. The statement says\n            // \"It’s guaranteed that any moment treasure in each cell has positive value\".\n            // The operation \"2 x y\" itself only demands 0 ≤ y < c_x. So we remain valid.\n            // But c_x will remain c_x-y, which is >=1 if y <= c_x-1, so that's valid.\n\n            // We'll try 10 attempts to pick a valid x. If we cannot, fallback to type-3.\n            bool found = false;\n            for (int tries = 0; tries < 10; tries++) {\n                int xIndex = rnd.next(0, n - 1); \n                if (C[xIndex] > 1) {\n                    // we can pick y in [1.. C[xIndex]-1]\n                    long long treasureVal = C[xIndex];\n                    long long y = 0;\n\n                    // choose y > 0 half the time\n                    if (rnd.next(2) == 1 && treasureVal > 1) {\n                        y = rnd.next(1LL, treasureVal - 1);\n                    } else {\n                        // y can be 0, which is still valid\n                        y = 0;\n                    }\n                    // now produce operation: 2 (xIndex+1) y\n                    cout << \"2 \" << (xIndex + 1) << \" \" << y << \"\\n\";\n                    // update C\n                    C[xIndex] -= y; \n                    found = true;\n                    break;\n                }\n            }\n            if (!found) {\n                // fallback to \"3\"\n                cout << \"3\\n\";\n            }\n        }\n        else {\n            // type-3\n            cout << \"3\\n\";\n        }\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\n/*\n * This generator creates test data for the described problem:\n *   h (1 ≤ h ≤ 10^18), n, m (1 ≤ n, m ≤ 10^5), k (1 ≤ k ≤ 10^4), \n *   distinct ai (1 ≤ ai ≤ h), and ci (1 ≤ ci ≤ 10^9).\n *   Then m operations follow:\n *     1) \"1 x\" with (1 ≤ x ≤ h),\n *     2) \"2 x y\" with (1 ≤ x ≤ n), (0 ≤ y < c_x),\n *     3) \"3\".\n *   We ensure at most 20 ops of type 1 and keep c_x positive.\n */\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    // Required command-line arguments.\n    // e.g. ./gen -h 1000 -n 5 -m 10 -k 2 -type random\n    long long h = opt<long long>(\"h\", 1000LL); // default = 1000 if not provided\n    int n = opt<int>(\"n\", 5);                  // default = 5\n    int m = opt<int>(\"m\", 10);                 // default = 10\n    long long k = opt<long long>(\"k\", 2LL);    // default = 2\n    string testType = opt<string>(\"type\", \"random\"); \n\n    // -------------------\n    // 1) Output line: h, n, m, k\n    // -------------------\n    cout << h << \" \" << n << \" \" << m << \" \" << k << \"\\n\";\n\n    // -------------------\n    // 2) Generate distinct cells a_i and random values c_i.\n    // -------------------\n    // Make sure we have n distinct positions in [1..h].\n    // If n > h, this is impossible, but let's assume valid arguments. \n    // We'll do a generic approach: pick n distinct numbers from [1..h].\n    // If h is extremely large, testlib's rnd.next(long long) supports up to 2^63-1.\n    // We'll generate positions straightforwardly but carefully.\n\n    // Collect distinct positions:\n    // Strategy: to avoid slow repeated checking for large n, pick random using a set or\n    // reservoir sample approach if needed. Here, we do a simple approach with a set\n    // if n is not too large. (This is just an example.)\n\n    set<long long> usedCells;\n    while ((int)usedCells.size() < n) {\n        long long candidate = rnd.next(h) + 1; // in [1..h]\n        usedCells.insert(candidate);\n    }\n    // Put them in a vector\n    vector<long long> A(usedCells.begin(), usedCells.end());\n\n    // Generate c_i in [1..10^9]\n    // We'll keep them in an array so we can update them for type-2 ops.\n    vector<long long> C(n);\n    for (int i = 0; i < n; i++) {\n        // Depending on testType, we might want special patterns:\n        if (testType == \"all1\") {\n            C[i] = 1;  \n        } else {\n            // random in [1..10^9]\n            C[i] = rnd.next(1, 1000000000);\n        }\n    }\n\n    // Output the n lines: (a_i, c_i)\n    // a_i are distinct by construction.\n    for (int i = 0; i < n; i++) {\n        cout << A[i] << \" \" << C[i] << \"\\n\";\n    }\n\n    // -------------------\n    // 3) Generate m operations.\n    //  - At most 20 type-1 ops\n    //  - \"2 x y\" must satisfy: 1 ≤ x ≤ n, 0 ≤ y < c_x\n    //    we must keep c_x positive after each type-2\n    //  - \"3\" can appear any number of times\n    //  - We preserve correctness\n    // -------------------\n\n    // Decide how many type-1 ops we'll have total (cannot exceed 20).\n    // For example, pick a small random up to min(20, m).\n    int t1ops = (m <= 20 ? rnd.next(0, m) : rnd.next(0, 20));\n    int performed1 = 0; // track how many type-1 ops used.\n\n    // We'll produce m operations sequentially.\n    // We'll do a random approach:\n    //   - pick an operation type among {1,2,3}, adjusting for constraints\n    //   - create a valid operation line\n    //   - keep track of c_x for type-2 changes\n    for (int i = 0; i < m; i++) {\n        // Weighted random to choose an op: we'll try an approach:\n        //   if we still can produce type-1, it has some small chance\n        //   type-2 and type-3 share the rest\n        // This is just an example strategy, can be refined.\n\n        int opType = 3; // default is 3\n        int r = rnd.next(100);\n        if (r < 20 && performed1 < t1ops) {\n            opType = 1; \n        } else if (r < 60) {\n            opType = 2; \n        } \n        // We'll see if we can do a valid type-2; if not, we fallback to 3 or 1.\n\n        if (opType == 1) {\n            // produce \"1 x\" with (1 ≤ x ≤ h)\n            // pick x in [1..h]\n            long long x = rnd.next(h) + 1;\n            cout << \"1 \" << x << \"\\n\";\n            performed1++;\n        }\n        else if (opType == 2) {\n            // need to pick x in [1..n] with c_x[x-1] >= 1\n            // and y in [0.. c_x - 1]. But c_x must remain >=1 if the problem\n            // demands strictly positive after the operation. The statement says\n            // \"It’s guaranteed that any moment treasure in each cell has positive value\".\n            // The operation \"2 x y\" itself only demands 0 ≤ y < c_x. So we remain valid.\n            // But c_x will remain c_x-y, which is >=1 if y <= c_x-1, so that's valid.\n\n            // We'll try 10 attempts to pick a valid x. If we cannot, fallback to type-3.\n            bool found = false;\n            for (int tries = 0; tries < 10; tries++) {\n                int xIndex = rnd.next(0, n - 1); \n                if (C[xIndex] > 1) {\n                    // we can pick y in [1.. C[xIndex]-1]\n                    long long treasureVal = C[xIndex];\n                    long long y = 0;\n\n                    // choose y > 0 half the time\n                    if (rnd.next(2) == 1 && treasureVal > 1) {\n                        y = rnd.next(1LL, treasureVal - 1);\n                    } else {\n                        // y can be 0, which is still valid\n                        y = 0;\n                    }\n                    // now produce operation: 2 (xIndex+1) y\n                    cout << \"2 \" << (xIndex + 1) << \" \" << y << \"\\n\";\n                    // update C\n                    C[xIndex] -= y; \n                    found = true;\n                    break;\n                }\n            }\n            if (!found) {\n                // fallback to \"3\"\n                cout << \"3\\n\";\n            }\n        }\n        else {\n            // type-3\n            cout << \"3\\n\";\n        }\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -h 10 -n 2 -m 5 -k 1 -type random\n./gen -h 10 -n 3 -m 5 -k 2 -type random\n./gen -h 10 -n 3 -m 5 -k 2 -type all1\n\n./gen -h 100 -n 5 -m 10 -k 1 -type random\n./gen -h 100 -n 5 -m 10 -k 2 -type random\n./gen -h 100 -n 5 -m 10 -k 5 -type all1\n\n./gen -h 1000 -n 8 -m 15 -k 2 -type random\n./gen -h 1000 -n 8 -m 15 -k 10 -type random\n./gen -h 1000 -n 8 -m 15 -k 10 -type all1\n\n./gen -h 999999999999999999 -n 5 -m 10 -k 1 -type random\n./gen -h 999999999999999999 -n 10 -m 15 -k 10000 -type random\n\n./gen -h 2000 -n 200 -m 200 -k 1 -type random\n./gen -h 2000 -n 200 -m 200 -k 10 -type random\n./gen -h 2000 -n 200 -m 200 -k 10 -type all1\n\n# Larger n and m\n./gen -h 50000 -n 1000 -m 1000 -k 100 -type random\n./gen -h 50000 -n 1000 -m 1000 -k 100 -type all1\n\n# Edge case: bigger n, bigger m\n./gen -h 1000000 -n 5000 -m 5000 -k 9999 -type random\n./gen -h 1000000 -n 5000 -m 5000 -k 9999 -type all1\n\n# Very large values of n, m near the limit\n./gen -h 1000000000 -n 100000 -m 100000 -k 1 -type random\n./gen -h 1000000000 -n 100000 -m 100000 -k 10000 -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:06:22.956485",
        "total_tutorials": 3,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "311/D",
      "title": "D. Interval Cubing",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test6 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains an integer n (1 ≤ n ≤ 105), representing the length of the sequence. The second line contains n space-separated integers a1, a2, ..., an (0 ≤ ai ≤ 109).The third line contains an integer q (1 ≤ q ≤ 105), representing the number of queries. Then follow q lines. Each line contains three integers ti (1 ≤ ti ≤ 2), li, ri (1 ≤ li ≤ ri ≤ n), where ti stands for the type of the query while li and ri is the parameters of the query, correspondingly.",
      "output_spec": "OutputFor each 1-type query, print the answer to it per line.You should notice that each printed number should be non-negative and less than 95542721.",
      "sample_tests": "ExamplesInputCopy81 2 3 4 5 6 7 851 2 52 2 51 2 52 3 61 4 7OutputCopy142242215492",
      "description": "D. Interval Cubing\n\ntime limit per test6 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains an integer n (1 ≤ n ≤ 105), representing the length of the sequence. The second line contains n space-separated integers a1, a2, ..., an (0 ≤ ai ≤ 109).The third line contains an integer q (1 ≤ q ≤ 105), representing the number of queries. Then follow q lines. Each line contains three integers ti (1 ≤ ti ≤ 2), li, ri (1 ≤ li ≤ ri ≤ n), where ti stands for the type of the query while li and ri is the parameters of the query, correspondingly.\n\nOutputFor each 1-type query, print the answer to it per line.You should notice that each printed number should be non-negative and less than 95542721.\n\nInputCopy81 2 3 4 5 6 7 851 2 52 2 51 2 52 3 61 4 7OutputCopy142242215492\n\nInputCopy81 2 3 4 5 6 7 851 2 52 2 51 2 52 3 61 4 7\n\nOutputCopy142242215492",
      "solutions": [
        {
          "title": "Codeforces Round #185 - Codeforces",
          "content": "Hello,everyone!Codeforces Round #185 will take place on Sunday, May 26th at 19:30MSK (23:30CST).This round is initiated by zanoes, and here are the problem setters: Div.1E & Div.2B —— zanoes (**Zhang Gaoxiang**) Div.1D & Div.1A —— liouzhou_101 (**Wang Qisheng**) Div.1C & Div.1B & Div.2A —— lydrainbowcat (**Li Yudong**) Testers are roosephu(Luo Yuping), FredaShi(Shi Haoyue), sjynoi(Sun Jiayu), sevenkplus(Gu Yuzhou), MinakoKojima(Tang Feihu) and Riatre.Especially thanks Gerald for helping us to prepare the round, MikeMirzayanov for the great platform and Delinur for translation.Score will be standard, 500-1000-1500-2000-2500 in both divisions. In our opinion, problems are easier than the past several rounds prepared by Chinese)This is our first Codeforces round, I hope you can enjoy it. Wish you high rating and good luck!UPD: We feel really sorry about the mistake we made. The following words were written by Div.1A (Div.2C)setter, liouzhou_101. http://codeforces.com/blog/entry/7773#comment-134702 . Meanwhile, It's also zanoes's and my fault that we didn't check his checker carefully, even brought troubles to Codeforces flat. I beg your forgive for liouzhou_101, for he also tried to prepare the round well these days. UPD2: The round will be unrated.Editorials will come out soon. Now you can find some of the editorials here: http://codeforces.com/blog/entry/7785Contest is over. Congratulations to the winners.Div.1 zfmdhy786 (I promise it's someone who pretends to be roosephu, and I've known who he is.) cp12321 RAD ACMonster kAc And ryz , cgy4ever, who passed problem E in the contest.Div.2 ymxlkAc sasha.sochka bohuss",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/7773",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1639
        },
        {
          "title": "Codeforces Round #185 Editorial - Codeforces",
          "content": "311A - Ближайшая параhttp://codeforces.com/blog/entry/7787311B - Транспортировка кошекP.S. I feel very sorry that I thought it was a traditional DP problem with only 800B code and didn't realize some participants were not familiar with such kind of problems, so I said it was easy. Let a[i] be the distance from hill 1 to hill i, s[i]=a[1]+a[2]+…+a[i].Firstly, we sort the cats by (Ti-a[i]). Then we can divide the cats into P consecutive parts, and plan a feeder for each part. Dynamic Programming can solve this problem.Let f[i,j] indicates the minimum sum of waiting time with i feeders and j cats.f[i,j] = f[i-1,k]+a[j]*(j-k)-s[j]+s[k] = a[j]*j-s[j] + f[i-1,k]+s[k]-a[j]*kThat’s O(PM^2). It’ll get TLE.Let p>q, if p is \"better\" than q, then:f[i-1,p]+s[p]-a[j]*p>f[i-1,q]+s[q]-a[j]*q(f[i-1,p]+s[p])-(f[i-1,q]+s[q])>a[j]*(p-q)g[p]-g[q]>a[j]*(p-q)So we can use Convex hull trick with a queue. Then we get O(MP), which can pass the problem.311C - Достать сокровищеFirstly, we solve such a problem: if we can go exactly k,k1,k2……or kp cells forward each step, what cells can we reach?We divide the H cells into k groups: Group 0,1……k-1. The i-th cell should be in Group (i mod k). If we reach Cell x in Group (x mod k), we can also reach Cell (x+kj , 1<=j<=p) in Group ((x+kj)mod k). If we reach Cell x in Group (x mod k), we can also reach Cell (x+k) in the same group. Let D[i] be the minimum cell we can reach in Group i. Then we can reach all the cells which number are bigger then D[i] in Group i. Regard the groups as points. Regard k,k1,k2……kp as edges. And use a Shortest-Path Algorithm to calculate all D[i]. Notice that there are at most 20 operations of type 1, we are able to run such an algorithm after each of these operations. The total time complexity is O(20*k*20*log(k)) with Dijkstra.Secondly, we build a binary-heap to solve operations of type 2 and 3. Type1 – If a D[i] becomes smaller, we put the new cells we can reach into the heap. Type2 – Decrease a value of a node in the heap, or a cell in the “Treasure Cell” array. Type3 – Ask the biggest node in the heap and delete it. These are basic operations of binary-heap. The time complexity is O(NlogN). In C++, you can also use priority_queue from STL and lazy-tags. So we can solve the whole problem in O(400klogk+NlogN).311D - Куб на отрезкеhttp://codeforces.com/blog/entry/7787311E - Биологhttp://codeforces.com/blog/entry/7847312A - Чье это предложение?We only need to find out if “miao.” is a prefix of the sentence, and if “lala.” is a suffix of the sentence. Pay attention to the situation when both conditions are satisfied.312B - Лучникиhttp://codeforces.com/blog/entry/7847",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/7785",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 311\\s*D"
          },
          "content_length": 2656
        },
        {
          "title": "Codeforces Round #185 Editorial (Div.1 A&D) - Codeforces",
          "content": "311A — The Closest PairP.S. I feel really guilty that I've made an awful mistake on the checker.We read the pseudo code carefully. If we ignore \"break\", tot will be up to .Consider whether we can make such inequality d ≤ p[j].x - p[i].x is always false. The obvious way is to make all points' x coordinates the same. And we can just choose n distinct numbers to be all points' y coordinate.Thus the problem is solved.311D — Interval CubingConsider a number x. If we apply an assignment x = x3, x becomes x3. If we apply such assignment once more, we will get (x3)3 = x32. If we apply such assignment k times, we will get x3k.Thus, we can get such a sequence a0 = x, a1 = x3, a2 = x32, ..., ak = x3k, ....Consider a prime p. From Fermat's Little Theorem, we can get xp - 1 = 1(mod p). Further more, we can get xy = xymod(p - 1)(mod p), here a mod b means the remainder of a divided by b.Fortunately, 348 = 1(mod (95542721 - 1)), thus, x3k = x3kmod48(mod p). In other words, ak = ak + 48, which means the cycle of the sequence is T = 48.Let's come back to the topic. Each time we run a 1-type query, for every i in the range [l, r], we apply such an assignment ai = ai3. At any moment some i has been applied 48 times such assignments, we can consider this i hasn't been applied any assignments before.We can use segment tree to solve this problem. Every node of the segment tree maintains some information: the times that we applied assignments in the node's whole range(it's a lazy tag), current sum of the node's corresponding range and the sum of the node's range after we applied assignments k(1 ≤ k < 48) times.In such a way, we can solve the problem in O(n·T + q·T·logn) time.If you do not realize how to maintain the segment tree clearly, you can view the code 3782263.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/7787",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 311\\s*D"
          },
          "content_length": 1775
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #185 - Codeforces - Code 1",
          "code": "I do not have time to participate in a number of competitions, this one I think I can get a better grade, yes I do , with good grade. But no rating changed.\nI may not to blame the one who hold the round, but I do not want this happen again.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7773",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #185 Editorial - Codeforces - Code 1",
          "code": "FOR i from 1 to n\n    PRINT (n-i,0)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7785",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #185 Editorial - Codeforces - Code 2",
          "code": "FOR i from 1 to n\n    PRINT (n-i,0)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7785",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    \n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, 0, 1000000000, \"a_i\");\n    inf.readEoln();\n\n    int q = inf.readInt(1, 100000, \"q\");\n    inf.readEoln();\n\n    for (int i = 0; i < q; i++) {\n        int t = inf.readInt(1, 2, \"t_i\");\n        inf.readSpace();\n        int l = inf.readInt(1, n, \"l_i\");\n        inf.readSpace();\n        int r = inf.readInt(l, n, \"r_i\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    \n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, 0, 1000000000, \"a_i\");\n    inf.readEoln();\n\n    int q = inf.readInt(1, 100000, \"q\");\n    inf.readEoln();\n\n    for (int i = 0; i < q; i++) {\n        int t = inf.readInt(1, 2, \"t_i\");\n        inf.readSpace();\n        int l = inf.readInt(1, n, \"l_i\");\n        inf.readSpace();\n        int r = inf.readInt(l, n, \"r_i\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    \n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, 0, 1000000000, \"a_i\");\n    inf.readEoln();\n\n    int q = inf.readInt(1, 100000, \"q\");\n    inf.readEoln();\n\n    for (int i = 0; i < q; i++) {\n        int t = inf.readInt(1, 2, \"t_i\");\n        inf.readSpace();\n        int l = inf.readInt(1, n, \"l_i\");\n        inf.readSpace();\n        int r = inf.readInt(l, n, \"r_i\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int q = opt<int>(\"q\");\n    string type = opt<string>(\"type\", \"random\");\n\n    // Generate array a_i of length n\n    vector<int> a(n);\n\n    if (type == \"max_values\") {\n        // Fill with maximum value (1e9)\n        for(int i = 0; i < n; ++i) {\n            a[i] = int(1e9);\n        }\n    } else if (type == \"min_values\") {\n        // Fill with zeros\n        for(int i = 0; i < n; ++i) {\n            a[i] = 0;\n        }\n    } else if (type == \"ones\") {\n        // All ones\n        for(int i = 0; i < n; ++i) {\n            a[i] = 1;\n        }\n    } else if (type == \"overflow\") {\n        // Initial values set to moderate numbers to cause overflow after cubing\n        for(int i = 0; i < n; ++i) {\n            a[i] = int(1e5);\n        }\n    } else if (type == \"alternating\") {\n        // Alternating 0 and 1e9\n        for(int i = 0; i < n; ++i) {\n            a[i] = (i % 2 == 0) ? 0 : int(1e9);\n        }\n    } else {\n        // Default to random\n        for(int i = 0; i < n; ++i) {\n            a[i] = rnd.next(0, int(1e9));\n        }\n    }\n\n    // Output n\n    printf(\"%d\\n\", n);\n    // Output a_i\n    for(int i = 0; i < n; ++i) {\n        printf(\"%d\", a[i]);\n        if (i + 1 < n)\n            printf(\" \");\n        else\n            printf(\"\\n\");\n    }\n\n    // Now generate queries\n    string qtype = opt<string>(\"qtype\", \"random\");\n    vector<tuple<int, int, int> > queries(q);\n\n    if (type == \"overflow\") {\n        // In this case, we want multiple cube operations on same elements\n        int l = 1;\n        int r = n;\n        for(int i = 0; i < q; ++i) {\n            int t = (i % 2 == 0) ? 2 : 1;\n            queries[i] = make_tuple(t, l, r);\n        }\n    } else if(qtype == \"type1\") {\n        // All queries are type 1\n        for(int i = 0; i < q; ++i) {\n            int l = rnd.next(1, n);\n            int r = rnd.next(l, n);\n            queries[i] = make_tuple(1, l, r);\n        }\n    } else if(qtype == \"type2\") {\n        // All queries are type 2\n        for(int i = 0; i < q; ++i) {\n            int l = rnd.next(1, n);\n            int r = rnd.next(l, n);\n            queries[i] = make_tuple(2, l, r);\n        }\n    } else if(qtype == \"alternating\") {\n        // Alternate between type 1 and type 2\n        for(int i = 0; i < q; ++i) {\n            int t = (i % 2) + 1;\n            int l = rnd.next(1, n);\n            int r = rnd.next(l, n);\n            queries[i] = make_tuple(t, l, r);\n        }\n    } else if(qtype == \"single_element\") {\n        // All queries are on l = r\n        for(int i = 0; i < q; ++i) {\n            int t = rnd.next(1, 2);\n            int l = rnd.next(1, n);\n            queries[i] = make_tuple(t, l, l);\n        }\n    } else if(qtype == \"full_range\") {\n        // All queries cover the full range\n        for(int i = 0; i < q; ++i) {\n            int t = rnd.next(1, 2);\n            queries[i] = make_tuple(t, 1, n);\n        }\n    } else {\n        // Default random queries\n        for(int i = 0; i < q; ++i) {\n            int t = rnd.next(1, 2);\n            int l = rnd.next(1, n);\n            int r = rnd.next(l, n);\n            queries[i] = make_tuple(t, l, r);\n        }\n    }\n\n    // Output q\n    printf(\"%d\\n\", q);\n\n    // Output queries\n    for(int i = 0; i < q; ++i) {\n        int t, l, r;\n        tie(t, l, r) = queries[i];\n        printf(\"%d %d %d\\n\", t, l, r);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int q = opt<int>(\"q\");\n    string type = opt<string>(\"type\", \"random\");\n\n    // Generate array a_i of length n\n    vector<int> a(n);\n\n    if (type == \"max_values\") {\n        // Fill with maximum value (1e9)\n        for(int i = 0; i < n; ++i) {\n            a[i] = int(1e9);\n        }\n    } else if (type == \"min_values\") {\n        // Fill with zeros\n        for(int i = 0; i < n; ++i) {\n            a[i] = 0;\n        }\n    } else if (type == \"ones\") {\n        // All ones\n        for(int i = 0; i < n; ++i) {\n            a[i] = 1;\n        }\n    } else if (type == \"overflow\") {\n        // Initial values set to moderate numbers to cause overflow after cubing\n        for(int i = 0; i < n; ++i) {\n            a[i] = int(1e5);\n        }\n    } else if (type == \"alternating\") {\n        // Alternating 0 and 1e9\n        for(int i = 0; i < n; ++i) {\n            a[i] = (i % 2 == 0) ? 0 : int(1e9);\n        }\n    } else {\n        // Default to random\n        for(int i = 0; i < n; ++i) {\n            a[i] = rnd.next(0, int(1e9));\n        }\n    }\n\n    // Output n\n    printf(\"%d\\n\", n);\n    // Output a_i\n    for(int i = 0; i < n; ++i) {\n        printf(\"%d\", a[i]);\n        if (i + 1 < n)\n            printf(\" \");\n        else\n            printf(\"\\n\");\n    }\n\n    // Now generate queries\n    string qtype = opt<string>(\"qtype\", \"random\");\n    vector<tuple<int, int, int> > queries(q);\n\n    if (type == \"overflow\") {\n        // In this case, we want multiple cube operations on same elements\n        int l = 1;\n        int r = n;\n        for(int i = 0; i < q; ++i) {\n            int t = (i % 2 == 0) ? 2 : 1;\n            queries[i] = make_tuple(t, l, r);\n        }\n    } else if(qtype == \"type1\") {\n        // All queries are type 1\n        for(int i = 0; i < q; ++i) {\n            int l = rnd.next(1, n);\n            int r = rnd.next(l, n);\n            queries[i] = make_tuple(1, l, r);\n        }\n    } else if(qtype == \"type2\") {\n        // All queries are type 2\n        for(int i = 0; i < q; ++i) {\n            int l = rnd.next(1, n);\n            int r = rnd.next(l, n);\n            queries[i] = make_tuple(2, l, r);\n        }\n    } else if(qtype == \"alternating\") {\n        // Alternate between type 1 and type 2\n        for(int i = 0; i < q; ++i) {\n            int t = (i % 2) + 1;\n            int l = rnd.next(1, n);\n            int r = rnd.next(l, n);\n            queries[i] = make_tuple(t, l, r);\n        }\n    } else if(qtype == \"single_element\") {\n        // All queries are on l = r\n        for(int i = 0; i < q; ++i) {\n            int t = rnd.next(1, 2);\n            int l = rnd.next(1, n);\n            queries[i] = make_tuple(t, l, l);\n        }\n    } else if(qtype == \"full_range\") {\n        // All queries cover the full range\n        for(int i = 0; i < q; ++i) {\n            int t = rnd.next(1, 2);\n            queries[i] = make_tuple(t, 1, n);\n        }\n    } else {\n        // Default random queries\n        for(int i = 0; i < q; ++i) {\n            int t = rnd.next(1, 2);\n            int l = rnd.next(1, n);\n            int r = rnd.next(l, n);\n            queries[i] = make_tuple(t, l, r);\n        }\n    }\n\n    // Output q\n    printf(\"%d\\n\", q);\n\n    // Output queries\n    for(int i = 0; i < q; ++i) {\n        int t, l, r;\n        tie(t, l, r) = queries[i];\n        printf(\"%d %d %d\\n\", t, l, r);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# 1. Minimal n and q\n./gen -n 1 -q 1 -type min_values -qtype type1\n\n# 2. Small n and q, random values\n./gen -n 10 -q 10 -type random -qtype random\n\n# 3. Small n, max q\n./gen -n 10 -q 100000 -type random -qtype random\n\n# 4. Max n and q, random values\n./gen -n 100000 -q 100000 -type random -qtype random\n\n# 5. Max n and q, initial max values\n./gen -n 100000 -q 100000 -type max_values -qtype random\n\n# 6. Max n and q, initial zeros\n./gen -n 100000 -q 100000 -type min_values -qtype random\n\n# 7. Max n and q, initial ones\n./gen -n 100000 -q 100000 -type ones -qtype random\n\n# 8. Max n and q, alternating initial values\n./gen -n 100000 -q 100000 -type alternating -qtype random\n\n# 9. Max n and q, only type1 queries\n./gen -n 100000 -q 100000 -type random -qtype type1\n\n# 10. Max n and q, only type2 queries\n./gen -n 100000 -q 100000 -type random -qtype type2\n\n# 11. Max n and q, alternating query types\n./gen -n 100000 -q 100000 -type random -qtype alternating\n\n# 12. Max n and q, l = r in queries\n./gen -n 100000 -q 100000 -type random -qtype single_element\n\n# 13. Max n and q, full range queries\n./gen -n 100000 -q 100000 -type random -qtype full_range\n\n# 14. Max n and q, overflow test\n./gen -n 100000 -q 100000 -type overflow\n\n# 15. Max n, q = 1\n./gen -n 100000 -q 1 -type random -qtype random\n\n# 16. n = 1, max q\n./gen -n 1 -q 100000 -type random -qtype random\n\n# 17. n = 1, q = 1, single element queries and updates\n./gen -n 1 -q 1 -type random -qtype single_element\n\n# 18. n = max, q = max, only l = r in queries\n./gen -n 100000 -q 100000 -type random -qtype single_element\n\n# 19. n = max, q = max, full range updates on max initial values\n./gen -n 100000 -q 100000 -type max_values -qtype full_range\n\n# 20. n = max, q = max, initial ones, alternating queries\n./gen -n 100000 -q 100000 -type ones -qtype alternating\n\n# 21. n = max, q = max, initial zeros, only type2 queries\n./gen -n 100000 -q 100000 -type min_values -qtype type2\n\n# 22. n = max, q = max, overflow test with full range updates\n./gen -n 100000 -q 100000 -type overflow\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:06:25.129287",
        "total_tutorials": 3,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "311/E",
      "title": "E. Biologist",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1.5 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains three integers n, m, g (1 ≤ n ≤ 104, 0 ≤ m ≤ 2000, 0 ≤ g ≤ 104). The second line contains n integers, each is 0 or 1, the sex of each dog, 0 represent the female and 1 represent the male. The third line contains n integers v1, v2, ..., vn (0 ≤ vi ≤ 104).Each of the next m lines describes a rich folk. On the i-th line the first number is the appointed sex of i-th folk (0 or 1), the next two integers are wi and ki (0 ≤ wi ≤ 104, 1 ≤ ki ≤ 10), next ki distinct integers are the indexes of appointed dogs (each index is between 1 and n). The last number of this line represents whether i-th folk is SmallR's good friend (0 — no or 1 — yes).",
      "output_spec": "OutputPrint a single integer, the maximum money SmallR can gain. Note that the integer is negative if SmallR will lose money.",
      "sample_tests": "ExamplesInputCopy5 5 90 1 1 1 01 8 6 2 30 7 3 3 2 1 11 8 1 5 11 0 3 2 1 4 10 8 3 4 2 1 01 7 2 4 1 1OutputCopy2InputCopy5 5 81 0 1 1 16 5 4 2 80 6 3 2 3 4 00 8 3 3 2 4 00 0 3 3 4 1 10 10 3 4 3 1 10 4 3 3 4 1 1OutputCopy16",
      "description": "E. Biologist\n\ntime limit per test1.5 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains three integers n, m, g (1 ≤ n ≤ 104, 0 ≤ m ≤ 2000, 0 ≤ g ≤ 104). The second line contains n integers, each is 0 or 1, the sex of each dog, 0 represent the female and 1 represent the male. The third line contains n integers v1, v2, ..., vn (0 ≤ vi ≤ 104).Each of the next m lines describes a rich folk. On the i-th line the first number is the appointed sex of i-th folk (0 or 1), the next two integers are wi and ki (0 ≤ wi ≤ 104, 1 ≤ ki ≤ 10), next ki distinct integers are the indexes of appointed dogs (each index is between 1 and n). The last number of this line represents whether i-th folk is SmallR's good friend (0 — no or 1 — yes).\n\nOutputPrint a single integer, the maximum money SmallR can gain. Note that the integer is negative if SmallR will lose money.\n\nInputCopy5 5 90 1 1 1 01 8 6 2 30 7 3 3 2 1 11 8 1 5 11 0 3 2 1 4 10 8 3 4 2 1 01 7 2 4 1 1OutputCopy2InputCopy5 5 81 0 1 1 16 5 4 2 80 6 3 2 3 4 00 8 3 3 2 4 00 0 3 3 4 1 10 10 3 4 3 1 10 4 3 3 4 1 1OutputCopy16\n\nInputCopy5 5 90 1 1 1 01 8 6 2 30 7 3 3 2 1 11 8 1 5 11 0 3 2 1 4 10 8 3 4 2 1 01 7 2 4 1 1\n\nOutputCopy2\n\nInputCopy5 5 81 0 1 1 16 5 4 2 80 6 3 2 3 4 00 8 3 3 2 4 00 0 3 3 4 1 10 10 3 4 3 1 10 4 3 3 4 1 1\n\nOutputCopy16",
      "solutions": [
        {
          "title": "Codeforces Round #185 - Codeforces",
          "content": "Hello,everyone!Codeforces Round #185 will take place on Sunday, May 26th at 19:30MSK (23:30CST).This round is initiated by zanoes, and here are the problem setters: Div.1E & Div.2B —— zanoes (**Zhang Gaoxiang**) Div.1D & Div.1A —— liouzhou_101 (**Wang Qisheng**) Div.1C & Div.1B & Div.2A —— lydrainbowcat (**Li Yudong**) Testers are roosephu(Luo Yuping), FredaShi(Shi Haoyue), sjynoi(Sun Jiayu), sevenkplus(Gu Yuzhou), MinakoKojima(Tang Feihu) and Riatre.Especially thanks Gerald for helping us to prepare the round, MikeMirzayanov for the great platform and Delinur for translation.Score will be standard, 500-1000-1500-2000-2500 in both divisions. In our opinion, problems are easier than the past several rounds prepared by Chinese)This is our first Codeforces round, I hope you can enjoy it. Wish you high rating and good luck!UPD: We feel really sorry about the mistake we made. The following words were written by Div.1A (Div.2C)setter, liouzhou_101. http://codeforces.com/blog/entry/7773#comment-134702 . Meanwhile, It's also zanoes's and my fault that we didn't check his checker carefully, even brought troubles to Codeforces flat. I beg your forgive for liouzhou_101, for he also tried to prepare the round well these days. UPD2: The round will be unrated.Editorials will come out soon. Now you can find some of the editorials here: http://codeforces.com/blog/entry/7785Contest is over. Congratulations to the winners.Div.1 zfmdhy786 (I promise it's someone who pretends to be roosephu, and I've known who he is.) cp12321 RAD ACMonster kAc And ryz , cgy4ever, who passed problem E in the contest.Div.2 ymxlkAc sasha.sochka bohuss",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/7773",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1639
        },
        {
          "title": "Codeforces Round #185 Editorial - Codeforces",
          "content": "311A - Ближайшая параhttp://codeforces.com/blog/entry/7787311B - Транспортировка кошекP.S. I feel very sorry that I thought it was a traditional DP problem with only 800B code and didn't realize some participants were not familiar with such kind of problems, so I said it was easy. Let a[i] be the distance from hill 1 to hill i, s[i]=a[1]+a[2]+…+a[i].Firstly, we sort the cats by (Ti-a[i]). Then we can divide the cats into P consecutive parts, and plan a feeder for each part. Dynamic Programming can solve this problem.Let f[i,j] indicates the minimum sum of waiting time with i feeders and j cats.f[i,j] = f[i-1,k]+a[j]*(j-k)-s[j]+s[k] = a[j]*j-s[j] + f[i-1,k]+s[k]-a[j]*kThat’s O(PM^2). It’ll get TLE.Let p>q, if p is \"better\" than q, then:f[i-1,p]+s[p]-a[j]*p>f[i-1,q]+s[q]-a[j]*q(f[i-1,p]+s[p])-(f[i-1,q]+s[q])>a[j]*(p-q)g[p]-g[q]>a[j]*(p-q)So we can use Convex hull trick with a queue. Then we get O(MP), which can pass the problem.311C - Достать сокровищеFirstly, we solve such a problem: if we can go exactly k,k1,k2……or kp cells forward each step, what cells can we reach?We divide the H cells into k groups: Group 0,1……k-1. The i-th cell should be in Group (i mod k). If we reach Cell x in Group (x mod k), we can also reach Cell (x+kj , 1<=j<=p) in Group ((x+kj)mod k). If we reach Cell x in Group (x mod k), we can also reach Cell (x+k) in the same group. Let D[i] be the minimum cell we can reach in Group i. Then we can reach all the cells which number are bigger then D[i] in Group i. Regard the groups as points. Regard k,k1,k2……kp as edges. And use a Shortest-Path Algorithm to calculate all D[i]. Notice that there are at most 20 operations of type 1, we are able to run such an algorithm after each of these operations. The total time complexity is O(20*k*20*log(k)) with Dijkstra.Secondly, we build a binary-heap to solve operations of type 2 and 3. Type1 – If a D[i] becomes smaller, we put the new cells we can reach into the heap. Type2 – Decrease a value of a node in the heap, or a cell in the “Treasure Cell” array. Type3 – Ask the biggest node in the heap and delete it. These are basic operations of binary-heap. The time complexity is O(NlogN). In C++, you can also use priority_queue from STL and lazy-tags. So we can solve the whole problem in O(400klogk+NlogN).311D - Куб на отрезкеhttp://codeforces.com/blog/entry/7787311E - Биологhttp://codeforces.com/blog/entry/7847312A - Чье это предложение?We only need to find out if “miao.” is a prefix of the sentence, and if “lala.” is a suffix of the sentence. Pay attention to the situation when both conditions are satisfied.312B - Лучникиhttp://codeforces.com/blog/entry/7847",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/7785",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 311\\s*E"
          },
          "content_length": 2656
        },
        {
          "title": "Codeforces Round #185 Editorial (Div.1 A&D) - Codeforces",
          "content": "311A — The Closest PairP.S. I feel really guilty that I've made an awful mistake on the checker.We read the pseudo code carefully. If we ignore \"break\", tot will be up to .Consider whether we can make such inequality d ≤ p[j].x - p[i].x is always false. The obvious way is to make all points' x coordinates the same. And we can just choose n distinct numbers to be all points' y coordinate.Thus the problem is solved.311D — Interval CubingConsider a number x. If we apply an assignment x = x3, x becomes x3. If we apply such assignment once more, we will get (x3)3 = x32. If we apply such assignment k times, we will get x3k.Thus, we can get such a sequence a0 = x, a1 = x3, a2 = x32, ..., ak = x3k, ....Consider a prime p. From Fermat's Little Theorem, we can get xp - 1 = 1(mod p). Further more, we can get xy = xymod(p - 1)(mod p), here a mod b means the remainder of a divided by b.Fortunately, 348 = 1(mod (95542721 - 1)), thus, x3k = x3kmod48(mod p). In other words, ak = ak + 48, which means the cycle of the sequence is T = 48.Let's come back to the topic. Each time we run a 1-type query, for every i in the range [l, r], we apply such an assignment ai = ai3. At any moment some i has been applied 48 times such assignments, we can consider this i hasn't been applied any assignments before.We can use segment tree to solve this problem. Every node of the segment tree maintains some information: the times that we applied assignments in the node's whole range(it's a lazy tag), current sum of the node's corresponding range and the sum of the node's range after we applied assignments k(1 ≤ k < 48) times.In such a way, we can solve the problem in O(n·T + q·T·logn) time.If you do not realize how to maintain the segment tree clearly, you can view the code 3782263.",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/7787",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.6,
            "reason": "宽松匹配: 包含题目编号 311 和字母"
          },
          "content_length": 1775
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #185 - Codeforces - Code 1",
          "code": "I do not have time to participate in a number of competitions, this one I think I can get a better grade, yes I do , with good grade. But no rating changed.\nI may not to blame the one who hold the round, but I do not want this happen again.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7773",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #185 Editorial - Codeforces - Code 1",
          "code": "FOR i from 1 to n\n    PRINT (n-i,0)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7785",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #185 Editorial - Codeforces - Code 2",
          "code": "FOR i from 1 to n\n    PRINT (n-i,0)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7785",
          "author": "Qingyu"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 10000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(0, 2000, \"m\");\n    inf.readSpace();\n    int g = inf.readInt(0, 10000, \"g\");\n    inf.readEoln();\n\n    vector<int> dog_sex(n);\n    if (n >= 1) {\n        dog_sex[0] = inf.readInt(0, 1, \"s_1\");\n        for (int i = 1; i < n; ++i) {\n            inf.readSpace();\n            dog_sex[i] = inf.readInt(0, 1, \"s_i\");\n        }\n    }\n    inf.readEoln();\n\n    vector<int> v(n);\n    if (n >=1) {\n        v[0] = inf.readInt(0, 10000, \"v_1\");\n        for (int i = 1; i < n; ++i) {\n            inf.readSpace();\n            v[i] = inf.readInt(0, 10000, \"v_i\");\n        }\n    }\n    inf.readEoln();\n\n    for (int i = 0; i < m; ++i) {\n        int si = inf.readInt(0, 1, \"appointed_sex\");\n        inf.readSpace();\n        int wi = inf.readInt(0, 10000, \"wi\");\n        inf.readSpace();\n        int ki = inf.readInt(1, 10, \"ki\");\n        vector<int> indices(ki);\n        for (int j = 0; j < ki; ++j) {\n            inf.readSpace();\n            indices[j] = inf.readInt(1, n, \"appointed_dog_index\");\n        }\n        set<int> idx_set(indices.begin(), indices.end());\n        ensuref((int)idx_set.size() == ki, \"The appointed dog indices must be distinct.\");\n        inf.readSpace();\n        int fi = inf.readInt(0, 1, \"fi\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 10000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(0, 2000, \"m\");\n    inf.readSpace();\n    int g = inf.readInt(0, 10000, \"g\");\n    inf.readEoln();\n\n    vector<int> dog_sex(n);\n    if (n >= 1) {\n        dog_sex[0] = inf.readInt(0, 1, \"s_1\");\n        for (int i = 1; i < n; ++i) {\n            inf.readSpace();\n            dog_sex[i] = inf.readInt(0, 1, \"s_i\");\n        }\n    }\n    inf.readEoln();\n\n    vector<int> v(n);\n    if (n >=1) {\n        v[0] = inf.readInt(0, 10000, \"v_1\");\n        for (int i = 1; i < n; ++i) {\n            inf.readSpace();\n            v[i] = inf.readInt(0, 10000, \"v_i\");\n        }\n    }\n    inf.readEoln();\n\n    for (int i = 0; i < m; ++i) {\n        int si = inf.readInt(0, 1, \"appointed_sex\");\n        inf.readSpace();\n        int wi = inf.readInt(0, 10000, \"wi\");\n        inf.readSpace();\n        int ki = inf.readInt(1, 10, \"ki\");\n        vector<int> indices(ki);\n        for (int j = 0; j < ki; ++j) {\n            inf.readSpace();\n            indices[j] = inf.readInt(1, n, \"appointed_dog_index\");\n        }\n        set<int> idx_set(indices.begin(), indices.end());\n        ensuref((int)idx_set.size() == ki, \"The appointed dog indices must be distinct.\");\n        inf.readSpace();\n        int fi = inf.readInt(0, 1, \"fi\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 10000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(0, 2000, \"m\");\n    inf.readSpace();\n    int g = inf.readInt(0, 10000, \"g\");\n    inf.readEoln();\n\n    vector<int> dog_sex(n);\n    if (n >= 1) {\n        dog_sex[0] = inf.readInt(0, 1, \"s_1\");\n        for (int i = 1; i < n; ++i) {\n            inf.readSpace();\n            dog_sex[i] = inf.readInt(0, 1, \"s_i\");\n        }\n    }\n    inf.readEoln();\n\n    vector<int> v(n);\n    if (n >=1) {\n        v[0] = inf.readInt(0, 10000, \"v_1\");\n        for (int i = 1; i < n; ++i) {\n            inf.readSpace();\n            v[i] = inf.readInt(0, 10000, \"v_i\");\n        }\n    }\n    inf.readEoln();\n\n    for (int i = 0; i < m; ++i) {\n        int si = inf.readInt(0, 1, \"appointed_sex\");\n        inf.readSpace();\n        int wi = inf.readInt(0, 10000, \"wi\");\n        inf.readSpace();\n        int ki = inf.readInt(1, 10, \"ki\");\n        vector<int> indices(ki);\n        for (int j = 0; j < ki; ++j) {\n            inf.readSpace();\n            indices[j] = inf.readInt(1, n, \"appointed_dog_index\");\n        }\n        set<int> idx_set(indices.begin(), indices.end());\n        ensuref((int)idx_set.size() == ki, \"The appointed dog indices must be distinct.\");\n        inf.readSpace();\n        int fi = inf.readInt(0, 1, \"fi\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    // Read parameters with defaults\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    int g = opt<int>(\"g\");\n    int max_v = opt<int>(\"max_v\", 10000);\n    int max_w = opt<int>(\"max_w\", 10000);\n    int max_ki = opt<int>(\"max_ki\", 10);\n    string init_sex_type = opt<string>(\"init_sex_type\", \"random\");\n    string friend_type = opt<string>(\"friend_type\", \"random\");\n    string ki_type = opt<string>(\"ki_type\", \"random\");\n    string appointed_dogs_type = opt<string>(\"appointed_dogs_type\", \"random\");\n    string appointed_sex_type = opt<string>(\"appointed_sex_type\", \"random\");\n    int fixed_appointed_sex = opt<int>(\"fixed_appointed_sex\", -1);\n\n    // Validate fixed_appointed_sex\n    if (appointed_sex_type == \"same\" && fixed_appointed_sex == -1) {\n        fixed_appointed_sex = rnd.next(2);\n    } else if (appointed_sex_type == \"same\" && fixed_appointed_sex != 0 && fixed_appointed_sex != 1) {\n        fprintf(stderr, \"Invalid fixed_appointed_sex value. It should be 0 or 1.\\n\");\n        return 1;\n    }\n\n    // Generate initial sexes\n    vector<int> sexes(n);\n    if (init_sex_type == \"all_zeros\") {\n        fill(sexes.begin(), sexes.end(), 0);\n    } else if (init_sex_type == \"all_ones\") {\n        fill(sexes.begin(), sexes.end(), 1);\n    } else { // random\n        for (int i = 0; i < n; ++i) {\n            sexes[i] = rnd.next(2); // 0 or 1\n        }\n    }\n\n    // Generate vi\n    vector<int> vi(n);\n    for (int i = 0; i < n; ++i) {\n        vi[i] = rnd.next(0, max_v); // 0 to max_v\n    }\n\n    // Possible appointed dogs pool\n    vector<int> dog_indices(n);\n    for (int i = 0; i < n; ++i) {\n        dog_indices[i] = i + 1;\n    }\n\n    // Generate m bets\n    vector<int> appointed_sex(m);\n    vector<int> wi(m);\n    vector<int> ki(m);\n    vector<vector<int>> appointed_dogs(m);\n    vector<int> is_good_friend(m);\n\n    vector<int> appointed_ki_dogs; // For appointed_dogs_type 'same'\n\n    if (appointed_dogs_type == \"same\") {\n        // pre-select a set of ki dogs\n        int selected_ki = 1;\n        if (ki_type == \"min\") {\n            selected_ki = 1;\n        } else if (ki_type == \"max\") {\n            selected_ki = min(max_ki, n);\n        } else { // random\n            selected_ki = rnd.next(1, min(max_ki, n));\n        }\n        shuffle(dog_indices.begin(), dog_indices.end());\n        for (int j = 0; j < selected_ki; ++j) {\n            appointed_ki_dogs.push_back(dog_indices[j]);\n        }\n    }\n\n    for (int i = 0; i < m; ++i) {\n        // Appointed sex\n        if (appointed_sex_type == \"same\") {\n            appointed_sex[i] = fixed_appointed_sex;\n        } else if (appointed_sex_type == \"conflicting\") {\n            appointed_sex[i] = i % 2;\n        } else { // random\n            appointed_sex[i] = rnd.next(2);\n        }\n\n        // wi\n        wi[i] = rnd.next(0, max_w); // 0 to max_w\n\n        // ki\n        if (ki_type == \"min\") {\n            ki[i] = 1;\n        } else if (ki_type == \"max\") {\n            ki[i] = min(max_ki, n);\n        } else { // random\n            ki[i] = rnd.next(1, min(max_ki, n));\n        }\n\n        // Appointed dogs\n        if (appointed_dogs_type == \"same\") {\n            // Use appointed_ki_dogs\n            appointed_dogs[i] = appointed_ki_dogs;\n            // Trim to ki[i] elements\n            if ((int)appointed_dogs[i].size() > ki[i]) {\n                appointed_dogs[i].resize(ki[i]);\n            }\n        } else if (appointed_dogs_type == \"different\") {\n            // Select different dogs for each bet\n            shuffle(dog_indices.begin(), dog_indices.end());\n            appointed_dogs[i].clear();\n            for (int j = 0; j < ki[i]; ++j) {\n                appointed_dogs[i].push_back(dog_indices[j]);\n            }\n        } else { // random\n            // Randomly select ki[i] distinct dogs\n            shuffle(dog_indices.begin(), dog_indices.end());\n            appointed_dogs[i].clear();\n            for (int j = 0; j < ki[i]; ++j) {\n                appointed_dogs[i].push_back(dog_indices[j]);\n            }\n        }\n\n        // Is good friend\n        if (friend_type == \"all_friends\") {\n            is_good_friend[i] = 1;\n        } else if (friend_type == \"all_not_friends\") {\n            is_good_friend[i] = 0;\n        } else { // random\n            is_good_friend[i] = rnd.next(2);\n        }\n    }\n\n    // Output\n    printf(\"%d %d %d\\n\", n, m, g);\n\n    // Output initial sexes\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d%c\", sexes[i], i == n-1 ? '\\n' : ' ');\n    }\n\n    // Output vi\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d%c\", vi[i], i == n-1 ? '\\n' : ' ');\n    }\n\n    // Output bets\n    for (int i = 0; i < m; ++i) {\n        printf(\"%d %d %d\", appointed_sex[i], wi[i], ki[i]);\n        for (int j = 0; j < ki[i]; ++j) {\n            printf(\" %d\", appointed_dogs[i][j]);\n        }\n        printf(\" %d\\n\", is_good_friend[i]);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    // Read parameters with defaults\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    int g = opt<int>(\"g\");\n    int max_v = opt<int>(\"max_v\", 10000);\n    int max_w = opt<int>(\"max_w\", 10000);\n    int max_ki = opt<int>(\"max_ki\", 10);\n    string init_sex_type = opt<string>(\"init_sex_type\", \"random\");\n    string friend_type = opt<string>(\"friend_type\", \"random\");\n    string ki_type = opt<string>(\"ki_type\", \"random\");\n    string appointed_dogs_type = opt<string>(\"appointed_dogs_type\", \"random\");\n    string appointed_sex_type = opt<string>(\"appointed_sex_type\", \"random\");\n    int fixed_appointed_sex = opt<int>(\"fixed_appointed_sex\", -1);\n\n    // Validate fixed_appointed_sex\n    if (appointed_sex_type == \"same\" && fixed_appointed_sex == -1) {\n        fixed_appointed_sex = rnd.next(2);\n    } else if (appointed_sex_type == \"same\" && fixed_appointed_sex != 0 && fixed_appointed_sex != 1) {\n        fprintf(stderr, \"Invalid fixed_appointed_sex value. It should be 0 or 1.\\n\");\n        return 1;\n    }\n\n    // Generate initial sexes\n    vector<int> sexes(n);\n    if (init_sex_type == \"all_zeros\") {\n        fill(sexes.begin(), sexes.end(), 0);\n    } else if (init_sex_type == \"all_ones\") {\n        fill(sexes.begin(), sexes.end(), 1);\n    } else { // random\n        for (int i = 0; i < n; ++i) {\n            sexes[i] = rnd.next(2); // 0 or 1\n        }\n    }\n\n    // Generate vi\n    vector<int> vi(n);\n    for (int i = 0; i < n; ++i) {\n        vi[i] = rnd.next(0, max_v); // 0 to max_v\n    }\n\n    // Possible appointed dogs pool\n    vector<int> dog_indices(n);\n    for (int i = 0; i < n; ++i) {\n        dog_indices[i] = i + 1;\n    }\n\n    // Generate m bets\n    vector<int> appointed_sex(m);\n    vector<int> wi(m);\n    vector<int> ki(m);\n    vector<vector<int>> appointed_dogs(m);\n    vector<int> is_good_friend(m);\n\n    vector<int> appointed_ki_dogs; // For appointed_dogs_type 'same'\n\n    if (appointed_dogs_type == \"same\") {\n        // pre-select a set of ki dogs\n        int selected_ki = 1;\n        if (ki_type == \"min\") {\n            selected_ki = 1;\n        } else if (ki_type == \"max\") {\n            selected_ki = min(max_ki, n);\n        } else { // random\n            selected_ki = rnd.next(1, min(max_ki, n));\n        }\n        shuffle(dog_indices.begin(), dog_indices.end());\n        for (int j = 0; j < selected_ki; ++j) {\n            appointed_ki_dogs.push_back(dog_indices[j]);\n        }\n    }\n\n    for (int i = 0; i < m; ++i) {\n        // Appointed sex\n        if (appointed_sex_type == \"same\") {\n            appointed_sex[i] = fixed_appointed_sex;\n        } else if (appointed_sex_type == \"conflicting\") {\n            appointed_sex[i] = i % 2;\n        } else { // random\n            appointed_sex[i] = rnd.next(2);\n        }\n\n        // wi\n        wi[i] = rnd.next(0, max_w); // 0 to max_w\n\n        // ki\n        if (ki_type == \"min\") {\n            ki[i] = 1;\n        } else if (ki_type == \"max\") {\n            ki[i] = min(max_ki, n);\n        } else { // random\n            ki[i] = rnd.next(1, min(max_ki, n));\n        }\n\n        // Appointed dogs\n        if (appointed_dogs_type == \"same\") {\n            // Use appointed_ki_dogs\n            appointed_dogs[i] = appointed_ki_dogs;\n            // Trim to ki[i] elements\n            if ((int)appointed_dogs[i].size() > ki[i]) {\n                appointed_dogs[i].resize(ki[i]);\n            }\n        } else if (appointed_dogs_type == \"different\") {\n            // Select different dogs for each bet\n            shuffle(dog_indices.begin(), dog_indices.end());\n            appointed_dogs[i].clear();\n            for (int j = 0; j < ki[i]; ++j) {\n                appointed_dogs[i].push_back(dog_indices[j]);\n            }\n        } else { // random\n            // Randomly select ki[i] distinct dogs\n            shuffle(dog_indices.begin(), dog_indices.end());\n            appointed_dogs[i].clear();\n            for (int j = 0; j < ki[i]; ++j) {\n                appointed_dogs[i].push_back(dog_indices[j]);\n            }\n        }\n\n        // Is good friend\n        if (friend_type == \"all_friends\") {\n            is_good_friend[i] = 1;\n        } else if (friend_type == \"all_not_friends\") {\n            is_good_friend[i] = 0;\n        } else { // random\n            is_good_friend[i] = rnd.next(2);\n        }\n    }\n\n    // Output\n    printf(\"%d %d %d\\n\", n, m, g);\n\n    // Output initial sexes\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d%c\", sexes[i], i == n-1 ? '\\n' : ' ');\n    }\n\n    // Output vi\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d%c\", vi[i], i == n-1 ? '\\n' : ' ');\n    }\n\n    // Output bets\n    for (int i = 0; i < m; ++i) {\n        printf(\"%d %d %d\", appointed_sex[i], wi[i], ki[i]);\n        for (int j = 0; j < ki[i]; ++j) {\n            printf(\" %d\", appointed_dogs[i][j]);\n        }\n        printf(\" %d\\n\", is_good_friend[i]);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -m 0 -g 0\n./gen -n 2 -m 1 -g 0\n./gen -n 2 -m 1 -g 10000 -max_v 10000 -max_w 10000\n./gen -n 10000 -m 2000 -g 10000\n./gen -n 100 -m 10 -g 1000 -init_sex_type all_zeros\n./gen -n 100 -m 10 -g 1000 -init_sex_type all_ones\n./gen -n 100 -m 10 -g 1000 -friend_type all_friends\n./gen -n 100 -m 10 -g 1000 -friend_type all_not_friends\n./gen -n 100 -m 10 -g 1000 -ki_type min\n./gen -n 100 -m 10 -g 1000 -ki_type max\n./gen -n 1000 -m 100 -g 1000 -appointed_dogs_type same\n./gen -n 1000 -m 100 -g 1000 -appointed_dogs_type same -appointed_sex_type conflicting\n./gen -n 10 -m 10 -g 1000 -ki_type max\n./gen -n 1000 -m 100 -g 1000 -max_v 0\n./gen -n 1000 -m 100 -g 1000 -max_v 10000\n./gen -n 1000 -m 100 -g 0\n./gen -n 1000 -m 100 -g 10000\n./gen -n 1000 -m 100 -g 10000 -friend_type all_friends\n./gen -n 1000 -m 100 -g 10000 -friend_type all_not_friends\n./gen -n 5000 -m 1000 -g 5000\n./gen -n 1000 -m 0 -g 1000\n./gen -n 1000 -m 2000 -g 1000\n./gen -n 1000 -m 1000 -g 1000 -appointed_dogs_type same -appointed_sex_type conflicting\n./gen -n 1000 -m 100 -g 1000 -init_sex_type all_zeros -appointed_sex_type same -fixed_appointed_sex 1\n./gen -n 1000 -m 100 -g 1000 -init_sex_type all_ones -appointed_sex_type same -fixed_appointed_sex 0\n./gen -n 1000 -m 100 -g 1000 -max_v 0\n./gen -n 100 -m 100 -g 1000 -max_w 0\n./gen -n 1000 -m 100 -g 1000 -ki_type min -appointed_dogs_type same\n./gen -n 1000 -m 100 -g 1000 -ki_type max -appointed_dogs_type different\n./gen -n 10000 -m 10 -g 1000\n./gen -n 10 -m 2000 -g 1000\n./gen -n 1000 -m 100 -g 1000 -max_w 0\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:06:26.963129",
        "total_tutorials": 3,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "312/A",
      "title": "A. Whose sentence is it?",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line of the input contains an integer n (1 ≤ n ≤ 10), number of sentences in the chat record. Each of the next n lines contains a sentence. A sentence is a string that contains only Latin letters (A-Z, a-z), underline (_), comma (,), point (.) and space ( ). Its length doesn’t exceed 100.",
      "output_spec": "OutputFor each sentence, output \"Freda's\" if the sentence was said by Freda, \"Rainbow's\" if the sentence was said by Rainbow, or \"OMG>.< I don't know!\" if liouzhou_101 can’t recognize whose sentence it is. He can’t recognize a sentence if it begins with \"miao.\" and ends with \"lala.\", or satisfies neither of the conditions.",
      "sample_tests": "ExamplesInputCopy5I will go to play with you lala.wow, welcome.miao.lala.miao.miao .OutputCopyFreda'sOMG>.< I don't know!OMG>.< I don't know!Rainbow'sOMG>.< I don't know!",
      "description": "A. Whose sentence is it?\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line of the input contains an integer n (1 ≤ n ≤ 10), number of sentences in the chat record. Each of the next n lines contains a sentence. A sentence is a string that contains only Latin letters (A-Z, a-z), underline (_), comma (,), point (.) and space ( ). Its length doesn’t exceed 100.\n\nOutputFor each sentence, output \"Freda's\" if the sentence was said by Freda, \"Rainbow's\" if the sentence was said by Rainbow, or \"OMG>.< I don't know!\" if liouzhou_101 can’t recognize whose sentence it is. He can’t recognize a sentence if it begins with \"miao.\" and ends with \"lala.\", or satisfies neither of the conditions.\n\nInputCopy5I will go to play with you lala.wow, welcome.miao.lala.miao.miao .OutputCopyFreda'sOMG>.< I don't know!OMG>.< I don't know!Rainbow'sOMG>.< I don't know!\n\nInputCopy5I will go to play with you lala.wow, welcome.miao.lala.miao.miao .\n\nOutputCopyFreda'sOMG>.< I don't know!OMG>.< I don't know!Rainbow'sOMG>.< I don't know!",
      "solutions": [
        {
          "title": "Codeforces Round #185 - Codeforces",
          "content": "Hello,everyone!Codeforces Round #185 will take place on Sunday, May 26th at 19:30MSK (23:30CST).This round is initiated by zanoes, and here are the problem setters: Div.1E & Div.2B —— zanoes (**Zhang Gaoxiang**) Div.1D & Div.1A —— liouzhou_101 (**Wang Qisheng**) Div.1C & Div.1B & Div.2A —— lydrainbowcat (**Li Yudong**) Testers are roosephu(Luo Yuping), FredaShi(Shi Haoyue), sjynoi(Sun Jiayu), sevenkplus(Gu Yuzhou), MinakoKojima(Tang Feihu) and Riatre.Especially thanks Gerald for helping us to prepare the round, MikeMirzayanov for the great platform and Delinur for translation.Score will be standard, 500-1000-1500-2000-2500 in both divisions. In our opinion, problems are easier than the past several rounds prepared by Chinese)This is our first Codeforces round, I hope you can enjoy it. Wish you high rating and good luck!UPD: We feel really sorry about the mistake we made. The following words were written by Div.1A (Div.2C)setter, liouzhou_101. http://codeforces.com/blog/entry/7773#comment-134702 . Meanwhile, It's also zanoes's and my fault that we didn't check his checker carefully, even brought troubles to Codeforces flat. I beg your forgive for liouzhou_101, for he also tried to prepare the round well these days. UPD2: The round will be unrated.Editorials will come out soon. Now you can find some of the editorials here: http://codeforces.com/blog/entry/7785Contest is over. Congratulations to the winners.Div.1 zfmdhy786 (I promise it's someone who pretends to be roosephu, and I've known who he is.) cp12321 RAD ACMonster kAc And ryz , cgy4ever, who passed problem E in the contest.Div.2 ymxlkAc sasha.sochka bohuss",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/7773",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1639
        },
        {
          "title": "Codeforces Round #185 Editorial - Codeforces",
          "content": "311A - Ближайшая параhttp://codeforces.com/blog/entry/7787311B - Транспортировка кошекP.S. I feel very sorry that I thought it was a traditional DP problem with only 800B code and didn't realize some participants were not familiar with such kind of problems, so I said it was easy. Let a[i] be the distance from hill 1 to hill i, s[i]=a[1]+a[2]+…+a[i].Firstly, we sort the cats by (Ti-a[i]). Then we can divide the cats into P consecutive parts, and plan a feeder for each part. Dynamic Programming can solve this problem.Let f[i,j] indicates the minimum sum of waiting time with i feeders and j cats.f[i,j] = f[i-1,k]+a[j]*(j-k)-s[j]+s[k] = a[j]*j-s[j] + f[i-1,k]+s[k]-a[j]*kThat’s O(PM^2). It’ll get TLE.Let p>q, if p is \"better\" than q, then:f[i-1,p]+s[p]-a[j]*p>f[i-1,q]+s[q]-a[j]*q(f[i-1,p]+s[p])-(f[i-1,q]+s[q])>a[j]*(p-q)g[p]-g[q]>a[j]*(p-q)So we can use Convex hull trick with a queue. Then we get O(MP), which can pass the problem.311C - Достать сокровищеFirstly, we solve such a problem: if we can go exactly k,k1,k2……or kp cells forward each step, what cells can we reach?We divide the H cells into k groups: Group 0,1……k-1. The i-th cell should be in Group (i mod k). If we reach Cell x in Group (x mod k), we can also reach Cell (x+kj , 1<=j<=p) in Group ((x+kj)mod k). If we reach Cell x in Group (x mod k), we can also reach Cell (x+k) in the same group. Let D[i] be the minimum cell we can reach in Group i. Then we can reach all the cells which number are bigger then D[i] in Group i. Regard the groups as points. Regard k,k1,k2……kp as edges. And use a Shortest-Path Algorithm to calculate all D[i]. Notice that there are at most 20 operations of type 1, we are able to run such an algorithm after each of these operations. The total time complexity is O(20*k*20*log(k)) with Dijkstra.Secondly, we build a binary-heap to solve operations of type 2 and 3. Type1 – If a D[i] becomes smaller, we put the new cells we can reach into the heap. Type2 – Decrease a value of a node in the heap, or a cell in the “Treasure Cell” array. Type3 – Ask the biggest node in the heap and delete it. These are basic operations of binary-heap. The time complexity is O(NlogN). In C++, you can also use priority_queue from STL and lazy-tags. So we can solve the whole problem in O(400klogk+NlogN).311D - Куб на отрезкеhttp://codeforces.com/blog/entry/7787311E - Биологhttp://codeforces.com/blog/entry/7847312A - Чье это предложение?We only need to find out if “miao.” is a prefix of the sentence, and if “lala.” is a suffix of the sentence. Pay attention to the situation when both conditions are satisfied.312B - Лучникиhttp://codeforces.com/blog/entry/7847",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/7785",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 312\\s*A"
          },
          "content_length": 2656
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #185 - Codeforces - Code 1",
          "code": "I do not have time to participate in a number of competitions, this one I think I can get a better grade, yes I do , with good grade. But no rating changed.\nI may not to blame the one who hold the round, but I do not want this happen again.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7773",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #185 Editorial - Codeforces - Code 1",
          "code": "FOR i from 1 to n\n    PRINT (n-i,0)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7785",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #185 Editorial - Codeforces - Code 2",
          "code": "FOR i from 1 to n\n    PRINT (n-i,0)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7785",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 10, \"n\");\n    inf.readEoln();\n    for (int i = 0; i < n; i++) {\n        string s = inf.readLine(\"^[A-Za-z_,. ]{1,100}$\");\n    }\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 10, \"n\");\n    inf.readEoln();\n    for (int i = 0; i < n; i++) {\n        string s = inf.readLine(\"^[A-Za-z_,. ]{1,100}$\");\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 10, \"n\");\n    inf.readEoln();\n    for (int i = 0; i < n; i++) {\n        string s = inf.readLine(\"^[A-Za-z_,. ]{1,100}$\");\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare sequences of tokens\");\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string j, p;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n\r\n        ans.readWordTo(j);\r\n        ouf.readWordTo(p);\r\n\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s words differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  compress(j).c_str(), compress(p).c_str());\r\n    }\r\n\r\n    if (ans.seekEof() && ouf.seekEof()) {\r\n        if (n == 1)\r\n            quitf(_ok, \"\\\"%s\\\"\", compress(j).c_str());\r\n        else\r\n            quitf(_ok, \"%d tokens\", n);\r\n    } else {\r\n        if (ans.seekEof())\r\n            quitf(_wa, \"Participant output contains extra tokens\");\r\n        else\r\n            quitf(_wa, \"Unexpected EOF in the participants output\");\r\n    }\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAX_LENGTH = 100;\n\nstring generate_random_sentence(int len) {\n    string chars = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_,. \";\n    string s;\n    for (int i = 0; i < len; ++i) {\n        s += chars[rnd.next(0, (int)chars.size() - 1)];\n    }\n    return s;\n}\n\nstring generate_sentence_with_end(string end_str, bool avoid_start = false) {\n    int max_body_len = MAX_LENGTH - (int)end_str.size();\n    if (max_body_len < 0) {\n        // Cannot generate such a sentence\n        return end_str.substr(0, MAX_LENGTH);\n    }\n    int body_len = rnd.next(0, max_body_len);\n    string body;\n    do {\n        body = generate_random_sentence(body_len);\n    } while (avoid_start && body.substr(0, 5) == \"miao.\");\n    return body + end_str;\n}\n\nstring generate_sentence_with_start(string start_str, bool avoid_end = false) {\n    int max_body_len = MAX_LENGTH - (int)start_str.size();\n    if (max_body_len < 0) {\n        // Cannot generate such a sentence\n        return start_str.substr(0, MAX_LENGTH);\n    }\n    int body_len = rnd.next(0, max_body_len);\n    string body;\n    do {\n        body = generate_random_sentence(body_len);\n    } while (avoid_end && body.size() >= 5 && body.substr(body.size()-5) == \"lala.\");\n    return start_str + body;\n}\n\nstring generate_sentence_with_start_and_end(string start_str, string end_str) {\n    int max_body_len = MAX_LENGTH - (int)start_str.size() - (int)end_str.size();\n    if (max_body_len < 0) {\n        // Need to truncate end_str\n        int available_len = MAX_LENGTH - (int)start_str.size();\n        return start_str + end_str.substr(0, available_len);\n    }\n    int body_len = rnd.next(0, max_body_len);\n    string body = generate_random_sentence(body_len);\n    return start_str + body + end_str;\n}\n\nstring generate_sentence_neither() {\n    int len = rnd.next(1, MAX_LENGTH);\n    string s;\n    do {\n        s = generate_random_sentence(len);\n    } while ((s.substr(0, 5) == \"miao.\") || (s.size() >= 5 && s.substr(s.size() - 5) == \"lala.\"));\n    return s;\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    if (n < 1) n = 1;\n    if (n > 10) n = 10;\n\n    printf(\"%d\\n\", n);\n\n    for (int i = 0; i < n; ++i) {\n        string sentence;\n        if (type == \"freda\") {\n            // Sentence that ends with \"lala.\", does not start with \"miao.\"\n            sentence = generate_sentence_with_end(\"lala.\", true);\n        } else if (type == \"rainbow\") {\n            // Sentence that starts with \"miao.\", does not end with \"lala.\"\n            sentence = generate_sentence_with_start(\"miao.\", true);\n        } else if (type == \"both\") {\n            // Sentence that starts with \"miao.\", ends with \"lala.\"\n            sentence = generate_sentence_with_start_and_end(\"miao.\", \"lala.\");\n        } else if (type == \"neither\") {\n            // Sentence that neither starts with \"miao.\" nor ends with \"lala.\"\n            sentence = generate_sentence_neither();\n        } else if (type == \"maxlen\") {\n            // Generate sentence of length exactly MAX_LENGTH\n            sentence = generate_random_sentence(MAX_LENGTH);\n\n            // Ensure that it's neither starting with \"miao.\" nor ending with \"lala.\"\n            if (sentence.substr(0, 5) == \"miao.\" || sentence.substr(MAX_LENGTH - 5) == \"lala.\") {\n                // Modify the sentence to avoid starting with \"miao.\" or ending with \"lala.\"\n                sentence[0] = 'X';\n                sentence[MAX_LENGTH - 1] = 'Y';\n            }\n        } else if (type == \"leading_space\") {\n            // Sentence that has spaces before \"miao.\"\n            sentence = string(rnd.next(1, 5), ' ') + \"miao.\" + generate_sentence_neither();\n        } else if (type == \"trailing_space\") {\n            // Sentence that ends with \"lala.\" followed by spaces\n            sentence = generate_sentence_neither() + \"lala.\" + string(rnd.next(1, 5), ' ');\n            if (sentence.length() > MAX_LENGTH) {\n                sentence = sentence.substr(0, MAX_LENGTH);\n            }\n        } else if (type == \"special\") {\n            // Use special cases to test potential mistakes\n            // Generate sentences with \"miao.\" or \"lala.\" in the middle\n            int len1 = rnd.next(1, MAX_LENGTH / 3);\n            int len2 = MAX_LENGTH - len1 - 10;\n            if (len2 < 0) len2 = 0;\n            string part1 = generate_random_sentence(len1);\n            string part2 = generate_random_sentence(len2);\n            sentence = part1 + \"miao.lala.\" + part2;\n            if (sentence.size() > MAX_LENGTH) {\n                sentence = sentence.substr(0, MAX_LENGTH);\n            }\n        } else {\n            // Random sentence\n            int len = rnd.next(1, MAX_LENGTH);\n            sentence = generate_random_sentence(len);\n        }\n\n        printf(\"%s\\n\", sentence.c_str());\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAX_LENGTH = 100;\n\nstring generate_random_sentence(int len) {\n    string chars = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_,. \";\n    string s;\n    for (int i = 0; i < len; ++i) {\n        s += chars[rnd.next(0, (int)chars.size() - 1)];\n    }\n    return s;\n}\n\nstring generate_sentence_with_end(string end_str, bool avoid_start = false) {\n    int max_body_len = MAX_LENGTH - (int)end_str.size();\n    if (max_body_len < 0) {\n        // Cannot generate such a sentence\n        return end_str.substr(0, MAX_LENGTH);\n    }\n    int body_len = rnd.next(0, max_body_len);\n    string body;\n    do {\n        body = generate_random_sentence(body_len);\n    } while (avoid_start && body.substr(0, 5) == \"miao.\");\n    return body + end_str;\n}\n\nstring generate_sentence_with_start(string start_str, bool avoid_end = false) {\n    int max_body_len = MAX_LENGTH - (int)start_str.size();\n    if (max_body_len < 0) {\n        // Cannot generate such a sentence\n        return start_str.substr(0, MAX_LENGTH);\n    }\n    int body_len = rnd.next(0, max_body_len);\n    string body;\n    do {\n        body = generate_random_sentence(body_len);\n    } while (avoid_end && body.size() >= 5 && body.substr(body.size()-5) == \"lala.\");\n    return start_str + body;\n}\n\nstring generate_sentence_with_start_and_end(string start_str, string end_str) {\n    int max_body_len = MAX_LENGTH - (int)start_str.size() - (int)end_str.size();\n    if (max_body_len < 0) {\n        // Need to truncate end_str\n        int available_len = MAX_LENGTH - (int)start_str.size();\n        return start_str + end_str.substr(0, available_len);\n    }\n    int body_len = rnd.next(0, max_body_len);\n    string body = generate_random_sentence(body_len);\n    return start_str + body + end_str;\n}\n\nstring generate_sentence_neither() {\n    int len = rnd.next(1, MAX_LENGTH);\n    string s;\n    do {\n        s = generate_random_sentence(len);\n    } while ((s.substr(0, 5) == \"miao.\") || (s.size() >= 5 && s.substr(s.size() - 5) == \"lala.\"));\n    return s;\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    if (n < 1) n = 1;\n    if (n > 10) n = 10;\n\n    printf(\"%d\\n\", n);\n\n    for (int i = 0; i < n; ++i) {\n        string sentence;\n        if (type == \"freda\") {\n            // Sentence that ends with \"lala.\", does not start with \"miao.\"\n            sentence = generate_sentence_with_end(\"lala.\", true);\n        } else if (type == \"rainbow\") {\n            // Sentence that starts with \"miao.\", does not end with \"lala.\"\n            sentence = generate_sentence_with_start(\"miao.\", true);\n        } else if (type == \"both\") {\n            // Sentence that starts with \"miao.\", ends with \"lala.\"\n            sentence = generate_sentence_with_start_and_end(\"miao.\", \"lala.\");\n        } else if (type == \"neither\") {\n            // Sentence that neither starts with \"miao.\" nor ends with \"lala.\"\n            sentence = generate_sentence_neither();\n        } else if (type == \"maxlen\") {\n            // Generate sentence of length exactly MAX_LENGTH\n            sentence = generate_random_sentence(MAX_LENGTH);\n\n            // Ensure that it's neither starting with \"miao.\" nor ending with \"lala.\"\n            if (sentence.substr(0, 5) == \"miao.\" || sentence.substr(MAX_LENGTH - 5) == \"lala.\") {\n                // Modify the sentence to avoid starting with \"miao.\" or ending with \"lala.\"\n                sentence[0] = 'X';\n                sentence[MAX_LENGTH - 1] = 'Y';\n            }\n        } else if (type == \"leading_space\") {\n            // Sentence that has spaces before \"miao.\"\n            sentence = string(rnd.next(1, 5), ' ') + \"miao.\" + generate_sentence_neither();\n        } else if (type == \"trailing_space\") {\n            // Sentence that ends with \"lala.\" followed by spaces\n            sentence = generate_sentence_neither() + \"lala.\" + string(rnd.next(1, 5), ' ');\n            if (sentence.length() > MAX_LENGTH) {\n                sentence = sentence.substr(0, MAX_LENGTH);\n            }\n        } else if (type == \"special\") {\n            // Use special cases to test potential mistakes\n            // Generate sentences with \"miao.\" or \"lala.\" in the middle\n            int len1 = rnd.next(1, MAX_LENGTH / 3);\n            int len2 = MAX_LENGTH - len1 - 10;\n            if (len2 < 0) len2 = 0;\n            string part1 = generate_random_sentence(len1);\n            string part2 = generate_random_sentence(len2);\n            sentence = part1 + \"miao.lala.\" + part2;\n            if (sentence.size() > MAX_LENGTH) {\n                sentence = sentence.substr(0, MAX_LENGTH);\n            }\n        } else {\n            // Random sentence\n            int len = rnd.next(1, MAX_LENGTH);\n            sentence = generate_random_sentence(len);\n        }\n\n        printf(\"%s\\n\", sentence.c_str());\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -type freda\n./gen -n 1 -type rainbow\n./gen -n 1 -type both\n./gen -n 1 -type neither\n./gen -n 1 -type maxlen\n./gen -n 1 -type special\n\n./gen -n 5 -type freda\n./gen -n 5 -type rainbow\n./gen -n 5 -type both\n./gen -n 5 -type neither\n./gen -n 5 -type maxlen\n./gen -n 5 -type special\n\n./gen -n 10 -type freda\n./gen -n 10 -type rainbow\n./gen -n 10 -type both\n./gen -n 10 -type neither\n./gen -n 10 -type maxlen\n./gen -n 10 -type special\n\n./gen -n 10 -type leading_space\n./gen -n 10 -type trailing_space\n\n./gen -n 5 -type leading_space\n./gen -n 5 -type trailing_space\n\n./gen -n 10 -type random\n./gen -n 10 -type random\n\n./gen -n 10 -type freda\n./gen -n 10 -type rainbow\n./gen -n 10 -type both\n./gen -n 10 -type neither\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:06:28.758816",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "312/B",
      "title": "B. Archer",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputA single line contains four integers .",
      "output_spec": "OutputPrint a single real number, the probability that SmallR will win the match.The answer will be considered correct if the absolute or relative error doesn't exceed 10 - 6.",
      "sample_tests": "ExamplesInputCopy1 2 1 2OutputCopy0.666666666667",
      "description": "time limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputA single line contains four integers .\n\nOutputPrint a single real number, the probability that SmallR will win the match.The answer will be considered correct if the absolute or relative error doesn't exceed 10 - 6.\n\nInputCopy1 2 1 2OutputCopy0.666666666667\n\nInputCopy1 2 1 2\n\nOutputCopy0.666666666667",
      "solutions": [
        {
          "title": "Codeforces Round #185 - Codeforces",
          "content": "Hello,everyone!Codeforces Round #185 will take place on Sunday, May 26th at 19:30MSK (23:30CST).This round is initiated by zanoes, and here are the problem setters: Div.1E & Div.2B —— zanoes (**Zhang Gaoxiang**) Div.1D & Div.1A —— liouzhou_101 (**Wang Qisheng**) Div.1C & Div.1B & Div.2A —— lydrainbowcat (**Li Yudong**) Testers are roosephu(Luo Yuping), FredaShi(Shi Haoyue), sjynoi(Sun Jiayu), sevenkplus(Gu Yuzhou), MinakoKojima(Tang Feihu) and Riatre.Especially thanks Gerald for helping us to prepare the round, MikeMirzayanov for the great platform and Delinur for translation.Score will be standard, 500-1000-1500-2000-2500 in both divisions. In our opinion, problems are easier than the past several rounds prepared by Chinese)This is our first Codeforces round, I hope you can enjoy it. Wish you high rating and good luck!UPD: We feel really sorry about the mistake we made. The following words were written by Div.1A (Div.2C)setter, liouzhou_101. http://codeforces.com/blog/entry/7773#comment-134702 . Meanwhile, It's also zanoes's and my fault that we didn't check his checker carefully, even brought troubles to Codeforces flat. I beg your forgive for liouzhou_101, for he also tried to prepare the round well these days. UPD2: The round will be unrated.Editorials will come out soon. Now you can find some of the editorials here: http://codeforces.com/blog/entry/7785Contest is over. Congratulations to the winners.Div.1 zfmdhy786 (I promise it's someone who pretends to be roosephu, and I've known who he is.) cp12321 RAD ACMonster kAc And ryz , cgy4ever, who passed problem E in the contest.Div.2 ymxlkAc sasha.sochka bohuss",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/7773",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1639
        },
        {
          "title": "Codeforces Round #185 Editorial - Codeforces",
          "content": "311A - Ближайшая параhttp://codeforces.com/blog/entry/7787311B - Транспортировка кошекP.S. I feel very sorry that I thought it was a traditional DP problem with only 800B code and didn't realize some participants were not familiar with such kind of problems, so I said it was easy. Let a[i] be the distance from hill 1 to hill i, s[i]=a[1]+a[2]+…+a[i].Firstly, we sort the cats by (Ti-a[i]). Then we can divide the cats into P consecutive parts, and plan a feeder for each part. Dynamic Programming can solve this problem.Let f[i,j] indicates the minimum sum of waiting time with i feeders and j cats.f[i,j] = f[i-1,k]+a[j]*(j-k)-s[j]+s[k] = a[j]*j-s[j] + f[i-1,k]+s[k]-a[j]*kThat’s O(PM^2). It’ll get TLE.Let p>q, if p is \"better\" than q, then:f[i-1,p]+s[p]-a[j]*p>f[i-1,q]+s[q]-a[j]*q(f[i-1,p]+s[p])-(f[i-1,q]+s[q])>a[j]*(p-q)g[p]-g[q]>a[j]*(p-q)So we can use Convex hull trick with a queue. Then we get O(MP), which can pass the problem.311C - Достать сокровищеFirstly, we solve such a problem: if we can go exactly k,k1,k2……or kp cells forward each step, what cells can we reach?We divide the H cells into k groups: Group 0,1……k-1. The i-th cell should be in Group (i mod k). If we reach Cell x in Group (x mod k), we can also reach Cell (x+kj , 1<=j<=p) in Group ((x+kj)mod k). If we reach Cell x in Group (x mod k), we can also reach Cell (x+k) in the same group. Let D[i] be the minimum cell we can reach in Group i. Then we can reach all the cells which number are bigger then D[i] in Group i. Regard the groups as points. Regard k,k1,k2……kp as edges. And use a Shortest-Path Algorithm to calculate all D[i]. Notice that there are at most 20 operations of type 1, we are able to run such an algorithm after each of these operations. The total time complexity is O(20*k*20*log(k)) with Dijkstra.Secondly, we build a binary-heap to solve operations of type 2 and 3. Type1 – If a D[i] becomes smaller, we put the new cells we can reach into the heap. Type2 – Decrease a value of a node in the heap, or a cell in the “Treasure Cell” array. Type3 – Ask the biggest node in the heap and delete it. These are basic operations of binary-heap. The time complexity is O(NlogN). In C++, you can also use priority_queue from STL and lazy-tags. So we can solve the whole problem in O(400klogk+NlogN).311D - Куб на отрезкеhttp://codeforces.com/blog/entry/7787311E - Биологhttp://codeforces.com/blog/entry/7847312A - Чье это предложение?We only need to find out if “miao.” is a prefix of the sentence, and if “lala.” is a suffix of the sentence. Pay attention to the situation when both conditions are satisfied.312B - Лучникиhttp://codeforces.com/blog/entry/7847",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/7785",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 312\\s*B"
          },
          "content_length": 2656
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #185 - Codeforces - Code 1",
          "code": "I do not have time to participate in a number of competitions, this one I think I can get a better grade, yes I do , with good grade. But no rating changed.\nI may not to blame the one who hold the round, but I do not want this happen again.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7773",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #185 Editorial - Codeforces - Code 1",
          "code": "FOR i from 1 to n\n    PRINT (n-i,0)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7785",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #185 Editorial - Codeforces - Code 2",
          "code": "FOR i from 1 to n\n    PRINT (n-i,0)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7785",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int a = inf.readInt(0, 1000000000, \"a\");\n    inf.readSpace();\n    int b = inf.readInt(1, 1000000000, \"b\");\n    inf.readSpace();\n    int c = inf.readInt(0, 1000000000, \"c\");\n    inf.readSpace();\n    int d = inf.readInt(1, 1000000000, \"d\");\n    inf.readEoln();\n\n    ensuref(a <= b, \"a (%d) should be less than or equal to b (%d)\", a, b);\n    ensuref(c <= d, \"c (%d) should be less than or equal to d (%d)\", c, d);\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int a = inf.readInt(0, 1000000000, \"a\");\n    inf.readSpace();\n    int b = inf.readInt(1, 1000000000, \"b\");\n    inf.readSpace();\n    int c = inf.readInt(0, 1000000000, \"c\");\n    inf.readSpace();\n    int d = inf.readInt(1, 1000000000, \"d\");\n    inf.readEoln();\n\n    ensuref(a <= b, \"a (%d) should be less than or equal to b (%d)\", a, b);\n    ensuref(c <= d, \"c (%d) should be less than or equal to d (%d)\", c, d);\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int a = inf.readInt(0, 1000000000, \"a\");\n    inf.readSpace();\n    int b = inf.readInt(1, 1000000000, \"b\");\n    inf.readSpace();\n    int c = inf.readInt(0, 1000000000, \"c\");\n    inf.readSpace();\n    int d = inf.readInt(1, 1000000000, \"d\");\n    inf.readEoln();\n\n    ensuref(a <= b, \"a (%d) should be less than or equal to b (%d)\", a, b);\n    ensuref(c <= d, \"c (%d) should be less than or equal to d (%d)\", c, d);\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nconst double EPS = 1E-6;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare two sequences of doubles, max absolute or relative  error = %.7f\", EPS);\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    double j = 0, p = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        n++;\r\n        j = ans.readDouble();\r\n        p = ouf.readDouble();\r\n        if (!doubleCompare(j, p, EPS)) {\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%.7f', found: '%.7f', error = '%.7f'\",\r\n                  n, englishEnding(n).c_str(), j, p, doubleDelta(j, p));\r\n        }\r\n    }\r\n\r\n    if (n == 1)\r\n        quitf(_ok, \"found '%.7f', expected '%.7f', error '%.7f'\", p, j, doubleDelta(j, p));\r\n\r\n    quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    // Parse options\n    int maxq = opt<int>(\"maxq\", 1000000000);\n    string type = opt<string>(\"type\", \"random\");\n\n    int p, q, p1, q1;\n\n    if (type == \"zeros\") {\n        // Set p or p1 to zero\n        q = rnd.next(1, maxq);\n        q1 = rnd.next(1, maxq);\n\n        // Randomly decide which of p or p1 is zero\n        if (rnd.next(0,1) == 0) {\n            p = 0;\n            p1 = rnd.next(0, q1);\n        } else {\n            p = rnd.next(0, q);\n            p1 = 0;\n        }\n    } else if (type == \"ones\") {\n        // Set p=q or p1=q1\n        q = rnd.next(1, maxq);\n        q1 = rnd.next(1, maxq);\n\n        // Randomly decide which of p or p1 equals q or q1\n        if (rnd.next(0,1) == 0) {\n            p = q;\n            p1 = rnd.next(0, q1);\n        } else {\n            p = rnd.next(0, q);\n            p1 = q1;\n        }\n    } else if (type == \"extremes\") {\n        // Set probabilities to 0 or 1\n        q = rnd.next(1, maxq);\n        q1 = rnd.next(1, maxq);\n\n        // Randomly set p and p1 to 0 or q/q1\n        p = rnd.next(0, 1) == 0 ? 0 : q;\n        p1 = rnd.next(0, 1) == 0 ? 0 : q1;\n    } else if (type == \"max\") {\n        // Set p, q, p1, q1 to maximum possible values\n        q = maxq;\n        q1 = maxq;\n        p = rnd.next(0, q);\n        p1 = rnd.next(0, q1);\n    } else if (type == \"small\") {\n        // Small values\n        q = rnd.next(1, 10);\n        q1 = rnd.next(1, 10);\n        p = rnd.next(0, q);\n        p1 = rnd.next(0, q1);\n    } else if (type == \"equal\") {\n        // p/q == p1/q1\n        q = rnd.next(1, maxq);\n        p = rnd.next(0, q);\n        q1 = q;\n        p1 = p;\n    } else {\n        // Random case\n        q = rnd.next(1, maxq);\n        q1 = rnd.next(1, maxq);\n        p = rnd.next(0, q);\n        p1 = rnd.next(0, q1);\n    }\n\n    // Output the test case\n    printf(\"%d %d %d %d\\n\", p, q, p1, q1);\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    // Parse options\n    int maxq = opt<int>(\"maxq\", 1000000000);\n    string type = opt<string>(\"type\", \"random\");\n\n    int p, q, p1, q1;\n\n    if (type == \"zeros\") {\n        // Set p or p1 to zero\n        q = rnd.next(1, maxq);\n        q1 = rnd.next(1, maxq);\n\n        // Randomly decide which of p or p1 is zero\n        if (rnd.next(0,1) == 0) {\n            p = 0;\n            p1 = rnd.next(0, q1);\n        } else {\n            p = rnd.next(0, q);\n            p1 = 0;\n        }\n    } else if (type == \"ones\") {\n        // Set p=q or p1=q1\n        q = rnd.next(1, maxq);\n        q1 = rnd.next(1, maxq);\n\n        // Randomly decide which of p or p1 equals q or q1\n        if (rnd.next(0,1) == 0) {\n            p = q;\n            p1 = rnd.next(0, q1);\n        } else {\n            p = rnd.next(0, q);\n            p1 = q1;\n        }\n    } else if (type == \"extremes\") {\n        // Set probabilities to 0 or 1\n        q = rnd.next(1, maxq);\n        q1 = rnd.next(1, maxq);\n\n        // Randomly set p and p1 to 0 or q/q1\n        p = rnd.next(0, 1) == 0 ? 0 : q;\n        p1 = rnd.next(0, 1) == 0 ? 0 : q1;\n    } else if (type == \"max\") {\n        // Set p, q, p1, q1 to maximum possible values\n        q = maxq;\n        q1 = maxq;\n        p = rnd.next(0, q);\n        p1 = rnd.next(0, q1);\n    } else if (type == \"small\") {\n        // Small values\n        q = rnd.next(1, 10);\n        q1 = rnd.next(1, 10);\n        p = rnd.next(0, q);\n        p1 = rnd.next(0, q1);\n    } else if (type == \"equal\") {\n        // p/q == p1/q1\n        q = rnd.next(1, maxq);\n        p = rnd.next(0, q);\n        q1 = q;\n        p1 = p;\n    } else {\n        // Random case\n        q = rnd.next(1, maxq);\n        q1 = rnd.next(1, maxq);\n        p = rnd.next(0, q);\n        p1 = rnd.next(0, q1);\n    }\n\n    // Output the test case\n    printf(\"%d %d %d %d\\n\", p, q, p1, q1);\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -type zeros\n./gen -type zeros\n./gen -type zeros -maxq 100\n./gen -type ones\n./gen -type ones\n./gen -type ones -maxq 100\n./gen -type extremes\n./gen -type extremes\n./gen -type extremes -maxq 500\n./gen -type max\n./gen -type max -maxq 1000000000\n./gen -type small\n./gen -type small\n./gen -type small\n./gen -type equal\n./gen -type equal\n./gen -type equal -maxq 1000000\n./gen -type random\n./gen -type random\n./gen -type random\n./gen -type random -maxq 10\n./gen -type random -maxq 100\n./gen -type random -maxq 1000\n./gen -type random -maxq 1000000\n./gen -type random -maxq 1000000000\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:06:30.763764",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "312/C",
      "title": "C. The Closest Pair",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputA single line which contains two space-separated integers n and k (2 ≤ n ≤ 2000, 1 ≤ k ≤ 109).",
      "output_spec": "OutputIf there doesn't exist such a data which let the given code get TLE, print \"no solution\" (without quotes); else print n lines, and the i-th line contains two integers xi, yi (|xi|, |yi| ≤ 109) representing the coordinates of the i-th point.The conditions below must be held:  All the points must be distinct.  |xi|, |yi| ≤ 109.  After running the given code, the value of tot should be larger than k.",
      "sample_tests": "ExamplesInputCopy4 3OutputCopy0 00 11 01 1InputCopy2 100OutputCopyno solution",
      "description": "C. The Closest Pair\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputA single line which contains two space-separated integers n and k (2 ≤ n ≤ 2000, 1 ≤ k ≤ 109).\n\nOutputIf there doesn't exist such a data which let the given code get TLE, print \"no solution\" (without quotes); else print n lines, and the i-th line contains two integers xi, yi (|xi|, |yi| ≤ 109) representing the coordinates of the i-th point.The conditions below must be held:  All the points must be distinct.  |xi|, |yi| ≤ 109.  After running the given code, the value of tot should be larger than k.\n\nInputCopy4 3OutputCopy0 00 11 01 1InputCopy2 100OutputCopyno solution\n\nInputCopy4 3\n\nOutputCopy0 00 11 01 1\n\nInputCopy2 100\n\nOutputCopyno solution",
      "solutions": [
        {
          "title": "Codeforces Round #185 - Codeforces",
          "content": "Hello,everyone!Codeforces Round #185 will take place on Sunday, May 26th at 19:30MSK (23:30CST).This round is initiated by zanoes, and here are the problem setters: Div.1E & Div.2B —— zanoes (**Zhang Gaoxiang**) Div.1D & Div.1A —— liouzhou_101 (**Wang Qisheng**) Div.1C & Div.1B & Div.2A —— lydrainbowcat (**Li Yudong**) Testers are roosephu(Luo Yuping), FredaShi(Shi Haoyue), sjynoi(Sun Jiayu), sevenkplus(Gu Yuzhou), MinakoKojima(Tang Feihu) and Riatre.Especially thanks Gerald for helping us to prepare the round, MikeMirzayanov for the great platform and Delinur for translation.Score will be standard, 500-1000-1500-2000-2500 in both divisions. In our opinion, problems are easier than the past several rounds prepared by Chinese)This is our first Codeforces round, I hope you can enjoy it. Wish you high rating and good luck!UPD: We feel really sorry about the mistake we made. The following words were written by Div.1A (Div.2C)setter, liouzhou_101. http://codeforces.com/blog/entry/7773#comment-134702 . Meanwhile, It's also zanoes's and my fault that we didn't check his checker carefully, even brought troubles to Codeforces flat. I beg your forgive for liouzhou_101, for he also tried to prepare the round well these days. UPD2: The round will be unrated.Editorials will come out soon. Now you can find some of the editorials here: http://codeforces.com/blog/entry/7785Contest is over. Congratulations to the winners.Div.1 zfmdhy786 (I promise it's someone who pretends to be roosephu, and I've known who he is.) cp12321 RAD ACMonster kAc And ryz , cgy4ever, who passed problem E in the contest.Div.2 ymxlkAc sasha.sochka bohuss",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/7773",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1639
        },
        {
          "title": "Codeforces Round #185 Editorial - Codeforces",
          "content": "311A - Ближайшая параhttp://codeforces.com/blog/entry/7787311B - Транспортировка кошекP.S. I feel very sorry that I thought it was a traditional DP problem with only 800B code and didn't realize some participants were not familiar with such kind of problems, so I said it was easy. Let a[i] be the distance from hill 1 to hill i, s[i]=a[1]+a[2]+…+a[i].Firstly, we sort the cats by (Ti-a[i]). Then we can divide the cats into P consecutive parts, and plan a feeder for each part. Dynamic Programming can solve this problem.Let f[i,j] indicates the minimum sum of waiting time with i feeders and j cats.f[i,j] = f[i-1,k]+a[j]*(j-k)-s[j]+s[k] = a[j]*j-s[j] + f[i-1,k]+s[k]-a[j]*kThat’s O(PM^2). It’ll get TLE.Let p>q, if p is \"better\" than q, then:f[i-1,p]+s[p]-a[j]*p>f[i-1,q]+s[q]-a[j]*q(f[i-1,p]+s[p])-(f[i-1,q]+s[q])>a[j]*(p-q)g[p]-g[q]>a[j]*(p-q)So we can use Convex hull trick with a queue. Then we get O(MP), which can pass the problem.311C - Достать сокровищеFirstly, we solve such a problem: if we can go exactly k,k1,k2……or kp cells forward each step, what cells can we reach?We divide the H cells into k groups: Group 0,1……k-1. The i-th cell should be in Group (i mod k). If we reach Cell x in Group (x mod k), we can also reach Cell (x+kj , 1<=j<=p) in Group ((x+kj)mod k). If we reach Cell x in Group (x mod k), we can also reach Cell (x+k) in the same group. Let D[i] be the minimum cell we can reach in Group i. Then we can reach all the cells which number are bigger then D[i] in Group i. Regard the groups as points. Regard k,k1,k2……kp as edges. And use a Shortest-Path Algorithm to calculate all D[i]. Notice that there are at most 20 operations of type 1, we are able to run such an algorithm after each of these operations. The total time complexity is O(20*k*20*log(k)) with Dijkstra.Secondly, we build a binary-heap to solve operations of type 2 and 3. Type1 – If a D[i] becomes smaller, we put the new cells we can reach into the heap. Type2 – Decrease a value of a node in the heap, or a cell in the “Treasure Cell” array. Type3 – Ask the biggest node in the heap and delete it. These are basic operations of binary-heap. The time complexity is O(NlogN). In C++, you can also use priority_queue from STL and lazy-tags. So we can solve the whole problem in O(400klogk+NlogN).311D - Куб на отрезкеhttp://codeforces.com/blog/entry/7787311E - Биологhttp://codeforces.com/blog/entry/7847312A - Чье это предложение?We only need to find out if “miao.” is a prefix of the sentence, and if “lala.” is a suffix of the sentence. Pay attention to the situation when both conditions are satisfied.312B - Лучникиhttp://codeforces.com/blog/entry/7847",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/7785",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.6,
            "reason": "宽松匹配: 包含题目编号 312 和字母"
          },
          "content_length": 2656
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #185 - Codeforces - Code 1",
          "code": "I do not have time to participate in a number of competitions, this one I think I can get a better grade, yes I do , with good grade. But no rating changed.\nI may not to blame the one who hold the round, but I do not want this happen again.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7773",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #185 Editorial - Codeforces - Code 1",
          "code": "FOR i from 1 to n\n    PRINT (n-i,0)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7785",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #185 Editorial - Codeforces - Code 2",
          "code": "FOR i from 1 to n\n    PRINT (n-i,0)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7785",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(2, 2000, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(1, 1000000000, \"k\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(2, 2000, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(1, 1000000000, \"k\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(2, 2000, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(1, 1000000000, \"k\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAX_COORD = int(1e9);\n\nint main(int argc, char* argv[]) {\n    registerTestlibCmd(argc, argv);\n\n    // Read n and k from the input file\n    int n = inf.readInt(2, 2000, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(1, int(1e9), \"k\");\n    inf.readEoln();\n    inf.readEof();\n\n    // Compute the maximum possible tot\n    long long tot_max = 1LL * n * (n - 1) / 2;\n\n    if (tot_max <= k) {\n        // No solution exists\n        string word1 = ouf.readToken();\n        if (word1 != \"no\")\n            quitf(_wa, \"Expected 'no solution', found '%s'\", word1.c_str());\n\n        string word2 = ouf.readToken();\n        if (word2 != \"solution\")\n            quitf(_wa, \"Expected 'no solution', found 'no %s'\", word2.c_str());\n\n        // Ensure there's nothing else\n        if (!ouf.seekEof())\n            quitf(_wa, \"Extra output found after 'no solution'\");\n\n        quitf(_ok, \"Correctly reported 'no solution'\");\n    } else {\n        // A solution must exist\n        // Read n lines of points\n        vector<pair<int, int>> points;\n        set<pair<int, int>> point_set;\n        for (int i = 0; i < n; ++i) {\n            int x = ouf.readInt(-MAX_COORD, MAX_COORD, \"x\");\n            ouf.readSpace();\n            int y = ouf.readInt(-MAX_COORD, MAX_COORD, \"y\");\n            ouf.readEoln();\n\n            if (point_set.count({x, y}))\n                quitf(_wa, \"Point (%d, %d) appears more than once\", x, y);\n            point_set.insert({x, y});\n\n            points.emplace_back(x, y);\n        }\n        if (!ouf.seekEof())\n            quitf(_wa, \"Extra output found after reading %d points\", n);\n\n        // Simulate the given code to compute tot\n        // Sort points by increasing x, then increasing y\n        sort(points.begin(), points.end());\n\n        double d = 1e20;\n        long long tot = 0;\n\n        for (int i = 0; i < n; ++i) {\n            for (int j = i + 1; j < n; ++j) {\n                ++tot;\n                if (points[j].first - points[i].first >= d)\n                    break;\n\n                long long dx = points[i].first - points[j].first;\n                long long dy = points[i].second - points[j].second;\n                double dist = sqrt(1.0L * dx * dx + 1.0L * dy * dy);\n                if (dist < d)\n                    d = dist;\n            }\n        }\n\n        if (tot > k) {\n            quitf(_ok, \"Found tot = %lld > k = %d\", tot, k);\n        } else {\n            quitf(_wa, \"Computed tot = %lld which is not greater than k = %d\", tot, k);\n        }\n    }\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\n/*\n  This generator produces a single test—a single line containing \"n k\".\n  According to the problem statement:\n\n    1) 2 ≤ n ≤ 2000\n    2) 1 ≤ k ≤ 10^9\n\n  The code below reads two command-line parameters:\n    - n (required)\n    - type (optional, default = \"random\")\n\n  Then it computes k in different ways to cover various corner cases and\n  ensures it stays in [1..1e9]. Finally, it prints \"n k\" on one line.\n\n  Possible values for \"type\":\n    - \"maxTLE\"    => Make k < n*(n-1)/2 when possible (forcing TOT > k).\n    - \"borderline\"=> Make k = n*(n-1)/2 (TOT == k).\n    - \"noSol\"     => Make k > n*(n-1)/2 (forcing TOT ≤ k).\n    - \"random\"    => Choose k uniformly at random from [1..1e9].\n*/\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    \n    int n = opt<int>(\"n\");  // n must be between 2 and 2000 (we will clamp if out of range).\n    string type = opt<string>(\"type\", \"random\"); \n    // TOT = total number of pairwise checks in the worst-case scenario = n * (n-1) / 2\n    long long TOT = 1LL * n * (n - 1) / 2;\n    long long k;\n\n    // Clamp n within [2..2000].\n    if (n < 2)  n = 2;\n    if (n > 2000) n = 2000;\n\n    // Decide k based on the chosen \"type\".\n    if (type == \"maxTLE\") {\n        // Attempt to force TOT > k; i.e., pick k < TOT if TOT > 1\n        if (TOT > 1) {\n            k = TOT - 1; \n        } else {\n            // If TOT == 1, then n == 2, we cannot pick k=0 because that violates k>=1\n            // so we pick k=1 to at least produce a valid test.\n            k = 1;\n        }\n    } \n    else if (type == \"borderline\") {\n        // TOT = k, so TOT will NOT exceed k\n        k = TOT;\n        if (k < 1) {\n            // Usually won't happen unless n=2 => TOT=1\n            k = 1;\n        }\n    } \n    else if (type == \"noSol\") {\n        // TOT < k, ensures TOT cannot exceed k\n        k = TOT + 1;\n        // but must not exceed 1e9\n        if (k > 1000000000LL) {\n            k = 1000000000LL;\n        }\n    } \n    else {\n        // \"random\" or any unrecognized type => pick k randomly in [1..1e9]\n        k = rnd.next(1LL, 1000000000LL);\n    }\n\n    // Ensure k is within [1..1e9].\n    if (k < 1) k = 1;\n    if (k > 1000000000LL) k = 1000000000LL;\n\n    // Output a single test in the format \"n k\".\n    cout << n << \" \" << k << \"\\n\";\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\n/*\n  This generator produces a single test—a single line containing \"n k\".\n  According to the problem statement:\n\n    1) 2 ≤ n ≤ 2000\n    2) 1 ≤ k ≤ 10^9\n\n  The code below reads two command-line parameters:\n    - n (required)\n    - type (optional, default = \"random\")\n\n  Then it computes k in different ways to cover various corner cases and\n  ensures it stays in [1..1e9]. Finally, it prints \"n k\" on one line.\n\n  Possible values for \"type\":\n    - \"maxTLE\"    => Make k < n*(n-1)/2 when possible (forcing TOT > k).\n    - \"borderline\"=> Make k = n*(n-1)/2 (TOT == k).\n    - \"noSol\"     => Make k > n*(n-1)/2 (forcing TOT ≤ k).\n    - \"random\"    => Choose k uniformly at random from [1..1e9].\n*/\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    \n    int n = opt<int>(\"n\");  // n must be between 2 and 2000 (we will clamp if out of range).\n    string type = opt<string>(\"type\", \"random\"); \n    // TOT = total number of pairwise checks in the worst-case scenario = n * (n-1) / 2\n    long long TOT = 1LL * n * (n - 1) / 2;\n    long long k;\n\n    // Clamp n within [2..2000].\n    if (n < 2)  n = 2;\n    if (n > 2000) n = 2000;\n\n    // Decide k based on the chosen \"type\".\n    if (type == \"maxTLE\") {\n        // Attempt to force TOT > k; i.e., pick k < TOT if TOT > 1\n        if (TOT > 1) {\n            k = TOT - 1; \n        } else {\n            // If TOT == 1, then n == 2, we cannot pick k=0 because that violates k>=1\n            // so we pick k=1 to at least produce a valid test.\n            k = 1;\n        }\n    } \n    else if (type == \"borderline\") {\n        // TOT = k, so TOT will NOT exceed k\n        k = TOT;\n        if (k < 1) {\n            // Usually won't happen unless n=2 => TOT=1\n            k = 1;\n        }\n    } \n    else if (type == \"noSol\") {\n        // TOT < k, ensures TOT cannot exceed k\n        k = TOT + 1;\n        // but must not exceed 1e9\n        if (k > 1000000000LL) {\n            k = 1000000000LL;\n        }\n    } \n    else {\n        // \"random\" or any unrecognized type => pick k randomly in [1..1e9]\n        k = rnd.next(1LL, 1000000000LL);\n    }\n\n    // Ensure k is within [1..1e9].\n    if (k < 1) k = 1;\n    if (k > 1000000000LL) k = 1000000000LL;\n\n    // Output a single test in the format \"n k\".\n    cout << n << \" \" << k << \"\\n\";\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Below are example commands (20+) showing how to invoke the generator\n# with different parameters to produce a range of test inputs.\n# Each command prints a single line \"n k\".\n\n# Small values of n\n./gen -n 2 -type maxTLE\n./gen -n 2 -type borderline\n./gen -n 2 -type noSol\n./gen -n 2 -type random\n\n./gen -n 3 -type maxTLE\n./gen -n 3 -type borderline\n./gen -n 3 -type noSol\n./gen -n 3 -type random\n\n./gen -n 4 -type maxTLE\n./gen -n 4 -type borderline\n./gen -n 4 -type noSol\n./gen -n 4 -type random\n\n# Medium values of n\n./gen -n 10 -type maxTLE\n./gen -n 10 -type borderline\n./gen -n 10 -type noSol\n./gen -n 10 -type random\n\n./gen -n 100 -type maxTLE\n./gen -n 100 -type borderline\n./gen -n 100 -type noSol\n./gen -n 100 -type random\n\n# Larger values of n\n./gen -n 999 -type maxTLE\n./gen -n 999 -type borderline\n./gen -n 999 -type noSol\n./gen -n 999 -type random\n\n./gen -n 2000 -type maxTLE\n./gen -n 2000 -type borderline\n./gen -n 2000 -type noSol\n./gen -n 2000 -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:06:32.663113",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "312/D",
      "title": "D. Cats Transport",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line of the input contains three integers n, m, p (2 ≤ n ≤ 105, 1 ≤ m ≤ 105, 1 ≤ p ≤ 100).The second line contains n - 1 positive integers d2, d3, ..., dn (1 ≤ di < 104).Each of the next m lines contains two integers hi and ti (1 ≤ hi ≤ n, 0 ≤ ti ≤ 109).",
      "output_spec": "OutputOutput an integer, the minimum sum of waiting time of all cats.Please, do not write the %lld specifier to read or write 64-bit integers in С++. It is preferred to use the cin, cout streams or the %I64d specifier.",
      "sample_tests": "ExamplesInputCopy4 6 21 3 51 02 14 91 102 103 12OutputCopy3",
      "description": "D. Cats Transport\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line of the input contains three integers n, m, p (2 ≤ n ≤ 105, 1 ≤ m ≤ 105, 1 ≤ p ≤ 100).The second line contains n - 1 positive integers d2, d3, ..., dn (1 ≤ di < 104).Each of the next m lines contains two integers hi and ti (1 ≤ hi ≤ n, 0 ≤ ti ≤ 109).\n\nOutputOutput an integer, the minimum sum of waiting time of all cats.Please, do not write the %lld specifier to read or write 64-bit integers in С++. It is preferred to use the cin, cout streams or the %I64d specifier.\n\nInputCopy4 6 21 3 51 02 14 91 102 103 12OutputCopy3\n\nInputCopy4 6 21 3 51 02 14 91 102 103 12\n\nOutputCopy3",
      "solutions": [
        {
          "title": "Codeforces Round #185 - Codeforces",
          "content": "Hello,everyone!Codeforces Round #185 will take place on Sunday, May 26th at 19:30MSK (23:30CST).This round is initiated by zanoes, and here are the problem setters: Div.1E & Div.2B —— zanoes (**Zhang Gaoxiang**) Div.1D & Div.1A —— liouzhou_101 (**Wang Qisheng**) Div.1C & Div.1B & Div.2A —— lydrainbowcat (**Li Yudong**) Testers are roosephu(Luo Yuping), FredaShi(Shi Haoyue), sjynoi(Sun Jiayu), sevenkplus(Gu Yuzhou), MinakoKojima(Tang Feihu) and Riatre.Especially thanks Gerald for helping us to prepare the round, MikeMirzayanov for the great platform and Delinur for translation.Score will be standard, 500-1000-1500-2000-2500 in both divisions. In our opinion, problems are easier than the past several rounds prepared by Chinese)This is our first Codeforces round, I hope you can enjoy it. Wish you high rating and good luck!UPD: We feel really sorry about the mistake we made. The following words were written by Div.1A (Div.2C)setter, liouzhou_101. http://codeforces.com/blog/entry/7773#comment-134702 . Meanwhile, It's also zanoes's and my fault that we didn't check his checker carefully, even brought troubles to Codeforces flat. I beg your forgive for liouzhou_101, for he also tried to prepare the round well these days. UPD2: The round will be unrated.Editorials will come out soon. Now you can find some of the editorials here: http://codeforces.com/blog/entry/7785Contest is over. Congratulations to the winners.Div.1 zfmdhy786 (I promise it's someone who pretends to be roosephu, and I've known who he is.) cp12321 RAD ACMonster kAc And ryz , cgy4ever, who passed problem E in the contest.Div.2 ymxlkAc sasha.sochka bohuss",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/7773",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1639
        },
        {
          "title": "Codeforces Round #185 Editorial - Codeforces",
          "content": "311A - Ближайшая параhttp://codeforces.com/blog/entry/7787311B - Транспортировка кошекP.S. I feel very sorry that I thought it was a traditional DP problem with only 800B code and didn't realize some participants were not familiar with such kind of problems, so I said it was easy. Let a[i] be the distance from hill 1 to hill i, s[i]=a[1]+a[2]+…+a[i].Firstly, we sort the cats by (Ti-a[i]). Then we can divide the cats into P consecutive parts, and plan a feeder for each part. Dynamic Programming can solve this problem.Let f[i,j] indicates the minimum sum of waiting time with i feeders and j cats.f[i,j] = f[i-1,k]+a[j]*(j-k)-s[j]+s[k] = a[j]*j-s[j] + f[i-1,k]+s[k]-a[j]*kThat’s O(PM^2). It’ll get TLE.Let p>q, if p is \"better\" than q, then:f[i-1,p]+s[p]-a[j]*p>f[i-1,q]+s[q]-a[j]*q(f[i-1,p]+s[p])-(f[i-1,q]+s[q])>a[j]*(p-q)g[p]-g[q]>a[j]*(p-q)So we can use Convex hull trick with a queue. Then we get O(MP), which can pass the problem.311C - Достать сокровищеFirstly, we solve such a problem: if we can go exactly k,k1,k2……or kp cells forward each step, what cells can we reach?We divide the H cells into k groups: Group 0,1……k-1. The i-th cell should be in Group (i mod k). If we reach Cell x in Group (x mod k), we can also reach Cell (x+kj , 1<=j<=p) in Group ((x+kj)mod k). If we reach Cell x in Group (x mod k), we can also reach Cell (x+k) in the same group. Let D[i] be the minimum cell we can reach in Group i. Then we can reach all the cells which number are bigger then D[i] in Group i. Regard the groups as points. Regard k,k1,k2……kp as edges. And use a Shortest-Path Algorithm to calculate all D[i]. Notice that there are at most 20 operations of type 1, we are able to run such an algorithm after each of these operations. The total time complexity is O(20*k*20*log(k)) with Dijkstra.Secondly, we build a binary-heap to solve operations of type 2 and 3. Type1 – If a D[i] becomes smaller, we put the new cells we can reach into the heap. Type2 – Decrease a value of a node in the heap, or a cell in the “Treasure Cell” array. Type3 – Ask the biggest node in the heap and delete it. These are basic operations of binary-heap. The time complexity is O(NlogN). In C++, you can also use priority_queue from STL and lazy-tags. So we can solve the whole problem in O(400klogk+NlogN).311D - Куб на отрезкеhttp://codeforces.com/blog/entry/7787311E - Биологhttp://codeforces.com/blog/entry/7847312A - Чье это предложение?We only need to find out if “miao.” is a prefix of the sentence, and if “lala.” is a suffix of the sentence. Pay attention to the situation when both conditions are satisfied.312B - Лучникиhttp://codeforces.com/blog/entry/7847",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/7785",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.6,
            "reason": "宽松匹配: 包含题目编号 312 和字母"
          },
          "content_length": 2656
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #185 - Codeforces - Code 1",
          "code": "I do not have time to participate in a number of competitions, this one I think I can get a better grade, yes I do , with good grade. But no rating changed.\nI may not to blame the one who hold the round, but I do not want this happen again.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7773",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #185 Editorial - Codeforces - Code 1",
          "code": "FOR i from 1 to n\n    PRINT (n-i,0)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7785",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #185 Editorial - Codeforces - Code 2",
          "code": "FOR i from 1 to n\n    PRINT (n-i,0)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7785",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(2, 100000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 100000, \"m\");\n    inf.readSpace();\n    int p = inf.readInt(1, 100, \"p\");\n    inf.readEoln();\n\n    vector<int> d = inf.readInts(n - 1, 1, 9999, \"d\");\n    inf.readEoln();\n\n    for (int i = 0; i < m; ++i) {\n        int hi = inf.readInt(1, n, \"hi\");\n        inf.readSpace();\n        int ti = inf.readInt(0, 1000000000, \"ti\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(2, 100000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 100000, \"m\");\n    inf.readSpace();\n    int p = inf.readInt(1, 100, \"p\");\n    inf.readEoln();\n\n    vector<int> d = inf.readInts(n - 1, 1, 9999, \"d\");\n    inf.readEoln();\n\n    for (int i = 0; i < m; ++i) {\n        int hi = inf.readInt(1, n, \"hi\");\n        inf.readSpace();\n        int ti = inf.readInt(0, 1000000000, \"ti\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(2, 100000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 100000, \"m\");\n    inf.readSpace();\n    int p = inf.readInt(1, 100, \"p\");\n    inf.readEoln();\n\n    vector<int> d = inf.readInts(n - 1, 1, 9999, \"d\");\n    inf.readEoln();\n\n    for (int i = 0; i < m; ++i) {\n        int hi = inf.readInt(1, n, \"hi\");\n        inf.readSpace();\n        int ti = inf.readInt(0, 1000000000, \"ti\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    int p = opt<int>(\"p\");\n    string type = opt<string>(\"type\", \"random\");\n\n    // Adjust n, m, p for specific types if needed\n    if (type == \"min_n_m\") {\n        n = 2;\n        m = 1;\n        p = 1;\n    } else if (type == \"max_n_m\") {\n        n = 100000;\n        m = 100000;\n        p = 100;\n    }\n\n    printf(\"%d %d %d\\n\", n, m, p);\n\n    vector<int> di(n + 1); // di[2..n]\n    if (type == \"min_di\") {\n        for (int i = 2; i <= n; ++i) {\n            di[i] = 1;\n        }\n    } else if (type == \"max_di\") {\n        for (int i = 2; i <= n; ++i) {\n            di[i] = 9999;\n        }\n    } else if (type == \"increasing_di\") {\n        for (int i = 2; i <= n; ++i) {\n            di[i] = i % 9999 + 1;\n        }\n    } else if (type == \"decreasing_di\") {\n        for (int i = 2; i <= n; ++i) {\n            di[i] = (n - i + 2) % 9999 + 1;\n        }\n    } else {\n        // Random di\n        for (int i = 2; i <= n; ++i) {\n            di[i] = rnd.next(1, 9999);\n        }\n    }\n\n    // Output di[2..n]\n    for (int i = 2; i <= n; ++i) {\n        printf(\"%d%c\", di[i], i == n ? '\\n' : ' ');\n    }\n\n    vector<int> hi(m);\n    vector<int> ti(m);\n\n    if (type == \"min_n_m\") {\n        // Only one cat at hill n at time 0\n        hi[0] = n;\n        ti[0] = 0;\n    } else if (type == \"cats_on_same_hill\") {\n        int hill = rnd.next(1, n);\n        for (int i = 0; i < m; ++i) {\n            hi[i] = hill;\n            ti[i] = rnd.next(0, int(1e9));\n        }\n    } else if (type == \"cats_on_hill_n\") {\n        for (int i = 0; i < m; ++i) {\n            hi[i] = n;\n            ti[i] = rnd.next(0, int(1e9));\n        }\n    } else if (type == \"equal_times\") {\n        int time = rnd.next(0, int(1e9));\n        for (int i = 0; i < m; ++i) {\n            hi[i] = rnd.next(1, n);\n            ti[i] = time;\n        }\n    } else if (type == \"early_cats\") {\n        for (int i = 0; i < m; ++i) {\n            hi[i] = rnd.next(1, n);\n            ti[i] = rnd.next(0, 10);\n        }\n    } else if (type == \"late_cats\") {\n        for (int i = 0; i < m; ++i) {\n            hi[i] = rnd.next(1, n);\n            ti[i] = rnd.next(int(1e9) - 10, int(1e9));\n        }\n    } else if (type == \"cats_spread_out\") {\n        for (int i = 0; i < m; ++i) {\n            hi[i] = i % n + 1;\n            ti[i] = rnd.next(0, int(1e9));\n        }\n    } else if (type == \"cats_on_random_hills\") {\n        for (int i = 0; i < m; ++i) {\n            hi[i] = rnd.next(1, n);\n            ti[i] = rnd.next(0, int(1e9));\n        }\n    } else if (type == \"max_n_m\") {\n        for (int i = 0; i < m; ++i) {\n            hi[i] = rnd.next(1, n);\n            ti[i] = rnd.next(0, int(1e9));\n        }\n    } else {\n        // Default random cats\n        for (int i = 0; i < m; ++i) {\n            hi[i] = rnd.next(1, n);\n            ti[i] = rnd.next(0, int(1e9));\n        }\n    }\n\n    // Output cats\n    for (int i = 0; i < m; ++i) {\n        printf(\"%d %d\\n\", hi[i], ti[i]);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    int p = opt<int>(\"p\");\n    string type = opt<string>(\"type\", \"random\");\n\n    // Adjust n, m, p for specific types if needed\n    if (type == \"min_n_m\") {\n        n = 2;\n        m = 1;\n        p = 1;\n    } else if (type == \"max_n_m\") {\n        n = 100000;\n        m = 100000;\n        p = 100;\n    }\n\n    printf(\"%d %d %d\\n\", n, m, p);\n\n    vector<int> di(n + 1); // di[2..n]\n    if (type == \"min_di\") {\n        for (int i = 2; i <= n; ++i) {\n            di[i] = 1;\n        }\n    } else if (type == \"max_di\") {\n        for (int i = 2; i <= n; ++i) {\n            di[i] = 9999;\n        }\n    } else if (type == \"increasing_di\") {\n        for (int i = 2; i <= n; ++i) {\n            di[i] = i % 9999 + 1;\n        }\n    } else if (type == \"decreasing_di\") {\n        for (int i = 2; i <= n; ++i) {\n            di[i] = (n - i + 2) % 9999 + 1;\n        }\n    } else {\n        // Random di\n        for (int i = 2; i <= n; ++i) {\n            di[i] = rnd.next(1, 9999);\n        }\n    }\n\n    // Output di[2..n]\n    for (int i = 2; i <= n; ++i) {\n        printf(\"%d%c\", di[i], i == n ? '\\n' : ' ');\n    }\n\n    vector<int> hi(m);\n    vector<int> ti(m);\n\n    if (type == \"min_n_m\") {\n        // Only one cat at hill n at time 0\n        hi[0] = n;\n        ti[0] = 0;\n    } else if (type == \"cats_on_same_hill\") {\n        int hill = rnd.next(1, n);\n        for (int i = 0; i < m; ++i) {\n            hi[i] = hill;\n            ti[i] = rnd.next(0, int(1e9));\n        }\n    } else if (type == \"cats_on_hill_n\") {\n        for (int i = 0; i < m; ++i) {\n            hi[i] = n;\n            ti[i] = rnd.next(0, int(1e9));\n        }\n    } else if (type == \"equal_times\") {\n        int time = rnd.next(0, int(1e9));\n        for (int i = 0; i < m; ++i) {\n            hi[i] = rnd.next(1, n);\n            ti[i] = time;\n        }\n    } else if (type == \"early_cats\") {\n        for (int i = 0; i < m; ++i) {\n            hi[i] = rnd.next(1, n);\n            ti[i] = rnd.next(0, 10);\n        }\n    } else if (type == \"late_cats\") {\n        for (int i = 0; i < m; ++i) {\n            hi[i] = rnd.next(1, n);\n            ti[i] = rnd.next(int(1e9) - 10, int(1e9));\n        }\n    } else if (type == \"cats_spread_out\") {\n        for (int i = 0; i < m; ++i) {\n            hi[i] = i % n + 1;\n            ti[i] = rnd.next(0, int(1e9));\n        }\n    } else if (type == \"cats_on_random_hills\") {\n        for (int i = 0; i < m; ++i) {\n            hi[i] = rnd.next(1, n);\n            ti[i] = rnd.next(0, int(1e9));\n        }\n    } else if (type == \"max_n_m\") {\n        for (int i = 0; i < m; ++i) {\n            hi[i] = rnd.next(1, n);\n            ti[i] = rnd.next(0, int(1e9));\n        }\n    } else {\n        // Default random cats\n        for (int i = 0; i < m; ++i) {\n            hi[i] = rnd.next(1, n);\n            ti[i] = rnd.next(0, int(1e9));\n        }\n    }\n\n    // Output cats\n    for (int i = 0; i < m; ++i) {\n        printf(\"%d %d\\n\", hi[i], ti[i]);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 2 -m 1 -p 1 -type min_n_m\n./gen -n 10 -m 10 -p 1 -type min_di\n./gen -n 10 -m 10 -p 1 -type max_di\n./gen -n 10 -m 10 -p 1 -type increasing_di\n./gen -n 10 -m 10 -p 1 -type decreasing_di\n./gen -n 10 -m 10 -p 1 -type early_cats\n./gen -n 10 -m 10 -p 1 -type late_cats\n./gen -n 10 -m 10 -p 1 -type equal_times\n./gen -n 10 -m 10 -p 1 -type cats_on_same_hill\n./gen -n 10 -m 10 -p 1 -type cats_on_hill_n\n./gen -n 10 -m 10 -p 1 -type cats_spread_out\n./gen -n 10 -m 10 -p 1 -type cats_on_random_hills\n./gen -n 100 -m 1000 -p 10 -type min_di\n./gen -n 100 -m 1000 -p 10 -type max_di\n./gen -n 100 -m 1000 -p 10 -type early_cats\n./gen -n 1000 -m 10000 -p 20 -type cats_on_same_hill\n./gen -n 1000 -m 10000 -p 20 -type cats_spread_out\n./gen -n 10000 -m 50000 -p 30 -type cats_on_random_hills\n./gen -n 20000 -m 80000 -p 40 -type equal_times\n./gen -n 50000 -m 100000 -p 50 -type early_cats\n./gen -n 100000 -m 100000 -p 1 -type random\n./gen -n 100000 -m 100000 -p 100 -type random\n./gen -n 100000 -m 100000 -p 100 -type min_di\n./gen -n 100000 -m 1 -p 1 -type cats_on_hill_n\n./gen -n 100000 -m 100000 -p 100 -type max_di\n./gen -n 100000 -m 100000 -p 50 -type increasing_di\n./gen -n 100000 -m 100000 -p 50 -type decreasing_di\n./gen -n 100000 -m 100000 -p 10 -type equal_times\n./gen -n 100000 -m 100000 -p 10 -type late_cats\n./gen -n 100000 -m 100000 -p 5 -type cats_on_same_hill\n./gen -n 100000 -m 1 -p 1 -type min_n_m\n./gen -n 100000 -m 100000 -p 100 -type max_n_m\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:06:34.824531",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "312/E",
      "title": "E. Достать сокровище",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест3 секунды",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеПервая строка содержит четыре целых числа: h (1 ≤ h ≤ 1018), n, m (1 ≤ n, m ≤ 105) и k (1 ≤ k ≤ 104).Каждая из следующих n строк содержит два целых числа: ai (1 ≤ ai ≤ h), ci (1 ≤ ci ≤ 109). Это означает, что i-ая «ячейка с сокровищами» — это ai-ая ячейка и в ней лежит сокровище на ci долларов. Все ai различны.Каждая из следующих m строк записана в одном из следующих трех форматов:  «1 x» — операция типа 1, 1 ≤ x ≤ h;  «2 x y» — операция типа 2, 1 ≤ x ≤ n, 0 ≤ y < cx;  «3» — операция типа 3. Максимальное количество операций типа 1 — 20. Гарантируется, что в любой момент стоимость сокровища в любой ячейке с сокровищем положительна. Гарантируется, что все операции корректны (никакая операция не может уменьшить стоимость уже взятого сокровища).Пожалуйста, не используйте спецификатор %lld, для чтения 64-битных чисел на С++. Рекомендуется использовать потоки cin, cout или спецификатор %I64d.",
      "output_spec": "Выходные данныеДля каждой операции типа 3, выведите целое число, указывающее на ценность (в долларах) самого ценного сокровища среди «ячеек c сокровищами», которые Фреда может достать. Если такого сокровища нет, выведите 0.",
      "sample_tests": "ПримерыВходные данныеСкопировать10 3 5 25 507 608 1002 2 531 333Выходные данныеСкопировать5510050",
      "description": "E. Достать сокровище\n\nограничение по времени на тест3 секунды\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвыводstdout\n\nВходные данныеПервая строка содержит четыре целых числа: h (1 ≤ h ≤ 1018), n, m (1 ≤ n, m ≤ 105) и k (1 ≤ k ≤ 104).Каждая из следующих n строк содержит два целых числа: ai (1 ≤ ai ≤ h), ci (1 ≤ ci ≤ 109). Это означает, что i-ая «ячейка с сокровищами» — это ai-ая ячейка и в ней лежит сокровище на ci долларов. Все ai различны.Каждая из следующих m строк записана в одном из следующих трех форматов:  «1 x» — операция типа 1, 1 ≤ x ≤ h;  «2 x y» — операция типа 2, 1 ≤ x ≤ n, 0 ≤ y < cx;  «3» — операция типа 3. Максимальное количество операций типа 1 — 20. Гарантируется, что в любой момент стоимость сокровища в любой ячейке с сокровищем положительна. Гарантируется, что все операции корректны (никакая операция не может уменьшить стоимость уже взятого сокровища).Пожалуйста, не используйте спецификатор %lld, для чтения 64-битных чисел на С++. Рекомендуется использовать потоки cin, cout или спецификатор %I64d.\n\nВходные данные\n\nВыходные данныеДля каждой операции типа 3, выведите целое число, указывающее на ценность (в долларах) самого ценного сокровища среди «ячеек c сокровищами», которые Фреда может достать. Если такого сокровища нет, выведите 0.\n\nВыходные данные\n\nВходные данныеСкопировать10 3 5 25 507 608 1002 2 531 333Выходные данныеСкопировать5510050\n\nВходные данныеСкопировать10 3 5 25 507 608 1002 2 531 333\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать5510050\n\nВыходные данныеСкопировать\n\nСкопировать\n\nПримечаниеВ примере дано 10 ячеек и 3 «ячейки с сокровищами». Первая — это ячейка 5, в ней лежит сокровище на 50 долларов. Вторая — это ячейка 7, в ней лежит сокровище на 60 долларов. Третья — это ячейка 8, в ней лежит сокровище на 100 долларов.Сначала Фреда может дотянуться только до ячеек 1, 3, 5, 7 и 9. Первая операция уменьшает стоимость в долларах второй «ячейки с сокровищами» с 60 до 55. После этого самое ценное сокровище среди доступных ей «ячеек с сокровищами» — это max(50, 55) = 55. После третьей операции она может двигаться на 3 ячейки вперед с каждым шагом, таким образом она может достигнуть ячеек 1, 3, 4, 5, 6, 7, 8, 9, 10. Значит, четвертая операция забирает сокровище стоимостью 100 долларов.Обратите внимание, что она забрала сокровище стоимостью 55 и 100 долларов, следовательно, ответ последней операцией она забирает сокровище стоимостью 50 долларов.",
      "solutions": [
        {
          "title": "Codeforces Round #185 - Codeforces",
          "content": "Всем привет!Раунд Codeforces Round #185 состоится в Воскресенье, 26 Мая, в 19:30 по московскому времени (23:30 по ЦПВ).Организатор раунда — zanoes, а задачи готовили: Div.1E и Div.2B —— zanoes (Жанг Гаощанг), Div.1D и Div.1A —— liouzhou_101 (Ванг Квишенг), Div.1C, Div.1B, Div.2A —— lydrainbowcat (Ли Юдонг) Тестеры — roosephu(Луо Юпинг), FredaShi (Ши Хаойе), sjynoi(Сун Джяю), sevenkplus(Гу Южу), MinakoKojima(Танг Фейху) и Riatre.Выражаем особую благодарность Gerald за помощь в подготовке раунда, MikeMirzayanov за классную платформу и Delinur за перевод.Распределение баллов будет стандартное, 500-1000-1500-2000-2500 в обоих дивизионах. Наверное, эти задачи проще задач из предыдущих китайских раундов :)Это наш первый раунд на Codeforces, надеюсь, он вам понравится. Высоких вам рейтингов и удачи!UPD: Мы очень сожалеем о нашей ошибке. Следующие слова были сказаны автором задачи div1A (div2C) liouzhou_101. http://codeforces.com/blog/entry/7773#comment-134702 . Конечно, это также моя ошибка и ошибка zanoes, что мы не прочитали этот чекер аккуратно и тем самым доставили проблемы Codeforces. Я приношу свои извинения за liouzhou_101, он очень старался сделать хороший контест во время подготовки раунда.UPD2: Раунд считается не рейтинговым.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/7773",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 1248
        },
        {
          "title": "Codeforces Round #185 Editorial - Codeforces",
          "content": "311A - Ближайшая параhttp://codeforces.com/blog/entry/7787311B - Транспортировка кошекP.S. I feel very sorry that I thought it was a traditional DP problem with only 800B code and didn't realize some participants were not familiar with such kind of problems, so I said it was easy. Let a[i] be the distance from hill 1 to hill i, s[i]=a[1]+a[2]+…+a[i].Firstly, we sort the cats by (Ti-a[i]). Then we can divide the cats into P consecutive parts, and plan a feeder for each part. Dynamic Programming can solve this problem.Let f[i,j] indicates the minimum sum of waiting time with i feeders and j cats.f[i,j] = f[i-1,k]+a[j]*(j-k)-s[j]+s[k] = a[j]*j-s[j] + f[i-1,k]+s[k]-a[j]*kThat’s O(PM^2). It’ll get TLE.Let p>q, if p is \"better\" than q, then:f[i-1,p]+s[p]-a[j]*p>f[i-1,q]+s[q]-a[j]*q(f[i-1,p]+s[p])-(f[i-1,q]+s[q])>a[j]*(p-q)g[p]-g[q]>a[j]*(p-q)So we can use Convex hull trick with a queue. Then we get O(MP), which can pass the problem.311C - Достать сокровищеFirstly, we solve such a problem: if we can go exactly k,k1,k2……or kp cells forward each step, what cells can we reach?We divide the H cells into k groups: Group 0,1……k-1. The i-th cell should be in Group (i mod k). If we reach Cell x in Group (x mod k), we can also reach Cell (x+kj , 1<=j<=p) in Group ((x+kj)mod k). If we reach Cell x in Group (x mod k), we can also reach Cell (x+k) in the same group. Let D[i] be the minimum cell we can reach in Group i. Then we can reach all the cells which number are bigger then D[i] in Group i. Regard the groups as points. Regard k,k1,k2……kp as edges. And use a Shortest-Path Algorithm to calculate all D[i]. Notice that there are at most 20 operations of type 1, we are able to run such an algorithm after each of these operations. The total time complexity is O(20*k*20*log(k)) with Dijkstra.Secondly, we build a binary-heap to solve operations of type 2 and 3. Type1 – If a D[i] becomes smaller, we put the new cells we can reach into the heap. Type2 – Decrease a value of a node in the heap, or a cell in the “Treasure Cell” array. Type3 – Ask the biggest node in the heap and delete it. These are basic operations of binary-heap. The time complexity is O(NlogN). In C++, you can also use priority_queue from STL and lazy-tags. So we can solve the whole problem in O(400klogk+NlogN).311D - Куб на отрезкеhttp://codeforces.com/blog/entry/7787311E - Биологhttp://codeforces.com/blog/entry/7847312A - Чье это предложение?We only need to find out if “miao.” is a prefix of the sentence, and if “lala.” is a suffix of the sentence. Pay attention to the situation when both conditions are satisfied.312B - Лучникиhttp://codeforces.com/blog/entry/7847",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/7785",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.6,
            "reason": "宽松匹配: 包含题目编号 312 和字母"
          },
          "content_length": 2656
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #185 - Codeforces - Code 1",
          "code": "I do not have time to participate in a number of competitions, this one I think I can get a better grade, yes I do , with good grade. But no rating changed.\nI may not to blame the one who hold the round, but I do not want this happen again.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7773",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #185 Editorial - Codeforces - Code 1",
          "code": "FOR i from 1 to n\n    PRINT (n-i,0)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7785",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #185 Editorial - Codeforces - Code 2",
          "code": "FOR i from 1 to n\n    PRINT (n-i,0)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7785",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    ll h = inf.readLong(1LL, 1000000000000000000LL, \"h\"); // 1e18\n    inf.readSpace();\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 100000, \"m\");\n    inf.readSpace();\n    int k = inf.readInt(1, 10000, \"k\");\n    inf.readEoln();\n\n    vector<ll> ai(n+1);\n    vector<int> ci(n+1);\n    set<ll> ai_set;\n\n    for(int i = 1; i <= n; i++) {\n        ai[i] = inf.readLong(1LL, h, \"ai[\" + vtos(i) + \"]\");\n        ensuref(ai_set.count(ai[i]) == 0, \"All ai must be distinct at line %d\", i+1);\n        ai_set.insert(ai[i]);\n        inf.readSpace();\n        ci[i] = inf.readInt(1, 1000000000, \"ci[\" + vtos(i) + \"]\");\n        inf.readEoln();\n    }\n\n    int type1_count = 0;\n    // methods are not used in this validator\n    // vector<int> methods;\n    // methods.push_back(k);\n\n    vector<int> cur_ci = ci; // current ci for each treasure cell\n\n    for(int op_num = 1; op_num <= m; op_num++) {\n        int op_type = inf.readInt(1,3, \"op_type at operation \" + vtos(op_num));\n        if(op_type == 1) {\n            inf.readSpace();\n            ll x = inf.readLong(1LL, h, \"x in op_type 1 at operation \" + vtos(op_num));\n            inf.readEoln();\n            type1_count++;\n            ensuref(type1_count <= 20, \"There are at most 20 operations of type 1\");\n            // We do not need to maintain methods for validation purposes\n        } else if(op_type == 2) {\n            inf.readSpace();\n            int x = inf.readInt(1, n, \"x in op_type 2 at operation \" + vtos(op_num));\n            ensuref(cur_ci[x] > 0, \"Treasure cell %d has already been taken or reduced to zero at operation %d\", x, op_num);\n            inf.readSpace();\n            int y = inf.readInt(0, cur_ci[x]-1, \"y in op_type 2 at operation \" + vtos(op_num));\n            inf.readEoln();\n            cur_ci[x] -= y;\n            ensuref(cur_ci[x] > 0, \"After operation, treasure in cell %d must remain positive\", x);\n        } else if(op_type == 3) {\n            inf.readEoln();\n            // Do nothing, as we cannot simulate type 3 operations within constraints\n        }\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    ll h = inf.readLong(1LL, 1000000000000000000LL, \"h\"); // 1e18\n    inf.readSpace();\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 100000, \"m\");\n    inf.readSpace();\n    int k = inf.readInt(1, 10000, \"k\");\n    inf.readEoln();\n\n    vector<ll> ai(n+1);\n    vector<int> ci(n+1);\n    set<ll> ai_set;\n\n    for(int i = 1; i <= n; i++) {\n        ai[i] = inf.readLong(1LL, h, \"ai[\" + vtos(i) + \"]\");\n        ensuref(ai_set.count(ai[i]) == 0, \"All ai must be distinct at line %d\", i+1);\n        ai_set.insert(ai[i]);\n        inf.readSpace();\n        ci[i] = inf.readInt(1, 1000000000, \"ci[\" + vtos(i) + \"]\");\n        inf.readEoln();\n    }\n\n    int type1_count = 0;\n    // methods are not used in this validator\n    // vector<int> methods;\n    // methods.push_back(k);\n\n    vector<int> cur_ci = ci; // current ci for each treasure cell\n\n    for(int op_num = 1; op_num <= m; op_num++) {\n        int op_type = inf.readInt(1,3, \"op_type at operation \" + vtos(op_num));\n        if(op_type == 1) {\n            inf.readSpace();\n            ll x = inf.readLong(1LL, h, \"x in op_type 1 at operation \" + vtos(op_num));\n            inf.readEoln();\n            type1_count++;\n            ensuref(type1_count <= 20, \"There are at most 20 operations of type 1\");\n            // We do not need to maintain methods for validation purposes\n        } else if(op_type == 2) {\n            inf.readSpace();\n            int x = inf.readInt(1, n, \"x in op_type 2 at operation \" + vtos(op_num));\n            ensuref(cur_ci[x] > 0, \"Treasure cell %d has already been taken or reduced to zero at operation %d\", x, op_num);\n            inf.readSpace();\n            int y = inf.readInt(0, cur_ci[x]-1, \"y in op_type 2 at operation \" + vtos(op_num));\n            inf.readEoln();\n            cur_ci[x] -= y;\n            ensuref(cur_ci[x] > 0, \"After operation, treasure in cell %d must remain positive\", x);\n        } else if(op_type == 3) {\n            inf.readEoln();\n            // Do nothing, as we cannot simulate type 3 operations within constraints\n        }\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    ll h = inf.readLong(1LL, 1000000000000000000LL, \"h\"); // 1e18\n    inf.readSpace();\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 100000, \"m\");\n    inf.readSpace();\n    int k = inf.readInt(1, 10000, \"k\");\n    inf.readEoln();\n\n    vector<ll> ai(n+1);\n    vector<int> ci(n+1);\n    set<ll> ai_set;\n\n    for(int i = 1; i <= n; i++) {\n        ai[i] = inf.readLong(1LL, h, \"ai[\" + vtos(i) + \"]\");\n        ensuref(ai_set.count(ai[i]) == 0, \"All ai must be distinct at line %d\", i+1);\n        ai_set.insert(ai[i]);\n        inf.readSpace();\n        ci[i] = inf.readInt(1, 1000000000, \"ci[\" + vtos(i) + \"]\");\n        inf.readEoln();\n    }\n\n    int type1_count = 0;\n    // methods are not used in this validator\n    // vector<int> methods;\n    // methods.push_back(k);\n\n    vector<int> cur_ci = ci; // current ci for each treasure cell\n\n    for(int op_num = 1; op_num <= m; op_num++) {\n        int op_type = inf.readInt(1,3, \"op_type at operation \" + vtos(op_num));\n        if(op_type == 1) {\n            inf.readSpace();\n            ll x = inf.readLong(1LL, h, \"x in op_type 1 at operation \" + vtos(op_num));\n            inf.readEoln();\n            type1_count++;\n            ensuref(type1_count <= 20, \"There are at most 20 operations of type 1\");\n            // We do not need to maintain methods for validation purposes\n        } else if(op_type == 2) {\n            inf.readSpace();\n            int x = inf.readInt(1, n, \"x in op_type 2 at operation \" + vtos(op_num));\n            ensuref(cur_ci[x] > 0, \"Treasure cell %d has already been taken or reduced to zero at operation %d\", x, op_num);\n            inf.readSpace();\n            int y = inf.readInt(0, cur_ci[x]-1, \"y in op_type 2 at operation \" + vtos(op_num));\n            inf.readEoln();\n            cur_ci[x] -= y;\n            ensuref(cur_ci[x] > 0, \"After operation, treasure in cell %d must remain positive\", x);\n        } else if(op_type == 3) {\n            inf.readEoln();\n            // Do nothing, as we cannot simulate type 3 operations within constraints\n        }\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    ll h = opt<ll>(\"h\");\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    int k = opt<int>(\"k\");\n    string test_type = opt<string>(\"test_type\", \"random\");\n\n    vector<ll> ai(n);\n    vector<int> ci(n);\n\n    set<ll> used_positions;\n    for(int i = 0; i < n; i++) {\n        ll a;\n        do {\n            a = rnd.next(1LL, h);\n        } while(used_positions.count(a));\n        ai[i] = a;\n        used_positions.insert(a);\n        ci[i] = rnd.next(1, int(1e9));\n    }\n\n    // Output h, n, m, k\n    cout << h << \" \" << n << \" \" << m << \" \" << k << \"\\n\";\n    for(int i = 0; i < n; i++) {\n        cout << ai[i] << \" \" << ci[i] << \"\\n\";\n    }\n\n    vector<ll> methods;\n    methods.push_back(k);\n\n    vector<int> existing_treasures;\n    for(int i = 0; i < n; i++) {\n        existing_treasures.push_back(i);\n    }\n\n    vector<int> current_ci = ci;\n\n    vector<bool> reachable(n, false);\n\n    auto update_reachable = [&]() {\n        for(int idx : existing_treasures){\n            reachable[idx] = false;\n            for(ll s : methods){\n                if( (ai[idx] -1) % s == 0){\n                    reachable[idx] = true;\n                    break;\n                }\n            }\n        }\n    };\n\n    update_reachable();\n\n    vector<int> op_types(m);\n    vector<vector<ll>> ops(m);\n\n    int max_op1 = 20;\n    int num_op1 = rnd.next(0, min(max_op1, m / 5));\n\n    vector<int> op1_positions;\n    for(int i = 0; i < m; i++)\n        op1_positions.push_back(i);\n    shuffle(op1_positions.begin(), op1_positions.end());\n    op1_positions.resize(num_op1);\n    set<int> op1_set(op1_positions.begin(), op1_positions.end());\n\n    for(int i = 0; i < m; i++) {\n        if(op1_set.count(i)) {\n            op_types[i] = 1;\n        } else {\n            op_types[i] = rnd.next(2,3);\n        }\n    }\n\n    for(int i = 0; i < m; i++) {\n        if(op_types[i] == 1) {\n            // Operation 1: \"1 x\"\n            ll x = rnd.next(1LL, h);\n            methods.push_back(x);\n            // Update reachable\n            update_reachable();\n            ops[i] = {x};\n        } else if(op_types[i] == 2) {\n            // Operation 2: \"2 x y\"\n            if(existing_treasures.empty()) {\n                // No existing treasures, change operation to type 3\n                op_types[i] = 3;\n                ops[i] = {};\n                i--; // Re-iterate to process as type 3\n                continue;\n            }\n            int idx = rnd.next(0, existing_treasures.size() - 1);\n            int x = existing_treasures[idx];\n            int y_max = current_ci[x] -1;\n            int y = rnd.next(0, y_max);\n            current_ci[x] -= y;\n            ops[i] = { (ll)(x + 1), (ll)y };\n        } else if(op_types[i] == 3) {\n            // Operation 3: \"3\"\n            ops[i] = {};\n            // Find and remove the most valuable reachable treasure\n            int max_value = -1;\n            int min_idx = n + 1;\n            int max_treasure_idx = -1;\n            for(int idx : existing_treasures) {\n                if(reachable[idx]) {\n                    if(current_ci[idx] > max_value || \n                      (current_ci[idx] == max_value && idx < min_idx)) {\n                        max_value = current_ci[idx];\n                        min_idx = idx;\n                        max_treasure_idx = idx;\n                    }\n                }\n            }\n            if(max_treasure_idx != -1) {\n                // Remove the treasure\n                existing_treasures.erase(\n                    remove(existing_treasures.begin(), existing_treasures.end(), max_treasure_idx),\n                    existing_treasures.end());\n                // No need to update reachable, since the treasure is removed\n            }\n        }\n    }\n\n    // Output operations\n    for(int i = 0; i < m; i++) {\n        if(op_types[i] == 1) {\n            cout << \"1 \" << ops[i][0] << \"\\n\";\n        } else if(op_types[i] == 2) {\n            cout << \"2 \" << ops[i][0] << \" \" << ops[i][1] << \"\\n\";\n        } else if(op_types[i] == 3) {\n            cout << \"3\\n\";\n        }\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    ll h = opt<ll>(\"h\");\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    int k = opt<int>(\"k\");\n    string test_type = opt<string>(\"test_type\", \"random\");\n\n    vector<ll> ai(n);\n    vector<int> ci(n);\n\n    set<ll> used_positions;\n    for(int i = 0; i < n; i++) {\n        ll a;\n        do {\n            a = rnd.next(1LL, h);\n        } while(used_positions.count(a));\n        ai[i] = a;\n        used_positions.insert(a);\n        ci[i] = rnd.next(1, int(1e9));\n    }\n\n    // Output h, n, m, k\n    cout << h << \" \" << n << \" \" << m << \" \" << k << \"\\n\";\n    for(int i = 0; i < n; i++) {\n        cout << ai[i] << \" \" << ci[i] << \"\\n\";\n    }\n\n    vector<ll> methods;\n    methods.push_back(k);\n\n    vector<int> existing_treasures;\n    for(int i = 0; i < n; i++) {\n        existing_treasures.push_back(i);\n    }\n\n    vector<int> current_ci = ci;\n\n    vector<bool> reachable(n, false);\n\n    auto update_reachable = [&]() {\n        for(int idx : existing_treasures){\n            reachable[idx] = false;\n            for(ll s : methods){\n                if( (ai[idx] -1) % s == 0){\n                    reachable[idx] = true;\n                    break;\n                }\n            }\n        }\n    };\n\n    update_reachable();\n\n    vector<int> op_types(m);\n    vector<vector<ll>> ops(m);\n\n    int max_op1 = 20;\n    int num_op1 = rnd.next(0, min(max_op1, m / 5));\n\n    vector<int> op1_positions;\n    for(int i = 0; i < m; i++)\n        op1_positions.push_back(i);\n    shuffle(op1_positions.begin(), op1_positions.end());\n    op1_positions.resize(num_op1);\n    set<int> op1_set(op1_positions.begin(), op1_positions.end());\n\n    for(int i = 0; i < m; i++) {\n        if(op1_set.count(i)) {\n            op_types[i] = 1;\n        } else {\n            op_types[i] = rnd.next(2,3);\n        }\n    }\n\n    for(int i = 0; i < m; i++) {\n        if(op_types[i] == 1) {\n            // Operation 1: \"1 x\"\n            ll x = rnd.next(1LL, h);\n            methods.push_back(x);\n            // Update reachable\n            update_reachable();\n            ops[i] = {x};\n        } else if(op_types[i] == 2) {\n            // Operation 2: \"2 x y\"\n            if(existing_treasures.empty()) {\n                // No existing treasures, change operation to type 3\n                op_types[i] = 3;\n                ops[i] = {};\n                i--; // Re-iterate to process as type 3\n                continue;\n            }\n            int idx = rnd.next(0, existing_treasures.size() - 1);\n            int x = existing_treasures[idx];\n            int y_max = current_ci[x] -1;\n            int y = rnd.next(0, y_max);\n            current_ci[x] -= y;\n            ops[i] = { (ll)(x + 1), (ll)y };\n        } else if(op_types[i] == 3) {\n            // Operation 3: \"3\"\n            ops[i] = {};\n            // Find and remove the most valuable reachable treasure\n            int max_value = -1;\n            int min_idx = n + 1;\n            int max_treasure_idx = -1;\n            for(int idx : existing_treasures) {\n                if(reachable[idx]) {\n                    if(current_ci[idx] > max_value || \n                      (current_ci[idx] == max_value && idx < min_idx)) {\n                        max_value = current_ci[idx];\n                        min_idx = idx;\n                        max_treasure_idx = idx;\n                    }\n                }\n            }\n            if(max_treasure_idx != -1) {\n                // Remove the treasure\n                existing_treasures.erase(\n                    remove(existing_treasures.begin(), existing_treasures.end(), max_treasure_idx),\n                    existing_treasures.end());\n                // No need to update reachable, since the treasure is removed\n            }\n        }\n    }\n\n    // Output operations\n    for(int i = 0; i < m; i++) {\n        if(op_types[i] == 1) {\n            cout << \"1 \" << ops[i][0] << \"\\n\";\n        } else if(op_types[i] == 2) {\n            cout << \"2 \" << ops[i][0] << \" \" << ops[i][1] << \"\\n\";\n        } else if(op_types[i] == 3) {\n            cout << \"3\\n\";\n        }\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Small random test cases\n./gen -h 1000 -n 10 -m 10 -k 2 -test_type random\n./gen -h 1000 -n 20 -m 15 -k 3 -test_type random\n./gen -h 10000 -n 50 -m 50 -k 5 -test_type random\n\n# Maximal h, small n and m\n./gen -h 1000000000000000000 -n 10 -m 10 -k 2 -test_type random\n./gen -h 1000000000000000000 -n 100 -m 100 -k 10000 -test_type random\n\n# Maximal n and m, moderate h\n./gen -h 1000000 -n 100000 -m 100000 -k 1000 -test_type random\n./gen -h 1000000000 -n 100000 -m 100000 -k 5000 -test_type random\n\n# Maximal h, n, and m\n./gen -h 1000000000000000000 -n 100000 -m 100000 -k 10000 -test_type random\n\n# Many type 1 operations (close to 20)\n./gen -h 1000000 -n 10000 -m 50000 -k 1000 -test_type random\n./gen -h 1000000 -n 10000 -m 50000 -k 1000 -test_type random\n\n# Many type 3 operations\n./gen -h 100000000 -n 10000 -m 100000 -k 100 -test_type random\n./gen -h 100000000 -n 10000 -m 100000 -k 500 -test_type random\n\n# Max treasure values\n./gen -h 1000000 -n 50000 -m 50000 -k 1000 -test_type random\n\n# Duplicate max treasure values\n./gen -h 1000000 -n 10000 -m 10000 -k 100 -test_type random\n\n# Unreachable treasures by default\n./gen -h 1000000 -n 10000 -m 10000 -k 1 -test_type random\n\n# Cases with no reachable treasures\n./gen -h 1000000 -n 10000 -m 10000 -k 1 -test_type random\n\n# Treasures at positions near h\n./gen -h 1000000000000000000 -n 50000 -m 50000 -k 999999999 -test_type random\n\n# Treasures at positions near 1\n./gen -h 1000000 -n 50000 -m 50000 -k 1 -test_type random\n\n# Test with k equals 1\n./gen -h 1000000 -n 50000 -m 50000 -k 1 -test_type random\n\n# Test with k equals h\n./gen -h 1000000 -n 50000 -m 50000 -k 1000000 -test_type random\n\n# Test with h, n, m at maximum limits\n./gen -h 1000000000000000000 -n 100000 -m 100000 -k 10000 -test_type random\n\n# Test varying methods added\n./gen -h 1000000 -n 10000 -m 50000 -k 500 -test_type random\n\n# Test with operations adding methods that are factors of h\n./gen -h 1000000 -n 10000 -m 50000 -k 1000 -test_type random\n\n# Test with maximum ci values\n./gen -h 1000000 -n 100000 -m 100000 -k 1000 -test_type random\n\n# Test with minimum ci values\n./gen -h 1000000 -n 100000 -m 100000 -k 1000 -test_type random\n\n# Test with treasures clustered at specific positions\n./gen -h 1000000 -n 10000 -m 50000 -k 100 -test_type random\n\n# Test with treasures evenly distributed\n./gen -h 1000000 -n 100000 -m 100000 -k 1000 -test_type random\n\n# Edge case with h = 1\n./gen -h 1 -n 1 -m 1 -k 1 -test_type random\n\n# Edge case with k > h\n./gen -h 1000 -n 100 -m 100 -k 10000 -test_type random\n\n# Edge case with no methods added\n./gen -h 1000000 -n 50000 -m 50000 -k 1000 -test_type random\n\n# Edge case where all operations are type 3\n./gen -h 1000000 -n 50000 -m 50000 -k 1000 -test_type random\n\n# Edge case where all operations are type 2\n./gen -h 1000000 -n 50000 -m 50000 -k 1000 -test_type random\n\n# Edge case with maximum operations of type 1\n./gen -h 1000000 -n 50000 -m 50000 -k 1000 -test_type random\n\n# Test with small k\n./gen -h 1000000 -n 10000 -m 10000 -k 2 -test_type random\n\n# Test with large k\n./gen -h 1000000 -n 10000 -m 10000 -k 999999 -test_type random\n\n# Extreme case where h, n, m are minimal\n./gen -h 1 -n 1 -m 1 -k 1 -test_type random\n\n# Extreme case where h, n, m are maximal\n./gen -h 1000000000000000000 -n 100000 -m 100000 -k 10000 -test_type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:06:36.966901",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "313/A",
      "title": "A. Ilya and Bank Account",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe single line contains integer n (10 ≤ |n| ≤ 109) — the state of Ilya's bank account.",
      "output_spec": "OutputIn a single line print an integer — the maximum state of the bank account that Ilya can get.",
      "sample_tests": "ExamplesInputCopy2230OutputCopy2230InputCopy-10OutputCopy0InputCopy-100003OutputCopy-10000",
      "description": "A. Ilya and Bank Account\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe single line contains integer n (10 ≤ |n| ≤ 109) — the state of Ilya's bank account.\n\nOutputIn a single line print an integer — the maximum state of the bank account that Ilya can get.\n\nInputCopy2230OutputCopy2230InputCopy-10OutputCopy0InputCopy-100003OutputCopy-10000\n\nInputCopy2230\n\nOutputCopy2230\n\nInputCopy-10\n\nOutputCopy0\n\nInputCopy-100003\n\nOutputCopy-10000\n\nNoteIn the first test sample Ilya doesn't profit from using the present.In the second test sample you can delete digit 1 and get the state of the account equal to 0.",
      "solutions": [
        {
          "title": "Codeforces Round #186 (Div. 2) - Codeforces",
          "content": "Hello everyone!Codeforces Round #186 (Div. 2) will take place on Thursday, May 30th at 19:30 MSK. This is my first Codeforces Round and I hope that everyone will enjoy this round. I would like to thank Gerald for helping me prepare this round. Special thanks to Delinur for translation of all problem statements into English.Problems point values today is: 500-1000-1500-2500-2500 Good luck & have fun! :)",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/7803",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 405
        },
        {
          "title": "Analysis of Codeforces Round #186 (Div. 2) - Codeforces",
          "content": "313A - Ilya and Bank AccountThis problem is the easiest one. You need to use only div and mod functions. If n>0, then answer is n, else you need to delete one of two digits. For better understanding you can look at solution. 313B - Ilya and QueriesPrecalculate some array Ai, that Ai = 1, if si = si + 1, else Ai = 0. Now for any query (l, r), you need to find sum of Ai, that (l ≤ i < r). It is standart problem. For solving this problem you can precalcutate some another array Sum, where Sumi = A1 + A2 + ... + Ai. Then sum of interval (l, r) is Sum_r — Sum_{l-1}. For better understanding you can look at solution.313C - Ilya and MatrixAt the start sort array. Let Ci — number of times of entering the number in Aі optimal placement. Answer is sum of Ai * Ci for all i (1 ≤ i ≤ 4n). If we look at the array C, we can see that for maximal element C = n + 1 (for array with size 4n), then for second, third and fourth maximum elements C = n. On this basis we can see, that for array with non-increasing order answer calculate like Sum(1, 1) + Sum(1, 4) + Sum(1, 16) + ... + Sum(1, 4n). So, for solve this problem you have to know only sort. For better understanding you can look at solution313D - Ilya and Roads To solve this problem you need to use dynamic programming. Let Fulli, j — minimal cost of covering interval (i, j). Fix left border and move right. You can solve this subtask with complexity O(nm) or O(nmlogn). Now we need to solve the standart problem of dynamic programming. Cover K points with intervals that have not intersect. This problem with square dynamic. dpi, j — minimal cost of covering j-points, if you look some prefix length i. Answer for all problem is minimal integer from dpi, j, (k ≤ j ≤ n).To solve second part:1) dpi + 1, j = min(dpi + 1, j, dpi, j) — skip point with number i + 12) dpk, j + len = min(dpk, j + len, dpi, j + Cost); Cost — cost of interval with length len, that ending at point k. We precalculate Cost at first part of solution.For better understanding you can look at solution313E - Ilya and Two NumbersAuthor solution is harder than that which is offered by MrDindows. It is solution of MrDindows.1) Get the number of our sequences in sorted by frequencies. Thus from the first sequence (hereinafter — the first type) — in a direct order from the second — to the contrary.2) These numbers are put on the stack, where if, recording onto the stack of the second type, we find the number at the top of the first type, then this pair of extract and add to the answer.3) At the end, obviously the stack we can find a number of properties of the second type and the first bottom — on. Then their grouping in response pairs with the start and end.For better understanding you can look at solution.Sorry for waiting.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/7826",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 313\\s*A"
          },
          "content_length": 2761
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #186 (Div. 2) - Codeforces - Code 1",
          "code": "ios_base::sync_with_stdio(false)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7803",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #186 (Div. 2) - Codeforces - Code 2",
          "code": "Collections.shuffle",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7803",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #186 (Div. 2) - Codeforces - Code 3",
          "code": "Collections.shuffle",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7803",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #186 (Div. 2) - Codeforces - Code 4",
          "code": "Collections.sort",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7803",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #186 (Div. 2) - Codeforces - Code 5",
          "code": "for(int n = 1 ; n <= N ; n++){\nfor(int k = 1 ; k <= n ; k++){\nfor(int i = 0 ; i < f[n].size() ; i++){\nfor(int h = n ; h >= 0 ; h--){\n...",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7803",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #186 (Div. 2) - Codeforces - Code 6",
          "code": "for(int n = 1 ; n <= N ; n++){\nfor(int k = 1 ; k <= n ; k++){\nfor(int i = 0 ; i < f[n].size() ; i++){\nfor(int h = n ; h >= 0 ; h--){\n...",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7803",
          "author": "jiangly"
        },
        {
          "title": "Analysis of Codeforces Round #186 (Div. 2) - Codeforces - Code 1",
          "code": "dp[i,j] = min(dp[i,j], dp[k,j], 1 <= k < i",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7826",
          "author": "jiangly"
        },
        {
          "title": "Analysis of Codeforces Round #186 (Div. 2) - Codeforces - Code 2",
          "code": "dp[i][j] = min(dp[i][j], dp[i-1][j]);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7826",
          "author": "jiangly"
        },
        {
          "title": "Analysis of Codeforces Round #186 (Div. 2) - Codeforces - Code 3",
          "code": "0 <= a,b,c < m",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7826",
          "author": "jiangly"
        },
        {
          "title": "Analysis of Codeforces Round #186 (Div. 2) - Codeforces - Code 4",
          "code": "if (a + b >= m and c + b < m) (resp. c + a)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7826",
          "author": "jiangly"
        },
        {
          "title": "Analysis of Codeforces Round #186 (Div. 2) - Codeforces - Code 5",
          "code": "then (always) (c + b) % m >= (a + b) % m",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7826",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    long long n = inf.readLong(-1000000000LL,1000000000LL,\"n\");\n    inf.readEoln();\n    ensuref(n <= -10 || n >= 10, \"n must satisfy either n <= -10 or n >= 10, but n = %lld\", n);\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    long long n = inf.readLong(-1000000000LL,1000000000LL,\"n\");\n    inf.readEoln();\n    ensuref(n <= -10 || n >= 10, \"n must satisfy either n <= -10 or n >= 10, but n = %lld\", n);\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    long long n = inf.readLong(-1000000000LL,1000000000LL,\"n\");\n    inf.readEoln();\n    ensuref(n <= -10 || n >= 10, \"n must satisfy either n <= -10 or n >= 10, but n = %lld\", n);\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    string type = opt<string>(\"type\", \"random\");\n    int n;\n\n    if (type == \"positive\") {\n        // Positive integer between 10 and 1e9\n        n = rnd.next(10, 1000000000);\n    } else if (type == \"negative\") {\n        // Negative integer between -1e9 and -10\n        n = -rnd.next(10, 1000000000);\n    } else if (type == \"max_positive\") {\n        n = 1000000000;\n    } else if (type == \"min_positive\") {\n        n = 10;\n    } else if (type == \"max_negative\") {\n        n = -10;\n    } else if (type == \"min_negative\") {\n        n = -1000000000;\n    } else if (type == \"negative_end_zero\") {\n        // Generate negative number ending with zero\n        int digits = rnd.next(2,9); // number of digits, at least 2\n        string s = \"-\";\n        s += char('1' + rnd.next(0, 8)); // first digit (excluding 0)\n        for(int i = 1; i < digits -1; ++i) {\n            s += char('0' + rnd.next(0,9));\n        }\n        s += '0'; // Last digit is zero\n        n = stoi(s);\n    } else if (type == \"negative_small\") {\n        // Negative numbers between -10 and -99\n        n = -rnd.next(10, 99);\n    } else if (type == \"negative_large\") {\n        // Negative numbers between -1000000000 and -100000000\n        n = -rnd.next(100000000, 1000000000);\n    } else if (type == \"single_digit\") {\n        // Number that will become single-digit number after deleting a digit\n        // For example n = -101, deleting a digit can become -10 or -11\n        int n1 = -rnd.next(10, 99); // n1 between -10 and -99\n        n = n1 * 10 + rnd.next(0, 9); // n between -100 to -999\n    } else if (type == \"zeroes\") {\n        // Generate numbers with zeros in various positions\n        int digits = rnd.next(2, 9);\n        string s = \"-\";\n        s += char('1' + rnd.next(0,8)); // first digit not zero\n        for(int i = 1; i < digits; ++i) {\n            s += '0';\n        }\n        n = stoi(s);\n    } else if (type == \"value\") {\n        // Output the specific value provided\n        n = opt<int>(\"value\");\n        if (abs(n) < 10 || abs(n) > 1000000000 || n == 0) {\n            cerr << \"Invalid value of n: \" << n << endl;\n            exit(1);\n        }\n    } else {\n        // Random integer between -1e9 and -10, or 10 and 1e9\n        int sign = rnd.next(0, 1) == 0 ? -1 : 1;\n        if (sign == -1) {\n            n = -rnd.next(10, 1000000000);\n        } else {\n            n = rnd.next(10, 1000000000);\n        }\n    }\n\n    // Output n\n    printf(\"%d\\n\", n);\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    string type = opt<string>(\"type\", \"random\");\n    int n;\n\n    if (type == \"positive\") {\n        // Positive integer between 10 and 1e9\n        n = rnd.next(10, 1000000000);\n    } else if (type == \"negative\") {\n        // Negative integer between -1e9 and -10\n        n = -rnd.next(10, 1000000000);\n    } else if (type == \"max_positive\") {\n        n = 1000000000;\n    } else if (type == \"min_positive\") {\n        n = 10;\n    } else if (type == \"max_negative\") {\n        n = -10;\n    } else if (type == \"min_negative\") {\n        n = -1000000000;\n    } else if (type == \"negative_end_zero\") {\n        // Generate negative number ending with zero\n        int digits = rnd.next(2,9); // number of digits, at least 2\n        string s = \"-\";\n        s += char('1' + rnd.next(0, 8)); // first digit (excluding 0)\n        for(int i = 1; i < digits -1; ++i) {\n            s += char('0' + rnd.next(0,9));\n        }\n        s += '0'; // Last digit is zero\n        n = stoi(s);\n    } else if (type == \"negative_small\") {\n        // Negative numbers between -10 and -99\n        n = -rnd.next(10, 99);\n    } else if (type == \"negative_large\") {\n        // Negative numbers between -1000000000 and -100000000\n        n = -rnd.next(100000000, 1000000000);\n    } else if (type == \"single_digit\") {\n        // Number that will become single-digit number after deleting a digit\n        // For example n = -101, deleting a digit can become -10 or -11\n        int n1 = -rnd.next(10, 99); // n1 between -10 and -99\n        n = n1 * 10 + rnd.next(0, 9); // n between -100 to -999\n    } else if (type == \"zeroes\") {\n        // Generate numbers with zeros in various positions\n        int digits = rnd.next(2, 9);\n        string s = \"-\";\n        s += char('1' + rnd.next(0,8)); // first digit not zero\n        for(int i = 1; i < digits; ++i) {\n            s += '0';\n        }\n        n = stoi(s);\n    } else if (type == \"value\") {\n        // Output the specific value provided\n        n = opt<int>(\"value\");\n        if (abs(n) < 10 || abs(n) > 1000000000 || n == 0) {\n            cerr << \"Invalid value of n: \" << n << endl;\n            exit(1);\n        }\n    } else {\n        // Random integer between -1e9 and -10, or 10 and 1e9\n        int sign = rnd.next(0, 1) == 0 ? -1 : 1;\n        if (sign == -1) {\n            n = -rnd.next(10, 1000000000);\n        } else {\n            n = rnd.next(10, 1000000000);\n        }\n    }\n\n    // Output n\n    printf(\"%d\\n\", n);\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Edge cases\n./gen -type min_negative\n./gen -type max_negative\n./gen -type min_positive\n./gen -type max_positive\n\n# Negative numbers ending with zero\n./gen -type negative_end_zero\n./gen -type negative_end_zero\n./gen -type negative_end_zero\n\n# Negative small numbers\n./gen -type negative_small\n./gen -type negative_small\n./gen -type negative_small\n\n# Negative large numbers\n./gen -type negative_large\n./gen -type negative_large\n./gen -type negative_large\n\n# Positive numbers\n./gen -type positive\n./gen -type positive\n./gen -type positive\n./gen -type positive\n./gen -type positive\n\n# Negative numbers\n./gen -type negative\n./gen -type negative\n./gen -type negative\n./gen -type negative\n./gen -type negative\n\n# Numbers with zeros in various positions\n./gen -type zeroes\n./gen -type zeroes\n\n# Single digit after deletion\n./gen -type single_digit\n./gen -type single_digit\n\n# Specific values from sample inputs\n./gen -type value -value -10\n./gen -type value -value 2230\n./gen -type value -value -100003\n\n# Specific large negative value\n./gen -type value -value -999999999\n\n# Random numbers\n./gen\n./gen\n./gen\n./gen\n./gen\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:06:39.259314",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "313/B",
      "title": "B. Ilya and Queries",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains string s of length n (2 ≤ n ≤ 105). It is guaranteed that the given string only consists of characters \".\" and \"#\".The next line contains integer m (1 ≤ m ≤ 105) — the number of queries. Each of the next m lines contains the description of the corresponding query. The i-th line contains integers li, ri (1 ≤ li < ri ≤ n).",
      "output_spec": "OutputPrint m integers — the answers to the queries in the order in which they are given in the input.",
      "sample_tests": "ExamplesInputCopy......43 42 31 62 6OutputCopy1154InputCopy#..###51 35 61 53 63 4OutputCopy11220",
      "description": "B. Ilya and Queries\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains string s of length n (2 ≤ n ≤ 105). It is guaranteed that the given string only consists of characters \".\" and \"#\".The next line contains integer m (1 ≤ m ≤ 105) — the number of queries. Each of the next m lines contains the description of the corresponding query. The i-th line contains integers li, ri (1 ≤ li < ri ≤ n).\n\nOutputPrint m integers — the answers to the queries in the order in which they are given in the input.\n\nInputCopy......43 42 31 62 6OutputCopy1154InputCopy#..###51 35 61 53 63 4OutputCopy11220\n\nInputCopy......43 42 31 62 6\n\nOutputCopy1154\n\nInputCopy#..###51 35 61 53 63 4\n\nOutputCopy11220",
      "solutions": [
        {
          "title": "Codeforces Round #186 (Div. 2) - Codeforces",
          "content": "Hello everyone!Codeforces Round #186 (Div. 2) will take place on Thursday, May 30th at 19:30 MSK. This is my first Codeforces Round and I hope that everyone will enjoy this round. I would like to thank Gerald for helping me prepare this round. Special thanks to Delinur for translation of all problem statements into English.Problems point values today is: 500-1000-1500-2500-2500 Good luck & have fun! :)",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/7803",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 405
        },
        {
          "title": "Analysis of Codeforces Round #186 (Div. 2) - Codeforces",
          "content": "313A - Ilya and Bank AccountThis problem is the easiest one. You need to use only div and mod functions. If n>0, then answer is n, else you need to delete one of two digits. For better understanding you can look at solution. 313B - Ilya and QueriesPrecalculate some array Ai, that Ai = 1, if si = si + 1, else Ai = 0. Now for any query (l, r), you need to find sum of Ai, that (l ≤ i < r). It is standart problem. For solving this problem you can precalcutate some another array Sum, where Sumi = A1 + A2 + ... + Ai. Then sum of interval (l, r) is Sum_r — Sum_{l-1}. For better understanding you can look at solution.313C - Ilya and MatrixAt the start sort array. Let Ci — number of times of entering the number in Aі optimal placement. Answer is sum of Ai * Ci for all i (1 ≤ i ≤ 4n). If we look at the array C, we can see that for maximal element C = n + 1 (for array with size 4n), then for second, third and fourth maximum elements C = n. On this basis we can see, that for array with non-increasing order answer calculate like Sum(1, 1) + Sum(1, 4) + Sum(1, 16) + ... + Sum(1, 4n). So, for solve this problem you have to know only sort. For better understanding you can look at solution313D - Ilya and Roads To solve this problem you need to use dynamic programming. Let Fulli, j — minimal cost of covering interval (i, j). Fix left border and move right. You can solve this subtask with complexity O(nm) or O(nmlogn). Now we need to solve the standart problem of dynamic programming. Cover K points with intervals that have not intersect. This problem with square dynamic. dpi, j — minimal cost of covering j-points, if you look some prefix length i. Answer for all problem is minimal integer from dpi, j, (k ≤ j ≤ n).To solve second part:1) dpi + 1, j = min(dpi + 1, j, dpi, j) — skip point with number i + 12) dpk, j + len = min(dpk, j + len, dpi, j + Cost); Cost — cost of interval with length len, that ending at point k. We precalculate Cost at first part of solution.For better understanding you can look at solution313E - Ilya and Two NumbersAuthor solution is harder than that which is offered by MrDindows. It is solution of MrDindows.1) Get the number of our sequences in sorted by frequencies. Thus from the first sequence (hereinafter — the first type) — in a direct order from the second — to the contrary.2) These numbers are put on the stack, where if, recording onto the stack of the second type, we find the number at the top of the first type, then this pair of extract and add to the answer.3) At the end, obviously the stack we can find a number of properties of the second type and the first bottom — on. Then their grouping in response pairs with the start and end.For better understanding you can look at solution.Sorry for waiting.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/7826",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 313\\s*B"
          },
          "content_length": 2761
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #186 (Div. 2) - Codeforces - Code 1",
          "code": "ios_base::sync_with_stdio(false)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7803",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #186 (Div. 2) - Codeforces - Code 2",
          "code": "Collections.shuffle",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7803",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #186 (Div. 2) - Codeforces - Code 3",
          "code": "Collections.shuffle",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7803",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #186 (Div. 2) - Codeforces - Code 4",
          "code": "Collections.sort",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7803",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #186 (Div. 2) - Codeforces - Code 5",
          "code": "for(int n = 1 ; n <= N ; n++){\nfor(int k = 1 ; k <= n ; k++){\nfor(int i = 0 ; i < f[n].size() ; i++){\nfor(int h = n ; h >= 0 ; h--){\n...",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7803",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #186 (Div. 2) - Codeforces - Code 6",
          "code": "for(int n = 1 ; n <= N ; n++){\nfor(int k = 1 ; k <= n ; k++){\nfor(int i = 0 ; i < f[n].size() ; i++){\nfor(int h = n ; h >= 0 ; h--){\n...",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7803",
          "author": "jiangly"
        },
        {
          "title": "Analysis of Codeforces Round #186 (Div. 2) - Codeforces - Code 1",
          "code": "dp[i,j] = min(dp[i,j], dp[k,j], 1 <= k < i",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7826",
          "author": "jiangly"
        },
        {
          "title": "Analysis of Codeforces Round #186 (Div. 2) - Codeforces - Code 2",
          "code": "dp[i][j] = min(dp[i][j], dp[i-1][j]);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7826",
          "author": "jiangly"
        },
        {
          "title": "Analysis of Codeforces Round #186 (Div. 2) - Codeforces - Code 3",
          "code": "0 <= a,b,c < m",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7826",
          "author": "jiangly"
        },
        {
          "title": "Analysis of Codeforces Round #186 (Div. 2) - Codeforces - Code 4",
          "code": "if (a + b >= m and c + b < m) (resp. c + a)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7826",
          "author": "jiangly"
        },
        {
          "title": "Analysis of Codeforces Round #186 (Div. 2) - Codeforces - Code 5",
          "code": "then (always) (c + b) % m >= (a + b) % m",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7826",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    // Read the string s\n    string s = inf.readLine(\"[.#]+\", \"s\");\n    ensuref(2 <= s.length() && s.length() <= 100000, \"Length of s must be between 2 and 1e5, but it's %d\", int(s.length()));\n    int n = s.length();\n\n    // Read m\n    int m = inf.readInt(1, 100000, \"m\");\n    inf.readEoln();\n\n    // For each of the m queries\n    for (int i = 0; i < m; ++i) {\n        int li = inf.readInt(1, n - 1, \"li\");\n        inf.readSpace();\n        int ri = inf.readInt(li + 1, n, \"ri\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    // Read the string s\n    string s = inf.readLine(\"[.#]+\", \"s\");\n    ensuref(2 <= s.length() && s.length() <= 100000, \"Length of s must be between 2 and 1e5, but it's %d\", int(s.length()));\n    int n = s.length();\n\n    // Read m\n    int m = inf.readInt(1, 100000, \"m\");\n    inf.readEoln();\n\n    // For each of the m queries\n    for (int i = 0; i < m; ++i) {\n        int li = inf.readInt(1, n - 1, \"li\");\n        inf.readSpace();\n        int ri = inf.readInt(li + 1, n, \"ri\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    // Read the string s\n    string s = inf.readLine(\"[.#]+\", \"s\");\n    ensuref(2 <= s.length() && s.length() <= 100000, \"Length of s must be between 2 and 1e5, but it's %d\", int(s.length()));\n    int n = s.length();\n\n    // Read m\n    int m = inf.readInt(1, 100000, \"m\");\n    inf.readEoln();\n\n    // For each of the m queries\n    for (int i = 0; i < m; ++i) {\n        int li = inf.readInt(1, n - 1, \"li\");\n        inf.readSpace();\n        int ri = inf.readInt(li + 1, n, \"ri\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\"); // length of the string\n    int m = opt<int>(\"m\"); // number of queries\n    string s_type = opt<string>(\"s_type\", \"random\");\n    string q_type = opt<string>(\"q_type\", \"random\");\n\n    // Ensure n and m within the given constraints\n    n = min(n, 100000);\n    n = max(n, 2);\n    m = min(m, 100000);\n    m = max(m, 1);\n\n    string s(n, '.'); // initialize s with '.'\n\n    if(s_type == \"all_dots\") {\n        // String of all '.'\n        s = string(n, '.');\n    } else if(s_type == \"all_hashes\") {\n        // String of all '#'\n        s = string(n, '#');\n    } else if(s_type == \"alternating\") {\n        // Alternating '.' and '#'\n        char c[2] = {'.', '#'};\n        for(int i = 0; i < n; i++) {\n            s[i] = c[i % 2];\n        }\n    } else if(s_type == \"random\") {\n        // Randomly assign '.' or '#'\n        for(int i = 0; i < n; i++) {\n            s[i] = rnd.next(2) ? '.' : '#';\n        }\n    } else if(s_type == \"runs\") {\n        // Random runs of '.' and '#'\n        int pos = 0;\n        char c = rnd.next(2) ? '.' : '#';\n        while (pos < n) {\n            int max_run_length = n / 10 + 1;\n            int run_length = rnd.next(1, max_run_length);\n            run_length = min(run_length, n - pos);\n            for(int i = 0; i < run_length; i++) {\n                s[pos++] = c;\n            }\n            c = (c == '.') ? '#' : '.';\n        }\n    } else if(s_type == \"half_and_half\") {\n        // First half '.' and second half '#'\n        int mid = n / 2;\n        for(int i = 0; i < mid; i++) {\n            s[i] = '.';\n        }\n        for(int i = mid; i < n; i++) {\n            s[i] = '#';\n        }\n    }\n\n    vector<pair<int, int>> queries(m);\n\n    if(q_type == \"random\") {\n        for(int i = 0; i < m; i++) {\n            int li = rnd.next(1, n - 1);\n            int ri = rnd.next(li + 1, n);\n            queries[i] = make_pair(li, ri);\n        }\n    } else if(q_type == \"full_range\") {\n        for(int i = 0; i < m; i++) {\n            queries[i] = make_pair(1, n);\n        }\n    } else if(q_type == \"small_ranges\") {\n        for(int i = 0; i < m; i++) {\n            int li = rnd.next(1, n - 1);\n            int max_len = min(5, n - li);\n            int len = rnd.next(1, max_len);\n            int ri = li + len;\n            queries[i] = make_pair(li, ri);\n        }\n    } else if(q_type == \"large_ranges\") {\n        int max_li = max(1, n / 10);\n        int min_ri = max(1, n - n / 10);\n        for(int i = 0; i < m; i++) {\n            int li = rnd.next(1, max_li);\n            int ri = rnd.next(max(li + 1, min_ri), n);\n            ri = max(ri, li + 1);\n            queries[i] = make_pair(li, ri);\n        }\n    }\n\n    // Output the string s\n    printf(\"%s\\n\", s.c_str());\n\n    // Output m\n    printf(\"%d\\n\", m);\n\n    // Output the queries\n    for(int i = 0; i < m; i++) {\n        printf(\"%d %d\\n\", queries[i].first, queries[i].second);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\"); // length of the string\n    int m = opt<int>(\"m\"); // number of queries\n    string s_type = opt<string>(\"s_type\", \"random\");\n    string q_type = opt<string>(\"q_type\", \"random\");\n\n    // Ensure n and m within the given constraints\n    n = min(n, 100000);\n    n = max(n, 2);\n    m = min(m, 100000);\n    m = max(m, 1);\n\n    string s(n, '.'); // initialize s with '.'\n\n    if(s_type == \"all_dots\") {\n        // String of all '.'\n        s = string(n, '.');\n    } else if(s_type == \"all_hashes\") {\n        // String of all '#'\n        s = string(n, '#');\n    } else if(s_type == \"alternating\") {\n        // Alternating '.' and '#'\n        char c[2] = {'.', '#'};\n        for(int i = 0; i < n; i++) {\n            s[i] = c[i % 2];\n        }\n    } else if(s_type == \"random\") {\n        // Randomly assign '.' or '#'\n        for(int i = 0; i < n; i++) {\n            s[i] = rnd.next(2) ? '.' : '#';\n        }\n    } else if(s_type == \"runs\") {\n        // Random runs of '.' and '#'\n        int pos = 0;\n        char c = rnd.next(2) ? '.' : '#';\n        while (pos < n) {\n            int max_run_length = n / 10 + 1;\n            int run_length = rnd.next(1, max_run_length);\n            run_length = min(run_length, n - pos);\n            for(int i = 0; i < run_length; i++) {\n                s[pos++] = c;\n            }\n            c = (c == '.') ? '#' : '.';\n        }\n    } else if(s_type == \"half_and_half\") {\n        // First half '.' and second half '#'\n        int mid = n / 2;\n        for(int i = 0; i < mid; i++) {\n            s[i] = '.';\n        }\n        for(int i = mid; i < n; i++) {\n            s[i] = '#';\n        }\n    }\n\n    vector<pair<int, int>> queries(m);\n\n    if(q_type == \"random\") {\n        for(int i = 0; i < m; i++) {\n            int li = rnd.next(1, n - 1);\n            int ri = rnd.next(li + 1, n);\n            queries[i] = make_pair(li, ri);\n        }\n    } else if(q_type == \"full_range\") {\n        for(int i = 0; i < m; i++) {\n            queries[i] = make_pair(1, n);\n        }\n    } else if(q_type == \"small_ranges\") {\n        for(int i = 0; i < m; i++) {\n            int li = rnd.next(1, n - 1);\n            int max_len = min(5, n - li);\n            int len = rnd.next(1, max_len);\n            int ri = li + len;\n            queries[i] = make_pair(li, ri);\n        }\n    } else if(q_type == \"large_ranges\") {\n        int max_li = max(1, n / 10);\n        int min_ri = max(1, n - n / 10);\n        for(int i = 0; i < m; i++) {\n            int li = rnd.next(1, max_li);\n            int ri = rnd.next(max(li + 1, min_ri), n);\n            ri = max(ri, li + 1);\n            queries[i] = make_pair(li, ri);\n        }\n    }\n\n    // Output the string s\n    printf(\"%s\\n\", s.c_str());\n\n    // Output m\n    printf(\"%d\\n\", m);\n\n    // Output the queries\n    for(int i = 0; i < m; i++) {\n        printf(\"%d %d\\n\", queries[i].first, queries[i].second);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 2 -m 1 -s_type all_dots -q_type full_range\n./gen -n 2 -m 1 -s_type all_hashes -q_type full_range\n./gen -n 2 -m 1 -s_type alternating -q_type full_range\n./gen -n 2 -m 1 -s_type random -q_type random\n./gen -n 2 -m 1 -s_type runs -q_type small_ranges\n\n./gen -n 3 -m 3 -s_type runs -q_type small_ranges\n\n./gen -n 10 -m 5 -s_type alternating -q_type random\n./gen -n 10 -m 5 -s_type random -q_type small_ranges\n./gen -n 10 -m 5 -s_type runs -q_type large_ranges\n./gen -n 10 -m 5 -s_type half_and_half -q_type full_range\n\n./gen -n 100 -m 50 -s_type all_dots -q_type small_ranges\n./gen -n 100 -m 50 -s_type all_hashes -q_type large_ranges\n./gen -n 100 -m 50 -s_type random -q_type random\n\n./gen -n 1000 -m 500 -s_type runs -q_type random\n./gen -n 1000 -m 500 -s_type alternating -q_type small_ranges\n\n./gen -n 99999 -m 1 -s_type alternating -q_type full_range\n\n./gen -n 50000 -m 50000 -s_type half_and_half -q_type large_ranges\n./gen -n 50000 -m 50000 -s_type random -q_type random\n\n./gen -n 100000 -m 1 -s_type half_and_half -q_type full_range\n\n./gen -n 100000 -m 100000 -s_type all_dots -q_type full_range\n./gen -n 100000 -m 100000 -s_type all_hashes -q_type full_range\n\n./gen -n 100000 -m 100000 -s_type runs -q_type small_ranges\n./gen -n 100000 -m 100000 -s_type runs -q_type large_ranges\n./gen -n 100000 -m 100000 -s_type alternating -q_type random\n./gen -n 100000 -m 100000 -s_type random -q_type random\n./gen -n 100000 -m 100000 -s_type runs -q_type random\n\n./gen -n 2 -m 1 -s_type random -q_type small_ranges\n./gen -n 2 -m 1 -s_type random -q_type large_ranges\n./gen -n 2 -m 1 -s_type random -q_type random\n\n./gen -n 100000 -m 100000 -s_type alternating -q_type large_ranges\n\n./gen -n 100000 -m 100000 -s_type random -q_type small_ranges\n\n./gen -n 2 -m 1 -s_type half_and_half -q_type random\n\n# Testing when n and m are at maximum values\n\n./gen -n 100000 -m 100000 -s_type random -q_type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:06:41.392289",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "313/C",
      "title": "C. Ilya and Matrix",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains integer 4n (1 ≤ 4n ≤ 2·106). The next line contains 4n integers ai (1 ≤ ai ≤ 109) — the numbers you need to arrange in the 2n × 2n-sized matrix.",
      "output_spec": "OutputOn a single line print the maximum value of the beauty of the described matrix.Please, do not use the %lld specifier to read or write 64-bit integers in С++. It is preferred to use the cin, cout streams or the %I64d specifier.",
      "sample_tests": "ExamplesInputCopy113OutputCopy13InputCopy41 2 3 4OutputCopy14",
      "description": "C. Ilya and Matrix\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains integer 4n (1 ≤ 4n ≤ 2·106). The next line contains 4n integers ai (1 ≤ ai ≤ 109) — the numbers you need to arrange in the 2n × 2n-sized matrix.\n\nOutputOn a single line print the maximum value of the beauty of the described matrix.Please, do not use the %lld specifier to read or write 64-bit integers in С++. It is preferred to use the cin, cout streams or the %I64d specifier.\n\nInputCopy113OutputCopy13InputCopy41 2 3 4OutputCopy14\n\nInputCopy113\n\nOutputCopy13\n\nInputCopy41 2 3 4\n\nOutputCopy14\n\nNoteConsider the second sample. You need to arrange the numbers in the matrix as follows:1 23 4Then the beauty of the matrix will equal: 4 + 1 + 2 + 3 + 4 = 14.",
      "solutions": [
        {
          "title": "Codeforces Round #186 (Div. 2) - Codeforces",
          "content": "Hello everyone!Codeforces Round #186 (Div. 2) will take place on Thursday, May 30th at 19:30 MSK. This is my first Codeforces Round and I hope that everyone will enjoy this round. I would like to thank Gerald for helping me prepare this round. Special thanks to Delinur for translation of all problem statements into English.Problems point values today is: 500-1000-1500-2500-2500 Good luck & have fun! :)",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/7803",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 405
        },
        {
          "title": "Analysis of Codeforces Round #186 (Div. 2) - Codeforces",
          "content": "313A - Ilya and Bank AccountThis problem is the easiest one. You need to use only div and mod functions. If n>0, then answer is n, else you need to delete one of two digits. For better understanding you can look at solution. 313B - Ilya and QueriesPrecalculate some array Ai, that Ai = 1, if si = si + 1, else Ai = 0. Now for any query (l, r), you need to find sum of Ai, that (l ≤ i < r). It is standart problem. For solving this problem you can precalcutate some another array Sum, where Sumi = A1 + A2 + ... + Ai. Then sum of interval (l, r) is Sum_r — Sum_{l-1}. For better understanding you can look at solution.313C - Ilya and MatrixAt the start sort array. Let Ci — number of times of entering the number in Aі optimal placement. Answer is sum of Ai * Ci for all i (1 ≤ i ≤ 4n). If we look at the array C, we can see that for maximal element C = n + 1 (for array with size 4n), then for second, third and fourth maximum elements C = n. On this basis we can see, that for array with non-increasing order answer calculate like Sum(1, 1) + Sum(1, 4) + Sum(1, 16) + ... + Sum(1, 4n). So, for solve this problem you have to know only sort. For better understanding you can look at solution313D - Ilya and Roads To solve this problem you need to use dynamic programming. Let Fulli, j — minimal cost of covering interval (i, j). Fix left border and move right. You can solve this subtask with complexity O(nm) or O(nmlogn). Now we need to solve the standart problem of dynamic programming. Cover K points with intervals that have not intersect. This problem with square dynamic. dpi, j — minimal cost of covering j-points, if you look some prefix length i. Answer for all problem is minimal integer from dpi, j, (k ≤ j ≤ n).To solve second part:1) dpi + 1, j = min(dpi + 1, j, dpi, j) — skip point with number i + 12) dpk, j + len = min(dpk, j + len, dpi, j + Cost); Cost — cost of interval with length len, that ending at point k. We precalculate Cost at first part of solution.For better understanding you can look at solution313E - Ilya and Two NumbersAuthor solution is harder than that which is offered by MrDindows. It is solution of MrDindows.1) Get the number of our sequences in sorted by frequencies. Thus from the first sequence (hereinafter — the first type) — in a direct order from the second — to the contrary.2) These numbers are put on the stack, where if, recording onto the stack of the second type, we find the number at the top of the first type, then this pair of extract and add to the answer.3) At the end, obviously the stack we can find a number of properties of the second type and the first bottom — on. Then their grouping in response pairs with the start and end.For better understanding you can look at solution.Sorry for waiting.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/7826",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 313\\s*C"
          },
          "content_length": 2761
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #186 (Div. 2) - Codeforces - Code 1",
          "code": "ios_base::sync_with_stdio(false)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7803",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #186 (Div. 2) - Codeforces - Code 2",
          "code": "Collections.shuffle",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7803",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #186 (Div. 2) - Codeforces - Code 3",
          "code": "Collections.shuffle",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7803",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #186 (Div. 2) - Codeforces - Code 4",
          "code": "Collections.sort",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7803",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #186 (Div. 2) - Codeforces - Code 5",
          "code": "for(int n = 1 ; n <= N ; n++){\nfor(int k = 1 ; k <= n ; k++){\nfor(int i = 0 ; i < f[n].size() ; i++){\nfor(int h = n ; h >= 0 ; h--){\n...",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7803",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #186 (Div. 2) - Codeforces - Code 6",
          "code": "for(int n = 1 ; n <= N ; n++){\nfor(int k = 1 ; k <= n ; k++){\nfor(int i = 0 ; i < f[n].size() ; i++){\nfor(int h = n ; h >= 0 ; h--){\n...",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7803",
          "author": "jiangly"
        },
        {
          "title": "Analysis of Codeforces Round #186 (Div. 2) - Codeforces - Code 1",
          "code": "dp[i,j] = min(dp[i,j], dp[k,j], 1 <= k < i",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7826",
          "author": "jiangly"
        },
        {
          "title": "Analysis of Codeforces Round #186 (Div. 2) - Codeforces - Code 2",
          "code": "dp[i][j] = min(dp[i][j], dp[i-1][j]);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7826",
          "author": "jiangly"
        },
        {
          "title": "Analysis of Codeforces Round #186 (Div. 2) - Codeforces - Code 3",
          "code": "0 <= a,b,c < m",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7826",
          "author": "jiangly"
        },
        {
          "title": "Analysis of Codeforces Round #186 (Div. 2) - Codeforces - Code 4",
          "code": "if (a + b >= m and c + b < m) (resp. c + a)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7826",
          "author": "jiangly"
        },
        {
          "title": "Analysis of Codeforces Round #186 (Div. 2) - Codeforces - Code 5",
          "code": "then (always) (c + b) % m >= (a + b) % m",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7826",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nbool isPowerOfFour(int x) {\n    if (x <= 0) return false;\n    if ((x & (x - 1)) != 0) return false; // Not a power of 2\n    int t = 0;\n    while (x > 1) {\n        x >>= 1;\n        t++;\n    }\n    return t % 2 == 0;\n}\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int k = inf.readInt(1, 2000000, \"k\");\n    inf.readEoln();\n    \n    ensuref(isPowerOfFour(k), \"k must be a power of 4\");\n\n    vector<int> a = inf.readInts(k, 1, 1000000000, \"a_i\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nbool isPowerOfFour(int x) {\n    if (x <= 0) return false;\n    if ((x & (x - 1)) != 0) return false; // Not a power of 2\n    int t = 0;\n    while (x > 1) {\n        x >>= 1;\n        t++;\n    }\n    return t % 2 == 0;\n}\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int k = inf.readInt(1, 2000000, \"k\");\n    inf.readEoln();\n    \n    ensuref(isPowerOfFour(k), \"k must be a power of 4\");\n\n    vector<int> a = inf.readInts(k, 1, 1000000000, \"a_i\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nbool isPowerOfFour(int x) {\n    if (x <= 0) return false;\n    if ((x & (x - 1)) != 0) return false; // Not a power of 2\n    int t = 0;\n    while (x > 1) {\n        x >>= 1;\n        t++;\n    }\n    return t % 2 == 0;\n}\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int k = inf.readInt(1, 2000000, \"k\");\n    inf.readEoln();\n    \n    ensuref(isPowerOfFour(k), \"k must be a power of 4\");\n\n    vector<int> a = inf.readInts(k, 1, 1000000000, \"a_i\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    \n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    // Calculate the size of the array: s = 4^n = 1 << (2 * n)\n    int s = 1 << (2 * n);\n\n    vector<int> a(s);\n\n    if (type == \"random\") {\n        // Generate random integers between 1 and 1e9\n        for(int i = 0; i < s; ++i)\n            a[i] = rnd.next(1, 1000000000);\n    } else if (type == \"same\") {\n        // Generate all elements with the same value\n        int value = opt<int>(\"value\", 1);\n        for(int i = 0; i < s; ++i)\n            a[i] = value;\n    } else if (type == \"ascending\") {\n        // Generate ascending sequence from 1 to 1e9\n        for(int i = 0; i < s; ++i)\n            a[i] = (int)((1LL * i * 1000000000) / s) + 1;\n    } else if (type == \"descending\") {\n        // Generate descending sequence from 1e9 to 1\n        for(int i = 0; i < s; ++i)\n            a[i] = (int)(1000000000 - (1LL * i * 1000000000) / s);\n    } else if (type == \"maxfirst\") {\n        // First half large numbers, second half small numbers\n        int k = s / 2;\n        for(int i = 0; i < s; ++i)\n            if (i < k)\n                a[i] = rnd.next(500000000, 1000000000);\n            else\n                a[i] = rnd.next(1, 500000000);\n    } else if (type == \"minfirst\") {\n        // First half small numbers, second half large numbers\n        int k = s / 2;\n        for(int i = 0; i < s; ++i)\n            if (i < k)\n                a[i] = rnd.next(1, 500000000);\n            else\n                a[i] = rnd.next(500000001, 1000000000);\n    } else {\n        // Default to random if unknown type\n        for(int i = 0; i < s; ++i)\n            a[i] = rnd.next(1, 1000000000);\n    }\n\n    // Output the size of the array\n    printf(\"%d\\n\", s);\n\n    // Output the array elements\n    for (int i = 0; i < s; ++i) {\n        printf(\"%d%c\", a[i], i + 1 == s ? '\\n' : ' ');\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    \n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    // Calculate the size of the array: s = 4^n = 1 << (2 * n)\n    int s = 1 << (2 * n);\n\n    vector<int> a(s);\n\n    if (type == \"random\") {\n        // Generate random integers between 1 and 1e9\n        for(int i = 0; i < s; ++i)\n            a[i] = rnd.next(1, 1000000000);\n    } else if (type == \"same\") {\n        // Generate all elements with the same value\n        int value = opt<int>(\"value\", 1);\n        for(int i = 0; i < s; ++i)\n            a[i] = value;\n    } else if (type == \"ascending\") {\n        // Generate ascending sequence from 1 to 1e9\n        for(int i = 0; i < s; ++i)\n            a[i] = (int)((1LL * i * 1000000000) / s) + 1;\n    } else if (type == \"descending\") {\n        // Generate descending sequence from 1e9 to 1\n        for(int i = 0; i < s; ++i)\n            a[i] = (int)(1000000000 - (1LL * i * 1000000000) / s);\n    } else if (type == \"maxfirst\") {\n        // First half large numbers, second half small numbers\n        int k = s / 2;\n        for(int i = 0; i < s; ++i)\n            if (i < k)\n                a[i] = rnd.next(500000000, 1000000000);\n            else\n                a[i] = rnd.next(1, 500000000);\n    } else if (type == \"minfirst\") {\n        // First half small numbers, second half large numbers\n        int k = s / 2;\n        for(int i = 0; i < s; ++i)\n            if (i < k)\n                a[i] = rnd.next(1, 500000000);\n            else\n                a[i] = rnd.next(500000001, 1000000000);\n    } else {\n        // Default to random if unknown type\n        for(int i = 0; i < s; ++i)\n            a[i] = rnd.next(1, 1000000000);\n    }\n\n    // Output the size of the array\n    printf(\"%d\\n\", s);\n\n    // Output the array elements\n    for (int i = 0; i < s; ++i) {\n        printf(\"%d%c\", a[i], i + 1 == s ? '\\n' : ' ');\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 0 -type random\n./gen -n 0 -type same -value 1\n./gen -n 0 -type same -value 1000000000\n\n./gen -n 1 -type random\n./gen -n 1 -type same -value 1\n./gen -n 1 -type same -value 1000000000\n\n./gen -n 2 -type random\n./gen -n 2 -type ascending\n./gen -n 2 -type descending\n./gen -n 2 -type same -value 1\n./gen -n 2 -type same -value 1000000000\n\n./gen -n 5 -type random\n./gen -n 5 -type ascending\n./gen -n 5 -type descending\n./gen -n 5 -type maxfirst\n./gen -n 5 -type minfirst\n./gen -n 5 -type same -value 1\n./gen -n 5 -type same -value 1000000000\n\n./gen -n 10 -type random\n./gen -n 10 -type ascending\n./gen -n 10 -type descending\n./gen -n 10 -type maxfirst\n./gen -n 10 -type minfirst\n./gen -n 10 -type same -value 1\n./gen -n 10 -type same -value 1000000000\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:06:43.297359",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "313/D",
      "title": "D. Илья и дороги",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест3 секунды",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеВ первой строке записаны три целых числа n, m, k (1 ≤ n ≤ 300, 1 ≤ m ≤ 105, 1 ≤ k ≤ n). В следующих m строках записано описание компаний. В i-той строке записаны три целых числа li, ri, ci (1 ≤ li ≤ ri ≤ n, 1 ≤ ci ≤ 109).",
      "output_spec": "Выходные данныеВыведите единственное целое число — минимальное количество денег, которое потребуется Илье, чтобы отремонтировать хотя бы k ям. Если отремонтировать хотя бы k ям невозможно, выведите -1.Пожалуйста, не используйте спецификатор %lld для чтения или записи 64-х битовых чисел на С++. Рекомендуется использовать потоки cin, cout или спецификатор %I64d.",
      "sample_tests": "ПримерыВходные данныеСкопировать10 4 67 9 116 9 137 7 73 5 6Выходные данныеСкопировать17Входные данныеСкопировать10 7 13 4 158 9 85 6 89 10 61 4 21 4 108 10 13Выходные данныеСкопировать2Входные данныеСкопировать10 1 95 10 14Выходные данныеСкопировать-1",
      "description": "D. Илья и дороги\n\nограничение по времени на тест3 секунды\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвыводstdout\n\nВходные данныеВ первой строке записаны три целых числа n, m, k (1 ≤ n ≤ 300, 1 ≤ m ≤ 105, 1 ≤ k ≤ n). В следующих m строках записано описание компаний. В i-той строке записаны три целых числа li, ri, ci (1 ≤ li ≤ ri ≤ n, 1 ≤ ci ≤ 109).\n\nВходные данные\n\nВыходные данныеВыведите единственное целое число — минимальное количество денег, которое потребуется Илье, чтобы отремонтировать хотя бы k ям. Если отремонтировать хотя бы k ям невозможно, выведите -1.Пожалуйста, не используйте спецификатор %lld для чтения или записи 64-х битовых чисел на С++. Рекомендуется использовать потоки cin, cout или спецификатор %I64d.\n\nВыходные данные\n\nВходные данныеСкопировать10 4 67 9 116 9 137 7 73 5 6Выходные данныеСкопировать17Входные данныеСкопировать10 7 13 4 158 9 85 6 89 10 61 4 21 4 108 10 13Выходные данныеСкопировать2Входные данныеСкопировать10 1 95 10 14Выходные данныеСкопировать-1\n\nВходные данныеСкопировать10 4 67 9 116 9 137 7 73 5 6\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать17\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать10 7 13 4 158 9 85 6 89 10 61 4 21 4 108 10 13\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать2\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать10 1 95 10 14\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать-1\n\nВыходные данныеСкопировать\n\nСкопировать",
      "solutions": [
        {
          "title": "Codeforces Round #186 (Div. 2) - Codeforces",
          "content": "Всем привет!В ближайший четверг 30 мая в 19:30 MSK пройдет Codeforces Round #186 (Div. 2), автором которого являюсь я. Это мой первый раунд на Codeforces и я надеюсь что все получат удовольствие от решения задач на нём.Спасибо Геральду Агапову (Gerald) за огромную помощь в подготовке раунда и Марии Беловой (Delinur) за перевод условий на английский. Также, хочется поблагодарить Ваню Здомского (ballon), за то что он протестировал раунд. Разбалловка сегодня такая: 500-1000-1500-2500-2500Good luck & have fun! :)",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/7803",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 514
        },
        {
          "title": "Разбор задач Codeforces Round #186 (Div. 2) - Codeforces",
          "content": "313A - Илья и банковский счетВ данной задаче не было ничего сложного. Нужно было уметь пользоваться div и mod. Понятно, что если n>0, то нет смысла удалят цифру. А иначе, нужно удалять.Для лучшего понимая посмотрите решение313B - Илья и запросы Предпосчитаем такой масив Ai, что Ai = 1, если si = si + 1, иначе Ai = 0. Теперь не сложно заметить, что ответом на запрос будет SumA, l, r - 1. Данную функцию можно организовать множеством вариантов. Одним из, является дерево отрезков. Но так как запросы можно выполнять в оффлайн, то можно использовать массив частичных сумм. Пусть Sumi – это сумма всех Aj, (j ≤ i). Тогда, что бы найти сумму на отрезке (l, r - 1) – нужно Sumr - 1 - Suml - 1. Для лучшего понимая посмотрите решение.313C - Илья и матрицаДля начала отсортируем массив. Пусть Сi –-- это количество раз вхождения числа Аі в оптимальную расстановку. Понятно, что ответом будет сумма всех чисел Ai*Ci (1 ≤ i ≤ 4n). Теперь нужно заметить, что максимальный элемент будет входить n + 1 раз. (Если размер массива равен 4n). Следующие 3 числа, будут входить в ответ n раз, еще следующие 12 уже n - 1. И так далее. Представим, что массив отсортирован по не возрастанию. Не сложно заметить, что ответом будет Sum(1, 1) + Sum(1, 4) + Sum(1, 16)… + Sum(1, 4n). Сумму на отрезках можно реализовывать в лоб, так как это позволяли ограничения. Для лучшего понимая посмотрите решение.313D - Илья и дороги Для того что бы решить эту задачу нужно было разбить её на две более легкие. Пусть Fulli, j – минимальная стоимость покрыть заданными отрезками, отрезок (i, j). Для того что бы подсчитать эту величину, для всех (i, j) нужно перебрать левую границу отрезка і, и двигать правую. Решение данной подзадачи имеет сложность О(nm). Теперь нам нужно решить вторую подзадачу. Вторая подзадача звучит так: покрыть не менее К точек, отрезками которые не пересекаются (Их стоимости мы знаем, так как мы решили первую подзадачу). Для её решения нужно использовать тот же метод динамического программирования, который намного проще чем решение первой подзадачи. Пусть dpi, j — минимальная стоимость покрыть j точек, если мы просмотрели только префикс длинной i. Из состояния (i, j) мы можем перейти в такие состояния:1) dpi + 1, j = min(dpi + 1, j, dpi, j); Скажем, что мы не будем покрывать точку с номером i + 12) dpk, j + len = min(dpk, j + len, dpi, j + Cost); Cost — стоимость покрытия отрезка длинной len, который заканчивается в точке k. Значение Cost мы предпосчитали в первой подзадаче. Для лучшего понимая посмотрите решение313E - Илья и два числа Для решения данной задачи нужно уметь использовать кучу и дерево интервалов. Заметим, что если мы берем цифру і с первого числа, и цифру j со второго, то в третьей будет цифра ((i + j)mod m). На каждом шагу из всех таких пар выбирается максимум. Ответ мы выводим на экран, а те две цифры, что мы использовали, нужно удалить. Для решения уже новой задачи, можно завести кучу, в которой изначально будет N значений. Для каждой цифры из первого множества, та цифра из второго которая будет самым оптимальным для ответа. То есть (i1 + i2)mod m = MAX. Но когда мы используем какую-то пару, возможно распадется другая пара. Для того что бы быстро строить новые пары, нужно использовать дерево интервалов для поиска К-го элемента. Для лучшего понимая посмотрите решениеТакже, существует более простое и понятное решение, которое описал MrDindows. Решение MrDindowsИзвините за ожидание.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/7826",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 313\\s*D"
          },
          "content_length": 3423
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #186 (Div. 2) - Codeforces - Code 1",
          "code": "ios_base::sync_with_stdio(false)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7803",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #186 (Div. 2) - Codeforces - Code 2",
          "code": "Collections.shuffle",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7803",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #186 (Div. 2) - Codeforces - Code 3",
          "code": "Collections.shuffle",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7803",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #186 (Div. 2) - Codeforces - Code 4",
          "code": "Collections.sort",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7803",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #186 (Div. 2) - Codeforces - Code 5",
          "code": "for(int n = 1 ; n <= N ; n++){\nfor(int k = 1 ; k <= n ; k++){\nfor(int i = 0 ; i < f[n].size() ; i++){\nfor(int h = n ; h >= 0 ; h--){\n...",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7803",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #186 (Div. 2) - Codeforces - Code 6",
          "code": "for(int n = 1 ; n <= N ; n++){\nfor(int k = 1 ; k <= n ; k++){\nfor(int i = 0 ; i < f[n].size() ; i++){\nfor(int h = n ; h >= 0 ; h--){\n...",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7803",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Codeforces Round #186 (Div. 2) - Codeforces - Code 1",
          "code": "dp[i][j] = min(dp[i][j],dp[i - 1][j])",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7826",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Codeforces Round #186 (Div. 2) - Codeforces - Code 2",
          "code": "dp[r - 1][j - (i - r + 1)], k <= r && r <= i",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7826",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Codeforces Round #186 (Div. 2) - Codeforces - Code 3",
          "code": "dp[k - 1][j - (i - k + 1)]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7826",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Codeforces Round #186 (Div. 2) - Codeforces - Code 4",
          "code": "dp[i,j] = min(dp[i,j], dp[k,j], 1 <= k < i",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7826",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Codeforces Round #186 (Div. 2) - Codeforces - Code 5",
          "code": "dp[i][j] = min(dp[i][j], dp[i-1][j]);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7826",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Codeforces Round #186 (Div. 2) - Codeforces - Code 6",
          "code": "0 <= a,b,c < m",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7826",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Codeforces Round #186 (Div. 2) - Codeforces - Code 7",
          "code": "if (a + b >= m and c + b < m) (resp. c + a)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7826",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Codeforces Round #186 (Div. 2) - Codeforces - Code 8",
          "code": "then (always) (c + b) % m >= (a + b) % m",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7826",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 300, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 100000, \"m\");\n    inf.readSpace();\n    int k = inf.readInt(1, n, \"k\");\n    inf.readEoln();\n\n    for (int i = 0; i < m; ++i) {\n        int li = inf.readInt(1, n, \"li\");\n        inf.readSpace();\n        int ri = inf.readInt(li, n, \"ri\");\n        inf.readSpace();\n        int ci = inf.readInt(1, 1000000000, \"ci\");\n        inf.readEoln();\n    }\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 300, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 100000, \"m\");\n    inf.readSpace();\n    int k = inf.readInt(1, n, \"k\");\n    inf.readEoln();\n\n    for (int i = 0; i < m; ++i) {\n        int li = inf.readInt(1, n, \"li\");\n        inf.readSpace();\n        int ri = inf.readInt(li, n, \"ri\");\n        inf.readSpace();\n        int ci = inf.readInt(1, 1000000000, \"ci\");\n        inf.readEoln();\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 300, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 100000, \"m\");\n    inf.readSpace();\n    int k = inf.readInt(1, n, \"k\");\n    inf.readEoln();\n\n    for (int i = 0; i < m; ++i) {\n        int li = inf.readInt(1, n, \"li\");\n        inf.readSpace();\n        int ri = inf.readInt(li, n, \"ri\");\n        inf.readSpace();\n        int ci = inf.readInt(1, 1000000000, \"ci\");\n        inf.readEoln();\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    int k = opt<int>(\"k\");\n    string test_type = opt<string>(\"type\", \"random\");\n\n    vector<int> holeCovered(n+1, 0); // holes covered count\n    vector<pair<pair<int,int>, int>> companies;\n\n    if (test_type == \"random\") {\n        // Random test case\n        for (int i = 0; i < m; i++) {\n            int l = rnd.next(1, n);\n            int r = rnd.next(1, n);\n            if (l > r) swap(l, r);\n            int c = rnd.next(1, 1000000000);\n            companies.push_back({{l,r}, c});\n        }\n    } else if (test_type == \"impossible\") {\n        // Generate companies covering less than k holes\n        int total_covered = 0;\n        for (int i = 0; i < m; i++) {\n            int l = rnd.next(1, n);\n            int r = rnd.next(l, min(l + 1, n)); // small segments\n            int c = rnd.next(1, 1000000000);\n            companies.push_back({{l,r}, c});\n            // Update holeCovered\n            for (int h = l; h <= r; h++) {\n                if (holeCovered[h] == 0) {\n                    holeCovered[h] = 1;\n                    total_covered++;\n                }\n            }\n            if (total_covered >= k) {\n                // Remove last company to ensure total_covered < k\n                for (int h = l; h <= r; h++) {\n                    holeCovered[h] = 0;\n                    total_covered--;\n                }\n                companies.pop_back();\n                break;\n            }\n        }\n        m = companies.size();\n    } else if (test_type == \"single_company\") {\n        // Generate a company that can fix at least k holes\n        if (k > n) {\n            fprintf(stderr, \"k cannot be greater than n in single_company type\\n\");\n            return 1;\n        }\n        int l = rnd.next(1, n - k + 1);\n        int r = l + k - 1;\n        int c = rnd.next(1, 1000000000);\n        companies.push_back({{l,r}, c});\n        m = 1;\n    } else if (test_type == \"overlapping\") {\n        // Generate companies with overlapping segments\n        for (int i = 0; i < m; i++) {\n            int l = rnd.next(1, n / 2);\n            int r = rnd.next(n / 2, n);\n            if (l > r) swap(l, r);\n            int c = rnd.next(1, 1000000000);\n            companies.push_back({{l,r}, c});\n        }\n    } else {\n        fprintf(stderr, \"Unknown test type: %s\", test_type.c_str());\n        return 1;\n    }\n\n    // Output n m k\n    printf(\"%d %d %d\\n\", n, (int)companies.size(), k);\n    for (auto &comp : companies) {\n        printf(\"%d %d %d\\n\", comp.first.first, comp.first.second, comp.second);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    int k = opt<int>(\"k\");\n    string test_type = opt<string>(\"type\", \"random\");\n\n    vector<int> holeCovered(n+1, 0); // holes covered count\n    vector<pair<pair<int,int>, int>> companies;\n\n    if (test_type == \"random\") {\n        // Random test case\n        for (int i = 0; i < m; i++) {\n            int l = rnd.next(1, n);\n            int r = rnd.next(1, n);\n            if (l > r) swap(l, r);\n            int c = rnd.next(1, 1000000000);\n            companies.push_back({{l,r}, c});\n        }\n    } else if (test_type == \"impossible\") {\n        // Generate companies covering less than k holes\n        int total_covered = 0;\n        for (int i = 0; i < m; i++) {\n            int l = rnd.next(1, n);\n            int r = rnd.next(l, min(l + 1, n)); // small segments\n            int c = rnd.next(1, 1000000000);\n            companies.push_back({{l,r}, c});\n            // Update holeCovered\n            for (int h = l; h <= r; h++) {\n                if (holeCovered[h] == 0) {\n                    holeCovered[h] = 1;\n                    total_covered++;\n                }\n            }\n            if (total_covered >= k) {\n                // Remove last company to ensure total_covered < k\n                for (int h = l; h <= r; h++) {\n                    holeCovered[h] = 0;\n                    total_covered--;\n                }\n                companies.pop_back();\n                break;\n            }\n        }\n        m = companies.size();\n    } else if (test_type == \"single_company\") {\n        // Generate a company that can fix at least k holes\n        if (k > n) {\n            fprintf(stderr, \"k cannot be greater than n in single_company type\\n\");\n            return 1;\n        }\n        int l = rnd.next(1, n - k + 1);\n        int r = l + k - 1;\n        int c = rnd.next(1, 1000000000);\n        companies.push_back({{l,r}, c});\n        m = 1;\n    } else if (test_type == \"overlapping\") {\n        // Generate companies with overlapping segments\n        for (int i = 0; i < m; i++) {\n            int l = rnd.next(1, n / 2);\n            int r = rnd.next(n / 2, n);\n            if (l > r) swap(l, r);\n            int c = rnd.next(1, 1000000000);\n            companies.push_back({{l,r}, c});\n        }\n    } else {\n        fprintf(stderr, \"Unknown test type: %s\", test_type.c_str());\n        return 1;\n    }\n\n    // Output n m k\n    printf(\"%d %d %d\\n\", n, (int)companies.size(), k);\n    for (auto &comp : companies) {\n        printf(\"%d %d %d\\n\", comp.first.first, comp.first.second, comp.second);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 10 -m 5 -k 5 -type random\n./gen -n 10 -m 10 -k 5 -type random\n./gen -n 100 -m 1000 -k 50 -type random\n./gen -n 300 -m 100000 -k 150 -type random\n\n./gen -n 10 -m 5 -k 11 -type impossible\n./gen -n 50 -m 100 -k 60 -type impossible\n./gen -n 300 -m 1000 -k 301 -type impossible\n\n./gen -n 10 -m 5 -k 3 -type single_company\n./gen -n 50 -m 1 -k 50 -type single_company\n./gen -n 300 -m 1 -k 150 -type single_company\n\n./gen -n 10 -m 10 -k 5 -type overlapping\n./gen -n 100 -m 1000 -k 50 -type overlapping\n./gen -n 300 -m 100000 -k 200 -type overlapping\n\n./gen -n 300 -m 100000 -k 1 -type random\n./gen -n 300 -m 100000 -k 300 -type random\n./gen -n 300 -m 100000 -k 150 -type random\n\n./gen -n 1 -m 1 -k 1 -type random\n\n./gen -n 2 -m 1 -k 2 -type impossible\n\n./gen -n 300 -m 0 -k 1 -type random\n\n./gen -n 1 -m 1 -k 2 -type impossible\n\n./gen -n 300 -m 100000 -k 299 -type overlapping\n\n./gen -n 299 -m 99999 -k 298 -type overlapping\n\n./gen -n 300 -m 100000 -k 300 -type single_company\n\n./gen -n 300 -m 50000 -k 100 -type random\n\n./gen -n 10 -m 1 -k 10 -type single_company\n\n./gen -n 300 -m 100000 -k 300 -type overlapping\n\n./gen -n 100 -m 100000 -k 50 -type random\n\n./gen -n 300 -m 100000 -k 0 -type random\n\n./gen -n 300 -m 100000 -k 1 -type impossible\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:06:45.227834",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "313/E",
      "title": "E. Илья и два числа",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест2 секунды",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеВ первой строке записано два целых числа n, m (1 ≤ n, m ≤ 105, m > 1). Во второй строке записано первое найденное число, в третьей строке записано второе найденное число. Числа записываются как последовательность цифр в системе счисления по основанию m. Каждая цифра — это целое число от 0 до m - 1. Цифры в строке записаны в порядке от старших разрядов к младшим.Заданные числа могут содержать лидирующие нули.",
      "output_spec": "Выходные данныеВыведите n цифр в системе счисления по основанию m — полученное третье число. Цифры выводите в порядке от старших разрядов к младшим.",
      "sample_tests": "ПримерыВходные данныеСкопировать4 75 4 3 25 6 5 4Выходные данныеСкопировать6 4 2 1 Входные данныеСкопировать5 52 4 4 1 31 0 1 2 4Выходные данныеСкопировать4 4 4 3 2",
      "description": "E. Илья и два числа\n\nограничение по времени на тест2 секунды\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвыводstdout\n\nВходные данныеВ первой строке записано два целых числа n, m (1 ≤ n, m ≤ 105, m > 1). Во второй строке записано первое найденное число, в третьей строке записано второе найденное число. Числа записываются как последовательность цифр в системе счисления по основанию m. Каждая цифра — это целое число от 0 до m - 1. Цифры в строке записаны в порядке от старших разрядов к младшим.Заданные числа могут содержать лидирующие нули.\n\nВходные данные\n\nВыходные данныеВыведите n цифр в системе счисления по основанию m — полученное третье число. Цифры выводите в порядке от старших разрядов к младшим.\n\nВыходные данные\n\nВходные данныеСкопировать4 75 4 3 25 6 5 4Выходные данныеСкопировать6 4 2 1 Входные данныеСкопировать5 52 4 4 1 31 0 1 2 4Выходные данныеСкопировать4 4 4 3 2\n\nВходные данныеСкопировать4 75 4 3 25 6 5 4\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать6 4 2 1\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать5 52 4 4 1 31 0 1 2 4\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать4 4 4 3 2\n\nВыходные данныеСкопировать\n\nСкопировать",
      "solutions": [
        {
          "title": "Codeforces Round #186 (Div. 2) - Codeforces",
          "content": "Всем привет!В ближайший четверг 30 мая в 19:30 MSK пройдет Codeforces Round #186 (Div. 2), автором которого являюсь я. Это мой первый раунд на Codeforces и я надеюсь что все получат удовольствие от решения задач на нём.Спасибо Геральду Агапову (Gerald) за огромную помощь в подготовке раунда и Марии Беловой (Delinur) за перевод условий на английский. Также, хочется поблагодарить Ваню Здомского (ballon), за то что он протестировал раунд. Разбалловка сегодня такая: 500-1000-1500-2500-2500Good luck & have fun! :)",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/7803",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 514
        },
        {
          "title": "Разбор задач Codeforces Round #186 (Div. 2) - Codeforces",
          "content": "313A - Илья и банковский счетВ данной задаче не было ничего сложного. Нужно было уметь пользоваться div и mod. Понятно, что если n>0, то нет смысла удалят цифру. А иначе, нужно удалять.Для лучшего понимая посмотрите решение313B - Илья и запросы Предпосчитаем такой масив Ai, что Ai = 1, если si = si + 1, иначе Ai = 0. Теперь не сложно заметить, что ответом на запрос будет SumA, l, r - 1. Данную функцию можно организовать множеством вариантов. Одним из, является дерево отрезков. Но так как запросы можно выполнять в оффлайн, то можно использовать массив частичных сумм. Пусть Sumi – это сумма всех Aj, (j ≤ i). Тогда, что бы найти сумму на отрезке (l, r - 1) – нужно Sumr - 1 - Suml - 1. Для лучшего понимая посмотрите решение.313C - Илья и матрицаДля начала отсортируем массив. Пусть Сi –-- это количество раз вхождения числа Аі в оптимальную расстановку. Понятно, что ответом будет сумма всех чисел Ai*Ci (1 ≤ i ≤ 4n). Теперь нужно заметить, что максимальный элемент будет входить n + 1 раз. (Если размер массива равен 4n). Следующие 3 числа, будут входить в ответ n раз, еще следующие 12 уже n - 1. И так далее. Представим, что массив отсортирован по не возрастанию. Не сложно заметить, что ответом будет Sum(1, 1) + Sum(1, 4) + Sum(1, 16)… + Sum(1, 4n). Сумму на отрезках можно реализовывать в лоб, так как это позволяли ограничения. Для лучшего понимая посмотрите решение.313D - Илья и дороги Для того что бы решить эту задачу нужно было разбить её на две более легкие. Пусть Fulli, j – минимальная стоимость покрыть заданными отрезками, отрезок (i, j). Для того что бы подсчитать эту величину, для всех (i, j) нужно перебрать левую границу отрезка і, и двигать правую. Решение данной подзадачи имеет сложность О(nm). Теперь нам нужно решить вторую подзадачу. Вторая подзадача звучит так: покрыть не менее К точек, отрезками которые не пересекаются (Их стоимости мы знаем, так как мы решили первую подзадачу). Для её решения нужно использовать тот же метод динамического программирования, который намного проще чем решение первой подзадачи. Пусть dpi, j — минимальная стоимость покрыть j точек, если мы просмотрели только префикс длинной i. Из состояния (i, j) мы можем перейти в такие состояния:1) dpi + 1, j = min(dpi + 1, j, dpi, j); Скажем, что мы не будем покрывать точку с номером i + 12) dpk, j + len = min(dpk, j + len, dpi, j + Cost); Cost — стоимость покрытия отрезка длинной len, который заканчивается в точке k. Значение Cost мы предпосчитали в первой подзадаче. Для лучшего понимая посмотрите решение313E - Илья и два числа Для решения данной задачи нужно уметь использовать кучу и дерево интервалов. Заметим, что если мы берем цифру і с первого числа, и цифру j со второго, то в третьей будет цифра ((i + j)mod m). На каждом шагу из всех таких пар выбирается максимум. Ответ мы выводим на экран, а те две цифры, что мы использовали, нужно удалить. Для решения уже новой задачи, можно завести кучу, в которой изначально будет N значений. Для каждой цифры из первого множества, та цифра из второго которая будет самым оптимальным для ответа. То есть (i1 + i2)mod m = MAX. Но когда мы используем какую-то пару, возможно распадется другая пара. Для того что бы быстро строить новые пары, нужно использовать дерево интервалов для поиска К-го элемента. Для лучшего понимая посмотрите решениеТакже, существует более простое и понятное решение, которое описал MrDindows. Решение MrDindowsИзвините за ожидание.",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/7826",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 313\\s*E"
          },
          "content_length": 3423
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #186 (Div. 2) - Codeforces - Code 1",
          "code": "ios_base::sync_with_stdio(false)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7803",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #186 (Div. 2) - Codeforces - Code 2",
          "code": "Collections.shuffle",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7803",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #186 (Div. 2) - Codeforces - Code 3",
          "code": "Collections.shuffle",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7803",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #186 (Div. 2) - Codeforces - Code 4",
          "code": "Collections.sort",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7803",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #186 (Div. 2) - Codeforces - Code 5",
          "code": "for(int n = 1 ; n <= N ; n++){\nfor(int k = 1 ; k <= n ; k++){\nfor(int i = 0 ; i < f[n].size() ; i++){\nfor(int h = n ; h >= 0 ; h--){\n...",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7803",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #186 (Div. 2) - Codeforces - Code 6",
          "code": "for(int n = 1 ; n <= N ; n++){\nfor(int k = 1 ; k <= n ; k++){\nfor(int i = 0 ; i < f[n].size() ; i++){\nfor(int h = n ; h >= 0 ; h--){\n...",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7803",
          "author": "Qingyu"
        },
        {
          "title": "Разбор задач Codeforces Round #186 (Div. 2) - Codeforces - Code 1",
          "code": "dp[i][j] = min(dp[i][j],dp[i - 1][j])",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7826",
          "author": "Qingyu"
        },
        {
          "title": "Разбор задач Codeforces Round #186 (Div. 2) - Codeforces - Code 2",
          "code": "dp[r - 1][j - (i - r + 1)], k <= r && r <= i",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7826",
          "author": "Qingyu"
        },
        {
          "title": "Разбор задач Codeforces Round #186 (Div. 2) - Codeforces - Code 3",
          "code": "dp[k - 1][j - (i - k + 1)]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7826",
          "author": "Qingyu"
        },
        {
          "title": "Разбор задач Codeforces Round #186 (Div. 2) - Codeforces - Code 4",
          "code": "dp[i,j] = min(dp[i,j], dp[k,j], 1 <= k < i",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7826",
          "author": "Qingyu"
        },
        {
          "title": "Разбор задач Codeforces Round #186 (Div. 2) - Codeforces - Code 5",
          "code": "dp[i][j] = min(dp[i][j], dp[i-1][j]);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7826",
          "author": "Qingyu"
        },
        {
          "title": "Разбор задач Codeforces Round #186 (Div. 2) - Codeforces - Code 6",
          "code": "0 <= a,b,c < m",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7826",
          "author": "Qingyu"
        },
        {
          "title": "Разбор задач Codeforces Round #186 (Div. 2) - Codeforces - Code 7",
          "code": "if (a + b >= m and c + b < m) (resp. c + a)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7826",
          "author": "Qingyu"
        },
        {
          "title": "Разбор задач Codeforces Round #186 (Div. 2) - Codeforces - Code 8",
          "code": "then (always) (c + b) % m >= (a + b) % m",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7826",
          "author": "Qingyu"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(2, 100000, \"m\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, 0, m - 1);\n    inf.readEoln();\n\n    vector<int> b = inf.readInts(n, 0, m - 1);\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(2, 100000, \"m\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, 0, m - 1);\n    inf.readEoln();\n\n    vector<int> b = inf.readInts(n, 0, m - 1);\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(2, 100000, \"m\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, 0, m - 1);\n    inf.readEoln();\n\n    vector<int> b = inf.readInts(n, 0, m - 1);\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string type = opt<string>(\"type\", \"random\");\n\n    cout << n << \" \" << m << \"\\n\";\n\n    vector<int> a(n), b(n);\n\n    if (type == \"random\") {\n        for(int i = 0; i < n; ++i) {\n            a[i] = rnd.next(0, m - 1);\n            b[i] = rnd.next(0, m - 1);\n        }\n    } else if (type == \"allzeros\") {\n        a.assign(n, 0);\n        b.assign(n, 0);\n    } else if (type == \"allmax\") {\n        a.assign(n, m - 1);\n        b.assign(n, m - 1);\n    } else if (type == \"leadingzeros\") {\n        int k = rnd.next(1, n);\n        a.assign(n, 0);\n        b.assign(n, 0);\n        for(int i = k; i < n; ++i) {\n            a[i] = rnd.next(0, m - 1);\n            b[i] = rnd.next(0, m - 1);\n        }\n    } else if (type == \"edgecase\") {\n        for(int i = 0; i < n; ++i) {\n            a[i] = m - 1 - (i % m);\n            b[i] = i % m;\n        }\n    } else if (type == \"small_m\") {\n        m = rnd.next(2, 10);\n        for(int i = 0; i < n; ++i) {\n            a[i] = rnd.next(0, m - 1);\n            b[i] = (m - 1 - a[i]) % m;\n        }\n    } else {\n        for(int i = 0; i < n; ++i) {\n            a[i] = rnd.next(0, m - 1);\n            b[i] = rnd.next(0, m - 1);\n        }\n    }\n\n    for(int i = 0; i < n; ++i) {\n        cout << a[i];\n        if (i + 1 < n)\n            cout << \" \";\n    }\n    cout << \"\\n\";\n    for(int i = 0; i < n; ++i) {\n        cout << b[i];\n        if (i + 1 < n)\n            cout << \" \";\n    }\n    cout << \"\\n\";\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string type = opt<string>(\"type\", \"random\");\n\n    cout << n << \" \" << m << \"\\n\";\n\n    vector<int> a(n), b(n);\n\n    if (type == \"random\") {\n        for(int i = 0; i < n; ++i) {\n            a[i] = rnd.next(0, m - 1);\n            b[i] = rnd.next(0, m - 1);\n        }\n    } else if (type == \"allzeros\") {\n        a.assign(n, 0);\n        b.assign(n, 0);\n    } else if (type == \"allmax\") {\n        a.assign(n, m - 1);\n        b.assign(n, m - 1);\n    } else if (type == \"leadingzeros\") {\n        int k = rnd.next(1, n);\n        a.assign(n, 0);\n        b.assign(n, 0);\n        for(int i = k; i < n; ++i) {\n            a[i] = rnd.next(0, m - 1);\n            b[i] = rnd.next(0, m - 1);\n        }\n    } else if (type == \"edgecase\") {\n        for(int i = 0; i < n; ++i) {\n            a[i] = m - 1 - (i % m);\n            b[i] = i % m;\n        }\n    } else if (type == \"small_m\") {\n        m = rnd.next(2, 10);\n        for(int i = 0; i < n; ++i) {\n            a[i] = rnd.next(0, m - 1);\n            b[i] = (m - 1 - a[i]) % m;\n        }\n    } else {\n        for(int i = 0; i < n; ++i) {\n            a[i] = rnd.next(0, m - 1);\n            b[i] = rnd.next(0, m - 1);\n        }\n    }\n\n    for(int i = 0; i < n; ++i) {\n        cout << a[i];\n        if (i + 1 < n)\n            cout << \" \";\n    }\n    cout << \"\\n\";\n    for(int i = 0; i < n; ++i) {\n        cout << b[i];\n        if (i + 1 < n)\n            cout << \" \";\n    }\n    cout << \"\\n\";\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -m 2 -type random\n./gen -n 1 -m 100000 -type random\n./gen -n 100000 -m 2 -type random\n./gen -n 100000 -m 100000 -type random\n\n./gen -n 100 -m 10 -type random\n./gen -n 100 -m 10 -type allzeros\n./gen -n 100 -m 10 -type allmax\n./gen -n 100 -m 10 -type leadingzeros\n./gen -n 100 -m 10 -type edgecase\n\n./gen -n 1000 -m 10000 -type random\n./gen -n 1000 -m 10000 -type allzeros\n./gen -n 1000 -m 10000 -type allmax\n./gen -n 1000 -m 10000 -type leadingzeros\n./gen -n 1000 -m 10000 -type edgecase\n\n./gen -n 100000 -m 100000 -type random\n./gen -n 100000 -m 100000 -type allzeros\n./gen -n 100000 -m 100000 -type allmax\n./gen -n 100000 -m 100000 -type leadingzeros\n./gen -n 100000 -m 100000 -type edgecase\n\n./gen -n 100000 -m 2 -type random\n./gen -n 100000 -m 2 -type edgecase\n./gen -n 100000 -m 2 -type small_m\n\n./gen -n 1 -m 100000 -type random\n./gen -n 2 -m 100000 -type random\n\n./gen -n 100000 -m 100000 -type random\n./gen -n 100000 -m 100000 -type leadingzeros\n\n./gen -n 100000 -m 3 -type edgecase\n./gen -n 100000 -m 2 -type small_m\n./gen -n 100000 -m 5 -type small_m\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:06:47.029157",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "314/A",
      "title": "A. Сережа и контест",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест2 секунды",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеВ первой строке заданы два целых числа n, k (1 ≤ n ≤ 2·105,  - 109 ≤ k ≤ 0). Во второй строке задано n целых чисел через пробел a1, a2, ..., an (1 ≤ ai ≤ 109) — рейтинги участников соревнования, в порядке их расположения в первоначальной таблице результатов.",
      "output_spec": "Выходные данныеВыведите номера участников, в том порядке, в котором они были удалены из таблицы. Выводите изначальные номера участников, то есть те, которые они имели в изначальной таблице.",
      "sample_tests": "ПримерыВходные данныеСкопировать5 05 3 4 1 2Выходные данныеСкопировать234Входные данныеСкопировать10 -105 5 1 7 5 1 2 4 9 2Выходные данныеСкопировать245789",
      "description": "A. Сережа и контест\n\nограничение по времени на тест2 секунды\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвыводstdout\n\nВходные данныеВ первой строке заданы два целых числа n, k (1 ≤ n ≤ 2·105,  - 109 ≤ k ≤ 0). Во второй строке задано n целых чисел через пробел a1, a2, ..., an (1 ≤ ai ≤ 109) — рейтинги участников соревнования, в порядке их расположения в первоначальной таблице результатов.\n\nВходные данные\n\nВыходные данныеВыведите номера участников, в том порядке, в котором они были удалены из таблицы. Выводите изначальные номера участников, то есть те, которые они имели в изначальной таблице.\n\nВыходные данные\n\nВходные данныеСкопировать5 05 3 4 1 2Выходные данныеСкопировать234Входные данныеСкопировать10 -105 5 1 7 5 1 2 4 9 2Выходные данныеСкопировать245789\n\nВходные данныеСкопировать5 05 3 4 1 2\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать234\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать10 -105 5 1 7 5 1 2 4 9 2\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать245789\n\nВыходные данныеСкопировать\n\nСкопировать\n\nПримечаниеРассмотрим первый тестовый пример.  Первоначально последовательность рейтингов участников соревнования равна [5, 3, 4, 1, 2]. По этой последовательности можно посчитать последовательность изменений рейтинга: [0, -9, -13, 8, 14]. По условию задачи первым будет выполнена заявка участника, занявшего второе место. После того, как участник на втором месте будет исключен из рейтинга, последовательность рейтингов участников соревнования будет равна [5, 4, 1, 2]. По этой последовательности можно посчитать новую последовательность изменений рейтинга: [0, -8, 2, 6]. По условию задачи будет выполнена заявка участника, занявшего второе место. В первоначальной таблице этот участник занимал третье место. Новая последовательность рейтингов равна [5, 1, 2], новая последовательность изменений рейтингов равна [0, -1, 1]. Будет выполнена заявка участника на втором месте, первоначально этот участник занимал четвертое место. Новая последовательность рейтингов [5, 2]. Новая последовательность изменений рейтингов [0, 0]. Больше никакие заявки не будут выполнены. Таким образом, нужно вывести 2, 3, 4.",
      "solutions": [
        {
          "title": "Codeforces Round #187 - Codeforces",
          "content": "Всем привет!Совсем скоро, 7 июня в 19:30 MSK состоится Codeforces Round #187, автором которого являюсь я. Это мой седьмой раунд на Codeforces и я надеюсь, что не последний.Спасибо Геральду Агапову (Gerald), Роману Фурко(Furko) и Аксенову Виталику(Aksenov239) за помощь в подготовке раунда и Марии Беловой (Delinur) за перевод условий на английский.Настоятельно рекомендую прочитать условия ВСЕХ задач.Gl & hf ! :)Разбор.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/7894",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 420
        },
        {
          "title": "Разбор Codeforces Round #187 - Codeforces",
          "content": "315A - Сережа и бутылкиПросто для каждой бутылки проверим, можно ли открыть ее другой. В данной задаче проходили абсолютно любые решения. 315B - Сережа и массивБудем поддерживать все элементы в массиве, но дополнительно заведем переменную add: сколько нужно добавить ко всем элементам. Тогда про добавлении ко всем элементам просто увеличим add. При выводе будем выводить элемент массива + величину add. При обновлении будем ставить элемент равным значению, которое нужно поставить минус текущая величина add. 314A - Сережа и контестЗаметим, что если мы удалили некоторого участника, то мы никогда не удалим участников с меньшими номерами, так как их сумма будет только увеличиваться. Поэтому просто последовательно рассмотрим всех участников, и если участник не подходит, то удалим его. 314B - Сережа и периодыПонятно, что можно жадно искать количество вхождений 2й строки в первой, но такое решение работает долго. Для ускорения процесса можно искать в первой строке строку, которая задает период второй. А ответ поделить на то, сколько строк нужно для задания второй строки. Далее рассмотрим наш жадный алгоритм. Мы идем по первой строке, пока не встретим первый символ второй строки, потом второй, третий и так далее до последнего, потом снова ищем первый, второй и так по циклу. Понятно, что когда мы дважды окажемся в состоянии, в котором позиции в первой строке соответствует одному символу строки, которая задает период и позиции во второй строке одинаковы, то мы получим период. Когда мы найдем этот период, то просто повторим его столько раз, сколько возможно, что бы каждый раз не считать одну и ту же информацию. Для лучшего понимая, советую прочитать любое прошедшее решение. 314C - Сережа и подпоследовательностиПонятно, что нужно посчитать сумму произведений элементов всех различных неубывающих подпоследовательностей заданной последовательности. Будем идти по последовательности слева направо и поддерживать массив q[i]: какая сумма всех нужных подпоследовательностей, таких что их последний элемент равен i. Понятно, что если очередное число это x, то нужно поставить q[x] = sum(q[1]+q[2]+...+q[x])*x+x. Ответом на задачу будет сумма всех q[i]. Для нахождения всех сумм можно использовать дерево Фенвика. 314D - Сережа и прямыеПовернем все на 45 градусов с помощью преобразования: (x, y) -> (x', y'): x' = x+y, y' = x-y.Далее нужно разместить две прямые параллельно осям координат. Отсортируем точки по первой координате. Далее будем использовать бинарный поиск по ответу. Пускай мы зафиксировали некоторое число, теперь нужно проверить хватит ли его, или нет. Заметим, что сейчас нужно разместить две полосы ширины 2 * зафиксированная величина, что бы ими покрыть все точки. Допустим, что некоторая точка будет прилегать к левой стороне вертикальной полосы, далее для всех точек, которые не попадают в полосу найдем минимальную и максимальную вторую координату. Если разница между найденными координатами не больше 2 * зафиксированная величина, то полосы разместить можно, иначе — нет. Скоро...",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/7905",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 314\\s*A"
          },
          "content_length": 3013
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #187 - Codeforces - Code 1",
          "code": "Мало того, что код написать,так и надо над оптимизацией думать",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7894",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #187 - Codeforces - Code 2",
          "code": "Мало того, что код написать,так и надо над оптимизацией думать",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7894",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #187 - Codeforces - Code 1",
          "code": "dp[i][j] = 25 * dp[i - 1][j - 1] + dp[i - 1][j + 1] otherwise. ('?' can be both: an opening and a closing bracket).",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7905",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #187 - Codeforces - Code 2",
          "code": "(x0, y0) --> (x1, y1)\nx0 = r * cos(a), y0 = r * sin(a)\nif a --> a + pi / 4\nx1 = r * cos(a + pi/4) = r * (cos(a) * cos(pi / 4) - sin(a) * sin(pi / 4)) \n   = 1 / sqrt(2) * (r * cos(a) - r * sin(a)) = 1 / sqrt(2) * (x0 - y0).\ny1 = r * sin(a + pi/4) = r * (sin(a) * cos(pi / 4) + cos(a) * sin(pi / 4)) \n   = 1 / sqrt(2) * (r * sin(a) + r * cos(a)) = 1 / sqrt(2) * (x0 + y0).\n\nSo, after rotating all the points 45 degrees and scale up all the coordinates with sqrt(2), (x0, y0) with be (x0 - y0, x0 + y0). \n\nAfter rotating, Manhattan distance ==> Chebyshev_distance. http://en.wikipedia.org/wiki/Chebyshev_distance",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7905",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #187 - Codeforces - Code 3",
          "code": "(x0, y0) --> (x1, y1)\nx0 = r * cos(a), y0 = r * sin(a)\nif a --> a + pi / 4\nx1 = r * cos(a + pi/4) = r * (cos(a) * cos(pi / 4) - sin(a) * sin(pi / 4)) \n   = 1 / sqrt(2) * (r * cos(a) - r * sin(a)) = 1 / sqrt(2) * (x0 - y0).\ny1 = r * sin(a + pi/4) = r * (sin(a) * cos(pi / 4) + cos(a) * sin(pi / 4)) \n   = 1 / sqrt(2) * (r * sin(a) + r * cos(a)) = 1 / sqrt(2) * (x0 + y0).\n\nSo, after rotating all the points 45 degrees and scale up all the coordinates with sqrt(2), (x0, y0) with be (x0 - y0, x0 + y0). \n\nAfter rotating, Manhattan distance ==> Chebyshev_distance. http://en.wikipedia.org/wiki/Chebyshev_distance",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7905",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #187 - Codeforces - Code 4",
          "code": "5\n1 1\n1 2\n2 3\n3 4\n4 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7905",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #187 - Codeforces - Code 5",
          "code": "5\n1 1\n1 2\n2 3\n3 4\n4 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7905",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #187 - Codeforces - Code 6",
          "code": "a_i == a_(i+1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7905",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 200000, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(-1000000000, 0, \"k\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, 1, 1000000000, \"a_i\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 200000, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(-1000000000, 0, \"k\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, 1, 1000000000, \"a_i\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 200000, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(-1000000000, 0, \"k\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, 1, 1000000000, \"a_i\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int k = opt<int>(\"k\", 0);\n    string type = opt<string>(\"type\", \"random\");\n    int min_ai = opt<int>(\"min_ai\", 1);\n    int max_ai = opt<int>(\"max_ai\", 1000000000);\n    int val = opt<int>(\"val\", min_ai);\n\n    vector<int> a(n);\n\n    if (type == \"equal\") {\n        for(int i = 0; i < n; ++i)\n            a[i] = val;\n    } else if (type == \"increasing\") {\n        int start = min_ai;\n        for(int i = 0; i < n; ++i)\n            a[i] = start + i;\n    } else if (type == \"decreasing\") {\n        int start = max_ai;\n        for(int i = 0; i < n; ++i)\n            a[i] = start - i;\n    } else if (type == \"random\") {\n        for(int i = 0; i < n; ++i)\n            a[i] = rnd.next(min_ai, max_ai);\n    } else if (type == \"max\") {\n        for(int i = 0; i < n; ++i)\n            a[i] = max_ai;\n    } else if (type == \"min\") {\n        for(int i = 0; i < n; ++i)\n            a[i] = min_ai;\n    } else if (type == \"palindrome\") {\n        for(int i = 0; i < n/2; ++i)\n            a[i] = a[n-1-i] = rnd.next(min_ai, max_ai);\n        if(n%2)\n            a[n/2] = rnd.next(min_ai, max_ai);\n    } else {\n        cerr << \"Unknown type: \" << type << endl;\n        exit(1);\n    }\n\n    // Output n and k\n    printf(\"%d %d\\n\", n, k);\n    for(int i = 0; i < n; ++i)\n        printf(\"%d%c\", a[i], \" \\n\"[i == n-1]);\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int k = opt<int>(\"k\", 0);\n    string type = opt<string>(\"type\", \"random\");\n    int min_ai = opt<int>(\"min_ai\", 1);\n    int max_ai = opt<int>(\"max_ai\", 1000000000);\n    int val = opt<int>(\"val\", min_ai);\n\n    vector<int> a(n);\n\n    if (type == \"equal\") {\n        for(int i = 0; i < n; ++i)\n            a[i] = val;\n    } else if (type == \"increasing\") {\n        int start = min_ai;\n        for(int i = 0; i < n; ++i)\n            a[i] = start + i;\n    } else if (type == \"decreasing\") {\n        int start = max_ai;\n        for(int i = 0; i < n; ++i)\n            a[i] = start - i;\n    } else if (type == \"random\") {\n        for(int i = 0; i < n; ++i)\n            a[i] = rnd.next(min_ai, max_ai);\n    } else if (type == \"max\") {\n        for(int i = 0; i < n; ++i)\n            a[i] = max_ai;\n    } else if (type == \"min\") {\n        for(int i = 0; i < n; ++i)\n            a[i] = min_ai;\n    } else if (type == \"palindrome\") {\n        for(int i = 0; i < n/2; ++i)\n            a[i] = a[n-1-i] = rnd.next(min_ai, max_ai);\n        if(n%2)\n            a[n/2] = rnd.next(min_ai, max_ai);\n    } else {\n        cerr << \"Unknown type: \" << type << endl;\n        exit(1);\n    }\n\n    // Output n and k\n    printf(\"%d %d\\n\", n, k);\n    for(int i = 0; i < n; ++i)\n        printf(\"%d%c\", a[i], \" \\n\"[i == n-1]);\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -k 0 -type equal -val 1000000000\n./gen -n 1 -k -1 -type equal -val 1\n./gen -n 2 -k 0 -type equal -val 1\n./gen -n 2 -k 0 -type equal -val 1000000000\n./gen -n 10 -k 0 -type random\n./gen -n 10 -k -10 -type random\n./gen -n 100 -k 0 -type increasing\n./gen -n 100 -k -100 -type decreasing\n./gen -n 1000 -k 0 -type equal -val 1\n./gen -n 1000 -k 0 -type equal -val 1000000000\n./gen -n 10000 -k -1000000000 -type random\n./gen -n 100000 -k -1000000000 -type random\n./gen -n 100000 -k 0 -type random -min_ai 1 -max_ai 1\n./gen -n 100000 -k -1000000000 -type random -min_ai 1000000000 -max_ai 1000000000\n./gen -n 200000 -k 0 -type min\n./gen -n 200000 -k 0 -type max\n./gen -n 200000 -k 0 -type random -min_ai 1 -max_ai 10\n./gen -n 200000 -k 0 -type random -min_ai 999999991 -max_ai 1000000000\n./gen -n 200000 -k -1 -type increasing\n./gen -n 200000 -k -1 -type decreasing\n./gen -n 200000 -k -100000 -type palindrome\n./gen -n 199999 -k -999999999 -type random\n./gen -n 200000 -k 0 -type equal -val 500000000\n./gen -n 200000 -k -123456789 -type random -min_ai 1 -max_ai 1\n./gen -n 200000 -k -10 -type random -min_ai 1 -max_ai 1\n./gen -n 200000 -k -10 -type random -min_ai 1000000000 -max_ai 1000000000\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:06:49.223824",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "314/B",
      "title": "B. Sereja and Periods",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains two integers b, d (1 ≤ b, d ≤ 107). The second line contains string a. The third line contains string c. The given strings are not empty and consist of lowercase English letters. Their lengths do not exceed 100.",
      "output_spec": "OutputIn a single line print an integer — the largest number p. If the required value of p doesn't exist, print 0.",
      "sample_tests": "ExamplesInputCopy10 3ababbabOutputCopy3",
      "description": "B. Sereja and Periods\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains two integers b, d (1 ≤ b, d ≤ 107). The second line contains string a. The third line contains string c. The given strings are not empty and consist of lowercase English letters. Their lengths do not exceed 100.\n\nOutputIn a single line print an integer — the largest number p. If the required value of p doesn't exist, print 0.\n\nInputCopy10 3ababbabOutputCopy3\n\nInputCopy10 3ababbab\n\nOutputCopy3",
      "solutions": [
        {
          "title": "Codeforces Round #187 - Codeforces",
          "content": "Hello everyone!Codeforces Round #187 will take place on Friday, June 7th at 19:30 MSK. This is my seventh Codeforces round and I hope not the last.I'd like to thank Gerald, Furko and Aksenov239 for helping me to prepare the round. Special thanks to Delinur for translation of all problem statements into English.I strongly recommend you to read ALL the problems.Gl & hf ! :)tutorial.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/7894",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 383
        },
        {
          "title": "Codeforces Round #187 tutorial - Codeforces",
          "content": "315A - Sereja and BottlesJust check for each bottle, can I open it with another. In this task can pass absolutely any solutions. 315B - Sereja and ArrayWe will support all of the elements in the array, but also we will supprt additionally variable add: how much to add to all the elements. Then to add some value to every element we simply increase the add. In the derivation we deduce the value of the array element + add. When you update the item we put to a value, value that you need to put minus the current value of add. 314A - Sereja and ContestNote that if we remove some of the participants, we never remove the participants with lower numbers as theirs amount will only increase. So just consider the sequence of all the participants, and if the participant does not fit we delete him. 314B - Sereja and PeriodsIt is clear that we can use greedy algorithm to look for the number of occurrences of the 2nd string in the first string, but it works too slow. To speed up the process, you can look at the first line of the string that specifies the second period. And the answer is divided into how many string you need to set the second string. Next, we consider our greedy algorithm. We are going by the first string, till we find the first character of the second string, then the second, third and so on until the last, then again find the first, second, and so the cycle. It is clear that if we stand in the same twice in a state in which the positions in the first string corresponds to one character string that determines the period and the position of the second string are the same, then we obtain the period. When we find this period, we can just repeat it as many times as possible. To better understand, I advise you to read any accepted solution. 314C - Sereja and SubsequencesIt is clear that we need to calculate the sum of the products of elements of all the different non-decreasing subsequences of given sequence. Let's go through the sequence from left to right and maintain the array q[i]: what means the sum of all relevant sub-sequences, such that their last element is equal to i. Clearly, if the next number is x, then you need to put q[x] = sum (q[1] + q[2] + ... + q[x]) * x + x. The answer to the problem is the sum of q[i]. To find all the amounts you can use Fenwick tree. 314D - Sereja and Straight LinesRoll all at 45 degrees using the transformation: (x, y) -> (x ', y'): x '= x + y, y' = x-y. Next you need to place two lines parallel to the coordinate axes. Sort the points by the first coordinate. Next, we use a binary search for the answer. May we have fixed a number, you now need to check whether it is enough or not. Note that now we need to put two strips of width 2 * fixed amount that they would have to cover all the points. Suppose that some point should be close to the left side of the vertical strip, then for all points that do not belong to the strip we find the minimum and maximum second coordinate. If the difference between the found coordinates no more then 2 * fixed quantity, the strip can be placed, otherwise — no. soon...",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/7905",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 314\\s*B"
          },
          "content_length": 3088
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #187 tutorial - Codeforces - Code 1",
          "code": "dp[i][j] = 25 * dp[i - 1][j - 1] + dp[i - 1][j + 1] otherwise. ('?' can be both: an opening and a closing bracket).",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7905",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #187 tutorial - Codeforces - Code 2",
          "code": "(x0, y0) --> (x1, y1)\nx0 = r * cos(a), y0 = r * sin(a)\nif a --> a + pi / 4\nx1 = r * cos(a + pi/4) = r * (cos(a) * cos(pi / 4) - sin(a) * sin(pi / 4)) \n   = 1 / sqrt(2) * (r * cos(a) - r * sin(a)) = 1 / sqrt(2) * (x0 - y0).\ny1 = r * sin(a + pi/4) = r * (sin(a) * cos(pi / 4) + cos(a) * sin(pi / 4)) \n   = 1 / sqrt(2) * (r * sin(a) + r * cos(a)) = 1 / sqrt(2) * (x0 + y0).\n\nSo, after rotating all the points 45 degrees and scale up all the coordinates with sqrt(2), (x0, y0) with be (x0 - y0, x0 + y0). \n\nAfter rotating, Manhattan distance ==> Chebyshev_distance. http://en.wikipedia.org/wiki/Chebyshev_distance",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7905",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #187 tutorial - Codeforces - Code 3",
          "code": "(x0, y0) --> (x1, y1)\nx0 = r * cos(a), y0 = r * sin(a)\nif a --> a + pi / 4\nx1 = r * cos(a + pi/4) = r * (cos(a) * cos(pi / 4) - sin(a) * sin(pi / 4)) \n   = 1 / sqrt(2) * (r * cos(a) - r * sin(a)) = 1 / sqrt(2) * (x0 - y0).\ny1 = r * sin(a + pi/4) = r * (sin(a) * cos(pi / 4) + cos(a) * sin(pi / 4)) \n   = 1 / sqrt(2) * (r * sin(a) + r * cos(a)) = 1 / sqrt(2) * (x0 + y0).\n\nSo, after rotating all the points 45 degrees and scale up all the coordinates with sqrt(2), (x0, y0) with be (x0 - y0, x0 + y0). \n\nAfter rotating, Manhattan distance ==> Chebyshev_distance. http://en.wikipedia.org/wiki/Chebyshev_distance",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7905",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #187 tutorial - Codeforces - Code 4",
          "code": "5\n1 1\n1 2\n2 3\n3 4\n4 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7905",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #187 tutorial - Codeforces - Code 5",
          "code": "5\n1 1\n1 2\n2 3\n3 4\n4 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7905",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #187 tutorial - Codeforces - Code 6",
          "code": "a_i == a_(i+1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7905",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int b = inf.readInt(1, 10000000, \"b\");\n    inf.readSpace();\n    int d = inf.readInt(1, 10000000, \"d\");\n    inf.readEoln();\n    string a = inf.readToken(\"[a-z]{1,100}\", \"a\");\n    inf.readEoln();\n    string c = inf.readToken(\"[a-z]{1,100}\", \"c\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int b = inf.readInt(1, 10000000, \"b\");\n    inf.readSpace();\n    int d = inf.readInt(1, 10000000, \"d\");\n    inf.readEoln();\n    string a = inf.readToken(\"[a-z]{1,100}\", \"a\");\n    inf.readEoln();\n    string c = inf.readToken(\"[a-z]{1,100}\", \"c\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int b = inf.readInt(1, 10000000, \"b\");\n    inf.readSpace();\n    int d = inf.readInt(1, 10000000, \"d\");\n    inf.readEoln();\n    string a = inf.readToken(\"[a-z]{1,100}\", \"a\");\n    inf.readEoln();\n    string c = inf.readToken(\"[a-z]{1,100}\", \"c\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    \n    int b = opt<int>(\"b\");\n    int d = opt<int>(\"d\");\n    int la = opt<int>(\"la\");\n    int lc = opt<int>(\"lc\");\n    string type = opt<string>(\"type\", \"random\");\n    \n    // Ensure the lengths are within the constraints\n    la = max(1, min(100, la));\n    lc = max(1, min(100, lc));\n    \n    string a, c;\n    \n    if (type == \"random\") {\n        // Generate random strings a and c\n        for (int i = 0; i < la; ++i)\n            a += (char)('a' + rnd.next(26));\n        for (int i = 0; i < lc; ++i)\n            c += (char)('a' + rnd.next(26));\n    } else if (type == \"same_char\") {\n        // Strings consisting of the same character\n        char ch_a = (char)('a' + rnd.next(26));\n        char ch_c = (char)('a' + rnd.next(26));\n        a = string(la, ch_a);\n        c = string(lc, ch_c);\n    } else if (type == \"alternating\") {\n        // String a: 'ababab...'\n        for (int i = 0; i < la; ++i)\n            a += (char)('a' + i % 2);\n        // String c: 'bababa...'\n        for (int i = 0; i < lc; ++i)\n            c += (char)('a' + (i + 1) % 2);\n    } else if (type == \"zero_p\") {\n        // String c cannot be obtained from w\n        for (int i = 0; i < la; ++i)\n            a += (char)('a' + rnd.next(13)); // 'a' to 'm'\n        for (int i = 0; i < lc; ++i)\n            c += (char)('n' + rnd.next(13)); // 'n' to 'z'\n    } else if (type == \"max_p\") {\n        // Strings where p is as large as possible, a and c are the same\n        for (int i = 0; i < la; ++i)\n            a += (char)('a' + rnd.next(26));\n        c = a;\n    } else if (type == \"overlapping\") {\n        // Create overlapping patterns between a and c\n        char ch1 = 'a' + rnd.next(26);\n        char ch2 = 'a' + rnd.next(26);\n        while (ch2 == ch1)\n            ch2 = 'a' + rnd.next(26);\n        // String a: ch1 + ch2 repeated\n        for (int i = 0; i < la; ++i)\n            a += (i % 2 == 0) ? ch1 : ch2;\n        // String c: ch2 + ch1 repeated\n        for (int i = 0; i < lc; ++i)\n            c += (i % 2 == 0) ? ch2 : ch1;\n    } else {\n        // Default to random strings\n        for (int i = 0; i < la; ++i)\n            a += (char)('a' + rnd.next(26));\n        for (int i = 0; i < lc; ++i)\n            c += (char)('a' + rnd.next(26));\n    }\n    \n    // Output b, d\n    printf(\"%d %d\\n\", b, d);\n    // Output string a\n    printf(\"%s\\n\", a.c_str());\n    // Output string c\n    printf(\"%s\\n\", c.c_str());\n    \n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    \n    int b = opt<int>(\"b\");\n    int d = opt<int>(\"d\");\n    int la = opt<int>(\"la\");\n    int lc = opt<int>(\"lc\");\n    string type = opt<string>(\"type\", \"random\");\n    \n    // Ensure the lengths are within the constraints\n    la = max(1, min(100, la));\n    lc = max(1, min(100, lc));\n    \n    string a, c;\n    \n    if (type == \"random\") {\n        // Generate random strings a and c\n        for (int i = 0; i < la; ++i)\n            a += (char)('a' + rnd.next(26));\n        for (int i = 0; i < lc; ++i)\n            c += (char)('a' + rnd.next(26));\n    } else if (type == \"same_char\") {\n        // Strings consisting of the same character\n        char ch_a = (char)('a' + rnd.next(26));\n        char ch_c = (char)('a' + rnd.next(26));\n        a = string(la, ch_a);\n        c = string(lc, ch_c);\n    } else if (type == \"alternating\") {\n        // String a: 'ababab...'\n        for (int i = 0; i < la; ++i)\n            a += (char)('a' + i % 2);\n        // String c: 'bababa...'\n        for (int i = 0; i < lc; ++i)\n            c += (char)('a' + (i + 1) % 2);\n    } else if (type == \"zero_p\") {\n        // String c cannot be obtained from w\n        for (int i = 0; i < la; ++i)\n            a += (char)('a' + rnd.next(13)); // 'a' to 'm'\n        for (int i = 0; i < lc; ++i)\n            c += (char)('n' + rnd.next(13)); // 'n' to 'z'\n    } else if (type == \"max_p\") {\n        // Strings where p is as large as possible, a and c are the same\n        for (int i = 0; i < la; ++i)\n            a += (char)('a' + rnd.next(26));\n        c = a;\n    } else if (type == \"overlapping\") {\n        // Create overlapping patterns between a and c\n        char ch1 = 'a' + rnd.next(26);\n        char ch2 = 'a' + rnd.next(26);\n        while (ch2 == ch1)\n            ch2 = 'a' + rnd.next(26);\n        // String a: ch1 + ch2 repeated\n        for (int i = 0; i < la; ++i)\n            a += (i % 2 == 0) ? ch1 : ch2;\n        // String c: ch2 + ch1 repeated\n        for (int i = 0; i < lc; ++i)\n            c += (i % 2 == 0) ? ch2 : ch1;\n    } else {\n        // Default to random strings\n        for (int i = 0; i < la; ++i)\n            a += (char)('a' + rnd.next(26));\n        for (int i = 0; i < lc; ++i)\n            c += (char)('a' + rnd.next(26));\n    }\n    \n    // Output b, d\n    printf(\"%d %d\\n\", b, d);\n    // Output string a\n    printf(\"%s\\n\", a.c_str());\n    // Output string c\n    printf(\"%s\\n\", c.c_str());\n    \n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -b 1 -d 1 -la 1 -lc 1 -type random\n./gen -b 1 -d 1 -la 2 -lc 2 -type alternating\n./gen -b 1 -d 1 -la 1 -lc 1 -type same_char\n./gen -b 1 -d 1 -la 10 -lc 10 -type zero_p\n./gen -b 1 -d 1 -la 5 -lc 5 -type max_p\n./gen -b 1 -d 1 -la 6 -lc 6 -type overlapping\n\n./gen -b 10000000 -d 10000000 -la 100 -lc 100 -type random\n./gen -b 10000000 -d 10000000 -la 100 -lc 100 -type same_char\n./gen -b 10000000 -d 10000000 -la 100 -lc 100 -type alternating\n./gen -b 10000000 -d 10000000 -la 100 -lc 100 -type zero_p\n./gen -b 10000000 -d 10000000 -la 100 -lc 100 -type max_p\n./gen -b 10000000 -d 10000000 -la 100 -lc 100 -type overlapping\n\n./gen -b 1 -d 10000000 -la 100 -lc 100 -type random\n./gen -b 10000000 -d 1 -la 100 -lc 100 -type random\n\n./gen -b 1 -d 1 -la 100 -lc 1 -type random\n./gen -b 1 -d 1 -la 1 -lc 100 -type random\n\n./gen -b 5000000 -d 5000000 -la 100 -lc 1 -type random\n./gen -b 5000000 -d 5000000 -la 1 -lc 100 -type random\n\n./gen -b 5000000 -d 5000000 -la 100 -lc 100 -type zero_p\n\n./gen -b 1 -d 10000000 -la 50 -lc 50 -type max_p\n./gen -b 10000000 -d 1 -la 50 -lc 50 -type max_p\n\n./gen -b 1234567 -d 7654321 -la 99 -lc 88 -type random\n./gen -b 9876543 -d 3456789 -la 100 -lc 100 -type overlapping\n./gen -b 10000000 -d 9999999 -la 2 -lc 2 -type same_char\n./gen -b 1 -d 1 -la 50 -lc 50 -type zero_p\n\n./gen -b 10000000 -d 10000000 -la 1 -lc 1 -type random\n./gen -b 1 -d 1 -la 1 -lc 1 -type random\n./gen -b 1 -d 1 -la 1 -lc 1 -type max_p\n./gen -b 10000000 -d 10000000 -la 1 -lc 1 -type max_p\n\n./gen -b 1 -d 10000000 -la 100 -lc 1 -type random\n./gen -b 10000000 -d 1 -la 1 -lc 100 -type random\n\n./gen -b 10000000 -d 10000000 -la 100 -lc 100 -type max_p\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:06:51.059446",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "314/C",
      "title": "C. Sereja and Subsequences",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains integer n (1 ≤ n ≤ 105). The second line contains n integers a1, a2, ..., an (1 ≤ ai ≤ 106).",
      "output_spec": "OutputIn the single line print the answer to the problem modulo 1000000007 (109 + 7).",
      "sample_tests": "ExamplesInputCopy142OutputCopy42InputCopy31 2 2OutputCopy13InputCopy51 2 3 4 5OutputCopy719",
      "description": "C. Sereja and Subsequences\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains integer n (1 ≤ n ≤ 105). The second line contains n integers a1, a2, ..., an (1 ≤ ai ≤ 106).\n\nOutputIn the single line print the answer to the problem modulo 1000000007 (109 + 7).\n\nInputCopy142OutputCopy42InputCopy31 2 2OutputCopy13InputCopy51 2 3 4 5OutputCopy719\n\nInputCopy142\n\nOutputCopy42\n\nInputCopy31 2 2\n\nOutputCopy13\n\nInputCopy51 2 3 4 5\n\nOutputCopy719",
      "solutions": [
        {
          "title": "Codeforces Round #187 - Codeforces",
          "content": "Hello everyone!Codeforces Round #187 will take place on Friday, June 7th at 19:30 MSK. This is my seventh Codeforces round and I hope not the last.I'd like to thank Gerald, Furko and Aksenov239 for helping me to prepare the round. Special thanks to Delinur for translation of all problem statements into English.I strongly recommend you to read ALL the problems.Gl & hf ! :)tutorial.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/7894",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 383
        },
        {
          "title": "Codeforces Round #187 tutorial - Codeforces",
          "content": "315A - Sereja and BottlesJust check for each bottle, can I open it with another. In this task can pass absolutely any solutions. 315B - Sereja and ArrayWe will support all of the elements in the array, but also we will supprt additionally variable add: how much to add to all the elements. Then to add some value to every element we simply increase the add. In the derivation we deduce the value of the array element + add. When you update the item we put to a value, value that you need to put minus the current value of add. 314A - Sereja and ContestNote that if we remove some of the participants, we never remove the participants with lower numbers as theirs amount will only increase. So just consider the sequence of all the participants, and if the participant does not fit we delete him. 314B - Sereja and PeriodsIt is clear that we can use greedy algorithm to look for the number of occurrences of the 2nd string in the first string, but it works too slow. To speed up the process, you can look at the first line of the string that specifies the second period. And the answer is divided into how many string you need to set the second string. Next, we consider our greedy algorithm. We are going by the first string, till we find the first character of the second string, then the second, third and so on until the last, then again find the first, second, and so the cycle. It is clear that if we stand in the same twice in a state in which the positions in the first string corresponds to one character string that determines the period and the position of the second string are the same, then we obtain the period. When we find this period, we can just repeat it as many times as possible. To better understand, I advise you to read any accepted solution. 314C - Sereja and SubsequencesIt is clear that we need to calculate the sum of the products of elements of all the different non-decreasing subsequences of given sequence. Let's go through the sequence from left to right and maintain the array q[i]: what means the sum of all relevant sub-sequences, such that their last element is equal to i. Clearly, if the next number is x, then you need to put q[x] = sum (q[1] + q[2] + ... + q[x]) * x + x. The answer to the problem is the sum of q[i]. To find all the amounts you can use Fenwick tree. 314D - Sereja and Straight LinesRoll all at 45 degrees using the transformation: (x, y) -> (x ', y'): x '= x + y, y' = x-y. Next you need to place two lines parallel to the coordinate axes. Sort the points by the first coordinate. Next, we use a binary search for the answer. May we have fixed a number, you now need to check whether it is enough or not. Note that now we need to put two strips of width 2 * fixed amount that they would have to cover all the points. Suppose that some point should be close to the left side of the vertical strip, then for all points that do not belong to the strip we find the minimum and maximum second coordinate. If the difference between the found coordinates no more then 2 * fixed quantity, the strip can be placed, otherwise — no. soon...",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/7905",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 314\\s*C"
          },
          "content_length": 3088
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #187 tutorial - Codeforces - Code 1",
          "code": "dp[i][j] = 25 * dp[i - 1][j - 1] + dp[i - 1][j + 1] otherwise. ('?' can be both: an opening and a closing bracket).",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7905",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #187 tutorial - Codeforces - Code 2",
          "code": "(x0, y0) --> (x1, y1)\nx0 = r * cos(a), y0 = r * sin(a)\nif a --> a + pi / 4\nx1 = r * cos(a + pi/4) = r * (cos(a) * cos(pi / 4) - sin(a) * sin(pi / 4)) \n   = 1 / sqrt(2) * (r * cos(a) - r * sin(a)) = 1 / sqrt(2) * (x0 - y0).\ny1 = r * sin(a + pi/4) = r * (sin(a) * cos(pi / 4) + cos(a) * sin(pi / 4)) \n   = 1 / sqrt(2) * (r * sin(a) + r * cos(a)) = 1 / sqrt(2) * (x0 + y0).\n\nSo, after rotating all the points 45 degrees and scale up all the coordinates with sqrt(2), (x0, y0) with be (x0 - y0, x0 + y0). \n\nAfter rotating, Manhattan distance ==> Chebyshev_distance. http://en.wikipedia.org/wiki/Chebyshev_distance",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7905",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #187 tutorial - Codeforces - Code 3",
          "code": "(x0, y0) --> (x1, y1)\nx0 = r * cos(a), y0 = r * sin(a)\nif a --> a + pi / 4\nx1 = r * cos(a + pi/4) = r * (cos(a) * cos(pi / 4) - sin(a) * sin(pi / 4)) \n   = 1 / sqrt(2) * (r * cos(a) - r * sin(a)) = 1 / sqrt(2) * (x0 - y0).\ny1 = r * sin(a + pi/4) = r * (sin(a) * cos(pi / 4) + cos(a) * sin(pi / 4)) \n   = 1 / sqrt(2) * (r * sin(a) + r * cos(a)) = 1 / sqrt(2) * (x0 + y0).\n\nSo, after rotating all the points 45 degrees and scale up all the coordinates with sqrt(2), (x0, y0) with be (x0 - y0, x0 + y0). \n\nAfter rotating, Manhattan distance ==> Chebyshev_distance. http://en.wikipedia.org/wiki/Chebyshev_distance",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7905",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #187 tutorial - Codeforces - Code 4",
          "code": "5\n1 1\n1 2\n2 3\n3 4\n4 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7905",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #187 tutorial - Codeforces - Code 5",
          "code": "5\n1 1\n1 2\n2 3\n3 4\n4 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7905",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #187 tutorial - Codeforces - Code 6",
          "code": "a_i == a_(i+1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7905",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n\n    std::vector<int> a = inf.readInts(n, 1, 1000000, \"a_i\");\n    inf.readEoln();\n\n    inf.readEof();\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n\n    std::vector<int> a = inf.readInts(n, 1, 1000000, \"a_i\");\n    inf.readEoln();\n\n    inf.readEof();\n\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n\n    std::vector<int> a = inf.readInts(n, 1, 1000000, \"a_i\");\n    inf.readEoln();\n\n    inf.readEof();\n\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n    int minA = opt<int>(\"minA\", 1);\n    int maxA = opt<int>(\"maxA\", 1000000);\n\n    vector<int> a(n);\n\n    if (type == \"random\") {\n        // Generate n random integers between minA and maxA\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(minA, maxA);\n        }\n    } else if (type == \"equal\") {\n        int equalValue = opt<int>(\"equalValue\", minA);\n        for (int i = 0; i < n; ++i) {\n            a[i] = equalValue;\n        }\n    } else if (type == \"increasing\") {\n        int current = minA;\n        int maxIncrement = max(1, (maxA - minA) / max(1, n - 1));\n        for (int i = 0; i < n; ++i) {\n            a[i] = current;\n            if (current < maxA) {\n                int increment = rnd.next(0, maxIncrement);\n                current += increment;\n                if (current > maxA) current = maxA;\n            }\n        }\n    } else if (type == \"decreasing\") {\n        int current = maxA;\n        int maxDecrement = max(1, (maxA - minA) / max(1, n - 1));\n        for (int i = 0; i < n; ++i) {\n            a[i] = current;\n            if (current > minA) {\n                int decrement = rnd.next(0, maxDecrement);\n                current -= decrement;\n                if (current < minA) current = minA;\n            }\n        }\n    } else if (type == \"alternating\") {\n        int val1 = opt<int>(\"val1\", minA);\n        int val2 = opt<int>(\"val2\", maxA);\n        for (int i = 0; i < n; ++i) {\n            if (i % 2 == 0)\n                a[i] = val1;\n            else\n                a[i] = val2;\n        }\n    } else {\n        // Unknown type\n        fprintf(stderr, \"Unknown type: %s\\n\", type.c_str());\n        return 1;\n    }\n\n    // Output\n    printf(\"%d\\n\", n);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d%c\", a[i], i+1 == n ? '\\n' : ' ');\n    }\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n    int minA = opt<int>(\"minA\", 1);\n    int maxA = opt<int>(\"maxA\", 1000000);\n\n    vector<int> a(n);\n\n    if (type == \"random\") {\n        // Generate n random integers between minA and maxA\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(minA, maxA);\n        }\n    } else if (type == \"equal\") {\n        int equalValue = opt<int>(\"equalValue\", minA);\n        for (int i = 0; i < n; ++i) {\n            a[i] = equalValue;\n        }\n    } else if (type == \"increasing\") {\n        int current = minA;\n        int maxIncrement = max(1, (maxA - minA) / max(1, n - 1));\n        for (int i = 0; i < n; ++i) {\n            a[i] = current;\n            if (current < maxA) {\n                int increment = rnd.next(0, maxIncrement);\n                current += increment;\n                if (current > maxA) current = maxA;\n            }\n        }\n    } else if (type == \"decreasing\") {\n        int current = maxA;\n        int maxDecrement = max(1, (maxA - minA) / max(1, n - 1));\n        for (int i = 0; i < n; ++i) {\n            a[i] = current;\n            if (current > minA) {\n                int decrement = rnd.next(0, maxDecrement);\n                current -= decrement;\n                if (current < minA) current = minA;\n            }\n        }\n    } else if (type == \"alternating\") {\n        int val1 = opt<int>(\"val1\", minA);\n        int val2 = opt<int>(\"val2\", maxA);\n        for (int i = 0; i < n; ++i) {\n            if (i % 2 == 0)\n                a[i] = val1;\n            else\n                a[i] = val2;\n        }\n    } else {\n        // Unknown type\n        fprintf(stderr, \"Unknown type: %s\\n\", type.c_str());\n        return 1;\n    }\n\n    // Output\n    printf(\"%d\\n\", n);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d%c\", a[i], i+1 == n ? '\\n' : ' ');\n    }\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# n=1 tests\n./gen -n 1 -type equal -equalValue 1\n./gen -n 1 -type random -minA 1 -maxA 1\n./gen -n 1 -type increasing\n./gen -n 1 -type decreasing\n./gen -n 1 -type alternating -val1 1 -val2 1000000\n\n# n=2 tests\n./gen -n 2 -type equal -equalValue 1\n./gen -n 2 -type random\n./gen -n 2 -type increasing -minA 1 -maxA 2\n./gen -n 2 -type decreasing -minA 1 -maxA 2\n./gen -n 2 -type alternating -val1 1 -val2 2\n\n# n=10 tests\n./gen -n 10 -type equal -equalValue 1000000\n./gen -n 10 -type random\n./gen -n 10 -type increasing\n./gen -n 10 -type decreasing\n./gen -n 10 -type alternating -val1 1 -val2 2\n\n# n=100 tests\n./gen -n 100 -type equal -equalValue 1\n./gen -n 100 -type random\n./gen -n 100 -type increasing\n./gen -n 100 -type decreasing\n./gen -n 100 -type alternating -val1 1 -val2 2\n\n# n=1000 tests\n./gen -n 1000 -type equal -equalValue 1000000\n./gen -n 1000 -type random\n./gen -n 1000 -type increasing\n./gen -n 1000 -type decreasing\n./gen -n 1000 -type alternating -val1 999999 -val2 1000000\n\n# n=100000 tests\n./gen -n 100000 -type equal -equalValue 1\n./gen -n 100000 -type equal -equalValue 1000000\n./gen -n 100000 -type random\n./gen -n 100000 -type increasing -minA 1 -maxA 1000000\n./gen -n 100000 -type decreasing -minA 1 -maxA 1000000\n./gen -n 100000 -type alternating -val1 999999 -val2 1000000\n\n# Special test cases\n# All elements are 1\n./gen -n 100000 -type equal -equalValue 1\n\n# All elements are maximum value\n./gen -n 100000 -type equal -equalValue 1000000\n\n# Only two different elements (1 and 2)\n./gen -n 100000 -type random -minA 1 -maxA 2\n\n# Random elements between 1 and 10\n./gen -n 100000 -type random -minA 1 -maxA 10\n\n# Random elements between 1 and 100\n./gen -n 100000 -type random -minA 1 -maxA 100\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:06:53.345709",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "314/D",
      "title": "D. Sereja and Straight Lines",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains integer n (1 ≤ n ≤ 105). Next n lines contain the coordinates of the lines. The i-th line contains two integers xi, yi (|xi|, |yi| ≤ 109).",
      "output_spec": "OutputIn a single line print a real number — the answer to the problem. Your answer will be considered correct iff its absolute or relative error doesn't exceed 10 - 6.",
      "sample_tests": "ExamplesInputCopy40 02 00 22 2OutputCopy0.000000000000000InputCopy41 00 12 11 2OutputCopy1.000000000000000",
      "description": "D. Sereja and Straight Lines\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains integer n (1 ≤ n ≤ 105). Next n lines contain the coordinates of the lines. The i-th line contains two integers xi, yi (|xi|, |yi| ≤ 109).\n\nOutputIn a single line print a real number — the answer to the problem. Your answer will be considered correct iff its absolute or relative error doesn't exceed 10 - 6.\n\nInputCopy40 02 00 22 2OutputCopy0.000000000000000InputCopy41 00 12 11 2OutputCopy1.000000000000000\n\nInputCopy40 02 00 22 2\n\nOutputCopy0.000000000000000\n\nInputCopy41 00 12 11 2\n\nOutputCopy1.000000000000000",
      "solutions": [
        {
          "title": "Codeforces Round #187 - Codeforces",
          "content": "Hello everyone!Codeforces Round #187 will take place on Friday, June 7th at 19:30 MSK. This is my seventh Codeforces round and I hope not the last.I'd like to thank Gerald, Furko and Aksenov239 for helping me to prepare the round. Special thanks to Delinur for translation of all problem statements into English.I strongly recommend you to read ALL the problems.Gl & hf ! :)tutorial.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/7894",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 383
        },
        {
          "title": "Codeforces Round #187 tutorial - Codeforces",
          "content": "315A - Sereja and BottlesJust check for each bottle, can I open it with another. In this task can pass absolutely any solutions. 315B - Sereja and ArrayWe will support all of the elements in the array, but also we will supprt additionally variable add: how much to add to all the elements. Then to add some value to every element we simply increase the add. In the derivation we deduce the value of the array element + add. When you update the item we put to a value, value that you need to put minus the current value of add. 314A - Sereja and ContestNote that if we remove some of the participants, we never remove the participants with lower numbers as theirs amount will only increase. So just consider the sequence of all the participants, and if the participant does not fit we delete him. 314B - Sereja and PeriodsIt is clear that we can use greedy algorithm to look for the number of occurrences of the 2nd string in the first string, but it works too slow. To speed up the process, you can look at the first line of the string that specifies the second period. And the answer is divided into how many string you need to set the second string. Next, we consider our greedy algorithm. We are going by the first string, till we find the first character of the second string, then the second, third and so on until the last, then again find the first, second, and so the cycle. It is clear that if we stand in the same twice in a state in which the positions in the first string corresponds to one character string that determines the period and the position of the second string are the same, then we obtain the period. When we find this period, we can just repeat it as many times as possible. To better understand, I advise you to read any accepted solution. 314C - Sereja and SubsequencesIt is clear that we need to calculate the sum of the products of elements of all the different non-decreasing subsequences of given sequence. Let's go through the sequence from left to right and maintain the array q[i]: what means the sum of all relevant sub-sequences, such that their last element is equal to i. Clearly, if the next number is x, then you need to put q[x] = sum (q[1] + q[2] + ... + q[x]) * x + x. The answer to the problem is the sum of q[i]. To find all the amounts you can use Fenwick tree. 314D - Sereja and Straight LinesRoll all at 45 degrees using the transformation: (x, y) -> (x ', y'): x '= x + y, y' = x-y. Next you need to place two lines parallel to the coordinate axes. Sort the points by the first coordinate. Next, we use a binary search for the answer. May we have fixed a number, you now need to check whether it is enough or not. Note that now we need to put two strips of width 2 * fixed amount that they would have to cover all the points. Suppose that some point should be close to the left side of the vertical strip, then for all points that do not belong to the strip we find the minimum and maximum second coordinate. If the difference between the found coordinates no more then 2 * fixed quantity, the strip can be placed, otherwise — no. soon...",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/7905",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 314\\s*D"
          },
          "content_length": 3088
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #187 tutorial - Codeforces - Code 1",
          "code": "dp[i][j] = 25 * dp[i - 1][j - 1] + dp[i - 1][j + 1] otherwise. ('?' can be both: an opening and a closing bracket).",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7905",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #187 tutorial - Codeforces - Code 2",
          "code": "(x0, y0) --> (x1, y1)\nx0 = r * cos(a), y0 = r * sin(a)\nif a --> a + pi / 4\nx1 = r * cos(a + pi/4) = r * (cos(a) * cos(pi / 4) - sin(a) * sin(pi / 4)) \n   = 1 / sqrt(2) * (r * cos(a) - r * sin(a)) = 1 / sqrt(2) * (x0 - y0).\ny1 = r * sin(a + pi/4) = r * (sin(a) * cos(pi / 4) + cos(a) * sin(pi / 4)) \n   = 1 / sqrt(2) * (r * sin(a) + r * cos(a)) = 1 / sqrt(2) * (x0 + y0).\n\nSo, after rotating all the points 45 degrees and scale up all the coordinates with sqrt(2), (x0, y0) with be (x0 - y0, x0 + y0). \n\nAfter rotating, Manhattan distance ==> Chebyshev_distance. http://en.wikipedia.org/wiki/Chebyshev_distance",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7905",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #187 tutorial - Codeforces - Code 3",
          "code": "(x0, y0) --> (x1, y1)\nx0 = r * cos(a), y0 = r * sin(a)\nif a --> a + pi / 4\nx1 = r * cos(a + pi/4) = r * (cos(a) * cos(pi / 4) - sin(a) * sin(pi / 4)) \n   = 1 / sqrt(2) * (r * cos(a) - r * sin(a)) = 1 / sqrt(2) * (x0 - y0).\ny1 = r * sin(a + pi/4) = r * (sin(a) * cos(pi / 4) + cos(a) * sin(pi / 4)) \n   = 1 / sqrt(2) * (r * sin(a) + r * cos(a)) = 1 / sqrt(2) * (x0 + y0).\n\nSo, after rotating all the points 45 degrees and scale up all the coordinates with sqrt(2), (x0, y0) with be (x0 - y0, x0 + y0). \n\nAfter rotating, Manhattan distance ==> Chebyshev_distance. http://en.wikipedia.org/wiki/Chebyshev_distance",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7905",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #187 tutorial - Codeforces - Code 4",
          "code": "5\n1 1\n1 2\n2 3\n3 4\n4 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7905",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #187 tutorial - Codeforces - Code 5",
          "code": "5\n1 1\n1 2\n2 3\n3 4\n4 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7905",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #187 tutorial - Codeforces - Code 6",
          "code": "a_i == a_(i+1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7905",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n    for (int i = 0; i < n; i++) {\n        int xi = inf.readInt(-1000000000, 1000000000, \"xi\");\n        inf.readSpace();\n        int yi = inf.readInt(-1000000000, 1000000000, \"yi\");\n        inf.readEoln();\n    }\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n    for (int i = 0; i < n; i++) {\n        int xi = inf.readInt(-1000000000, 1000000000, \"xi\");\n        inf.readSpace();\n        int yi = inf.readInt(-1000000000, 1000000000, \"yi\");\n        inf.readEoln();\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n    for (int i = 0; i < n; i++) {\n        int xi = inf.readInt(-1000000000, 1000000000, \"xi\");\n        inf.readSpace();\n        int yi = inf.readInt(-1000000000, 1000000000, \"yi\");\n        inf.readEoln();\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nconst double EPS = 1E-6;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare two sequences of doubles, max absolute or relative  error = %.7f\", EPS);\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    double j = 0, p = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        n++;\r\n        j = ans.readDouble();\r\n        p = ouf.readDouble();\r\n        if (!doubleCompare(j, p, EPS)) {\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%.7f', found: '%.7f', error = '%.7f'\",\r\n                  n, englishEnding(n).c_str(), j, p, doubleDelta(j, p));\r\n        }\r\n    }\r\n\r\n    if (n == 1)\r\n        quitf(_ok, \"found '%.7f', expected '%.7f', error '%.7f'\", p, j, doubleDelta(j, p));\r\n\r\n    quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    n = max(1, min(n, 100000)); // Ensure n is within [1, 1e5]\n\n    if (type == \"random\"){\n        // Generate n random points where xi, yi in [-1e9, 1e9]\n        printf(\"%d\\n\", n);\n        for(int i = 0; i < n; ++i){\n            int x = rnd.next(-1000000000, 1000000000);\n            int y = rnd.next(-1000000000, 1000000000);\n            printf(\"%d %d\\n\", x, y);\n        }\n    } else if (type == \"all_same_point\"){\n        // All points are the same\n        printf(\"%d\\n\", n);\n        int x = rnd.next(-1000000000, 1000000000);\n        int y = rnd.next(-1000000000, 1000000000);\n        for(int i = 0; i < n; ++i){\n            printf(\"%d %d\\n\", x, y);\n        }\n    } else if (type == \"max_coordinates\"){\n        // Points have maximum or minimum coordinates\n        printf(\"%d\\n\", n);\n        for(int i = 0; i < n; ++i){\n            int x = rnd.next(0, 1) ? 1000000000 : -1000000000;\n            int y = rnd.next(0, 1) ? 1000000000 : -1000000000;\n            printf(\"%d %d\\n\", x, y);\n        }\n    } else if (type == \"min_n\"){\n        // n is set to 1 regardless of input\n        n = 1;\n        printf(\"%d\\n\", n);\n        int x = rnd.next(-1000000000, 1000000000);\n        int y = rnd.next(-1000000000, 1000000000);\n        printf(\"%d %d\\n\", x, y);\n    } else if (type == \"line_x\"){\n        // Points along x-axis (y = 0)\n        printf(\"%d\\n\", n);\n        for(int i = 0; i < n; ++i){\n            int x = rnd.next(-1000000000, 1000000000);\n            int y = 0;\n            printf(\"%d %d\\n\", x, y);\n        }\n    } else if (type == \"line_y\"){\n        // Points along y-axis (x = 0)\n        printf(\"%d\\n\", n);\n        for(int i = 0; i < n; ++i){\n            int x = 0;\n            int y = rnd.next(-1000000000, 1000000000);\n            printf(\"%d %d\\n\", x, y);\n        }\n    } else if (type == \"diagonal_line\"){\n        // Points along y = x\n        printf(\"%d\\n\", n);\n        for(int i = 0; i < n; ++i){\n            int x = rnd.next(-1000000000, 1000000000);\n            int y = x;\n            printf(\"%d %d\\n\", x, y);\n        }\n    } else if (type == \"grid\"){\n        // Points forming a grid\n        int grid_size = ceil(sqrt(n));\n        int count = 0;\n        int64_t min_coord = -1000000000;\n        int64_t max_coord = 1000000000;\n\n        int64_t step = (max_coord - min_coord) / max(1, grid_size - 1);\n        vector<int64_t> xs, ys;\n        for(int i = 0; i < grid_size; ++i){\n            xs.push_back(min_coord + i * step);\n            ys.push_back(min_coord + i * step);\n        }\n        shuffle(xs.begin(), xs.end());\n        shuffle(ys.begin(), ys.end());\n        printf(\"%d\\n\", n);\n        for(int i = 0; i < grid_size && count < n; ++i){\n            for(int j = 0; j < grid_size && count < n; ++j){\n                printf(\"%lld %lld\\n\", xs[i], ys[j]);\n                ++count;\n            }\n        }\n    } else {\n        // Default to random\n        printf(\"%d\\n\", n);\n        for(int i = 0; i < n; ++i){\n            int x = rnd.next(-1000000000, 1000000000);\n            int y = rnd.next(-1000000000, 1000000000);\n            printf(\"%d %d\\n\", x, y);\n        }\n    }\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    n = max(1, min(n, 100000)); // Ensure n is within [1, 1e5]\n\n    if (type == \"random\"){\n        // Generate n random points where xi, yi in [-1e9, 1e9]\n        printf(\"%d\\n\", n);\n        for(int i = 0; i < n; ++i){\n            int x = rnd.next(-1000000000, 1000000000);\n            int y = rnd.next(-1000000000, 1000000000);\n            printf(\"%d %d\\n\", x, y);\n        }\n    } else if (type == \"all_same_point\"){\n        // All points are the same\n        printf(\"%d\\n\", n);\n        int x = rnd.next(-1000000000, 1000000000);\n        int y = rnd.next(-1000000000, 1000000000);\n        for(int i = 0; i < n; ++i){\n            printf(\"%d %d\\n\", x, y);\n        }\n    } else if (type == \"max_coordinates\"){\n        // Points have maximum or minimum coordinates\n        printf(\"%d\\n\", n);\n        for(int i = 0; i < n; ++i){\n            int x = rnd.next(0, 1) ? 1000000000 : -1000000000;\n            int y = rnd.next(0, 1) ? 1000000000 : -1000000000;\n            printf(\"%d %d\\n\", x, y);\n        }\n    } else if (type == \"min_n\"){\n        // n is set to 1 regardless of input\n        n = 1;\n        printf(\"%d\\n\", n);\n        int x = rnd.next(-1000000000, 1000000000);\n        int y = rnd.next(-1000000000, 1000000000);\n        printf(\"%d %d\\n\", x, y);\n    } else if (type == \"line_x\"){\n        // Points along x-axis (y = 0)\n        printf(\"%d\\n\", n);\n        for(int i = 0; i < n; ++i){\n            int x = rnd.next(-1000000000, 1000000000);\n            int y = 0;\n            printf(\"%d %d\\n\", x, y);\n        }\n    } else if (type == \"line_y\"){\n        // Points along y-axis (x = 0)\n        printf(\"%d\\n\", n);\n        for(int i = 0; i < n; ++i){\n            int x = 0;\n            int y = rnd.next(-1000000000, 1000000000);\n            printf(\"%d %d\\n\", x, y);\n        }\n    } else if (type == \"diagonal_line\"){\n        // Points along y = x\n        printf(\"%d\\n\", n);\n        for(int i = 0; i < n; ++i){\n            int x = rnd.next(-1000000000, 1000000000);\n            int y = x;\n            printf(\"%d %d\\n\", x, y);\n        }\n    } else if (type == \"grid\"){\n        // Points forming a grid\n        int grid_size = ceil(sqrt(n));\n        int count = 0;\n        int64_t min_coord = -1000000000;\n        int64_t max_coord = 1000000000;\n\n        int64_t step = (max_coord - min_coord) / max(1, grid_size - 1);\n        vector<int64_t> xs, ys;\n        for(int i = 0; i < grid_size; ++i){\n            xs.push_back(min_coord + i * step);\n            ys.push_back(min_coord + i * step);\n        }\n        shuffle(xs.begin(), xs.end());\n        shuffle(ys.begin(), ys.end());\n        printf(\"%d\\n\", n);\n        for(int i = 0; i < grid_size && count < n; ++i){\n            for(int j = 0; j < grid_size && count < n; ++j){\n                printf(\"%lld %lld\\n\", xs[i], ys[j]);\n                ++count;\n            }\n        }\n    } else {\n        // Default to random\n        printf(\"%d\\n\", n);\n        for(int i = 0; i < n; ++i){\n            int x = rnd.next(-1000000000, 1000000000);\n            int y = rnd.next(-1000000000, 1000000000);\n            printf(\"%d %d\\n\", x, y);\n        }\n    }\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -type min_n\n./gen -n 1 -type random\n\n./gen -n 2 -type random\n./gen -n 2 -type line_x\n./gen -n 2 -type line_y\n\n./gen -n 10 -type random\n./gen -n 10 -type all_same_point\n./gen -n 10 -type max_coordinates\n./gen -n 10 -type line_x\n./gen -n 10 -type line_y\n./gen -n 10 -type diagonal_line\n./gen -n 10 -type grid\n\n./gen -n 100 -type random\n./gen -n 100 -type all_same_point\n./gen -n 100 -type max_coordinates\n./gen -n 100 -type line_x\n./gen -n 100 -type line_y\n./gen -n 100 -type diagonal_line\n./gen -n 100 -type grid\n\n./gen -n 1000 -type random\n./gen -n 1000 -type all_same_point\n./gen -n 1000 -type max_coordinates\n./gen -n 1000 -type line_x\n./gen -n 1000 -type line_y\n./gen -n 1000 -type diagonal_line\n./gen -n 1000 -type grid\n\n./gen -n 100000 -type random\n./gen -n 100000 -type all_same_point\n./gen -n 100000 -type max_coordinates\n./gen -n 100000 -type line_x\n./gen -n 100000 -type line_y\n./gen -n 100000 -type diagonal_line\n./gen -n 100000 -type grid\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:06:55.624148",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "314/E",
      "title": "E. Sereja and Squares",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test4 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains integer n the number of points (1 ≤ n ≤ 105). The second line contains a sequence consisting of n small English letters and question marks — the sequence of letters, that mark points, in order of increasing x-coordinate of points. Question marks denote the points without letters (Petya erased them). It is guaranteed that the input string doesn't contain letter \"x\".",
      "output_spec": "OutputIn a single line print the answer to the problem modulo 4294967296. If there is no way to return the removed letters, print number 0.Please, do not write the %lld specifier to read or write 64-bit integers in С++. It is preferred to use the cin, cout streams or the %I64d specifier.",
      "sample_tests": "ExamplesInputCopy4a???OutputCopy50InputCopy4abc?OutputCopy0InputCopy6abc???OutputCopy1",
      "description": "E. Sereja and Squares\n\ntime limit per test4 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains integer n the number of points (1 ≤ n ≤ 105). The second line contains a sequence consisting of n small English letters and question marks — the sequence of letters, that mark points, in order of increasing x-coordinate of points. Question marks denote the points without letters (Petya erased them). It is guaranteed that the input string doesn't contain letter \"x\".\n\nOutputIn a single line print the answer to the problem modulo 4294967296. If there is no way to return the removed letters, print number 0.Please, do not write the %lld specifier to read or write 64-bit integers in С++. It is preferred to use the cin, cout streams or the %I64d specifier.\n\nInputCopy4a???OutputCopy50InputCopy4abc?OutputCopy0InputCopy6abc???OutputCopy1\n\nInputCopy4a???\n\nOutputCopy50\n\nInputCopy4abc?\n\nOutputCopy0\n\nInputCopy6abc???\n\nOutputCopy1",
      "solutions": [
        {
          "title": "Codeforces Round #187 - Codeforces",
          "content": "Hello everyone!Codeforces Round #187 will take place on Friday, June 7th at 19:30 MSK. This is my seventh Codeforces round and I hope not the last.I'd like to thank Gerald, Furko and Aksenov239 for helping me to prepare the round. Special thanks to Delinur for translation of all problem statements into English.I strongly recommend you to read ALL the problems.Gl & hf ! :)tutorial.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/7894",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 383
        },
        {
          "title": "Codeforces Round #187 tutorial - Codeforces",
          "content": "315A - Sereja and BottlesJust check for each bottle, can I open it with another. In this task can pass absolutely any solutions. 315B - Sereja and ArrayWe will support all of the elements in the array, but also we will supprt additionally variable add: how much to add to all the elements. Then to add some value to every element we simply increase the add. In the derivation we deduce the value of the array element + add. When you update the item we put to a value, value that you need to put minus the current value of add. 314A - Sereja and ContestNote that if we remove some of the participants, we never remove the participants with lower numbers as theirs amount will only increase. So just consider the sequence of all the participants, and if the participant does not fit we delete him. 314B - Sereja and PeriodsIt is clear that we can use greedy algorithm to look for the number of occurrences of the 2nd string in the first string, but it works too slow. To speed up the process, you can look at the first line of the string that specifies the second period. And the answer is divided into how many string you need to set the second string. Next, we consider our greedy algorithm. We are going by the first string, till we find the first character of the second string, then the second, third and so on until the last, then again find the first, second, and so the cycle. It is clear that if we stand in the same twice in a state in which the positions in the first string corresponds to one character string that determines the period and the position of the second string are the same, then we obtain the period. When we find this period, we can just repeat it as many times as possible. To better understand, I advise you to read any accepted solution. 314C - Sereja and SubsequencesIt is clear that we need to calculate the sum of the products of elements of all the different non-decreasing subsequences of given sequence. Let's go through the sequence from left to right and maintain the array q[i]: what means the sum of all relevant sub-sequences, such that their last element is equal to i. Clearly, if the next number is x, then you need to put q[x] = sum (q[1] + q[2] + ... + q[x]) * x + x. The answer to the problem is the sum of q[i]. To find all the amounts you can use Fenwick tree. 314D - Sereja and Straight LinesRoll all at 45 degrees using the transformation: (x, y) -> (x ', y'): x '= x + y, y' = x-y. Next you need to place two lines parallel to the coordinate axes. Sort the points by the first coordinate. Next, we use a binary search for the answer. May we have fixed a number, you now need to check whether it is enough or not. Note that now we need to put two strips of width 2 * fixed amount that they would have to cover all the points. Suppose that some point should be close to the left side of the vertical strip, then for all points that do not belong to the strip we find the minimum and maximum second coordinate. If the difference between the found coordinates no more then 2 * fixed quantity, the strip can be placed, otherwise — no. soon...",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/7905",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.6,
            "reason": "宽松匹配: 包含题目编号 314 和字母"
          },
          "content_length": 3088
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #187 tutorial - Codeforces - Code 1",
          "code": "dp[i][j] = 25 * dp[i - 1][j - 1] + dp[i - 1][j + 1] otherwise. ('?' can be both: an opening and a closing bracket).",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7905",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #187 tutorial - Codeforces - Code 2",
          "code": "(x0, y0) --> (x1, y1)\nx0 = r * cos(a), y0 = r * sin(a)\nif a --> a + pi / 4\nx1 = r * cos(a + pi/4) = r * (cos(a) * cos(pi / 4) - sin(a) * sin(pi / 4)) \n   = 1 / sqrt(2) * (r * cos(a) - r * sin(a)) = 1 / sqrt(2) * (x0 - y0).\ny1 = r * sin(a + pi/4) = r * (sin(a) * cos(pi / 4) + cos(a) * sin(pi / 4)) \n   = 1 / sqrt(2) * (r * sin(a) + r * cos(a)) = 1 / sqrt(2) * (x0 + y0).\n\nSo, after rotating all the points 45 degrees and scale up all the coordinates with sqrt(2), (x0, y0) with be (x0 - y0, x0 + y0). \n\nAfter rotating, Manhattan distance ==> Chebyshev_distance. http://en.wikipedia.org/wiki/Chebyshev_distance",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7905",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #187 tutorial - Codeforces - Code 3",
          "code": "(x0, y0) --> (x1, y1)\nx0 = r * cos(a), y0 = r * sin(a)\nif a --> a + pi / 4\nx1 = r * cos(a + pi/4) = r * (cos(a) * cos(pi / 4) - sin(a) * sin(pi / 4)) \n   = 1 / sqrt(2) * (r * cos(a) - r * sin(a)) = 1 / sqrt(2) * (x0 - y0).\ny1 = r * sin(a + pi/4) = r * (sin(a) * cos(pi / 4) + cos(a) * sin(pi / 4)) \n   = 1 / sqrt(2) * (r * sin(a) + r * cos(a)) = 1 / sqrt(2) * (x0 + y0).\n\nSo, after rotating all the points 45 degrees and scale up all the coordinates with sqrt(2), (x0, y0) with be (x0 - y0, x0 + y0). \n\nAfter rotating, Manhattan distance ==> Chebyshev_distance. http://en.wikipedia.org/wiki/Chebyshev_distance",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7905",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #187 tutorial - Codeforces - Code 4",
          "code": "5\n1 1\n1 2\n2 3\n3 4\n4 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7905",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #187 tutorial - Codeforces - Code 5",
          "code": "5\n1 1\n1 2\n2 3\n3 4\n4 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7905",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #187 tutorial - Codeforces - Code 6",
          "code": "a_i == a_(i+1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7905",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n    string s = inf.readLine();\n    ensuref(int(s.length()) == n, \"Length of string (%d) != n (%d)\", int(s.length()), n);\n    for (int i = 0; i < n; ++i) {\n        char c = s[i];\n        ensuref(c == '?' || (c >= 'a' && c <= 'z' && c != 'x'),\n                \"Invalid character '%c' at position %d\", c, i + 1);\n    }\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n    string s = inf.readLine();\n    ensuref(int(s.length()) == n, \"Length of string (%d) != n (%d)\", int(s.length()), n);\n    for (int i = 0; i < n; ++i) {\n        char c = s[i];\n        ensuref(c == '?' || (c >= 'a' && c <= 'z' && c != 'x'),\n                \"Invalid character '%c' at position %d\", c, i + 1);\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n    string s = inf.readLine();\n    ensuref(int(s.length()) == n, \"Length of string (%d) != n (%d)\", int(s.length()), n);\n    for (int i = 0; i < n; ++i) {\n        char c = s[i];\n        ensuref(c == '?' || (c >= 'a' && c <= 'z' && c != 'x'),\n                \"Invalid character '%c' at position %d\", c, i + 1);\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\n// Function to generate a random lowercase letter excluding 'x'\nchar randomLetter() {\n    int idx = rnd.next(25); // letters 'a'-'z' excluding 'x'\n    if (idx < ('x' - 'a')) return 'a' + idx;\n    else return 'a' + idx + 1;\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    // Read the parameters\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    if (type == \"random\") {\n        // Generate a random string of letters and '?' marks\n        string s;\n        for (int i = 0; i < n; ++i) {\n            if (rnd.next(2) == 0)\n                s += '?';\n            else\n                s += randomLetter();\n        }\n        printf(\"%d\\n%s\\n\", n, s.c_str());\n    } else if (type == \"all_questions\") {\n        // Generate a string of all '?'\n        string s(n, '?');\n        printf(\"%d\\n%s\\n\", n, s.c_str());\n    } else if (type == \"no_questions\") {\n        // Generate a string of all letters\n        string s;\n        for (int i = 0; i < n; ++i) {\n            s += randomLetter();\n        }\n        printf(\"%d\\n%s\\n\", n, s.c_str());\n    } else if (type == \"q_lt_n_over_2\") {\n        // Generate a string with number of '?' less than n/2\n        int q = rnd.next(0, max(0, n / 2 - 1)); // q < n/2\n        vector<int> positions(n);\n        iota(positions.begin(), positions.end(), 0);\n        shuffle(positions.begin(), positions.end());\n        set<int> question_positions(positions.begin(), positions.begin() + q);\n\n        string s(n, 'a'); // Initialize with some letter\n        for (int i = 0; i < n; ++i) {\n            if (question_positions.count(i))\n                s[i] = '?';\n            else\n                s[i] = randomLetter();\n        }\n        printf(\"%d\\n%s\\n\", n, s.c_str());\n    } else if (type == \"n_odd\") {\n        // Ensure n is odd\n        if (n % 2 == 0) n += 1;\n        string s;\n        for (int i = 0; i < n; ++i) {\n            if (rnd.next(2) == 0)\n                s += '?';\n            else\n                s += randomLetter();\n        }\n        printf(\"%d\\n%s\\n\", n, s.c_str());\n    } else if (type == \"answer_zero\") {\n        // Generate a test case where the answer is zero\n        if (n % 2 == 1) {\n            // n is odd, answer is zero\n            string s;\n            for (int i = 0; i < n; ++i) {\n                s += randomLetter();\n            }\n            printf(\"%d\\n%s\\n\", n, s.c_str());\n        } else {\n            // n is even, make number of '?' less than n/2\n            int q = rnd.next(0, max(0, n / 2 - 1)); // q < n/2\n            vector<int> positions(n);\n            iota(positions.begin(), positions.end(), 0);\n            shuffle(positions.begin(), positions.end());\n            set<int> question_positions(positions.begin(), positions.begin() + q);\n\n            string s(n, 'a'); // Initialize with some letter\n            for (int i = 0; i < n; ++i) {\n                if (question_positions.count(i))\n                    s[i] = '?';\n                else\n                    s[i] = randomLetter();\n            }\n            printf(\"%d\\n%s\\n\", n, s.c_str());\n        }\n    } else if (type == \"answer_one\") {\n        // Generate a test case where the answer is one\n        if (n % 2 == 1 || n / 2 > 25) {\n            // Cannot generate a valid test case for answer one\n            // Output a simple case\n            n = 2;\n            printf(\"%d\\na?\\n\", n);\n        } else {\n            string s(n, '?');\n            for (int i = 0; i < n / 2; ++i) {\n                s[i] = 'a' + i;\n            }\n            printf(\"%d\\n%s\\n\", n, s.c_str());\n        }\n    } else if (type == \"max\") {\n        // Generate maximum size test case n = 100000\n        n = 100000;\n        string s;\n        for (int i = 0; i < n; ++i) {\n            s += randomLetter();\n        }\n        printf(\"%d\\n%s\\n\", n, s.c_str());\n    } else {\n        // Default case: generate a random string\n        string s;\n        for (int i = 0; i < n; ++i) {\n            if (rnd.next(2) == 0)\n                s += '?';\n            else\n                s += randomLetter();\n        }\n        printf(\"%d\\n%s\\n\", n, s.c_str());\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\n// Function to generate a random lowercase letter excluding 'x'\nchar randomLetter() {\n    int idx = rnd.next(25); // letters 'a'-'z' excluding 'x'\n    if (idx < ('x' - 'a')) return 'a' + idx;\n    else return 'a' + idx + 1;\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    // Read the parameters\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    if (type == \"random\") {\n        // Generate a random string of letters and '?' marks\n        string s;\n        for (int i = 0; i < n; ++i) {\n            if (rnd.next(2) == 0)\n                s += '?';\n            else\n                s += randomLetter();\n        }\n        printf(\"%d\\n%s\\n\", n, s.c_str());\n    } else if (type == \"all_questions\") {\n        // Generate a string of all '?'\n        string s(n, '?');\n        printf(\"%d\\n%s\\n\", n, s.c_str());\n    } else if (type == \"no_questions\") {\n        // Generate a string of all letters\n        string s;\n        for (int i = 0; i < n; ++i) {\n            s += randomLetter();\n        }\n        printf(\"%d\\n%s\\n\", n, s.c_str());\n    } else if (type == \"q_lt_n_over_2\") {\n        // Generate a string with number of '?' less than n/2\n        int q = rnd.next(0, max(0, n / 2 - 1)); // q < n/2\n        vector<int> positions(n);\n        iota(positions.begin(), positions.end(), 0);\n        shuffle(positions.begin(), positions.end());\n        set<int> question_positions(positions.begin(), positions.begin() + q);\n\n        string s(n, 'a'); // Initialize with some letter\n        for (int i = 0; i < n; ++i) {\n            if (question_positions.count(i))\n                s[i] = '?';\n            else\n                s[i] = randomLetter();\n        }\n        printf(\"%d\\n%s\\n\", n, s.c_str());\n    } else if (type == \"n_odd\") {\n        // Ensure n is odd\n        if (n % 2 == 0) n += 1;\n        string s;\n        for (int i = 0; i < n; ++i) {\n            if (rnd.next(2) == 0)\n                s += '?';\n            else\n                s += randomLetter();\n        }\n        printf(\"%d\\n%s\\n\", n, s.c_str());\n    } else if (type == \"answer_zero\") {\n        // Generate a test case where the answer is zero\n        if (n % 2 == 1) {\n            // n is odd, answer is zero\n            string s;\n            for (int i = 0; i < n; ++i) {\n                s += randomLetter();\n            }\n            printf(\"%d\\n%s\\n\", n, s.c_str());\n        } else {\n            // n is even, make number of '?' less than n/2\n            int q = rnd.next(0, max(0, n / 2 - 1)); // q < n/2\n            vector<int> positions(n);\n            iota(positions.begin(), positions.end(), 0);\n            shuffle(positions.begin(), positions.end());\n            set<int> question_positions(positions.begin(), positions.begin() + q);\n\n            string s(n, 'a'); // Initialize with some letter\n            for (int i = 0; i < n; ++i) {\n                if (question_positions.count(i))\n                    s[i] = '?';\n                else\n                    s[i] = randomLetter();\n            }\n            printf(\"%d\\n%s\\n\", n, s.c_str());\n        }\n    } else if (type == \"answer_one\") {\n        // Generate a test case where the answer is one\n        if (n % 2 == 1 || n / 2 > 25) {\n            // Cannot generate a valid test case for answer one\n            // Output a simple case\n            n = 2;\n            printf(\"%d\\na?\\n\", n);\n        } else {\n            string s(n, '?');\n            for (int i = 0; i < n / 2; ++i) {\n                s[i] = 'a' + i;\n            }\n            printf(\"%d\\n%s\\n\", n, s.c_str());\n        }\n    } else if (type == \"max\") {\n        // Generate maximum size test case n = 100000\n        n = 100000;\n        string s;\n        for (int i = 0; i < n; ++i) {\n            s += randomLetter();\n        }\n        printf(\"%d\\n%s\\n\", n, s.c_str());\n    } else {\n        // Default case: generate a random string\n        string s;\n        for (int i = 0; i < n; ++i) {\n            if (rnd.next(2) == 0)\n                s += '?';\n            else\n                s += randomLetter();\n        }\n        printf(\"%d\\n%s\\n\", n, s.c_str());\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -type random\n./gen -n 2 -type random\n./gen -n 3 -type n_odd\n./gen -n 10 -type random\n./gen -n 10 -type all_questions\n./gen -n 10 -type no_questions\n./gen -n 10 -type q_lt_n_over_2\n./gen -n 10 -type answer_zero\n./gen -n 10 -type answer_one\n\n./gen -n 100 -type random\n./gen -n 100 -type all_questions\n./gen -n 100 -type no_questions\n./gen -n 100 -type q_lt_n_over_2\n./gen -n 100 -type answer_zero\n./gen -n 100 -type answer_one\n\n./gen -n 1000 -type random\n./gen -n 1000 -type all_questions\n./gen -n 1000 -type no_questions\n./gen -n 1000 -type q_lt_n_over_2\n./gen -n 1000 -type answer_zero\n\n./gen -n 10000 -type random\n./gen -n 10000 -type all_questions\n./gen -n 10000 -type no_questions\n./gen -n 10000 -type answer_zero\n./gen -n 10000 -type answer_one\n\n./gen -n 99999 -type random\n./gen -n 100000 -type random\n./gen -n 100000 -type all_questions\n./gen -n 100000 -type no_questions\n./gen -n 100000 -type q_lt_n_over_2\n./gen -n 100000 -type answer_zero\n\n./gen -n 100001 -type n_odd\n./gen -type max\n./gen -n 50 -type answer_one\n./gen -n 50000 -type answer_one\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:06:58.005704",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "315/A",
      "title": "A. Sereja and Bottles",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains integer n (1 ≤ n ≤ 100) — the number of bottles. The next n lines contain the bottles' description. The i-th line contains two integers ai, bi (1 ≤ ai, bi ≤ 1000) — the description of the i-th bottle.",
      "output_spec": "OutputIn a single line print a single integer — the answer to the problem.",
      "sample_tests": "ExamplesInputCopy41 12 23 34 4OutputCopy4InputCopy41 22 33 44 1OutputCopy0",
      "description": "A. Sereja and Bottles\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains integer n (1 ≤ n ≤ 100) — the number of bottles. The next n lines contain the bottles' description. The i-th line contains two integers ai, bi (1 ≤ ai, bi ≤ 1000) — the description of the i-th bottle.\n\nOutputIn a single line print a single integer — the answer to the problem.\n\nInputCopy41 12 23 34 4OutputCopy4InputCopy41 22 33 44 1OutputCopy0\n\nInputCopy41 12 23 34 4\n\nOutputCopy4\n\nInputCopy41 22 33 44 1\n\nOutputCopy0",
      "solutions": [
        {
          "title": "Codeforces Round #187 - Codeforces",
          "content": "Hello everyone!Codeforces Round #187 will take place on Friday, June 7th at 19:30 MSK. This is my seventh Codeforces round and I hope not the last.I'd like to thank Gerald, Furko and Aksenov239 for helping me to prepare the round. Special thanks to Delinur for translation of all problem statements into English.I strongly recommend you to read ALL the problems.Gl & hf ! :)tutorial.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/7894",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 383
        },
        {
          "title": "Codeforces Round #187 tutorial - Codeforces",
          "content": "315A - Sereja and BottlesJust check for each bottle, can I open it with another. In this task can pass absolutely any solutions. 315B - Sereja and ArrayWe will support all of the elements in the array, but also we will supprt additionally variable add: how much to add to all the elements. Then to add some value to every element we simply increase the add. In the derivation we deduce the value of the array element + add. When you update the item we put to a value, value that you need to put minus the current value of add. 314A - Sereja and ContestNote that if we remove some of the participants, we never remove the participants with lower numbers as theirs amount will only increase. So just consider the sequence of all the participants, and if the participant does not fit we delete him. 314B - Sereja and PeriodsIt is clear that we can use greedy algorithm to look for the number of occurrences of the 2nd string in the first string, but it works too slow. To speed up the process, you can look at the first line of the string that specifies the second period. And the answer is divided into how many string you need to set the second string. Next, we consider our greedy algorithm. We are going by the first string, till we find the first character of the second string, then the second, third and so on until the last, then again find the first, second, and so the cycle. It is clear that if we stand in the same twice in a state in which the positions in the first string corresponds to one character string that determines the period and the position of the second string are the same, then we obtain the period. When we find this period, we can just repeat it as many times as possible. To better understand, I advise you to read any accepted solution. 314C - Sereja and SubsequencesIt is clear that we need to calculate the sum of the products of elements of all the different non-decreasing subsequences of given sequence. Let's go through the sequence from left to right and maintain the array q[i]: what means the sum of all relevant sub-sequences, such that their last element is equal to i. Clearly, if the next number is x, then you need to put q[x] = sum (q[1] + q[2] + ... + q[x]) * x + x. The answer to the problem is the sum of q[i]. To find all the amounts you can use Fenwick tree. 314D - Sereja and Straight LinesRoll all at 45 degrees using the transformation: (x, y) -> (x ', y'): x '= x + y, y' = x-y. Next you need to place two lines parallel to the coordinate axes. Sort the points by the first coordinate. Next, we use a binary search for the answer. May we have fixed a number, you now need to check whether it is enough or not. Note that now we need to put two strips of width 2 * fixed amount that they would have to cover all the points. Suppose that some point should be close to the left side of the vertical strip, then for all points that do not belong to the strip we find the minimum and maximum second coordinate. If the difference between the found coordinates no more then 2 * fixed quantity, the strip can be placed, otherwise — no. soon...",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/7905",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 315\\s*A"
          },
          "content_length": 3088
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #187 tutorial - Codeforces - Code 1",
          "code": "dp[i][j] = 25 * dp[i - 1][j - 1] + dp[i - 1][j + 1] otherwise. ('?' can be both: an opening and a closing bracket).",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7905",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #187 tutorial - Codeforces - Code 2",
          "code": "(x0, y0) --> (x1, y1)\nx0 = r * cos(a), y0 = r * sin(a)\nif a --> a + pi / 4\nx1 = r * cos(a + pi/4) = r * (cos(a) * cos(pi / 4) - sin(a) * sin(pi / 4)) \n   = 1 / sqrt(2) * (r * cos(a) - r * sin(a)) = 1 / sqrt(2) * (x0 - y0).\ny1 = r * sin(a + pi/4) = r * (sin(a) * cos(pi / 4) + cos(a) * sin(pi / 4)) \n   = 1 / sqrt(2) * (r * sin(a) + r * cos(a)) = 1 / sqrt(2) * (x0 + y0).\n\nSo, after rotating all the points 45 degrees and scale up all the coordinates with sqrt(2), (x0, y0) with be (x0 - y0, x0 + y0). \n\nAfter rotating, Manhattan distance ==> Chebyshev_distance. http://en.wikipedia.org/wiki/Chebyshev_distance",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7905",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #187 tutorial - Codeforces - Code 3",
          "code": "(x0, y0) --> (x1, y1)\nx0 = r * cos(a), y0 = r * sin(a)\nif a --> a + pi / 4\nx1 = r * cos(a + pi/4) = r * (cos(a) * cos(pi / 4) - sin(a) * sin(pi / 4)) \n   = 1 / sqrt(2) * (r * cos(a) - r * sin(a)) = 1 / sqrt(2) * (x0 - y0).\ny1 = r * sin(a + pi/4) = r * (sin(a) * cos(pi / 4) + cos(a) * sin(pi / 4)) \n   = 1 / sqrt(2) * (r * sin(a) + r * cos(a)) = 1 / sqrt(2) * (x0 + y0).\n\nSo, after rotating all the points 45 degrees and scale up all the coordinates with sqrt(2), (x0, y0) with be (x0 - y0, x0 + y0). \n\nAfter rotating, Manhattan distance ==> Chebyshev_distance. http://en.wikipedia.org/wiki/Chebyshev_distance",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7905",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #187 tutorial - Codeforces - Code 4",
          "code": "5\n1 1\n1 2\n2 3\n3 4\n4 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7905",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #187 tutorial - Codeforces - Code 5",
          "code": "5\n1 1\n1 2\n2 3\n3 4\n4 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7905",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #187 tutorial - Codeforces - Code 6",
          "code": "a_i == a_(i+1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7905",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[])\n{\n    registerValidation(argc, argv);\n\n    // Read n\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readEoln();\n\n    // For each of n lines\n    for(int i = 0; i < n; ++i)\n    {\n        // Read ai and bi\n        int ai = inf.readInt(1, 1000, \"ai\");\n\n        inf.readSpace();\n        \n        int bi = inf.readInt(1, 1000, \"bi\");\n        \n        inf.readEoln();\n    }\n\n    inf.readEof();\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[])\n{\n    registerValidation(argc, argv);\n\n    // Read n\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readEoln();\n\n    // For each of n lines\n    for(int i = 0; i < n; ++i)\n    {\n        // Read ai and bi\n        int ai = inf.readInt(1, 1000, \"ai\");\n\n        inf.readSpace();\n        \n        int bi = inf.readInt(1, 1000, \"bi\");\n        \n        inf.readEoln();\n    }\n\n    inf.readEof();\n\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[])\n{\n    registerValidation(argc, argv);\n\n    // Read n\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readEoln();\n\n    // For each of n lines\n    for(int i = 0; i < n; ++i)\n    {\n        // Read ai and bi\n        int ai = inf.readInt(1, 1000, \"ai\");\n\n        inf.readSpace();\n        \n        int bi = inf.readInt(1, 1000, \"bi\");\n        \n        inf.readEoln();\n    }\n\n    inf.readEof();\n\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    \n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n    \n    printf(\"%d\\n\", n);\n    vector<int> a(n), b(n);\n\n    if (type == \"all_unopenable\") {\n        // Generate ai and bi such that no bottle can open any other bottle.\n        // bi does not match any ai\n        for(int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, 500);\n        }\n        set<int> a_set(a.begin(), a.end());\n        int bi_value = 501;\n        for(int i = 0; i < n; ++i) {\n            while(a_set.count(bi_value)) {\n                ++bi_value;\n            }\n            b[i] = bi_value++;\n        }\n    } else if (type == \"all_openable\") {\n        // Generate ai and bi such that all bottles can be opened\n        // Ensure every bi matches some ai\n        for(int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, 1000);\n        }\n        for(int i = 0; i < n; ++i) {\n            b[i] = a[rnd.next(0, n-1)];\n        }\n    } else if (type == \"some_openable\") {\n        // Generate a mix of openable and unopenable bottles\n        for(int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, 1000);\n        }\n        set<int> a_set(a.begin(), a.end());\n        for(int i = 0; i < n; ++i) {\n            if (i % 2 == 0) {\n                b[i] = a[rnd.next(0, n-1)]; // Can be opened\n            } else {\n                int bi_value = 1001;\n                while(a_set.count(bi_value)) {\n                    ++bi_value;\n                }\n                b[i] = bi_value++; // Cannot be opened\n            }\n        }\n    } else if (type == \"max_ai_bi\") {\n        // Set ai and bi to maximum value 1000\n        for(int i = 0; i < n; ++i) {\n            a[i] = 1000;\n            b[i] = 1000;\n        }\n    } else if (type == \"min_ai_bi\") {\n        // Set ai and bi to minimum value 1\n        for(int i = 0; i < n; ++i) {\n            a[i] = 1;\n            b[i] = 1;\n        }\n    } else if (type == \"self_openable\") {\n        // Each bottle can open itself\n        for(int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, 1000);\n            b[i] = a[i];\n        }\n    } else if (type == \"non_self_openable\") {\n        // bi does not match any ai, including itself\n        for(int i = 0; i < n; ++i) {\n            a[i] = i + 1; // Unique ai\n        }\n        for(int i = 0; i < n; ++i) {\n            b[i] = n + i + 1; // bi values that are different from any ai\n        }\n    } else if (type == \"max_n\") {\n        // n == 100, generate random ai and bi\n        if (n != 100) {\n            cerr << \"Error: n must be 100 for type 'max_n'.\\n\";\n            return 1;\n        }\n        for(int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, 1000);\n            b[i] = rnd.next(1, 1000);\n        }\n    } else if (type == \"random\") {\n        for(int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, 1000);\n            b[i] = rnd.next(1, 1000);\n        }\n    } else {\n        // Default to random\n        for(int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, 1000);\n            b[i] = rnd.next(1, 1000);\n        }\n    }\n    \n    for(int i = 0; i < n; ++i) {\n        printf(\"%d %d\\n\", a[i], b[i]);\n    }\n    \n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    \n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n    \n    printf(\"%d\\n\", n);\n    vector<int> a(n), b(n);\n\n    if (type == \"all_unopenable\") {\n        // Generate ai and bi such that no bottle can open any other bottle.\n        // bi does not match any ai\n        for(int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, 500);\n        }\n        set<int> a_set(a.begin(), a.end());\n        int bi_value = 501;\n        for(int i = 0; i < n; ++i) {\n            while(a_set.count(bi_value)) {\n                ++bi_value;\n            }\n            b[i] = bi_value++;\n        }\n    } else if (type == \"all_openable\") {\n        // Generate ai and bi such that all bottles can be opened\n        // Ensure every bi matches some ai\n        for(int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, 1000);\n        }\n        for(int i = 0; i < n; ++i) {\n            b[i] = a[rnd.next(0, n-1)];\n        }\n    } else if (type == \"some_openable\") {\n        // Generate a mix of openable and unopenable bottles\n        for(int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, 1000);\n        }\n        set<int> a_set(a.begin(), a.end());\n        for(int i = 0; i < n; ++i) {\n            if (i % 2 == 0) {\n                b[i] = a[rnd.next(0, n-1)]; // Can be opened\n            } else {\n                int bi_value = 1001;\n                while(a_set.count(bi_value)) {\n                    ++bi_value;\n                }\n                b[i] = bi_value++; // Cannot be opened\n            }\n        }\n    } else if (type == \"max_ai_bi\") {\n        // Set ai and bi to maximum value 1000\n        for(int i = 0; i < n; ++i) {\n            a[i] = 1000;\n            b[i] = 1000;\n        }\n    } else if (type == \"min_ai_bi\") {\n        // Set ai and bi to minimum value 1\n        for(int i = 0; i < n; ++i) {\n            a[i] = 1;\n            b[i] = 1;\n        }\n    } else if (type == \"self_openable\") {\n        // Each bottle can open itself\n        for(int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, 1000);\n            b[i] = a[i];\n        }\n    } else if (type == \"non_self_openable\") {\n        // bi does not match any ai, including itself\n        for(int i = 0; i < n; ++i) {\n            a[i] = i + 1; // Unique ai\n        }\n        for(int i = 0; i < n; ++i) {\n            b[i] = n + i + 1; // bi values that are different from any ai\n        }\n    } else if (type == \"max_n\") {\n        // n == 100, generate random ai and bi\n        if (n != 100) {\n            cerr << \"Error: n must be 100 for type 'max_n'.\\n\";\n            return 1;\n        }\n        for(int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, 1000);\n            b[i] = rnd.next(1, 1000);\n        }\n    } else if (type == \"random\") {\n        for(int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, 1000);\n            b[i] = rnd.next(1, 1000);\n        }\n    } else {\n        // Default to random\n        for(int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, 1000);\n            b[i] = rnd.next(1, 1000);\n        }\n    }\n    \n    for(int i = 0; i < n; ++i) {\n        printf(\"%d %d\\n\", a[i], b[i]);\n    }\n    \n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -type min_ai_bi\n./gen -n 1 -type max_ai_bi\n\n./gen -n 2 -type all_unopenable\n./gen -n 2 -type all_openable\n\n./gen -n 5 -type random\n./gen -n 5 -type all_openable\n\n./gen -n 10 -type random\n./gen -n 10 -type self_openable\n./gen -n 10 -type non_self_openable\n./gen -n 10 -type some_openable\n\n./gen -n 50 -type random\n./gen -n 50 -type all_unopenable\n./gen -n 50 -type all_openable\n./gen -n 50 -type self_openable\n./gen -n 50 -type non_self_openable\n./gen -n 50 -type some_openable\n\n./gen -n 99 -type random\n./gen -n 99 -type all_unopenable\n./gen -n 99 -type all_openable\n./gen -n 99 -type self_openable\n./gen -n 99 -type non_self_openable\n./gen -n 99 -type some_openable\n\n./gen -n 100 -type random\n./gen -n 100 -type all_unopenable\n./gen -n 100 -type all_openable\n./gen -n 100 -type self_openable\n./gen -n 100 -type non_self_openable\n./gen -n 100 -type some_openable\n\n./gen -n 100 -type min_ai_bi\n./gen -n 100 -type max_ai_bi\n\n./gen -n 100 -type max_n\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:07:00.071531",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "315/B",
      "title": "B. Сережа и массив",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест1 секунда",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеВ первой строке записаны целые числа n, m (1 ≤ n, m ≤ 105). Во второй строке записаны n целых чисел через пробел a1, a2, ..., an (1 ≤ ai ≤ 109) — исходный массив.Следующие m строк описывают операции, i-ая строка описывает i-ую операцию. Первое число в i-ой строке — целое число ti (1 ≤ ti ≤ 3), которое обозначает тип операции. Если ti = 1, то далее следуют два целых числа vi и xi, (1 ≤ vi ≤ n, 1 ≤ xi ≤ 109). Если ti = 2, то далее следует целое число yi (1 ≤ yi ≤ 104). Если же ti = 3, то далее следует целое число qi (1 ≤ qi ≤ n).",
      "output_spec": "Выходные данныеДля каждой операции третьего типа выведите значение aqi. Значения выводите в порядке следования соответствующих запросов во входных данных.",
      "sample_tests": "ПримерыВходные данныеСкопировать10 111 2 3 4 5 6 7 8 9 103 23 92 103 13 101 1 102 102 103 13 103 9Выходные данныеСкопировать291120304039",
      "description": "B. Сережа и массив\n\nограничение по времени на тест1 секунда\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвыводstdout\n\nВходные данныеВ первой строке записаны целые числа n, m (1 ≤ n, m ≤ 105). Во второй строке записаны n целых чисел через пробел a1, a2, ..., an (1 ≤ ai ≤ 109) — исходный массив.Следующие m строк описывают операции, i-ая строка описывает i-ую операцию. Первое число в i-ой строке — целое число ti (1 ≤ ti ≤ 3), которое обозначает тип операции. Если ti = 1, то далее следуют два целых числа vi и xi, (1 ≤ vi ≤ n, 1 ≤ xi ≤ 109). Если ti = 2, то далее следует целое число yi (1 ≤ yi ≤ 104). Если же ti = 3, то далее следует целое число qi (1 ≤ qi ≤ n).\n\nВходные данные\n\nВыходные данныеДля каждой операции третьего типа выведите значение aqi. Значения выводите в порядке следования соответствующих запросов во входных данных.\n\nВыходные данные\n\nВходные данныеСкопировать10 111 2 3 4 5 6 7 8 9 103 23 92 103 13 101 1 102 102 103 13 103 9Выходные данныеСкопировать291120304039\n\nВходные данныеСкопировать10 111 2 3 4 5 6 7 8 9 103 23 92 103 13 101 1 102 102 103 13 103 9\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать291120304039\n\nВыходные данныеСкопировать\n\nСкопировать",
      "solutions": [
        {
          "title": "Codeforces Round #187 - Codeforces",
          "content": "Всем привет!Совсем скоро, 7 июня в 19:30 MSK состоится Codeforces Round #187, автором которого являюсь я. Это мой седьмой раунд на Codeforces и я надеюсь, что не последний.Спасибо Геральду Агапову (Gerald), Роману Фурко(Furko) и Аксенову Виталику(Aksenov239) за помощь в подготовке раунда и Марии Беловой (Delinur) за перевод условий на английский.Настоятельно рекомендую прочитать условия ВСЕХ задач.Gl & hf ! :)Разбор.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/7894",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 420
        },
        {
          "title": "Разбор Codeforces Round #187 - Codeforces",
          "content": "315A - Сережа и бутылкиПросто для каждой бутылки проверим, можно ли открыть ее другой. В данной задаче проходили абсолютно любые решения. 315B - Сережа и массивБудем поддерживать все элементы в массиве, но дополнительно заведем переменную add: сколько нужно добавить ко всем элементам. Тогда про добавлении ко всем элементам просто увеличим add. При выводе будем выводить элемент массива + величину add. При обновлении будем ставить элемент равным значению, которое нужно поставить минус текущая величина add. 314A - Сережа и контестЗаметим, что если мы удалили некоторого участника, то мы никогда не удалим участников с меньшими номерами, так как их сумма будет только увеличиваться. Поэтому просто последовательно рассмотрим всех участников, и если участник не подходит, то удалим его. 314B - Сережа и периодыПонятно, что можно жадно искать количество вхождений 2й строки в первой, но такое решение работает долго. Для ускорения процесса можно искать в первой строке строку, которая задает период второй. А ответ поделить на то, сколько строк нужно для задания второй строки. Далее рассмотрим наш жадный алгоритм. Мы идем по первой строке, пока не встретим первый символ второй строки, потом второй, третий и так далее до последнего, потом снова ищем первый, второй и так по циклу. Понятно, что когда мы дважды окажемся в состоянии, в котором позиции в первой строке соответствует одному символу строки, которая задает период и позиции во второй строке одинаковы, то мы получим период. Когда мы найдем этот период, то просто повторим его столько раз, сколько возможно, что бы каждый раз не считать одну и ту же информацию. Для лучшего понимая, советую прочитать любое прошедшее решение. 314C - Сережа и подпоследовательностиПонятно, что нужно посчитать сумму произведений элементов всех различных неубывающих подпоследовательностей заданной последовательности. Будем идти по последовательности слева направо и поддерживать массив q[i]: какая сумма всех нужных подпоследовательностей, таких что их последний элемент равен i. Понятно, что если очередное число это x, то нужно поставить q[x] = sum(q[1]+q[2]+...+q[x])*x+x. Ответом на задачу будет сумма всех q[i]. Для нахождения всех сумм можно использовать дерево Фенвика. 314D - Сережа и прямыеПовернем все на 45 градусов с помощью преобразования: (x, y) -> (x', y'): x' = x+y, y' = x-y.Далее нужно разместить две прямые параллельно осям координат. Отсортируем точки по первой координате. Далее будем использовать бинарный поиск по ответу. Пускай мы зафиксировали некоторое число, теперь нужно проверить хватит ли его, или нет. Заметим, что сейчас нужно разместить две полосы ширины 2 * зафиксированная величина, что бы ими покрыть все точки. Допустим, что некоторая точка будет прилегать к левой стороне вертикальной полосы, далее для всех точек, которые не попадают в полосу найдем минимальную и максимальную вторую координату. Если разница между найденными координатами не больше 2 * зафиксированная величина, то полосы разместить можно, иначе — нет. Скоро...",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/7905",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 315\\s*B"
          },
          "content_length": 3013
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #187 - Codeforces - Code 1",
          "code": "Мало того, что код написать,так и надо над оптимизацией думать",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7894",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #187 - Codeforces - Code 2",
          "code": "Мало того, что код написать,так и надо над оптимизацией думать",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7894",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #187 - Codeforces - Code 1",
          "code": "dp[i][j] = 25 * dp[i - 1][j - 1] + dp[i - 1][j + 1] otherwise. ('?' can be both: an opening and a closing bracket).",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7905",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #187 - Codeforces - Code 2",
          "code": "(x0, y0) --> (x1, y1)\nx0 = r * cos(a), y0 = r * sin(a)\nif a --> a + pi / 4\nx1 = r * cos(a + pi/4) = r * (cos(a) * cos(pi / 4) - sin(a) * sin(pi / 4)) \n   = 1 / sqrt(2) * (r * cos(a) - r * sin(a)) = 1 / sqrt(2) * (x0 - y0).\ny1 = r * sin(a + pi/4) = r * (sin(a) * cos(pi / 4) + cos(a) * sin(pi / 4)) \n   = 1 / sqrt(2) * (r * sin(a) + r * cos(a)) = 1 / sqrt(2) * (x0 + y0).\n\nSo, after rotating all the points 45 degrees and scale up all the coordinates with sqrt(2), (x0, y0) with be (x0 - y0, x0 + y0). \n\nAfter rotating, Manhattan distance ==> Chebyshev_distance. http://en.wikipedia.org/wiki/Chebyshev_distance",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7905",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #187 - Codeforces - Code 3",
          "code": "(x0, y0) --> (x1, y1)\nx0 = r * cos(a), y0 = r * sin(a)\nif a --> a + pi / 4\nx1 = r * cos(a + pi/4) = r * (cos(a) * cos(pi / 4) - sin(a) * sin(pi / 4)) \n   = 1 / sqrt(2) * (r * cos(a) - r * sin(a)) = 1 / sqrt(2) * (x0 - y0).\ny1 = r * sin(a + pi/4) = r * (sin(a) * cos(pi / 4) + cos(a) * sin(pi / 4)) \n   = 1 / sqrt(2) * (r * sin(a) + r * cos(a)) = 1 / sqrt(2) * (x0 + y0).\n\nSo, after rotating all the points 45 degrees and scale up all the coordinates with sqrt(2), (x0, y0) with be (x0 - y0, x0 + y0). \n\nAfter rotating, Manhattan distance ==> Chebyshev_distance. http://en.wikipedia.org/wiki/Chebyshev_distance",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7905",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #187 - Codeforces - Code 4",
          "code": "5\n1 1\n1 2\n2 3\n3 4\n4 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7905",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #187 - Codeforces - Code 5",
          "code": "5\n1 1\n1 2\n2 3\n3 4\n4 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7905",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #187 - Codeforces - Code 6",
          "code": "a_i == a_(i+1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7905",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    // Read n and m\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 100000, \"m\");\n    inf.readEoln();\n\n    // Read the array elements a_1 to a_n\n    for (int i = 1; i <= n; i++) {\n        if (i > 1)\n            inf.readSpace();\n        int a_i = inf.readInt(1, 1000000000, \"a_i\");\n    }\n    inf.readEoln();\n\n    // Read and validate each operation\n    for (int i = 0; i < m; i++) {\n        int t_i = inf.readInt(1, 3, \"t_i\");\n        if (t_i == 1) {\n            inf.readSpace();\n            int v_i = inf.readInt(1, n, \"v_i\");\n            inf.readSpace();\n            int x_i = inf.readInt(1, 1000000000, \"x_i\");\n        } else if (t_i == 2) {\n            inf.readSpace();\n            int y_i = inf.readInt(1, 10000, \"y_i\");\n        } else if (t_i == 3) {\n            inf.readSpace();\n            int q_i = inf.readInt(1, n, \"q_i\");\n        }\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    // Read n and m\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 100000, \"m\");\n    inf.readEoln();\n\n    // Read the array elements a_1 to a_n\n    for (int i = 1; i <= n; i++) {\n        if (i > 1)\n            inf.readSpace();\n        int a_i = inf.readInt(1, 1000000000, \"a_i\");\n    }\n    inf.readEoln();\n\n    // Read and validate each operation\n    for (int i = 0; i < m; i++) {\n        int t_i = inf.readInt(1, 3, \"t_i\");\n        if (t_i == 1) {\n            inf.readSpace();\n            int v_i = inf.readInt(1, n, \"v_i\");\n            inf.readSpace();\n            int x_i = inf.readInt(1, 1000000000, \"x_i\");\n        } else if (t_i == 2) {\n            inf.readSpace();\n            int y_i = inf.readInt(1, 10000, \"y_i\");\n        } else if (t_i == 3) {\n            inf.readSpace();\n            int q_i = inf.readInt(1, n, \"q_i\");\n        }\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    // Read n and m\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 100000, \"m\");\n    inf.readEoln();\n\n    // Read the array elements a_1 to a_n\n    for (int i = 1; i <= n; i++) {\n        if (i > 1)\n            inf.readSpace();\n        int a_i = inf.readInt(1, 1000000000, \"a_i\");\n    }\n    inf.readEoln();\n\n    // Read and validate each operation\n    for (int i = 0; i < m; i++) {\n        int t_i = inf.readInt(1, 3, \"t_i\");\n        if (t_i == 1) {\n            inf.readSpace();\n            int v_i = inf.readInt(1, n, \"v_i\");\n            inf.readSpace();\n            int x_i = inf.readInt(1, 1000000000, \"x_i\");\n        } else if (t_i == 2) {\n            inf.readSpace();\n            int y_i = inf.readInt(1, 10000, \"y_i\");\n        } else if (t_i == 3) {\n            inf.readSpace();\n            int q_i = inf.readInt(1, n, \"q_i\");\n        }\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    // Read parameters\n    int n;\n    int m = opt<int>(\"m\");\n    string type = opt<string>(\"type\", \"random\");\n\n    if (type == \"single_element\") {\n        n = 1;\n    } else {\n        n = opt<int>(\"n\");\n    }\n\n    // Generate the array a[]\n    vector<long long> a(n);\n    if (type == \"max_ai\") {\n        fill(a.begin(), a.end(), 1000000000LL);\n    } else if (type == \"min_ai\") {\n        fill(a.begin(), a.end(), 1LL);\n    } else if (type == \"single_element\") {\n        a[0] = rnd.next(1LL, 1000000000LL);\n    } else {\n        // Random ai in [1, 1e9]\n        for (int i = 0; i < n; ++i)\n            a[i] = rnd.next(1LL, 1000000000LL);\n    }\n\n    // Generate the m operations\n    vector<tuple<int,int,int>> ops; // ti, parameter1, parameter2 (if applicable)\n\n    if (type == \"all_type2\") {\n        for (int i = 0; i < m; ++i) {\n            int yi = rnd.next(1, 10000);\n            ops.emplace_back(2, yi, 0);\n        }\n    } else if (type == \"all_type3\") {\n        for (int i = 0; i < m; ++i) {\n            int qi = rnd.next(1, n);\n            ops.emplace_back(3, qi, 0);\n        }\n    } else if (type == \"all_type1\") {\n        for (int i = 0; i < m; ++i) {\n            int vi = rnd.next(1, n);\n            int xi = rnd.next(1, 1000000000);\n            ops.emplace_back(1, vi, xi);\n        }\n    } else if (type == \"alternating\") {\n        for (int i = 0; i < m; ++i) {\n            int ti = (i % 3) + 1; // Types 1,2,3 in order\n            if (ti == 1) {\n                int vi = rnd.next(1, n);\n                int xi = rnd.next(1, 1000000000);\n                ops.emplace_back(1, vi, xi);\n            } else if (ti == 2) {\n                int yi = rnd.next(1, 10000);\n                ops.emplace_back(2, yi, 0);\n            } else if (ti == 3) {\n                int qi = rnd.next(1, n);\n                ops.emplace_back(3, qi, 0);\n            }\n        }\n    } else if (type == \"max_increment\") {\n        // Maximize accumulated increment to check for overflows\n        for (int i = 0; i < m; ++i) {\n            int ti = rnd.next(1, 3);\n            if (ti == 1) {\n                int vi = rnd.next(1, n);\n                int xi = rnd.next(1, 1000000000);\n                ops.emplace_back(1, vi, xi);\n            } else if (ti == 2) {\n                int yi = 10000;\n                ops.emplace_back(2, yi, 0);\n            } else if (ti == 3) {\n                int qi = rnd.next(1, n);\n                ops.emplace_back(3, qi, 0);\n            }\n        }\n    } else if (type == \"min_increment\") {\n        // yi = 1\n        for (int i = 0; i < m; ++i) {\n            int ti = rnd.next(1, 3);\n            if (ti == 1) {\n                int vi = rnd.next(1, n);\n                int xi = rnd.next(1, 1000000000);\n                ops.emplace_back(1, vi, xi);\n            } else if (ti == 2) {\n                int yi = 1;\n                ops.emplace_back(2, yi, 0);\n            } else if (ti == 3) {\n                int qi = rnd.next(1, n);\n                ops.emplace_back(3, qi, 0);\n            }\n        }\n    } else if (type == \"single_element\") {\n        for (int i = 0; i < m; ++i) {\n            int ti = rnd.next(1, 3);\n            if (ti == 1) {\n                int vi = 1;\n                int xi = rnd.next(1, 1000000000);\n                ops.emplace_back(1, vi, xi);\n            } else if (ti == 2) {\n                int yi = rnd.next(1, 10000);\n                ops.emplace_back(2, yi, 0);\n            } else if (ti == 3) {\n                int qi = 1;\n                ops.emplace_back(3, qi, 0);\n            }\n        }\n    } else {\n        // Random test case\n        for (int i = 0; i < m; ++i) {\n            int ti = rnd.next(1, 3);\n            if (ti == 1) {\n                int vi = rnd.next(1, n);\n                int xi = rnd.next(1, 1000000000);\n                ops.emplace_back(1, vi, xi);\n            } else if (ti == 2) {\n                int yi = rnd.next(1, 10000);\n                ops.emplace_back(2, yi, 0);\n            } else if (ti == 3) {\n                int qi = rnd.next(1, n);\n                ops.emplace_back(3, qi, 0);\n            }\n        }\n    }\n\n    // Output\n    printf(\"%d %d\\n\", n, m);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%lld%c\", a[i], i == n-1 ? '\\n' : ' ');\n    }\n\n    for (auto op : ops) {\n        int ti = get<0>(op);\n        int p1 = get<1>(op);\n        int p2 = get<2>(op);\n        if (ti == 1) {\n            printf(\"1 %d %d\\n\", p1, p2);\n        } else if (ti == 2) {\n            printf(\"2 %d\\n\", p1);\n        } else if (ti == 3) {\n            printf(\"3 %d\\n\", p1);\n        }\n    }\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    // Read parameters\n    int n;\n    int m = opt<int>(\"m\");\n    string type = opt<string>(\"type\", \"random\");\n\n    if (type == \"single_element\") {\n        n = 1;\n    } else {\n        n = opt<int>(\"n\");\n    }\n\n    // Generate the array a[]\n    vector<long long> a(n);\n    if (type == \"max_ai\") {\n        fill(a.begin(), a.end(), 1000000000LL);\n    } else if (type == \"min_ai\") {\n        fill(a.begin(), a.end(), 1LL);\n    } else if (type == \"single_element\") {\n        a[0] = rnd.next(1LL, 1000000000LL);\n    } else {\n        // Random ai in [1, 1e9]\n        for (int i = 0; i < n; ++i)\n            a[i] = rnd.next(1LL, 1000000000LL);\n    }\n\n    // Generate the m operations\n    vector<tuple<int,int,int>> ops; // ti, parameter1, parameter2 (if applicable)\n\n    if (type == \"all_type2\") {\n        for (int i = 0; i < m; ++i) {\n            int yi = rnd.next(1, 10000);\n            ops.emplace_back(2, yi, 0);\n        }\n    } else if (type == \"all_type3\") {\n        for (int i = 0; i < m; ++i) {\n            int qi = rnd.next(1, n);\n            ops.emplace_back(3, qi, 0);\n        }\n    } else if (type == \"all_type1\") {\n        for (int i = 0; i < m; ++i) {\n            int vi = rnd.next(1, n);\n            int xi = rnd.next(1, 1000000000);\n            ops.emplace_back(1, vi, xi);\n        }\n    } else if (type == \"alternating\") {\n        for (int i = 0; i < m; ++i) {\n            int ti = (i % 3) + 1; // Types 1,2,3 in order\n            if (ti == 1) {\n                int vi = rnd.next(1, n);\n                int xi = rnd.next(1, 1000000000);\n                ops.emplace_back(1, vi, xi);\n            } else if (ti == 2) {\n                int yi = rnd.next(1, 10000);\n                ops.emplace_back(2, yi, 0);\n            } else if (ti == 3) {\n                int qi = rnd.next(1, n);\n                ops.emplace_back(3, qi, 0);\n            }\n        }\n    } else if (type == \"max_increment\") {\n        // Maximize accumulated increment to check for overflows\n        for (int i = 0; i < m; ++i) {\n            int ti = rnd.next(1, 3);\n            if (ti == 1) {\n                int vi = rnd.next(1, n);\n                int xi = rnd.next(1, 1000000000);\n                ops.emplace_back(1, vi, xi);\n            } else if (ti == 2) {\n                int yi = 10000;\n                ops.emplace_back(2, yi, 0);\n            } else if (ti == 3) {\n                int qi = rnd.next(1, n);\n                ops.emplace_back(3, qi, 0);\n            }\n        }\n    } else if (type == \"min_increment\") {\n        // yi = 1\n        for (int i = 0; i < m; ++i) {\n            int ti = rnd.next(1, 3);\n            if (ti == 1) {\n                int vi = rnd.next(1, n);\n                int xi = rnd.next(1, 1000000000);\n                ops.emplace_back(1, vi, xi);\n            } else if (ti == 2) {\n                int yi = 1;\n                ops.emplace_back(2, yi, 0);\n            } else if (ti == 3) {\n                int qi = rnd.next(1, n);\n                ops.emplace_back(3, qi, 0);\n            }\n        }\n    } else if (type == \"single_element\") {\n        for (int i = 0; i < m; ++i) {\n            int ti = rnd.next(1, 3);\n            if (ti == 1) {\n                int vi = 1;\n                int xi = rnd.next(1, 1000000000);\n                ops.emplace_back(1, vi, xi);\n            } else if (ti == 2) {\n                int yi = rnd.next(1, 10000);\n                ops.emplace_back(2, yi, 0);\n            } else if (ti == 3) {\n                int qi = 1;\n                ops.emplace_back(3, qi, 0);\n            }\n        }\n    } else {\n        // Random test case\n        for (int i = 0; i < m; ++i) {\n            int ti = rnd.next(1, 3);\n            if (ti == 1) {\n                int vi = rnd.next(1, n);\n                int xi = rnd.next(1, 1000000000);\n                ops.emplace_back(1, vi, xi);\n            } else if (ti == 2) {\n                int yi = rnd.next(1, 10000);\n                ops.emplace_back(2, yi, 0);\n            } else if (ti == 3) {\n                int qi = rnd.next(1, n);\n                ops.emplace_back(3, qi, 0);\n            }\n        }\n    }\n\n    // Output\n    printf(\"%d %d\\n\", n, m);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%lld%c\", a[i], i == n-1 ? '\\n' : ' ');\n    }\n\n    for (auto op : ops) {\n        int ti = get<0>(op);\n        int p1 = get<1>(op);\n        int p2 = get<2>(op);\n        if (ti == 1) {\n            printf(\"1 %d %d\\n\", p1, p2);\n        } else if (ti == 2) {\n            printf(\"2 %d\\n\", p1);\n        } else if (ti == 3) {\n            printf(\"3 %d\\n\", p1);\n        }\n    }\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -m 0 -type random\n./gen -n 1 -m 1 -type random\n./gen -n 1 -m 10 -type random\n\n./gen -n 100 -m 100 -type random\n./gen -n 1000 -m 1000 -type random\n./gen -n 100000 -m 100000 -type random\n\n./gen -n 100000 -m 100000 -type max_ai\n./gen -n 100000 -m 100000 -type min_ai\n\n./gen -n 100000 -m 100000 -type all_type2\n./gen -n 100000 -m 100000 -type all_type3\n./gen -n 100000 -m 100000 -type all_type1\n./gen -n 100000 -m 100000 -type alternating\n\n./gen -n 100000 -m 100000 -type max_increment\n./gen -n 100000 -m 100000 -type min_increment\n\n./gen -m 100000 -type single_element\n\n./gen -n 1 -m 100000 -type random\n\n./gen -n 2 -m 100000 -type random\n\n./gen -n 1000 -m 100000 -type random\n\n./gen -n 100000 -m 100000 -type random\n\n./gen -n 50000 -m 100000 -type random\n\n./gen -n 99999 -m 100000 -type random\n\n./gen -n 1 -m 100000 -type max_increment\n\n./gen -n 1 -m 100000 -type min_increment\n\n./gen -n 100000 -m 0 -type random\n\n./gen -n 100000 -m 1 -type random\n\n./gen -n 100000 -m 100000 -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:07:02.204823",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "315/C",
      "title": "C. Sereja and Contest",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains two integers n, k (1 ≤ n ≤ 2·105,  - 109 ≤ k ≤ 0). The second line contains n space-separated integers a1, a2, ..., an (1 ≤ ai ≤ 109) — ratings of the participants in the initial table.",
      "output_spec": "OutputPrint the numbers of participants in the order in which they were removed from the table. Print the initial numbers of the participants, that is, the numbers that the participants had in the initial table.",
      "sample_tests": "ExamplesInputCopy5 05 3 4 1 2OutputCopy234InputCopy10 -105 5 1 7 5 1 2 4 9 2OutputCopy245789",
      "description": "C. Sereja and Contest\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains two integers n, k (1 ≤ n ≤ 2·105,  - 109 ≤ k ≤ 0). The second line contains n space-separated integers a1, a2, ..., an (1 ≤ ai ≤ 109) — ratings of the participants in the initial table.\n\nOutputPrint the numbers of participants in the order in which they were removed from the table. Print the initial numbers of the participants, that is, the numbers that the participants had in the initial table.\n\nInputCopy5 05 3 4 1 2OutputCopy234InputCopy10 -105 5 1 7 5 1 2 4 9 2OutputCopy245789\n\nInputCopy5 05 3 4 1 2\n\nOutputCopy234\n\nInputCopy10 -105 5 1 7 5 1 2 4 9 2\n\nOutputCopy245789\n\nNoteConsider the first test sample.  Initially the sequence of the contest participants' ratings equals [5, 3, 4, 1, 2]. You can use this sequence to calculate the sequence of rating changes: [0, -9, -13, 8, 14]. According to the problem statement, the application of the participant who won the second place will be considered first. As soon as the second place winner is out from the ratings, the participants' rating sequence will equal [5, 4, 1, 2]. By this sequence you can count the new sequence of rating changes: [0, -8, 2, 6]. According to the problem statement, the application of the participant who won the second place will be considered. Initially this participant won third place. The new rating sequence equals [5, 1, 2], the new sequence of rating changes equals [0, -1, 1]. The second place participant's application is taken into consideration, initially this participant won the fourth place. The new rating sequence equals [5, 2], the new sequence of rating changes equals [0, 0]. No more applications will be considered. Thus, you should print 2, 3, 4.",
      "solutions": [
        {
          "title": "Codeforces Round #187 - Codeforces",
          "content": "Hello everyone!Codeforces Round #187 will take place on Friday, June 7th at 19:30 MSK. This is my seventh Codeforces round and I hope not the last.I'd like to thank Gerald, Furko and Aksenov239 for helping me to prepare the round. Special thanks to Delinur for translation of all problem statements into English.I strongly recommend you to read ALL the problems.Gl & hf ! :)tutorial.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/7894",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 383
        },
        {
          "title": "Codeforces Round #187 tutorial - Codeforces",
          "content": "315A - Sereja and BottlesJust check for each bottle, can I open it with another. In this task can pass absolutely any solutions. 315B - Sereja and ArrayWe will support all of the elements in the array, but also we will supprt additionally variable add: how much to add to all the elements. Then to add some value to every element we simply increase the add. In the derivation we deduce the value of the array element + add. When you update the item we put to a value, value that you need to put minus the current value of add. 314A - Sereja and ContestNote that if we remove some of the participants, we never remove the participants with lower numbers as theirs amount will only increase. So just consider the sequence of all the participants, and if the participant does not fit we delete him. 314B - Sereja and PeriodsIt is clear that we can use greedy algorithm to look for the number of occurrences of the 2nd string in the first string, but it works too slow. To speed up the process, you can look at the first line of the string that specifies the second period. And the answer is divided into how many string you need to set the second string. Next, we consider our greedy algorithm. We are going by the first string, till we find the first character of the second string, then the second, third and so on until the last, then again find the first, second, and so the cycle. It is clear that if we stand in the same twice in a state in which the positions in the first string corresponds to one character string that determines the period and the position of the second string are the same, then we obtain the period. When we find this period, we can just repeat it as many times as possible. To better understand, I advise you to read any accepted solution. 314C - Sereja and SubsequencesIt is clear that we need to calculate the sum of the products of elements of all the different non-decreasing subsequences of given sequence. Let's go through the sequence from left to right and maintain the array q[i]: what means the sum of all relevant sub-sequences, such that their last element is equal to i. Clearly, if the next number is x, then you need to put q[x] = sum (q[1] + q[2] + ... + q[x]) * x + x. The answer to the problem is the sum of q[i]. To find all the amounts you can use Fenwick tree. 314D - Sereja and Straight LinesRoll all at 45 degrees using the transformation: (x, y) -> (x ', y'): x '= x + y, y' = x-y. Next you need to place two lines parallel to the coordinate axes. Sort the points by the first coordinate. Next, we use a binary search for the answer. May we have fixed a number, you now need to check whether it is enough or not. Note that now we need to put two strips of width 2 * fixed amount that they would have to cover all the points. Suppose that some point should be close to the left side of the vertical strip, then for all points that do not belong to the strip we find the minimum and maximum second coordinate. If the difference between the found coordinates no more then 2 * fixed quantity, the strip can be placed, otherwise — no. soon...",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/7905",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.6,
            "reason": "宽松匹配: 包含题目编号 315 和字母"
          },
          "content_length": 3088
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #187 tutorial - Codeforces - Code 1",
          "code": "dp[i][j] = 25 * dp[i - 1][j - 1] + dp[i - 1][j + 1] otherwise. ('?' can be both: an opening and a closing bracket).",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7905",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #187 tutorial - Codeforces - Code 2",
          "code": "(x0, y0) --> (x1, y1)\nx0 = r * cos(a), y0 = r * sin(a)\nif a --> a + pi / 4\nx1 = r * cos(a + pi/4) = r * (cos(a) * cos(pi / 4) - sin(a) * sin(pi / 4)) \n   = 1 / sqrt(2) * (r * cos(a) - r * sin(a)) = 1 / sqrt(2) * (x0 - y0).\ny1 = r * sin(a + pi/4) = r * (sin(a) * cos(pi / 4) + cos(a) * sin(pi / 4)) \n   = 1 / sqrt(2) * (r * sin(a) + r * cos(a)) = 1 / sqrt(2) * (x0 + y0).\n\nSo, after rotating all the points 45 degrees and scale up all the coordinates with sqrt(2), (x0, y0) with be (x0 - y0, x0 + y0). \n\nAfter rotating, Manhattan distance ==> Chebyshev_distance. http://en.wikipedia.org/wiki/Chebyshev_distance",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7905",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #187 tutorial - Codeforces - Code 3",
          "code": "(x0, y0) --> (x1, y1)\nx0 = r * cos(a), y0 = r * sin(a)\nif a --> a + pi / 4\nx1 = r * cos(a + pi/4) = r * (cos(a) * cos(pi / 4) - sin(a) * sin(pi / 4)) \n   = 1 / sqrt(2) * (r * cos(a) - r * sin(a)) = 1 / sqrt(2) * (x0 - y0).\ny1 = r * sin(a + pi/4) = r * (sin(a) * cos(pi / 4) + cos(a) * sin(pi / 4)) \n   = 1 / sqrt(2) * (r * sin(a) + r * cos(a)) = 1 / sqrt(2) * (x0 + y0).\n\nSo, after rotating all the points 45 degrees and scale up all the coordinates with sqrt(2), (x0, y0) with be (x0 - y0, x0 + y0). \n\nAfter rotating, Manhattan distance ==> Chebyshev_distance. http://en.wikipedia.org/wiki/Chebyshev_distance",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7905",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #187 tutorial - Codeforces - Code 4",
          "code": "5\n1 1\n1 2\n2 3\n3 4\n4 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7905",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #187 tutorial - Codeforces - Code 5",
          "code": "5\n1 1\n1 2\n2 3\n3 4\n4 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7905",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #187 tutorial - Codeforces - Code 6",
          "code": "a_i == a_(i+1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7905",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    // Read n and k\n    int n = inf.readInt(1, 200000, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(-1000000000, 0, \"k\");\n    inf.readEoln();\n\n    // Read n integers a_i\n    vector<int> a = inf.readInts(n, 1, 1000000000, \"a_i\");\n    inf.readEoln();\n\n    // Check EOF\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    // Read n and k\n    int n = inf.readInt(1, 200000, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(-1000000000, 0, \"k\");\n    inf.readEoln();\n\n    // Read n integers a_i\n    vector<int> a = inf.readInts(n, 1, 1000000000, \"a_i\");\n    inf.readEoln();\n\n    // Check EOF\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    // Read n and k\n    int n = inf.readInt(1, 200000, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(-1000000000, 0, \"k\");\n    inf.readEoln();\n\n    // Read n integers a_i\n    vector<int> a = inf.readInts(n, 1, 1000000000, \"a_i\");\n    inf.readEoln();\n\n    // Check EOF\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int k = opt<int>(\"k\");\n    string type = opt<string>(\"type\", \"random\");\n    int maxRating = opt<int>(\"maxRating\", 1000000000);\n    int minRating = opt<int>(\"minRating\", 1);\n\n    vector<int> a(n);\n\n    if (type == \"random\") {\n        for (int i = 0; i < n; ++i)\n            a[i] = rnd.next(minRating, maxRating);\n    } else if (type == \"inc\") {\n        for (int i = 0; i < n; ++i)\n            a[i] = minRating + (long long)(maxRating - minRating) * i / max(1, n - 1);\n    } else if (type == \"dec\") {\n        for (int i = 0; i < n; ++i)\n            a[i] = maxRating - (long long)(maxRating - minRating) * i / max(1, n - 1);\n    } else if (type == \"same\") {\n        int value = opt<int>(\"value\", maxRating / 2);\n        for (int i = 0; i < n; ++i)\n            a[i] = value;\n    } else if (type == \"onebig\") {\n        for (int i = 0; i < n; ++i)\n            a[i] = minRating;\n        int bigIndex = opt<int>(\"bigIndex\", 0) % n;\n        a[bigIndex] = maxRating;\n    } else if (type == \"alternating\") {\n        for (int i = 0; i < n; ++i)\n            a[i] = (i % 2 == 0) ? maxRating : minRating;\n    } else if (type == \"minimum\") {\n        for (int i = 0; i < n; ++i)\n            a[i] = minRating;\n    } else if (type == \"maximum\") {\n        for (int i = 0; i < n; ++i)\n            a[i] = maxRating;\n    } else {\n        // Default to random\n        for (int i = 0; i < n; ++i)\n            a[i] = rnd.next(minRating, maxRating);\n    }\n\n    // Output n and k\n    printf(\"%d %d\\n\", n, k);\n    // Output a_i\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d%c\", a[i], i == n - 1 ? '\\n' : ' ');\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int k = opt<int>(\"k\");\n    string type = opt<string>(\"type\", \"random\");\n    int maxRating = opt<int>(\"maxRating\", 1000000000);\n    int minRating = opt<int>(\"minRating\", 1);\n\n    vector<int> a(n);\n\n    if (type == \"random\") {\n        for (int i = 0; i < n; ++i)\n            a[i] = rnd.next(minRating, maxRating);\n    } else if (type == \"inc\") {\n        for (int i = 0; i < n; ++i)\n            a[i] = minRating + (long long)(maxRating - minRating) * i / max(1, n - 1);\n    } else if (type == \"dec\") {\n        for (int i = 0; i < n; ++i)\n            a[i] = maxRating - (long long)(maxRating - minRating) * i / max(1, n - 1);\n    } else if (type == \"same\") {\n        int value = opt<int>(\"value\", maxRating / 2);\n        for (int i = 0; i < n; ++i)\n            a[i] = value;\n    } else if (type == \"onebig\") {\n        for (int i = 0; i < n; ++i)\n            a[i] = minRating;\n        int bigIndex = opt<int>(\"bigIndex\", 0) % n;\n        a[bigIndex] = maxRating;\n    } else if (type == \"alternating\") {\n        for (int i = 0; i < n; ++i)\n            a[i] = (i % 2 == 0) ? maxRating : minRating;\n    } else if (type == \"minimum\") {\n        for (int i = 0; i < n; ++i)\n            a[i] = minRating;\n    } else if (type == \"maximum\") {\n        for (int i = 0; i < n; ++i)\n            a[i] = maxRating;\n    } else {\n        // Default to random\n        for (int i = 0; i < n; ++i)\n            a[i] = rnd.next(minRating, maxRating);\n    }\n\n    // Output n and k\n    printf(\"%d %d\\n\", n, k);\n    // Output a_i\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d%c\", a[i], i == n - 1 ? '\\n' : ' ');\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Small test cases\n./gen -n 1 -k 0 -type same\n./gen -n 2 -k -1 -type random\n./gen -n 5 -k 0 -type inc\n./gen -n 5 -k -100 -type dec\n./gen -n 10 -k 0 -type same -value 1000000\n./gen -n 10 -k -100 -type onebig -bigIndex 5\n\n# Edge cases for k\n./gen -n 100 -k 0 -type random\n./gen -n 100 -k -1000000000 -type random\n./gen -n 100 -k -1 -type random\n\n# Edge cases for n\n./gen -n 200000 -k 0 -type random\n./gen -n 200000 -k -1000000000 -type random\n\n# Max rating values\n./gen -n 1000 -k 0 -type maximum\n./gen -n 1000 -k -1000000000 -type minimum\n./gen -n 1000 -k -500000000 -type alternating\n\n# Increasing and decreasing ratings\n./gen -n 200000 -k 0 -type inc\n./gen -n 200000 -k -1 -type dec\n\n# All participants have same rating\n./gen -n 200000 -k 0 -type same -value 500000000\n./gen -n 200000 -k -1 -type same -value 1\n\n# One participant has a high rating\n./gen -n 200000 -k 0 -type onebig -bigIndex 0\n./gen -n 200000 -k -1 -type onebig -bigIndex 199999\n\n# Alternating ratings to test the removal process\n./gen -n 200000 -k -1000000000 -type alternating\n\n# Worst-case scenario for removal process\n./gen -n 200000 -k -1 -type worstcase\n\n# Random with different min and max ratings\n./gen -n 200000 -k 0 -type random -minRating 1 -maxRating 1000\n./gen -n 200000 -k -500000000 -type random -minRating 1 -maxRating 1000000000\n\n# Random small n with large ratings\n./gen -n 100 -k -1000 -type random -minRating 100000000 -maxRating 1000000000\n\n# Random large n with small ratings\n./gen -n 200000 -k -1000 -type random -minRating 1 -maxRating 10\n\n# Mixing types\n./gen -n 200000 -k -1000 -type random\n./gen -n 200000 -k 0 -type random\n./gen -n 200000 -k -1 -type random\n\n# Test with k = -1e9 and maximal ratings\n./gen -n 200000 -k -1000000000 -type maximum\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:07:04.328385",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "315/D",
      "title": "D. Sereja and Periods",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains two integers b, d (1 ≤ b, d ≤ 107). The second line contains string a. The third line contains string c. The given strings are not empty and consist of lowercase English letters. Their lengths do not exceed 100.",
      "output_spec": "OutputIn a single line print an integer — the largest number p. If the required value of p doesn't exist, print 0.",
      "sample_tests": "ExamplesInputCopy10 3ababbabOutputCopy3",
      "description": "D. Sereja and Periods\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains two integers b, d (1 ≤ b, d ≤ 107). The second line contains string a. The third line contains string c. The given strings are not empty and consist of lowercase English letters. Their lengths do not exceed 100.\n\nOutputIn a single line print an integer — the largest number p. If the required value of p doesn't exist, print 0.\n\nInputCopy10 3ababbabOutputCopy3\n\nInputCopy10 3ababbab\n\nOutputCopy3",
      "solutions": [
        {
          "title": "Codeforces Round #187 - Codeforces",
          "content": "Hello everyone!Codeforces Round #187 will take place on Friday, June 7th at 19:30 MSK. This is my seventh Codeforces round and I hope not the last.I'd like to thank Gerald, Furko and Aksenov239 for helping me to prepare the round. Special thanks to Delinur for translation of all problem statements into English.I strongly recommend you to read ALL the problems.Gl & hf ! :)tutorial.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/7894",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 383
        },
        {
          "title": "Codeforces Round #187 tutorial - Codeforces",
          "content": "315A - Sereja and BottlesJust check for each bottle, can I open it with another. In this task can pass absolutely any solutions. 315B - Sereja and ArrayWe will support all of the elements in the array, but also we will supprt additionally variable add: how much to add to all the elements. Then to add some value to every element we simply increase the add. In the derivation we deduce the value of the array element + add. When you update the item we put to a value, value that you need to put minus the current value of add. 314A - Sereja and ContestNote that if we remove some of the participants, we never remove the participants with lower numbers as theirs amount will only increase. So just consider the sequence of all the participants, and if the participant does not fit we delete him. 314B - Sereja and PeriodsIt is clear that we can use greedy algorithm to look for the number of occurrences of the 2nd string in the first string, but it works too slow. To speed up the process, you can look at the first line of the string that specifies the second period. And the answer is divided into how many string you need to set the second string. Next, we consider our greedy algorithm. We are going by the first string, till we find the first character of the second string, then the second, third and so on until the last, then again find the first, second, and so the cycle. It is clear that if we stand in the same twice in a state in which the positions in the first string corresponds to one character string that determines the period and the position of the second string are the same, then we obtain the period. When we find this period, we can just repeat it as many times as possible. To better understand, I advise you to read any accepted solution. 314C - Sereja and SubsequencesIt is clear that we need to calculate the sum of the products of elements of all the different non-decreasing subsequences of given sequence. Let's go through the sequence from left to right and maintain the array q[i]: what means the sum of all relevant sub-sequences, such that their last element is equal to i. Clearly, if the next number is x, then you need to put q[x] = sum (q[1] + q[2] + ... + q[x]) * x + x. The answer to the problem is the sum of q[i]. To find all the amounts you can use Fenwick tree. 314D - Sereja and Straight LinesRoll all at 45 degrees using the transformation: (x, y) -> (x ', y'): x '= x + y, y' = x-y. Next you need to place two lines parallel to the coordinate axes. Sort the points by the first coordinate. Next, we use a binary search for the answer. May we have fixed a number, you now need to check whether it is enough or not. Note that now we need to put two strips of width 2 * fixed amount that they would have to cover all the points. Suppose that some point should be close to the left side of the vertical strip, then for all points that do not belong to the strip we find the minimum and maximum second coordinate. If the difference between the found coordinates no more then 2 * fixed quantity, the strip can be placed, otherwise — no. soon...",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/7905",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.6,
            "reason": "宽松匹配: 包含题目编号 315 和字母"
          },
          "content_length": 3088
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #187 tutorial - Codeforces - Code 1",
          "code": "dp[i][j] = 25 * dp[i - 1][j - 1] + dp[i - 1][j + 1] otherwise. ('?' can be both: an opening and a closing bracket).",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7905",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #187 tutorial - Codeforces - Code 2",
          "code": "(x0, y0) --> (x1, y1)\nx0 = r * cos(a), y0 = r * sin(a)\nif a --> a + pi / 4\nx1 = r * cos(a + pi/4) = r * (cos(a) * cos(pi / 4) - sin(a) * sin(pi / 4)) \n   = 1 / sqrt(2) * (r * cos(a) - r * sin(a)) = 1 / sqrt(2) * (x0 - y0).\ny1 = r * sin(a + pi/4) = r * (sin(a) * cos(pi / 4) + cos(a) * sin(pi / 4)) \n   = 1 / sqrt(2) * (r * sin(a) + r * cos(a)) = 1 / sqrt(2) * (x0 + y0).\n\nSo, after rotating all the points 45 degrees and scale up all the coordinates with sqrt(2), (x0, y0) with be (x0 - y0, x0 + y0). \n\nAfter rotating, Manhattan distance ==> Chebyshev_distance. http://en.wikipedia.org/wiki/Chebyshev_distance",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7905",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #187 tutorial - Codeforces - Code 3",
          "code": "(x0, y0) --> (x1, y1)\nx0 = r * cos(a), y0 = r * sin(a)\nif a --> a + pi / 4\nx1 = r * cos(a + pi/4) = r * (cos(a) * cos(pi / 4) - sin(a) * sin(pi / 4)) \n   = 1 / sqrt(2) * (r * cos(a) - r * sin(a)) = 1 / sqrt(2) * (x0 - y0).\ny1 = r * sin(a + pi/4) = r * (sin(a) * cos(pi / 4) + cos(a) * sin(pi / 4)) \n   = 1 / sqrt(2) * (r * sin(a) + r * cos(a)) = 1 / sqrt(2) * (x0 + y0).\n\nSo, after rotating all the points 45 degrees and scale up all the coordinates with sqrt(2), (x0, y0) with be (x0 - y0, x0 + y0). \n\nAfter rotating, Manhattan distance ==> Chebyshev_distance. http://en.wikipedia.org/wiki/Chebyshev_distance",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7905",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #187 tutorial - Codeforces - Code 4",
          "code": "5\n1 1\n1 2\n2 3\n3 4\n4 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7905",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #187 tutorial - Codeforces - Code 5",
          "code": "5\n1 1\n1 2\n2 3\n3 4\n4 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7905",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #187 tutorial - Codeforces - Code 6",
          "code": "a_i == a_(i+1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7905",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int b = inf.readInt(1, 10000000, \"b\");\n    inf.readSpace();\n    int d = inf.readInt(1, 10000000, \"d\");\n    inf.readEoln();\n\n    string a = inf.readLine(\"[a-z]{1,100}\", \"a\");\n    string c = inf.readLine(\"[a-z]{1,100}\", \"c\");\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int b = inf.readInt(1, 10000000, \"b\");\n    inf.readSpace();\n    int d = inf.readInt(1, 10000000, \"d\");\n    inf.readEoln();\n\n    string a = inf.readLine(\"[a-z]{1,100}\", \"a\");\n    string c = inf.readLine(\"[a-z]{1,100}\", \"c\");\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int b = inf.readInt(1, 10000000, \"b\");\n    inf.readSpace();\n    int d = inf.readInt(1, 10000000, \"d\");\n    inf.readEoln();\n\n    string a = inf.readLine(\"[a-z]{1,100}\", \"a\");\n    string c = inf.readLine(\"[a-z]{1,100}\", \"c\");\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    // Read the parameters\n    int b = opt<int>(\"b\");\n    int d = opt<int>(\"d\");\n    int a_len = opt<int>(\"a_len\", -1); // If not provided, default to random value\n    int c_len = opt<int>(\"c_len\", -1);\n    string a_type = opt<string>(\"a_type\", \"random\");\n    string c_type = opt<string>(\"c_type\", \"random\");\n    string mode = opt<string>(\"mode\", \"random\");\n\n    // Cap b and d within constraints\n    b = max(1, min(10000000, b));\n    d = max(1, min(10000000, d));\n\n    // Now generate strings a and c based on a_type and c_type\n\n    string a, c;\n\n    // Lengths of a and c should be at least 1 and at most 100\n    if(a_len == -1)\n        a_len = rnd.next(1, 100);\n    else\n        a_len = min(max(1, a_len), 100);\n\n    if(c_len == -1)\n        c_len = rnd.next(1, 100);\n    else\n        c_len = min(max(1, c_len), 100);\n\n    // Generate string a\n    if(a_type == \"random\") {\n        for(int i = 0; i < a_len; ++i)\n            a += (char)('a' + rnd.next(26));\n    } else if(a_type == \"single_char\") {\n        char ch = 'a' + rnd.next(26);\n        a = string(a_len, ch);\n    } else if(a_type == \"repeated_pattern\") {\n        int pattern_len = rnd.next(1, a_len);\n        string pattern = \"\";\n        for(int i = 0; i < pattern_len; ++i)\n            pattern += (char)('a' + rnd.next(26));\n        while ((int)a.size() < a_len)\n            a += pattern;\n        a = a.substr(0, a_len);\n    } else if(a_type == \"same_as_c\") {\n        // Set a to be same as c\n        if(c.empty()) {\n            c = \"\";\n            // Generate c now\n            if(c_type == \"random\") {\n                for(int i = 0; i < c_len; ++i)\n                    c += (char)('a' + rnd.next(26));\n            } else if(c_type == \"single_char\") {\n                char ch = 'a' + rnd.next(26);\n                c = string(c_len, ch);\n            } else if(c_type == \"repeated_pattern\") {\n                int pattern_len = rnd.next(1, c_len);\n                string pattern = \"\";\n                for(int i = 0; i < pattern_len; ++i)\n                    pattern += (char)('a' + rnd.next(26));\n                while ((int)c.size() < c_len)\n                    c += pattern;\n                c = c.substr(0, c_len);\n            }\n        }\n        a = c;\n        a_len = c_len = a.size();\n    }\n\n    // Now generate string c if not done already\n    if(c.empty()) { // c might have been generated if a_type == \"same_as_c\"\n        if(c_type == \"random\") {\n            for(int i = 0; i < c_len; ++i)\n                c += (char)('a' + rnd.next(26));\n        } else if(c_type == \"single_char\") {\n            char ch = 'a' + rnd.next(26);\n            c = string(c_len, ch);\n        } else if(c_type == \"repeated_pattern\") {\n            int pattern_len = rnd.next(1, c_len);\n            string pattern = \"\";\n            for(int i = 0; i < pattern_len; ++i)\n                pattern += (char)('a' + rnd.next(26));\n            while ((int)c.size() < c_len)\n                c += pattern;\n            c = c.substr(0, c_len);\n        }\n    }\n\n    // Now, depending on the mode, adjust the parameters to generate special test cases\n\n    if(mode == \"max_p\") {\n        // We need to make sure that c^[p] can be obtained from w\n        // Let's make a and c to be the same, then p can be b\n        a = c;\n        a_len = c_len = a.size();\n        // We can set b and d, and p will be b/d\n        d = 1;\n        b = max(b, 1);\n    } else if(mode == \"zero_p\") {\n        // Generate a and c such that c^[1] cannot be obtained from w\n        // Make sure that c contains characters not in a\n        set<char> a_chars(a.begin(), a.end());\n        char ch;\n        do {\n            ch = 'a' + rnd.next(26);\n        } while(a_chars.count(ch));\n        c = string(c_len, ch);\n    } else if(mode == \"edge\") {\n        // Edge cases, like b=1, d=1, min or max lengths\n        b = 1;\n        d = 1;\n        a_len = min(a_len, 1);\n        c_len = min(c_len, 1);\n        char ch = 'a' + rnd.next(26);\n        a = string(a_len, ch);\n        c = string(c_len, ch);\n    } else if(mode == \"overlap\") {\n        // Create overlapping patterns in a and c\n        int pattern_len = rnd.next(1, min(a_len, c_len));\n        string pattern = \"\";\n        for(int i = 0; i < pattern_len; ++i)\n            pattern += (char)('a' + rnd.next(26));\n\n        a = \"\";\n        while((int)a.size() < a_len)\n            a += pattern;\n        a = a.substr(0, a_len);\n\n        c = \"\";\n        while((int)c.size() < c_len)\n            c += pattern;\n        c = c.substr(0, c_len);\n    } else if(mode == \"random\") {\n        // Do nothing, keep random strings\n    }\n\n    // Output the data\n    printf(\"%d %d\\n\", b, d);\n    printf(\"%s\\n\", a.c_str());\n    printf(\"%s\\n\", c.c_str());\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    // Read the parameters\n    int b = opt<int>(\"b\");\n    int d = opt<int>(\"d\");\n    int a_len = opt<int>(\"a_len\", -1); // If not provided, default to random value\n    int c_len = opt<int>(\"c_len\", -1);\n    string a_type = opt<string>(\"a_type\", \"random\");\n    string c_type = opt<string>(\"c_type\", \"random\");\n    string mode = opt<string>(\"mode\", \"random\");\n\n    // Cap b and d within constraints\n    b = max(1, min(10000000, b));\n    d = max(1, min(10000000, d));\n\n    // Now generate strings a and c based on a_type and c_type\n\n    string a, c;\n\n    // Lengths of a and c should be at least 1 and at most 100\n    if(a_len == -1)\n        a_len = rnd.next(1, 100);\n    else\n        a_len = min(max(1, a_len), 100);\n\n    if(c_len == -1)\n        c_len = rnd.next(1, 100);\n    else\n        c_len = min(max(1, c_len), 100);\n\n    // Generate string a\n    if(a_type == \"random\") {\n        for(int i = 0; i < a_len; ++i)\n            a += (char)('a' + rnd.next(26));\n    } else if(a_type == \"single_char\") {\n        char ch = 'a' + rnd.next(26);\n        a = string(a_len, ch);\n    } else if(a_type == \"repeated_pattern\") {\n        int pattern_len = rnd.next(1, a_len);\n        string pattern = \"\";\n        for(int i = 0; i < pattern_len; ++i)\n            pattern += (char)('a' + rnd.next(26));\n        while ((int)a.size() < a_len)\n            a += pattern;\n        a = a.substr(0, a_len);\n    } else if(a_type == \"same_as_c\") {\n        // Set a to be same as c\n        if(c.empty()) {\n            c = \"\";\n            // Generate c now\n            if(c_type == \"random\") {\n                for(int i = 0; i < c_len; ++i)\n                    c += (char)('a' + rnd.next(26));\n            } else if(c_type == \"single_char\") {\n                char ch = 'a' + rnd.next(26);\n                c = string(c_len, ch);\n            } else if(c_type == \"repeated_pattern\") {\n                int pattern_len = rnd.next(1, c_len);\n                string pattern = \"\";\n                for(int i = 0; i < pattern_len; ++i)\n                    pattern += (char)('a' + rnd.next(26));\n                while ((int)c.size() < c_len)\n                    c += pattern;\n                c = c.substr(0, c_len);\n            }\n        }\n        a = c;\n        a_len = c_len = a.size();\n    }\n\n    // Now generate string c if not done already\n    if(c.empty()) { // c might have been generated if a_type == \"same_as_c\"\n        if(c_type == \"random\") {\n            for(int i = 0; i < c_len; ++i)\n                c += (char)('a' + rnd.next(26));\n        } else if(c_type == \"single_char\") {\n            char ch = 'a' + rnd.next(26);\n            c = string(c_len, ch);\n        } else if(c_type == \"repeated_pattern\") {\n            int pattern_len = rnd.next(1, c_len);\n            string pattern = \"\";\n            for(int i = 0; i < pattern_len; ++i)\n                pattern += (char)('a' + rnd.next(26));\n            while ((int)c.size() < c_len)\n                c += pattern;\n            c = c.substr(0, c_len);\n        }\n    }\n\n    // Now, depending on the mode, adjust the parameters to generate special test cases\n\n    if(mode == \"max_p\") {\n        // We need to make sure that c^[p] can be obtained from w\n        // Let's make a and c to be the same, then p can be b\n        a = c;\n        a_len = c_len = a.size();\n        // We can set b and d, and p will be b/d\n        d = 1;\n        b = max(b, 1);\n    } else if(mode == \"zero_p\") {\n        // Generate a and c such that c^[1] cannot be obtained from w\n        // Make sure that c contains characters not in a\n        set<char> a_chars(a.begin(), a.end());\n        char ch;\n        do {\n            ch = 'a' + rnd.next(26);\n        } while(a_chars.count(ch));\n        c = string(c_len, ch);\n    } else if(mode == \"edge\") {\n        // Edge cases, like b=1, d=1, min or max lengths\n        b = 1;\n        d = 1;\n        a_len = min(a_len, 1);\n        c_len = min(c_len, 1);\n        char ch = 'a' + rnd.next(26);\n        a = string(a_len, ch);\n        c = string(c_len, ch);\n    } else if(mode == \"overlap\") {\n        // Create overlapping patterns in a and c\n        int pattern_len = rnd.next(1, min(a_len, c_len));\n        string pattern = \"\";\n        for(int i = 0; i < pattern_len; ++i)\n            pattern += (char)('a' + rnd.next(26));\n\n        a = \"\";\n        while((int)a.size() < a_len)\n            a += pattern;\n        a = a.substr(0, a_len);\n\n        c = \"\";\n        while((int)c.size() < c_len)\n            c += pattern;\n        c = c.substr(0, c_len);\n    } else if(mode == \"random\") {\n        // Do nothing, keep random strings\n    }\n\n    // Output the data\n    printf(\"%d %d\\n\", b, d);\n    printf(\"%s\\n\", a.c_str());\n    printf(\"%s\\n\", c.c_str());\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -b 1 -d 1 -a_len 1 -c_len 1 -mode edge\n./gen -b 1 -d 1 -a_len 100 -c_len 100 -mode edge\n./gen -b 1 -d 1 -a_len 1 -c_len 100 -mode edge\n./gen -b 1 -d 1 -a_len 100 -c_len 1 -mode edge\n\n./gen -b 10000000 -d 1 -a_len 1 -c_len 1 -mode max_p\n./gen -b 10000000 -d 1 -a_len 100 -c_len 100 -a_type same_as_c -mode max_p\n./gen -b 10000000 -d 5000000 -a_len 10 -c_len 10 -a_type same_as_c -mode max_p\n./gen -b 9999999 -d 9999999 -a_len 50 -c_len 50 -a_type same_as_c -mode max_p\n\n./gen -b 10000000 -d 1 -a_len 100 -c_len 100 -a_type random -c_type random -mode zero_p\n./gen -b 5000000 -d 1 -a_len 50 -c_len 50 -a_type random -c_type random -mode zero_p\n\n./gen -b 5000000 -d 2 -a_len 60 -c_len 50 -mode random\n./gen -b 10 -d 10000000 -a_len 100 -c_len 1 -a_type single_char -c_type single_char -mode random\n./gen -b 9999999 -d 10000000 -a_len 100 -c_len 1 -a_type single_char -c_type single_char -mode random\n\n./gen -b 1 -d 10000000 -a_len 100 -c_len 100 -a_type single_char -c_type single_char -mode random\n./gen -b 10000000 -d 10000000 -a_len 100 -c_len 100 -a_type repeated_pattern -c_type repeated_pattern -mode overlap\n./gen -b 10000000 -d 10000000 -a_len 10 -c_len 10 -a_type repeated_pattern -c_type repeated_pattern -mode overlap\n\n./gen -b 10000000 -d 1 -a_len 100 -c_len 100 -a_type random -c_type random -mode random\n./gen -b 10000000 -d 1 -a_len 50 -c_len 50 -a_type random -c_type random -mode random\n\n./gen -b 10000000 -d 10000000 -a_len 1 -c_len 1 -a_type single_char -c_type single_char -mode random\n./gen -b 10000000 -d 5000000 -a_len 20 -c_len 20 -a_type random -c_type random -mode random\n\n./gen -b 1 -d 10000000 -a_len 50 -c_len 50 -a_type random -c_type random -mode random\n./gen -b 5000000 -d 5000000 -a_len 100 -c_len 100 -a_type random -c_type random -mode random\n\n./gen -b 1234567 -d 7654321 -a_len 99 -c_len 88 -mode random\n./gen -b 10000 -d 10000 -a_len 5 -c_len 5 -mode random\n\n./gen -b 9999999 -d 1 -a_len 1 -c_len 1 -a_type single_char -c_type single_char -mode random\n./gen -b 1 -d 9999999 -a_len 1 -c_len 1 -a_type single_char -c_type single_char -mode random\n./gen -b 1 -d 9999999 -a_len 1 -c_len 1 -a_type random -c_type single_char -mode random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:07:06.504760",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "315/E",
      "title": "E. Сережа и подпоследовательности",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест2 секунды",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеВ первой строке содержится целое число n (1 ≤ n ≤ 105). Во второй строке содержится n целых чисел a1, a2, ..., an (1 ≤ ai ≤ 106).",
      "output_spec": "Выходные данныеВ единственную строку выведите остаток от деления ответа на задачу на число 1000000007 (109 + 7).",
      "sample_tests": "ПримерыВходные данныеСкопировать142Выходные данныеСкопировать42Входные данныеСкопировать31 2 2Выходные данныеСкопировать13Входные данныеСкопировать51 2 3 4 5Выходные данныеСкопировать719",
      "description": "E. Сережа и подпоследовательности\n\nограничение по времени на тест2 секунды\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвыводstdout\n\nВходные данныеВ первой строке содержится целое число n (1 ≤ n ≤ 105). Во второй строке содержится n целых чисел a1, a2, ..., an (1 ≤ ai ≤ 106).\n\nВходные данные\n\nВыходные данныеВ единственную строку выведите остаток от деления ответа на задачу на число 1000000007 (109 + 7).\n\nВыходные данные\n\nВходные данныеСкопировать142Выходные данныеСкопировать42Входные данныеСкопировать31 2 2Выходные данныеСкопировать13Входные данныеСкопировать51 2 3 4 5Выходные данныеСкопировать719\n\nВходные данныеСкопировать142\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать42\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать31 2 2\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать13\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать51 2 3 4 5\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать719\n\nВыходные данныеСкопировать\n\nСкопировать",
      "solutions": [
        {
          "title": "Codeforces Round #187 - Codeforces",
          "content": "Всем привет!Совсем скоро, 7 июня в 19:30 MSK состоится Codeforces Round #187, автором которого являюсь я. Это мой седьмой раунд на Codeforces и я надеюсь, что не последний.Спасибо Геральду Агапову (Gerald), Роману Фурко(Furko) и Аксенову Виталику(Aksenov239) за помощь в подготовке раунда и Марии Беловой (Delinur) за перевод условий на английский.Настоятельно рекомендую прочитать условия ВСЕХ задач.Gl & hf ! :)Разбор.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/7894",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 420
        },
        {
          "title": "Разбор Codeforces Round #187 - Codeforces",
          "content": "315A - Сережа и бутылкиПросто для каждой бутылки проверим, можно ли открыть ее другой. В данной задаче проходили абсолютно любые решения. 315B - Сережа и массивБудем поддерживать все элементы в массиве, но дополнительно заведем переменную add: сколько нужно добавить ко всем элементам. Тогда про добавлении ко всем элементам просто увеличим add. При выводе будем выводить элемент массива + величину add. При обновлении будем ставить элемент равным значению, которое нужно поставить минус текущая величина add. 314A - Сережа и контестЗаметим, что если мы удалили некоторого участника, то мы никогда не удалим участников с меньшими номерами, так как их сумма будет только увеличиваться. Поэтому просто последовательно рассмотрим всех участников, и если участник не подходит, то удалим его. 314B - Сережа и периодыПонятно, что можно жадно искать количество вхождений 2й строки в первой, но такое решение работает долго. Для ускорения процесса можно искать в первой строке строку, которая задает период второй. А ответ поделить на то, сколько строк нужно для задания второй строки. Далее рассмотрим наш жадный алгоритм. Мы идем по первой строке, пока не встретим первый символ второй строки, потом второй, третий и так далее до последнего, потом снова ищем первый, второй и так по циклу. Понятно, что когда мы дважды окажемся в состоянии, в котором позиции в первой строке соответствует одному символу строки, которая задает период и позиции во второй строке одинаковы, то мы получим период. Когда мы найдем этот период, то просто повторим его столько раз, сколько возможно, что бы каждый раз не считать одну и ту же информацию. Для лучшего понимая, советую прочитать любое прошедшее решение. 314C - Сережа и подпоследовательностиПонятно, что нужно посчитать сумму произведений элементов всех различных неубывающих подпоследовательностей заданной последовательности. Будем идти по последовательности слева направо и поддерживать массив q[i]: какая сумма всех нужных подпоследовательностей, таких что их последний элемент равен i. Понятно, что если очередное число это x, то нужно поставить q[x] = sum(q[1]+q[2]+...+q[x])*x+x. Ответом на задачу будет сумма всех q[i]. Для нахождения всех сумм можно использовать дерево Фенвика. 314D - Сережа и прямыеПовернем все на 45 градусов с помощью преобразования: (x, y) -> (x', y'): x' = x+y, y' = x-y.Далее нужно разместить две прямые параллельно осям координат. Отсортируем точки по первой координате. Далее будем использовать бинарный поиск по ответу. Пускай мы зафиксировали некоторое число, теперь нужно проверить хватит ли его, или нет. Заметим, что сейчас нужно разместить две полосы ширины 2 * зафиксированная величина, что бы ими покрыть все точки. Допустим, что некоторая точка будет прилегать к левой стороне вертикальной полосы, далее для всех точек, которые не попадают в полосу найдем минимальную и максимальную вторую координату. Если разница между найденными координатами не больше 2 * зафиксированная величина, то полосы разместить можно, иначе — нет. Скоро...",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/7905",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.5,
            "reason": "宽松匹配: 包含题目编号 315"
          },
          "content_length": 3013
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #187 - Codeforces - Code 1",
          "code": "Мало того, что код написать,так и надо над оптимизацией думать",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7894",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #187 - Codeforces - Code 2",
          "code": "Мало того, что код написать,так и надо над оптимизацией думать",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7894",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #187 - Codeforces - Code 1",
          "code": "dp[i][j] = 25 * dp[i - 1][j - 1] + dp[i - 1][j + 1] otherwise. ('?' can be both: an opening and a closing bracket).",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7905",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #187 - Codeforces - Code 2",
          "code": "(x0, y0) --> (x1, y1)\nx0 = r * cos(a), y0 = r * sin(a)\nif a --> a + pi / 4\nx1 = r * cos(a + pi/4) = r * (cos(a) * cos(pi / 4) - sin(a) * sin(pi / 4)) \n   = 1 / sqrt(2) * (r * cos(a) - r * sin(a)) = 1 / sqrt(2) * (x0 - y0).\ny1 = r * sin(a + pi/4) = r * (sin(a) * cos(pi / 4) + cos(a) * sin(pi / 4)) \n   = 1 / sqrt(2) * (r * sin(a) + r * cos(a)) = 1 / sqrt(2) * (x0 + y0).\n\nSo, after rotating all the points 45 degrees and scale up all the coordinates with sqrt(2), (x0, y0) with be (x0 - y0, x0 + y0). \n\nAfter rotating, Manhattan distance ==> Chebyshev_distance. http://en.wikipedia.org/wiki/Chebyshev_distance",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7905",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #187 - Codeforces - Code 3",
          "code": "(x0, y0) --> (x1, y1)\nx0 = r * cos(a), y0 = r * sin(a)\nif a --> a + pi / 4\nx1 = r * cos(a + pi/4) = r * (cos(a) * cos(pi / 4) - sin(a) * sin(pi / 4)) \n   = 1 / sqrt(2) * (r * cos(a) - r * sin(a)) = 1 / sqrt(2) * (x0 - y0).\ny1 = r * sin(a + pi/4) = r * (sin(a) * cos(pi / 4) + cos(a) * sin(pi / 4)) \n   = 1 / sqrt(2) * (r * sin(a) + r * cos(a)) = 1 / sqrt(2) * (x0 + y0).\n\nSo, after rotating all the points 45 degrees and scale up all the coordinates with sqrt(2), (x0, y0) with be (x0 - y0, x0 + y0). \n\nAfter rotating, Manhattan distance ==> Chebyshev_distance. http://en.wikipedia.org/wiki/Chebyshev_distance",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7905",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #187 - Codeforces - Code 4",
          "code": "5\n1 1\n1 2\n2 3\n3 4\n4 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7905",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #187 - Codeforces - Code 5",
          "code": "5\n1 1\n1 2\n2 3\n3 4\n4 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7905",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #187 - Codeforces - Code 6",
          "code": "a_i == a_(i+1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7905",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n    vector<int> a = inf.readInts(n, 1, 1000000, \"a_i\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n    vector<int> a = inf.readInts(n, 1, 1000000, \"a_i\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n    vector<int> a = inf.readInts(n, 1, 1000000, \"a_i\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> a(n);\n\n    if (type == \"random\") {\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, 1000000);\n        }\n    } else if (type == \"min_ai\") {\n        for (int i = 0; i < n; ++i) {\n            a[i] = 1;\n        }\n    } else if (type == \"max_ai\") {\n        for (int i = 0; i < n; ++i) {\n            a[i] = 1000000;\n        }\n    } else if (type == \"increasing\") {\n        int val = 1;\n        for (int i = 0; i < n; ++i) {\n            a[i] = val;\n            val += rnd.next(0, 10);\n            if (val > 1000000) val = 1000000;\n        }\n    } else if (type == \"decreasing\") {\n        int val = 1000000;\n        for (int i = 0; i < n; ++i) {\n            a[i] = val;\n            val -= rnd.next(0, 10);\n            if (val < 1) val = 1;\n        }\n    } else if (type == \"same\") {\n        int val = rnd.next(1, 1000000);\n        for (int i = 0; i < n; ++i) {\n            a[i] = val;\n        }\n    } else if (type == \"two_values\") {\n        int val1 = rnd.next(1, 1000000);\n        int val2 = rnd.next(1, 1000000);\n        for (int i = 0; i < n; ++i) {\n            a[i] = (rnd.next(0, 1) ? val1 : val2);\n        }\n    } else if (type == \"one_large_rest_small\") {\n        int idx = rnd.next(0, n - 1);\n        for (int i = 0; i < n; ++i) {\n            if (i == idx)\n                a[i] = 1000000;\n            else\n                a[i] = 1;\n        }\n    } else if (type == \"one_small_rest_large\") {\n        int idx = rnd.next(0, n - 1);\n        for (int i = 0; i < n; ++i) {\n            if (i == idx)\n                a[i] = 1;\n            else\n                a[i] = 1000000;\n        }\n    } else if (type == \"duplicates\") {\n        int num_distinct = rnd.next(1, min(n, 10));\n        vector<int> vals;\n        for (int i = 0; i < num_distinct; ++i) {\n            vals.push_back(rnd.next(1, 1000000));\n        }\n        for (int i = 0; i < n; ++i) {\n            a[i] = vals[rnd.next(0, num_distinct - 1)];\n        }\n    } else {\n        // default to random\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, 1000000);\n        }\n    }\n\n    // Output the test case\n    printf(\"%d\\n\", n);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d\", a[i]);\n        if (i + 1 < n)\n            printf(\" \");\n    }\n    printf(\"\\n\");\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> a(n);\n\n    if (type == \"random\") {\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, 1000000);\n        }\n    } else if (type == \"min_ai\") {\n        for (int i = 0; i < n; ++i) {\n            a[i] = 1;\n        }\n    } else if (type == \"max_ai\") {\n        for (int i = 0; i < n; ++i) {\n            a[i] = 1000000;\n        }\n    } else if (type == \"increasing\") {\n        int val = 1;\n        for (int i = 0; i < n; ++i) {\n            a[i] = val;\n            val += rnd.next(0, 10);\n            if (val > 1000000) val = 1000000;\n        }\n    } else if (type == \"decreasing\") {\n        int val = 1000000;\n        for (int i = 0; i < n; ++i) {\n            a[i] = val;\n            val -= rnd.next(0, 10);\n            if (val < 1) val = 1;\n        }\n    } else if (type == \"same\") {\n        int val = rnd.next(1, 1000000);\n        for (int i = 0; i < n; ++i) {\n            a[i] = val;\n        }\n    } else if (type == \"two_values\") {\n        int val1 = rnd.next(1, 1000000);\n        int val2 = rnd.next(1, 1000000);\n        for (int i = 0; i < n; ++i) {\n            a[i] = (rnd.next(0, 1) ? val1 : val2);\n        }\n    } else if (type == \"one_large_rest_small\") {\n        int idx = rnd.next(0, n - 1);\n        for (int i = 0; i < n; ++i) {\n            if (i == idx)\n                a[i] = 1000000;\n            else\n                a[i] = 1;\n        }\n    } else if (type == \"one_small_rest_large\") {\n        int idx = rnd.next(0, n - 1);\n        for (int i = 0; i < n; ++i) {\n            if (i == idx)\n                a[i] = 1;\n            else\n                a[i] = 1000000;\n        }\n    } else if (type == \"duplicates\") {\n        int num_distinct = rnd.next(1, min(n, 10));\n        vector<int> vals;\n        for (int i = 0; i < num_distinct; ++i) {\n            vals.push_back(rnd.next(1, 1000000));\n        }\n        for (int i = 0; i < n; ++i) {\n            a[i] = vals[rnd.next(0, num_distinct - 1)];\n        }\n    } else {\n        // default to random\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, 1000000);\n        }\n    }\n\n    // Output the test case\n    printf(\"%d\\n\", n);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d\", a[i]);\n        if (i + 1 < n)\n            printf(\" \");\n    }\n    printf(\"\\n\");\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -type min_ai\n./gen -n 1 -type max_ai\n./gen -n 1 -type same\n\n./gen -n 5 -type random\n./gen -n 5 -type increasing\n./gen -n 5 -type decreasing\n./gen -n 5 -type duplicates\n\n./gen -n 10 -type random\n./gen -n 10 -type two_values\n./gen -n 10 -type one_large_rest_small\n\n./gen -n 100 -type random\n./gen -n 100 -type increasing\n./gen -n 100 -type decreasing\n./gen -n 100 -type duplicates\n\n./gen -n 1000 -type random\n./gen -n 1000 -type duplicates\n\n./gen -n 10000 -type random\n./gen -n 10000 -type increasing\n./gen -n 10000 -type decreasing\n\n./gen -n 100000 -type random\n./gen -n 100000 -type increasing\n./gen -n 100000 -type decreasing\n./gen -n 100000 -type min_ai\n./gen -n 100000 -type max_ai\n./gen -n 100000 -type same\n\n./gen -n 99999 -type one_large_rest_small\n./gen -n 99999 -type one_small_rest_large\n\n./gen -n 100000 -type two_values\n./gen -n 100000 -type duplicates\n\n# Edge cases\n./gen -n 1 -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:07:08.255745",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "317/A",
      "title": "A. Perfect Pair",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputSingle line of the input contains three integers x, y and m ( - 1018 ≤ x, y, m ≤ 1018).Please, do not use the %lld specifier to read or write 64-bit integers in C++. It is preffered to use the cin, cout streams or the %I64d specifier.",
      "output_spec": "OutputPrint the minimum number of operations or \"-1\" (without quotes), if it is impossible to transform the given pair to the m-perfect one.",
      "sample_tests": "ExamplesInputCopy1 2 5OutputCopy2InputCopy-1 4 15OutputCopy4InputCopy0 -1 5OutputCopy-1",
      "description": "A. Perfect Pair\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputSingle line of the input contains three integers x, y and m ( - 1018 ≤ x, y, m ≤ 1018).Please, do not use the %lld specifier to read or write 64-bit integers in C++. It is preffered to use the cin, cout streams or the %I64d specifier.\n\nOutputPrint the minimum number of operations or \"-1\" (without quotes), if it is impossible to transform the given pair to the m-perfect one.\n\nInputCopy1 2 5OutputCopy2InputCopy-1 4 15OutputCopy4InputCopy0 -1 5OutputCopy-1\n\nInputCopy1 2 5\n\nOutputCopy2\n\nInputCopy-1 4 15\n\nOutputCopy4\n\nInputCopy0 -1 5\n\nOutputCopy-1\n\nNoteIn the first sample the following sequence of operations is suitable: (1, 2)  (3, 2)  (5, 2).In the second sample: (-1, 4)  (3, 4)  (7, 4)  (11, 4)  (15, 4).Finally, in the third sample x, y cannot be made positive, hence there is no proper sequence of operations.",
      "solutions": [
        {
          "title": "Codeforces Round #188 - Codeforces",
          "content": "Hello, friends! Winter 188th Codeforces Round is coming!We wished to prepare for you some enjoyable problems (as we believe, not very difficult) with nice ideas and clear statements.\"We\" includes authors of the problems yaro and Rei, Codeforces Rounds supervisor Gerald and the platform founder MikeMirzayanov. Special thanks to Pasha (PavelKunyavskiy) and Artem (RAD) for the testing and helpful comments.Last time I was preparing a competition here on Codeforces, Rounds were still \"beta\". Well, with less \"beta\" comes greater responsibility. So I wish the authors and the organizers a successfully held Round. As for the participants, I wish you the unconventional ideas, the clean code (and a clean keyboard, of course), and satisfaction from five (well, possibly the less number will also do...) correct and accepted solutions!It seems to us that it is not an easy job to arrange the problems by their difficulty, so we have chosen the dynamic scores. Still (out of curiousity) let us put a bet on the following relative difficulties for the problems: div.1 — B-B-C-C-E, div.2 — A-B-C-C-E. How close is our guess?UPD Sorry for the problems with the Codeforces testing queue during the round.We will still be happy if you rate our contest (when it will be over): short survey.And with the gap of one hack the winner of div.1 is meret (Jakub Pachocki)!Div.1 standings, Div.2 standings.Analysis (thanks to Rei for the translation).",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/7862",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1433
        },
        {
          "title": "Codeforces Round #188 (analysis) - Codeforces",
          "content": "Problem analysis v 0.9.318A - Even OddsIn this problem we need to understand how exactly numbers from 1 to n rearrange when we write firstly all odd numbers and after them all even numbers. To find out which number stands at position k one needs to find the position where even numbers start and output either the position of the odd number from the first half of the sequence or for the even number from the second half of the sequence.318B - Strings of PowerIn the heavy metal problem one needs to find the number of the substrings in the string S with a given prefix A and given suffix B. If we mark black all the starting positions of the entries of the string A in S, and white all the starting positions of the entries of the string B, then we come to the following problem: count the number of pairs <black position, white position> (in this order). To solve this it is enough to iterate from left to right counting the number of the passed black positions. Meeting black position we increment this number by one, meeting white position we add to the answer the number of pairs with this white position, which is exactly our memorized number of the already passed black positions.317A - Perfect Pair318C - Perfect PairThis problem were more about accuracy then about ideas or coding. It is important to not forget any cases here.On each step we replace one of the numbers x, y by their sum x + y until the pair becomes m-perfect (id est one of them becomes not lesser than m). It is clear that one sould replace lesser number from the pair x, y. Indeed lets say the pair x1 ≤ y1 dominates the pair x2 ≤ y2, if y1 ≥ y2 and x1 ≥ y2. In this case if one can get m-perfect pair from x2, y2 by certain sequence of actions, then one can get m-perfect pair from x1, y1 by the same or shorter sequence of actions. If x ≤ y, then the pair x + y, y dominates the pair x + y, x. Hence path from x + y, y to m-perfect is not longer than from x + y, x, and we may assume that we choose exactly this pair.Consider following cases: x ≤ 0, y ≤ 0 In this case our numbers do not increase in the process. Hence either the pair is alredy m-perfect or it will never be. x > 0 and y > 0 In this case for each m pair will after several steps become m-perfect. To count precise number of those steps one needs to launch emulation. If x > 0 and y > 0, then pair \"grows exponentionaly>> (more formally: easy to show that starting from secnd step sum x + y grows in at least 3 / 2 times each step) and emulation works pretty fast. However in the case x < 0 and y > 0 (or vice versa) pair might change very slowly. Most bright example is x =  - 1018, y = 1. Thus one needs to count number of steps until both numbers becomes positive before launching emulationt. For x < 0 and y > 0 number of those steps is exactly . 317B - Ants318D - AntsOne may reformulate the problem ass follows. Non-negative integers A(x, y) are placed in the vertices of two-dimensional lattice We may imagine this construction as a function . On each step for each vertex P = (x, y) with A(x, y) ≥ 4 we perform operation φP, which substracts 4 from A(x, y) and adds 1 to A(x, y - 1), A(x, y + 1), A(x - 1, y), A(x + 1, y). We may think that operation φP applies to the whole function A. We need to find values of A after the iterations stops.Key idea is that operactions φP and φQ for all points P and Q commutes, that is φP(φQ(A)) = φQ(φP(A)). This means that the order of operations is unimportant. In particular, we may assume that from each given vertex run all possible four-groups of ants and not only one. After this observation one may run full emulation of the process. As an exercise contestants may check that ants will never leave square 200 × 200 with center in the origin 0 with given constraints.317C - Balance318E - BalanceIn this problem we need to find 2n2 transfusions from initial configuration to the desired one. First of all we propose the following: if in each connected component overall volume of the water in initial configuration is the same as in desired one, then answer exist. We call the vessel ready, if current volume of its water equals desired one. Let us describe solution which is probably easier to code. We will make vessels ready one by one. Consider the pair of non-ready vessels s and t (there is more water in s than desired, and less water in t than desired), such that they are connected by the path P, and if one transfuses d litres from s to t then one of the vessels becomes ready. Now we need to find a way to transfuse d litres by path P from s to t. One may write recursive function pour(s, t, d) for this aim. Let t' stand before t in this path, then function works as follows: transfuses from t' to t as many water as possible (not more than d of course), then calls pour(s, t', d) and on the final step transfuses from t' to t all that left. It is easy to check that all such transfusions are correct. This algorithm makes 2len transfusions on the path of length len, so total number of transfusions is not greater than 2n2.317D - Game with PowersFor each numner x denote sequence of its powers within [1..n] as Pow(x): Game proceeds as follows: on each step one player takes still available number x from 1 to n and prohibits whole set Pow(x). Who can't make his turn loses.This game may be decomposed in the sum of lesser games. Indeed, lets call number x simple (and corresponding sequence Pow(x) simple), if it is not a power of any number y < x. Then: 1. for each there is simple x, such that ; 2. for each simple distinct x and y sets Pow(x) and P(y) do not intersect. Indeed, for a given k there is exactly one simple x such that k is power of x. This may be showed from fundamental theorem of arithmetic: if and d = gcd(α1, α2, ..., αn), then .Hence set [1..n] decomposes into primitive sets Pow(x), on each of those Pow(x) game proceeds independetly. Now one may use Sprague–Grundy theory to see that mexx of our game is just xor of all mexx of games on simple Pow(x). For fixed x, if Pow(x) = {x, x2, ..., xs}, then mexx of the game on Pow(x) depends only on s, but not on x. In our case s runs from 1 to 29, mexx for all such s may be directly precalculated. Now it is enough to find numbers q(s) of simple x with a given size of Pow(x) equal to s (actually we are interested in parity of q(s) not in q(s) itself).Our constraints allows to do it directly: run x from 2 to , if it is not crossed out, determine the size Pow(x) [increment corresponding q(s)], and cross out all numbers from Pow(x). This cycle finds all simple sequences of length at least 2. Quantity of non-crossed numbers is the number of all simple sequences of length 1. Now it is enough to look at parities of q(s) and xor coressponding mexx.However one may find all q(s) for . Indeed lets look at the number and sequence {x, x2, x3, x4, ..., xs}. This sequence is not simple iff it is containd in some larger simple sequence. But number of subsequenes of size s in a given sequence of size t > s is easy to find: it is just [t / s]. Recalling that simple sequences do not intersect one gets the reccurent formula:. Now it is easy to find all q(s) from q(29) to q(1).Remark: while coding it is important to remeber simple number x = 1.317E - Princess and Her ShadowIn this problem princess Vlada should simply catch the Shadow. Here is the idea of a solution. If there is only one tree, then using it as a barrier to the shadow it is not hard to catch the shadow. Similar technique works if Vlada and Shadow are far from the square where all the trees grow. But what can she do in the dark depths of the forest? If there is no path at all between Vlada and Shadow, then there is no way to catch it. Otherwise consider a shortest path from Vlada to the Shadow and make Vlada follow it. This path gives Vlada a queue of the steps that she should perform. Additionaly if shadow moves, then we add her move to the queue (simply speaking Vlada follows the shadow). This is where the algorithmic part ends. Now we state that either Vlada catches the shadow in the desired number of steps, or steps out of the \"forest square\". To proof this we note that the length of the path between Vlada and Shadow may only decrease. And if it does not decrease long enough, then once in k steps (k is the length of the path) Vlada and Shadow shifts at the same vector over and over, and at some moment leaves the \"forest square\". Note that if the trees allow our heroes to step out of the \"forest square\" at the beginning, then we may just get them out from the start. But taking this approach we still need to catch the Shadow in a \"labyrinth forest\".Apologies for the delay. There are probably misprints and mistakes here (thousands of them!), please feel free to point them out.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/7956",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 317\\s*A"
          },
          "content_length": 8753
        },
        {
          "title": "Codeforces Round #188 (analysis) - Codeforces",
          "content": "Problem analysis v 0.9.318A - Even OddsIn this problem we need to understand how exactly numbers from 1 to n rearrange when we write firstly all odd numbers and after them all even numbers. To find out which number stands at position k one needs to find the position where even numbers start and output either the position of the odd number from the first half of the sequence or for the even number from the second half of the sequence.318B - Strings of PowerIn the heavy metal problem one needs to find the number of the substrings in the string S with a given prefix A and given suffix B. If we mark black all the starting positions of the entries of the string A in S, and white all the starting positions of the entries of the string B, then we come to the following problem: count the number of pairs <black position, white position> (in this order). To solve this it is enough to iterate from left to right counting the number of the passed black positions. Meeting black position we increment this number by one, meeting white position we add to the answer the number of pairs with this white position, which is exactly our memorized number of the already passed black positions.317A - Perfect Pair318C - Perfect PairThis problem were more about accuracy then about ideas or coding. It is important to not forget any cases here.On each step we replace one of the numbers x, y by their sum x + y until the pair becomes m-perfect (id est one of them becomes not lesser than m). It is clear that one sould replace lesser number from the pair x, y. Indeed lets say the pair x1 ≤ y1 dominates the pair x2 ≤ y2, if y1 ≥ y2 and x1 ≥ y2. In this case if one can get m-perfect pair from x2, y2 by certain sequence of actions, then one can get m-perfect pair from x1, y1 by the same or shorter sequence of actions. If x ≤ y, then the pair x + y, y dominates the pair x + y, x. Hence path from x + y, y to m-perfect is not longer than from x + y, x, and we may assume that we choose exactly this pair.Consider following cases: x ≤ 0, y ≤ 0 In this case our numbers do not increase in the process. Hence either the pair is alredy m-perfect or it will never be. x > 0 and y > 0 In this case for each m pair will after several steps become m-perfect. To count precise number of those steps one needs to launch emulation. If x > 0 and y > 0, then pair \"grows exponentionaly>> (more formally: easy to show that starting from secnd step sum x + y grows in at least 3 / 2 times each step) and emulation works pretty fast. However in the case x < 0 and y > 0 (or vice versa) pair might change very slowly. Most bright example is x =  - 1018, y = 1. Thus one needs to count number of steps until both numbers becomes positive before launching emulationt. For x < 0 and y > 0 number of those steps is exactly . 317B - Ants318D - AntsOne may reformulate the problem ass follows. Non-negative integers A(x, y) are placed in the vertices of two-dimensional lattice We may imagine this construction as a function . On each step for each vertex P = (x, y) with A(x, y) ≥ 4 we perform operation φP, which substracts 4 from A(x, y) and adds 1 to A(x, y - 1), A(x, y + 1), A(x - 1, y), A(x + 1, y). We may think that operation φP applies to the whole function A. We need to find values of A after the iterations stops.Key idea is that operactions φP and φQ for all points P and Q commutes, that is φP(φQ(A)) = φQ(φP(A)). This means that the order of operations is unimportant. In particular, we may assume that from each given vertex run all possible four-groups of ants and not only one. After this observation one may run full emulation of the process. As an exercise contestants may check that ants will never leave square 200 × 200 with center in the origin 0 with given constraints.317C - Balance318E - BalanceIn this problem we need to find 2n2 transfusions from initial configuration to the desired one. First of all we propose the following: if in each connected component overall volume of the water in initial configuration is the same as in desired one, then answer exist. We call the vessel ready, if current volume of its water equals desired one. Let us describe solution which is probably easier to code. We will make vessels ready one by one. Consider the pair of non-ready vessels s and t (there is more water in s than desired, and less water in t than desired), such that they are connected by the path P, and if one transfuses d litres from s to t then one of the vessels becomes ready. Now we need to find a way to transfuse d litres by path P from s to t. One may write recursive function pour(s, t, d) for this aim. Let t' stand before t in this path, then function works as follows: transfuses from t' to t as many water as possible (not more than d of course), then calls pour(s, t', d) and on the final step transfuses from t' to t all that left. It is easy to check that all such transfusions are correct. This algorithm makes 2len transfusions on the path of length len, so total number of transfusions is not greater than 2n2.317D - Game with PowersFor each numner x denote sequence of its powers within [1..n] as Pow(x): Game proceeds as follows: on each step one player takes still available number x from 1 to n and prohibits whole set Pow(x). Who can't make his turn loses.This game may be decomposed in the sum of lesser games. Indeed, lets call number x simple (and corresponding sequence Pow(x) simple), if it is not a power of any number y < x. Then: 1. for each there is simple x, such that ; 2. for each simple distinct x and y sets Pow(x) and P(y) do not intersect. Indeed, for a given k there is exactly one simple x such that k is power of x. This may be showed from fundamental theorem of arithmetic: if and d = gcd(α1, α2, ..., αn), then .Hence set [1..n] decomposes into primitive sets Pow(x), on each of those Pow(x) game proceeds independetly. Now one may use Sprague–Grundy theory to see that mexx of our game is just xor of all mexx of games on simple Pow(x). For fixed x, if Pow(x) = {x, x2, ..., xs}, then mexx of the game on Pow(x) depends only on s, but not on x. In our case s runs from 1 to 29, mexx for all such s may be directly precalculated. Now it is enough to find numbers q(s) of simple x with a given size of Pow(x) equal to s (actually we are interested in parity of q(s) not in q(s) itself).Our constraints allows to do it directly: run x from 2 to , if it is not crossed out, determine the size Pow(x) [increment corresponding q(s)], and cross out all numbers from Pow(x). This cycle finds all simple sequences of length at least 2. Quantity of non-crossed numbers is the number of all simple sequences of length 1. Now it is enough to look at parities of q(s) and xor coressponding mexx.However one may find all q(s) for . Indeed lets look at the number and sequence {x, x2, x3, x4, ..., xs}. This sequence is not simple iff it is containd in some larger simple sequence. But number of subsequenes of size s in a given sequence of size t > s is easy to find: it is just [t / s]. Recalling that simple sequences do not intersect one gets the reccurent formula:. Now it is easy to find all q(s) from q(29) to q(1).Remark: while coding it is important to remeber simple number x = 1.317E - Princess and Her ShadowIn this problem princess Vlada should simply catch the Shadow. Here is the idea of a solution. If there is only one tree, then using it as a barrier to the shadow it is not hard to catch the shadow. Similar technique works if Vlada and Shadow are far from the square where all the trees grow. But what can she do in the dark depths of the forest? If there is no path at all between Vlada and Shadow, then there is no way to catch it. Otherwise consider a shortest path from Vlada to the Shadow and make Vlada follow it. This path gives Vlada a queue of the steps that she should perform. Additionaly if shadow moves, then we add her move to the queue (simply speaking Vlada follows the shadow). This is where the algorithmic part ends. Now we state that either Vlada catches the shadow in the desired number of steps, or steps out of the \"forest square\". To proof this we note that the length of the path between Vlada and Shadow may only decrease. And if it does not decrease long enough, then once in k steps (k is the length of the path) Vlada and Shadow shifts at the same vector over and over, and at some moment leaves the \"forest square\". Note that if the trees allow our heroes to step out of the \"forest square\" at the beginning, then we may just get them out from the start. But taking this approach we still need to catch the Shadow in a \"labyrinth forest\".Apologies for the delay. There are probably misprints and mistakes here (thousands of them!), please feel free to point them out.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/7956",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 317\\s*A"
          },
          "content_length": 8753
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #188 - Codeforces - Code 1",
          "code": "-1000000000000000000 1 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7862",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #188 - Codeforces - Code 2",
          "code": "...\nlong long x,y,m;\nlong long res;\n...\nint mymx = max(x,y); // int ???\nint mymn = min(x,y); // int ???\n\nx = mymx;\ny = mymn;\n...",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7862",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #188 - Codeforces - Code 3",
          "code": "...\nlong long x,y,m;\nlong long res;\n...\nint mymx = max(x,y); // int ???\nint mymn = min(x,y); // int ???\n\nx = mymx;\ny = mymn;\n...",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7862",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #188 - Codeforces - Code 4",
          "code": "s.size() < 4",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7862",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #188 - Codeforces - Code 5",
          "code": "s.size() - 4",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7862",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #188 - Codeforces - Code 6",
          "code": "#define SZ(x) (int)x.size()",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7862",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #188 - Codeforces - Code 7",
          "code": "Contest rating",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7862",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #188 (analysis) - Codeforces - Code 1",
          "code": "Thank you for the nice contest and editorial. \nIn \"Ants\" problem, Is there any way to expect the simulation will be converge so fast before we writing brute force code? how to make sure n = 30000 is the worst case?",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7956",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #188 (analysis) - Codeforces - Code 2",
          "code": "Thank you for the nice contest and editorial. \nIn \"Ants\" problem, Is there any way to expect the simulation will be converge so fast before we writing brute force code? how to make sure n = 30000 is the worst case?",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7956",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #188 (analysis) - Codeforces - Code 3",
          "code": "#include <string.h>\n#include <cstdio>\n#include <map>\nusing namespace std;\nmap<long long ,int>SG;\nint DFS(long long state) {\n    //printf(\"%I64d\\n\",state);getchar();getchar();\n    if(state==0) return 0;\n    if(SG[state]) return SG[state];\n    int len=0;long long tmp=state;\n    while(tmp>0) {\n        len++;\n        tmp>>=1;\n    }\n    bool cnt[100];memset(cnt,0,sizeof(cnt));\n    for(int i=1;i<=len;i++) {\n        long long k=(1<<(i-1)),tmp=state;\n        while(k<=tmp) {\n            tmp&=(((1<<(len+1))-1)^k);//printf(\"%lld\\n\",k);\n            k<<=i;\n\t\t}//printf(\"%lld\\n\",tmp);\n\t\tif(tmp==state) continue;\n        int ret=DFS(tmp);\n        cnt[ret]=1;\n    }\n    for(int i=0;;i++)if(!cnt[i]){\n        //printf(\"%d %d\\n\",len,i);\n        return (SG[state]=i);\n    }\n}\nint main()\n{\n    for(int I=1;I<=29;I++) {\n        printf(\"%d\\n\",DFS((long long )((1<<I)-1)));\n    }\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/7956",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #188 (analysis) - Codeforces - Code 4",
          "code": "#include <string.h>\n#include <cstdio>\n#include <map>\nusing namespace std;\nmap<long long ,int>SG;\nint DFS(long long state) {\n    //printf(\"%I64d\\n\",state);getchar();getchar();\n    if(state==0) return 0;\n    if(SG[state]) return SG[state];\n    int len=0;long long tmp=state;\n    while(tmp>0) {\n        len++;\n        tmp>>=1;\n    }\n    bool cnt[100];memset(cnt,0,sizeof(cnt));\n    for(int i=1;i<=len;i++) {\n        long long k=(1<<(i-1)),tmp=state;\n        while(k<=tmp) {\n            tmp&=(((1<<(len+1))-1)^k);//printf(\"%lld\\n\",k);\n            k<<=i;\n\t\t}//printf(\"%lld\\n\",tmp);\n\t\tif(tmp==state) continue;\n        int ret=DFS(tmp);\n        cnt[ret]=1;\n    }\n    for(int i=0;;i++)if(!cnt[i]){\n        //printf(\"%d %d\\n\",len,i);\n        return (SG[state]=i);\n    }\n}\nint main()\n{\n    for(int I=1;I<=29;I++) {\n        printf(\"%d\\n\",DFS((long long )((1<<I)-1)));\n    }\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/7956",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #188 (analysis) - Codeforces - Code 1",
          "code": "Thank you for the nice contest and editorial. \nIn \"Ants\" problem, Is there any way to expect the simulation will be converge so fast before we writing brute force code? how to make sure n = 30000 is the worst case?",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7956",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #188 (analysis) - Codeforces - Code 2",
          "code": "Thank you for the nice contest and editorial. \nIn \"Ants\" problem, Is there any way to expect the simulation will be converge so fast before we writing brute force code? how to make sure n = 30000 is the worst case?",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7956",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #188 (analysis) - Codeforces - Code 3",
          "code": "#include <string.h>\n#include <cstdio>\n#include <map>\nusing namespace std;\nmap<long long ,int>SG;\nint DFS(long long state) {\n    //printf(\"%I64d\\n\",state);getchar();getchar();\n    if(state==0) return 0;\n    if(SG[state]) return SG[state];\n    int len=0;long long tmp=state;\n    while(tmp>0) {\n        len++;\n        tmp>>=1;\n    }\n    bool cnt[100];memset(cnt,0,sizeof(cnt));\n    for(int i=1;i<=len;i++) {\n        long long k=(1<<(i-1)),tmp=state;\n        while(k<=tmp) {\n            tmp&=(((1<<(len+1))-1)^k);//printf(\"%lld\\n\",k);\n            k<<=i;\n\t\t}//printf(\"%lld\\n\",tmp);\n\t\tif(tmp==state) continue;\n        int ret=DFS(tmp);\n        cnt[ret]=1;\n    }\n    for(int i=0;;i++)if(!cnt[i]){\n        //printf(\"%d %d\\n\",len,i);\n        return (SG[state]=i);\n    }\n}\nint main()\n{\n    for(int I=1;I<=29;I++) {\n        printf(\"%d\\n\",DFS((long long )((1<<I)-1)));\n    }\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/7956",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #188 (analysis) - Codeforces - Code 4",
          "code": "#include <string.h>\n#include <cstdio>\n#include <map>\nusing namespace std;\nmap<long long ,int>SG;\nint DFS(long long state) {\n    //printf(\"%I64d\\n\",state);getchar();getchar();\n    if(state==0) return 0;\n    if(SG[state]) return SG[state];\n    int len=0;long long tmp=state;\n    while(tmp>0) {\n        len++;\n        tmp>>=1;\n    }\n    bool cnt[100];memset(cnt,0,sizeof(cnt));\n    for(int i=1;i<=len;i++) {\n        long long k=(1<<(i-1)),tmp=state;\n        while(k<=tmp) {\n            tmp&=(((1<<(len+1))-1)^k);//printf(\"%lld\\n\",k);\n            k<<=i;\n\t\t}//printf(\"%lld\\n\",tmp);\n\t\tif(tmp==state) continue;\n        int ret=DFS(tmp);\n        cnt[ret]=1;\n    }\n    for(int i=0;;i++)if(!cnt[i]){\n        //printf(\"%d %d\\n\",len,i);\n        return (SG[state]=i);\n    }\n}\nint main()\n{\n    for(int I=1;I<=29;I++) {\n        printf(\"%d\\n\",DFS((long long )((1<<I)-1)));\n    }\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/7956",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    \n    long long x = inf.readLong(-1000000000000000000LL, 1000000000000000000LL, \"x\");\n    inf.readSpace();\n    long long y = inf.readLong(-1000000000000000000LL, 1000000000000000000LL, \"y\");\n    inf.readSpace();\n    long long m = inf.readLong(-1000000000000000000LL, 1000000000000000000LL, \"m\");\n    inf.readEoln();\n    inf.readEof();\n    \n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    \n    long long x = inf.readLong(-1000000000000000000LL, 1000000000000000000LL, \"x\");\n    inf.readSpace();\n    long long y = inf.readLong(-1000000000000000000LL, 1000000000000000000LL, \"y\");\n    inf.readSpace();\n    long long m = inf.readLong(-1000000000000000000LL, 1000000000000000000LL, \"m\");\n    inf.readEoln();\n    inf.readEof();\n    \n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    \n    long long x = inf.readLong(-1000000000000000000LL, 1000000000000000000LL, \"x\");\n    inf.readSpace();\n    long long y = inf.readLong(-1000000000000000000LL, 1000000000000000000LL, \"y\");\n    inf.readSpace();\n    long long m = inf.readLong(-1000000000000000000LL, 1000000000000000000LL, \"m\");\n    inf.readEoln();\n    inf.readEof();\n    \n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst long long LLINF = 1000000000000000000LL;\nconst long long LL_MAX = LLINF;\nconst long long LL_MIN = -LLINF;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    string type = opt<string>(\"type\", \"random\");\n\n    long long x, y, m;\n\n    if (type == \"random\") {\n        // x, y, m randomly in [-1e18, 1e18]\n        x = rnd.next(LL_MIN, LL_MAX);\n        y = rnd.next(LL_MIN, LL_MAX);\n        m = rnd.next(LL_MIN, LL_MAX);\n    } else if (type == \"randomPositive\") {\n        // x, y, m in [0, 1e18]\n        x = rnd.next(0LL, LL_MAX);\n        y = rnd.next(0LL, LL_MAX);\n        m = rnd.next(0LL, LL_MAX);\n    } else if (type == \"randomNegative\") {\n        // x, y, m in [-1e18, 0]\n        x = rnd.next(LL_MIN, 0LL);\n        y = rnd.next(LL_MIN, 0LL);\n        m = rnd.next(LL_MIN, 0LL);\n    } else if (type == \"xGeqM\") {\n        // x ≥ m\n        m = rnd.next(LL_MIN, LL_MAX);\n        x = rnd.next(m, LL_MAX);\n        y = rnd.next(LL_MIN, LL_MAX);\n    } else if (type == \"yGeqM\") {\n        // y ≥ m\n        m = rnd.next(LL_MIN, LL_MAX);\n        y = rnd.next(m, LL_MAX);\n        x = rnd.next(LL_MIN, LL_MAX);\n    } else if (type == \"bothNegative\") {\n        // x ≤ -1, y ≤ -1, m ≥ 1\n        x = rnd.next(LL_MIN, -1LL);\n        y = rnd.next(LL_MIN, -1LL);\n        m = rnd.next(1LL, LL_MAX);\n    } else if (type == \"xNegativeYPositive\") {\n        // x negative, y positive\n        x = rnd.next(LL_MIN, -1LL);\n        y = rnd.next(1LL, LL_MAX);\n        m = rnd.next(LL_MIN, LL_MAX);\n    } else if (type == \"xPositiveYNegative\") {\n        // x positive, y negative\n        x = rnd.next(1LL, LL_MAX);\n        y = rnd.next(LL_MIN, -1LL);\n        m = rnd.next(LL_MIN, LL_MAX);\n    } else if (type == \"zeros\") {\n        // x = 0, y = 0, m = 0\n        x = 0LL;\n        y = 0LL;\n        m = 0LL;\n    } else if (type == \"mZero\") {\n        // m = 0\n        x = rnd.next(LL_MIN, LL_MAX);\n        y = rnd.next(LL_MIN, LL_MAX);\n        m = 0LL;\n    } else if (type == \"mNegative\") {\n        // m negative\n        x = rnd.next(LL_MIN, LL_MAX);\n        y = rnd.next(LL_MIN, LL_MAX);\n        m = rnd.next(LL_MIN, -1LL);\n    } else if (type == \"mPositiveLarge\") {\n        // m = 1e18\n        m = LL_MAX;\n        x = rnd.next(LL_MIN, LL_MAX);\n        y = rnd.next(LL_MIN, LL_MAX);\n    } else if (type == \"mNegativeLarge\") {\n        // m = -1e18\n        m = LL_MIN;\n        x = rnd.next(LL_MIN, LL_MAX);\n        y = rnd.next(LL_MIN, LL_MAX);\n    } else if (type == \"edgeMax\") {\n        // x = y = m = 1e18\n        x = LL_MAX;\n        y = LL_MAX;\n        m = LL_MAX;\n    } else if (type == \"edgeMin\") {\n        // x = y = m = -1e18\n        x = LL_MIN;\n        y = LL_MIN;\n        m = LL_MIN;\n    } else {\n        // Default random case\n        x = rnd.next(LL_MIN, LL_MAX);\n        y = rnd.next(LL_MIN, LL_MAX);\n        m = rnd.next(LL_MIN, LL_MAX);\n    }\n    // Output the test case\n    cout << x << \" \" << y << \" \" << m << endl;\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst long long LLINF = 1000000000000000000LL;\nconst long long LL_MAX = LLINF;\nconst long long LL_MIN = -LLINF;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    string type = opt<string>(\"type\", \"random\");\n\n    long long x, y, m;\n\n    if (type == \"random\") {\n        // x, y, m randomly in [-1e18, 1e18]\n        x = rnd.next(LL_MIN, LL_MAX);\n        y = rnd.next(LL_MIN, LL_MAX);\n        m = rnd.next(LL_MIN, LL_MAX);\n    } else if (type == \"randomPositive\") {\n        // x, y, m in [0, 1e18]\n        x = rnd.next(0LL, LL_MAX);\n        y = rnd.next(0LL, LL_MAX);\n        m = rnd.next(0LL, LL_MAX);\n    } else if (type == \"randomNegative\") {\n        // x, y, m in [-1e18, 0]\n        x = rnd.next(LL_MIN, 0LL);\n        y = rnd.next(LL_MIN, 0LL);\n        m = rnd.next(LL_MIN, 0LL);\n    } else if (type == \"xGeqM\") {\n        // x ≥ m\n        m = rnd.next(LL_MIN, LL_MAX);\n        x = rnd.next(m, LL_MAX);\n        y = rnd.next(LL_MIN, LL_MAX);\n    } else if (type == \"yGeqM\") {\n        // y ≥ m\n        m = rnd.next(LL_MIN, LL_MAX);\n        y = rnd.next(m, LL_MAX);\n        x = rnd.next(LL_MIN, LL_MAX);\n    } else if (type == \"bothNegative\") {\n        // x ≤ -1, y ≤ -1, m ≥ 1\n        x = rnd.next(LL_MIN, -1LL);\n        y = rnd.next(LL_MIN, -1LL);\n        m = rnd.next(1LL, LL_MAX);\n    } else if (type == \"xNegativeYPositive\") {\n        // x negative, y positive\n        x = rnd.next(LL_MIN, -1LL);\n        y = rnd.next(1LL, LL_MAX);\n        m = rnd.next(LL_MIN, LL_MAX);\n    } else if (type == \"xPositiveYNegative\") {\n        // x positive, y negative\n        x = rnd.next(1LL, LL_MAX);\n        y = rnd.next(LL_MIN, -1LL);\n        m = rnd.next(LL_MIN, LL_MAX);\n    } else if (type == \"zeros\") {\n        // x = 0, y = 0, m = 0\n        x = 0LL;\n        y = 0LL;\n        m = 0LL;\n    } else if (type == \"mZero\") {\n        // m = 0\n        x = rnd.next(LL_MIN, LL_MAX);\n        y = rnd.next(LL_MIN, LL_MAX);\n        m = 0LL;\n    } else if (type == \"mNegative\") {\n        // m negative\n        x = rnd.next(LL_MIN, LL_MAX);\n        y = rnd.next(LL_MIN, LL_MAX);\n        m = rnd.next(LL_MIN, -1LL);\n    } else if (type == \"mPositiveLarge\") {\n        // m = 1e18\n        m = LL_MAX;\n        x = rnd.next(LL_MIN, LL_MAX);\n        y = rnd.next(LL_MIN, LL_MAX);\n    } else if (type == \"mNegativeLarge\") {\n        // m = -1e18\n        m = LL_MIN;\n        x = rnd.next(LL_MIN, LL_MAX);\n        y = rnd.next(LL_MIN, LL_MAX);\n    } else if (type == \"edgeMax\") {\n        // x = y = m = 1e18\n        x = LL_MAX;\n        y = LL_MAX;\n        m = LL_MAX;\n    } else if (type == \"edgeMin\") {\n        // x = y = m = -1e18\n        x = LL_MIN;\n        y = LL_MIN;\n        m = LL_MIN;\n    } else {\n        // Default random case\n        x = rnd.next(LL_MIN, LL_MAX);\n        y = rnd.next(LL_MIN, LL_MAX);\n        m = rnd.next(LL_MIN, LL_MAX);\n    }\n    // Output the test case\n    cout << x << \" \" << y << \" \" << m << endl;\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -type random\n./gen -type random\n./gen -type random\n./gen -type randomPositive\n./gen -type randomPositive\n./gen -type randomPositive\n./gen -type randomNegative\n./gen -type randomNegative\n./gen -type randomNegative\n./gen -type xGeqM\n./gen -type xGeqM\n./gen -type yGeqM\n./gen -type yGeqM\n./gen -type bothNegative\n./gen -type bothNegative\n./gen -type xNegativeYPositive\n./gen -type xNegativeYPositive\n./gen -type xPositiveYNegative\n./gen -type xPositiveYNegative\n./gen -type zeros\n./gen -type zeros\n./gen -type mZero\n./gen -type mZero\n./gen -type mNegative\n./gen -type mNegative\n./gen -type mPositiveLarge\n./gen -type mPositiveLarge\n./gen -type mNegativeLarge\n./gen -type mNegativeLarge\n./gen -type edgeMax\n./gen -type edgeMin\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:07:10.610683",
        "total_tutorials": 3,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "317/B",
      "title": "B. Ants",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputFirst input line contains integers n (0 ≤ n ≤ 30000) and t (1 ≤ t ≤ 50000), where n is the number of ants in the colony and t is the number of queries. Each of the next t lines contains coordinates of a query junction: integers xi, yi ( - 109 ≤ xi, yi ≤ 109). Queries may coincide.It is guaranteed that there will be a certain moment of time when no possible movements can happen (in other words, the process will eventually end).",
      "output_spec": "OutputPrint t integers, one per line — the number of ants at the corresponding junctions when the movement of the ants stops.",
      "sample_tests": "ExamplesInputCopy1 30 10 00 -1OutputCopy010InputCopy6 50 -20 -10 00 10 2OutputCopy01210",
      "description": "time limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputFirst input line contains integers n (0 ≤ n ≤ 30000) and t (1 ≤ t ≤ 50000), where n is the number of ants in the colony and t is the number of queries. Each of the next t lines contains coordinates of a query junction: integers xi, yi ( - 109 ≤ xi, yi ≤ 109). Queries may coincide.It is guaranteed that there will be a certain moment of time when no possible movements can happen (in other words, the process will eventually end).\n\nOutputPrint t integers, one per line — the number of ants at the corresponding junctions when the movement of the ants stops.\n\nInputCopy1 30 10 00 -1OutputCopy010InputCopy6 50 -20 -10 00 10 2OutputCopy01210\n\nInputCopy1 30 10 00 -1\n\nOutputCopy010\n\nInputCopy6 50 -20 -10 00 10 2\n\nOutputCopy01210\n\nNoteIn the first sample the colony consists of the one ant, so nothing happens at all.In the second sample the colony consists of 6 ants. At the first minute 4 ants scatter from (0, 0) to the neighbouring junctions. After that the process stops.",
      "solutions": [
        {
          "title": "Codeforces Round #188 - Codeforces",
          "content": "Hello, friends! Winter 188th Codeforces Round is coming!We wished to prepare for you some enjoyable problems (as we believe, not very difficult) with nice ideas and clear statements.\"We\" includes authors of the problems yaro and Rei, Codeforces Rounds supervisor Gerald and the platform founder MikeMirzayanov. Special thanks to Pasha (PavelKunyavskiy) and Artem (RAD) for the testing and helpful comments.Last time I was preparing a competition here on Codeforces, Rounds were still \"beta\". Well, with less \"beta\" comes greater responsibility. So I wish the authors and the organizers a successfully held Round. As for the participants, I wish you the unconventional ideas, the clean code (and a clean keyboard, of course), and satisfaction from five (well, possibly the less number will also do...) correct and accepted solutions!It seems to us that it is not an easy job to arrange the problems by their difficulty, so we have chosen the dynamic scores. Still (out of curiousity) let us put a bet on the following relative difficulties for the problems: div.1 — B-B-C-C-E, div.2 — A-B-C-C-E. How close is our guess?UPD Sorry for the problems with the Codeforces testing queue during the round.We will still be happy if you rate our contest (when it will be over): short survey.And with the gap of one hack the winner of div.1 is meret (Jakub Pachocki)!Div.1 standings, Div.2 standings.Analysis (thanks to Rei for the translation).",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/7862",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1433
        },
        {
          "title": "Codeforces Round #188 (analysis) - Codeforces",
          "content": "Problem analysis v 0.9.318A - Even OddsIn this problem we need to understand how exactly numbers from 1 to n rearrange when we write firstly all odd numbers and after them all even numbers. To find out which number stands at position k one needs to find the position where even numbers start and output either the position of the odd number from the first half of the sequence or for the even number from the second half of the sequence.318B - Strings of PowerIn the heavy metal problem one needs to find the number of the substrings in the string S with a given prefix A and given suffix B. If we mark black all the starting positions of the entries of the string A in S, and white all the starting positions of the entries of the string B, then we come to the following problem: count the number of pairs <black position, white position> (in this order). To solve this it is enough to iterate from left to right counting the number of the passed black positions. Meeting black position we increment this number by one, meeting white position we add to the answer the number of pairs with this white position, which is exactly our memorized number of the already passed black positions.317A - Perfect Pair318C - Perfect PairThis problem were more about accuracy then about ideas or coding. It is important to not forget any cases here.On each step we replace one of the numbers x, y by their sum x + y until the pair becomes m-perfect (id est one of them becomes not lesser than m). It is clear that one sould replace lesser number from the pair x, y. Indeed lets say the pair x1 ≤ y1 dominates the pair x2 ≤ y2, if y1 ≥ y2 and x1 ≥ y2. In this case if one can get m-perfect pair from x2, y2 by certain sequence of actions, then one can get m-perfect pair from x1, y1 by the same or shorter sequence of actions. If x ≤ y, then the pair x + y, y dominates the pair x + y, x. Hence path from x + y, y to m-perfect is not longer than from x + y, x, and we may assume that we choose exactly this pair.Consider following cases: x ≤ 0, y ≤ 0 In this case our numbers do not increase in the process. Hence either the pair is alredy m-perfect or it will never be. x > 0 and y > 0 In this case for each m pair will after several steps become m-perfect. To count precise number of those steps one needs to launch emulation. If x > 0 and y > 0, then pair \"grows exponentionaly>> (more formally: easy to show that starting from secnd step sum x + y grows in at least 3 / 2 times each step) and emulation works pretty fast. However in the case x < 0 and y > 0 (or vice versa) pair might change very slowly. Most bright example is x =  - 1018, y = 1. Thus one needs to count number of steps until both numbers becomes positive before launching emulationt. For x < 0 and y > 0 number of those steps is exactly . 317B - Ants318D - AntsOne may reformulate the problem ass follows. Non-negative integers A(x, y) are placed in the vertices of two-dimensional lattice We may imagine this construction as a function . On each step for each vertex P = (x, y) with A(x, y) ≥ 4 we perform operation φP, which substracts 4 from A(x, y) and adds 1 to A(x, y - 1), A(x, y + 1), A(x - 1, y), A(x + 1, y). We may think that operation φP applies to the whole function A. We need to find values of A after the iterations stops.Key idea is that operactions φP and φQ for all points P and Q commutes, that is φP(φQ(A)) = φQ(φP(A)). This means that the order of operations is unimportant. In particular, we may assume that from each given vertex run all possible four-groups of ants and not only one. After this observation one may run full emulation of the process. As an exercise contestants may check that ants will never leave square 200 × 200 with center in the origin 0 with given constraints.317C - Balance318E - BalanceIn this problem we need to find 2n2 transfusions from initial configuration to the desired one. First of all we propose the following: if in each connected component overall volume of the water in initial configuration is the same as in desired one, then answer exist. We call the vessel ready, if current volume of its water equals desired one. Let us describe solution which is probably easier to code. We will make vessels ready one by one. Consider the pair of non-ready vessels s and t (there is more water in s than desired, and less water in t than desired), such that they are connected by the path P, and if one transfuses d litres from s to t then one of the vessels becomes ready. Now we need to find a way to transfuse d litres by path P from s to t. One may write recursive function pour(s, t, d) for this aim. Let t' stand before t in this path, then function works as follows: transfuses from t' to t as many water as possible (not more than d of course), then calls pour(s, t', d) and on the final step transfuses from t' to t all that left. It is easy to check that all such transfusions are correct. This algorithm makes 2len transfusions on the path of length len, so total number of transfusions is not greater than 2n2.317D - Game with PowersFor each numner x denote sequence of its powers within [1..n] as Pow(x): Game proceeds as follows: on each step one player takes still available number x from 1 to n and prohibits whole set Pow(x). Who can't make his turn loses.This game may be decomposed in the sum of lesser games. Indeed, lets call number x simple (and corresponding sequence Pow(x) simple), if it is not a power of any number y < x. Then: 1. for each there is simple x, such that ; 2. for each simple distinct x and y sets Pow(x) and P(y) do not intersect. Indeed, for a given k there is exactly one simple x such that k is power of x. This may be showed from fundamental theorem of arithmetic: if and d = gcd(α1, α2, ..., αn), then .Hence set [1..n] decomposes into primitive sets Pow(x), on each of those Pow(x) game proceeds independetly. Now one may use Sprague–Grundy theory to see that mexx of our game is just xor of all mexx of games on simple Pow(x). For fixed x, if Pow(x) = {x, x2, ..., xs}, then mexx of the game on Pow(x) depends only on s, but not on x. In our case s runs from 1 to 29, mexx for all such s may be directly precalculated. Now it is enough to find numbers q(s) of simple x with a given size of Pow(x) equal to s (actually we are interested in parity of q(s) not in q(s) itself).Our constraints allows to do it directly: run x from 2 to , if it is not crossed out, determine the size Pow(x) [increment corresponding q(s)], and cross out all numbers from Pow(x). This cycle finds all simple sequences of length at least 2. Quantity of non-crossed numbers is the number of all simple sequences of length 1. Now it is enough to look at parities of q(s) and xor coressponding mexx.However one may find all q(s) for . Indeed lets look at the number and sequence {x, x2, x3, x4, ..., xs}. This sequence is not simple iff it is containd in some larger simple sequence. But number of subsequenes of size s in a given sequence of size t > s is easy to find: it is just [t / s]. Recalling that simple sequences do not intersect one gets the reccurent formula:. Now it is easy to find all q(s) from q(29) to q(1).Remark: while coding it is important to remeber simple number x = 1.317E - Princess and Her ShadowIn this problem princess Vlada should simply catch the Shadow. Here is the idea of a solution. If there is only one tree, then using it as a barrier to the shadow it is not hard to catch the shadow. Similar technique works if Vlada and Shadow are far from the square where all the trees grow. But what can she do in the dark depths of the forest? If there is no path at all between Vlada and Shadow, then there is no way to catch it. Otherwise consider a shortest path from Vlada to the Shadow and make Vlada follow it. This path gives Vlada a queue of the steps that she should perform. Additionaly if shadow moves, then we add her move to the queue (simply speaking Vlada follows the shadow). This is where the algorithmic part ends. Now we state that either Vlada catches the shadow in the desired number of steps, or steps out of the \"forest square\". To proof this we note that the length of the path between Vlada and Shadow may only decrease. And if it does not decrease long enough, then once in k steps (k is the length of the path) Vlada and Shadow shifts at the same vector over and over, and at some moment leaves the \"forest square\". Note that if the trees allow our heroes to step out of the \"forest square\" at the beginning, then we may just get them out from the start. But taking this approach we still need to catch the Shadow in a \"labyrinth forest\".Apologies for the delay. There are probably misprints and mistakes here (thousands of them!), please feel free to point them out.",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/7956",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 317\\s*B"
          },
          "content_length": 8753
        },
        {
          "title": "Codeforces Round #188 (analysis) - Codeforces",
          "content": "Problem analysis v 0.9.318A - Even OddsIn this problem we need to understand how exactly numbers from 1 to n rearrange when we write firstly all odd numbers and after them all even numbers. To find out which number stands at position k one needs to find the position where even numbers start and output either the position of the odd number from the first half of the sequence or for the even number from the second half of the sequence.318B - Strings of PowerIn the heavy metal problem one needs to find the number of the substrings in the string S with a given prefix A and given suffix B. If we mark black all the starting positions of the entries of the string A in S, and white all the starting positions of the entries of the string B, then we come to the following problem: count the number of pairs <black position, white position> (in this order). To solve this it is enough to iterate from left to right counting the number of the passed black positions. Meeting black position we increment this number by one, meeting white position we add to the answer the number of pairs with this white position, which is exactly our memorized number of the already passed black positions.317A - Perfect Pair318C - Perfect PairThis problem were more about accuracy then about ideas or coding. It is important to not forget any cases here.On each step we replace one of the numbers x, y by their sum x + y until the pair becomes m-perfect (id est one of them becomes not lesser than m). It is clear that one sould replace lesser number from the pair x, y. Indeed lets say the pair x1 ≤ y1 dominates the pair x2 ≤ y2, if y1 ≥ y2 and x1 ≥ y2. In this case if one can get m-perfect pair from x2, y2 by certain sequence of actions, then one can get m-perfect pair from x1, y1 by the same or shorter sequence of actions. If x ≤ y, then the pair x + y, y dominates the pair x + y, x. Hence path from x + y, y to m-perfect is not longer than from x + y, x, and we may assume that we choose exactly this pair.Consider following cases: x ≤ 0, y ≤ 0 In this case our numbers do not increase in the process. Hence either the pair is alredy m-perfect or it will never be. x > 0 and y > 0 In this case for each m pair will after several steps become m-perfect. To count precise number of those steps one needs to launch emulation. If x > 0 and y > 0, then pair \"grows exponentionaly>> (more formally: easy to show that starting from secnd step sum x + y grows in at least 3 / 2 times each step) and emulation works pretty fast. However in the case x < 0 and y > 0 (or vice versa) pair might change very slowly. Most bright example is x =  - 1018, y = 1. Thus one needs to count number of steps until both numbers becomes positive before launching emulationt. For x < 0 and y > 0 number of those steps is exactly . 317B - Ants318D - AntsOne may reformulate the problem ass follows. Non-negative integers A(x, y) are placed in the vertices of two-dimensional lattice We may imagine this construction as a function . On each step for each vertex P = (x, y) with A(x, y) ≥ 4 we perform operation φP, which substracts 4 from A(x, y) and adds 1 to A(x, y - 1), A(x, y + 1), A(x - 1, y), A(x + 1, y). We may think that operation φP applies to the whole function A. We need to find values of A after the iterations stops.Key idea is that operactions φP and φQ for all points P and Q commutes, that is φP(φQ(A)) = φQ(φP(A)). This means that the order of operations is unimportant. In particular, we may assume that from each given vertex run all possible four-groups of ants and not only one. After this observation one may run full emulation of the process. As an exercise contestants may check that ants will never leave square 200 × 200 with center in the origin 0 with given constraints.317C - Balance318E - BalanceIn this problem we need to find 2n2 transfusions from initial configuration to the desired one. First of all we propose the following: if in each connected component overall volume of the water in initial configuration is the same as in desired one, then answer exist. We call the vessel ready, if current volume of its water equals desired one. Let us describe solution which is probably easier to code. We will make vessels ready one by one. Consider the pair of non-ready vessels s and t (there is more water in s than desired, and less water in t than desired), such that they are connected by the path P, and if one transfuses d litres from s to t then one of the vessels becomes ready. Now we need to find a way to transfuse d litres by path P from s to t. One may write recursive function pour(s, t, d) for this aim. Let t' stand before t in this path, then function works as follows: transfuses from t' to t as many water as possible (not more than d of course), then calls pour(s, t', d) and on the final step transfuses from t' to t all that left. It is easy to check that all such transfusions are correct. This algorithm makes 2len transfusions on the path of length len, so total number of transfusions is not greater than 2n2.317D - Game with PowersFor each numner x denote sequence of its powers within [1..n] as Pow(x): Game proceeds as follows: on each step one player takes still available number x from 1 to n and prohibits whole set Pow(x). Who can't make his turn loses.This game may be decomposed in the sum of lesser games. Indeed, lets call number x simple (and corresponding sequence Pow(x) simple), if it is not a power of any number y < x. Then: 1. for each there is simple x, such that ; 2. for each simple distinct x and y sets Pow(x) and P(y) do not intersect. Indeed, for a given k there is exactly one simple x such that k is power of x. This may be showed from fundamental theorem of arithmetic: if and d = gcd(α1, α2, ..., αn), then .Hence set [1..n] decomposes into primitive sets Pow(x), on each of those Pow(x) game proceeds independetly. Now one may use Sprague–Grundy theory to see that mexx of our game is just xor of all mexx of games on simple Pow(x). For fixed x, if Pow(x) = {x, x2, ..., xs}, then mexx of the game on Pow(x) depends only on s, but not on x. In our case s runs from 1 to 29, mexx for all such s may be directly precalculated. Now it is enough to find numbers q(s) of simple x with a given size of Pow(x) equal to s (actually we are interested in parity of q(s) not in q(s) itself).Our constraints allows to do it directly: run x from 2 to , if it is not crossed out, determine the size Pow(x) [increment corresponding q(s)], and cross out all numbers from Pow(x). This cycle finds all simple sequences of length at least 2. Quantity of non-crossed numbers is the number of all simple sequences of length 1. Now it is enough to look at parities of q(s) and xor coressponding mexx.However one may find all q(s) for . Indeed lets look at the number and sequence {x, x2, x3, x4, ..., xs}. This sequence is not simple iff it is containd in some larger simple sequence. But number of subsequenes of size s in a given sequence of size t > s is easy to find: it is just [t / s]. Recalling that simple sequences do not intersect one gets the reccurent formula:. Now it is easy to find all q(s) from q(29) to q(1).Remark: while coding it is important to remeber simple number x = 1.317E - Princess and Her ShadowIn this problem princess Vlada should simply catch the Shadow. Here is the idea of a solution. If there is only one tree, then using it as a barrier to the shadow it is not hard to catch the shadow. Similar technique works if Vlada and Shadow are far from the square where all the trees grow. But what can she do in the dark depths of the forest? If there is no path at all between Vlada and Shadow, then there is no way to catch it. Otherwise consider a shortest path from Vlada to the Shadow and make Vlada follow it. This path gives Vlada a queue of the steps that she should perform. Additionaly if shadow moves, then we add her move to the queue (simply speaking Vlada follows the shadow). This is where the algorithmic part ends. Now we state that either Vlada catches the shadow in the desired number of steps, or steps out of the \"forest square\". To proof this we note that the length of the path between Vlada and Shadow may only decrease. And if it does not decrease long enough, then once in k steps (k is the length of the path) Vlada and Shadow shifts at the same vector over and over, and at some moment leaves the \"forest square\". Note that if the trees allow our heroes to step out of the \"forest square\" at the beginning, then we may just get them out from the start. But taking this approach we still need to catch the Shadow in a \"labyrinth forest\".Apologies for the delay. There are probably misprints and mistakes here (thousands of them!), please feel free to point them out.",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/7956",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 317\\s*B"
          },
          "content_length": 8753
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #188 - Codeforces - Code 1",
          "code": "-1000000000000000000 1 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7862",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #188 - Codeforces - Code 2",
          "code": "...\nlong long x,y,m;\nlong long res;\n...\nint mymx = max(x,y); // int ???\nint mymn = min(x,y); // int ???\n\nx = mymx;\ny = mymn;\n...",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7862",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #188 - Codeforces - Code 3",
          "code": "...\nlong long x,y,m;\nlong long res;\n...\nint mymx = max(x,y); // int ???\nint mymn = min(x,y); // int ???\n\nx = mymx;\ny = mymn;\n...",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7862",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #188 - Codeforces - Code 4",
          "code": "s.size() < 4",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7862",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #188 - Codeforces - Code 5",
          "code": "s.size() - 4",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7862",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #188 - Codeforces - Code 6",
          "code": "#define SZ(x) (int)x.size()",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7862",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #188 - Codeforces - Code 7",
          "code": "Contest rating",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7862",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #188 (analysis) - Codeforces - Code 1",
          "code": "Thank you for the nice contest and editorial. \nIn \"Ants\" problem, Is there any way to expect the simulation will be converge so fast before we writing brute force code? how to make sure n = 30000 is the worst case?",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7956",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #188 (analysis) - Codeforces - Code 2",
          "code": "Thank you for the nice contest and editorial. \nIn \"Ants\" problem, Is there any way to expect the simulation will be converge so fast before we writing brute force code? how to make sure n = 30000 is the worst case?",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7956",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #188 (analysis) - Codeforces - Code 3",
          "code": "#include <string.h>\n#include <cstdio>\n#include <map>\nusing namespace std;\nmap<long long ,int>SG;\nint DFS(long long state) {\n    //printf(\"%I64d\\n\",state);getchar();getchar();\n    if(state==0) return 0;\n    if(SG[state]) return SG[state];\n    int len=0;long long tmp=state;\n    while(tmp>0) {\n        len++;\n        tmp>>=1;\n    }\n    bool cnt[100];memset(cnt,0,sizeof(cnt));\n    for(int i=1;i<=len;i++) {\n        long long k=(1<<(i-1)),tmp=state;\n        while(k<=tmp) {\n            tmp&=(((1<<(len+1))-1)^k);//printf(\"%lld\\n\",k);\n            k<<=i;\n\t\t}//printf(\"%lld\\n\",tmp);\n\t\tif(tmp==state) continue;\n        int ret=DFS(tmp);\n        cnt[ret]=1;\n    }\n    for(int i=0;;i++)if(!cnt[i]){\n        //printf(\"%d %d\\n\",len,i);\n        return (SG[state]=i);\n    }\n}\nint main()\n{\n    for(int I=1;I<=29;I++) {\n        printf(\"%d\\n\",DFS((long long )((1<<I)-1)));\n    }\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/7956",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #188 (analysis) - Codeforces - Code 4",
          "code": "#include <string.h>\n#include <cstdio>\n#include <map>\nusing namespace std;\nmap<long long ,int>SG;\nint DFS(long long state) {\n    //printf(\"%I64d\\n\",state);getchar();getchar();\n    if(state==0) return 0;\n    if(SG[state]) return SG[state];\n    int len=0;long long tmp=state;\n    while(tmp>0) {\n        len++;\n        tmp>>=1;\n    }\n    bool cnt[100];memset(cnt,0,sizeof(cnt));\n    for(int i=1;i<=len;i++) {\n        long long k=(1<<(i-1)),tmp=state;\n        while(k<=tmp) {\n            tmp&=(((1<<(len+1))-1)^k);//printf(\"%lld\\n\",k);\n            k<<=i;\n\t\t}//printf(\"%lld\\n\",tmp);\n\t\tif(tmp==state) continue;\n        int ret=DFS(tmp);\n        cnt[ret]=1;\n    }\n    for(int i=0;;i++)if(!cnt[i]){\n        //printf(\"%d %d\\n\",len,i);\n        return (SG[state]=i);\n    }\n}\nint main()\n{\n    for(int I=1;I<=29;I++) {\n        printf(\"%d\\n\",DFS((long long )((1<<I)-1)));\n    }\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/7956",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #188 (analysis) - Codeforces - Code 1",
          "code": "Thank you for the nice contest and editorial. \nIn \"Ants\" problem, Is there any way to expect the simulation will be converge so fast before we writing brute force code? how to make sure n = 30000 is the worst case?",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7956",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #188 (analysis) - Codeforces - Code 2",
          "code": "Thank you for the nice contest and editorial. \nIn \"Ants\" problem, Is there any way to expect the simulation will be converge so fast before we writing brute force code? how to make sure n = 30000 is the worst case?",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7956",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #188 (analysis) - Codeforces - Code 3",
          "code": "#include <string.h>\n#include <cstdio>\n#include <map>\nusing namespace std;\nmap<long long ,int>SG;\nint DFS(long long state) {\n    //printf(\"%I64d\\n\",state);getchar();getchar();\n    if(state==0) return 0;\n    if(SG[state]) return SG[state];\n    int len=0;long long tmp=state;\n    while(tmp>0) {\n        len++;\n        tmp>>=1;\n    }\n    bool cnt[100];memset(cnt,0,sizeof(cnt));\n    for(int i=1;i<=len;i++) {\n        long long k=(1<<(i-1)),tmp=state;\n        while(k<=tmp) {\n            tmp&=(((1<<(len+1))-1)^k);//printf(\"%lld\\n\",k);\n            k<<=i;\n\t\t}//printf(\"%lld\\n\",tmp);\n\t\tif(tmp==state) continue;\n        int ret=DFS(tmp);\n        cnt[ret]=1;\n    }\n    for(int i=0;;i++)if(!cnt[i]){\n        //printf(\"%d %d\\n\",len,i);\n        return (SG[state]=i);\n    }\n}\nint main()\n{\n    for(int I=1;I<=29;I++) {\n        printf(\"%d\\n\",DFS((long long )((1<<I)-1)));\n    }\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/7956",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #188 (analysis) - Codeforces - Code 4",
          "code": "#include <string.h>\n#include <cstdio>\n#include <map>\nusing namespace std;\nmap<long long ,int>SG;\nint DFS(long long state) {\n    //printf(\"%I64d\\n\",state);getchar();getchar();\n    if(state==0) return 0;\n    if(SG[state]) return SG[state];\n    int len=0;long long tmp=state;\n    while(tmp>0) {\n        len++;\n        tmp>>=1;\n    }\n    bool cnt[100];memset(cnt,0,sizeof(cnt));\n    for(int i=1;i<=len;i++) {\n        long long k=(1<<(i-1)),tmp=state;\n        while(k<=tmp) {\n            tmp&=(((1<<(len+1))-1)^k);//printf(\"%lld\\n\",k);\n            k<<=i;\n\t\t}//printf(\"%lld\\n\",tmp);\n\t\tif(tmp==state) continue;\n        int ret=DFS(tmp);\n        cnt[ret]=1;\n    }\n    for(int i=0;;i++)if(!cnt[i]){\n        //printf(\"%d %d\\n\",len,i);\n        return (SG[state]=i);\n    }\n}\nint main()\n{\n    for(int I=1;I<=29;I++) {\n        printf(\"%d\\n\",DFS((long long )((1<<I)-1)));\n    }\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/7956",
          "author": "Qingyu"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(0, 30000, \"n\");\n    inf.readSpace();\n    int t = inf.readInt(1, 50000, \"t\");\n    inf.readEoln();\n    for (int i = 0; i < t; i++) {\n        int x = inf.readInt(-1000000000, 1000000000, \"xi\");\n        inf.readSpace();\n        int y = inf.readInt(-1000000000, 1000000000, \"yi\");\n        inf.readEoln();\n    }\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(0, 30000, \"n\");\n    inf.readSpace();\n    int t = inf.readInt(1, 50000, \"t\");\n    inf.readEoln();\n    for (int i = 0; i < t; i++) {\n        int x = inf.readInt(-1000000000, 1000000000, \"xi\");\n        inf.readSpace();\n        int y = inf.readInt(-1000000000, 1000000000, \"yi\");\n        inf.readEoln();\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(0, 30000, \"n\");\n    inf.readSpace();\n    int t = inf.readInt(1, 50000, \"t\");\n    inf.readEoln();\n    for (int i = 0; i < t; i++) {\n        int x = inf.readInt(-1000000000, 1000000000, \"xi\");\n        inf.readSpace();\n        int y = inf.readInt(-1000000000, 1000000000, \"yi\");\n        inf.readEoln();\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    int n = opt<int>(\"n\"); // Number of ants at origin\n    int t = opt<int>(\"t\"); // Number of queries\n    string qtype = opt<string>(\"qtype\", \"random\"); // Type of queries\n\n    // Output n and t\n    printf(\"%d %d\\n\", n, t);\n\n    // Generate queries based on qtype\n    vector<pair<int, int>> queries;\n    if (qtype == \"origin\") {\n        // All queries at (0, 0)\n        for (int i = 0; i < t; ++i) {\n            queries.push_back({0, 0});\n        }\n    } else if (qtype == \"neighbor\") {\n        // Queries at positions adjacent to (0, 0)\n        int dx[] = {1, -1, 0, 0};\n        int dy[] = {0, 0, 1, -1};\n        for (int i = 0; i < t; ++i) {\n            int dir = i % 4;\n            queries.push_back({dx[dir], dy[dir]});\n        }\n    } else if (qtype == \"line\") {\n        // Queries along the x-axis\n        for (int i = 0; i < t; ++i) {\n            queries.push_back({i, 0});\n        }\n    } else if (qtype == \"far\") {\n        // Queries at positions far from origin\n        for (int i = 0; i < t; ++i) {\n            int x = rnd.next(-1000000000, 1000000000);\n            int y = rnd.next(-1000000000, 1000000000);\n            queries.push_back({x, y});\n        }\n    } else if (qtype == \"duplicate\") {\n        // Duplicate queries\n        int x = rnd.next(-100, 100);\n        int y = rnd.next(-100, 100);\n        for (int i = 0; i < t; ++i) {\n            queries.push_back({x, y});\n        }\n    } else if (qtype == \"mixed\") {\n        // Mixed queries\n        for (int i = 0; i < t; ++i) {\n            int type = rnd.next(0, 4);\n            if (type == 0) {\n                queries.push_back({0, 0});\n            } else if (type == 1) {\n                int x = rnd.next(-1000, 1000);\n                int y = rnd.next(-1000, 1000);\n                queries.push_back({x, y});\n            } else if (type == 2) {\n                int x = rnd.next(-1000000000, 1000000000);\n                int y = rnd.next(-1000000000, 1000000000);\n                queries.push_back({x, y});\n            } else {\n                int x = rnd.next(-10, 10);\n                int y = rnd.next(-10, 10);\n                queries.push_back({x, y});\n            }\n        }\n    } else {\n        // Default to random\n        for (int i = 0; i < t; ++i) {\n            int x = rnd.next(-1000000000, 1000000000);\n            int y = rnd.next(-1000000000, 1000000000);\n            queries.push_back({x, y});\n        }\n    }\n\n    // Output queries\n    for (auto& p : queries) {\n        printf(\"%d %d\\n\", p.first, p.second);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    int n = opt<int>(\"n\"); // Number of ants at origin\n    int t = opt<int>(\"t\"); // Number of queries\n    string qtype = opt<string>(\"qtype\", \"random\"); // Type of queries\n\n    // Output n and t\n    printf(\"%d %d\\n\", n, t);\n\n    // Generate queries based on qtype\n    vector<pair<int, int>> queries;\n    if (qtype == \"origin\") {\n        // All queries at (0, 0)\n        for (int i = 0; i < t; ++i) {\n            queries.push_back({0, 0});\n        }\n    } else if (qtype == \"neighbor\") {\n        // Queries at positions adjacent to (0, 0)\n        int dx[] = {1, -1, 0, 0};\n        int dy[] = {0, 0, 1, -1};\n        for (int i = 0; i < t; ++i) {\n            int dir = i % 4;\n            queries.push_back({dx[dir], dy[dir]});\n        }\n    } else if (qtype == \"line\") {\n        // Queries along the x-axis\n        for (int i = 0; i < t; ++i) {\n            queries.push_back({i, 0});\n        }\n    } else if (qtype == \"far\") {\n        // Queries at positions far from origin\n        for (int i = 0; i < t; ++i) {\n            int x = rnd.next(-1000000000, 1000000000);\n            int y = rnd.next(-1000000000, 1000000000);\n            queries.push_back({x, y});\n        }\n    } else if (qtype == \"duplicate\") {\n        // Duplicate queries\n        int x = rnd.next(-100, 100);\n        int y = rnd.next(-100, 100);\n        for (int i = 0; i < t; ++i) {\n            queries.push_back({x, y});\n        }\n    } else if (qtype == \"mixed\") {\n        // Mixed queries\n        for (int i = 0; i < t; ++i) {\n            int type = rnd.next(0, 4);\n            if (type == 0) {\n                queries.push_back({0, 0});\n            } else if (type == 1) {\n                int x = rnd.next(-1000, 1000);\n                int y = rnd.next(-1000, 1000);\n                queries.push_back({x, y});\n            } else if (type == 2) {\n                int x = rnd.next(-1000000000, 1000000000);\n                int y = rnd.next(-1000000000, 1000000000);\n                queries.push_back({x, y});\n            } else {\n                int x = rnd.next(-10, 10);\n                int y = rnd.next(-10, 10);\n                queries.push_back({x, y});\n            }\n        }\n    } else {\n        // Default to random\n        for (int i = 0; i < t; ++i) {\n            int x = rnd.next(-1000000000, 1000000000);\n            int y = rnd.next(-1000000000, 1000000000);\n            queries.push_back({x, y});\n        }\n    }\n\n    // Output queries\n    for (auto& p : queries) {\n        printf(\"%d %d\\n\", p.first, p.second);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 0 -t 1 -qtype origin\n./gen -n 1 -t 1 -qtype origin\n./gen -n 2 -t 1 -qtype origin\n./gen -n 3 -t 4 -qtype neighbor\n./gen -n 4 -t 5 -qtype neighbor\n./gen -n 5 -t 10 -qtype neighbor\n./gen -n 10 -t 10 -qtype line\n./gen -n 100 -t 50 -qtype line\n./gen -n 1000 -t 1000 -qtype line\n./gen -n 30000 -t 50000 -qtype far\n./gen -n 30000 -t 50000 -qtype random\n./gen -n 30000 -t 50000 -qtype duplicate\n./gen -n 10000 -t 50000 -qtype mixed\n./gen -n 100 -t 50000 -qtype mixed\n./gen -n 30000 -t 1 -qtype origin\n./gen -n 30000 -t 1 -qtype neighbor\n./gen -n 12345 -t 50000 -qtype random\n./gen -n 0 -t 50000 -qtype random\n./gen -n 29999 -t 50000 -qtype far\n./gen -n 4 -t 10 -qtype line\n./gen -n 30000 -t 50000 -qtype mixed\n./gen -n 30000 -t 50000 -qtype neighbor\n./gen -n 1 -t 1 -qtype far\n./gen -n 3 -t 50000 -qtype duplicate\n./gen -n 10000 -t 50000 -qtype duplicate\n./gen -n 0 -t 50000 -qtype duplicate\n./gen -n 5 -t 50000 -qtype line\n./gen -n 30000 -t 1 -qtype far\n./gen -n 20 -t 20 -qtype line\n./gen -n 10 -t 20 -qtype mixed\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:07:12.648271",
        "total_tutorials": 3,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "317/C",
      "title": "C. Balance",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputFirst line of the input contains integers n, v, e (1 ≤ n ≤ 300, 1 ≤ v ≤ 109, 0 ≤ e ≤ 50000).Next two lines contain n integers each: initial ai and the desired amounts bi of water in corresponding vessels (0 ≤ ai, bi ≤ v).Next e lines describe one tube each in the format x y (1 ≤ x, y ≤ n, x ≠ y) for a tube between vessels number x and y. There might be multiple tubes between two vessels. You may assume that vessels are numbered from 1 to n in some way.",
      "output_spec": "OutputPrint \"NO\" (without quotes), if such sequence of transfusions does not exist.Otherwise print any suitable sequence in the following format. On the first line print the total number of transfusions k (k should not exceed 2·n2). In the following k lines print transfusions in the format x y d (transfusion of d liters from the vessel number x to the vessel number y, x and y must be distinct). For all transfusions d must be a non-negative integer.",
      "sample_tests": "ExamplesInputCopy2 10 11 95 51 2OutputCopy12 1 4InputCopy2 10 05 24 2OutputCopyNOInputCopy2 10 04 24 2OutputCopy0",
      "description": "time limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputFirst line of the input contains integers n, v, e (1 ≤ n ≤ 300, 1 ≤ v ≤ 109, 0 ≤ e ≤ 50000).Next two lines contain n integers each: initial ai and the desired amounts bi of water in corresponding vessels (0 ≤ ai, bi ≤ v).Next e lines describe one tube each in the format x y (1 ≤ x, y ≤ n, x ≠ y) for a tube between vessels number x and y. There might be multiple tubes between two vessels. You may assume that vessels are numbered from 1 to n in some way.\n\nOutputPrint \"NO\" (without quotes), if such sequence of transfusions does not exist.Otherwise print any suitable sequence in the following format. On the first line print the total number of transfusions k (k should not exceed 2·n2). In the following k lines print transfusions in the format x y d (transfusion of d liters from the vessel number x to the vessel number y, x and y must be distinct). For all transfusions d must be a non-negative integer.\n\nInputCopy2 10 11 95 51 2OutputCopy12 1 4InputCopy2 10 05 24 2OutputCopyNOInputCopy2 10 04 24 2OutputCopy0\n\nInputCopy2 10 11 95 51 2\n\nOutputCopy12 1 4\n\nInputCopy2 10 05 24 2\n\nOutputCopyNO\n\nInputCopy2 10 04 24 2\n\nOutputCopy0",
      "solutions": [
        {
          "title": "Codeforces Round #188 - Codeforces",
          "content": "Hello, friends! Winter 188th Codeforces Round is coming!We wished to prepare for you some enjoyable problems (as we believe, not very difficult) with nice ideas and clear statements.\"We\" includes authors of the problems yaro and Rei, Codeforces Rounds supervisor Gerald and the platform founder MikeMirzayanov. Special thanks to Pasha (PavelKunyavskiy) and Artem (RAD) for the testing and helpful comments.Last time I was preparing a competition here on Codeforces, Rounds were still \"beta\". Well, with less \"beta\" comes greater responsibility. So I wish the authors and the organizers a successfully held Round. As for the participants, I wish you the unconventional ideas, the clean code (and a clean keyboard, of course), and satisfaction from five (well, possibly the less number will also do...) correct and accepted solutions!It seems to us that it is not an easy job to arrange the problems by their difficulty, so we have chosen the dynamic scores. Still (out of curiousity) let us put a bet on the following relative difficulties for the problems: div.1 — B-B-C-C-E, div.2 — A-B-C-C-E. How close is our guess?UPD Sorry for the problems with the Codeforces testing queue during the round.We will still be happy if you rate our contest (when it will be over): short survey.And with the gap of one hack the winner of div.1 is meret (Jakub Pachocki)!Div.1 standings, Div.2 standings.Analysis (thanks to Rei for the translation).",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/7862",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1433
        },
        {
          "title": "Codeforces Round #188 (analysis) - Codeforces",
          "content": "Problem analysis v 0.9.318A - Even OddsIn this problem we need to understand how exactly numbers from 1 to n rearrange when we write firstly all odd numbers and after them all even numbers. To find out which number stands at position k one needs to find the position where even numbers start and output either the position of the odd number from the first half of the sequence or for the even number from the second half of the sequence.318B - Strings of PowerIn the heavy metal problem one needs to find the number of the substrings in the string S with a given prefix A and given suffix B. If we mark black all the starting positions of the entries of the string A in S, and white all the starting positions of the entries of the string B, then we come to the following problem: count the number of pairs <black position, white position> (in this order). To solve this it is enough to iterate from left to right counting the number of the passed black positions. Meeting black position we increment this number by one, meeting white position we add to the answer the number of pairs with this white position, which is exactly our memorized number of the already passed black positions.317A - Perfect Pair318C - Perfect PairThis problem were more about accuracy then about ideas or coding. It is important to not forget any cases here.On each step we replace one of the numbers x, y by their sum x + y until the pair becomes m-perfect (id est one of them becomes not lesser than m). It is clear that one sould replace lesser number from the pair x, y. Indeed lets say the pair x1 ≤ y1 dominates the pair x2 ≤ y2, if y1 ≥ y2 and x1 ≥ y2. In this case if one can get m-perfect pair from x2, y2 by certain sequence of actions, then one can get m-perfect pair from x1, y1 by the same or shorter sequence of actions. If x ≤ y, then the pair x + y, y dominates the pair x + y, x. Hence path from x + y, y to m-perfect is not longer than from x + y, x, and we may assume that we choose exactly this pair.Consider following cases: x ≤ 0, y ≤ 0 In this case our numbers do not increase in the process. Hence either the pair is alredy m-perfect or it will never be. x > 0 and y > 0 In this case for each m pair will after several steps become m-perfect. To count precise number of those steps one needs to launch emulation. If x > 0 and y > 0, then pair \"grows exponentionaly>> (more formally: easy to show that starting from secnd step sum x + y grows in at least 3 / 2 times each step) and emulation works pretty fast. However in the case x < 0 and y > 0 (or vice versa) pair might change very slowly. Most bright example is x =  - 1018, y = 1. Thus one needs to count number of steps until both numbers becomes positive before launching emulationt. For x < 0 and y > 0 number of those steps is exactly . 317B - Ants318D - AntsOne may reformulate the problem ass follows. Non-negative integers A(x, y) are placed in the vertices of two-dimensional lattice We may imagine this construction as a function . On each step for each vertex P = (x, y) with A(x, y) ≥ 4 we perform operation φP, which substracts 4 from A(x, y) and adds 1 to A(x, y - 1), A(x, y + 1), A(x - 1, y), A(x + 1, y). We may think that operation φP applies to the whole function A. We need to find values of A after the iterations stops.Key idea is that operactions φP and φQ for all points P and Q commutes, that is φP(φQ(A)) = φQ(φP(A)). This means that the order of operations is unimportant. In particular, we may assume that from each given vertex run all possible four-groups of ants and not only one. After this observation one may run full emulation of the process. As an exercise contestants may check that ants will never leave square 200 × 200 with center in the origin 0 with given constraints.317C - Balance318E - BalanceIn this problem we need to find 2n2 transfusions from initial configuration to the desired one. First of all we propose the following: if in each connected component overall volume of the water in initial configuration is the same as in desired one, then answer exist. We call the vessel ready, if current volume of its water equals desired one. Let us describe solution which is probably easier to code. We will make vessels ready one by one. Consider the pair of non-ready vessels s and t (there is more water in s than desired, and less water in t than desired), such that they are connected by the path P, and if one transfuses d litres from s to t then one of the vessels becomes ready. Now we need to find a way to transfuse d litres by path P from s to t. One may write recursive function pour(s, t, d) for this aim. Let t' stand before t in this path, then function works as follows: transfuses from t' to t as many water as possible (not more than d of course), then calls pour(s, t', d) and on the final step transfuses from t' to t all that left. It is easy to check that all such transfusions are correct. This algorithm makes 2len transfusions on the path of length len, so total number of transfusions is not greater than 2n2.317D - Game with PowersFor each numner x denote sequence of its powers within [1..n] as Pow(x): Game proceeds as follows: on each step one player takes still available number x from 1 to n and prohibits whole set Pow(x). Who can't make his turn loses.This game may be decomposed in the sum of lesser games. Indeed, lets call number x simple (and corresponding sequence Pow(x) simple), if it is not a power of any number y < x. Then: 1. for each there is simple x, such that ; 2. for each simple distinct x and y sets Pow(x) and P(y) do not intersect. Indeed, for a given k there is exactly one simple x such that k is power of x. This may be showed from fundamental theorem of arithmetic: if and d = gcd(α1, α2, ..., αn), then .Hence set [1..n] decomposes into primitive sets Pow(x), on each of those Pow(x) game proceeds independetly. Now one may use Sprague–Grundy theory to see that mexx of our game is just xor of all mexx of games on simple Pow(x). For fixed x, if Pow(x) = {x, x2, ..., xs}, then mexx of the game on Pow(x) depends only on s, but not on x. In our case s runs from 1 to 29, mexx for all such s may be directly precalculated. Now it is enough to find numbers q(s) of simple x with a given size of Pow(x) equal to s (actually we are interested in parity of q(s) not in q(s) itself).Our constraints allows to do it directly: run x from 2 to , if it is not crossed out, determine the size Pow(x) [increment corresponding q(s)], and cross out all numbers from Pow(x). This cycle finds all simple sequences of length at least 2. Quantity of non-crossed numbers is the number of all simple sequences of length 1. Now it is enough to look at parities of q(s) and xor coressponding mexx.However one may find all q(s) for . Indeed lets look at the number and sequence {x, x2, x3, x4, ..., xs}. This sequence is not simple iff it is containd in some larger simple sequence. But number of subsequenes of size s in a given sequence of size t > s is easy to find: it is just [t / s]. Recalling that simple sequences do not intersect one gets the reccurent formula:. Now it is easy to find all q(s) from q(29) to q(1).Remark: while coding it is important to remeber simple number x = 1.317E - Princess and Her ShadowIn this problem princess Vlada should simply catch the Shadow. Here is the idea of a solution. If there is only one tree, then using it as a barrier to the shadow it is not hard to catch the shadow. Similar technique works if Vlada and Shadow are far from the square where all the trees grow. But what can she do in the dark depths of the forest? If there is no path at all between Vlada and Shadow, then there is no way to catch it. Otherwise consider a shortest path from Vlada to the Shadow and make Vlada follow it. This path gives Vlada a queue of the steps that she should perform. Additionaly if shadow moves, then we add her move to the queue (simply speaking Vlada follows the shadow). This is where the algorithmic part ends. Now we state that either Vlada catches the shadow in the desired number of steps, or steps out of the \"forest square\". To proof this we note that the length of the path between Vlada and Shadow may only decrease. And if it does not decrease long enough, then once in k steps (k is the length of the path) Vlada and Shadow shifts at the same vector over and over, and at some moment leaves the \"forest square\". Note that if the trees allow our heroes to step out of the \"forest square\" at the beginning, then we may just get them out from the start. But taking this approach we still need to catch the Shadow in a \"labyrinth forest\".Apologies for the delay. There are probably misprints and mistakes here (thousands of them!), please feel free to point them out.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/7956",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 317\\s*C"
          },
          "content_length": 8753
        },
        {
          "title": "Codeforces Round #188 (analysis) - Codeforces",
          "content": "Problem analysis v 0.9.318A - Even OddsIn this problem we need to understand how exactly numbers from 1 to n rearrange when we write firstly all odd numbers and after them all even numbers. To find out which number stands at position k one needs to find the position where even numbers start and output either the position of the odd number from the first half of the sequence or for the even number from the second half of the sequence.318B - Strings of PowerIn the heavy metal problem one needs to find the number of the substrings in the string S with a given prefix A and given suffix B. If we mark black all the starting positions of the entries of the string A in S, and white all the starting positions of the entries of the string B, then we come to the following problem: count the number of pairs <black position, white position> (in this order). To solve this it is enough to iterate from left to right counting the number of the passed black positions. Meeting black position we increment this number by one, meeting white position we add to the answer the number of pairs with this white position, which is exactly our memorized number of the already passed black positions.317A - Perfect Pair318C - Perfect PairThis problem were more about accuracy then about ideas or coding. It is important to not forget any cases here.On each step we replace one of the numbers x, y by their sum x + y until the pair becomes m-perfect (id est one of them becomes not lesser than m). It is clear that one sould replace lesser number from the pair x, y. Indeed lets say the pair x1 ≤ y1 dominates the pair x2 ≤ y2, if y1 ≥ y2 and x1 ≥ y2. In this case if one can get m-perfect pair from x2, y2 by certain sequence of actions, then one can get m-perfect pair from x1, y1 by the same or shorter sequence of actions. If x ≤ y, then the pair x + y, y dominates the pair x + y, x. Hence path from x + y, y to m-perfect is not longer than from x + y, x, and we may assume that we choose exactly this pair.Consider following cases: x ≤ 0, y ≤ 0 In this case our numbers do not increase in the process. Hence either the pair is alredy m-perfect or it will never be. x > 0 and y > 0 In this case for each m pair will after several steps become m-perfect. To count precise number of those steps one needs to launch emulation. If x > 0 and y > 0, then pair \"grows exponentionaly>> (more formally: easy to show that starting from secnd step sum x + y grows in at least 3 / 2 times each step) and emulation works pretty fast. However in the case x < 0 and y > 0 (or vice versa) pair might change very slowly. Most bright example is x =  - 1018, y = 1. Thus one needs to count number of steps until both numbers becomes positive before launching emulationt. For x < 0 and y > 0 number of those steps is exactly . 317B - Ants318D - AntsOne may reformulate the problem ass follows. Non-negative integers A(x, y) are placed in the vertices of two-dimensional lattice We may imagine this construction as a function . On each step for each vertex P = (x, y) with A(x, y) ≥ 4 we perform operation φP, which substracts 4 from A(x, y) and adds 1 to A(x, y - 1), A(x, y + 1), A(x - 1, y), A(x + 1, y). We may think that operation φP applies to the whole function A. We need to find values of A after the iterations stops.Key idea is that operactions φP and φQ for all points P and Q commutes, that is φP(φQ(A)) = φQ(φP(A)). This means that the order of operations is unimportant. In particular, we may assume that from each given vertex run all possible four-groups of ants and not only one. After this observation one may run full emulation of the process. As an exercise contestants may check that ants will never leave square 200 × 200 with center in the origin 0 with given constraints.317C - Balance318E - BalanceIn this problem we need to find 2n2 transfusions from initial configuration to the desired one. First of all we propose the following: if in each connected component overall volume of the water in initial configuration is the same as in desired one, then answer exist. We call the vessel ready, if current volume of its water equals desired one. Let us describe solution which is probably easier to code. We will make vessels ready one by one. Consider the pair of non-ready vessels s and t (there is more water in s than desired, and less water in t than desired), such that they are connected by the path P, and if one transfuses d litres from s to t then one of the vessels becomes ready. Now we need to find a way to transfuse d litres by path P from s to t. One may write recursive function pour(s, t, d) for this aim. Let t' stand before t in this path, then function works as follows: transfuses from t' to t as many water as possible (not more than d of course), then calls pour(s, t', d) and on the final step transfuses from t' to t all that left. It is easy to check that all such transfusions are correct. This algorithm makes 2len transfusions on the path of length len, so total number of transfusions is not greater than 2n2.317D - Game with PowersFor each numner x denote sequence of its powers within [1..n] as Pow(x): Game proceeds as follows: on each step one player takes still available number x from 1 to n and prohibits whole set Pow(x). Who can't make his turn loses.This game may be decomposed in the sum of lesser games. Indeed, lets call number x simple (and corresponding sequence Pow(x) simple), if it is not a power of any number y < x. Then: 1. for each there is simple x, such that ; 2. for each simple distinct x and y sets Pow(x) and P(y) do not intersect. Indeed, for a given k there is exactly one simple x such that k is power of x. This may be showed from fundamental theorem of arithmetic: if and d = gcd(α1, α2, ..., αn), then .Hence set [1..n] decomposes into primitive sets Pow(x), on each of those Pow(x) game proceeds independetly. Now one may use Sprague–Grundy theory to see that mexx of our game is just xor of all mexx of games on simple Pow(x). For fixed x, if Pow(x) = {x, x2, ..., xs}, then mexx of the game on Pow(x) depends only on s, but not on x. In our case s runs from 1 to 29, mexx for all such s may be directly precalculated. Now it is enough to find numbers q(s) of simple x with a given size of Pow(x) equal to s (actually we are interested in parity of q(s) not in q(s) itself).Our constraints allows to do it directly: run x from 2 to , if it is not crossed out, determine the size Pow(x) [increment corresponding q(s)], and cross out all numbers from Pow(x). This cycle finds all simple sequences of length at least 2. Quantity of non-crossed numbers is the number of all simple sequences of length 1. Now it is enough to look at parities of q(s) and xor coressponding mexx.However one may find all q(s) for . Indeed lets look at the number and sequence {x, x2, x3, x4, ..., xs}. This sequence is not simple iff it is containd in some larger simple sequence. But number of subsequenes of size s in a given sequence of size t > s is easy to find: it is just [t / s]. Recalling that simple sequences do not intersect one gets the reccurent formula:. Now it is easy to find all q(s) from q(29) to q(1).Remark: while coding it is important to remeber simple number x = 1.317E - Princess and Her ShadowIn this problem princess Vlada should simply catch the Shadow. Here is the idea of a solution. If there is only one tree, then using it as a barrier to the shadow it is not hard to catch the shadow. Similar technique works if Vlada and Shadow are far from the square where all the trees grow. But what can she do in the dark depths of the forest? If there is no path at all between Vlada and Shadow, then there is no way to catch it. Otherwise consider a shortest path from Vlada to the Shadow and make Vlada follow it. This path gives Vlada a queue of the steps that she should perform. Additionaly if shadow moves, then we add her move to the queue (simply speaking Vlada follows the shadow). This is where the algorithmic part ends. Now we state that either Vlada catches the shadow in the desired number of steps, or steps out of the \"forest square\". To proof this we note that the length of the path between Vlada and Shadow may only decrease. And if it does not decrease long enough, then once in k steps (k is the length of the path) Vlada and Shadow shifts at the same vector over and over, and at some moment leaves the \"forest square\". Note that if the trees allow our heroes to step out of the \"forest square\" at the beginning, then we may just get them out from the start. But taking this approach we still need to catch the Shadow in a \"labyrinth forest\".Apologies for the delay. There are probably misprints and mistakes here (thousands of them!), please feel free to point them out.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/7956",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 317\\s*C"
          },
          "content_length": 8753
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #188 - Codeforces - Code 1",
          "code": "-1000000000000000000 1 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7862",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #188 - Codeforces - Code 2",
          "code": "...\nlong long x,y,m;\nlong long res;\n...\nint mymx = max(x,y); // int ???\nint mymn = min(x,y); // int ???\n\nx = mymx;\ny = mymn;\n...",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7862",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #188 - Codeforces - Code 3",
          "code": "...\nlong long x,y,m;\nlong long res;\n...\nint mymx = max(x,y); // int ???\nint mymn = min(x,y); // int ???\n\nx = mymx;\ny = mymn;\n...",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7862",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #188 - Codeforces - Code 4",
          "code": "s.size() < 4",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7862",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #188 - Codeforces - Code 5",
          "code": "s.size() - 4",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7862",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #188 - Codeforces - Code 6",
          "code": "#define SZ(x) (int)x.size()",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7862",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #188 - Codeforces - Code 7",
          "code": "Contest rating",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7862",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #188 (analysis) - Codeforces - Code 1",
          "code": "Thank you for the nice contest and editorial. \nIn \"Ants\" problem, Is there any way to expect the simulation will be converge so fast before we writing brute force code? how to make sure n = 30000 is the worst case?",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7956",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #188 (analysis) - Codeforces - Code 2",
          "code": "Thank you for the nice contest and editorial. \nIn \"Ants\" problem, Is there any way to expect the simulation will be converge so fast before we writing brute force code? how to make sure n = 30000 is the worst case?",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7956",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #188 (analysis) - Codeforces - Code 3",
          "code": "#include <string.h>\n#include <cstdio>\n#include <map>\nusing namespace std;\nmap<long long ,int>SG;\nint DFS(long long state) {\n    //printf(\"%I64d\\n\",state);getchar();getchar();\n    if(state==0) return 0;\n    if(SG[state]) return SG[state];\n    int len=0;long long tmp=state;\n    while(tmp>0) {\n        len++;\n        tmp>>=1;\n    }\n    bool cnt[100];memset(cnt,0,sizeof(cnt));\n    for(int i=1;i<=len;i++) {\n        long long k=(1<<(i-1)),tmp=state;\n        while(k<=tmp) {\n            tmp&=(((1<<(len+1))-1)^k);//printf(\"%lld\\n\",k);\n            k<<=i;\n\t\t}//printf(\"%lld\\n\",tmp);\n\t\tif(tmp==state) continue;\n        int ret=DFS(tmp);\n        cnt[ret]=1;\n    }\n    for(int i=0;;i++)if(!cnt[i]){\n        //printf(\"%d %d\\n\",len,i);\n        return (SG[state]=i);\n    }\n}\nint main()\n{\n    for(int I=1;I<=29;I++) {\n        printf(\"%d\\n\",DFS((long long )((1<<I)-1)));\n    }\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/7956",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #188 (analysis) - Codeforces - Code 4",
          "code": "#include <string.h>\n#include <cstdio>\n#include <map>\nusing namespace std;\nmap<long long ,int>SG;\nint DFS(long long state) {\n    //printf(\"%I64d\\n\",state);getchar();getchar();\n    if(state==0) return 0;\n    if(SG[state]) return SG[state];\n    int len=0;long long tmp=state;\n    while(tmp>0) {\n        len++;\n        tmp>>=1;\n    }\n    bool cnt[100];memset(cnt,0,sizeof(cnt));\n    for(int i=1;i<=len;i++) {\n        long long k=(1<<(i-1)),tmp=state;\n        while(k<=tmp) {\n            tmp&=(((1<<(len+1))-1)^k);//printf(\"%lld\\n\",k);\n            k<<=i;\n\t\t}//printf(\"%lld\\n\",tmp);\n\t\tif(tmp==state) continue;\n        int ret=DFS(tmp);\n        cnt[ret]=1;\n    }\n    for(int i=0;;i++)if(!cnt[i]){\n        //printf(\"%d %d\\n\",len,i);\n        return (SG[state]=i);\n    }\n}\nint main()\n{\n    for(int I=1;I<=29;I++) {\n        printf(\"%d\\n\",DFS((long long )((1<<I)-1)));\n    }\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/7956",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #188 (analysis) - Codeforces - Code 1",
          "code": "Thank you for the nice contest and editorial. \nIn \"Ants\" problem, Is there any way to expect the simulation will be converge so fast before we writing brute force code? how to make sure n = 30000 is the worst case?",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7956",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #188 (analysis) - Codeforces - Code 2",
          "code": "Thank you for the nice contest and editorial. \nIn \"Ants\" problem, Is there any way to expect the simulation will be converge so fast before we writing brute force code? how to make sure n = 30000 is the worst case?",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7956",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #188 (analysis) - Codeforces - Code 3",
          "code": "#include <string.h>\n#include <cstdio>\n#include <map>\nusing namespace std;\nmap<long long ,int>SG;\nint DFS(long long state) {\n    //printf(\"%I64d\\n\",state);getchar();getchar();\n    if(state==0) return 0;\n    if(SG[state]) return SG[state];\n    int len=0;long long tmp=state;\n    while(tmp>0) {\n        len++;\n        tmp>>=1;\n    }\n    bool cnt[100];memset(cnt,0,sizeof(cnt));\n    for(int i=1;i<=len;i++) {\n        long long k=(1<<(i-1)),tmp=state;\n        while(k<=tmp) {\n            tmp&=(((1<<(len+1))-1)^k);//printf(\"%lld\\n\",k);\n            k<<=i;\n\t\t}//printf(\"%lld\\n\",tmp);\n\t\tif(tmp==state) continue;\n        int ret=DFS(tmp);\n        cnt[ret]=1;\n    }\n    for(int i=0;;i++)if(!cnt[i]){\n        //printf(\"%d %d\\n\",len,i);\n        return (SG[state]=i);\n    }\n}\nint main()\n{\n    for(int I=1;I<=29;I++) {\n        printf(\"%d\\n\",DFS((long long )((1<<I)-1)));\n    }\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/7956",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #188 (analysis) - Codeforces - Code 4",
          "code": "#include <string.h>\n#include <cstdio>\n#include <map>\nusing namespace std;\nmap<long long ,int>SG;\nint DFS(long long state) {\n    //printf(\"%I64d\\n\",state);getchar();getchar();\n    if(state==0) return 0;\n    if(SG[state]) return SG[state];\n    int len=0;long long tmp=state;\n    while(tmp>0) {\n        len++;\n        tmp>>=1;\n    }\n    bool cnt[100];memset(cnt,0,sizeof(cnt));\n    for(int i=1;i<=len;i++) {\n        long long k=(1<<(i-1)),tmp=state;\n        while(k<=tmp) {\n            tmp&=(((1<<(len+1))-1)^k);//printf(\"%lld\\n\",k);\n            k<<=i;\n\t\t}//printf(\"%lld\\n\",tmp);\n\t\tif(tmp==state) continue;\n        int ret=DFS(tmp);\n        cnt[ret]=1;\n    }\n    for(int i=0;;i++)if(!cnt[i]){\n        //printf(\"%d %d\\n\",len,i);\n        return (SG[state]=i);\n    }\n}\nint main()\n{\n    for(int I=1;I<=29;I++) {\n        printf(\"%d\\n\",DFS((long long )((1<<I)-1)));\n    }\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/7956",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 300, \"n\");\n    inf.readSpace();\n    long long v = inf.readLong(1LL, 1000000000LL, \"v\");\n    inf.readSpace();\n    int e = inf.readInt(0, 50000, \"e\");\n    inf.readEoln();\n\n    vector<long long> a = inf.readLongs(n, 0LL, v, \"ai\");\n    inf.readEoln();\n\n    vector<long long> b = inf.readLongs(n, 0LL, v, \"bi\");\n    inf.readEoln();\n\n    for (int i = 0; i < e; ++i) {\n        int x = inf.readInt(1, n, \"x_i\");\n        inf.readSpace();\n        int y = inf.readInt(1, n, \"y_i\");\n        inf.readEoln();\n        ensuref(x != y, \"Edge %d: x_i (%d) and y_i (%d) must be different\", i+1, x, y);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 300, \"n\");\n    inf.readSpace();\n    long long v = inf.readLong(1LL, 1000000000LL, \"v\");\n    inf.readSpace();\n    int e = inf.readInt(0, 50000, \"e\");\n    inf.readEoln();\n\n    vector<long long> a = inf.readLongs(n, 0LL, v, \"ai\");\n    inf.readEoln();\n\n    vector<long long> b = inf.readLongs(n, 0LL, v, \"bi\");\n    inf.readEoln();\n\n    for (int i = 0; i < e; ++i) {\n        int x = inf.readInt(1, n, \"x_i\");\n        inf.readSpace();\n        int y = inf.readInt(1, n, \"y_i\");\n        inf.readEoln();\n        ensuref(x != y, \"Edge %d: x_i (%d) and y_i (%d) must be different\", i+1, x, y);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 300, \"n\");\n    inf.readSpace();\n    long long v = inf.readLong(1LL, 1000000000LL, \"v\");\n    inf.readSpace();\n    int e = inf.readInt(0, 50000, \"e\");\n    inf.readEoln();\n\n    vector<long long> a = inf.readLongs(n, 0LL, v, \"ai\");\n    inf.readEoln();\n\n    vector<long long> b = inf.readLongs(n, 0LL, v, \"bi\");\n    inf.readEoln();\n\n    for (int i = 0; i < e; ++i) {\n        int x = inf.readInt(1, n, \"x_i\");\n        inf.readSpace();\n        int y = inf.readInt(1, n, \"y_i\");\n        inf.readEoln();\n        ensuref(x != y, \"Edge %d: x_i (%d) and y_i (%d) must be different\", i+1, x, y);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAX_E = 50000;\nconst int MAX_N = 300;\nconst int MAX_V = 1e9;\n\nint n, v, e;\nvector<int> ai, bi;\nvector<vector<int>> adj; // Adjacency list\nvector<int> component; // Component id for each node\nvector<vector<int>> components; // Nodes in each component\n\nvoid dfs(int u, int comp_id, vector<bool>& visited) {\n    visited[u] = true;\n    component[u] = comp_id;\n    components[comp_id].push_back(u);\n    for (int v : adj[u]) {\n        if (!visited[v]) {\n            dfs(v, comp_id, visited);\n        }\n    }\n}\n\nint main(int argc, char* argv[]) {\n    registerTestlibCmd(argc, argv);\n\n    // Read input data\n    n = inf.readInt(1, MAX_N, \"n\");\n    v = inf.readInt(1, MAX_V, \"v\");\n    e = inf.readInt(0, MAX_E, \"e\");\n\n    ai.resize(n);\n    bi.resize(n);\n\n    for (int i = 0; i < n; ++i) {\n        ai[i] = inf.readInt(0, v, format(\"ai[%d]\", i + 1));\n    }\n    for (int i = 0; i < n; ++i) {\n        bi[i] = inf.readInt(0, v, format(\"bi[%d]\", i + 1));\n    }\n\n    adj.resize(n);\n\n    set<pair<int, int>> tubes;\n\n    for (int i = 0; i < e; ++i) {\n        int x = inf.readInt(1, n, format(\"tube[%d].x\", i + 1)) - 1;\n        int y = inf.readInt(1, n, format(\"tube[%d].y\", i + 1)) - 1;\n        if (x == y) {\n            inf.quitf(_fail, \"Input contains tube between same vessel (%d)\", x + 1);\n        }\n        adj[x].push_back(y);\n        adj[y].push_back(x);\n        tubes.insert({min(x, y), max(x, y)});\n    }\n\n    // Compute connected components\n    vector<bool> visited(n, false);\n    component.resize(n, -1);\n    components.clear();\n    int comp_id = 0;\n\n    for (int i = 0; i < n; ++i) {\n        if (!visited[i]) {\n            components.push_back(vector<int>());\n            dfs(i, comp_id++, visited);\n        }\n    }\n\n    bool solution_exists = true;\n    // For each component, check if sum of ai equals sum of bi\n    for (int cid = 0; cid < comp_id; ++cid) {\n        long long sum_ai = 0, sum_bi = 0;\n        for (int u : components[cid]) {\n            sum_ai += ai[u];\n            sum_bi += bi[u];\n        }\n        if (sum_ai != sum_bi) {\n            solution_exists = false;\n            break;\n        }\n    }\n\n    // Read participant's output\n    string firstToken = ouf.readToken();\n\n    if (firstToken == \"NO\") {\n        // Participant outputs 'NO'\n        if (solution_exists) {\n            quitf(_wa, \"Solution exists, but participant outputs 'NO'\");\n        } else {\n            quitf(_ok, \"Correct: no solution exists and participant outputs 'NO'\");\n        }\n    } else {\n        // Participant outputs a solution\n        int k = 0;\n        try {\n            k = stoi(firstToken);\n        } catch (...) {\n            quitf(_wa, \"First token is neither 'NO' nor an integer\");\n        }\n\n        if (k < 0 || k > 2 * n * n) {\n            quitf(_wa, \"Invalid number of transfusions k = %d\", k);\n        }\n\n        vector<int> amount = ai;\n        for (int i = 0; i < k; ++i) {\n            int x = ouf.readInt(1, n, format(\"transfusion[%d].x\", i + 1)) - 1;\n            int y = ouf.readInt(1, n, format(\"transfusion[%d].y\", i + 1)) - 1;\n            int d = ouf.readInt(0, v, format(\"transfusion[%d].d\", i + 1));\n\n            if (x == y) {\n                quitf(_wa, \"Transfusion %d: x and y are the same (%d)\", i + 1, x + 1);\n            }\n\n            // Check if there is at least one tube between x and y\n            if (tubes.find({min(x, y), max(x, y)}) == tubes.end()) {\n                quitf(_wa, \"Transfusion %d: no tube between vessels %d and %d\", i + 1, x + 1, y + 1);\n            }\n\n            if (amount[x] < d) {\n                quitf(_wa, \"Transfusion %d: insufficient water in vessel %d\", i + 1, x + 1);\n            }\n            amount[x] -= d;\n            amount[y] += d;\n            if (amount[y] > v) {\n                quitf(_wa, \"Transfusion %d: vessel %d exceeds capacity\", i + 1, y + 1);\n            }\n        }\n\n        // Check if final amounts match desired amounts\n        for (int i = 0; i < n; ++i) {\n            if (amount[i] != bi[i]) {\n                quitf(_wa, \"Final amount in vessel %d is %d, expected %d\", i + 1, amount[i], bi[i]);\n            }\n        }\n\n        quitf(_ok, \"Correct solution with %d transfusions\", k);\n    }\n\n    // Should not reach here\n    quitf(_fail, \"Checker did not produce a verdict\");\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int v = opt<int>(\"v\", 1000000000);\n    int e = opt<int>(\"e\", min(50000, n*(n-1)/2));\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> ai(n, 0); // initial amounts\n    vector<int> bi(n, 0); // desired amounts\n    vector<pair<int, int> > edges; // list of tubes\n\n    if (type == \"random\") {\n        // Generate connected random graph\n        // Ensure connectivity\n        \n        // Build a random spanning tree first\n        vector<int> parent(n);\n        parent[0] = -1; // root\n        for (int i = 1; i < n; i++) {\n            parent[i] = rnd.next(0, i - 1);\n            edges.emplace_back(i, parent[i]);\n        }\n\n        // Add extra edges randomly\n        int max_edges = n * (n - 1) / 2;\n        e = min(e, max_edges);\n        int extra_edges = e - (n - 1);\n        set<pair<int,int>> edge_set(edges.begin(), edges.end());\n        while (extra_edges > 0) {\n            int u = rnd.next(0, n - 1);\n            int v_ = rnd.next(0, n - 1);\n            if (u == v_) continue;\n            pair<int,int> p1 = make_pair(u, v_);\n            pair<int,int> p2 = make_pair(v_, u);\n            if (edge_set.count(p1) || edge_set.count(p2)) continue;\n            edges.emplace_back(u, v_);\n            edge_set.insert(p1);\n            edge_set.insert(p2);\n            extra_edges--;\n        }\n\n        // Randomly decide multiple tubes between two vessels\n        int max_extra_tubes = min(50000 - (int)edges.size(), 100);\n        int extra_tubes = rnd.next(0, max_extra_tubes);\n        while (extra_tubes-- > 0) {\n            int u = rnd.next(0, n -1);\n            int v_ = rnd.next(0, n -1);\n            if (u == v_) continue;\n            edges.emplace_back(u, v_);\n        }\n\n        // Shuffle edges\n        shuffle(edges.begin(), edges.end());\n\n        // Initial and desired amounts\n        long long total_volume = (long long)v * n;\n        // Generate ai and bi so that sum(ai)=sum(bi)\n        long long total_water = rnd.next(0LL, total_volume);\n\n        // Distribute total_water among n vessels\n        long long remaining_water = total_water;\n        for (int i = 0; i < n; i++) {\n            long long max_amount = min((long long)v, remaining_water);\n            ai[i] = rnd.next(0LL, max_amount);\n            remaining_water -= ai[i];\n        }\n        // Remaining water goes into the last vessel\n        ai[n-1] += remaining_water;\n\n        // Generate bi such that sum(bi)=sum(ai)\n        remaining_water = total_water;\n        for (int i = 0; i < n; i++) {\n            long long max_amount = min((long long)v, remaining_water);\n            bi[i] = rnd.next(0LL, max_amount);\n            remaining_water -= bi[i];\n        }\n        bi[n-1] += remaining_water;\n\n    } else if (type == \"impossible_total\") {\n        // sum(ai) != sum(bi)\n        // Generate ai and bi such that sum(ai) != sum(bi)\n        // Build a connected graph\n\n        // Build a spanning tree\n        vector<int> parent(n);\n        parent[0] = -1; // root\n        for (int i = 1; i < n; i++) {\n            parent[i] = rnd.next(0, i -1);\n            edges.emplace_back(i, parent[i]);\n        }\n\n        // Randomly decide ai and bi\n        for (int i = 0; i < n; i++) {\n            ai[i] = rnd.next(0, v);\n            bi[i] = rnd.next(0, v);\n        }\n\n        // Modify bi[0] to make sum(ai) != sum(bi)\n        long long sum_ai = accumulate(ai.begin(), ai.end(), 0LL);\n        long long sum_bi = accumulate(bi.begin(), bi.end(), 0LL);\n        if (sum_ai == sum_bi) {\n            // make them different\n            if (bi[0] < v) {\n                bi[0]++;\n            } else if (bi[0] > 0) {\n                bi[0]--;\n            } else if (n > 1 && bi[1] < v) {\n                bi[1]++;\n            } else {\n                // All bi at max or zero, adjust ai\n                if (ai[0] < v) ai[0]++;\n                else if (ai[0] > 0) ai[0]--;\n            }\n        }\n\n    } else if (type == \"impossible_isolated\") {\n        // Create an isolated vessel with ai != bi\n        // For simplicity, set e to n - 2 (disconnect one node)\n        if (n <= 1) {\n            // Can't create an isolated node\n            // Just output NO solution\n            printf(\"%d %d %d\\n\", n, v, 0);\n            printf(\"0\\n\");\n            printf(\"1\\n\");\n            return 0;\n        }\n        e = n - 2;\n        // Build a connected graph among nodes 0 to n - 2\n        // Node n -1 is isolated\n\n        // Build a chain\n        for (int i = 0; i < n - 2; i++) {\n            edges.emplace_back(i, i + 1);\n        }\n\n        // ai and bi\n        for (int i = 0; i < n -1; i++) {\n            ai[i] = rnd.next(0, v);\n            bi[i] = ai[i];\n        }\n\n        // For the isolated node\n        ai[n -1 ] = rnd.next(0, v);\n        bi[n -1 ] = (ai[n -1 ] + 1) % (v + 1); // Ensure ai != bi\n\n    } else if (type == \"max_edges\") {\n        // Generate e = 50000 edges\n\n        // Build a connected graph first\n        vector<int> parent(n);\n        parent[0] = -1; // root\n        for (int i = 1; i < n; i++) {\n            parent[i] = rnd.next(0, i -1);\n            edges.emplace_back(i, parent[i]);\n        }\n\n        // Now add extra edges\n        int current_edges = edges.size();\n        int required_edges = 50000;\n        int extra_edges = required_edges - current_edges;\n        int max_edges = n * (n - 1) / 2;\n        if (required_edges > max_edges) {\n            // Can't have more than max_edges\n            required_edges = max_edges;\n            extra_edges = required_edges - current_edges;\n        }\n        set<pair<int,int>> edge_set(edges.begin(), edges.end());\n        while (extra_edges > 0) {\n            int u = rnd.next(0, n -1);\n            int v_ = rnd.next(0, n -1);\n            if (u == v_) continue;\n            pair<int,int> p1 = make_pair(u, v_);\n            pair<int,int> p2 = make_pair(v_, u);\n            if (edge_set.count(p1) || edge_set.count(p2)) continue;\n            edges.emplace_back(u, v_);\n            edge_set.insert(p1);\n            edge_set.insert(p2);\n            extra_edges--;\n        }\n\n        // ai and bi\n        long long total_water = (long long)v * n / 2;\n        long long remaining_water = total_water;\n        for (int i = 0; i < n; i++) {\n            ai[i] = rnd.next(0LL, min((long long)v, remaining_water));\n            remaining_water -= ai[i];\n        }\n        ai[n -1 ] += remaining_water;\n\n        // bi same as ai\n        bi = ai;\n\n    } else if (type == \"disconnected\") {\n        // Build a disconnected graph\n        // For simplicity, n >= 2\n        if (n < 2) n = 2;\n        // Divide nodes into two sets\n        int mid = n / 2;\n        // Connect nodes 0 to mid -1\n        for (int i = 0; i < mid - 1; i++) {\n            edges.emplace_back(i, i + 1);\n        }\n        // Connect nodes mid to n -1\n        for (int i = mid; i < n -1; i++) {\n            edges.emplace_back(i, i +1);\n        }\n        // ai and bi\n        for (int i = 0; i < n; i++) {\n            ai[i] = rnd.next(0, v);\n            bi[i] = ai[i];\n        }\n        // Now make desired amount in one component different\n        bi[0] = (ai[0] + 1) % (v +1); // make ai[0] != bi[0]\n\n    } else if (type == \"multiple_tubes\") {\n        // Create multiple tubes between some nodes\n\n        // Build a connected graph first\n        vector<int> parent(n);\n        parent[0] = -1; // root\n        for (int i = 1; i < n; i++) {\n            parent[i] = rnd.next(0, i -1);\n            edges.emplace_back(i, parent[i]);\n        }\n\n        // Now add multiple tubes between random nodes\n        int extra_tubes = min(50000 - (int)edges.size(), n * n);\n        while (extra_tubes-- > 0) {\n            int u = rnd.next(0, n -1);\n            int v_ = rnd.next(0, n -1);\n            if (u == v_) continue;\n            edges.emplace_back(u, v_);\n        }\n\n        // ai and bi\n        long long total_water = (long long)v * n / 2;\n        long long remaining_water = total_water;\n        for (int i = 0; i < n; i++) {\n            ai[i] = rnd.next(0LL, min((long long)v, remaining_water));\n            remaining_water -= ai[i];\n        }\n        ai[n -1 ] += remaining_water;\n\n        // bi same as ai\n        bi = ai;\n\n    } else if (type == \"max_vessels\") {\n        n = 300;\n        e = min(e, 50000);\n        // Build as in random\n\n        // Build a random connected graph\n        vector<int> parent(n);\n        parent[0] = -1; // root\n        for (int i = 1; i < n; i++) {\n            parent[i] = rnd.next(0, i - 1);\n            edges.emplace_back(i, parent[i]);\n        }\n\n        // Add extra edges randomly up to e\n        int max_edges = n * (n -1) / 2;\n        e = min(e, max_edges);\n        int extra_edges = e - (n -1);\n        set<pair<int,int>> edge_set(edges.begin(), edges.end());\n        while (extra_edges-- >0) {\n            int u = rnd.next(0, n - 1);\n            int v_ = rnd.next(0, n -1);\n            if (u == v_) continue;\n            pair<int,int> p1 = make_pair(u, v_);\n            pair<int,int> p2 = make_pair(v_, u);\n            if (edge_set.count(p1) || edge_set.count(p2)) continue;\n            edges.emplace_back(u, v_);\n            edge_set.insert(p1);\n            edge_set.insert(p2);\n        }\n\n        // ai and bi\n        long long total_water = (long long)v * n / 2;\n        long long remaining_water = total_water;\n        for (int i = 0; i < n; i++) {\n            ai[i] = rnd.next(0LL, min((long long)v, remaining_water));\n            remaining_water -= ai[i];\n        }\n        ai[n -1 ] += remaining_water;\n\n        // bi same as ai\n        bi = ai;\n\n    } else if (type == \"min_vessels\") {\n        n = 1;\n        e = 0;\n        // generate ai[0] and bi[0]\n        ai.resize(1);\n        bi.resize(1);\n        ai[0] = rnd.next(0, v);\n        bi[0] = ai[0]; // make them equal\n\n    } else if (type == \"zero_edges\") {\n        e = 0;\n        // ai and bi\n        for (int i = 0; i < n; i++) {\n            ai[i] = rnd.next(0, v);\n            bi[i] = ai[i];\n        }\n        // Now make ai[0] != bi[0] unless n ==1\n        if (n > 1) {\n            bi[0] = (ai[0] + 1) % (v +1);\n        }\n    } else {\n        // Default case, same as random\n        // ...\n    }\n\n    // Output the test case\n\n    printf(\"%d %d %d\\n\", n, v, (int)edges.size());\n    for (int i = 0; i < n; i++) {\n        printf(\"%d%c\", ai[i], i+1 == n ? '\\n' : ' ');\n    }\n    for (int i = 0; i < n; i++) {\n        printf(\"%d%c\", bi[i], i+1 == n ? '\\n' : ' ');\n    }\n\n    for (auto e : edges) {\n        printf(\"%d %d\\n\", e.first + 1, e.second + 1);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int v = opt<int>(\"v\", 1000000000);\n    int e = opt<int>(\"e\", min(50000, n*(n-1)/2));\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> ai(n, 0); // initial amounts\n    vector<int> bi(n, 0); // desired amounts\n    vector<pair<int, int> > edges; // list of tubes\n\n    if (type == \"random\") {\n        // Generate connected random graph\n        // Ensure connectivity\n        \n        // Build a random spanning tree first\n        vector<int> parent(n);\n        parent[0] = -1; // root\n        for (int i = 1; i < n; i++) {\n            parent[i] = rnd.next(0, i - 1);\n            edges.emplace_back(i, parent[i]);\n        }\n\n        // Add extra edges randomly\n        int max_edges = n * (n - 1) / 2;\n        e = min(e, max_edges);\n        int extra_edges = e - (n - 1);\n        set<pair<int,int>> edge_set(edges.begin(), edges.end());\n        while (extra_edges > 0) {\n            int u = rnd.next(0, n - 1);\n            int v_ = rnd.next(0, n - 1);\n            if (u == v_) continue;\n            pair<int,int> p1 = make_pair(u, v_);\n            pair<int,int> p2 = make_pair(v_, u);\n            if (edge_set.count(p1) || edge_set.count(p2)) continue;\n            edges.emplace_back(u, v_);\n            edge_set.insert(p1);\n            edge_set.insert(p2);\n            extra_edges--;\n        }\n\n        // Randomly decide multiple tubes between two vessels\n        int max_extra_tubes = min(50000 - (int)edges.size(), 100);\n        int extra_tubes = rnd.next(0, max_extra_tubes);\n        while (extra_tubes-- > 0) {\n            int u = rnd.next(0, n -1);\n            int v_ = rnd.next(0, n -1);\n            if (u == v_) continue;\n            edges.emplace_back(u, v_);\n        }\n\n        // Shuffle edges\n        shuffle(edges.begin(), edges.end());\n\n        // Initial and desired amounts\n        long long total_volume = (long long)v * n;\n        // Generate ai and bi so that sum(ai)=sum(bi)\n        long long total_water = rnd.next(0LL, total_volume);\n\n        // Distribute total_water among n vessels\n        long long remaining_water = total_water;\n        for (int i = 0; i < n; i++) {\n            long long max_amount = min((long long)v, remaining_water);\n            ai[i] = rnd.next(0LL, max_amount);\n            remaining_water -= ai[i];\n        }\n        // Remaining water goes into the last vessel\n        ai[n-1] += remaining_water;\n\n        // Generate bi such that sum(bi)=sum(ai)\n        remaining_water = total_water;\n        for (int i = 0; i < n; i++) {\n            long long max_amount = min((long long)v, remaining_water);\n            bi[i] = rnd.next(0LL, max_amount);\n            remaining_water -= bi[i];\n        }\n        bi[n-1] += remaining_water;\n\n    } else if (type == \"impossible_total\") {\n        // sum(ai) != sum(bi)\n        // Generate ai and bi such that sum(ai) != sum(bi)\n        // Build a connected graph\n\n        // Build a spanning tree\n        vector<int> parent(n);\n        parent[0] = -1; // root\n        for (int i = 1; i < n; i++) {\n            parent[i] = rnd.next(0, i -1);\n            edges.emplace_back(i, parent[i]);\n        }\n\n        // Randomly decide ai and bi\n        for (int i = 0; i < n; i++) {\n            ai[i] = rnd.next(0, v);\n            bi[i] = rnd.next(0, v);\n        }\n\n        // Modify bi[0] to make sum(ai) != sum(bi)\n        long long sum_ai = accumulate(ai.begin(), ai.end(), 0LL);\n        long long sum_bi = accumulate(bi.begin(), bi.end(), 0LL);\n        if (sum_ai == sum_bi) {\n            // make them different\n            if (bi[0] < v) {\n                bi[0]++;\n            } else if (bi[0] > 0) {\n                bi[0]--;\n            } else if (n > 1 && bi[1] < v) {\n                bi[1]++;\n            } else {\n                // All bi at max or zero, adjust ai\n                if (ai[0] < v) ai[0]++;\n                else if (ai[0] > 0) ai[0]--;\n            }\n        }\n\n    } else if (type == \"impossible_isolated\") {\n        // Create an isolated vessel with ai != bi\n        // For simplicity, set e to n - 2 (disconnect one node)\n        if (n <= 1) {\n            // Can't create an isolated node\n            // Just output NO solution\n            printf(\"%d %d %d\\n\", n, v, 0);\n            printf(\"0\\n\");\n            printf(\"1\\n\");\n            return 0;\n        }\n        e = n - 2;\n        // Build a connected graph among nodes 0 to n - 2\n        // Node n -1 is isolated\n\n        // Build a chain\n        for (int i = 0; i < n - 2; i++) {\n            edges.emplace_back(i, i + 1);\n        }\n\n        // ai and bi\n        for (int i = 0; i < n -1; i++) {\n            ai[i] = rnd.next(0, v);\n            bi[i] = ai[i];\n        }\n\n        // For the isolated node\n        ai[n -1 ] = rnd.next(0, v);\n        bi[n -1 ] = (ai[n -1 ] + 1) % (v + 1); // Ensure ai != bi\n\n    } else if (type == \"max_edges\") {\n        // Generate e = 50000 edges\n\n        // Build a connected graph first\n        vector<int> parent(n);\n        parent[0] = -1; // root\n        for (int i = 1; i < n; i++) {\n            parent[i] = rnd.next(0, i -1);\n            edges.emplace_back(i, parent[i]);\n        }\n\n        // Now add extra edges\n        int current_edges = edges.size();\n        int required_edges = 50000;\n        int extra_edges = required_edges - current_edges;\n        int max_edges = n * (n - 1) / 2;\n        if (required_edges > max_edges) {\n            // Can't have more than max_edges\n            required_edges = max_edges;\n            extra_edges = required_edges - current_edges;\n        }\n        set<pair<int,int>> edge_set(edges.begin(), edges.end());\n        while (extra_edges > 0) {\n            int u = rnd.next(0, n -1);\n            int v_ = rnd.next(0, n -1);\n            if (u == v_) continue;\n            pair<int,int> p1 = make_pair(u, v_);\n            pair<int,int> p2 = make_pair(v_, u);\n            if (edge_set.count(p1) || edge_set.count(p2)) continue;\n            edges.emplace_back(u, v_);\n            edge_set.insert(p1);\n            edge_set.insert(p2);\n            extra_edges--;\n        }\n\n        // ai and bi\n        long long total_water = (long long)v * n / 2;\n        long long remaining_water = total_water;\n        for (int i = 0; i < n; i++) {\n            ai[i] = rnd.next(0LL, min((long long)v, remaining_water));\n            remaining_water -= ai[i];\n        }\n        ai[n -1 ] += remaining_water;\n\n        // bi same as ai\n        bi = ai;\n\n    } else if (type == \"disconnected\") {\n        // Build a disconnected graph\n        // For simplicity, n >= 2\n        if (n < 2) n = 2;\n        // Divide nodes into two sets\n        int mid = n / 2;\n        // Connect nodes 0 to mid -1\n        for (int i = 0; i < mid - 1; i++) {\n            edges.emplace_back(i, i + 1);\n        }\n        // Connect nodes mid to n -1\n        for (int i = mid; i < n -1; i++) {\n            edges.emplace_back(i, i +1);\n        }\n        // ai and bi\n        for (int i = 0; i < n; i++) {\n            ai[i] = rnd.next(0, v);\n            bi[i] = ai[i];\n        }\n        // Now make desired amount in one component different\n        bi[0] = (ai[0] + 1) % (v +1); // make ai[0] != bi[0]\n\n    } else if (type == \"multiple_tubes\") {\n        // Create multiple tubes between some nodes\n\n        // Build a connected graph first\n        vector<int> parent(n);\n        parent[0] = -1; // root\n        for (int i = 1; i < n; i++) {\n            parent[i] = rnd.next(0, i -1);\n            edges.emplace_back(i, parent[i]);\n        }\n\n        // Now add multiple tubes between random nodes\n        int extra_tubes = min(50000 - (int)edges.size(), n * n);\n        while (extra_tubes-- > 0) {\n            int u = rnd.next(0, n -1);\n            int v_ = rnd.next(0, n -1);\n            if (u == v_) continue;\n            edges.emplace_back(u, v_);\n        }\n\n        // ai and bi\n        long long total_water = (long long)v * n / 2;\n        long long remaining_water = total_water;\n        for (int i = 0; i < n; i++) {\n            ai[i] = rnd.next(0LL, min((long long)v, remaining_water));\n            remaining_water -= ai[i];\n        }\n        ai[n -1 ] += remaining_water;\n\n        // bi same as ai\n        bi = ai;\n\n    } else if (type == \"max_vessels\") {\n        n = 300;\n        e = min(e, 50000);\n        // Build as in random\n\n        // Build a random connected graph\n        vector<int> parent(n);\n        parent[0] = -1; // root\n        for (int i = 1; i < n; i++) {\n            parent[i] = rnd.next(0, i - 1);\n            edges.emplace_back(i, parent[i]);\n        }\n\n        // Add extra edges randomly up to e\n        int max_edges = n * (n -1) / 2;\n        e = min(e, max_edges);\n        int extra_edges = e - (n -1);\n        set<pair<int,int>> edge_set(edges.begin(), edges.end());\n        while (extra_edges-- >0) {\n            int u = rnd.next(0, n - 1);\n            int v_ = rnd.next(0, n -1);\n            if (u == v_) continue;\n            pair<int,int> p1 = make_pair(u, v_);\n            pair<int,int> p2 = make_pair(v_, u);\n            if (edge_set.count(p1) || edge_set.count(p2)) continue;\n            edges.emplace_back(u, v_);\n            edge_set.insert(p1);\n            edge_set.insert(p2);\n        }\n\n        // ai and bi\n        long long total_water = (long long)v * n / 2;\n        long long remaining_water = total_water;\n        for (int i = 0; i < n; i++) {\n            ai[i] = rnd.next(0LL, min((long long)v, remaining_water));\n            remaining_water -= ai[i];\n        }\n        ai[n -1 ] += remaining_water;\n\n        // bi same as ai\n        bi = ai;\n\n    } else if (type == \"min_vessels\") {\n        n = 1;\n        e = 0;\n        // generate ai[0] and bi[0]\n        ai.resize(1);\n        bi.resize(1);\n        ai[0] = rnd.next(0, v);\n        bi[0] = ai[0]; // make them equal\n\n    } else if (type == \"zero_edges\") {\n        e = 0;\n        // ai and bi\n        for (int i = 0; i < n; i++) {\n            ai[i] = rnd.next(0, v);\n            bi[i] = ai[i];\n        }\n        // Now make ai[0] != bi[0] unless n ==1\n        if (n > 1) {\n            bi[0] = (ai[0] + 1) % (v +1);\n        }\n    } else {\n        // Default case, same as random\n        // ...\n    }\n\n    // Output the test case\n\n    printf(\"%d %d %d\\n\", n, v, (int)edges.size());\n    for (int i = 0; i < n; i++) {\n        printf(\"%d%c\", ai[i], i+1 == n ? '\\n' : ' ');\n    }\n    for (int i = 0; i < n; i++) {\n        printf(\"%d%c\", bi[i], i+1 == n ? '\\n' : ' ');\n    }\n\n    for (auto e : edges) {\n        printf(\"%d %d\\n\", e.first + 1, e.second + 1);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -e 0 -v 10 -type min_vessels\n./gen -n 2 -e 0 -v 100 -type zero_edges\n./gen -n 2 -e 1 -v 1000 -type multiple_tubes\n./gen -n 5 -e 4 -type random\n./gen -n 5 -e 3 -type impossible_total\n./gen -n 5 -e 2 -type impossible_isolated\n./gen -n 5 -e 3 -type disconnected\n./gen -n 5 -e 7 -type multiple_tubes\n./gen -n 10 -e 15 -v 100 -type random\n./gen -n 10 -e 5 -v 50 -type impossible_total\n./gen -n 10 -e 8 -v 50 -type impossible_isolated\n./gen -n 10 -e 20 -v 50 -type disconnected\n./gen -n 10 -e 50 -v 100 -type multiple_tubes\n./gen -n 50 -e 100 -v 1000000 -type random\n./gen -n 50 -e 120 -v 1000000 -type impossible_total\n./gen -n 50 -e 49 -v 1000000 -type impossible_isolated\n./gen -n 50 -e 80 -v 1000000 -type disconnected\n./gen -n 50 -e 500 -v 1000000 -type multiple_tubes\n./gen -n 100 -e 1000 -v 2000000000 -type random\n./gen -n 100 -e 2000 -v 2000000000 -type multiple_tubes\n./gen -n 100 -e 0 -v 2000000000 -type zero_edges\n./gen -n 300 -e 50000 -v 1000000000 -type max_edges\n./gen -n 300 -e 20000 -v 1000000000 -type max_vessels\n./gen -n 300 -e 500 -v 1000000000 -type impossible_total\n./gen -n 300 -e 1000 -v 1000000000 -type impossible_isolated\n./gen -n 300 -e 1000 -v 1000000000 -type disconnected\n./gen -n 300 -e 10000 -v 1000000000 -type multiple_tubes\n./gen -n 299 -e 10000 -v 1000000000 -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:07:14.818986",
        "total_tutorials": 3,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "317/D",
      "title": "D. Game with Powers",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputInput contains single integer n (1 ≤ n ≤ 109).",
      "output_spec": "OutputPrint the name of the winner — \"Vasya\" or \"Petya\" (without quotes).",
      "sample_tests": "ExamplesInputCopy1OutputCopyVasyaInputCopy2OutputCopyPetyaInputCopy8OutputCopyPetya",
      "description": "D. Game with Powers\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputInput contains single integer n (1 ≤ n ≤ 109).\n\nOutputPrint the name of the winner — \"Vasya\" or \"Petya\" (without quotes).\n\nInputCopy1OutputCopyVasyaInputCopy2OutputCopyPetyaInputCopy8OutputCopyPetya\n\nOutputCopyVasya\n\nOutputCopyPetya\n\nOutputCopyPetya\n\nNoteIn the first sample Vasya will choose 1 and win immediately.In the second sample no matter which number Vasya chooses during his first turn, Petya can choose the remaining number and win.",
      "solutions": [
        {
          "title": "Codeforces Round #188 - Codeforces",
          "content": "Hello, friends! Winter 188th Codeforces Round is coming!We wished to prepare for you some enjoyable problems (as we believe, not very difficult) with nice ideas and clear statements.\"We\" includes authors of the problems yaro and Rei, Codeforces Rounds supervisor Gerald and the platform founder MikeMirzayanov. Special thanks to Pasha (PavelKunyavskiy) and Artem (RAD) for the testing and helpful comments.Last time I was preparing a competition here on Codeforces, Rounds were still \"beta\". Well, with less \"beta\" comes greater responsibility. So I wish the authors and the organizers a successfully held Round. As for the participants, I wish you the unconventional ideas, the clean code (and a clean keyboard, of course), and satisfaction from five (well, possibly the less number will also do...) correct and accepted solutions!It seems to us that it is not an easy job to arrange the problems by their difficulty, so we have chosen the dynamic scores. Still (out of curiousity) let us put a bet on the following relative difficulties for the problems: div.1 — B-B-C-C-E, div.2 — A-B-C-C-E. How close is our guess?UPD Sorry for the problems with the Codeforces testing queue during the round.We will still be happy if you rate our contest (when it will be over): short survey.And with the gap of one hack the winner of div.1 is meret (Jakub Pachocki)!Div.1 standings, Div.2 standings.Analysis (thanks to Rei for the translation).",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/7862",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1433
        },
        {
          "title": "Codeforces Round #188 (analysis) - Codeforces",
          "content": "Problem analysis v 0.9.318A - Even OddsIn this problem we need to understand how exactly numbers from 1 to n rearrange when we write firstly all odd numbers and after them all even numbers. To find out which number stands at position k one needs to find the position where even numbers start and output either the position of the odd number from the first half of the sequence or for the even number from the second half of the sequence.318B - Strings of PowerIn the heavy metal problem one needs to find the number of the substrings in the string S with a given prefix A and given suffix B. If we mark black all the starting positions of the entries of the string A in S, and white all the starting positions of the entries of the string B, then we come to the following problem: count the number of pairs <black position, white position> (in this order). To solve this it is enough to iterate from left to right counting the number of the passed black positions. Meeting black position we increment this number by one, meeting white position we add to the answer the number of pairs with this white position, which is exactly our memorized number of the already passed black positions.317A - Perfect Pair318C - Perfect PairThis problem were more about accuracy then about ideas or coding. It is important to not forget any cases here.On each step we replace one of the numbers x, y by their sum x + y until the pair becomes m-perfect (id est one of them becomes not lesser than m). It is clear that one sould replace lesser number from the pair x, y. Indeed lets say the pair x1 ≤ y1 dominates the pair x2 ≤ y2, if y1 ≥ y2 and x1 ≥ y2. In this case if one can get m-perfect pair from x2, y2 by certain sequence of actions, then one can get m-perfect pair from x1, y1 by the same or shorter sequence of actions. If x ≤ y, then the pair x + y, y dominates the pair x + y, x. Hence path from x + y, y to m-perfect is not longer than from x + y, x, and we may assume that we choose exactly this pair.Consider following cases: x ≤ 0, y ≤ 0 In this case our numbers do not increase in the process. Hence either the pair is alredy m-perfect or it will never be. x > 0 and y > 0 In this case for each m pair will after several steps become m-perfect. To count precise number of those steps one needs to launch emulation. If x > 0 and y > 0, then pair \"grows exponentionaly>> (more formally: easy to show that starting from secnd step sum x + y grows in at least 3 / 2 times each step) and emulation works pretty fast. However in the case x < 0 and y > 0 (or vice versa) pair might change very slowly. Most bright example is x =  - 1018, y = 1. Thus one needs to count number of steps until both numbers becomes positive before launching emulationt. For x < 0 and y > 0 number of those steps is exactly . 317B - Ants318D - AntsOne may reformulate the problem ass follows. Non-negative integers A(x, y) are placed in the vertices of two-dimensional lattice We may imagine this construction as a function . On each step for each vertex P = (x, y) with A(x, y) ≥ 4 we perform operation φP, which substracts 4 from A(x, y) and adds 1 to A(x, y - 1), A(x, y + 1), A(x - 1, y), A(x + 1, y). We may think that operation φP applies to the whole function A. We need to find values of A after the iterations stops.Key idea is that operactions φP and φQ for all points P and Q commutes, that is φP(φQ(A)) = φQ(φP(A)). This means that the order of operations is unimportant. In particular, we may assume that from each given vertex run all possible four-groups of ants and not only one. After this observation one may run full emulation of the process. As an exercise contestants may check that ants will never leave square 200 × 200 with center in the origin 0 with given constraints.317C - Balance318E - BalanceIn this problem we need to find 2n2 transfusions from initial configuration to the desired one. First of all we propose the following: if in each connected component overall volume of the water in initial configuration is the same as in desired one, then answer exist. We call the vessel ready, if current volume of its water equals desired one. Let us describe solution which is probably easier to code. We will make vessels ready one by one. Consider the pair of non-ready vessels s and t (there is more water in s than desired, and less water in t than desired), such that they are connected by the path P, and if one transfuses d litres from s to t then one of the vessels becomes ready. Now we need to find a way to transfuse d litres by path P from s to t. One may write recursive function pour(s, t, d) for this aim. Let t' stand before t in this path, then function works as follows: transfuses from t' to t as many water as possible (not more than d of course), then calls pour(s, t', d) and on the final step transfuses from t' to t all that left. It is easy to check that all such transfusions are correct. This algorithm makes 2len transfusions on the path of length len, so total number of transfusions is not greater than 2n2.317D - Game with PowersFor each numner x denote sequence of its powers within [1..n] as Pow(x): Game proceeds as follows: on each step one player takes still available number x from 1 to n and prohibits whole set Pow(x). Who can't make his turn loses.This game may be decomposed in the sum of lesser games. Indeed, lets call number x simple (and corresponding sequence Pow(x) simple), if it is not a power of any number y < x. Then: 1. for each there is simple x, such that ; 2. for each simple distinct x and y sets Pow(x) and P(y) do not intersect. Indeed, for a given k there is exactly one simple x such that k is power of x. This may be showed from fundamental theorem of arithmetic: if and d = gcd(α1, α2, ..., αn), then .Hence set [1..n] decomposes into primitive sets Pow(x), on each of those Pow(x) game proceeds independetly. Now one may use Sprague–Grundy theory to see that mexx of our game is just xor of all mexx of games on simple Pow(x). For fixed x, if Pow(x) = {x, x2, ..., xs}, then mexx of the game on Pow(x) depends only on s, but not on x. In our case s runs from 1 to 29, mexx for all such s may be directly precalculated. Now it is enough to find numbers q(s) of simple x with a given size of Pow(x) equal to s (actually we are interested in parity of q(s) not in q(s) itself).Our constraints allows to do it directly: run x from 2 to , if it is not crossed out, determine the size Pow(x) [increment corresponding q(s)], and cross out all numbers from Pow(x). This cycle finds all simple sequences of length at least 2. Quantity of non-crossed numbers is the number of all simple sequences of length 1. Now it is enough to look at parities of q(s) and xor coressponding mexx.However one may find all q(s) for . Indeed lets look at the number and sequence {x, x2, x3, x4, ..., xs}. This sequence is not simple iff it is containd in some larger simple sequence. But number of subsequenes of size s in a given sequence of size t > s is easy to find: it is just [t / s]. Recalling that simple sequences do not intersect one gets the reccurent formula:. Now it is easy to find all q(s) from q(29) to q(1).Remark: while coding it is important to remeber simple number x = 1.317E - Princess and Her ShadowIn this problem princess Vlada should simply catch the Shadow. Here is the idea of a solution. If there is only one tree, then using it as a barrier to the shadow it is not hard to catch the shadow. Similar technique works if Vlada and Shadow are far from the square where all the trees grow. But what can she do in the dark depths of the forest? If there is no path at all between Vlada and Shadow, then there is no way to catch it. Otherwise consider a shortest path from Vlada to the Shadow and make Vlada follow it. This path gives Vlada a queue of the steps that she should perform. Additionaly if shadow moves, then we add her move to the queue (simply speaking Vlada follows the shadow). This is where the algorithmic part ends. Now we state that either Vlada catches the shadow in the desired number of steps, or steps out of the \"forest square\". To proof this we note that the length of the path between Vlada and Shadow may only decrease. And if it does not decrease long enough, then once in k steps (k is the length of the path) Vlada and Shadow shifts at the same vector over and over, and at some moment leaves the \"forest square\". Note that if the trees allow our heroes to step out of the \"forest square\" at the beginning, then we may just get them out from the start. But taking this approach we still need to catch the Shadow in a \"labyrinth forest\".Apologies for the delay. There are probably misprints and mistakes here (thousands of them!), please feel free to point them out.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/7956",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 317\\s*D"
          },
          "content_length": 8753
        },
        {
          "title": "Codeforces Round #188 (analysis) - Codeforces",
          "content": "Problem analysis v 0.9.318A - Even OddsIn this problem we need to understand how exactly numbers from 1 to n rearrange when we write firstly all odd numbers and after them all even numbers. To find out which number stands at position k one needs to find the position where even numbers start and output either the position of the odd number from the first half of the sequence or for the even number from the second half of the sequence.318B - Strings of PowerIn the heavy metal problem one needs to find the number of the substrings in the string S with a given prefix A and given suffix B. If we mark black all the starting positions of the entries of the string A in S, and white all the starting positions of the entries of the string B, then we come to the following problem: count the number of pairs <black position, white position> (in this order). To solve this it is enough to iterate from left to right counting the number of the passed black positions. Meeting black position we increment this number by one, meeting white position we add to the answer the number of pairs with this white position, which is exactly our memorized number of the already passed black positions.317A - Perfect Pair318C - Perfect PairThis problem were more about accuracy then about ideas or coding. It is important to not forget any cases here.On each step we replace one of the numbers x, y by their sum x + y until the pair becomes m-perfect (id est one of them becomes not lesser than m). It is clear that one sould replace lesser number from the pair x, y. Indeed lets say the pair x1 ≤ y1 dominates the pair x2 ≤ y2, if y1 ≥ y2 and x1 ≥ y2. In this case if one can get m-perfect pair from x2, y2 by certain sequence of actions, then one can get m-perfect pair from x1, y1 by the same or shorter sequence of actions. If x ≤ y, then the pair x + y, y dominates the pair x + y, x. Hence path from x + y, y to m-perfect is not longer than from x + y, x, and we may assume that we choose exactly this pair.Consider following cases: x ≤ 0, y ≤ 0 In this case our numbers do not increase in the process. Hence either the pair is alredy m-perfect or it will never be. x > 0 and y > 0 In this case for each m pair will after several steps become m-perfect. To count precise number of those steps one needs to launch emulation. If x > 0 and y > 0, then pair \"grows exponentionaly>> (more formally: easy to show that starting from secnd step sum x + y grows in at least 3 / 2 times each step) and emulation works pretty fast. However in the case x < 0 and y > 0 (or vice versa) pair might change very slowly. Most bright example is x =  - 1018, y = 1. Thus one needs to count number of steps until both numbers becomes positive before launching emulationt. For x < 0 and y > 0 number of those steps is exactly . 317B - Ants318D - AntsOne may reformulate the problem ass follows. Non-negative integers A(x, y) are placed in the vertices of two-dimensional lattice We may imagine this construction as a function . On each step for each vertex P = (x, y) with A(x, y) ≥ 4 we perform operation φP, which substracts 4 from A(x, y) and adds 1 to A(x, y - 1), A(x, y + 1), A(x - 1, y), A(x + 1, y). We may think that operation φP applies to the whole function A. We need to find values of A after the iterations stops.Key idea is that operactions φP and φQ for all points P and Q commutes, that is φP(φQ(A)) = φQ(φP(A)). This means that the order of operations is unimportant. In particular, we may assume that from each given vertex run all possible four-groups of ants and not only one. After this observation one may run full emulation of the process. As an exercise contestants may check that ants will never leave square 200 × 200 with center in the origin 0 with given constraints.317C - Balance318E - BalanceIn this problem we need to find 2n2 transfusions from initial configuration to the desired one. First of all we propose the following: if in each connected component overall volume of the water in initial configuration is the same as in desired one, then answer exist. We call the vessel ready, if current volume of its water equals desired one. Let us describe solution which is probably easier to code. We will make vessels ready one by one. Consider the pair of non-ready vessels s and t (there is more water in s than desired, and less water in t than desired), such that they are connected by the path P, and if one transfuses d litres from s to t then one of the vessels becomes ready. Now we need to find a way to transfuse d litres by path P from s to t. One may write recursive function pour(s, t, d) for this aim. Let t' stand before t in this path, then function works as follows: transfuses from t' to t as many water as possible (not more than d of course), then calls pour(s, t', d) and on the final step transfuses from t' to t all that left. It is easy to check that all such transfusions are correct. This algorithm makes 2len transfusions on the path of length len, so total number of transfusions is not greater than 2n2.317D - Game with PowersFor each numner x denote sequence of its powers within [1..n] as Pow(x): Game proceeds as follows: on each step one player takes still available number x from 1 to n and prohibits whole set Pow(x). Who can't make his turn loses.This game may be decomposed in the sum of lesser games. Indeed, lets call number x simple (and corresponding sequence Pow(x) simple), if it is not a power of any number y < x. Then: 1. for each there is simple x, such that ; 2. for each simple distinct x and y sets Pow(x) and P(y) do not intersect. Indeed, for a given k there is exactly one simple x such that k is power of x. This may be showed from fundamental theorem of arithmetic: if and d = gcd(α1, α2, ..., αn), then .Hence set [1..n] decomposes into primitive sets Pow(x), on each of those Pow(x) game proceeds independetly. Now one may use Sprague–Grundy theory to see that mexx of our game is just xor of all mexx of games on simple Pow(x). For fixed x, if Pow(x) = {x, x2, ..., xs}, then mexx of the game on Pow(x) depends only on s, but not on x. In our case s runs from 1 to 29, mexx for all such s may be directly precalculated. Now it is enough to find numbers q(s) of simple x with a given size of Pow(x) equal to s (actually we are interested in parity of q(s) not in q(s) itself).Our constraints allows to do it directly: run x from 2 to , if it is not crossed out, determine the size Pow(x) [increment corresponding q(s)], and cross out all numbers from Pow(x). This cycle finds all simple sequences of length at least 2. Quantity of non-crossed numbers is the number of all simple sequences of length 1. Now it is enough to look at parities of q(s) and xor coressponding mexx.However one may find all q(s) for . Indeed lets look at the number and sequence {x, x2, x3, x4, ..., xs}. This sequence is not simple iff it is containd in some larger simple sequence. But number of subsequenes of size s in a given sequence of size t > s is easy to find: it is just [t / s]. Recalling that simple sequences do not intersect one gets the reccurent formula:. Now it is easy to find all q(s) from q(29) to q(1).Remark: while coding it is important to remeber simple number x = 1.317E - Princess and Her ShadowIn this problem princess Vlada should simply catch the Shadow. Here is the idea of a solution. If there is only one tree, then using it as a barrier to the shadow it is not hard to catch the shadow. Similar technique works if Vlada and Shadow are far from the square where all the trees grow. But what can she do in the dark depths of the forest? If there is no path at all between Vlada and Shadow, then there is no way to catch it. Otherwise consider a shortest path from Vlada to the Shadow and make Vlada follow it. This path gives Vlada a queue of the steps that she should perform. Additionaly if shadow moves, then we add her move to the queue (simply speaking Vlada follows the shadow). This is where the algorithmic part ends. Now we state that either Vlada catches the shadow in the desired number of steps, or steps out of the \"forest square\". To proof this we note that the length of the path between Vlada and Shadow may only decrease. And if it does not decrease long enough, then once in k steps (k is the length of the path) Vlada and Shadow shifts at the same vector over and over, and at some moment leaves the \"forest square\". Note that if the trees allow our heroes to step out of the \"forest square\" at the beginning, then we may just get them out from the start. But taking this approach we still need to catch the Shadow in a \"labyrinth forest\".Apologies for the delay. There are probably misprints and mistakes here (thousands of them!), please feel free to point them out.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/7956",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 317\\s*D"
          },
          "content_length": 8753
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #188 - Codeforces - Code 1",
          "code": "-1000000000000000000 1 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7862",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #188 - Codeforces - Code 2",
          "code": "...\nlong long x,y,m;\nlong long res;\n...\nint mymx = max(x,y); // int ???\nint mymn = min(x,y); // int ???\n\nx = mymx;\ny = mymn;\n...",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7862",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #188 - Codeforces - Code 3",
          "code": "...\nlong long x,y,m;\nlong long res;\n...\nint mymx = max(x,y); // int ???\nint mymn = min(x,y); // int ???\n\nx = mymx;\ny = mymn;\n...",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7862",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #188 - Codeforces - Code 4",
          "code": "s.size() < 4",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7862",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #188 - Codeforces - Code 5",
          "code": "s.size() - 4",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7862",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #188 - Codeforces - Code 6",
          "code": "#define SZ(x) (int)x.size()",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7862",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #188 - Codeforces - Code 7",
          "code": "Contest rating",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7862",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #188 (analysis) - Codeforces - Code 1",
          "code": "Thank you for the nice contest and editorial. \nIn \"Ants\" problem, Is there any way to expect the simulation will be converge so fast before we writing brute force code? how to make sure n = 30000 is the worst case?",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7956",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #188 (analysis) - Codeforces - Code 2",
          "code": "Thank you for the nice contest and editorial. \nIn \"Ants\" problem, Is there any way to expect the simulation will be converge so fast before we writing brute force code? how to make sure n = 30000 is the worst case?",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7956",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #188 (analysis) - Codeforces - Code 3",
          "code": "#include <string.h>\n#include <cstdio>\n#include <map>\nusing namespace std;\nmap<long long ,int>SG;\nint DFS(long long state) {\n    //printf(\"%I64d\\n\",state);getchar();getchar();\n    if(state==0) return 0;\n    if(SG[state]) return SG[state];\n    int len=0;long long tmp=state;\n    while(tmp>0) {\n        len++;\n        tmp>>=1;\n    }\n    bool cnt[100];memset(cnt,0,sizeof(cnt));\n    for(int i=1;i<=len;i++) {\n        long long k=(1<<(i-1)),tmp=state;\n        while(k<=tmp) {\n            tmp&=(((1<<(len+1))-1)^k);//printf(\"%lld\\n\",k);\n            k<<=i;\n\t\t}//printf(\"%lld\\n\",tmp);\n\t\tif(tmp==state) continue;\n        int ret=DFS(tmp);\n        cnt[ret]=1;\n    }\n    for(int i=0;;i++)if(!cnt[i]){\n        //printf(\"%d %d\\n\",len,i);\n        return (SG[state]=i);\n    }\n}\nint main()\n{\n    for(int I=1;I<=29;I++) {\n        printf(\"%d\\n\",DFS((long long )((1<<I)-1)));\n    }\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/7956",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #188 (analysis) - Codeforces - Code 4",
          "code": "#include <string.h>\n#include <cstdio>\n#include <map>\nusing namespace std;\nmap<long long ,int>SG;\nint DFS(long long state) {\n    //printf(\"%I64d\\n\",state);getchar();getchar();\n    if(state==0) return 0;\n    if(SG[state]) return SG[state];\n    int len=0;long long tmp=state;\n    while(tmp>0) {\n        len++;\n        tmp>>=1;\n    }\n    bool cnt[100];memset(cnt,0,sizeof(cnt));\n    for(int i=1;i<=len;i++) {\n        long long k=(1<<(i-1)),tmp=state;\n        while(k<=tmp) {\n            tmp&=(((1<<(len+1))-1)^k);//printf(\"%lld\\n\",k);\n            k<<=i;\n\t\t}//printf(\"%lld\\n\",tmp);\n\t\tif(tmp==state) continue;\n        int ret=DFS(tmp);\n        cnt[ret]=1;\n    }\n    for(int i=0;;i++)if(!cnt[i]){\n        //printf(\"%d %d\\n\",len,i);\n        return (SG[state]=i);\n    }\n}\nint main()\n{\n    for(int I=1;I<=29;I++) {\n        printf(\"%d\\n\",DFS((long long )((1<<I)-1)));\n    }\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/7956",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #188 (analysis) - Codeforces - Code 1",
          "code": "Thank you for the nice contest and editorial. \nIn \"Ants\" problem, Is there any way to expect the simulation will be converge so fast before we writing brute force code? how to make sure n = 30000 is the worst case?",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7956",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #188 (analysis) - Codeforces - Code 2",
          "code": "Thank you for the nice contest and editorial. \nIn \"Ants\" problem, Is there any way to expect the simulation will be converge so fast before we writing brute force code? how to make sure n = 30000 is the worst case?",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7956",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #188 (analysis) - Codeforces - Code 3",
          "code": "#include <string.h>\n#include <cstdio>\n#include <map>\nusing namespace std;\nmap<long long ,int>SG;\nint DFS(long long state) {\n    //printf(\"%I64d\\n\",state);getchar();getchar();\n    if(state==0) return 0;\n    if(SG[state]) return SG[state];\n    int len=0;long long tmp=state;\n    while(tmp>0) {\n        len++;\n        tmp>>=1;\n    }\n    bool cnt[100];memset(cnt,0,sizeof(cnt));\n    for(int i=1;i<=len;i++) {\n        long long k=(1<<(i-1)),tmp=state;\n        while(k<=tmp) {\n            tmp&=(((1<<(len+1))-1)^k);//printf(\"%lld\\n\",k);\n            k<<=i;\n\t\t}//printf(\"%lld\\n\",tmp);\n\t\tif(tmp==state) continue;\n        int ret=DFS(tmp);\n        cnt[ret]=1;\n    }\n    for(int i=0;;i++)if(!cnt[i]){\n        //printf(\"%d %d\\n\",len,i);\n        return (SG[state]=i);\n    }\n}\nint main()\n{\n    for(int I=1;I<=29;I++) {\n        printf(\"%d\\n\",DFS((long long )((1<<I)-1)));\n    }\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/7956",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #188 (analysis) - Codeforces - Code 4",
          "code": "#include <string.h>\n#include <cstdio>\n#include <map>\nusing namespace std;\nmap<long long ,int>SG;\nint DFS(long long state) {\n    //printf(\"%I64d\\n\",state);getchar();getchar();\n    if(state==0) return 0;\n    if(SG[state]) return SG[state];\n    int len=0;long long tmp=state;\n    while(tmp>0) {\n        len++;\n        tmp>>=1;\n    }\n    bool cnt[100];memset(cnt,0,sizeof(cnt));\n    for(int i=1;i<=len;i++) {\n        long long k=(1<<(i-1)),tmp=state;\n        while(k<=tmp) {\n            tmp&=(((1<<(len+1))-1)^k);//printf(\"%lld\\n\",k);\n            k<<=i;\n\t\t}//printf(\"%lld\\n\",tmp);\n\t\tif(tmp==state) continue;\n        int ret=DFS(tmp);\n        cnt[ret]=1;\n    }\n    for(int i=0;;i++)if(!cnt[i]){\n        //printf(\"%d %d\\n\",len,i);\n        return (SG[state]=i);\n    }\n}\nint main()\n{\n    for(int I=1;I<=29;I++) {\n        printf(\"%d\\n\",DFS((long long )((1<<I)-1)));\n    }\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/7956",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 1000000000, \"n\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 1000000000, \"n\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 1000000000, \"n\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare sequences of tokens\");\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string j, p;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n\r\n        ans.readWordTo(j);\r\n        ouf.readWordTo(p);\r\n\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s words differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  compress(j).c_str(), compress(p).c_str());\r\n    }\r\n\r\n    if (ans.seekEof() && ouf.seekEof()) {\r\n        if (n == 1)\r\n            quitf(_ok, \"\\\"%s\\\"\", compress(j).c_str());\r\n        else\r\n            quitf(_ok, \"%d tokens\", n);\r\n    } else {\r\n        if (ans.seekEof())\r\n            quitf(_wa, \"Participant output contains extra tokens\");\r\n        else\r\n            quitf(_wa, \"Unexpected EOF in the participants output\");\r\n    }\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\", -1);\n    string type = opt<string>(\"type\", \"random\");\n\n    if (n == -1) {\n        if (type == \"small\") {\n            n = rnd.next(1, 10);\n        } else if (type == \"large\") {\n            n = rnd.next((int)1e9 - 10, (int)1e9);\n        } else if (type == \"powers\") {\n            int base = rnd.next(2, 1000);\n            int exp = rnd.next(2, 30);\n            long long val = 1;\n            for (int i = 0; i < exp; ++i) {\n                val *= base;\n                if (val > 1e9) break;\n            }\n            n = min((int)val, (int)1e9);\n        } else if (type == \"max\") {\n            n = (int)1e9;\n        } else if (type == \"random\") {\n            n = rnd.next(1, (int)1e9);\n        } else if (type == \"near_power\") {\n            int base = rnd.next(2, 1000);\n            int exp = rnd.next(2, 30);\n            long long val = 1;\n            for (int i = 0; i < exp; ++i) {\n                val *= base;\n                if (val > 1e9) {\n                    val = 1e9;\n                    break;\n                }\n            }\n            int delta = rnd.next(-10, 10);\n            n = min(max(1, (int)(val + delta)), (int)1e9);\n        } else {\n            // default random\n            n = rnd.next(1, (int)1e9);\n        }\n    } else {\n        n = min(max(n,1), (int)1e9);\n    }\n\n    printf(\"%d\\n\", n);\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\", -1);\n    string type = opt<string>(\"type\", \"random\");\n\n    if (n == -1) {\n        if (type == \"small\") {\n            n = rnd.next(1, 10);\n        } else if (type == \"large\") {\n            n = rnd.next((int)1e9 - 10, (int)1e9);\n        } else if (type == \"powers\") {\n            int base = rnd.next(2, 1000);\n            int exp = rnd.next(2, 30);\n            long long val = 1;\n            for (int i = 0; i < exp; ++i) {\n                val *= base;\n                if (val > 1e9) break;\n            }\n            n = min((int)val, (int)1e9);\n        } else if (type == \"max\") {\n            n = (int)1e9;\n        } else if (type == \"random\") {\n            n = rnd.next(1, (int)1e9);\n        } else if (type == \"near_power\") {\n            int base = rnd.next(2, 1000);\n            int exp = rnd.next(2, 30);\n            long long val = 1;\n            for (int i = 0; i < exp; ++i) {\n                val *= base;\n                if (val > 1e9) {\n                    val = 1e9;\n                    break;\n                }\n            }\n            int delta = rnd.next(-10, 10);\n            n = min(max(1, (int)(val + delta)), (int)1e9);\n        } else {\n            // default random\n            n = rnd.next(1, (int)1e9);\n        }\n    } else {\n        n = min(max(n,1), (int)1e9);\n    }\n\n    printf(\"%d\\n\", n);\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1\n./gen -n 2\n./gen -n 3\n./gen -n 4\n./gen -n 5\n./gen -n 10\n./gen -n 100\n./gen -n 500\n./gen -n 1000\n./gen -n 5000\n./gen -n 10000\n./gen -n 50000\n./gen -n 100000\n./gen -n 500000\n./gen -n 1000000\n./gen -n 5000000\n./gen -n 10000000\n./gen -n 50000000\n./gen -n 100000000\n./gen -n 500000000\n./gen -n 999999937\n./gen -n 999999929\n./gen -n 1000000000\n\n./gen -type small\n./gen -type small\n./gen -type small\n\n./gen -type large\n./gen -type large\n./gen -type large\n\n./gen -type powers\n./gen -type powers\n./gen -type powers\n\n./gen -type random\n./gen -type random\n./gen -type random\n\n./gen -type near_power\n./gen -type near_power\n./gen -type near_power\n\n./gen -n 1024\n./gen -n 59049\n./gen -n 9765625\n./gen -n 6\n./gen -n 28\n./gen -n 496\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:07:16.852932",
        "total_tutorials": 3,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "317/E",
      "title": "E. Princess and Her Shadow",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputFirst line of the input contains the coordinates of the characters vx, vy, sx, sy and the number of trees m (0 ≤ m ≤ 400). The following m lines contain the coordinates of the trees.All the coordinates are integers between -100 and 100, inclusive. The Princess, The Shadow and the trees are located in the different cells.",
      "output_spec": "OutputIf it is impossible for the Princess to catch the Shadow, print \"-1\" (without quotes).Otherwise print a sequence of characters \"L\", \"R\", \"D\", \"U\", corresponding to the Princess's moves, following which she will be able to catch the Shadow at some turn (L — move to the left, R — to the right, U — up, D — down; axis x is directed to the right, y — up).The number of characters (that is, the number of moves) must not exceed 106. All the Princess's moves should be correct, that is must not lead to the cell where a tree grows. It is allowed for the Princess and the Shadow to occupy the same cell before the last turn.",
      "sample_tests": "ExamplesInputCopy0 0 1 0 10 1OutputCopyLLURInputCopy5 0 3 0 82 -12 02 13 -14 14 03 14 -1OutputCopy-1InputCopy3 2 1 1 30 11 00 0OutputCopyDLL",
      "description": "E. Princess and Her Shadow\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputFirst line of the input contains the coordinates of the characters vx, vy, sx, sy and the number of trees m (0 ≤ m ≤ 400). The following m lines contain the coordinates of the trees.All the coordinates are integers between -100 and 100, inclusive. The Princess, The Shadow and the trees are located in the different cells.\n\nOutputIf it is impossible for the Princess to catch the Shadow, print \"-1\" (without quotes).Otherwise print a sequence of characters \"L\", \"R\", \"D\", \"U\", corresponding to the Princess's moves, following which she will be able to catch the Shadow at some turn (L — move to the left, R — to the right, U — up, D — down; axis x is directed to the right, y — up).The number of characters (that is, the number of moves) must not exceed 106. All the Princess's moves should be correct, that is must not lead to the cell where a tree grows. It is allowed for the Princess and the Shadow to occupy the same cell before the last turn.\n\nInputCopy0 0 1 0 10 1OutputCopyLLURInputCopy5 0 3 0 82 -12 02 13 -14 14 03 14 -1OutputCopy-1InputCopy3 2 1 1 30 11 00 0OutputCopyDLL\n\nInputCopy0 0 1 0 10 1\n\nOutputCopyLLUR\n\nInputCopy5 0 3 0 82 -12 02 13 -14 14 03 14 -1\n\nOutputCopy-1\n\nInputCopy3 2 1 1 30 11 00 0\n\nOutputCopyDLL\n\nNoteBelow the pictures for the samples are given (Princess, Shadow and the trees are colored in pink, gray and black correspondingly; the blue dot marks the lattice center).In the first case the Princess may make two left steps, one step upwards and one right step: In the following case the Princess cannot catch the Shadow: In the last sample the Princess may make two left steps and one down step (in any order):",
      "solutions": [
        {
          "title": "Codeforces Round #188 - Codeforces",
          "content": "Hello, friends! Winter 188th Codeforces Round is coming!We wished to prepare for you some enjoyable problems (as we believe, not very difficult) with nice ideas and clear statements.\"We\" includes authors of the problems yaro and Rei, Codeforces Rounds supervisor Gerald and the platform founder MikeMirzayanov. Special thanks to Pasha (PavelKunyavskiy) and Artem (RAD) for the testing and helpful comments.Last time I was preparing a competition here on Codeforces, Rounds were still \"beta\". Well, with less \"beta\" comes greater responsibility. So I wish the authors and the organizers a successfully held Round. As for the participants, I wish you the unconventional ideas, the clean code (and a clean keyboard, of course), and satisfaction from five (well, possibly the less number will also do...) correct and accepted solutions!It seems to us that it is not an easy job to arrange the problems by their difficulty, so we have chosen the dynamic scores. Still (out of curiousity) let us put a bet on the following relative difficulties for the problems: div.1 — B-B-C-C-E, div.2 — A-B-C-C-E. How close is our guess?UPD Sorry for the problems with the Codeforces testing queue during the round.We will still be happy if you rate our contest (when it will be over): short survey.And with the gap of one hack the winner of div.1 is meret (Jakub Pachocki)!Div.1 standings, Div.2 standings.Analysis (thanks to Rei for the translation).",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/7862",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1433
        },
        {
          "title": "Codeforces Round #188 (analysis) - Codeforces",
          "content": "Problem analysis v 0.9.318A - Even OddsIn this problem we need to understand how exactly numbers from 1 to n rearrange when we write firstly all odd numbers and after them all even numbers. To find out which number stands at position k one needs to find the position where even numbers start and output either the position of the odd number from the first half of the sequence or for the even number from the second half of the sequence.318B - Strings of PowerIn the heavy metal problem one needs to find the number of the substrings in the string S with a given prefix A and given suffix B. If we mark black all the starting positions of the entries of the string A in S, and white all the starting positions of the entries of the string B, then we come to the following problem: count the number of pairs <black position, white position> (in this order). To solve this it is enough to iterate from left to right counting the number of the passed black positions. Meeting black position we increment this number by one, meeting white position we add to the answer the number of pairs with this white position, which is exactly our memorized number of the already passed black positions.317A - Perfect Pair318C - Perfect PairThis problem were more about accuracy then about ideas or coding. It is important to not forget any cases here.On each step we replace one of the numbers x, y by their sum x + y until the pair becomes m-perfect (id est one of them becomes not lesser than m). It is clear that one sould replace lesser number from the pair x, y. Indeed lets say the pair x1 ≤ y1 dominates the pair x2 ≤ y2, if y1 ≥ y2 and x1 ≥ y2. In this case if one can get m-perfect pair from x2, y2 by certain sequence of actions, then one can get m-perfect pair from x1, y1 by the same or shorter sequence of actions. If x ≤ y, then the pair x + y, y dominates the pair x + y, x. Hence path from x + y, y to m-perfect is not longer than from x + y, x, and we may assume that we choose exactly this pair.Consider following cases: x ≤ 0, y ≤ 0 In this case our numbers do not increase in the process. Hence either the pair is alredy m-perfect or it will never be. x > 0 and y > 0 In this case for each m pair will after several steps become m-perfect. To count precise number of those steps one needs to launch emulation. If x > 0 and y > 0, then pair \"grows exponentionaly>> (more formally: easy to show that starting from secnd step sum x + y grows in at least 3 / 2 times each step) and emulation works pretty fast. However in the case x < 0 and y > 0 (or vice versa) pair might change very slowly. Most bright example is x =  - 1018, y = 1. Thus one needs to count number of steps until both numbers becomes positive before launching emulationt. For x < 0 and y > 0 number of those steps is exactly . 317B - Ants318D - AntsOne may reformulate the problem ass follows. Non-negative integers A(x, y) are placed in the vertices of two-dimensional lattice We may imagine this construction as a function . On each step for each vertex P = (x, y) with A(x, y) ≥ 4 we perform operation φP, which substracts 4 from A(x, y) and adds 1 to A(x, y - 1), A(x, y + 1), A(x - 1, y), A(x + 1, y). We may think that operation φP applies to the whole function A. We need to find values of A after the iterations stops.Key idea is that operactions φP and φQ for all points P and Q commutes, that is φP(φQ(A)) = φQ(φP(A)). This means that the order of operations is unimportant. In particular, we may assume that from each given vertex run all possible four-groups of ants and not only one. After this observation one may run full emulation of the process. As an exercise contestants may check that ants will never leave square 200 × 200 with center in the origin 0 with given constraints.317C - Balance318E - BalanceIn this problem we need to find 2n2 transfusions from initial configuration to the desired one. First of all we propose the following: if in each connected component overall volume of the water in initial configuration is the same as in desired one, then answer exist. We call the vessel ready, if current volume of its water equals desired one. Let us describe solution which is probably easier to code. We will make vessels ready one by one. Consider the pair of non-ready vessels s and t (there is more water in s than desired, and less water in t than desired), such that they are connected by the path P, and if one transfuses d litres from s to t then one of the vessels becomes ready. Now we need to find a way to transfuse d litres by path P from s to t. One may write recursive function pour(s, t, d) for this aim. Let t' stand before t in this path, then function works as follows: transfuses from t' to t as many water as possible (not more than d of course), then calls pour(s, t', d) and on the final step transfuses from t' to t all that left. It is easy to check that all such transfusions are correct. This algorithm makes 2len transfusions on the path of length len, so total number of transfusions is not greater than 2n2.317D - Game with PowersFor each numner x denote sequence of its powers within [1..n] as Pow(x): Game proceeds as follows: on each step one player takes still available number x from 1 to n and prohibits whole set Pow(x). Who can't make his turn loses.This game may be decomposed in the sum of lesser games. Indeed, lets call number x simple (and corresponding sequence Pow(x) simple), if it is not a power of any number y < x. Then: 1. for each there is simple x, such that ; 2. for each simple distinct x and y sets Pow(x) and P(y) do not intersect. Indeed, for a given k there is exactly one simple x such that k is power of x. This may be showed from fundamental theorem of arithmetic: if and d = gcd(α1, α2, ..., αn), then .Hence set [1..n] decomposes into primitive sets Pow(x), on each of those Pow(x) game proceeds independetly. Now one may use Sprague–Grundy theory to see that mexx of our game is just xor of all mexx of games on simple Pow(x). For fixed x, if Pow(x) = {x, x2, ..., xs}, then mexx of the game on Pow(x) depends only on s, but not on x. In our case s runs from 1 to 29, mexx for all such s may be directly precalculated. Now it is enough to find numbers q(s) of simple x with a given size of Pow(x) equal to s (actually we are interested in parity of q(s) not in q(s) itself).Our constraints allows to do it directly: run x from 2 to , if it is not crossed out, determine the size Pow(x) [increment corresponding q(s)], and cross out all numbers from Pow(x). This cycle finds all simple sequences of length at least 2. Quantity of non-crossed numbers is the number of all simple sequences of length 1. Now it is enough to look at parities of q(s) and xor coressponding mexx.However one may find all q(s) for . Indeed lets look at the number and sequence {x, x2, x3, x4, ..., xs}. This sequence is not simple iff it is containd in some larger simple sequence. But number of subsequenes of size s in a given sequence of size t > s is easy to find: it is just [t / s]. Recalling that simple sequences do not intersect one gets the reccurent formula:. Now it is easy to find all q(s) from q(29) to q(1).Remark: while coding it is important to remeber simple number x = 1.317E - Princess and Her ShadowIn this problem princess Vlada should simply catch the Shadow. Here is the idea of a solution. If there is only one tree, then using it as a barrier to the shadow it is not hard to catch the shadow. Similar technique works if Vlada and Shadow are far from the square where all the trees grow. But what can she do in the dark depths of the forest? If there is no path at all between Vlada and Shadow, then there is no way to catch it. Otherwise consider a shortest path from Vlada to the Shadow and make Vlada follow it. This path gives Vlada a queue of the steps that she should perform. Additionaly if shadow moves, then we add her move to the queue (simply speaking Vlada follows the shadow). This is where the algorithmic part ends. Now we state that either Vlada catches the shadow in the desired number of steps, or steps out of the \"forest square\". To proof this we note that the length of the path between Vlada and Shadow may only decrease. And if it does not decrease long enough, then once in k steps (k is the length of the path) Vlada and Shadow shifts at the same vector over and over, and at some moment leaves the \"forest square\". Note that if the trees allow our heroes to step out of the \"forest square\" at the beginning, then we may just get them out from the start. But taking this approach we still need to catch the Shadow in a \"labyrinth forest\".Apologies for the delay. There are probably misprints and mistakes here (thousands of them!), please feel free to point them out.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/7956",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 317\\s*E"
          },
          "content_length": 8753
        },
        {
          "title": "Codeforces Round #188 (analysis) - Codeforces",
          "content": "Problem analysis v 0.9.318A - Even OddsIn this problem we need to understand how exactly numbers from 1 to n rearrange when we write firstly all odd numbers and after them all even numbers. To find out which number stands at position k one needs to find the position where even numbers start and output either the position of the odd number from the first half of the sequence or for the even number from the second half of the sequence.318B - Strings of PowerIn the heavy metal problem one needs to find the number of the substrings in the string S with a given prefix A and given suffix B. If we mark black all the starting positions of the entries of the string A in S, and white all the starting positions of the entries of the string B, then we come to the following problem: count the number of pairs <black position, white position> (in this order). To solve this it is enough to iterate from left to right counting the number of the passed black positions. Meeting black position we increment this number by one, meeting white position we add to the answer the number of pairs with this white position, which is exactly our memorized number of the already passed black positions.317A - Perfect Pair318C - Perfect PairThis problem were more about accuracy then about ideas or coding. It is important to not forget any cases here.On each step we replace one of the numbers x, y by their sum x + y until the pair becomes m-perfect (id est one of them becomes not lesser than m). It is clear that one sould replace lesser number from the pair x, y. Indeed lets say the pair x1 ≤ y1 dominates the pair x2 ≤ y2, if y1 ≥ y2 and x1 ≥ y2. In this case if one can get m-perfect pair from x2, y2 by certain sequence of actions, then one can get m-perfect pair from x1, y1 by the same or shorter sequence of actions. If x ≤ y, then the pair x + y, y dominates the pair x + y, x. Hence path from x + y, y to m-perfect is not longer than from x + y, x, and we may assume that we choose exactly this pair.Consider following cases: x ≤ 0, y ≤ 0 In this case our numbers do not increase in the process. Hence either the pair is alredy m-perfect or it will never be. x > 0 and y > 0 In this case for each m pair will after several steps become m-perfect. To count precise number of those steps one needs to launch emulation. If x > 0 and y > 0, then pair \"grows exponentionaly>> (more formally: easy to show that starting from secnd step sum x + y grows in at least 3 / 2 times each step) and emulation works pretty fast. However in the case x < 0 and y > 0 (or vice versa) pair might change very slowly. Most bright example is x =  - 1018, y = 1. Thus one needs to count number of steps until both numbers becomes positive before launching emulationt. For x < 0 and y > 0 number of those steps is exactly . 317B - Ants318D - AntsOne may reformulate the problem ass follows. Non-negative integers A(x, y) are placed in the vertices of two-dimensional lattice We may imagine this construction as a function . On each step for each vertex P = (x, y) with A(x, y) ≥ 4 we perform operation φP, which substracts 4 from A(x, y) and adds 1 to A(x, y - 1), A(x, y + 1), A(x - 1, y), A(x + 1, y). We may think that operation φP applies to the whole function A. We need to find values of A after the iterations stops.Key idea is that operactions φP and φQ for all points P and Q commutes, that is φP(φQ(A)) = φQ(φP(A)). This means that the order of operations is unimportant. In particular, we may assume that from each given vertex run all possible four-groups of ants and not only one. After this observation one may run full emulation of the process. As an exercise contestants may check that ants will never leave square 200 × 200 with center in the origin 0 with given constraints.317C - Balance318E - BalanceIn this problem we need to find 2n2 transfusions from initial configuration to the desired one. First of all we propose the following: if in each connected component overall volume of the water in initial configuration is the same as in desired one, then answer exist. We call the vessel ready, if current volume of its water equals desired one. Let us describe solution which is probably easier to code. We will make vessels ready one by one. Consider the pair of non-ready vessels s and t (there is more water in s than desired, and less water in t than desired), such that they are connected by the path P, and if one transfuses d litres from s to t then one of the vessels becomes ready. Now we need to find a way to transfuse d litres by path P from s to t. One may write recursive function pour(s, t, d) for this aim. Let t' stand before t in this path, then function works as follows: transfuses from t' to t as many water as possible (not more than d of course), then calls pour(s, t', d) and on the final step transfuses from t' to t all that left. It is easy to check that all such transfusions are correct. This algorithm makes 2len transfusions on the path of length len, so total number of transfusions is not greater than 2n2.317D - Game with PowersFor each numner x denote sequence of its powers within [1..n] as Pow(x): Game proceeds as follows: on each step one player takes still available number x from 1 to n and prohibits whole set Pow(x). Who can't make his turn loses.This game may be decomposed in the sum of lesser games. Indeed, lets call number x simple (and corresponding sequence Pow(x) simple), if it is not a power of any number y < x. Then: 1. for each there is simple x, such that ; 2. for each simple distinct x and y sets Pow(x) and P(y) do not intersect. Indeed, for a given k there is exactly one simple x such that k is power of x. This may be showed from fundamental theorem of arithmetic: if and d = gcd(α1, α2, ..., αn), then .Hence set [1..n] decomposes into primitive sets Pow(x), on each of those Pow(x) game proceeds independetly. Now one may use Sprague–Grundy theory to see that mexx of our game is just xor of all mexx of games on simple Pow(x). For fixed x, if Pow(x) = {x, x2, ..., xs}, then mexx of the game on Pow(x) depends only on s, but not on x. In our case s runs from 1 to 29, mexx for all such s may be directly precalculated. Now it is enough to find numbers q(s) of simple x with a given size of Pow(x) equal to s (actually we are interested in parity of q(s) not in q(s) itself).Our constraints allows to do it directly: run x from 2 to , if it is not crossed out, determine the size Pow(x) [increment corresponding q(s)], and cross out all numbers from Pow(x). This cycle finds all simple sequences of length at least 2. Quantity of non-crossed numbers is the number of all simple sequences of length 1. Now it is enough to look at parities of q(s) and xor coressponding mexx.However one may find all q(s) for . Indeed lets look at the number and sequence {x, x2, x3, x4, ..., xs}. This sequence is not simple iff it is containd in some larger simple sequence. But number of subsequenes of size s in a given sequence of size t > s is easy to find: it is just [t / s]. Recalling that simple sequences do not intersect one gets the reccurent formula:. Now it is easy to find all q(s) from q(29) to q(1).Remark: while coding it is important to remeber simple number x = 1.317E - Princess and Her ShadowIn this problem princess Vlada should simply catch the Shadow. Here is the idea of a solution. If there is only one tree, then using it as a barrier to the shadow it is not hard to catch the shadow. Similar technique works if Vlada and Shadow are far from the square where all the trees grow. But what can she do in the dark depths of the forest? If there is no path at all between Vlada and Shadow, then there is no way to catch it. Otherwise consider a shortest path from Vlada to the Shadow and make Vlada follow it. This path gives Vlada a queue of the steps that she should perform. Additionaly if shadow moves, then we add her move to the queue (simply speaking Vlada follows the shadow). This is where the algorithmic part ends. Now we state that either Vlada catches the shadow in the desired number of steps, or steps out of the \"forest square\". To proof this we note that the length of the path between Vlada and Shadow may only decrease. And if it does not decrease long enough, then once in k steps (k is the length of the path) Vlada and Shadow shifts at the same vector over and over, and at some moment leaves the \"forest square\". Note that if the trees allow our heroes to step out of the \"forest square\" at the beginning, then we may just get them out from the start. But taking this approach we still need to catch the Shadow in a \"labyrinth forest\".Apologies for the delay. There are probably misprints and mistakes here (thousands of them!), please feel free to point them out.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/7956",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 317\\s*E"
          },
          "content_length": 8753
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #188 - Codeforces - Code 1",
          "code": "-1000000000000000000 1 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7862",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #188 - Codeforces - Code 2",
          "code": "...\nlong long x,y,m;\nlong long res;\n...\nint mymx = max(x,y); // int ???\nint mymn = min(x,y); // int ???\n\nx = mymx;\ny = mymn;\n...",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7862",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #188 - Codeforces - Code 3",
          "code": "...\nlong long x,y,m;\nlong long res;\n...\nint mymx = max(x,y); // int ???\nint mymn = min(x,y); // int ???\n\nx = mymx;\ny = mymn;\n...",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7862",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #188 - Codeforces - Code 4",
          "code": "s.size() < 4",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7862",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #188 - Codeforces - Code 5",
          "code": "s.size() - 4",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7862",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #188 - Codeforces - Code 6",
          "code": "#define SZ(x) (int)x.size()",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7862",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #188 - Codeforces - Code 7",
          "code": "Contest rating",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7862",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #188 (analysis) - Codeforces - Code 1",
          "code": "Thank you for the nice contest and editorial. \nIn \"Ants\" problem, Is there any way to expect the simulation will be converge so fast before we writing brute force code? how to make sure n = 30000 is the worst case?",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7956",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #188 (analysis) - Codeforces - Code 2",
          "code": "Thank you for the nice contest and editorial. \nIn \"Ants\" problem, Is there any way to expect the simulation will be converge so fast before we writing brute force code? how to make sure n = 30000 is the worst case?",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7956",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #188 (analysis) - Codeforces - Code 3",
          "code": "#include <string.h>\n#include <cstdio>\n#include <map>\nusing namespace std;\nmap<long long ,int>SG;\nint DFS(long long state) {\n    //printf(\"%I64d\\n\",state);getchar();getchar();\n    if(state==0) return 0;\n    if(SG[state]) return SG[state];\n    int len=0;long long tmp=state;\n    while(tmp>0) {\n        len++;\n        tmp>>=1;\n    }\n    bool cnt[100];memset(cnt,0,sizeof(cnt));\n    for(int i=1;i<=len;i++) {\n        long long k=(1<<(i-1)),tmp=state;\n        while(k<=tmp) {\n            tmp&=(((1<<(len+1))-1)^k);//printf(\"%lld\\n\",k);\n            k<<=i;\n\t\t}//printf(\"%lld\\n\",tmp);\n\t\tif(tmp==state) continue;\n        int ret=DFS(tmp);\n        cnt[ret]=1;\n    }\n    for(int i=0;;i++)if(!cnt[i]){\n        //printf(\"%d %d\\n\",len,i);\n        return (SG[state]=i);\n    }\n}\nint main()\n{\n    for(int I=1;I<=29;I++) {\n        printf(\"%d\\n\",DFS((long long )((1<<I)-1)));\n    }\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/7956",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #188 (analysis) - Codeforces - Code 4",
          "code": "#include <string.h>\n#include <cstdio>\n#include <map>\nusing namespace std;\nmap<long long ,int>SG;\nint DFS(long long state) {\n    //printf(\"%I64d\\n\",state);getchar();getchar();\n    if(state==0) return 0;\n    if(SG[state]) return SG[state];\n    int len=0;long long tmp=state;\n    while(tmp>0) {\n        len++;\n        tmp>>=1;\n    }\n    bool cnt[100];memset(cnt,0,sizeof(cnt));\n    for(int i=1;i<=len;i++) {\n        long long k=(1<<(i-1)),tmp=state;\n        while(k<=tmp) {\n            tmp&=(((1<<(len+1))-1)^k);//printf(\"%lld\\n\",k);\n            k<<=i;\n\t\t}//printf(\"%lld\\n\",tmp);\n\t\tif(tmp==state) continue;\n        int ret=DFS(tmp);\n        cnt[ret]=1;\n    }\n    for(int i=0;;i++)if(!cnt[i]){\n        //printf(\"%d %d\\n\",len,i);\n        return (SG[state]=i);\n    }\n}\nint main()\n{\n    for(int I=1;I<=29;I++) {\n        printf(\"%d\\n\",DFS((long long )((1<<I)-1)));\n    }\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/7956",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #188 (analysis) - Codeforces - Code 1",
          "code": "Thank you for the nice contest and editorial. \nIn \"Ants\" problem, Is there any way to expect the simulation will be converge so fast before we writing brute force code? how to make sure n = 30000 is the worst case?",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7956",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #188 (analysis) - Codeforces - Code 2",
          "code": "Thank you for the nice contest and editorial. \nIn \"Ants\" problem, Is there any way to expect the simulation will be converge so fast before we writing brute force code? how to make sure n = 30000 is the worst case?",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7956",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #188 (analysis) - Codeforces - Code 3",
          "code": "#include <string.h>\n#include <cstdio>\n#include <map>\nusing namespace std;\nmap<long long ,int>SG;\nint DFS(long long state) {\n    //printf(\"%I64d\\n\",state);getchar();getchar();\n    if(state==0) return 0;\n    if(SG[state]) return SG[state];\n    int len=0;long long tmp=state;\n    while(tmp>0) {\n        len++;\n        tmp>>=1;\n    }\n    bool cnt[100];memset(cnt,0,sizeof(cnt));\n    for(int i=1;i<=len;i++) {\n        long long k=(1<<(i-1)),tmp=state;\n        while(k<=tmp) {\n            tmp&=(((1<<(len+1))-1)^k);//printf(\"%lld\\n\",k);\n            k<<=i;\n\t\t}//printf(\"%lld\\n\",tmp);\n\t\tif(tmp==state) continue;\n        int ret=DFS(tmp);\n        cnt[ret]=1;\n    }\n    for(int i=0;;i++)if(!cnt[i]){\n        //printf(\"%d %d\\n\",len,i);\n        return (SG[state]=i);\n    }\n}\nint main()\n{\n    for(int I=1;I<=29;I++) {\n        printf(\"%d\\n\",DFS((long long )((1<<I)-1)));\n    }\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/7956",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #188 (analysis) - Codeforces - Code 4",
          "code": "#include <string.h>\n#include <cstdio>\n#include <map>\nusing namespace std;\nmap<long long ,int>SG;\nint DFS(long long state) {\n    //printf(\"%I64d\\n\",state);getchar();getchar();\n    if(state==0) return 0;\n    if(SG[state]) return SG[state];\n    int len=0;long long tmp=state;\n    while(tmp>0) {\n        len++;\n        tmp>>=1;\n    }\n    bool cnt[100];memset(cnt,0,sizeof(cnt));\n    for(int i=1;i<=len;i++) {\n        long long k=(1<<(i-1)),tmp=state;\n        while(k<=tmp) {\n            tmp&=(((1<<(len+1))-1)^k);//printf(\"%lld\\n\",k);\n            k<<=i;\n\t\t}//printf(\"%lld\\n\",tmp);\n\t\tif(tmp==state) continue;\n        int ret=DFS(tmp);\n        cnt[ret]=1;\n    }\n    for(int i=0;;i++)if(!cnt[i]){\n        //printf(\"%d %d\\n\",len,i);\n        return (SG[state]=i);\n    }\n}\nint main()\n{\n    for(int I=1;I<=29;I++) {\n        printf(\"%d\\n\",DFS((long long )((1<<I)-1)));\n    }\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/7956",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int vx = inf.readInt(-100, 100, \"vx\");\n    inf.readSpace();\n    int vy = inf.readInt(-100, 100, \"vy\");\n    inf.readSpace();\n    int sx = inf.readInt(-100, 100, \"sx\");\n    inf.readSpace();\n    int sy = inf.readInt(-100, 100, \"sy\");\n    inf.readSpace();\n    int m = inf.readInt(0, 400, \"m\");\n    inf.readEoln();\n\n    ensuref(vx != sx || vy != sy, \"The Princess and the Shadow are in the same cell\");\n\n    set<pair<int, int>> tree_positions;\n\n    for (int i = 0; i < m; ++i) {\n        int x = inf.readInt(-100, 100, \"x_i\");\n        inf.readSpace();\n        int y = inf.readInt(-100, 100, \"y_i\");\n        inf.readEoln();\n\n        ensuref(!(x == vx && y == vy), \"Tree position (%d, %d) is the same as the Princess's position\", x, y);\n        ensuref(!(x == sx && y == sy), \"Tree position (%d, %d) is the same as the Shadow's position\", x, y);\n\n        auto result = tree_positions.insert(make_pair(x, y));\n        ensuref(result.second, \"Duplicate tree position (%d, %d)\", x, y);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int vx = inf.readInt(-100, 100, \"vx\");\n    inf.readSpace();\n    int vy = inf.readInt(-100, 100, \"vy\");\n    inf.readSpace();\n    int sx = inf.readInt(-100, 100, \"sx\");\n    inf.readSpace();\n    int sy = inf.readInt(-100, 100, \"sy\");\n    inf.readSpace();\n    int m = inf.readInt(0, 400, \"m\");\n    inf.readEoln();\n\n    ensuref(vx != sx || vy != sy, \"The Princess and the Shadow are in the same cell\");\n\n    set<pair<int, int>> tree_positions;\n\n    for (int i = 0; i < m; ++i) {\n        int x = inf.readInt(-100, 100, \"x_i\");\n        inf.readSpace();\n        int y = inf.readInt(-100, 100, \"y_i\");\n        inf.readEoln();\n\n        ensuref(!(x == vx && y == vy), \"Tree position (%d, %d) is the same as the Princess's position\", x, y);\n        ensuref(!(x == sx && y == sy), \"Tree position (%d, %d) is the same as the Shadow's position\", x, y);\n\n        auto result = tree_positions.insert(make_pair(x, y));\n        ensuref(result.second, \"Duplicate tree position (%d, %d)\", x, y);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int vx = inf.readInt(-100, 100, \"vx\");\n    inf.readSpace();\n    int vy = inf.readInt(-100, 100, \"vy\");\n    inf.readSpace();\n    int sx = inf.readInt(-100, 100, \"sx\");\n    inf.readSpace();\n    int sy = inf.readInt(-100, 100, \"sy\");\n    inf.readSpace();\n    int m = inf.readInt(0, 400, \"m\");\n    inf.readEoln();\n\n    ensuref(vx != sx || vy != sy, \"The Princess and the Shadow are in the same cell\");\n\n    set<pair<int, int>> tree_positions;\n\n    for (int i = 0; i < m; ++i) {\n        int x = inf.readInt(-100, 100, \"x_i\");\n        inf.readSpace();\n        int y = inf.readInt(-100, 100, \"y_i\");\n        inf.readEoln();\n\n        ensuref(!(x == vx && y == vy), \"Tree position (%d, %d) is the same as the Princess's position\", x, y);\n        ensuref(!(x == sx && y == sy), \"Tree position (%d, %d) is the same as the Shadow's position\", x, y);\n\n        auto result = tree_positions.insert(make_pair(x, y));\n        ensuref(result.second, \"Duplicate tree position (%d, %d)\", x, y);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[])\n{\n    registerTestlibCmd(argc, argv);\n\n    // Read input data from the input file (inf)\n    int vx = inf.readInt(-100, 100);\n    int vy = inf.readInt(-100, 100);\n    int sx = inf.readInt(-100, 100);\n    int sy = inf.readInt(-100, 100);\n    int m = inf.readInt(0, 400);\n\n    set<pair<int,int>> trees;\n    for (int i = 0; i < m; ++i)\n    {\n        int tx = inf.readInt(-100, 100);\n        int ty = inf.readInt(-100, 100);\n        trees.insert({tx, ty});\n    }\n\n    // Save the initial positions\n    int princess_x = vx;\n    int princess_y = vy;\n    int shadow_x = sx;\n    int shadow_y = sy;\n\n    // Read the jury's answer\n    string jury_ans_line = ans.readLine();\n\n    bool jury_impossible = (jury_ans_line == \"-1\");\n\n    // Read the contestant's answer\n    string contestant_answer = ouf.readLine();\n\n    if (contestant_answer == \"-1\")\n    {\n        if (jury_impossible)\n            quitf(_ok, \"both answers are impossible\");\n        else\n            quitf(_wa, \"jury found a solution, but contestant says impossible\");\n    }\n    else\n    {\n        // Contestant outputs a sequence of moves\n        if (contestant_answer.size() > 1000000)\n            quitf(_wa, \"the sequence is too long, length = %d\", (int)contestant_answer.size());\n\n        map<char, pair<int,int>> dir = {\n            {'L', {-1, 0}},\n            {'R', {1, 0}},\n            {'U', {0, 1}},\n            {'D', {0, -1}},\n        };\n\n        int px = princess_x;\n        int py = princess_y;\n        int sx = shadow_x;\n        int sy = shadow_y;\n\n        for (size_t step = 0; step < contestant_answer.size(); ++step)\n        {\n            char move = contestant_answer[step];\n\n            if (dir.find(move) == dir.end())\n                quitf(_wa, \"invalid character '%c' at position %d\", move, (int)step+1);\n\n            // Princess moves\n            int pdx = dir[move].first;\n            int pdy = dir[move].second;\n\n            int new_px = px + pdx;\n            int new_py = py + pdy;\n\n            // Check whether the Princess moves into a tree cell\n            if (trees.count({new_px, new_py}))\n                quitf(_wa, \"Princess moves into a tree cell at step %d (%d, %d)\", (int)step+1, new_px, new_py);\n\n            // Update Princess position\n            px = new_px;\n            py = new_py;\n\n            // Shadow moves\n            // Check if Shadow can move in the same direction\n            int sdx = pdx;\n            int sdy = pdy;\n\n            int new_sx = sx + sdx;\n            int new_sy = sy + sdy;\n\n            // If new cell is not a tree, Shadow moves\n            if (!trees.count({new_sx, new_sy}))\n            {\n                sx = new_sx;\n                sy = new_sy;\n            }\n\n            // After both move, check if positions are same\n            if (px == sx && py == sy)\n                quitf(_ok, \"Princess catches the Shadow at step %d\", (int)step+1);\n        }\n\n        // After all moves, if the Princess did not catch the Shadow\n        quitf(_wa, \"Princess did not catch the Shadow after %d moves\", (int)contestant_answer.size());\n    }\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char*argv[]){\n    registerGen(argc, argv, 1);\n    \n    // Parse parameters\n    int m = opt<int>(\"m\", 0); // Number of trees\n    string type = opt<string>(\"type\", \"random\"); // Type of test case\n    int min_coord = opt<int>(\"min_coord\", -100);\n    int max_coord = opt<int>(\"max_coord\", 100);\n    \n    // Ensure valid coordinate limits\n    ensure(min_coord >= -100 && min_coord <= 100);\n    ensure(max_coord >= -100 && max_coord <= 100);\n    ensure(min_coord <= max_coord);\n    \n    // Declare variables\n    int vx, vy, sx, sy;\n    vector<pair<int,int>> trees;\n    \n    if(type == \"no_trees\"){\n        // No trees\n        m = 0;\n        \n        // Random positions for Princess and Shadow\n        vx = rnd.next(min_coord, max_coord);\n        vy = rnd.next(min_coord, max_coord);\n        do {\n            sx = rnd.next(min_coord, max_coord);\n            sy = rnd.next(min_coord, max_coord);\n        } while(sx == vx && sy == vy);\n    }\n    else if(type == \"max_trees\"){\n        // Maximum number of trees\n        m = 400;\n        \n        // Random positions for Princess and Shadow\n        vx = rnd.next(min_coord, max_coord);\n        vy = rnd.next(min_coord, max_coord);\n        do {\n            sx = rnd.next(min_coord, max_coord);\n            sy = rnd.next(min_coord, max_coord);\n        } while(sx == vx && sy == vy);\n        \n        // Generate tree positions\n        set<pair<int,int>> positions;\n        positions.insert({vx, vy});\n        positions.insert({sx, sy});\n        while(positions.size() < m + 2){\n            int tx = rnd.next(min_coord, max_coord);\n            int ty = rnd.next(min_coord, max_coord);\n            positions.insert({tx, ty});\n        }\n        positions.erase({vx, vy});\n        positions.erase({sx, sy});\n        for(auto p : positions){\n            trees.push_back(p);\n        }\n    }\n    else if(type == \"impossible\"){\n        // Impossible case where the Shadow is completely enclosed by trees\n        int center_x = rnd.next(min_coord+1, max_coord-1);\n        int center_y = rnd.next(min_coord+1, max_coord-1);\n        sx = center_x;\n        sy = center_y;\n        \n        // Surround the Shadow with trees\n        vector<pair<int,int>> positions = {\n            {center_x-1, center_y}, {center_x+1, center_y},\n            {center_x, center_y-1}, {center_x, center_y+1}\n        };\n        trees = positions;\n        m = positions.size();\n        \n        // Place Princess elsewhere\n        do {\n            vx = rnd.next(min_coord, max_coord);\n            vy = rnd.next(min_coord, max_coord);\n        } while((vx == sx && vy == sy) || count(positions.begin(), positions.end(), make_pair(vx, vy)));\n    }\n    else if(type == \"possible\"){\n        // Possible scenario with no trees\n        m = 0;\n\n        // Random positions for Princess and Shadow\n        vx = rnd.next(min_coord, max_coord);\n        vy = rnd.next(min_coord, max_coord);\n        do {\n            sx = rnd.next(min_coord, max_coord);\n            sy = rnd.next(min_coord, max_coord);\n        } while(sx == vx && sy == vy);\n    }\n    else if(type == \"shadow_isolation\"){\n        // Shadow is nearly enclosed by trees but one side open\n        int center_x = rnd.next(min_coord+1, max_coord-1);\n        int center_y = rnd.next(min_coord+1, max_coord-1);\n        sx = center_x;\n        sy = center_y;\n        \n        vector<pair<int,int>> positions = {\n            {center_x-1, center_y}, {center_x+1, center_y},\n            {center_x, center_y-1}\n        };\n        trees = positions;\n        m = positions.size();\n        \n        // Place Princess at a random position\n        do {\n            vx = rnd.next(min_coord, max_coord);\n            vy = rnd.next(min_coord, max_coord);\n        } while((vx == sx && vy == sy) || count(positions.begin(), positions.end(), make_pair(vx, vy)));\n    }\n    else if(type == \"princess_isolation\"){\n        // Princess is surrounded by trees and cannot move\n        int center_x = rnd.next(min_coord+1, max_coord-1);\n        int center_y = rnd.next(min_coord+1, max_coord-1);\n        vx = center_x;\n        vy = center_y;\n        \n        vector<pair<int,int>> positions = {\n            {center_x-1, center_y}, {center_x+1, center_y},\n            {center_x, center_y-1}, {center_x, center_y+1}\n        };\n        trees = positions;\n        m = positions.size();\n        \n        // Place Shadow elsewhere\n        do {\n            sx = rnd.next(min_coord, max_coord);\n            sy = rnd.next(min_coord, max_coord);\n        } while((sx == vx && sy == vy) || count(positions.begin(), positions.end(), make_pair(sx, sy)));\n    }\n    else if(type == \"close_start\"){\n        // Princess and Shadow start next to each other\n        vx = rnd.next(min_coord, max_coord);\n        vy = rnd.next(min_coord, max_coord);\n        vector<pair<int,int>> adjCells;\n        adjCells.push_back({vx-1, vy});\n        adjCells.push_back({vx+1, vy});\n        adjCells.push_back({vx, vy-1});\n        adjCells.push_back({vx, vy+1});\n        vector<pair<int,int>> possiblePositions;\n        for(auto p : adjCells){\n            if(p.first >= min_coord && p.first <= max_coord && p.second >= min_coord && p.second <= max_coord){\n                possiblePositions.push_back(p);\n            }\n        }\n        if(possiblePositions.empty()){\n            vx = min_coord;\n            vy = min_coord;\n            possiblePositions.push_back({vx+1, vy});\n        }\n        int idx = rnd.next(0, (int)possiblePositions.size() - 1);\n        sx = possiblePositions[idx].first;\n        sy = possiblePositions[idx].second;\n        m = 0;\n    }\n    else if (type == \"far_start\"){\n        // Princess and Shadow are at maximum distance\n        vx = min_coord;\n        vy = min_coord;\n        sx = max_coord;\n        sy = max_coord;\n        m = 0;\n    }\n    else if (type == \"random\"){\n        // Random test case\n        m = opt<int>(\"m\", rnd.next(0, 400));\n        \n        set<pair<int,int>> positions;\n        vx = rnd.next(min_coord, max_coord);\n        vy = rnd.next(min_coord, max_coord);\n        positions.insert({vx, vy});\n        do {\n            sx = rnd.next(min_coord, max_coord);\n            sy = rnd.next(min_coord, max_coord);\n        } while(positions.count({sx, sy}));\n        positions.insert({sx, sy});\n        \n        while(positions.size() < m + 2){\n            int tx = rnd.next(min_coord, max_coord);\n            int ty = rnd.next(min_coord, max_coord);\n            positions.insert({tx, ty});\n        }\n        positions.erase({vx, vy});\n        positions.erase({sx, sy});\n        for(auto p : positions){\n            trees.push_back(p);\n        }\n    }\n    else {\n        // Unknown type\n        fprintf(stderr, \"Unknown type: %s\\n\", type.c_str());\n        exit(1);\n    }\n    \n    // Output the test case\n    printf(\"%d %d %d %d %d\\n\", vx, vy, sx, sy, m);\n    for(int i = 0; i < m; ++i){\n        printf(\"%d %d\\n\", trees[i].first, trees[i].second);\n    }\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char*argv[]){\n    registerGen(argc, argv, 1);\n    \n    // Parse parameters\n    int m = opt<int>(\"m\", 0); // Number of trees\n    string type = opt<string>(\"type\", \"random\"); // Type of test case\n    int min_coord = opt<int>(\"min_coord\", -100);\n    int max_coord = opt<int>(\"max_coord\", 100);\n    \n    // Ensure valid coordinate limits\n    ensure(min_coord >= -100 && min_coord <= 100);\n    ensure(max_coord >= -100 && max_coord <= 100);\n    ensure(min_coord <= max_coord);\n    \n    // Declare variables\n    int vx, vy, sx, sy;\n    vector<pair<int,int>> trees;\n    \n    if(type == \"no_trees\"){\n        // No trees\n        m = 0;\n        \n        // Random positions for Princess and Shadow\n        vx = rnd.next(min_coord, max_coord);\n        vy = rnd.next(min_coord, max_coord);\n        do {\n            sx = rnd.next(min_coord, max_coord);\n            sy = rnd.next(min_coord, max_coord);\n        } while(sx == vx && sy == vy);\n    }\n    else if(type == \"max_trees\"){\n        // Maximum number of trees\n        m = 400;\n        \n        // Random positions for Princess and Shadow\n        vx = rnd.next(min_coord, max_coord);\n        vy = rnd.next(min_coord, max_coord);\n        do {\n            sx = rnd.next(min_coord, max_coord);\n            sy = rnd.next(min_coord, max_coord);\n        } while(sx == vx && sy == vy);\n        \n        // Generate tree positions\n        set<pair<int,int>> positions;\n        positions.insert({vx, vy});\n        positions.insert({sx, sy});\n        while(positions.size() < m + 2){\n            int tx = rnd.next(min_coord, max_coord);\n            int ty = rnd.next(min_coord, max_coord);\n            positions.insert({tx, ty});\n        }\n        positions.erase({vx, vy});\n        positions.erase({sx, sy});\n        for(auto p : positions){\n            trees.push_back(p);\n        }\n    }\n    else if(type == \"impossible\"){\n        // Impossible case where the Shadow is completely enclosed by trees\n        int center_x = rnd.next(min_coord+1, max_coord-1);\n        int center_y = rnd.next(min_coord+1, max_coord-1);\n        sx = center_x;\n        sy = center_y;\n        \n        // Surround the Shadow with trees\n        vector<pair<int,int>> positions = {\n            {center_x-1, center_y}, {center_x+1, center_y},\n            {center_x, center_y-1}, {center_x, center_y+1}\n        };\n        trees = positions;\n        m = positions.size();\n        \n        // Place Princess elsewhere\n        do {\n            vx = rnd.next(min_coord, max_coord);\n            vy = rnd.next(min_coord, max_coord);\n        } while((vx == sx && vy == sy) || count(positions.begin(), positions.end(), make_pair(vx, vy)));\n    }\n    else if(type == \"possible\"){\n        // Possible scenario with no trees\n        m = 0;\n\n        // Random positions for Princess and Shadow\n        vx = rnd.next(min_coord, max_coord);\n        vy = rnd.next(min_coord, max_coord);\n        do {\n            sx = rnd.next(min_coord, max_coord);\n            sy = rnd.next(min_coord, max_coord);\n        } while(sx == vx && sy == vy);\n    }\n    else if(type == \"shadow_isolation\"){\n        // Shadow is nearly enclosed by trees but one side open\n        int center_x = rnd.next(min_coord+1, max_coord-1);\n        int center_y = rnd.next(min_coord+1, max_coord-1);\n        sx = center_x;\n        sy = center_y;\n        \n        vector<pair<int,int>> positions = {\n            {center_x-1, center_y}, {center_x+1, center_y},\n            {center_x, center_y-1}\n        };\n        trees = positions;\n        m = positions.size();\n        \n        // Place Princess at a random position\n        do {\n            vx = rnd.next(min_coord, max_coord);\n            vy = rnd.next(min_coord, max_coord);\n        } while((vx == sx && vy == sy) || count(positions.begin(), positions.end(), make_pair(vx, vy)));\n    }\n    else if(type == \"princess_isolation\"){\n        // Princess is surrounded by trees and cannot move\n        int center_x = rnd.next(min_coord+1, max_coord-1);\n        int center_y = rnd.next(min_coord+1, max_coord-1);\n        vx = center_x;\n        vy = center_y;\n        \n        vector<pair<int,int>> positions = {\n            {center_x-1, center_y}, {center_x+1, center_y},\n            {center_x, center_y-1}, {center_x, center_y+1}\n        };\n        trees = positions;\n        m = positions.size();\n        \n        // Place Shadow elsewhere\n        do {\n            sx = rnd.next(min_coord, max_coord);\n            sy = rnd.next(min_coord, max_coord);\n        } while((sx == vx && sy == vy) || count(positions.begin(), positions.end(), make_pair(sx, sy)));\n    }\n    else if(type == \"close_start\"){\n        // Princess and Shadow start next to each other\n        vx = rnd.next(min_coord, max_coord);\n        vy = rnd.next(min_coord, max_coord);\n        vector<pair<int,int>> adjCells;\n        adjCells.push_back({vx-1, vy});\n        adjCells.push_back({vx+1, vy});\n        adjCells.push_back({vx, vy-1});\n        adjCells.push_back({vx, vy+1});\n        vector<pair<int,int>> possiblePositions;\n        for(auto p : adjCells){\n            if(p.first >= min_coord && p.first <= max_coord && p.second >= min_coord && p.second <= max_coord){\n                possiblePositions.push_back(p);\n            }\n        }\n        if(possiblePositions.empty()){\n            vx = min_coord;\n            vy = min_coord;\n            possiblePositions.push_back({vx+1, vy});\n        }\n        int idx = rnd.next(0, (int)possiblePositions.size() - 1);\n        sx = possiblePositions[idx].first;\n        sy = possiblePositions[idx].second;\n        m = 0;\n    }\n    else if (type == \"far_start\"){\n        // Princess and Shadow are at maximum distance\n        vx = min_coord;\n        vy = min_coord;\n        sx = max_coord;\n        sy = max_coord;\n        m = 0;\n    }\n    else if (type == \"random\"){\n        // Random test case\n        m = opt<int>(\"m\", rnd.next(0, 400));\n        \n        set<pair<int,int>> positions;\n        vx = rnd.next(min_coord, max_coord);\n        vy = rnd.next(min_coord, max_coord);\n        positions.insert({vx, vy});\n        do {\n            sx = rnd.next(min_coord, max_coord);\n            sy = rnd.next(min_coord, max_coord);\n        } while(positions.count({sx, sy}));\n        positions.insert({sx, sy});\n        \n        while(positions.size() < m + 2){\n            int tx = rnd.next(min_coord, max_coord);\n            int ty = rnd.next(min_coord, max_coord);\n            positions.insert({tx, ty});\n        }\n        positions.erase({vx, vy});\n        positions.erase({sx, sy});\n        for(auto p : positions){\n            trees.push_back(p);\n        }\n    }\n    else {\n        // Unknown type\n        fprintf(stderr, \"Unknown type: %s\\n\", type.c_str());\n        exit(1);\n    }\n    \n    // Output the test case\n    printf(\"%d %d %d %d %d\\n\", vx, vy, sx, sy, m);\n    for(int i = 0; i < m; ++i){\n        printf(\"%d %d\\n\", trees[i].first, trees[i].second);\n    }\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -type no_trees\n./gen -type max_trees\n\n./gen -type possible\n./gen -type possible\n./gen -type possible\n\n./gen -type impossible\n./gen -type impossible\n./gen -type impossible\n\n./gen -type shadow_isolation\n./gen -type shadow_isolation\n\n./gen -type princess_isolation\n./gen -type princess_isolation\n\n./gen -type close_start\n./gen -type close_start\n\n./gen -type far_start\n./gen -type far_start\n\n./gen -type random\n./gen -type random\n./gen -type random\n\n./gen -type random -m 0\n./gen -type random -m 400\n\n./gen -type random -min_coord -100 -max_coord -50\n./gen -type random -min_coord -50 -max_coord 0\n./gen -type random -min_coord 0 -max_coord 50\n./gen -type random -min_coord 50 -max_coord 100\n\n./gen -type random -m 200\n./gen -type random -m 100\n./gen -type random -m 50\n\n./gen -type impossible\n./gen -type impossible\n./gen -type impossible\n\n./gen -type princess_isolation\n./gen -type princess_isolation\n\n./gen -type shadow_isolation\n./gen -type shadow_isolation\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:07:18.659833",
        "total_tutorials": 3,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "318/A",
      "title": "A. Чет и нечет",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест1 секунда",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеВ единственной строчке через пробел записаны целые числа n и k (1 ≤ k ≤ n ≤ 1012).Пожалуйста, не используйте спецификатор %lld для чтения или записи 64-х битных чисел на С++. Рекомендуется использовать потоки cin, cout или спецификатор %I64d).",
      "output_spec": "Выходные данныеВыведите число, которое окажется на позиции с номером k в тетрадке Володи.",
      "sample_tests": "ПримерыВходные данныеСкопировать10 3Выходные данныеСкопировать5Входные данныеСкопировать7 7Выходные данныеСкопировать6",
      "description": "A. Чет и нечет\n\nограничение по времени на тест1 секунда\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвыводstdout\n\nВходные данныеВ единственной строчке через пробел записаны целые числа n и k (1 ≤ k ≤ n ≤ 1012).Пожалуйста, не используйте спецификатор %lld для чтения или записи 64-х битных чисел на С++. Рекомендуется использовать потоки cin, cout или спецификатор %I64d).\n\nВходные данные\n\nВыходные данныеВыведите число, которое окажется на позиции с номером k в тетрадке Володи.\n\nВыходные данные\n\nВходные данныеСкопировать10 3Выходные данныеСкопировать5Входные данныеСкопировать7 7Выходные данныеСкопировать6\n\nВходные данныеСкопировать10 3\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать5\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать7 7\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать6\n\nВыходные данныеСкопировать\n\nСкопировать\n\nПримечаниеВ первом примере Володя выпишет числа в порядке {1, 3, 5, 7, 9, 2, 4, 6, 8, 10}, поэтому на третьем месте в этой последовательности стоит число 5.",
      "solutions": [
        {
          "title": "Codeforces Round #188 - Codeforces",
          "content": "Добрый вечер, друзья!За обсуждением животрепещущей темы использования чужого кода в своих решениях можно и не заметить, что приближается зима 188 раунд платформы Codeforces!А ведь мы постарались подготовить для вас набор задач с любопытными (и, как нам хочется думать, не сильно сложными) идеями и понятными условиями.Мы — это авторы задач yaro и Rei, куратор раундов Codeforces Gerald и автор системы MikeMirzayanov. Отдельное спасибо Паше (PavelKunyavskiy) и Артему (RAD) за тестирование и дельные замечания.Последний раз, когда я участвовал в проведении соревнования на Codeforces, раунды еще носили статус \"beta\". Но чем меньше \"beta\", тем больше ответственность. В связи с этим желаю организаторам и авторам еще одного успешно проведенного раунда. Участникам же — нестандартных задач и идей, чистого кода (а также чистой клавиатуры) и побольше правильно сданных решений!Нам представляется непростой задачей оценить уровень сложности задач для всей массы участников, поэтому разбалловка будет динамическая. Все же ради любопытства сделаем следующее предположение об относительной сложности задач: div.1: B-B-C-C-E, div.2: A-B-C-C-E. Угадаем ли?UPD Приносим извинения за проблемы с очередью тестирования Codeforces.В любом случае, нам будет очень приятно, если вы оцените наш раунд (после его завершения): short survey.В упорной борьбе с отрывом в один взлом победителем div.1 стал meret (Jakub Pachocki)!Доступны результаты первого дивизиона, результаты второго дивизиона.Разбор.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/7862",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 1483
        },
        {
          "title": "Codeforces Round #188 (разбор) - Codeforces",
          "content": "Предварительная версия разбора.318A - Чет и нечетВ задаче про четные и нечетные числа требуется понять, как будет выглядеть последовательность чисел от 1 до n, если выписать сначала все нечетные числа, а затем — четные. Для того, чтобы определить, какое число стоит на k-м месте, нужно посчитать индекс в массиве, с которого начнутся четные числа, и вывести соответствующее k либо нечетное число из первой половины массива, либо четное из второй.318B - Энергетические строчкиВ задаче про хэви-метал требуется найти в строке S количество подстрок, начинающихся на одну строчку A и заканчивающихся другой строчкой B. Если мы пометим черным все позиции вхождения в S строки A, белым — позиции вхождения строки B, то получим следующую задачу: посчитать количество пар <черная позиция, белая позиция> (причем именно в таком порядке). Для этого достаточно бежать, к примеру, слева направо и хранить счетчик — количество уже пройденных черных позиций. Тогда если мы встречаем очередную черную позицию, то увеличиваем счетчик на один, если встречаем белую — добавляем к ответу количество пар с данной белой позицией. А это количество — и есть текущее значение счетчика.317A - Превосходная пара318C - Превосходная параКак легко понять эта задача была задачей на аккуратность. В ней труднее не придумать решение, а написать его так, чтобы ни один случай не был забыт.Каждый ход мы заменяем одно из чисел x, y на их сумму x + y и так пока пара чисел на доске не станет m-превосходной (то есть одно из чисел станет не меньше m). Ясно, что заменять на сумму нужно именно меньшее из двух чисел x и y. Действительно, будем говорить что пара чисел x1 ≤ y1 мажорирует пару чисел x2 ≤ y2, если y1 ≥ y2 и x1 ≥ y2. В этой ситуации, если за несколько наших действий из пары x2, y2 мы получим m-превосходную, то применяя те же самые действия к x1, y1 мы получим m-превосходную пару никак не позже. Если x ≤ y, то пара x + y, y мажорирует пару x + y, x. Поэтому путь через x + y, y до m-превосходной никак не длинее, и можно считать что мы выбираем именно эту пару. Теперь действия нашего игрока однозначны.Рассмотрим случаи: x ≤ 0, y ≤ 0 В этом случае наши операции не увеличивают числа на доске, поэтому пара может стать m-превосходной только если она изначально была m-превосходной. x > 0 или y > 0 В этом случае для любого m пара со временем станет m-превосходной. Для того чтобы посчитать точное количество шагов теперь достаточно запустить эмуляцию. Однако если при x > 0 и y > 0 легко видеть что пара <<растет экспоненциально>> (формальнее: лекго видеть что начиная со второго шага сумма x + y увеличивается хотя бы в 3 / 2 раза за каждый ход) и эмуляция работает очень быстро, то в случае x < 0 и y > 0 (или наоборот) числа в паре могут изменяться очень медленно. Особенно хорошо это видно на примере x =  - 1018, y = 1. Поэтому в таком случае необходимо отдельно посчитать количество шагов до момента, когда оба числа станут неотрицательными и только потом запускать эмуляцию. Для x < 0 и y > 0 такое количество шагов равно . 317B - Муравьи318D - МуравьиЗадачу можно представлять себе следующим образом. В вершинах двумерной решетки расставлены неотрицательные целые числа A(x, y). Считаем, что они заданы функцией . В каждый момент времени для каждой вершины P = (x, y) с числом A(x, y) ≥ 4 применяется операция φP, которая уменьшает A(x, y) на 4 и увеличивает A(x, y - 1), A(x, y + 1), A(x - 1, y), A(x + 1, y) на 1. Можно считать, что операция φP применяется ко всей функции A. От нас требуется найти эту функцию в запрашиваемых узлах после того как итерации прекратятся.Ключевое наблюдение для большинства решений состояло в том, что операции φP и φQ для всех точек P и Q коммутируют, то есть φP(φQ(A)) = φQ(φP(A)). Поэтому неважно в каком именно порядке применять операции. В частности, можно считать, что из данной вершины разбегаются сразу все возможные четверки муравьев. Теперь можно запустить прямую эмуляцию процесса в таком виде. В качестве упражнения участникам предлагается проверить, что муравьи никогда не покинут квадрат 200 × 200 с центром в 0 при указанных ограничениях.317C - Баланс318E - БалансВ задаче про сосуды и воду требовалось найти последовательность из порядка n2 переливаний, которая переводит начальную конфигурацию в конечную. Во-первых, утверждается следующее: если в каждой компоненте связности сумма исходных значений и сумма итоговых совпадают, то ответ существует. Назовем сосуд готовым, если текущее и требуемое количество воды в нем совпадают. Опишем сначала решение, которое, вероятно, проще всего пишется. Будем делать сосуды готовыми по очереди. Возьмем произвольную пару еще не готовых сосудов s и t (в s сейчас воды больше, чем нужно, в t — меньше, чем нужно), такую, что их соединяет некоторый простой путь P, при этом если перелить из s в t d литров, то один из сосудов станет готовым. Осталось научиться переливать d литров по пути из s в t. Напишем для этого рекурсивную функцию pour(s, t, d). Пусть t' идет перед t в этом пути, тогда функцию выполнит следующее: перельет из t' сколько возможно (разумеется, не больше d) в t, вызовет pour(s, t', d) и затем перельет из t' в t то, что осталось. Несложно проверить, что никакой сосуд при этом не переполнится. Такой алгоритм производит переливание по пути длины len за 2len элементарных переливаний, в итоге решение делает не более 2n2 операций.317D - Игра со степенямиДавайте для каждого числа x обозначим последовательность его степеней не вылезающих за границы [1..n] через Pow(x): Тогда наша игра состоит в следующем: каждый игрок на очередном шаге выбирает еще не зачеркнутое число x от 1 до n и зачеркивает все числа из Pow(x). Проигрывает не имеющий хода.Легко заметить, что такая игра распадается в сумму нескольких более простых игр. Действительно, назовем число x примитивным (и соответствующую последовательность Pow(x) примитивной), если оно не является степенью никакого числа y < x. Тогда: 1. для любого числа найдется примитивное число x, такое что ; 2. для любых различных примитивных чисел x и y множества Pow(x) и P(y) не пересекаются. Действительно для данного числа k существует ровно одно примитивное x степенью которого k является. Это, например, следует из основной теоремы арифметики: если и d = gcd(α1, α2, ..., αn), то .Таким образом все множество [1..n] разбивается на маленькие примитивные подмножества Pow(x), игра на которых происходит независимо. Наша игра распалась в сумму меньших игр. Теперь необходимо применить теорию Шпрага-Гранди и заметить, что мекс-функция нашей игры является ксором мекс-функций всех игр на примитивных Pow(x). Среди таких игр много совпадающих, что позволит легко вычислить ксор.Для конкретного x, если Pow(x) = {x, x2, ..., xs}, то мекс-функция зависит только от s, но не от самого x. В наших ограничениях s принимает значения от 1 до 29, мекс-функции для всех таких s можно предподсчитать напрямую. Осталось теперь лишь найти количество q(s) примитивных x с данной длиной Pow(x) равной s (более точно нас интересует не количество, а лишь четность этого количества).Ограничения задачи позволяют сделать это \"в лоб\": увеличиваем x от 2 до , если оно не зачеркнуто, находим длину Pow(x) [увеличиваем соответствующее q(s)], и зачеркиваем все числа из Pow(x). Этот цикл найдет все примитивные последовательности длины хотя бы 2. Количество незачеркнутых чисел даст все примитивные последовательности длины 1. Останется лишь посмотреть на их четности и посчитать соответсвующий ксор мексов.Однако можно найти все q(s) и за . Действительно, давайте посмотрим какое-нибудь число и последовательность {x, x2, x3, x4, ..., xs}. Она не является примитивной, только если содержится как подмножество в некоторой большей примитивной последовательности. Количество таких подпоследовательностей длины s в данной примитивной последовательности длины t > s легко найти, действительно это [t / s]. Вспоминая теперь, что притимвные последовательности не пересекаются получаем реккуретную формулу. Используя ее, легко найти все q(s) начиная с q(29) и заканчивая q(1).Замечание: при написании задачи важно не забыть учесть примитивное x = 1.317E - Принцесса и ее теньВ задаче про принцессу Владу требовалось всего-навсего поймать тень. Опишем идею решения. Если на плоскости растет всего одно дерево, то, используя его как преграду для тени, несложно найти подходящую последовательность ходов. Аналогично поступим (использовав какое-либо крайнее дерево), если Влада и Тень находятся далеко, вне квадрата, где могут расти деревья. Осталось понять, что же делать в самой чаще леса! Если между Владой и ее тенью вообще не существует пути, то поймать тень никак не удастся. Иначе рассмотрим кратчайший путь от принцессы до тени, и пойдем принцессой по нему. Будет считать, что этот путь задает нам очередь шагов, которые необходимо сделать. При этом если тень передвигается куда-либо, то добавим ее ход в очередь (иначе говоря, мы идем по пути, состоящему из кратчайшего пути до тени в начальный момент времени и последующих передвижений тени). Алгоритмическая часть на этом закончилась: утверждается, что мы за необходимое число шагов либо поймаем тень, либо выйдем из \"лесного квадрата\". Доказательство опирается на следующую идею: длина пути, по которому мы идем до тени, разве что уменьшается. При этом если она не уменьшается достаточно долго, то раз в k шагов (k — длина пути) происходит смещение на один и тот же ненулевой вектор, следовательно, мы выйдем из \"лесного квадрата\". Стоит отметить, что если наши герои не заперты в лабиринт (могут выйти из \"лесного квадрата\"), то можно вывести их из квадрата по очереди. Но в таком случае для лабиринта все равно придется придумывать способ ловить тень.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/7956",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 318\\s*A"
          },
          "content_length": 9624
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #188 - Codeforces - Code 1",
          "code": "for (int i = 23;i < 30;i++) {\n        ans[i] = 1;\n    }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7862",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #188 - Codeforces - Code 2",
          "code": "for (int i = 23;i < 30;i++) {\n        ans[i] = 1;\n    }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7862",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #188 - Codeforces - Code 3",
          "code": "-1000000000000000000 1 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7862",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #188 - Codeforces - Code 4",
          "code": "...\nlong long x,y,m;\nlong long res;\n...\nint mymx = max(x,y); // int ???\nint mymn = min(x,y); // int ???\n\nx = mymx;\ny = mymn;\n...",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7862",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #188 - Codeforces - Code 5",
          "code": "...\nlong long x,y,m;\nlong long res;\n...\nint mymx = max(x,y); // int ???\nint mymn = min(x,y); // int ???\n\nx = mymx;\ny = mymn;\n...",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7862",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #188 - Codeforces - Code 6",
          "code": "s.size() < 4",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7862",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #188 - Codeforces - Code 7",
          "code": "s.size() - 4",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7862",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #188 - Codeforces - Code 8",
          "code": "#define SZ(x) (int)x.size()",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7862",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #188 - Codeforces - Code 9",
          "code": "Contest rating",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7862",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #188 - Codeforces - Code 10",
          "code": "Взлом не использует генератор\ncom.codeforces.contester.exception.ChallengeIgnoredException: Challenge is ignored because of the challenged submit is not the last accepted now [submissionId=3887152].\ncom.codeforces.contester.processor.impl.ChallengeProcessor.internalProcess(ChallengeProcessor.java:100)    com.codeforces.contester.processor.impl.ChallengeProcessor.process(ChallengeProcessor.java:63)\ncom.codeforces.contester.processor.impl.ChallengeProcessor.process(ChallengeProcessor.java:36)    com.codeforces.contester.processor.RunnableFactory$ProcessorRunnable.run(RunnableFactory.java:51)\ncom.codeforces.contester.ContesterServletRunnable$2.run(ContesterServletRunnable.java:169)\njava.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1110)\njava.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:603)\njava.lang.Thread.run(Thread.java:722)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7862",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #188 - Codeforces - Code 11",
          "code": "Взлом не использует генератор\ncom.codeforces.contester.exception.ChallengeIgnoredException: Challenge is ignored because of the challenged submit is not the last accepted now [submissionId=3887152].\ncom.codeforces.contester.processor.impl.ChallengeProcessor.internalProcess(ChallengeProcessor.java:100)    com.codeforces.contester.processor.impl.ChallengeProcessor.process(ChallengeProcessor.java:63)\ncom.codeforces.contester.processor.impl.ChallengeProcessor.process(ChallengeProcessor.java:36)    com.codeforces.contester.processor.RunnableFactory$ProcessorRunnable.run(RunnableFactory.java:51)\ncom.codeforces.contester.ContesterServletRunnable$2.run(ContesterServletRunnable.java:169)\njava.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1110)\njava.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:603)\njava.lang.Thread.run(Thread.java:722)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7862",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #188 - Codeforces - Code 12",
          "code": "challenged submit is not the last accepted now",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7862",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #188 (разбор) - Codeforces - Code 1",
          "code": "1 1\n1 2\n2 3\n3 5\n5 8\n8 13\n13 21",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7956",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #188 (разбор) - Codeforces - Code 2",
          "code": "1 1\n1 2\n2 3\n3 5\n5 8\n8 13\n13 21",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7956",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #188 (разбор) - Codeforces - Code 3",
          "code": "109 строка:    X = X ^ (((max(0, n - (SQ - 1))) % 2 == 1) ? get(1) : 0);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7956",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #188 (разбор) - Codeforces - Code 4",
          "code": "109 строка:    X = X ^ (((max(0, n - (SQ - 1))) % 2 == 1) ? get(1) : 0);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7956",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #188 (разбор) - Codeforces - Code 5",
          "code": "Thank you for the nice contest and editorial. \nIn \"Ants\" problem, Is there any way to expect the simulation will be converge so fast before we writing brute force code? how to make sure n = 30000 is the worst case?",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7956",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #188 (разбор) - Codeforces - Code 6",
          "code": "Thank you for the nice contest and editorial. \nIn \"Ants\" problem, Is there any way to expect the simulation will be converge so fast before we writing brute force code? how to make sure n = 30000 is the worst case?",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7956",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #188 (разбор) - Codeforces - Code 7",
          "code": "#include <string.h>\n#include <cstdio>\n#include <map>\nusing namespace std;\nmap<long long ,int>SG;\nint DFS(long long state) {\n    //printf(\"%I64d\\n\",state);getchar();getchar();\n    if(state==0) return 0;\n    if(SG[state]) return SG[state];\n    int len=0;long long tmp=state;\n    while(tmp>0) {\n        len++;\n        tmp>>=1;\n    }\n    bool cnt[100];memset(cnt,0,sizeof(cnt));\n    for(int i=1;i<=len;i++) {\n        long long k=(1<<(i-1)),tmp=state;\n        while(k<=tmp) {\n            tmp&=(((1<<(len+1))-1)^k);//printf(\"%lld\\n\",k);\n            k<<=i;\n\t\t}//printf(\"%lld\\n\",tmp);\n\t\tif(tmp==state) continue;\n        int ret=DFS(tmp);\n        cnt[ret]=1;\n    }\n    for(int i=0;;i++)if(!cnt[i]){\n        //printf(\"%d %d\\n\",len,i);\n        return (SG[state]=i);\n    }\n}\nint main()\n{\n    for(int I=1;I<=29;I++) {\n        printf(\"%d\\n\",DFS((long long )((1<<I)-1)));\n    }\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/7956",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #188 (разбор) - Codeforces - Code 8",
          "code": "#include <string.h>\n#include <cstdio>\n#include <map>\nusing namespace std;\nmap<long long ,int>SG;\nint DFS(long long state) {\n    //printf(\"%I64d\\n\",state);getchar();getchar();\n    if(state==0) return 0;\n    if(SG[state]) return SG[state];\n    int len=0;long long tmp=state;\n    while(tmp>0) {\n        len++;\n        tmp>>=1;\n    }\n    bool cnt[100];memset(cnt,0,sizeof(cnt));\n    for(int i=1;i<=len;i++) {\n        long long k=(1<<(i-1)),tmp=state;\n        while(k<=tmp) {\n            tmp&=(((1<<(len+1))-1)^k);//printf(\"%lld\\n\",k);\n            k<<=i;\n\t\t}//printf(\"%lld\\n\",tmp);\n\t\tif(tmp==state) continue;\n        int ret=DFS(tmp);\n        cnt[ret]=1;\n    }\n    for(int i=0;;i++)if(!cnt[i]){\n        //printf(\"%d %d\\n\",len,i);\n        return (SG[state]=i);\n    }\n}\nint main()\n{\n    for(int I=1;I<=29;I++) {\n        printf(\"%d\\n\",DFS((long long )((1<<I)-1)));\n    }\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/7956",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    long long n = inf.readLong(1LL, 1000000000000LL, \"n\");\n    inf.readSpace();\n    long long k = inf.readLong(1LL, 1000000000000LL, \"k\");\n    inf.readEoln();\n\n    ensuref(k <= n, \"k should be less than or equal to n, but k=%lld > n=%lld\", k, n);\n\n    inf.readEof();\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    long long n = inf.readLong(1LL, 1000000000000LL, \"n\");\n    inf.readSpace();\n    long long k = inf.readLong(1LL, 1000000000000LL, \"k\");\n    inf.readEoln();\n\n    ensuref(k <= n, \"k should be less than or equal to n, but k=%lld > n=%lld\", k, n);\n\n    inf.readEof();\n\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    long long n = inf.readLong(1LL, 1000000000000LL, \"n\");\n    inf.readSpace();\n    long long k = inf.readLong(1LL, 1000000000000LL, \"k\");\n    inf.readEoln();\n\n    ensuref(k <= n, \"k should be less than or equal to n, but k=%lld > n=%lld\", k, n);\n\n    inf.readEof();\n\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    long long n = opt<long long>(\"n\");\n    string kpos = opt<string>(\"kpos\", \"random\");\n\n    long long k;\n    if (kpos == \"first\") {\n        k = 1;\n    } else if (kpos == \"middle\") {\n        k = (n + 1) / 2;\n    } else if (kpos == \"last\") {\n        k = n;\n    } else if (kpos == \"last_odd\") {\n        long long cnt_odd = (n + 1) / 2;\n        k = cnt_odd;\n    } else if (kpos == \"first_even\") {\n        long long cnt_odd = (n + 1) / 2;\n        if (cnt_odd + 1 <= n) {\n            k = cnt_odd + 1;\n        } else {\n            k = n; // No even numbers, set to last position\n        }\n    } else if (kpos == \"random\") {\n        k = rnd.next(1LL, n);\n    } else {\n        // Invalid kpos, generate random k\n        k = rnd.next(1LL, n);\n    }\n\n    // Ensure k in range [1, n]\n    if (k < 1) k = 1;\n    if (k > n) k = n;\n\n    // Output n and k\n    printf(\"%lld %lld\\n\", n, k);\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    long long n = opt<long long>(\"n\");\n    string kpos = opt<string>(\"kpos\", \"random\");\n\n    long long k;\n    if (kpos == \"first\") {\n        k = 1;\n    } else if (kpos == \"middle\") {\n        k = (n + 1) / 2;\n    } else if (kpos == \"last\") {\n        k = n;\n    } else if (kpos == \"last_odd\") {\n        long long cnt_odd = (n + 1) / 2;\n        k = cnt_odd;\n    } else if (kpos == \"first_even\") {\n        long long cnt_odd = (n + 1) / 2;\n        if (cnt_odd + 1 <= n) {\n            k = cnt_odd + 1;\n        } else {\n            k = n; // No even numbers, set to last position\n        }\n    } else if (kpos == \"random\") {\n        k = rnd.next(1LL, n);\n    } else {\n        // Invalid kpos, generate random k\n        k = rnd.next(1LL, n);\n    }\n\n    // Ensure k in range [1, n]\n    if (k < 1) k = 1;\n    if (k > n) k = n;\n\n    // Output n and k\n    printf(\"%lld %lld\\n\", n, k);\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Test case 1: Minimal n, minimal k\n./gen -n 1 -kpos first\n\n# Test case 2: Minimal n, maximal k\n./gen -n 1 -kpos last\n\n# Test case 3: Small n, k in the middle\n./gen -n 2 -kpos middle\n\n# Test case 4: Small n, k is first\n./gen -n 5 -kpos first\n\n# Test case 5: Small n, k is last\n./gen -n 5 -kpos last\n\n# Test case 6: Small n, k is last_odd (test the last odd position)\n./gen -n 5 -kpos last_odd\n\n# Test case 7: Small n, k is first_even (test the first even position)\n./gen -n 5 -kpos first_even\n\n# Test case 8: Medium n, k is random\n./gen -n 1000 -kpos random\n\n# Test case 9: Medium n, k is middle\n./gen -n 1000 -kpos middle\n\n# Test case 10: Medium n, k is last_odd\n./gen -n 1000 -kpos last_odd\n\n# Test case 11: Medium n, k is first_even\n./gen -n 1000 -kpos first_even\n\n# Test case 12: Large n, k is first\n./gen -n 1000000 -kpos first\n\n# Test case 13: Large n, k is last\n./gen -n 1000000 -kpos last\n\n# Test case 14: Large n, k is middle\n./gen -n 1000000 -kpos middle\n\n# Test case 15: Large n, k is random\n./gen -n 1000000 -kpos random\n\n# Test case 16: Large n, k is last_odd\n./gen -n 1000000 -kpos last_odd\n\n# Test case 17: Large n, k is first_even\n./gen -n 1000000 -kpos first_even\n\n# Test case 18: Max n, k is first\n./gen -n 1000000000000 -kpos first\n\n# Test case 19: Max n, k is last\n./gen -n 1000000000000 -kpos last\n\n# Test case 20: Max n, k is middle\n./gen -n 1000000000000 -kpos middle\n\n# Test case 21: Max n, k is random\n./gen -n 1000000000000 -kpos random\n\n# Test case 22: Max n, k is last_odd\n./gen -n 1000000000000 -kpos last_odd\n\n# Test case 23: Max n, k is first_even\n./gen -n 1000000000000 -kpos first_even\n\n# Test case 24: n is maximum odd number less than max_n, k is random\n./gen -n 999999999999 -kpos random\n\n# Test case 25: n is maximum even number less than max_n, k is last_odd\n./gen -n 999999999998 -kpos last_odd\n\n# Test case 26: n is large prime number, k is random\n./gen -n 999999937 -kpos random\n\n# Test case 27: Random n in large range, k is random\n./gen -n 123456789012 -kpos random\n\n# Test case 28: Small n, k is random\n./gen -n 1234 -kpos random\n\n# Test case 29: n is large, k is first_even\n./gen -n 1000000000000 -kpos first_even\n\n# Test case 30: n is small, k is first_even (to test when n is odd and even)\n./gen -n 6 -kpos first_even\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:07:20.812785",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "318/B",
      "title": "B. Энергетические строчки",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест2 секунды",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеВо входных данных содержится единственная непустая строка, состоящая только из строчных букв латинского алфавита. Длина строки не превышает 106 символов.",
      "output_spec": "Выходные данныеВыведите единственное число — количество энергетических подстрок в данной строке.Пожалуйста, не используйте спецификатор %lld для чтения или записи 64-х битных чисел на С++. Рекомендуется использовать потоки cin, cout или спецификатор %I64d).",
      "sample_tests": "ПримерыВходные данныеСкопироватьheavymetalisheavymetalВыходные данныеСкопировать3Входные данныеСкопироватьheavymetalismetalВыходные данныеСкопировать2Входные данныеСкопироватьtrueheavymetalissotruewellitisalsosoheavythatyoucanalmostfeeltheweightofmetalonyouВыходные данныеСкопировать3",
      "description": "B. Энергетические строчки\n\nограничение по времени на тест2 секунды\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвыводstdout\n\nВходные данныеВо входных данных содержится единственная непустая строка, состоящая только из строчных букв латинского алфавита. Длина строки не превышает 106 символов.\n\nВходные данные\n\nВыходные данныеВыведите единственное число — количество энергетических подстрок в данной строке.Пожалуйста, не используйте спецификатор %lld для чтения или записи 64-х битных чисел на С++. Рекомендуется использовать потоки cin, cout или спецификатор %I64d).\n\nВыходные данные\n\nВходные данныеСкопироватьheavymetalisheavymetalВыходные данныеСкопировать3Входные данныеСкопироватьheavymetalismetalВыходные данныеСкопировать2Входные данныеСкопироватьtrueheavymetalissotruewellitisalsosoheavythatyoucanalmostfeeltheweightofmetalonyouВыходные данныеСкопировать3\n\nВходные данныеСкопироватьheavymetalisheavymetal\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать3\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопироватьheavymetalismetal\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать2\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопироватьtrueheavymetalissotruewellitisalsosoheavythatyoucanalmostfeeltheweightofmetalonyou\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать3\n\nВыходные данныеСкопировать\n\nСкопировать\n\nПримечаниеВ первом примере в строке «heavymetalisheavymetal» дважды встречается энергетическая подстрока «heavymetal», кроме того, вся строка «heavymetalisheavymetal» является энергетической.Во втором примере в строке «heavymetalismetal» есть две энергетические подстрочки: «heavymetal» и «heavymetalismetal».",
      "solutions": [
        {
          "title": "Codeforces Round #188 - Codeforces",
          "content": "Добрый вечер, друзья!За обсуждением животрепещущей темы использования чужого кода в своих решениях можно и не заметить, что приближается зима 188 раунд платформы Codeforces!А ведь мы постарались подготовить для вас набор задач с любопытными (и, как нам хочется думать, не сильно сложными) идеями и понятными условиями.Мы — это авторы задач yaro и Rei, куратор раундов Codeforces Gerald и автор системы MikeMirzayanov. Отдельное спасибо Паше (PavelKunyavskiy) и Артему (RAD) за тестирование и дельные замечания.Последний раз, когда я участвовал в проведении соревнования на Codeforces, раунды еще носили статус \"beta\". Но чем меньше \"beta\", тем больше ответственность. В связи с этим желаю организаторам и авторам еще одного успешно проведенного раунда. Участникам же — нестандартных задач и идей, чистого кода (а также чистой клавиатуры) и побольше правильно сданных решений!Нам представляется непростой задачей оценить уровень сложности задач для всей массы участников, поэтому разбалловка будет динамическая. Все же ради любопытства сделаем следующее предположение об относительной сложности задач: div.1: B-B-C-C-E, div.2: A-B-C-C-E. Угадаем ли?UPD Приносим извинения за проблемы с очередью тестирования Codeforces.В любом случае, нам будет очень приятно, если вы оцените наш раунд (после его завершения): short survey.В упорной борьбе с отрывом в один взлом победителем div.1 стал meret (Jakub Pachocki)!Доступны результаты первого дивизиона, результаты второго дивизиона.Разбор.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/7862",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 1483
        },
        {
          "title": "Codeforces",
          "content": "Codeforces is temporarily unavailable\n\n Possibly the server is too busy, something has gone wrong or it is server maintenance. Anyway try again in a few\n moments.\n\n Codeforces временно недоступен\n\n Возможно, сервер слишком занят обработкой запросов, возникла какая-то нештатная ситуация или просто ведутся\n профилактические работы.\n В любом случае, попробуйте повторить запрос через некоторое время.",
          "author": "Unknown",
          "url": "https://codeforces.com/blog/entry/7956",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 399
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #188 - Codeforces - Code 1",
          "code": "for (int i = 23;i < 30;i++) {\n        ans[i] = 1;\n    }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7862",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #188 - Codeforces - Code 2",
          "code": "for (int i = 23;i < 30;i++) {\n        ans[i] = 1;\n    }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7862",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #188 - Codeforces - Code 3",
          "code": "-1000000000000000000 1 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7862",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #188 - Codeforces - Code 4",
          "code": "...\nlong long x,y,m;\nlong long res;\n...\nint mymx = max(x,y); // int ???\nint mymn = min(x,y); // int ???\n\nx = mymx;\ny = mymn;\n...",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7862",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #188 - Codeforces - Code 5",
          "code": "...\nlong long x,y,m;\nlong long res;\n...\nint mymx = max(x,y); // int ???\nint mymn = min(x,y); // int ???\n\nx = mymx;\ny = mymn;\n...",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7862",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #188 - Codeforces - Code 6",
          "code": "s.size() < 4",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7862",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #188 - Codeforces - Code 7",
          "code": "s.size() - 4",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7862",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #188 - Codeforces - Code 8",
          "code": "#define SZ(x) (int)x.size()",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7862",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #188 - Codeforces - Code 9",
          "code": "Contest rating",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7862",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #188 - Codeforces - Code 10",
          "code": "Взлом не использует генератор\ncom.codeforces.contester.exception.ChallengeIgnoredException: Challenge is ignored because of the challenged submit is not the last accepted now [submissionId=3887152].\ncom.codeforces.contester.processor.impl.ChallengeProcessor.internalProcess(ChallengeProcessor.java:100)    com.codeforces.contester.processor.impl.ChallengeProcessor.process(ChallengeProcessor.java:63)\ncom.codeforces.contester.processor.impl.ChallengeProcessor.process(ChallengeProcessor.java:36)    com.codeforces.contester.processor.RunnableFactory$ProcessorRunnable.run(RunnableFactory.java:51)\ncom.codeforces.contester.ContesterServletRunnable$2.run(ContesterServletRunnable.java:169)\njava.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1110)\njava.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:603)\njava.lang.Thread.run(Thread.java:722)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7862",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #188 - Codeforces - Code 11",
          "code": "Взлом не использует генератор\ncom.codeforces.contester.exception.ChallengeIgnoredException: Challenge is ignored because of the challenged submit is not the last accepted now [submissionId=3887152].\ncom.codeforces.contester.processor.impl.ChallengeProcessor.internalProcess(ChallengeProcessor.java:100)    com.codeforces.contester.processor.impl.ChallengeProcessor.process(ChallengeProcessor.java:63)\ncom.codeforces.contester.processor.impl.ChallengeProcessor.process(ChallengeProcessor.java:36)    com.codeforces.contester.processor.RunnableFactory$ProcessorRunnable.run(RunnableFactory.java:51)\ncom.codeforces.contester.ContesterServletRunnable$2.run(ContesterServletRunnable.java:169)\njava.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1110)\njava.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:603)\njava.lang.Thread.run(Thread.java:722)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7862",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #188 - Codeforces - Code 12",
          "code": "challenged submit is not the last accepted now",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7862",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    string s = inf.readLine(\"[a-z]+\", \"s\");\n    ensuref((int)s.size() <= 1000000, \"Length of s should not exceed 1,000,000, but is %d\", (int)s.size());\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    string s = inf.readLine(\"[a-z]+\", \"s\");\n    ensuref((int)s.size() <= 1000000, \"Length of s should not exceed 1,000,000, but is %d\", (int)s.size());\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    string s = inf.readLine(\"[a-z]+\", \"s\");\n    ensuref((int)s.size() <= 1000000, \"Length of s should not exceed 1,000,000, but is %d\", (int)s.size());\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n    \n    string s = \"\";\n\n    if (type == \"random\") {\n        // Generate random lowercase letters\n        s = \"\";\n        for (int i = 0; i < n; ++i)\n            s += (char)('a' + rnd.next(26));\n    }\n    else if (type == \"heavy_only\") {\n        // Generate as many \"heavy\" as possible\n        int times = n / 5;\n        for (int i = 0; i < times; ++i)\n            s += \"heavy\";\n        // Pad remaining letters if any\n        int remaining = n - times * 5;\n        for (int i = 0; i < remaining; ++i)\n            s += (char)('a' + rnd.next(26));\n    }\n    else if (type == \"metal_only\") {\n        // Generate as many \"metal\" as possible\n        int times = n / 5;\n        for (int i = 0; i < times; ++i)\n            s += \"metal\";\n        // Pad remaining letters if any\n        int remaining = n - times * 5;\n        for (int i = 0; i < remaining; ++i)\n            s += (char)('a' + rnd.next(26));\n    }\n    else if (type == \"alternating\") {\n        // Alternate \"heavy\" and \"metal\"\n        int times = n / 10;\n        for (int i = 0; i < times; ++i) {\n            s += \"heavy\";\n            s += \"metal\";\n        }\n        int remaining = n - times * 10;\n        if (remaining >= 5) {\n            s += \"heavy\";\n            remaining -= 5;\n        }\n        if (remaining >= 5) {\n            s += \"metal\";\n            remaining -= 5;\n        }\n        // Pad remaining letters\n        for (int i = 0; i < remaining; ++i)\n            s += (char)('a' + rnd.next(26));\n    }\n    else if (type == \"max_powerful\") {\n        // Maximize the number of powerful substrings\n        int h = n / 10;\n        int m = h;\n        int total_length = h * 5 + m * 5;\n        if (total_length > n) {\n            h--;\n            m--;\n            total_length = h * 5 + m * 5;\n        }\n        s = \"\";\n        for (int i = 0; i < h; ++i)\n            s += \"heavy\";\n        for (int i = 0; i < m; ++i)\n            s += \"metal\";\n        // Pad the rest with random letters\n        int remaining = n - total_length;\n        for (int i = 0; i < remaining; ++i)\n            s += (char)('a' + rnd.next(26));\n    }\n    else if (type == \"no_heavy_metal\") {\n        // Generate a string without \"heavy\" or \"metal\"\n        string letters = \"bcdfgijknopqrsuvwxyz\";\n        for (int i = 0; i < n; ++i)\n            s += letters[rnd.next(letters.size())];\n    }\n    else if (type == \"metal_before_heavy\") {\n        // \"metal\" occurs before \"heavy\"\n        int h = n / 10;\n        int m = h;\n        int total_length = m * 5 + h * 5;\n        if (total_length > n) {\n            m--;\n            h--;\n            total_length = m * 5 + h * 5;\n        }\n        s = \"\";\n        for (int i = 0; i < m; ++i)\n            s += \"metal\";\n        for (int i = 0; i < h; ++i)\n            s += \"heavy\";\n        // Pad the rest with random letters\n        int remaining = n - total_length;\n        for (int i = 0; i < remaining; ++i)\n            s += (char)('a' + rnd.next(26));\n    }\n    else if (type == \"interleaved\") {\n        // Letters from \"heavy\" and \"metal\" interleaved randomly\n        string letters = \"heavymetal\";\n        while ((int)s.size() < n) {\n            s += letters[rnd.next(letters.size())];\n        }\n        s = s.substr(0, n);\n    }\n    else {\n        // Default to random\n        s = \"\";\n        for (int i = 0; i < n; ++i)\n            s += (char)('a' + rnd.next(26));\n    }\n\n    // Output the generated string\n    cout << s << endl;\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n    \n    string s = \"\";\n\n    if (type == \"random\") {\n        // Generate random lowercase letters\n        s = \"\";\n        for (int i = 0; i < n; ++i)\n            s += (char)('a' + rnd.next(26));\n    }\n    else if (type == \"heavy_only\") {\n        // Generate as many \"heavy\" as possible\n        int times = n / 5;\n        for (int i = 0; i < times; ++i)\n            s += \"heavy\";\n        // Pad remaining letters if any\n        int remaining = n - times * 5;\n        for (int i = 0; i < remaining; ++i)\n            s += (char)('a' + rnd.next(26));\n    }\n    else if (type == \"metal_only\") {\n        // Generate as many \"metal\" as possible\n        int times = n / 5;\n        for (int i = 0; i < times; ++i)\n            s += \"metal\";\n        // Pad remaining letters if any\n        int remaining = n - times * 5;\n        for (int i = 0; i < remaining; ++i)\n            s += (char)('a' + rnd.next(26));\n    }\n    else if (type == \"alternating\") {\n        // Alternate \"heavy\" and \"metal\"\n        int times = n / 10;\n        for (int i = 0; i < times; ++i) {\n            s += \"heavy\";\n            s += \"metal\";\n        }\n        int remaining = n - times * 10;\n        if (remaining >= 5) {\n            s += \"heavy\";\n            remaining -= 5;\n        }\n        if (remaining >= 5) {\n            s += \"metal\";\n            remaining -= 5;\n        }\n        // Pad remaining letters\n        for (int i = 0; i < remaining; ++i)\n            s += (char)('a' + rnd.next(26));\n    }\n    else if (type == \"max_powerful\") {\n        // Maximize the number of powerful substrings\n        int h = n / 10;\n        int m = h;\n        int total_length = h * 5 + m * 5;\n        if (total_length > n) {\n            h--;\n            m--;\n            total_length = h * 5 + m * 5;\n        }\n        s = \"\";\n        for (int i = 0; i < h; ++i)\n            s += \"heavy\";\n        for (int i = 0; i < m; ++i)\n            s += \"metal\";\n        // Pad the rest with random letters\n        int remaining = n - total_length;\n        for (int i = 0; i < remaining; ++i)\n            s += (char)('a' + rnd.next(26));\n    }\n    else if (type == \"no_heavy_metal\") {\n        // Generate a string without \"heavy\" or \"metal\"\n        string letters = \"bcdfgijknopqrsuvwxyz\";\n        for (int i = 0; i < n; ++i)\n            s += letters[rnd.next(letters.size())];\n    }\n    else if (type == \"metal_before_heavy\") {\n        // \"metal\" occurs before \"heavy\"\n        int h = n / 10;\n        int m = h;\n        int total_length = m * 5 + h * 5;\n        if (total_length > n) {\n            m--;\n            h--;\n            total_length = m * 5 + h * 5;\n        }\n        s = \"\";\n        for (int i = 0; i < m; ++i)\n            s += \"metal\";\n        for (int i = 0; i < h; ++i)\n            s += \"heavy\";\n        // Pad the rest with random letters\n        int remaining = n - total_length;\n        for (int i = 0; i < remaining; ++i)\n            s += (char)('a' + rnd.next(26));\n    }\n    else if (type == \"interleaved\") {\n        // Letters from \"heavy\" and \"metal\" interleaved randomly\n        string letters = \"heavymetal\";\n        while ((int)s.size() < n) {\n            s += letters[rnd.next(letters.size())];\n        }\n        s = s.substr(0, n);\n    }\n    else {\n        // Default to random\n        s = \"\";\n        for (int i = 0; i < n; ++i)\n            s += (char)('a' + rnd.next(26));\n    }\n\n    // Output the generated string\n    cout << s << endl;\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -type random\n./gen -n 5 -type random\n./gen -n 10 -type random\n./gen -n 10 -type heavy_only\n./gen -n 10 -type metal_only\n./gen -n 10 -type alternating\n./gen -n 10 -type max_powerful\n./gen -n 10 -type no_heavy_metal\n./gen -n 10 -type metal_before_heavy\n./gen -n 10 -type interleaved\n./gen -n 100 -type random\n./gen -n 100 -type max_powerful\n./gen -n 100 -type no_heavy_metal\n./gen -n 100 -type metal_before_heavy\n./gen -n 1000 -type random\n./gen -n 1000 -type max_powerful\n./gen -n 1000 -type no_heavy_metal\n./gen -n 1000 -type metal_before_heavy\n./gen -n 1000000 -type random\n./gen -n 1000000 -type heavy_only\n./gen -n 1000000 -type metal_only\n./gen -n 1000000 -type alternating\n./gen -n 1000000 -type max_powerful\n./gen -n 1000000 -type no_heavy_metal\n./gen -n 1000000 -type metal_before_heavy\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:07:22.970946",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "318/C",
      "title": "C. Perfect Pair",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputSingle line of the input contains three integers x, y and m ( - 1018 ≤ x, y, m ≤ 1018).Please, do not use the %lld specifier to read or write 64-bit integers in C++. It is preffered to use the cin, cout streams or the %I64d specifier.",
      "output_spec": "OutputPrint the minimum number of operations or \"-1\" (without quotes), if it is impossible to transform the given pair to the m-perfect one.",
      "sample_tests": "ExamplesInputCopy1 2 5OutputCopy2InputCopy-1 4 15OutputCopy4InputCopy0 -1 5OutputCopy-1",
      "description": "C. Perfect Pair\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputSingle line of the input contains three integers x, y and m ( - 1018 ≤ x, y, m ≤ 1018).Please, do not use the %lld specifier to read or write 64-bit integers in C++. It is preffered to use the cin, cout streams or the %I64d specifier.\n\nOutputPrint the minimum number of operations or \"-1\" (without quotes), if it is impossible to transform the given pair to the m-perfect one.\n\nInputCopy1 2 5OutputCopy2InputCopy-1 4 15OutputCopy4InputCopy0 -1 5OutputCopy-1\n\nInputCopy1 2 5\n\nOutputCopy2\n\nInputCopy-1 4 15\n\nOutputCopy4\n\nInputCopy0 -1 5\n\nOutputCopy-1\n\nNoteIn the first sample the following sequence of operations is suitable: (1, 2)  (3, 2)  (5, 2).In the second sample: (-1, 4)  (3, 4)  (7, 4)  (11, 4)  (15, 4).Finally, in the third sample x, y cannot be made positive, hence there is no proper sequence of operations.",
      "solutions": [
        {
          "title": "Codeforces Round #188 - Codeforces",
          "content": "Hello, friends! Winter 188th Codeforces Round is coming!We wished to prepare for you some enjoyable problems (as we believe, not very difficult) with nice ideas and clear statements.\"We\" includes authors of the problems yaro and Rei, Codeforces Rounds supervisor Gerald and the platform founder MikeMirzayanov. Special thanks to Pasha (PavelKunyavskiy) and Artem (RAD) for the testing and helpful comments.Last time I was preparing a competition here on Codeforces, Rounds were still \"beta\". Well, with less \"beta\" comes greater responsibility. So I wish the authors and the organizers a successfully held Round. As for the participants, I wish you the unconventional ideas, the clean code (and a clean keyboard, of course), and satisfaction from five (well, possibly the less number will also do...) correct and accepted solutions!It seems to us that it is not an easy job to arrange the problems by their difficulty, so we have chosen the dynamic scores. Still (out of curiousity) let us put a bet on the following relative difficulties for the problems: div.1 — B-B-C-C-E, div.2 — A-B-C-C-E. How close is our guess?UPD Sorry for the problems with the Codeforces testing queue during the round.We will still be happy if you rate our contest (when it will be over): short survey.And with the gap of one hack the winner of div.1 is meret (Jakub Pachocki)!Div.1 standings, Div.2 standings.Analysis (thanks to Rei for the translation).",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/7862",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1433
        },
        {
          "title": "Codeforces Round #188 (analysis) - Codeforces",
          "content": "Problem analysis v 0.9.318A - Even OddsIn this problem we need to understand how exactly numbers from 1 to n rearrange when we write firstly all odd numbers and after them all even numbers. To find out which number stands at position k one needs to find the position where even numbers start and output either the position of the odd number from the first half of the sequence or for the even number from the second half of the sequence.318B - Strings of PowerIn the heavy metal problem one needs to find the number of the substrings in the string S with a given prefix A and given suffix B. If we mark black all the starting positions of the entries of the string A in S, and white all the starting positions of the entries of the string B, then we come to the following problem: count the number of pairs <black position, white position> (in this order). To solve this it is enough to iterate from left to right counting the number of the passed black positions. Meeting black position we increment this number by one, meeting white position we add to the answer the number of pairs with this white position, which is exactly our memorized number of the already passed black positions.317A - Perfect Pair318C - Perfect PairThis problem were more about accuracy then about ideas or coding. It is important to not forget any cases here.On each step we replace one of the numbers x, y by their sum x + y until the pair becomes m-perfect (id est one of them becomes not lesser than m). It is clear that one sould replace lesser number from the pair x, y. Indeed lets say the pair x1 ≤ y1 dominates the pair x2 ≤ y2, if y1 ≥ y2 and x1 ≥ y2. In this case if one can get m-perfect pair from x2, y2 by certain sequence of actions, then one can get m-perfect pair from x1, y1 by the same or shorter sequence of actions. If x ≤ y, then the pair x + y, y dominates the pair x + y, x. Hence path from x + y, y to m-perfect is not longer than from x + y, x, and we may assume that we choose exactly this pair.Consider following cases: x ≤ 0, y ≤ 0 In this case our numbers do not increase in the process. Hence either the pair is alredy m-perfect or it will never be. x > 0 and y > 0 In this case for each m pair will after several steps become m-perfect. To count precise number of those steps one needs to launch emulation. If x > 0 and y > 0, then pair \"grows exponentionaly>> (more formally: easy to show that starting from secnd step sum x + y grows in at least 3 / 2 times each step) and emulation works pretty fast. However in the case x < 0 and y > 0 (or vice versa) pair might change very slowly. Most bright example is x =  - 1018, y = 1. Thus one needs to count number of steps until both numbers becomes positive before launching emulationt. For x < 0 and y > 0 number of those steps is exactly . 317B - Ants318D - AntsOne may reformulate the problem ass follows. Non-negative integers A(x, y) are placed in the vertices of two-dimensional lattice We may imagine this construction as a function . On each step for each vertex P = (x, y) with A(x, y) ≥ 4 we perform operation φP, which substracts 4 from A(x, y) and adds 1 to A(x, y - 1), A(x, y + 1), A(x - 1, y), A(x + 1, y). We may think that operation φP applies to the whole function A. We need to find values of A after the iterations stops.Key idea is that operactions φP and φQ for all points P and Q commutes, that is φP(φQ(A)) = φQ(φP(A)). This means that the order of operations is unimportant. In particular, we may assume that from each given vertex run all possible four-groups of ants and not only one. After this observation one may run full emulation of the process. As an exercise contestants may check that ants will never leave square 200 × 200 with center in the origin 0 with given constraints.317C - Balance318E - BalanceIn this problem we need to find 2n2 transfusions from initial configuration to the desired one. First of all we propose the following: if in each connected component overall volume of the water in initial configuration is the same as in desired one, then answer exist. We call the vessel ready, if current volume of its water equals desired one. Let us describe solution which is probably easier to code. We will make vessels ready one by one. Consider the pair of non-ready vessels s and t (there is more water in s than desired, and less water in t than desired), such that they are connected by the path P, and if one transfuses d litres from s to t then one of the vessels becomes ready. Now we need to find a way to transfuse d litres by path P from s to t. One may write recursive function pour(s, t, d) for this aim. Let t' stand before t in this path, then function works as follows: transfuses from t' to t as many water as possible (not more than d of course), then calls pour(s, t', d) and on the final step transfuses from t' to t all that left. It is easy to check that all such transfusions are correct. This algorithm makes 2len transfusions on the path of length len, so total number of transfusions is not greater than 2n2.317D - Game with PowersFor each numner x denote sequence of its powers within [1..n] as Pow(x): Game proceeds as follows: on each step one player takes still available number x from 1 to n and prohibits whole set Pow(x). Who can't make his turn loses.This game may be decomposed in the sum of lesser games. Indeed, lets call number x simple (and corresponding sequence Pow(x) simple), if it is not a power of any number y < x. Then: 1. for each there is simple x, such that ; 2. for each simple distinct x and y sets Pow(x) and P(y) do not intersect. Indeed, for a given k there is exactly one simple x such that k is power of x. This may be showed from fundamental theorem of arithmetic: if and d = gcd(α1, α2, ..., αn), then .Hence set [1..n] decomposes into primitive sets Pow(x), on each of those Pow(x) game proceeds independetly. Now one may use Sprague–Grundy theory to see that mexx of our game is just xor of all mexx of games on simple Pow(x). For fixed x, if Pow(x) = {x, x2, ..., xs}, then mexx of the game on Pow(x) depends only on s, but not on x. In our case s runs from 1 to 29, mexx for all such s may be directly precalculated. Now it is enough to find numbers q(s) of simple x with a given size of Pow(x) equal to s (actually we are interested in parity of q(s) not in q(s) itself).Our constraints allows to do it directly: run x from 2 to , if it is not crossed out, determine the size Pow(x) [increment corresponding q(s)], and cross out all numbers from Pow(x). This cycle finds all simple sequences of length at least 2. Quantity of non-crossed numbers is the number of all simple sequences of length 1. Now it is enough to look at parities of q(s) and xor coressponding mexx.However one may find all q(s) for . Indeed lets look at the number and sequence {x, x2, x3, x4, ..., xs}. This sequence is not simple iff it is containd in some larger simple sequence. But number of subsequenes of size s in a given sequence of size t > s is easy to find: it is just [t / s]. Recalling that simple sequences do not intersect one gets the reccurent formula:. Now it is easy to find all q(s) from q(29) to q(1).Remark: while coding it is important to remeber simple number x = 1.317E - Princess and Her ShadowIn this problem princess Vlada should simply catch the Shadow. Here is the idea of a solution. If there is only one tree, then using it as a barrier to the shadow it is not hard to catch the shadow. Similar technique works if Vlada and Shadow are far from the square where all the trees grow. But what can she do in the dark depths of the forest? If there is no path at all between Vlada and Shadow, then there is no way to catch it. Otherwise consider a shortest path from Vlada to the Shadow and make Vlada follow it. This path gives Vlada a queue of the steps that she should perform. Additionaly if shadow moves, then we add her move to the queue (simply speaking Vlada follows the shadow). This is where the algorithmic part ends. Now we state that either Vlada catches the shadow in the desired number of steps, or steps out of the \"forest square\". To proof this we note that the length of the path between Vlada and Shadow may only decrease. And if it does not decrease long enough, then once in k steps (k is the length of the path) Vlada and Shadow shifts at the same vector over and over, and at some moment leaves the \"forest square\". Note that if the trees allow our heroes to step out of the \"forest square\" at the beginning, then we may just get them out from the start. But taking this approach we still need to catch the Shadow in a \"labyrinth forest\".Apologies for the delay. There are probably misprints and mistakes here (thousands of them!), please feel free to point them out.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/7956",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 318\\s*C"
          },
          "content_length": 8753
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #188 - Codeforces - Code 1",
          "code": "-1000000000000000000 1 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7862",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #188 - Codeforces - Code 2",
          "code": "...\nlong long x,y,m;\nlong long res;\n...\nint mymx = max(x,y); // int ???\nint mymn = min(x,y); // int ???\n\nx = mymx;\ny = mymn;\n...",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7862",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #188 - Codeforces - Code 3",
          "code": "...\nlong long x,y,m;\nlong long res;\n...\nint mymx = max(x,y); // int ???\nint mymn = min(x,y); // int ???\n\nx = mymx;\ny = mymn;\n...",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7862",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #188 - Codeforces - Code 4",
          "code": "s.size() < 4",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7862",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #188 - Codeforces - Code 5",
          "code": "s.size() - 4",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7862",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #188 - Codeforces - Code 6",
          "code": "#define SZ(x) (int)x.size()",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7862",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #188 - Codeforces - Code 7",
          "code": "Contest rating",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7862",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #188 (analysis) - Codeforces - Code 1",
          "code": "Thank you for the nice contest and editorial. \nIn \"Ants\" problem, Is there any way to expect the simulation will be converge so fast before we writing brute force code? how to make sure n = 30000 is the worst case?",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7956",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #188 (analysis) - Codeforces - Code 2",
          "code": "Thank you for the nice contest and editorial. \nIn \"Ants\" problem, Is there any way to expect the simulation will be converge so fast before we writing brute force code? how to make sure n = 30000 is the worst case?",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7956",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #188 (analysis) - Codeforces - Code 3",
          "code": "#include <string.h>\n#include <cstdio>\n#include <map>\nusing namespace std;\nmap<long long ,int>SG;\nint DFS(long long state) {\n    //printf(\"%I64d\\n\",state);getchar();getchar();\n    if(state==0) return 0;\n    if(SG[state]) return SG[state];\n    int len=0;long long tmp=state;\n    while(tmp>0) {\n        len++;\n        tmp>>=1;\n    }\n    bool cnt[100];memset(cnt,0,sizeof(cnt));\n    for(int i=1;i<=len;i++) {\n        long long k=(1<<(i-1)),tmp=state;\n        while(k<=tmp) {\n            tmp&=(((1<<(len+1))-1)^k);//printf(\"%lld\\n\",k);\n            k<<=i;\n\t\t}//printf(\"%lld\\n\",tmp);\n\t\tif(tmp==state) continue;\n        int ret=DFS(tmp);\n        cnt[ret]=1;\n    }\n    for(int i=0;;i++)if(!cnt[i]){\n        //printf(\"%d %d\\n\",len,i);\n        return (SG[state]=i);\n    }\n}\nint main()\n{\n    for(int I=1;I<=29;I++) {\n        printf(\"%d\\n\",DFS((long long )((1<<I)-1)));\n    }\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/7956",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #188 (analysis) - Codeforces - Code 4",
          "code": "#include <string.h>\n#include <cstdio>\n#include <map>\nusing namespace std;\nmap<long long ,int>SG;\nint DFS(long long state) {\n    //printf(\"%I64d\\n\",state);getchar();getchar();\n    if(state==0) return 0;\n    if(SG[state]) return SG[state];\n    int len=0;long long tmp=state;\n    while(tmp>0) {\n        len++;\n        tmp>>=1;\n    }\n    bool cnt[100];memset(cnt,0,sizeof(cnt));\n    for(int i=1;i<=len;i++) {\n        long long k=(1<<(i-1)),tmp=state;\n        while(k<=tmp) {\n            tmp&=(((1<<(len+1))-1)^k);//printf(\"%lld\\n\",k);\n            k<<=i;\n\t\t}//printf(\"%lld\\n\",tmp);\n\t\tif(tmp==state) continue;\n        int ret=DFS(tmp);\n        cnt[ret]=1;\n    }\n    for(int i=0;;i++)if(!cnt[i]){\n        //printf(\"%d %d\\n\",len,i);\n        return (SG[state]=i);\n    }\n}\nint main()\n{\n    for(int I=1;I<=29;I++) {\n        printf(\"%d\\n\",DFS((long long )((1<<I)-1)));\n    }\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/7956",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    long long min_value = -1000000000000000000LL; // -1e18\n    long long max_value = 1000000000000000000LL; // 1e18\n    long long x = inf.readLong(min_value, max_value, \"x\");\n    inf.readSpace();\n    long long y = inf.readLong(min_value, max_value, \"y\");\n    inf.readSpace();\n    long long m = inf.readLong(min_value, max_value, \"m\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    long long min_value = -1000000000000000000LL; // -1e18\n    long long max_value = 1000000000000000000LL; // 1e18\n    long long x = inf.readLong(min_value, max_value, \"x\");\n    inf.readSpace();\n    long long y = inf.readLong(min_value, max_value, \"y\");\n    inf.readSpace();\n    long long m = inf.readLong(min_value, max_value, \"m\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    long long min_value = -1000000000000000000LL; // -1e18\n    long long max_value = 1000000000000000000LL; // 1e18\n    long long x = inf.readLong(min_value, max_value, \"x\");\n    inf.readSpace();\n    long long y = inf.readLong(min_value, max_value, \"y\");\n    inf.readSpace();\n    long long m = inf.readLong(min_value, max_value, \"m\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst long long MIN_L = -1000000000000000000LL;\nconst long long MAX_L = 1000000000000000000LL;\nconst long long OFFSET_L = 100000000000000000LL;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    string type = opt<string>(\"type\", \"random\");\n    long long x, y, m;\n\n    if (type == \"random\") {\n        x = rnd.next(MIN_L, MAX_L);\n        y = rnd.next(MIN_L, MAX_L);\n        m = rnd.next(MIN_L, MAX_L);\n    } else if (type == \"positive\") {\n        x = rnd.next(1LL, MAX_L);\n        y = rnd.next(1LL, MAX_L);\n        m = rnd.next(1LL, MAX_L);\n    } else if (type == \"negative\") {\n        x = rnd.next(MIN_L, -1LL);\n        y = rnd.next(MIN_L, -1LL);\n        m = rnd.next(MIN_L, -1LL);\n    } else if (type == \"impossible_negative\") {\n        x = rnd.next(MIN_L, 0LL);\n        y = rnd.next(MIN_L, 0LL);\n        m = rnd.next(1LL, MAX_L);\n    } else if (type == \"zeros\") {\n        x = y = 0LL;\n        m = rnd.next(MIN_L, MAX_L);\n    } else if (type == \"large_positive\") {\n        x = rnd.next(MAX_L - OFFSET_L, MAX_L);\n        y = rnd.next(MAX_L - OFFSET_L, MAX_L);\n        m = rnd.next(MAX_L - OFFSET_L, MAX_L);\n    } else if (type == \"max_limits\") {\n        x = MAX_L;\n        y = MAX_L;\n        m = MAX_L;\n    } else if (type == \"min_limits\") {\n        x = MIN_L;\n        y = MIN_L;\n        m = MIN_L;\n    } else if (type == \"mixed_sign\") {\n        x = rnd.next(MIN_L, -1LL);\n        y = rnd.next(1LL, MAX_L);\n        m = rnd.next(MIN_L, MAX_L);\n    } else if (type == \"positive_m_negative_x_y\") {\n        x = rnd.next(MIN_L, -1LL);\n        y = rnd.next(MIN_L, -1LL);\n        m = rnd.next(1LL, MAX_L);\n    } else if (type == \"negative_m_positive_x_y\") {\n        x = rnd.next(1LL, MAX_L);\n        y = rnd.next(1LL, MAX_L);\n        m = rnd.next(MIN_L, -1LL);\n    } else if (type == \"same_numbers\") {\n        x = y = rnd.next(MIN_L, MAX_L);\n        m = rnd.next(MIN_L, MAX_L);\n    } else if (type == \"large_sum_overflow\") {\n        x = MAX_L - rnd.next(0LL, 1000000000000LL);\n        y = MAX_L - rnd.next(0LL, 1000000000000LL);\n        m = MAX_L;\n    } else if (type == \"small_numbers\") {\n        x = rnd.next(-10LL, 10LL);\n        y = rnd.next(-10LL, 10LL);\n        m = rnd.next(-10LL, 10LL);\n    } else if (type == \"custom\") {\n        x = opt<long long>(\"x\");\n        y = opt<long long>(\"y\");\n        m = opt<long long>(\"m\");\n    } else {\n        // Default to random\n        x = rnd.next(MIN_L, MAX_L);\n        y = rnd.next(MIN_L, MAX_L);\n        m = rnd.next(MIN_L, MAX_L);\n    }\n\n    printf(\"%lld %lld %lld\\n\", x, y, m);\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst long long MIN_L = -1000000000000000000LL;\nconst long long MAX_L = 1000000000000000000LL;\nconst long long OFFSET_L = 100000000000000000LL;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    string type = opt<string>(\"type\", \"random\");\n    long long x, y, m;\n\n    if (type == \"random\") {\n        x = rnd.next(MIN_L, MAX_L);\n        y = rnd.next(MIN_L, MAX_L);\n        m = rnd.next(MIN_L, MAX_L);\n    } else if (type == \"positive\") {\n        x = rnd.next(1LL, MAX_L);\n        y = rnd.next(1LL, MAX_L);\n        m = rnd.next(1LL, MAX_L);\n    } else if (type == \"negative\") {\n        x = rnd.next(MIN_L, -1LL);\n        y = rnd.next(MIN_L, -1LL);\n        m = rnd.next(MIN_L, -1LL);\n    } else if (type == \"impossible_negative\") {\n        x = rnd.next(MIN_L, 0LL);\n        y = rnd.next(MIN_L, 0LL);\n        m = rnd.next(1LL, MAX_L);\n    } else if (type == \"zeros\") {\n        x = y = 0LL;\n        m = rnd.next(MIN_L, MAX_L);\n    } else if (type == \"large_positive\") {\n        x = rnd.next(MAX_L - OFFSET_L, MAX_L);\n        y = rnd.next(MAX_L - OFFSET_L, MAX_L);\n        m = rnd.next(MAX_L - OFFSET_L, MAX_L);\n    } else if (type == \"max_limits\") {\n        x = MAX_L;\n        y = MAX_L;\n        m = MAX_L;\n    } else if (type == \"min_limits\") {\n        x = MIN_L;\n        y = MIN_L;\n        m = MIN_L;\n    } else if (type == \"mixed_sign\") {\n        x = rnd.next(MIN_L, -1LL);\n        y = rnd.next(1LL, MAX_L);\n        m = rnd.next(MIN_L, MAX_L);\n    } else if (type == \"positive_m_negative_x_y\") {\n        x = rnd.next(MIN_L, -1LL);\n        y = rnd.next(MIN_L, -1LL);\n        m = rnd.next(1LL, MAX_L);\n    } else if (type == \"negative_m_positive_x_y\") {\n        x = rnd.next(1LL, MAX_L);\n        y = rnd.next(1LL, MAX_L);\n        m = rnd.next(MIN_L, -1LL);\n    } else if (type == \"same_numbers\") {\n        x = y = rnd.next(MIN_L, MAX_L);\n        m = rnd.next(MIN_L, MAX_L);\n    } else if (type == \"large_sum_overflow\") {\n        x = MAX_L - rnd.next(0LL, 1000000000000LL);\n        y = MAX_L - rnd.next(0LL, 1000000000000LL);\n        m = MAX_L;\n    } else if (type == \"small_numbers\") {\n        x = rnd.next(-10LL, 10LL);\n        y = rnd.next(-10LL, 10LL);\n        m = rnd.next(-10LL, 10LL);\n    } else if (type == \"custom\") {\n        x = opt<long long>(\"x\");\n        y = opt<long long>(\"y\");\n        m = opt<long long>(\"m\");\n    } else {\n        // Default to random\n        x = rnd.next(MIN_L, MAX_L);\n        y = rnd.next(MIN_L, MAX_L);\n        m = rnd.next(MIN_L, MAX_L);\n    }\n\n    printf(\"%lld %lld %lld\\n\", x, y, m);\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -type random\n./gen -type positive\n./gen -type negative\n./gen -type impossible_negative\n./gen -type zeros\n./gen -type large_positive\n./gen -type max_limits\n./gen -type min_limits\n./gen -type mixed_sign\n./gen -type positive_m_negative_x_y\n./gen -type negative_m_positive_x_y\n./gen -type same_numbers\n./gen -type large_sum_overflow\n./gen -type small_numbers\n\n# Custom test cases\n./gen -type custom -x 0 -y 0 -m 5\n./gen -type custom -x -1 -y -1 -m 5\n./gen -type custom -x 1 -y 2 -m 5\n./gen -type custom -x -1 -y 4 -m 15\n./gen -type custom -x 0 -y -1 -m -5\n./gen -type custom -x 1000000000000000000 -y -1000000000000000000 -m 0\n./gen -type custom -x -1000000000000000000 -y 1000000000000000000 -m 0\n\n# Additional random test cases\n./gen -type random\n./gen -type random\n./gen -type random\n\n./gen -type positive\n./gen -type positive\n\n./gen -type negative\n./gen -type negative\n\n./gen -type zeros\n\n./gen -type max_limits\n\n./gen -type min_limits\n\n./gen -type mixed_sign\n./gen -type mixed_sign\n\n./gen -type large_positive\n\n./gen -type large_sum_overflow\n\n./gen -type impossible_negative\n\n./gen -type small_numbers\n./gen -type small_numbers\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:07:24.743621",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "318/D",
      "title": "D. Муравьи",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест1 секунда",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеПервая строка содержит целые числа n (0 ≤ n ≤ 30000) и t (1 ≤ t ≤ 50000), где n — количество муравьев в колонии, t — количество запросов. Каждая из следующих t строк содержит координаты узлов-запросов: целые числа xi, yi ( - 109 ≤ xi, yi ≤ 109). Запросы могут повторяться.Гарантируется, что наступит момент, когда муравьи не смогут больше совершать движения и процесс остановится.",
      "output_spec": "Выходные данныеВыведите t чисел, по одному на строчку — количества муравьев в соответствующих узлах в конце забега.",
      "sample_tests": "ПримерыВходные данныеСкопировать1 30 10 00 -1Выходные данныеСкопировать010Входные данныеСкопировать6 50 -20 -10 00 10 2Выходные данныеСкопировать01210",
      "description": "ограничение по времени на тест1 секунда\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвыводstdout\n\nВходные данныеПервая строка содержит целые числа n (0 ≤ n ≤ 30000) и t (1 ≤ t ≤ 50000), где n — количество муравьев в колонии, t — количество запросов. Каждая из следующих t строк содержит координаты узлов-запросов: целые числа xi, yi ( - 109 ≤ xi, yi ≤ 109). Запросы могут повторяться.Гарантируется, что наступит момент, когда муравьи не смогут больше совершать движения и процесс остановится.\n\nВходные данные\n\nВыходные данныеВыведите t чисел, по одному на строчку — количества муравьев в соответствующих узлах в конце забега.\n\nВыходные данные\n\nВходные данныеСкопировать1 30 10 00 -1Выходные данныеСкопировать010Входные данныеСкопировать6 50 -20 -10 00 10 2Выходные данныеСкопировать01210\n\nВходные данныеСкопировать1 30 10 00 -1\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать010\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать6 50 -20 -10 00 10 2\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать01210\n\nВыходные данныеСкопировать\n\nСкопировать\n\nПримечаниеВ первом примере колония состоит всего из одного муравья, и никаких движений не происходит.Во втором примере колония состоит из 6 муравьев. На первой минуте 4 муравья из (0, 0) разбегаются в соседние узлы. После этого процесс останавливается.",
      "solutions": [
        {
          "title": "Codeforces Round #188 - Codeforces",
          "content": "Добрый вечер, друзья!За обсуждением животрепещущей темы использования чужого кода в своих решениях можно и не заметить, что приближается зима 188 раунд платформы Codeforces!А ведь мы постарались подготовить для вас набор задач с любопытными (и, как нам хочется думать, не сильно сложными) идеями и понятными условиями.Мы — это авторы задач yaro и Rei, куратор раундов Codeforces Gerald и автор системы MikeMirzayanov. Отдельное спасибо Паше (PavelKunyavskiy) и Артему (RAD) за тестирование и дельные замечания.Последний раз, когда я участвовал в проведении соревнования на Codeforces, раунды еще носили статус \"beta\". Но чем меньше \"beta\", тем больше ответственность. В связи с этим желаю организаторам и авторам еще одного успешно проведенного раунда. Участникам же — нестандартных задач и идей, чистого кода (а также чистой клавиатуры) и побольше правильно сданных решений!Нам представляется непростой задачей оценить уровень сложности задач для всей массы участников, поэтому разбалловка будет динамическая. Все же ради любопытства сделаем следующее предположение об относительной сложности задач: div.1: B-B-C-C-E, div.2: A-B-C-C-E. Угадаем ли?UPD Приносим извинения за проблемы с очередью тестирования Codeforces.В любом случае, нам будет очень приятно, если вы оцените наш раунд (после его завершения): short survey.В упорной борьбе с отрывом в один взлом победителем div.1 стал meret (Jakub Pachocki)!Доступны результаты первого дивизиона, результаты второго дивизиона.Разбор.",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/7862",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 1483
        },
        {
          "title": "Codeforces Round #188 (разбор) - Codeforces",
          "content": "Предварительная версия разбора.318A - Чет и нечетВ задаче про четные и нечетные числа требуется понять, как будет выглядеть последовательность чисел от 1 до n, если выписать сначала все нечетные числа, а затем — четные. Для того, чтобы определить, какое число стоит на k-м месте, нужно посчитать индекс в массиве, с которого начнутся четные числа, и вывести соответствующее k либо нечетное число из первой половины массива, либо четное из второй.318B - Энергетические строчкиВ задаче про хэви-метал требуется найти в строке S количество подстрок, начинающихся на одну строчку A и заканчивающихся другой строчкой B. Если мы пометим черным все позиции вхождения в S строки A, белым — позиции вхождения строки B, то получим следующую задачу: посчитать количество пар <черная позиция, белая позиция> (причем именно в таком порядке). Для этого достаточно бежать, к примеру, слева направо и хранить счетчик — количество уже пройденных черных позиций. Тогда если мы встречаем очередную черную позицию, то увеличиваем счетчик на один, если встречаем белую — добавляем к ответу количество пар с данной белой позицией. А это количество — и есть текущее значение счетчика.317A - Превосходная пара318C - Превосходная параКак легко понять эта задача была задачей на аккуратность. В ней труднее не придумать решение, а написать его так, чтобы ни один случай не был забыт.Каждый ход мы заменяем одно из чисел x, y на их сумму x + y и так пока пара чисел на доске не станет m-превосходной (то есть одно из чисел станет не меньше m). Ясно, что заменять на сумму нужно именно меньшее из двух чисел x и y. Действительно, будем говорить что пара чисел x1 ≤ y1 мажорирует пару чисел x2 ≤ y2, если y1 ≥ y2 и x1 ≥ y2. В этой ситуации, если за несколько наших действий из пары x2, y2 мы получим m-превосходную, то применяя те же самые действия к x1, y1 мы получим m-превосходную пару никак не позже. Если x ≤ y, то пара x + y, y мажорирует пару x + y, x. Поэтому путь через x + y, y до m-превосходной никак не длинее, и можно считать что мы выбираем именно эту пару. Теперь действия нашего игрока однозначны.Рассмотрим случаи: x ≤ 0, y ≤ 0 В этом случае наши операции не увеличивают числа на доске, поэтому пара может стать m-превосходной только если она изначально была m-превосходной. x > 0 или y > 0 В этом случае для любого m пара со временем станет m-превосходной. Для того чтобы посчитать точное количество шагов теперь достаточно запустить эмуляцию. Однако если при x > 0 и y > 0 легко видеть что пара <<растет экспоненциально>> (формальнее: лекго видеть что начиная со второго шага сумма x + y увеличивается хотя бы в 3 / 2 раза за каждый ход) и эмуляция работает очень быстро, то в случае x < 0 и y > 0 (или наоборот) числа в паре могут изменяться очень медленно. Особенно хорошо это видно на примере x =  - 1018, y = 1. Поэтому в таком случае необходимо отдельно посчитать количество шагов до момента, когда оба числа станут неотрицательными и только потом запускать эмуляцию. Для x < 0 и y > 0 такое количество шагов равно . 317B - Муравьи318D - МуравьиЗадачу можно представлять себе следующим образом. В вершинах двумерной решетки расставлены неотрицательные целые числа A(x, y). Считаем, что они заданы функцией . В каждый момент времени для каждой вершины P = (x, y) с числом A(x, y) ≥ 4 применяется операция φP, которая уменьшает A(x, y) на 4 и увеличивает A(x, y - 1), A(x, y + 1), A(x - 1, y), A(x + 1, y) на 1. Можно считать, что операция φP применяется ко всей функции A. От нас требуется найти эту функцию в запрашиваемых узлах после того как итерации прекратятся.Ключевое наблюдение для большинства решений состояло в том, что операции φP и φQ для всех точек P и Q коммутируют, то есть φP(φQ(A)) = φQ(φP(A)). Поэтому неважно в каком именно порядке применять операции. В частности, можно считать, что из данной вершины разбегаются сразу все возможные четверки муравьев. Теперь можно запустить прямую эмуляцию процесса в таком виде. В качестве упражнения участникам предлагается проверить, что муравьи никогда не покинут квадрат 200 × 200 с центром в 0 при указанных ограничениях.317C - Баланс318E - БалансВ задаче про сосуды и воду требовалось найти последовательность из порядка n2 переливаний, которая переводит начальную конфигурацию в конечную. Во-первых, утверждается следующее: если в каждой компоненте связности сумма исходных значений и сумма итоговых совпадают, то ответ существует. Назовем сосуд готовым, если текущее и требуемое количество воды в нем совпадают. Опишем сначала решение, которое, вероятно, проще всего пишется. Будем делать сосуды готовыми по очереди. Возьмем произвольную пару еще не готовых сосудов s и t (в s сейчас воды больше, чем нужно, в t — меньше, чем нужно), такую, что их соединяет некоторый простой путь P, при этом если перелить из s в t d литров, то один из сосудов станет готовым. Осталось научиться переливать d литров по пути из s в t. Напишем для этого рекурсивную функцию pour(s, t, d). Пусть t' идет перед t в этом пути, тогда функцию выполнит следующее: перельет из t' сколько возможно (разумеется, не больше d) в t, вызовет pour(s, t', d) и затем перельет из t' в t то, что осталось. Несложно проверить, что никакой сосуд при этом не переполнится. Такой алгоритм производит переливание по пути длины len за 2len элементарных переливаний, в итоге решение делает не более 2n2 операций.317D - Игра со степенямиДавайте для каждого числа x обозначим последовательность его степеней не вылезающих за границы [1..n] через Pow(x): Тогда наша игра состоит в следующем: каждый игрок на очередном шаге выбирает еще не зачеркнутое число x от 1 до n и зачеркивает все числа из Pow(x). Проигрывает не имеющий хода.Легко заметить, что такая игра распадается в сумму нескольких более простых игр. Действительно, назовем число x примитивным (и соответствующую последовательность Pow(x) примитивной), если оно не является степенью никакого числа y < x. Тогда: 1. для любого числа найдется примитивное число x, такое что ; 2. для любых различных примитивных чисел x и y множества Pow(x) и P(y) не пересекаются. Действительно для данного числа k существует ровно одно примитивное x степенью которого k является. Это, например, следует из основной теоремы арифметики: если и d = gcd(α1, α2, ..., αn), то .Таким образом все множество [1..n] разбивается на маленькие примитивные подмножества Pow(x), игра на которых происходит независимо. Наша игра распалась в сумму меньших игр. Теперь необходимо применить теорию Шпрага-Гранди и заметить, что мекс-функция нашей игры является ксором мекс-функций всех игр на примитивных Pow(x). Среди таких игр много совпадающих, что позволит легко вычислить ксор.Для конкретного x, если Pow(x) = {x, x2, ..., xs}, то мекс-функция зависит только от s, но не от самого x. В наших ограничениях s принимает значения от 1 до 29, мекс-функции для всех таких s можно предподсчитать напрямую. Осталось теперь лишь найти количество q(s) примитивных x с данной длиной Pow(x) равной s (более точно нас интересует не количество, а лишь четность этого количества).Ограничения задачи позволяют сделать это \"в лоб\": увеличиваем x от 2 до , если оно не зачеркнуто, находим длину Pow(x) [увеличиваем соответствующее q(s)], и зачеркиваем все числа из Pow(x). Этот цикл найдет все примитивные последовательности длины хотя бы 2. Количество незачеркнутых чисел даст все примитивные последовательности длины 1. Останется лишь посмотреть на их четности и посчитать соответсвующий ксор мексов.Однако можно найти все q(s) и за . Действительно, давайте посмотрим какое-нибудь число и последовательность {x, x2, x3, x4, ..., xs}. Она не является примитивной, только если содержится как подмножество в некоторой большей примитивной последовательности. Количество таких подпоследовательностей длины s в данной примитивной последовательности длины t > s легко найти, действительно это [t / s]. Вспоминая теперь, что притимвные последовательности не пересекаются получаем реккуретную формулу. Используя ее, легко найти все q(s) начиная с q(29) и заканчивая q(1).Замечание: при написании задачи важно не забыть учесть примитивное x = 1.317E - Принцесса и ее теньВ задаче про принцессу Владу требовалось всего-навсего поймать тень. Опишем идею решения. Если на плоскости растет всего одно дерево, то, используя его как преграду для тени, несложно найти подходящую последовательность ходов. Аналогично поступим (использовав какое-либо крайнее дерево), если Влада и Тень находятся далеко, вне квадрата, где могут расти деревья. Осталось понять, что же делать в самой чаще леса! Если между Владой и ее тенью вообще не существует пути, то поймать тень никак не удастся. Иначе рассмотрим кратчайший путь от принцессы до тени, и пойдем принцессой по нему. Будет считать, что этот путь задает нам очередь шагов, которые необходимо сделать. При этом если тень передвигается куда-либо, то добавим ее ход в очередь (иначе говоря, мы идем по пути, состоящему из кратчайшего пути до тени в начальный момент времени и последующих передвижений тени). Алгоритмическая часть на этом закончилась: утверждается, что мы за необходимое число шагов либо поймаем тень, либо выйдем из \"лесного квадрата\". Доказательство опирается на следующую идею: длина пути, по которому мы идем до тени, разве что уменьшается. При этом если она не уменьшается достаточно долго, то раз в k шагов (k — длина пути) происходит смещение на один и тот же ненулевой вектор, следовательно, мы выйдем из \"лесного квадрата\". Стоит отметить, что если наши герои не заперты в лабиринт (могут выйти из \"лесного квадрата\"), то можно вывести их из квадрата по очереди. Но в таком случае для лабиринта все равно придется придумывать способ ловить тень.",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/7956",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 318\\s*D"
          },
          "content_length": 9624
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #188 - Codeforces - Code 1",
          "code": "for (int i = 23;i < 30;i++) {\n        ans[i] = 1;\n    }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7862",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #188 - Codeforces - Code 2",
          "code": "for (int i = 23;i < 30;i++) {\n        ans[i] = 1;\n    }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7862",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #188 - Codeforces - Code 3",
          "code": "-1000000000000000000 1 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7862",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #188 - Codeforces - Code 4",
          "code": "...\nlong long x,y,m;\nlong long res;\n...\nint mymx = max(x,y); // int ???\nint mymn = min(x,y); // int ???\n\nx = mymx;\ny = mymn;\n...",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7862",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #188 - Codeforces - Code 5",
          "code": "...\nlong long x,y,m;\nlong long res;\n...\nint mymx = max(x,y); // int ???\nint mymn = min(x,y); // int ???\n\nx = mymx;\ny = mymn;\n...",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7862",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #188 - Codeforces - Code 6",
          "code": "s.size() < 4",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7862",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #188 - Codeforces - Code 7",
          "code": "s.size() - 4",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7862",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #188 - Codeforces - Code 8",
          "code": "#define SZ(x) (int)x.size()",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7862",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #188 - Codeforces - Code 9",
          "code": "Contest rating",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7862",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #188 - Codeforces - Code 10",
          "code": "Взлом не использует генератор\ncom.codeforces.contester.exception.ChallengeIgnoredException: Challenge is ignored because of the challenged submit is not the last accepted now [submissionId=3887152].\ncom.codeforces.contester.processor.impl.ChallengeProcessor.internalProcess(ChallengeProcessor.java:100)    com.codeforces.contester.processor.impl.ChallengeProcessor.process(ChallengeProcessor.java:63)\ncom.codeforces.contester.processor.impl.ChallengeProcessor.process(ChallengeProcessor.java:36)    com.codeforces.contester.processor.RunnableFactory$ProcessorRunnable.run(RunnableFactory.java:51)\ncom.codeforces.contester.ContesterServletRunnable$2.run(ContesterServletRunnable.java:169)\njava.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1110)\njava.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:603)\njava.lang.Thread.run(Thread.java:722)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7862",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #188 - Codeforces - Code 11",
          "code": "Взлом не использует генератор\ncom.codeforces.contester.exception.ChallengeIgnoredException: Challenge is ignored because of the challenged submit is not the last accepted now [submissionId=3887152].\ncom.codeforces.contester.processor.impl.ChallengeProcessor.internalProcess(ChallengeProcessor.java:100)    com.codeforces.contester.processor.impl.ChallengeProcessor.process(ChallengeProcessor.java:63)\ncom.codeforces.contester.processor.impl.ChallengeProcessor.process(ChallengeProcessor.java:36)    com.codeforces.contester.processor.RunnableFactory$ProcessorRunnable.run(RunnableFactory.java:51)\ncom.codeforces.contester.ContesterServletRunnable$2.run(ContesterServletRunnable.java:169)\njava.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1110)\njava.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:603)\njava.lang.Thread.run(Thread.java:722)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7862",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #188 - Codeforces - Code 12",
          "code": "challenged submit is not the last accepted now",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7862",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #188 (разбор) - Codeforces - Code 1",
          "code": "1 1\n1 2\n2 3\n3 5\n5 8\n8 13\n13 21",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7956",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #188 (разбор) - Codeforces - Code 2",
          "code": "1 1\n1 2\n2 3\n3 5\n5 8\n8 13\n13 21",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7956",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #188 (разбор) - Codeforces - Code 3",
          "code": "109 строка:    X = X ^ (((max(0, n - (SQ - 1))) % 2 == 1) ? get(1) : 0);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7956",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #188 (разбор) - Codeforces - Code 4",
          "code": "109 строка:    X = X ^ (((max(0, n - (SQ - 1))) % 2 == 1) ? get(1) : 0);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7956",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #188 (разбор) - Codeforces - Code 5",
          "code": "Thank you for the nice contest and editorial. \nIn \"Ants\" problem, Is there any way to expect the simulation will be converge so fast before we writing brute force code? how to make sure n = 30000 is the worst case?",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7956",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #188 (разбор) - Codeforces - Code 6",
          "code": "Thank you for the nice contest and editorial. \nIn \"Ants\" problem, Is there any way to expect the simulation will be converge so fast before we writing brute force code? how to make sure n = 30000 is the worst case?",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7956",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #188 (разбор) - Codeforces - Code 7",
          "code": "#include <string.h>\n#include <cstdio>\n#include <map>\nusing namespace std;\nmap<long long ,int>SG;\nint DFS(long long state) {\n    //printf(\"%I64d\\n\",state);getchar();getchar();\n    if(state==0) return 0;\n    if(SG[state]) return SG[state];\n    int len=0;long long tmp=state;\n    while(tmp>0) {\n        len++;\n        tmp>>=1;\n    }\n    bool cnt[100];memset(cnt,0,sizeof(cnt));\n    for(int i=1;i<=len;i++) {\n        long long k=(1<<(i-1)),tmp=state;\n        while(k<=tmp) {\n            tmp&=(((1<<(len+1))-1)^k);//printf(\"%lld\\n\",k);\n            k<<=i;\n\t\t}//printf(\"%lld\\n\",tmp);\n\t\tif(tmp==state) continue;\n        int ret=DFS(tmp);\n        cnt[ret]=1;\n    }\n    for(int i=0;;i++)if(!cnt[i]){\n        //printf(\"%d %d\\n\",len,i);\n        return (SG[state]=i);\n    }\n}\nint main()\n{\n    for(int I=1;I<=29;I++) {\n        printf(\"%d\\n\",DFS((long long )((1<<I)-1)));\n    }\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/7956",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #188 (разбор) - Codeforces - Code 8",
          "code": "#include <string.h>\n#include <cstdio>\n#include <map>\nusing namespace std;\nmap<long long ,int>SG;\nint DFS(long long state) {\n    //printf(\"%I64d\\n\",state);getchar();getchar();\n    if(state==0) return 0;\n    if(SG[state]) return SG[state];\n    int len=0;long long tmp=state;\n    while(tmp>0) {\n        len++;\n        tmp>>=1;\n    }\n    bool cnt[100];memset(cnt,0,sizeof(cnt));\n    for(int i=1;i<=len;i++) {\n        long long k=(1<<(i-1)),tmp=state;\n        while(k<=tmp) {\n            tmp&=(((1<<(len+1))-1)^k);//printf(\"%lld\\n\",k);\n            k<<=i;\n\t\t}//printf(\"%lld\\n\",tmp);\n\t\tif(tmp==state) continue;\n        int ret=DFS(tmp);\n        cnt[ret]=1;\n    }\n    for(int i=0;;i++)if(!cnt[i]){\n        //printf(\"%d %d\\n\",len,i);\n        return (SG[state]=i);\n    }\n}\nint main()\n{\n    for(int I=1;I<=29;I++) {\n        printf(\"%d\\n\",DFS((long long )((1<<I)-1)));\n    }\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/7956",
          "author": "Qingyu"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(0, 30000, \"n\");\n    inf.readSpace();\n    int t = inf.readInt(1, 50000, \"t\");\n    inf.readEoln();\n    for (int i = 0; i < t; ++i) {\n        int xi = inf.readInt(-1000000000, 1000000000, \"xi\");\n        inf.readSpace();\n        int yi = inf.readInt(-1000000000, 1000000000, \"yi\");\n        inf.readEoln();\n    }\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(0, 30000, \"n\");\n    inf.readSpace();\n    int t = inf.readInt(1, 50000, \"t\");\n    inf.readEoln();\n    for (int i = 0; i < t; ++i) {\n        int xi = inf.readInt(-1000000000, 1000000000, \"xi\");\n        inf.readSpace();\n        int yi = inf.readInt(-1000000000, 1000000000, \"yi\");\n        inf.readEoln();\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(0, 30000, \"n\");\n    inf.readSpace();\n    int t = inf.readInt(1, 50000, \"t\");\n    inf.readEoln();\n    for (int i = 0; i < t; ++i) {\n        int xi = inf.readInt(-1000000000, 1000000000, \"xi\");\n        inf.readSpace();\n        int yi = inf.readInt(-1000000000, 1000000000, \"yi\");\n        inf.readEoln();\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\", 0);          // Number of ants\n    int t = opt<int>(\"t\", 1);          // Number of queries\n    string type = opt<string>(\"type\", \"random\"); // Type of test case\n\n    // Constraints\n    const int MIN_N = 0;\n    const int MAX_N = 30000;\n    const int MIN_T = 1;\n    const int MAX_T = 50000;\n    const int MIN_XY = -1000000000;\n    const int MAX_XY = 1000000000;\n\n    // Modify n and t if necessary\n    n = max(MIN_N, min(n, MAX_N));\n    t = max(MIN_T, min(t, MAX_T));\n\n    vector<pair<int,int>> queries(t);\n\n    if (type == \"zero_ants\") {\n        // n = 0\n        n = 0;\n        // Queries can be random\n        for (int i = 0; i < t; ++i) {\n            int x = rnd.next(MIN_XY, MAX_XY);\n            int y = rnd.next(MIN_XY, MAX_XY);\n            queries[i] = make_pair(x, y);\n        }\n    } else if (type == \"one_ant\") {\n        n = 1;\n        // Queries can be random\n        for (int i = 0; i < t; ++i) {\n            int x = rnd.next(MIN_XY, MAX_XY);\n            int y = rnd.next(MIN_XY, MAX_XY);\n            queries[i] = make_pair(x, y);\n        }\n    } else if (type == \"minimal_movement\") {\n        // n = 4\n        n = 4;\n        // Queries around origin\n        for (int i = 0; i < t; ++i) {\n            int x = rnd.next(-10, 10);\n            int y = rnd.next(-10, 10);\n            queries[i] = make_pair(x, y);\n        }\n    } else if (type == \"max_ants\") {\n        n = MAX_N;\n        // Queries can be random\n        for (int i = 0; i < t; ++i) {\n            int x = rnd.next(MIN_XY, MAX_XY);\n            int y = rnd.next(MIN_XY, MAX_XY);\n            queries[i] = make_pair(x, y);\n        }\n    } else if (type == \"max_queries\") {\n        t = MAX_T;\n        // n can be random or specified\n        for (int i = 0; i < t; ++i) {\n            int x = rnd.next(MIN_XY, MAX_XY);\n            int y = rnd.next(MIN_XY, MAX_XY);\n            queries[i] = make_pair(x, y);\n        }\n    } else if (type == \"duplicate_queries\") {\n        n = rnd.next(MIN_N, MAX_N);\n        // Duplicate the same position multiple times\n        int x = rnd.next(MIN_XY, MAX_XY);\n        int y = rnd.next(MIN_XY, MAX_XY);\n        for (int i = 0; i < t; ++i) {\n            queries[i] = make_pair(x, y);\n        }\n    } else if (type == \"extreme_coords\") {\n        n = rnd.next(MIN_N, MAX_N);\n        for (int i = 0; i < t; ++i) {\n            int x = (rnd.next(2) == 0) ? MIN_XY : MAX_XY;\n            int y = (rnd.next(2) == 0) ? MIN_XY : MAX_XY;\n            queries[i] = make_pair(x, y);\n        }\n    } else if (type == \"origin_queries\") {\n        // All queries at (0, 0)\n        for (int i = 0; i < t; ++i) {\n            queries[i] = make_pair(0, 0);\n        }\n    } else if (type == \"near_origin\") {\n        // Positions near origin\n        for (int i = 0; i < t; ++i) {\n            int x = rnd.next(-10, 10);\n            int y = rnd.next(-10, 10);\n            queries[i] = make_pair(x, y);\n        }\n    } else if (type == \"unreachable_positions\") {\n        // Positions that ants cannot reach\n        // Since ants spread from (0,0) only in steps of 1, positions with sum of x and y odd are unreachable\n        for (int i = 0; i < t; ++i) {\n            int x = rnd.next(1, 1000000000);\n            int y = rnd.next(1, 1000000000);\n            if ((x + y) % 2 == 0) y += 1; // Make x + y odd\n            queries[i] = make_pair(x, y);\n        }\n    } else if (type == \"random\") {\n        // Generate random n and t, but n and t should be passed via parameters\n        for (int i = 0; i < t; ++i) {\n            int x = rnd.next(MIN_XY, MAX_XY);\n            int y = rnd.next(MIN_XY, MAX_XY);\n            queries[i] = make_pair(x, y);\n        }\n    } else {\n        // Default case\n        for (int i = 0; i < t; ++i) {\n            int x = rnd.next(MIN_XY, MAX_XY);\n            int y = rnd.next(MIN_XY, MAX_XY);\n            queries[i] = make_pair(x, y);\n        }\n    }\n\n    // Output\n    printf(\"%d %d\\n\", n, t);\n    for (int i = 0; i < t; ++i) {\n        printf(\"%d %d\\n\", queries[i].first, queries[i].second);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\", 0);          // Number of ants\n    int t = opt<int>(\"t\", 1);          // Number of queries\n    string type = opt<string>(\"type\", \"random\"); // Type of test case\n\n    // Constraints\n    const int MIN_N = 0;\n    const int MAX_N = 30000;\n    const int MIN_T = 1;\n    const int MAX_T = 50000;\n    const int MIN_XY = -1000000000;\n    const int MAX_XY = 1000000000;\n\n    // Modify n and t if necessary\n    n = max(MIN_N, min(n, MAX_N));\n    t = max(MIN_T, min(t, MAX_T));\n\n    vector<pair<int,int>> queries(t);\n\n    if (type == \"zero_ants\") {\n        // n = 0\n        n = 0;\n        // Queries can be random\n        for (int i = 0; i < t; ++i) {\n            int x = rnd.next(MIN_XY, MAX_XY);\n            int y = rnd.next(MIN_XY, MAX_XY);\n            queries[i] = make_pair(x, y);\n        }\n    } else if (type == \"one_ant\") {\n        n = 1;\n        // Queries can be random\n        for (int i = 0; i < t; ++i) {\n            int x = rnd.next(MIN_XY, MAX_XY);\n            int y = rnd.next(MIN_XY, MAX_XY);\n            queries[i] = make_pair(x, y);\n        }\n    } else if (type == \"minimal_movement\") {\n        // n = 4\n        n = 4;\n        // Queries around origin\n        for (int i = 0; i < t; ++i) {\n            int x = rnd.next(-10, 10);\n            int y = rnd.next(-10, 10);\n            queries[i] = make_pair(x, y);\n        }\n    } else if (type == \"max_ants\") {\n        n = MAX_N;\n        // Queries can be random\n        for (int i = 0; i < t; ++i) {\n            int x = rnd.next(MIN_XY, MAX_XY);\n            int y = rnd.next(MIN_XY, MAX_XY);\n            queries[i] = make_pair(x, y);\n        }\n    } else if (type == \"max_queries\") {\n        t = MAX_T;\n        // n can be random or specified\n        for (int i = 0; i < t; ++i) {\n            int x = rnd.next(MIN_XY, MAX_XY);\n            int y = rnd.next(MIN_XY, MAX_XY);\n            queries[i] = make_pair(x, y);\n        }\n    } else if (type == \"duplicate_queries\") {\n        n = rnd.next(MIN_N, MAX_N);\n        // Duplicate the same position multiple times\n        int x = rnd.next(MIN_XY, MAX_XY);\n        int y = rnd.next(MIN_XY, MAX_XY);\n        for (int i = 0; i < t; ++i) {\n            queries[i] = make_pair(x, y);\n        }\n    } else if (type == \"extreme_coords\") {\n        n = rnd.next(MIN_N, MAX_N);\n        for (int i = 0; i < t; ++i) {\n            int x = (rnd.next(2) == 0) ? MIN_XY : MAX_XY;\n            int y = (rnd.next(2) == 0) ? MIN_XY : MAX_XY;\n            queries[i] = make_pair(x, y);\n        }\n    } else if (type == \"origin_queries\") {\n        // All queries at (0, 0)\n        for (int i = 0; i < t; ++i) {\n            queries[i] = make_pair(0, 0);\n        }\n    } else if (type == \"near_origin\") {\n        // Positions near origin\n        for (int i = 0; i < t; ++i) {\n            int x = rnd.next(-10, 10);\n            int y = rnd.next(-10, 10);\n            queries[i] = make_pair(x, y);\n        }\n    } else if (type == \"unreachable_positions\") {\n        // Positions that ants cannot reach\n        // Since ants spread from (0,0) only in steps of 1, positions with sum of x and y odd are unreachable\n        for (int i = 0; i < t; ++i) {\n            int x = rnd.next(1, 1000000000);\n            int y = rnd.next(1, 1000000000);\n            if ((x + y) % 2 == 0) y += 1; // Make x + y odd\n            queries[i] = make_pair(x, y);\n        }\n    } else if (type == \"random\") {\n        // Generate random n and t, but n and t should be passed via parameters\n        for (int i = 0; i < t; ++i) {\n            int x = rnd.next(MIN_XY, MAX_XY);\n            int y = rnd.next(MIN_XY, MAX_XY);\n            queries[i] = make_pair(x, y);\n        }\n    } else {\n        // Default case\n        for (int i = 0; i < t; ++i) {\n            int x = rnd.next(MIN_XY, MAX_XY);\n            int y = rnd.next(MIN_XY, MAX_XY);\n            queries[i] = make_pair(x, y);\n        }\n    }\n\n    // Output\n    printf(\"%d %d\\n\", n, t);\n    for (int i = 0; i < t; ++i) {\n        printf(\"%d %d\\n\", queries[i].first, queries[i].second);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 0 -t 1 -type zero_ants\n./gen -n 1 -t 1 -type one_ant\n./gen -n 3 -t 5 -type one_ant\n./gen -n 4 -t 10 -type minimal_movement\n./gen -n 5 -t 10 -type minimal_movement\n./gen -n 1000 -t 100 -type random\n./gen -n 30000 -t 50000 -type max_ants\n./gen -n 30000 -t 50000 -type max_queries\n./gen -n 30000 -t 50000 -type random\n./gen -n 10000 -t 10000 -type duplicate_queries\n./gen -n 10000 -t 10000 -type origin_queries\n./gen -n 5000 -t 5000 -type near_origin\n./gen -n 20000 -t 10000 -type extreme_coords\n./gen -n 20000 -t 10000 -type unreachable_positions\n./gen -n 0 -t 50000 -type zero_ants\n./gen -n 1 -t 50000 -type one_ant\n./gen -n 4 -t 10000 -type minimal_movement\n./gen -n 30000 -t 1 -type max_ants\n./gen -n 9999 -t 49999 -type near_origin\n./gen -n 10000 -t 50000 -type random\n./gen -n 25000 -t 25000 -type extreme_coords\n./gen -n 30000 -t 50000 -type duplicate_queries\n./gen -n 4 -t 1 -type origin_queries\n./gen -n 3 -t 3 -type random\n./gen -n 10 -t 10 -type near_origin\n./gen -n 5000 -t 10000 -type unreachable_positions\n./gen -n 30000 -t 50000 -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:07:26.406517",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "318/E",
      "title": "E. Баланс",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест1 секунда",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеПервая строка содержит целые числа n, v, e (1 ≤ n ≤ 300, 1 ≤ v ≤ 109, 0 ≤ e ≤ 50000).Следующие две строки содержат по n неотрицательных целых чисел каждая — изначальные ai и требуемые объемы bi соответствующих сосудов (0 ≤ ai, bi ≤ v).В следующих e строках содержится описание всех трубок в формате x y (1 ≤ x, y ≤ n, x ≠ y) для трубки, соединяющей сосуды с номерами x и y. Два сосуда могут быть соединены более чем одной трубкой. Считайте, что сосуды пронумерованы некоторым образом от 1 до n.",
      "output_spec": "Выходные данныеВыведите «NO» (без кавычек), если такой последовательности переливаний не существует. Иначе выведите любую подходящую последовательность переливаний в следующем формате. В первой строчке выведите число переливаний k (k не должно превышать 2·n2). В последующих строчках выведите переливания по одному на строке в формате x y d (переливание d литров из сосуда номер x в сосуд номер y, x и y должны быть различны). Для всех операций число d должно быть целым неотрицательным.",
      "sample_tests": "ПримерыВходные данныеСкопировать2 10 11 95 51 2Выходные данныеСкопировать12 1 4Входные данныеСкопировать2 10 05 24 2Выходные данныеСкопироватьNOВходные данныеСкопировать2 10 04 24 2Выходные данныеСкопировать0",
      "description": "ограничение по времени на тест1 секунда\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвыводstdout\n\nВходные данныеПервая строка содержит целые числа n, v, e (1 ≤ n ≤ 300, 1 ≤ v ≤ 109, 0 ≤ e ≤ 50000).Следующие две строки содержат по n неотрицательных целых чисел каждая — изначальные ai и требуемые объемы bi соответствующих сосудов (0 ≤ ai, bi ≤ v).В следующих e строках содержится описание всех трубок в формате x y (1 ≤ x, y ≤ n, x ≠ y) для трубки, соединяющей сосуды с номерами x и y. Два сосуда могут быть соединены более чем одной трубкой. Считайте, что сосуды пронумерованы некоторым образом от 1 до n.\n\nВходные данные\n\nВыходные данныеВыведите «NO» (без кавычек), если такой последовательности переливаний не существует. Иначе выведите любую подходящую последовательность переливаний в следующем формате. В первой строчке выведите число переливаний k (k не должно превышать 2·n2). В последующих строчках выведите переливания по одному на строке в формате x y d (переливание d литров из сосуда номер x в сосуд номер y, x и y должны быть различны). Для всех операций число d должно быть целым неотрицательным.\n\nВыходные данные\n\nВходные данныеСкопировать2 10 11 95 51 2Выходные данныеСкопировать12 1 4Входные данныеСкопировать2 10 05 24 2Выходные данныеСкопироватьNOВходные данныеСкопировать2 10 04 24 2Выходные данныеСкопировать0\n\nВходные данныеСкопировать2 10 11 95 51 2\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать12 1 4\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать2 10 05 24 2\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопироватьNO\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать2 10 04 24 2\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать0\n\nВыходные данныеСкопировать\n\nСкопировать",
      "solutions": [
        {
          "title": "Codeforces Round #188 - Codeforces",
          "content": "Добрый вечер, друзья!За обсуждением животрепещущей темы использования чужого кода в своих решениях можно и не заметить, что приближается зима 188 раунд платформы Codeforces!А ведь мы постарались подготовить для вас набор задач с любопытными (и, как нам хочется думать, не сильно сложными) идеями и понятными условиями.Мы — это авторы задач yaro и Rei, куратор раундов Codeforces Gerald и автор системы MikeMirzayanov. Отдельное спасибо Паше (PavelKunyavskiy) и Артему (RAD) за тестирование и дельные замечания.Последний раз, когда я участвовал в проведении соревнования на Codeforces, раунды еще носили статус \"beta\". Но чем меньше \"beta\", тем больше ответственность. В связи с этим желаю организаторам и авторам еще одного успешно проведенного раунда. Участникам же — нестандартных задач и идей, чистого кода (а также чистой клавиатуры) и побольше правильно сданных решений!Нам представляется непростой задачей оценить уровень сложности задач для всей массы участников, поэтому разбалловка будет динамическая. Все же ради любопытства сделаем следующее предположение об относительной сложности задач: div.1: B-B-C-C-E, div.2: A-B-C-C-E. Угадаем ли?UPD Приносим извинения за проблемы с очередью тестирования Codeforces.В любом случае, нам будет очень приятно, если вы оцените наш раунд (после его завершения): short survey.В упорной борьбе с отрывом в один взлом победителем div.1 стал meret (Jakub Pachocki)!Доступны результаты первого дивизиона, результаты второго дивизиона.Разбор.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/7862",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 1483
        },
        {
          "title": "Codeforces Round #188 (разбор) - Codeforces",
          "content": "Предварительная версия разбора.318A - Чет и нечетВ задаче про четные и нечетные числа требуется понять, как будет выглядеть последовательность чисел от 1 до n, если выписать сначала все нечетные числа, а затем — четные. Для того, чтобы определить, какое число стоит на k-м месте, нужно посчитать индекс в массиве, с которого начнутся четные числа, и вывести соответствующее k либо нечетное число из первой половины массива, либо четное из второй.318B - Энергетические строчкиВ задаче про хэви-метал требуется найти в строке S количество подстрок, начинающихся на одну строчку A и заканчивающихся другой строчкой B. Если мы пометим черным все позиции вхождения в S строки A, белым — позиции вхождения строки B, то получим следующую задачу: посчитать количество пар <черная позиция, белая позиция> (причем именно в таком порядке). Для этого достаточно бежать, к примеру, слева направо и хранить счетчик — количество уже пройденных черных позиций. Тогда если мы встречаем очередную черную позицию, то увеличиваем счетчик на один, если встречаем белую — добавляем к ответу количество пар с данной белой позицией. А это количество — и есть текущее значение счетчика.317A - Превосходная пара318C - Превосходная параКак легко понять эта задача была задачей на аккуратность. В ней труднее не придумать решение, а написать его так, чтобы ни один случай не был забыт.Каждый ход мы заменяем одно из чисел x, y на их сумму x + y и так пока пара чисел на доске не станет m-превосходной (то есть одно из чисел станет не меньше m). Ясно, что заменять на сумму нужно именно меньшее из двух чисел x и y. Действительно, будем говорить что пара чисел x1 ≤ y1 мажорирует пару чисел x2 ≤ y2, если y1 ≥ y2 и x1 ≥ y2. В этой ситуации, если за несколько наших действий из пары x2, y2 мы получим m-превосходную, то применяя те же самые действия к x1, y1 мы получим m-превосходную пару никак не позже. Если x ≤ y, то пара x + y, y мажорирует пару x + y, x. Поэтому путь через x + y, y до m-превосходной никак не длинее, и можно считать что мы выбираем именно эту пару. Теперь действия нашего игрока однозначны.Рассмотрим случаи: x ≤ 0, y ≤ 0 В этом случае наши операции не увеличивают числа на доске, поэтому пара может стать m-превосходной только если она изначально была m-превосходной. x > 0 или y > 0 В этом случае для любого m пара со временем станет m-превосходной. Для того чтобы посчитать точное количество шагов теперь достаточно запустить эмуляцию. Однако если при x > 0 и y > 0 легко видеть что пара <<растет экспоненциально>> (формальнее: лекго видеть что начиная со второго шага сумма x + y увеличивается хотя бы в 3 / 2 раза за каждый ход) и эмуляция работает очень быстро, то в случае x < 0 и y > 0 (или наоборот) числа в паре могут изменяться очень медленно. Особенно хорошо это видно на примере x =  - 1018, y = 1. Поэтому в таком случае необходимо отдельно посчитать количество шагов до момента, когда оба числа станут неотрицательными и только потом запускать эмуляцию. Для x < 0 и y > 0 такое количество шагов равно . 317B - Муравьи318D - МуравьиЗадачу можно представлять себе следующим образом. В вершинах двумерной решетки расставлены неотрицательные целые числа A(x, y). Считаем, что они заданы функцией . В каждый момент времени для каждой вершины P = (x, y) с числом A(x, y) ≥ 4 применяется операция φP, которая уменьшает A(x, y) на 4 и увеличивает A(x, y - 1), A(x, y + 1), A(x - 1, y), A(x + 1, y) на 1. Можно считать, что операция φP применяется ко всей функции A. От нас требуется найти эту функцию в запрашиваемых узлах после того как итерации прекратятся.Ключевое наблюдение для большинства решений состояло в том, что операции φP и φQ для всех точек P и Q коммутируют, то есть φP(φQ(A)) = φQ(φP(A)). Поэтому неважно в каком именно порядке применять операции. В частности, можно считать, что из данной вершины разбегаются сразу все возможные четверки муравьев. Теперь можно запустить прямую эмуляцию процесса в таком виде. В качестве упражнения участникам предлагается проверить, что муравьи никогда не покинут квадрат 200 × 200 с центром в 0 при указанных ограничениях.317C - Баланс318E - БалансВ задаче про сосуды и воду требовалось найти последовательность из порядка n2 переливаний, которая переводит начальную конфигурацию в конечную. Во-первых, утверждается следующее: если в каждой компоненте связности сумма исходных значений и сумма итоговых совпадают, то ответ существует. Назовем сосуд готовым, если текущее и требуемое количество воды в нем совпадают. Опишем сначала решение, которое, вероятно, проще всего пишется. Будем делать сосуды готовыми по очереди. Возьмем произвольную пару еще не готовых сосудов s и t (в s сейчас воды больше, чем нужно, в t — меньше, чем нужно), такую, что их соединяет некоторый простой путь P, при этом если перелить из s в t d литров, то один из сосудов станет готовым. Осталось научиться переливать d литров по пути из s в t. Напишем для этого рекурсивную функцию pour(s, t, d). Пусть t' идет перед t в этом пути, тогда функцию выполнит следующее: перельет из t' сколько возможно (разумеется, не больше d) в t, вызовет pour(s, t', d) и затем перельет из t' в t то, что осталось. Несложно проверить, что никакой сосуд при этом не переполнится. Такой алгоритм производит переливание по пути длины len за 2len элементарных переливаний, в итоге решение делает не более 2n2 операций.317D - Игра со степенямиДавайте для каждого числа x обозначим последовательность его степеней не вылезающих за границы [1..n] через Pow(x): Тогда наша игра состоит в следующем: каждый игрок на очередном шаге выбирает еще не зачеркнутое число x от 1 до n и зачеркивает все числа из Pow(x). Проигрывает не имеющий хода.Легко заметить, что такая игра распадается в сумму нескольких более простых игр. Действительно, назовем число x примитивным (и соответствующую последовательность Pow(x) примитивной), если оно не является степенью никакого числа y < x. Тогда: 1. для любого числа найдется примитивное число x, такое что ; 2. для любых различных примитивных чисел x и y множества Pow(x) и P(y) не пересекаются. Действительно для данного числа k существует ровно одно примитивное x степенью которого k является. Это, например, следует из основной теоремы арифметики: если и d = gcd(α1, α2, ..., αn), то .Таким образом все множество [1..n] разбивается на маленькие примитивные подмножества Pow(x), игра на которых происходит независимо. Наша игра распалась в сумму меньших игр. Теперь необходимо применить теорию Шпрага-Гранди и заметить, что мекс-функция нашей игры является ксором мекс-функций всех игр на примитивных Pow(x). Среди таких игр много совпадающих, что позволит легко вычислить ксор.Для конкретного x, если Pow(x) = {x, x2, ..., xs}, то мекс-функция зависит только от s, но не от самого x. В наших ограничениях s принимает значения от 1 до 29, мекс-функции для всех таких s можно предподсчитать напрямую. Осталось теперь лишь найти количество q(s) примитивных x с данной длиной Pow(x) равной s (более точно нас интересует не количество, а лишь четность этого количества).Ограничения задачи позволяют сделать это \"в лоб\": увеличиваем x от 2 до , если оно не зачеркнуто, находим длину Pow(x) [увеличиваем соответствующее q(s)], и зачеркиваем все числа из Pow(x). Этот цикл найдет все примитивные последовательности длины хотя бы 2. Количество незачеркнутых чисел даст все примитивные последовательности длины 1. Останется лишь посмотреть на их четности и посчитать соответсвующий ксор мексов.Однако можно найти все q(s) и за . Действительно, давайте посмотрим какое-нибудь число и последовательность {x, x2, x3, x4, ..., xs}. Она не является примитивной, только если содержится как подмножество в некоторой большей примитивной последовательности. Количество таких подпоследовательностей длины s в данной примитивной последовательности длины t > s легко найти, действительно это [t / s]. Вспоминая теперь, что притимвные последовательности не пересекаются получаем реккуретную формулу. Используя ее, легко найти все q(s) начиная с q(29) и заканчивая q(1).Замечание: при написании задачи важно не забыть учесть примитивное x = 1.317E - Принцесса и ее теньВ задаче про принцессу Владу требовалось всего-навсего поймать тень. Опишем идею решения. Если на плоскости растет всего одно дерево, то, используя его как преграду для тени, несложно найти подходящую последовательность ходов. Аналогично поступим (использовав какое-либо крайнее дерево), если Влада и Тень находятся далеко, вне квадрата, где могут расти деревья. Осталось понять, что же делать в самой чаще леса! Если между Владой и ее тенью вообще не существует пути, то поймать тень никак не удастся. Иначе рассмотрим кратчайший путь от принцессы до тени, и пойдем принцессой по нему. Будет считать, что этот путь задает нам очередь шагов, которые необходимо сделать. При этом если тень передвигается куда-либо, то добавим ее ход в очередь (иначе говоря, мы идем по пути, состоящему из кратчайшего пути до тени в начальный момент времени и последующих передвижений тени). Алгоритмическая часть на этом закончилась: утверждается, что мы за необходимое число шагов либо поймаем тень, либо выйдем из \"лесного квадрата\". Доказательство опирается на следующую идею: длина пути, по которому мы идем до тени, разве что уменьшается. При этом если она не уменьшается достаточно долго, то раз в k шагов (k — длина пути) происходит смещение на один и тот же ненулевой вектор, следовательно, мы выйдем из \"лесного квадрата\". Стоит отметить, что если наши герои не заперты в лабиринт (могут выйти из \"лесного квадрата\"), то можно вывести их из квадрата по очереди. Но в таком случае для лабиринта все равно придется придумывать способ ловить тень.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/7956",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 318\\s*E"
          },
          "content_length": 9624
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #188 - Codeforces - Code 1",
          "code": "for (int i = 23;i < 30;i++) {\n        ans[i] = 1;\n    }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7862",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #188 - Codeforces - Code 2",
          "code": "for (int i = 23;i < 30;i++) {\n        ans[i] = 1;\n    }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7862",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #188 - Codeforces - Code 3",
          "code": "-1000000000000000000 1 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7862",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #188 - Codeforces - Code 4",
          "code": "...\nlong long x,y,m;\nlong long res;\n...\nint mymx = max(x,y); // int ???\nint mymn = min(x,y); // int ???\n\nx = mymx;\ny = mymn;\n...",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7862",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #188 - Codeforces - Code 5",
          "code": "...\nlong long x,y,m;\nlong long res;\n...\nint mymx = max(x,y); // int ???\nint mymn = min(x,y); // int ???\n\nx = mymx;\ny = mymn;\n...",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7862",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #188 - Codeforces - Code 6",
          "code": "s.size() < 4",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7862",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #188 - Codeforces - Code 7",
          "code": "s.size() - 4",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7862",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #188 - Codeforces - Code 8",
          "code": "#define SZ(x) (int)x.size()",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7862",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #188 - Codeforces - Code 9",
          "code": "Contest rating",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7862",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #188 - Codeforces - Code 10",
          "code": "Взлом не использует генератор\ncom.codeforces.contester.exception.ChallengeIgnoredException: Challenge is ignored because of the challenged submit is not the last accepted now [submissionId=3887152].\ncom.codeforces.contester.processor.impl.ChallengeProcessor.internalProcess(ChallengeProcessor.java:100)    com.codeforces.contester.processor.impl.ChallengeProcessor.process(ChallengeProcessor.java:63)\ncom.codeforces.contester.processor.impl.ChallengeProcessor.process(ChallengeProcessor.java:36)    com.codeforces.contester.processor.RunnableFactory$ProcessorRunnable.run(RunnableFactory.java:51)\ncom.codeforces.contester.ContesterServletRunnable$2.run(ContesterServletRunnable.java:169)\njava.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1110)\njava.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:603)\njava.lang.Thread.run(Thread.java:722)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7862",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #188 - Codeforces - Code 11",
          "code": "Взлом не использует генератор\ncom.codeforces.contester.exception.ChallengeIgnoredException: Challenge is ignored because of the challenged submit is not the last accepted now [submissionId=3887152].\ncom.codeforces.contester.processor.impl.ChallengeProcessor.internalProcess(ChallengeProcessor.java:100)    com.codeforces.contester.processor.impl.ChallengeProcessor.process(ChallengeProcessor.java:63)\ncom.codeforces.contester.processor.impl.ChallengeProcessor.process(ChallengeProcessor.java:36)    com.codeforces.contester.processor.RunnableFactory$ProcessorRunnable.run(RunnableFactory.java:51)\ncom.codeforces.contester.ContesterServletRunnable$2.run(ContesterServletRunnable.java:169)\njava.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1110)\njava.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:603)\njava.lang.Thread.run(Thread.java:722)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7862",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #188 - Codeforces - Code 12",
          "code": "challenged submit is not the last accepted now",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7862",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #188 (разбор) - Codeforces - Code 1",
          "code": "1 1\n1 2\n2 3\n3 5\n5 8\n8 13\n13 21",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7956",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #188 (разбор) - Codeforces - Code 2",
          "code": "1 1\n1 2\n2 3\n3 5\n5 8\n8 13\n13 21",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7956",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #188 (разбор) - Codeforces - Code 3",
          "code": "109 строка:    X = X ^ (((max(0, n - (SQ - 1))) % 2 == 1) ? get(1) : 0);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7956",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #188 (разбор) - Codeforces - Code 4",
          "code": "109 строка:    X = X ^ (((max(0, n - (SQ - 1))) % 2 == 1) ? get(1) : 0);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7956",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #188 (разбор) - Codeforces - Code 5",
          "code": "Thank you for the nice contest and editorial. \nIn \"Ants\" problem, Is there any way to expect the simulation will be converge so fast before we writing brute force code? how to make sure n = 30000 is the worst case?",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7956",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #188 (разбор) - Codeforces - Code 6",
          "code": "Thank you for the nice contest and editorial. \nIn \"Ants\" problem, Is there any way to expect the simulation will be converge so fast before we writing brute force code? how to make sure n = 30000 is the worst case?",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/7956",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #188 (разбор) - Codeforces - Code 7",
          "code": "#include <string.h>\n#include <cstdio>\n#include <map>\nusing namespace std;\nmap<long long ,int>SG;\nint DFS(long long state) {\n    //printf(\"%I64d\\n\",state);getchar();getchar();\n    if(state==0) return 0;\n    if(SG[state]) return SG[state];\n    int len=0;long long tmp=state;\n    while(tmp>0) {\n        len++;\n        tmp>>=1;\n    }\n    bool cnt[100];memset(cnt,0,sizeof(cnt));\n    for(int i=1;i<=len;i++) {\n        long long k=(1<<(i-1)),tmp=state;\n        while(k<=tmp) {\n            tmp&=(((1<<(len+1))-1)^k);//printf(\"%lld\\n\",k);\n            k<<=i;\n\t\t}//printf(\"%lld\\n\",tmp);\n\t\tif(tmp==state) continue;\n        int ret=DFS(tmp);\n        cnt[ret]=1;\n    }\n    for(int i=0;;i++)if(!cnt[i]){\n        //printf(\"%d %d\\n\",len,i);\n        return (SG[state]=i);\n    }\n}\nint main()\n{\n    for(int I=1;I<=29;I++) {\n        printf(\"%d\\n\",DFS((long long )((1<<I)-1)));\n    }\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/7956",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #188 (разбор) - Codeforces - Code 8",
          "code": "#include <string.h>\n#include <cstdio>\n#include <map>\nusing namespace std;\nmap<long long ,int>SG;\nint DFS(long long state) {\n    //printf(\"%I64d\\n\",state);getchar();getchar();\n    if(state==0) return 0;\n    if(SG[state]) return SG[state];\n    int len=0;long long tmp=state;\n    while(tmp>0) {\n        len++;\n        tmp>>=1;\n    }\n    bool cnt[100];memset(cnt,0,sizeof(cnt));\n    for(int i=1;i<=len;i++) {\n        long long k=(1<<(i-1)),tmp=state;\n        while(k<=tmp) {\n            tmp&=(((1<<(len+1))-1)^k);//printf(\"%lld\\n\",k);\n            k<<=i;\n\t\t}//printf(\"%lld\\n\",tmp);\n\t\tif(tmp==state) continue;\n        int ret=DFS(tmp);\n        cnt[ret]=1;\n    }\n    for(int i=0;;i++)if(!cnt[i]){\n        //printf(\"%d %d\\n\",len,i);\n        return (SG[state]=i);\n    }\n}\nint main()\n{\n    for(int I=1;I<=29;I++) {\n        printf(\"%d\\n\",DFS((long long )((1<<I)-1)));\n    }\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/7956",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 300, \"n\");\n    inf.readSpace();\n    int v = inf.readInt(1, 1000000000, \"v\");\n    inf.readSpace();\n    int e = inf.readInt(0, 50000, \"e\");\n    inf.readEoln();\n\n    vector<int> ai = inf.readInts(n, 0, v, \"ai\");\n    inf.readEoln();\n\n    vector<int> bi = inf.readInts(n, 0, v, \"bi\");\n    inf.readEoln();\n\n    for (int i = 0; i < e; ++i) {\n        int x = inf.readInt(1, n, \"x_i\");\n        inf.readSpace();\n        int y = inf.readInt(1, n, \"y_i\");\n        inf.readEoln();\n        ensuref(x != y, \"Edge %d: x_i (%d) should not be equal to y_i (%d)\", i + 1, x, y);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 300, \"n\");\n    inf.readSpace();\n    int v = inf.readInt(1, 1000000000, \"v\");\n    inf.readSpace();\n    int e = inf.readInt(0, 50000, \"e\");\n    inf.readEoln();\n\n    vector<int> ai = inf.readInts(n, 0, v, \"ai\");\n    inf.readEoln();\n\n    vector<int> bi = inf.readInts(n, 0, v, \"bi\");\n    inf.readEoln();\n\n    for (int i = 0; i < e; ++i) {\n        int x = inf.readInt(1, n, \"x_i\");\n        inf.readSpace();\n        int y = inf.readInt(1, n, \"y_i\");\n        inf.readEoln();\n        ensuref(x != y, \"Edge %d: x_i (%d) should not be equal to y_i (%d)\", i + 1, x, y);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 300, \"n\");\n    inf.readSpace();\n    int v = inf.readInt(1, 1000000000, \"v\");\n    inf.readSpace();\n    int e = inf.readInt(0, 50000, \"e\");\n    inf.readEoln();\n\n    vector<int> ai = inf.readInts(n, 0, v, \"ai\");\n    inf.readEoln();\n\n    vector<int> bi = inf.readInts(n, 0, v, \"bi\");\n    inf.readEoln();\n\n    for (int i = 0; i < e; ++i) {\n        int x = inf.readInt(1, n, \"x_i\");\n        inf.readSpace();\n        int y = inf.readInt(1, n, \"y_i\");\n        inf.readEoln();\n        ensuref(x != y, \"Edge %d: x_i (%d) should not be equal to y_i (%d)\", i + 1, x, y);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint n, v, e;\nvector<int> ai, bi;\nvector<set<int>> adj;\n\nbool readAndValidate(InStream &stream, const vector<int>& a, const vector<int>& b, const vector<set<int>>& adj, int n, int v, const char *who) {\n    string firstToken = stream.readToken();\n    if (firstToken == \"NO\") {\n        // Participant says NO\n        return false;\n    } else {\n        // Participant provides a sequence\n        int k = atoi(firstToken.c_str());\n        if (k < 0 || k > 2 * n * n) {\n            stream.quitf(_wa, \"%s: invalid number of transfusions: k = %d, expected 0 <= k <= %d\", who, k, 2 * n * n);\n        }\n        vector<int> amount = a; // current amounts in the vessels\n        // read k transfusions\n        for (int i = 0; i < k; ++i) {\n            int x = stream.readInt(1, n, format(\"%s: x of transfusion %d\", who, i + 1).c_str());\n            int y = stream.readInt(1, n, format(\"%s: y of transfusion %d\", who, i + 1).c_str());\n            int d = stream.readInt(0, v, format(\"%s: amount of transfusion %d\", who, i + 1).c_str());\n            if (x == y) {\n                stream.quitf(_wa, \"%s: in transfusion %d, x == y\", who, i + 1);\n            }\n            if (adj[x].find(y) == adj[x].end()) {\n                stream.quitf(_wa, \"%s: in transfusion %d, vessels %d and %d are not connected directly\", who, i + 1, x, y);\n            }\n            if (amount[x] < d) {\n                stream.quitf(_wa, \"%s: in transfusion %d, not enough water in vessel %d: have %d, need to transfer %d\", who, i + 1, x, amount[x], d);\n            }\n            amount[x] -= d;\n            amount[y] += d;\n            if (amount[x] < 0 || amount[x] > v) {\n                stream.quitf(_wa, \"%s: in transfusion %d, amount in vessel %d out of bounds: %d\", who, i + 1, x, amount[x]);\n            }\n            if (amount[y] < 0 || amount[y] > v) {\n                stream.quitf(_wa, \"%s: in transfusion %d, amount in vessel %d out of bounds: %d\", who, i + 1, y, amount[y]);\n            }\n        }\n        // After all transfusions, check if amounts match desired amounts\n        for (int i = 1; i <= n; ++i) {\n            if (amount[i] != b[i]) {\n                stream.quitf(_wa, \"%s: amount in vessel %d is %d, expected %d\", who, i, amount[i], b[i]);\n            }\n        }\n        return true;\n    }\n}\n\nint main(int argc, char* argv[]) {\n    registerTestlibCmd(argc, argv);\n\n    n = inf.readInt();\n    v = inf.readInt();\n    e = inf.readInt();\n\n    ai.resize(n + 1);\n    bi.resize(n + 1);\n    adj.resize(n + 1);\n\n    for (int i = 1; i <= n; ++i) {\n        ai[i] = inf.readInt(0, v);\n    }\n    for (int i = 1; i <= n; ++i) {\n        bi[i] = inf.readInt(0, v);\n    }\n    for (int i = 0; i < e; ++i) {\n        int x = inf.readInt(1, n);\n        int y = inf.readInt(1, n);\n        adj[x].insert(y);\n        adj[y].insert(x);\n    }\n\n    bool jAns = readAndValidate(ans, ai, bi, adj, n, v, \"Jury\");\n    bool pAns = readAndValidate(ouf, ai, bi, adj, n, v, \"Participant\");\n\n    if (!jAns && !pAns) {\n        quitf(_ok, \"Both outputs are NO\");\n    } else if (!jAns && pAns) {\n        quitf(_fail, \"Participant found a solution, but jury says NO\");\n    } else if (jAns && !pAns) {\n        quitf(_wa, \"Participant outputs NO, but solution exists\");\n    } else {\n        // Both provide a solution, and participant's solution is valid\n        quitf(_ok, \"Participant's answer is correct\");\n    }\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    long long v = opt<long long>(\"v\", 1000000000LL);\n    int e = opt<int>(\"e\", 0);\n    string type = opt<string>(\"type\", \"random\");\n\n    if (n < 1 || n > 300) {\n        fprintf(stderr, \"n must be between 1 and 300\\n\");\n        exit(1);\n    }\n    if (v < 1 || v > 1000000000LL) {\n        fprintf(stderr, \"v must be between 1 and 1e9\\n\");\n        exit(1);\n    }\n    if (e < 0 || e > 50000) {\n        fprintf(stderr, \"e must be between 0 and 50000\\n\");\n        exit(1);\n    }\n\n    vector<long long> ai(n), bi(n);\n    vector<pair<int, int>> edges;\n\n    if (type == \"no_tubes_possible\") {\n        e = 0;\n        for (int i = 0; i < n; ++i) {\n            ai[i] = rnd.next(0LL, v);\n            bi[i] = ai[i];\n        }\n    } else if (type == \"no_tubes_impossible\") {\n        e = 0;\n        for (int i = 0; i < n; ++i) {\n            ai[i] = rnd.next(0LL, v);\n            do {\n                bi[i] = rnd.next(0LL, v);\n            } while (bi[i] == ai[i]);\n        }\n    } else if (type == \"total_water_differs\") {\n        for (int i = 0; i < n; ++i) {\n            ai[i] = rnd.next(0LL, v);\n        }\n        long long total_ai = accumulate(ai.begin(), ai.end(), 0LL);\n        long long total_bi = total_ai + rnd.next(1LL, v);\n        long long remaining = total_bi;\n        for (int i = 0; i < n; ++i) {\n            if (i + 1 == n) {\n                bi[i] = remaining;\n            } else {\n                bi[i] = rnd.next(0LL, min(v, remaining));\n                remaining -= bi[i];\n            }\n            if (bi[i] > v) bi[i] = v;\n            remaining = max(remaining - bi[i], 0LL);\n        }\n    } else if (type == \"disconnected\") {\n        if (n < 2) {\n            fprintf(stderr, \"n must be at least 2 for disconnected type\\n\");\n            exit(1);\n        }\n        // Split vessels into two components\n        int split = n / 2;\n        vector<int> comp1, comp2;\n        for (int i = 0; i < n; ++i) {\n            if (i < split)\n                comp1.push_back(i + 1);\n            else\n                comp2.push_back(i + 1);\n        }\n        // Assign ai and bi\n        long long total_ai = 0, total_bi = 0;\n        for (int idx : comp1) {\n            ai[idx - 1] = rnd.next(0LL, v);\n            bi[idx - 1] = rnd.next(0LL, ai[idx - 1]); // bi <= ai\n            total_ai += ai[idx - 1];\n            total_bi += bi[idx - 1];\n        }\n        for (int idx : comp2) {\n            ai[idx - 1] = rnd.next(0LL, v);\n            bi[idx - 1] = rnd.next(ai[idx - 1], v); // bi >= ai\n            total_ai += ai[idx - 1];\n            total_bi += bi[idx - 1];\n        }\n        // Adjust to make total_ai == total_bi\n        long long diff = total_ai - total_bi;\n        if (diff > 0) {\n            for (int idx : comp2) {\n                long long increase = min(v - bi[idx - 1], diff);\n                bi[idx - 1] += increase;\n                diff -= increase;\n                if (diff == 0) break;\n            }\n        }\n        if (diff > 0) {\n            for (int idx : comp1) {\n                long long decrease = min(bi[idx - 1], diff);\n                bi[idx - 1] -= decrease;\n                diff -= decrease;\n                if (diff == 0) break;\n            }\n        }\n        // Create edges within components\n        for (size_t i = 1; i < comp1.size(); ++i) {\n            edges.push_back(make_pair(comp1[i - 1], comp1[i]));\n        }\n        for (size_t i = 1; i < comp2.size(); ++i) {\n            edges.push_back(make_pair(comp2[i - 1], comp2[i]));\n        }\n        e = edges.size();\n    } else if (type == \"multiple_tubes\") {\n        // Create multiple tubes between random pairs\n        for (int i = 0; i < e; ++i) {\n            int x = rnd.next(1, n);\n            int y = rnd.next(1, n);\n            while (x == y)\n                y = rnd.next(1, n);\n            edges.push_back(make_pair(x, y));\n        }\n        // Random ai and bi\n        for (int i = 0; i < n; ++i) {\n            ai[i] = rnd.next(0LL, v);\n            bi[i] = rnd.next(0LL, v);\n        }\n    } else if (type == \"ai_equals_bi\") {\n        // Random ai, bi = ai\n        for (int i = 0; i < n; ++i) {\n            ai[i] = rnd.next(0LL, v);\n            bi[i] = ai[i];\n        }\n        // Random tubes\n        for (int i = 0; i < e; ++i) {\n            int x = rnd.next(1, n);\n            int y = rnd.next(1, n);\n            while (x == y)\n                y = rnd.next(1, n);\n            edges.push_back(make_pair(x, y));\n        }\n    } else if (type == \"capacity_exceeds\") {\n        // Setup ai and bi so that capacities would be exceeded during transfers if not careful\n        for (int i = 0; i < n; ++i) {\n            ai[i] = v;\n            bi[i] = 0;\n        }\n        // Random tubes\n        for (int i = 0; i < e; ++i) {\n            int x = rnd.next(1, n);\n            int y = rnd.next(1, n);\n            while (x == y)\n                y = rnd.next(1, n);\n            edges.push_back(make_pair(x, y));\n        }\n    } else if (type == \"max_n_e\") {\n        n = 300;\n        e = 50000;\n        for (int i = 0; i < n; ++i) {\n            ai[i] = rnd.next(0LL, v);\n            bi[i] = rnd.next(0LL, v);\n        }\n        // Generate a random connected graph with many edges\n        for (int i = 2; i <= n; ++i) {\n            edges.push_back(make_pair(rnd.next(1, i - 1), i));\n        }\n        while ((int)edges.size() < e) {\n            int x = rnd.next(1, n);\n            int y = rnd.next(1, n);\n            if (x != y)\n                edges.push_back(make_pair(x, y));\n        }\n    } else {\n        // Random case\n        for (int i = 0; i < n; ++i) {\n            ai[i] = rnd.next(0LL, v);\n            bi[i] = rnd.next(0LL, v);\n        }\n        // Random tubes\n        set<pair<int, int>> used_edges;\n        while ((int)edges.size() < e) {\n            int x = rnd.next(1, n);\n            int y = rnd.next(1, n);\n            if (x == y) continue;\n            // Allow multiple tubes between the same pair\n            edges.push_back(make_pair(x, y));\n        }\n    }\n\n    // Output n v e\n    cout << n << \" \" << v << \" \" << e << endl;\n\n    // Output ai\n    for (int i = 0; i < n; ++i) {\n        cout << ai[i];\n        if (i + 1 == n)\n            cout << endl;\n        else\n            cout << \" \";\n    }\n\n    // Output bi\n    for (int i = 0; i < n; ++i) {\n        cout << bi[i];\n        if (i + 1 == n)\n            cout << endl;\n        else\n            cout << \" \";\n    }\n\n    // Output edges\n    for (auto edge : edges) {\n        cout << edge.first << \" \" << edge.second << endl;\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    long long v = opt<long long>(\"v\", 1000000000LL);\n    int e = opt<int>(\"e\", 0);\n    string type = opt<string>(\"type\", \"random\");\n\n    if (n < 1 || n > 300) {\n        fprintf(stderr, \"n must be between 1 and 300\\n\");\n        exit(1);\n    }\n    if (v < 1 || v > 1000000000LL) {\n        fprintf(stderr, \"v must be between 1 and 1e9\\n\");\n        exit(1);\n    }\n    if (e < 0 || e > 50000) {\n        fprintf(stderr, \"e must be between 0 and 50000\\n\");\n        exit(1);\n    }\n\n    vector<long long> ai(n), bi(n);\n    vector<pair<int, int>> edges;\n\n    if (type == \"no_tubes_possible\") {\n        e = 0;\n        for (int i = 0; i < n; ++i) {\n            ai[i] = rnd.next(0LL, v);\n            bi[i] = ai[i];\n        }\n    } else if (type == \"no_tubes_impossible\") {\n        e = 0;\n        for (int i = 0; i < n; ++i) {\n            ai[i] = rnd.next(0LL, v);\n            do {\n                bi[i] = rnd.next(0LL, v);\n            } while (bi[i] == ai[i]);\n        }\n    } else if (type == \"total_water_differs\") {\n        for (int i = 0; i < n; ++i) {\n            ai[i] = rnd.next(0LL, v);\n        }\n        long long total_ai = accumulate(ai.begin(), ai.end(), 0LL);\n        long long total_bi = total_ai + rnd.next(1LL, v);\n        long long remaining = total_bi;\n        for (int i = 0; i < n; ++i) {\n            if (i + 1 == n) {\n                bi[i] = remaining;\n            } else {\n                bi[i] = rnd.next(0LL, min(v, remaining));\n                remaining -= bi[i];\n            }\n            if (bi[i] > v) bi[i] = v;\n            remaining = max(remaining - bi[i], 0LL);\n        }\n    } else if (type == \"disconnected\") {\n        if (n < 2) {\n            fprintf(stderr, \"n must be at least 2 for disconnected type\\n\");\n            exit(1);\n        }\n        // Split vessels into two components\n        int split = n / 2;\n        vector<int> comp1, comp2;\n        for (int i = 0; i < n; ++i) {\n            if (i < split)\n                comp1.push_back(i + 1);\n            else\n                comp2.push_back(i + 1);\n        }\n        // Assign ai and bi\n        long long total_ai = 0, total_bi = 0;\n        for (int idx : comp1) {\n            ai[idx - 1] = rnd.next(0LL, v);\n            bi[idx - 1] = rnd.next(0LL, ai[idx - 1]); // bi <= ai\n            total_ai += ai[idx - 1];\n            total_bi += bi[idx - 1];\n        }\n        for (int idx : comp2) {\n            ai[idx - 1] = rnd.next(0LL, v);\n            bi[idx - 1] = rnd.next(ai[idx - 1], v); // bi >= ai\n            total_ai += ai[idx - 1];\n            total_bi += bi[idx - 1];\n        }\n        // Adjust to make total_ai == total_bi\n        long long diff = total_ai - total_bi;\n        if (diff > 0) {\n            for (int idx : comp2) {\n                long long increase = min(v - bi[idx - 1], diff);\n                bi[idx - 1] += increase;\n                diff -= increase;\n                if (diff == 0) break;\n            }\n        }\n        if (diff > 0) {\n            for (int idx : comp1) {\n                long long decrease = min(bi[idx - 1], diff);\n                bi[idx - 1] -= decrease;\n                diff -= decrease;\n                if (diff == 0) break;\n            }\n        }\n        // Create edges within components\n        for (size_t i = 1; i < comp1.size(); ++i) {\n            edges.push_back(make_pair(comp1[i - 1], comp1[i]));\n        }\n        for (size_t i = 1; i < comp2.size(); ++i) {\n            edges.push_back(make_pair(comp2[i - 1], comp2[i]));\n        }\n        e = edges.size();\n    } else if (type == \"multiple_tubes\") {\n        // Create multiple tubes between random pairs\n        for (int i = 0; i < e; ++i) {\n            int x = rnd.next(1, n);\n            int y = rnd.next(1, n);\n            while (x == y)\n                y = rnd.next(1, n);\n            edges.push_back(make_pair(x, y));\n        }\n        // Random ai and bi\n        for (int i = 0; i < n; ++i) {\n            ai[i] = rnd.next(0LL, v);\n            bi[i] = rnd.next(0LL, v);\n        }\n    } else if (type == \"ai_equals_bi\") {\n        // Random ai, bi = ai\n        for (int i = 0; i < n; ++i) {\n            ai[i] = rnd.next(0LL, v);\n            bi[i] = ai[i];\n        }\n        // Random tubes\n        for (int i = 0; i < e; ++i) {\n            int x = rnd.next(1, n);\n            int y = rnd.next(1, n);\n            while (x == y)\n                y = rnd.next(1, n);\n            edges.push_back(make_pair(x, y));\n        }\n    } else if (type == \"capacity_exceeds\") {\n        // Setup ai and bi so that capacities would be exceeded during transfers if not careful\n        for (int i = 0; i < n; ++i) {\n            ai[i] = v;\n            bi[i] = 0;\n        }\n        // Random tubes\n        for (int i = 0; i < e; ++i) {\n            int x = rnd.next(1, n);\n            int y = rnd.next(1, n);\n            while (x == y)\n                y = rnd.next(1, n);\n            edges.push_back(make_pair(x, y));\n        }\n    } else if (type == \"max_n_e\") {\n        n = 300;\n        e = 50000;\n        for (int i = 0; i < n; ++i) {\n            ai[i] = rnd.next(0LL, v);\n            bi[i] = rnd.next(0LL, v);\n        }\n        // Generate a random connected graph with many edges\n        for (int i = 2; i <= n; ++i) {\n            edges.push_back(make_pair(rnd.next(1, i - 1), i));\n        }\n        while ((int)edges.size() < e) {\n            int x = rnd.next(1, n);\n            int y = rnd.next(1, n);\n            if (x != y)\n                edges.push_back(make_pair(x, y));\n        }\n    } else {\n        // Random case\n        for (int i = 0; i < n; ++i) {\n            ai[i] = rnd.next(0LL, v);\n            bi[i] = rnd.next(0LL, v);\n        }\n        // Random tubes\n        set<pair<int, int>> used_edges;\n        while ((int)edges.size() < e) {\n            int x = rnd.next(1, n);\n            int y = rnd.next(1, n);\n            if (x == y) continue;\n            // Allow multiple tubes between the same pair\n            edges.push_back(make_pair(x, y));\n        }\n    }\n\n    // Output n v e\n    cout << n << \" \" << v << \" \" << e << endl;\n\n    // Output ai\n    for (int i = 0; i < n; ++i) {\n        cout << ai[i];\n        if (i + 1 == n)\n            cout << endl;\n        else\n            cout << \" \";\n    }\n\n    // Output bi\n    for (int i = 0; i < n; ++i) {\n        cout << bi[i];\n        if (i + 1 == n)\n            cout << endl;\n        else\n            cout << \" \";\n    }\n\n    // Output edges\n    for (auto edge : edges) {\n        cout << edge.first << \" \" << edge.second << endl;\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -v 10 -e 0 -type no_tubes_possible\n./gen -n 1 -v 10 -e 0 -type no_tubes_impossible\n./gen -n 2 -v 10 -e 0 -type no_tubes_possible\n./gen -n 2 -v 10 -e 0 -type no_tubes_impossible\n./gen -n 5 -v 20 -e 0 -type total_water_differs\n./gen -n 5 -v 20 -e 3 -type total_water_differs\n./gen -n 10 -v 100 -e 0 -type total_water_differs\n./gen -n 10 -v 100 -e 20 -type disconnected\n./gen -n 10 -v 100 -e 10 -type multiple_tubes\n./gen -n 50 -v 1000 -e 100 -type ai_equals_bi\n./gen -n 100 -v 1000000 -e 1000 -type random\n./gen -n 200 -v 1000000000 -e 5000 -type capacity_exceeds\n./gen -n 300 -v 1000000000 -e 50000 -type max_n_e\n./gen -n 300 -v 1 -e 50000 -type random\n./gen -n 250 -v 500000000 -e 40000 -type multiple_tubes\n./gen -n 50 -v 1000000000 -e 0 -type ai_equals_bi\n./gen -n 70 -v 200000000 -e 1000 -type capacity_exceeds\n./gen -n 150 -v 1000000 -e 10000 -type disconnected\n./gen -n 300 -v 100 -e 50000 -type random\n./gen -n 80 -v 50000 -e 2000 -type total_water_differs\n./gen -n 3 -v 10 -e 3 -type ai_equals_bi\n./gen -n 2 -v 10 -e 1 -type capacity_exceeds\n./gen -n 30 -v 1000 -e 100 -type multiple_tubes\n./gen -n 100 -v 1000 -e 1000 -type random\n./gen -n 150 -v 1000000 -e 10000 -type ai_equals_bi\n./gen -n 200 -v 1000000000 -e 30000 -type capacity_exceeds\n./gen -n 299 -v 999999999 -e 49999 -type random\n./gen -n 300 -v 1 -e 50000 -type multiple_tubes\n./gen -n 1 -v 1 -e 0 -type no_tubes_possible\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:07:28.618140",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "319/A",
      "title": "A. Танцевальный клуб Малека",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест1 секунда",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеВ первой строке содержится двоичное число x длины n, (1 ≤ n ≤ 100).Это число может содержать ведущие нули.",
      "output_spec": "Выходные данныеВыведите сложность данного распределения по модулю 1000000007 (109 + 7).",
      "sample_tests": "ПримерыВходные данныеСкопировать11Выходные данныеСкопировать6Входные данныеСкопировать01Выходные данныеСкопировать2Входные данныеСкопировать1Выходные данныеСкопировать1",
      "description": "A. Танцевальный клуб Малека\n\nограничение по времени на тест1 секунда\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвыводstdout\n\nВходные данныеВ первой строке содержится двоичное число x длины n, (1 ≤ n ≤ 100).Это число может содержать ведущие нули.\n\nВходные данные\n\nВыходные данныеВыведите сложность данного распределения по модулю 1000000007 (109 + 7).\n\nВыходные данные\n\nВходные данныеСкопировать11Выходные данныеСкопировать6Входные данныеСкопировать01Выходные данныеСкопировать2Входные данныеСкопировать1Выходные данныеСкопировать1\n\nВходные данныеСкопировать11\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать6\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать01\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать2\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать1\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать1\n\nВыходные данныеСкопировать\n\nСкопировать",
      "solutions": [
        {
          "title": "Codeforces Round #189 - Codeforces",
          "content": "Привет, Codeforces! :-{DПо случаю двух важных событий в мире спортивного программирования (IOI и ACM ICPC) я и мои друзья (команда Ирана на IOI) решили сделать подарок всем пользователям Codeforces, которые будут участвовать хотя бы в одном из этих двух соревнования, а также всем остальным. :)Этот раунд подготовил я (havaliza), dani1373 и keivan, также нам помогал fab. Я хочу поблагодарить всю команду Codeforces за их усилия в поддержании этого веб-сайта.Надеюсь вам понравится решать задачи так же, как нам понравилось их готовить! ^.^Update 1. Распределение баллов по задачам в Div. 1: 500-1000-1500-2500-2500, в Div. 2 распределение стандартное.Update 2. Большое спасибо пользователю Aksenov239, который очень много помогал нам в подготовке раунда.Update 3. Here is the editorial. To be completed soon :)",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/8063",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 811
        },
        {
          "title": "Codeforces Round #189 — Editorial - Codeforces",
          "content": "320A - Magic NumbersAlthough the input number is very small, solving the problem for arbitrary length numbers using strings is easier. It's easy to prove that a number meeting the following conditions is magical: The number should only consist of digits 1 and 4. The number should begin with digit 1. The number should not contain three consecutive fours (i.e. 444). Here is a sample implementation in C++: #include <iostream>\n#include <string>\n\nusing namespace std;\n\nbool is_magical(string number) {\n\tfor (int i = 0; i < (int)number.size(); i++)\n\t\tif (number[i] != '1' && number[i] != '4')\n\t\t\treturn false;\n\n\tif (number[0] == '4')\n\t\treturn false;\n\n\tif (number.find(\"444\") != number.npos)\n\t\treturn false;\n\n\treturn true;\n}\n\nint main() {\n\tstring number;\n\tcin >> number;\n\n\tif (is_magical(number))\n\t\tcout << \"YES\" << endl;\n\telse\n\t\tcout << \"NO\" << endl;\n\n\treturn 0;\n}320B - Ping-Pong (Easy Version)Imagine the intervals as nodes of a graph and draw directed edges between them as defined in the statement. Now answering the second query would be trivial if you are familiar with graph traversal algorithms like DFS or BFS or even Floyd-Warshall!Here's an implementation using DFS: 3951145And here's an implementation using BFS: 3947426Finally an implementation using Floyd-Warshall: 3945330319A - Malek Dance ClubSolving this problem was easy when you modeled the assignment with two sets of points numbered from 0 to 2n - 1 (inclusive) paired with 2n line segments. Each line segment corresponds to a dance pair. And each pair of intersecting lines increase the complexity by one.Imagine you now the solution for binary string x. Now we want to calculate the answer for 1x and 0x easily. Look at the figure below:The figure shows what happens in a simple case. Whenever you append 0 before x the same structure appears twice in the result. But whenever you append 1 before x the same structure appears twice but the first half of points in right column are swapped with the second half. This increases the number of intersections by size of first half times size of the second half.So if x has length n and f(x) is the complexity of the assignment then we have: f(0x) = 2f(x) f(1x) = 2f(x) + 22n An interesting fact is that f(x) is equal to x2n - 1.319B - Psychos in a LineWill be fixed :) Let's find the murderer! Well, if you look close you see that each psycho is murdered by the nearest psycho on his left which has a greater id. Now let ti be the number of the step which i-th psycho in the line is murdered (not the psycho with id equal to i). Assume j-th psycho in the line be the nearest psycho with a larger id than i-th psycho in the line in his left. As we know j-th psycho kills the i-th psycho. We also now that this happens when all psychos between j and i have been killed. So ti = max(tj + 1, ..., ti - 1) + 1. Now we have a simple O(n2) solution using the above observations. To make things run faster you should be familiar with a classic problem. This problem asks to find the nearest greater element to the left of each element in a array. This problem has a O(n) solution. You can solve it yourself or read about it here. After knowing about all these things it wouldn't be hard to figure out a way to solve this problem efficiently. Here is a cute implementation of what is described above: 3945963 319C - Kalila and Dimna in the Logging IndustryThis problem is equal to finding the minimum cost to cut the last tree completely. Because any cutting operation can be done with no cost afterward. Let dpi be the minimum cost to cut the i-th tree completely. It's easy to figure out that we can calculate dpi if we know the index of the last tree which has been cut completely (j-th tree). Knowing this dpi would be equal to dpj + bjai. So dpi = minj = 1..i - 1(dpj + bjai).Using the above information the problem has an easy dynamic programming solution in O(n2). There's a known method which can be used to improve recursive relations with similar form. It's called Convex Hull Trick. You can read about it here.319D - Have You Ever Heard About the Word?TODO319E - Ping-PongTODO",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/8166",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 319\\s*A"
          },
          "content_length": 4095
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #189 - Codeforces - Code 1",
          "code": "100000\n100000 1 2 3 ... 99999",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8063",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #189 - Codeforces - Code 2",
          "code": "100000\n100000 1 2 3 ... 99999",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8063",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #189 - Codeforces - Code 3",
          "code": "100000  \n100000 99999 99998 ... 1.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8063",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #189 - Codeforces - Code 4",
          "code": "100000  \n100000 99999 99998 ... 1.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8063",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #189 - Codeforces - Code 5",
          "code": "Psychos in a Line",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8063",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #189 - Codeforces - Code 6",
          "code": "100000\n100000 1 2 ... 99997 99999 99998",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8063",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #189 - Codeforces - Code 7",
          "code": "100000\n100000 1 2 ... 99997 99999 99998",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8063",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #189 - Codeforces - Code 8",
          "code": "Time limit exceeded",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8063",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #189 - Codeforces - Code 9",
          "code": "(8 9 10 11 12 13 14 15)(0 1 2 3 4 5 6 7)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8063",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #189 - Codeforces - Code 10",
          "code": "(8 9 10 11 12 13 14 15)(0 1 2 3 4 5 6 7)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8063",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #189 - Codeforces - Code 11",
          "code": "(4 5 6 7)(0 1 2 3)|(12 13 14 15)(8 9 10 11)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8063",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #189 - Codeforces - Code 12",
          "code": "(4 5 6 7)(0 1 2 3)|(12 13 14 15)(8 9 10 11)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8063",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #189 - Codeforces - Code 13",
          "code": "(2 3)(0 1)|(6 7)(4 5)|(10 11)(8 9)|(14 15)(12 13)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8063",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #189 - Codeforces - Code 14",
          "code": "(2 3)(0 1)|(6 7)(4 5)|(10 11)(8 9)|(14 15)(12 13)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8063",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #189 - Codeforces - Code 15",
          "code": "(1)(0)|(3)(2)|(5)(4)|(7)(6)|...",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8063",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #189 - Codeforces - Code 16",
          "code": "(1)(0)|(3)(2)|(5)(4)|(7)(6)|...",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8063",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #189 - Codeforces - Code 17",
          "code": "101\n\n000 101\n001 100\n010 111\n011 110\n100 001\n101 000\n110 011\n111 010\n\n1 * (4 * 4) + 2 * (0 * 0) + 4 * (1 * 1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8063",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #189 - Codeforces - Code 18",
          "code": "101\n\n000 101\n001 100\n010 111\n011 110\n100 001\n101 000\n110 011\n111 010\n\n1 * (4 * 4) + 2 * (0 * 0) + 4 * (1 * 1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8063",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #189 - Codeforces - Code 19",
          "code": "0 ^ 0 = 0\n1 ^ 0 = 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8063",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #189 - Codeforces - Code 20",
          "code": "0 ^ 0 = 0\n1 ^ 0 = 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8063",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #189 - Codeforces - Code 21",
          "code": "0 ^ 1 = 1\n1 ^ 1 = 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8063",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #189 - Codeforces - Code 22",
          "code": "0 ^ 1 = 1\n1 ^ 1 = 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8063",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #189 - Codeforces - Code 23",
          "code": "x=10\nMDC    NFC\n00(0)  10(2)\n01(1)  11(3)\n10(2)  00(0)\n11(3)  01(1)\nans is 4 = 1*2*2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8063",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #189 - Codeforces - Code 24",
          "code": "x=10\nMDC    NFC\n00(0)  10(2)\n01(1)  11(3)\n10(2)  00(0)\n11(3)  01(1)\nans is 4 = 1*2*2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8063",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #189 - Codeforces - Code 25",
          "code": "x=01\nMDC    NFC\n00(0)  01(1)\n01(1)  00(0)\n10(2)  11(3)\n11(3)  10(2)\nans is 2 = 2*1*1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8063",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #189 - Codeforces - Code 26",
          "code": "x=01\nMDC    NFC\n00(0)  01(1)\n01(1)  00(0)\n10(2)  11(3)\n11(3)  10(2)\nans is 2 = 2*1*1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8063",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #189 - Codeforces - Code 27",
          "code": "x=11\nMDC    NFC\n00(0)  11(3)\n01(1)  10(2)\n10(2)  01(1)\n11(3)  00(0)\nans is 6 = 2*1*1 + 1*2*2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8063",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #189 - Codeforces - Code 28",
          "code": "x=11\nMDC    NFC\n00(0)  11(3)\n01(1)  10(2)\n10(2)  01(1)\n11(3)  00(0)\nans is 6 = 2*1*1 + 1*2*2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8063",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #189 - Codeforces - Code 29",
          "code": "foretell(d)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8063",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #189 - Codeforces - Code 30",
          "code": "foretell(d)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8063",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #189 - Codeforces - Code 31",
          "code": "vector <bool> &visited",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8063",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #189 - Codeforces - Code 32",
          "code": "20\n1 1208 1583\n1 -258 729\n1 -409 1201\n1 194 1938\n1 -958 1575\n1 -1466 1752\n2 1 2\n2 1 2\n2 6 5\n1 -1870 1881\n1 -2002 2749\n1 -2002 2984\n1 -2002 3293\n2 2 4\n2 8 10\n2 9 6\n1 -2002 3572\n1 -2002 4175\n1 -2002 4452\n1 -2002 4605",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8063",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #189 - Codeforces - Code 33",
          "code": "20\n1 1208 1583\n1 -258 729\n1 -409 1201\n1 194 1938\n1 -958 1575\n1 -1466 1752\n2 1 2\n2 1 2\n2 6 5\n1 -1870 1881\n1 -2002 2749\n1 -2002 2984\n1 -2002 3293\n2 2 4\n2 8 10\n2 9 6\n1 -2002 3572\n1 -2002 4175\n1 -2002 4452\n1 -2002 4605",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8063",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #189 — Editorial - Codeforces - Code 1",
          "code": "#include <iostream>\n#include <string>\n\nusing namespace std;\n\nbool is_magical(string number) {\n\tfor (int i = 0; i < (int)number.size(); i++)\n\t\tif (number[i] != '1' && number[i] != '4')\n\t\t\treturn false;\n\n\tif (number[0] == '4')\n\t\treturn false;\n\n\tif (number.find(\"444\") != number.npos)\n\t\treturn false;\n\n\treturn true;\n}\n\nint main() {\n\tstring number;\n\tcin >> number;\n\n\tif (is_magical(number))\n\t\tcout << \"YES\" << endl;\n\telse\n\t\tcout << \"NO\" << endl;\n\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/8166",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #189 — Editorial - Codeforces - Code 2",
          "code": "#include <iostream>\n#include <string>\n\nusing namespace std;\n\nbool is_magical(string number) {\n\tfor (int i = 0; i < (int)number.size(); i++)\n\t\tif (number[i] != '1' && number[i] != '4')\n\t\t\treturn false;\n\n\tif (number[0] == '4')\n\t\treturn false;\n\n\tif (number.find(\"444\") != number.npos)\n\t\treturn false;\n\n\treturn true;\n}\n\nint main() {\n\tstring number;\n\tcin >> number;\n\n\tif (is_magical(number))\n\t\tcout << \"YES\" << endl;\n\telse\n\t\tcout << \"NO\" << endl;\n\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/8166",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #189 — Editorial - Codeforces - Code 3",
          "code": "2\n1 1000000000\n1000000000 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8166",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #189 — Editorial - Codeforces - Code 4",
          "code": "2\n1 1000000000\n1000000000 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8166",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #189 — Editorial - Codeforces - Code 5",
          "code": "if (number[i] != '1' && number[i] != '4')\n\t\t\treturn false;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8166",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #189 — Editorial - Codeforces - Code 6",
          "code": "if (number[i] != '1' && number[i] != '4')\n\t\t\treturn false;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8166",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #189 — Editorial - Codeforces - Code 7",
          "code": "Heights:   [10 9 7 8 6 5 3 4 2 1]\nKillTimes: [-1 0 0 1 0 0 0 1 0 0]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8166",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #189 — Editorial - Codeforces - Code 8",
          "code": "Heights:   [10 9 7 8 6 5 3 4 2 1]\nKillTimes: [-1 0 0 1 0 0 0 1 0 0]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8166",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #189 — Editorial - Codeforces - Code 9",
          "code": "Heights:   [1 2 3 4 5 6]\nKillTimes: [-1 -1 -1 -1 -1 -1]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8166",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #189 — Editorial - Codeforces - Code 10",
          "code": "Heights:   [1 2 3 4 5 6]\nKillTimes: [-1 -1 -1 -1 -1 -1]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8166",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #189 — Editorial - Codeforces - Code 11",
          "code": "total number of rounds = 1 + max(KillTimes)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8166",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #189 — Editorial - Codeforces - Code 12",
          "code": "active_killers",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8166",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #189 — Editorial - Codeforces - Code 13",
          "code": "[10] -> Person 0 is the only active killer and their kill_time is -1[10 9] -> Both 0 and 1 are active killers and kill_time[1] = 0\n[10 9 7] -> All 0,1,2 are active killers and kill_time[2] = 0\n[10 9 7 8] -> Now, 7 fails to kill 8, which means that 8 will survive for atleast one more round in comparison to 8. Therefore, kill_time[3] = 1. Further, we notice that height 7 can no longer be the one to kill anyone to the right. Therefore, we can remove them from list of active killers. Further, we can see that the kill_time[1] = 0 which means that despite having a greater height (9) in comparison to current height (8), psycho at index 1 cannot be the one to kill psycho at index 3. Therefore, we can once again remove them list of active killers. So, the new active_killers are 0 and 3.\n[10 9 7 8 6] -> As height 6 is lower than 8, psycho 4 would be killed by psycho 3, and the list of active_killers would have 0, 3 and 4.\n.. the process continues so on.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8166",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #189 — Editorial - Codeforces - Code 14",
          "code": "[10] -> Person 0 is the only active killer and their kill_time is -1[10 9] -> Both 0 and 1 are active killers and kill_time[1] = 0\n[10 9 7] -> All 0,1,2 are active killers and kill_time[2] = 0\n[10 9 7 8] -> Now, 7 fails to kill 8, which means that 8 will survive for atleast one more round in comparison to 8. Therefore, kill_time[3] = 1. Further, we notice that height 7 can no longer be the one to kill anyone to the right. Therefore, we can remove them from list of active killers. Further, we can see that the kill_time[1] = 0 which means that despite having a greater height (9) in comparison to current height (8), psycho at index 1 cannot be the one to kill psycho at index 3. Therefore, we can once again remove them list of active killers. So, the new active_killers are 0 and 3.\n[10 9 7 8 6] -> As height 6 is lower than 8, psycho 4 would be killed by psycho 3, and the list of active_killers would have 0, 3 and 4.\n.. the process continues so on.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8166",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #189 — Editorial - Codeforces - Code 15",
          "code": "std::stack<int> killers;\n    std::vector<int> kill_time(num, 0);\n    kill_time[0] = -1;\n    killers.push(0);\n    for (int i = 1; i < num; ++i) {\n        while (!killers.empty()) {\n            int cur_killer = killers.top();\n            if (kill_time[cur_killer] != -1 && kill_time[cur_killer] < kill_time[i]) {\n                killers.pop();\n            } else if (height[cur_killer] < height[i]) {\n                kill_time[i] = std::max(kill_time[i], kill_time[cur_killer] + 1);\n                killers.pop();\n            } else break;\n        }\n        if (killers.empty()) kill_time[i] = -1;\n        killers.push(i);\n    }\n    std::cout << *std::max_element(kill_time.begin(), kill_time.end()) + 1 << std::endl;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8166",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #189 — Editorial - Codeforces - Code 16",
          "code": "std::stack<int> killers;\n    std::vector<int> kill_time(num, 0);\n    kill_time[0] = -1;\n    killers.push(0);\n    for (int i = 1; i < num; ++i) {\n        while (!killers.empty()) {\n            int cur_killer = killers.top();\n            if (kill_time[cur_killer] != -1 && kill_time[cur_killer] < kill_time[i]) {\n                killers.pop();\n            } else if (height[cur_killer] < height[i]) {\n                kill_time[i] = std::max(kill_time[i], kill_time[cur_killer] + 1);\n                killers.pop();\n            } else break;\n        }\n        if (killers.empty()) kill_time[i] = -1;\n        killers.push(i);\n    }\n    std::cout << *std::max_element(kill_time.begin(), kill_time.end()) + 1 << std::endl;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8166",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #189 — Editorial - Codeforces - Code 17",
          "code": "def ismagic(s: str) -> bool:\n    for i in [\"1\", \"14\", \"144\"]:\n        if s == i:\n            return True\n        elif s.endswith(i):\n            return ismagic(s[:-len(i)]) # remove the suffix\n    return False",
          "language": "Python",
          "source": "https://codeforces.com/blog/entry/8166",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #189 — Editorial - Codeforces - Code 18",
          "code": "def ismagic(s: str) -> bool:\n    for i in [\"1\", \"14\", \"144\"]:\n        if s == i:\n            return True\n        elif s.endswith(i):\n            return ismagic(s[:-len(i)]) # remove the suffix\n    return False",
          "language": "Python",
          "source": "https://codeforces.com/blog/entry/8166",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    string x = inf.readLine(\"[01]{1,100}\", \"x\");\n\n    inf.readEof();\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    string x = inf.readLine(\"[01]{1,100}\", \"x\");\n\n    inf.readEof();\n\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    string x = inf.readLine(\"[01]{1,100}\", \"x\");\n\n    inf.readEof();\n\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    string x;\n\n    if (type == \"all_zeros\") {\n        x = string(n, '0');\n    } else if (type == \"all_ones\") {\n        x = string(n, '1');\n    } else if (type == \"alternating0\") {\n        x = \"\";\n        for (int i = 0; i < n; ++i) {\n            x += (i % 2 == 0) ? '0' : '1';\n        }\n    } else if (type == \"alternating1\") {\n        x = \"\";\n        for (int i = 0; i < n; ++i) {\n            x += (i % 2 == 0) ? '1' : '0';\n        }\n    } else if (type == \"leading_zeros\") {\n        if (n == 1) {\n            x = '0';\n        } else {\n            int num_leading_zeros = rnd.next(1, n-1);\n            x = string(num_leading_zeros, '0');\n            for (int i = num_leading_zeros; i < n; ++i) {\n                x += rnd.next(0,1) ? '1' : '0';\n            }\n        }\n    } else if (type == \"single_one\") {\n        x = string(n, '0');\n        int pos = rnd.next(0, n-1);\n        x[pos] = '1';\n    } else if (type == \"single_zero\") {\n        x = string(n, '1');\n        int pos = rnd.next(0, n-1);\n        x[pos] = '0';\n    } else if (type == \"palindrome\") {\n        x = \"\";\n        for (int i = 0; i < (n+1)/2; ++i) {\n            char c = rnd.next(0,1) ? '1' : '0';\n            x += c;\n        }\n        for (int i = n/2 - 1; i >= 0; --i) {\n            x += x[i];\n        }\n    } else if (type == \"random\") {\n        x = \"\";\n        for (int i = 0; i < n; ++i) {\n            x += rnd.next(0,1) ? '1' : '0';\n        }\n    } else {\n        // Default to random if unknown type\n        x = \"\";\n        for (int i = 0; i < n; ++i) {\n            x += rnd.next(0,1) ? '1' : '0';\n        }    \n    }\n\n    // Ensure the length of x is exactly n\n    assert((int)x.size() == n);\n    printf(\"%s\\n\", x.c_str());\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    string x;\n\n    if (type == \"all_zeros\") {\n        x = string(n, '0');\n    } else if (type == \"all_ones\") {\n        x = string(n, '1');\n    } else if (type == \"alternating0\") {\n        x = \"\";\n        for (int i = 0; i < n; ++i) {\n            x += (i % 2 == 0) ? '0' : '1';\n        }\n    } else if (type == \"alternating1\") {\n        x = \"\";\n        for (int i = 0; i < n; ++i) {\n            x += (i % 2 == 0) ? '1' : '0';\n        }\n    } else if (type == \"leading_zeros\") {\n        if (n == 1) {\n            x = '0';\n        } else {\n            int num_leading_zeros = rnd.next(1, n-1);\n            x = string(num_leading_zeros, '0');\n            for (int i = num_leading_zeros; i < n; ++i) {\n                x += rnd.next(0,1) ? '1' : '0';\n            }\n        }\n    } else if (type == \"single_one\") {\n        x = string(n, '0');\n        int pos = rnd.next(0, n-1);\n        x[pos] = '1';\n    } else if (type == \"single_zero\") {\n        x = string(n, '1');\n        int pos = rnd.next(0, n-1);\n        x[pos] = '0';\n    } else if (type == \"palindrome\") {\n        x = \"\";\n        for (int i = 0; i < (n+1)/2; ++i) {\n            char c = rnd.next(0,1) ? '1' : '0';\n            x += c;\n        }\n        for (int i = n/2 - 1; i >= 0; --i) {\n            x += x[i];\n        }\n    } else if (type == \"random\") {\n        x = \"\";\n        for (int i = 0; i < n; ++i) {\n            x += rnd.next(0,1) ? '1' : '0';\n        }\n    } else {\n        // Default to random if unknown type\n        x = \"\";\n        for (int i = 0; i < n; ++i) {\n            x += rnd.next(0,1) ? '1' : '0';\n        }    \n    }\n\n    // Ensure the length of x is exactly n\n    assert((int)x.size() == n);\n    printf(\"%s\\n\", x.c_str());\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -type all_zeros\n./gen -n 1 -type all_ones\n./gen -n 1 -type random\n\n./gen -n 2 -type alternating0\n./gen -n 2 -type palindrome\n./gen -n 2 -type random\n\n./gen -n 10 -type all_zeros\n./gen -n 10 -type all_ones\n./gen -n 10 -type leading_zeros\n./gen -n 10 -type palindrome\n./gen -n 10 -type random\n\n./gen -n 50 -type alternating0\n./gen -n 50 -type palindrome\n./gen -n 50 -type single_one\n./gen -n 50 -type random\n\n./gen -n 99 -type leading_zeros\n./gen -n 99 -type palindrome\n./gen -n 99 -type random\n\n./gen -n 100 -type all_zeros\n./gen -n 100 -type all_ones\n./gen -n 100 -type single_zero\n./gen -n 100 -type palindrome\n./gen -n 100 -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:07:30.917326",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "319/B",
      "title": "B. Psychos in a Line",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line of input contains integer n denoting the number of psychos, (1 ≤ n ≤ 105). In the second line there will be a list of n space separated distinct integers each in range 1 to n, inclusive — ids of the psychos in the line from left to right.",
      "output_spec": "OutputPrint the number of steps, so that the line remains the same afterward.",
      "sample_tests": "ExamplesInputCopy1010 9 7 8 6 5 3 4 2 1OutputCopy2InputCopy61 2 3 4 5 6OutputCopy0",
      "description": "B. Psychos in a Line\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line of input contains integer n denoting the number of psychos, (1 ≤ n ≤ 105). In the second line there will be a list of n space separated distinct integers each in range 1 to n, inclusive — ids of the psychos in the line from left to right.\n\nOutputPrint the number of steps, so that the line remains the same afterward.\n\nInputCopy1010 9 7 8 6 5 3 4 2 1OutputCopy2InputCopy61 2 3 4 5 6OutputCopy0\n\nInputCopy1010 9 7 8 6 5 3 4 2 1\n\nOutputCopy2\n\nInputCopy61 2 3 4 5 6\n\nOutputCopy0\n\nNoteIn the first sample line of the psychos transforms as follows: [10 9 7 8 6 5 3 4 2 1]  →  [10 8 4]  →  [10]. So, there are two steps.",
      "solutions": [
        {
          "title": "Codeforces Round #189 - Codeforces",
          "content": "Hello, Codeforces! :-{DAs two important events IOI and ACM ICPC are coming soon, me and my friends as the Iranian IOI team decided to prepare a gift for all the Codeforces users who'll soon participate in one of these events, and also everybody else. :)This round authored by me (havaliza), dani1373 and keivan with help from fab. I want to thank all the Codeforces team for their kind and great effort to maintain this website.Hope you enjoy solving the problems as much as we're enjoying preparing them! ^.^Update 1. The score distribution for Div. 1 is 500-1000-1500-2500-2500 and for Div. 2 its regular.Update 2. Special thanks to Aksenov239 who helped us so much to prepare this round.Update 3. Here is the editorial. To be completed soon :)",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/8063",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 746
        },
        {
          "title": "Codeforces Round #189 — Editorial - Codeforces",
          "content": "320A - Magic NumbersAlthough the input number is very small, solving the problem for arbitrary length numbers using strings is easier. It's easy to prove that a number meeting the following conditions is magical: The number should only consist of digits 1 and 4. The number should begin with digit 1. The number should not contain three consecutive fours (i.e. 444). Here is a sample implementation in C++: #include <iostream>\n#include <string>\n\nusing namespace std;\n\nbool is_magical(string number) {\n\tfor (int i = 0; i < (int)number.size(); i++)\n\t\tif (number[i] != '1' && number[i] != '4')\n\t\t\treturn false;\n\n\tif (number[0] == '4')\n\t\treturn false;\n\n\tif (number.find(\"444\") != number.npos)\n\t\treturn false;\n\n\treturn true;\n}\n\nint main() {\n\tstring number;\n\tcin >> number;\n\n\tif (is_magical(number))\n\t\tcout << \"YES\" << endl;\n\telse\n\t\tcout << \"NO\" << endl;\n\n\treturn 0;\n}320B - Ping-Pong (Easy Version)Imagine the intervals as nodes of a graph and draw directed edges between them as defined in the statement. Now answering the second query would be trivial if you are familiar with graph traversal algorithms like DFS or BFS or even Floyd-Warshall!Here's an implementation using DFS: 3951145And here's an implementation using BFS: 3947426Finally an implementation using Floyd-Warshall: 3945330319A - Malek Dance ClubSolving this problem was easy when you modeled the assignment with two sets of points numbered from 0 to 2n - 1 (inclusive) paired with 2n line segments. Each line segment corresponds to a dance pair. And each pair of intersecting lines increase the complexity by one.Imagine you now the solution for binary string x. Now we want to calculate the answer for 1x and 0x easily. Look at the figure below:The figure shows what happens in a simple case. Whenever you append 0 before x the same structure appears twice in the result. But whenever you append 1 before x the same structure appears twice but the first half of points in right column are swapped with the second half. This increases the number of intersections by size of first half times size of the second half.So if x has length n and f(x) is the complexity of the assignment then we have: f(0x) = 2f(x) f(1x) = 2f(x) + 22n An interesting fact is that f(x) is equal to x2n - 1.319B - Psychos in a LineWill be fixed :) Let's find the murderer! Well, if you look close you see that each psycho is murdered by the nearest psycho on his left which has a greater id. Now let ti be the number of the step which i-th psycho in the line is murdered (not the psycho with id equal to i). Assume j-th psycho in the line be the nearest psycho with a larger id than i-th psycho in the line in his left. As we know j-th psycho kills the i-th psycho. We also now that this happens when all psychos between j and i have been killed. So ti = max(tj + 1, ..., ti - 1) + 1. Now we have a simple O(n2) solution using the above observations. To make things run faster you should be familiar with a classic problem. This problem asks to find the nearest greater element to the left of each element in a array. This problem has a O(n) solution. You can solve it yourself or read about it here. After knowing about all these things it wouldn't be hard to figure out a way to solve this problem efficiently. Here is a cute implementation of what is described above: 3945963 319C - Kalila and Dimna in the Logging IndustryThis problem is equal to finding the minimum cost to cut the last tree completely. Because any cutting operation can be done with no cost afterward. Let dpi be the minimum cost to cut the i-th tree completely. It's easy to figure out that we can calculate dpi if we know the index of the last tree which has been cut completely (j-th tree). Knowing this dpi would be equal to dpj + bjai. So dpi = minj = 1..i - 1(dpj + bjai).Using the above information the problem has an easy dynamic programming solution in O(n2). There's a known method which can be used to improve recursive relations with similar form. It's called Convex Hull Trick. You can read about it here.319D - Have You Ever Heard About the Word?TODO319E - Ping-PongTODO",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/8166",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 319\\s*B"
          },
          "content_length": 4095
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #189 - Codeforces - Code 1",
          "code": "Psychos in a Line",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8063",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #189 - Codeforces - Code 2",
          "code": "100000\n100000 1 2 ... 99997 99999 99998",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8063",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #189 - Codeforces - Code 3",
          "code": "100000\n100000 1 2 ... 99997 99999 99998",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8063",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #189 - Codeforces - Code 4",
          "code": "Time limit exceeded",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8063",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #189 - Codeforces - Code 5",
          "code": "(8 9 10 11 12 13 14 15)(0 1 2 3 4 5 6 7)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8063",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #189 - Codeforces - Code 6",
          "code": "(8 9 10 11 12 13 14 15)(0 1 2 3 4 5 6 7)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8063",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #189 - Codeforces - Code 7",
          "code": "(4 5 6 7)(0 1 2 3)|(12 13 14 15)(8 9 10 11)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8063",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #189 - Codeforces - Code 8",
          "code": "(4 5 6 7)(0 1 2 3)|(12 13 14 15)(8 9 10 11)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8063",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #189 - Codeforces - Code 9",
          "code": "(2 3)(0 1)|(6 7)(4 5)|(10 11)(8 9)|(14 15)(12 13)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8063",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #189 - Codeforces - Code 10",
          "code": "(2 3)(0 1)|(6 7)(4 5)|(10 11)(8 9)|(14 15)(12 13)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8063",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #189 - Codeforces - Code 11",
          "code": "(1)(0)|(3)(2)|(5)(4)|(7)(6)|...",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8063",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #189 - Codeforces - Code 12",
          "code": "(1)(0)|(3)(2)|(5)(4)|(7)(6)|...",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8063",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #189 - Codeforces - Code 13",
          "code": "101\n\n000 101\n001 100\n010 111\n011 110\n100 001\n101 000\n110 011\n111 010\n\n1 * (4 * 4) + 2 * (0 * 0) + 4 * (1 * 1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8063",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #189 - Codeforces - Code 14",
          "code": "101\n\n000 101\n001 100\n010 111\n011 110\n100 001\n101 000\n110 011\n111 010\n\n1 * (4 * 4) + 2 * (0 * 0) + 4 * (1 * 1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8063",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #189 - Codeforces - Code 15",
          "code": "0 ^ 0 = 0\n1 ^ 0 = 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8063",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #189 - Codeforces - Code 16",
          "code": "0 ^ 0 = 0\n1 ^ 0 = 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8063",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #189 - Codeforces - Code 17",
          "code": "0 ^ 1 = 1\n1 ^ 1 = 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8063",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #189 - Codeforces - Code 18",
          "code": "0 ^ 1 = 1\n1 ^ 1 = 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8063",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #189 - Codeforces - Code 19",
          "code": "x=10\nMDC    NFC\n00(0)  10(2)\n01(1)  11(3)\n10(2)  00(0)\n11(3)  01(1)\nans is 4 = 1*2*2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8063",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #189 - Codeforces - Code 20",
          "code": "x=10\nMDC    NFC\n00(0)  10(2)\n01(1)  11(3)\n10(2)  00(0)\n11(3)  01(1)\nans is 4 = 1*2*2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8063",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #189 - Codeforces - Code 21",
          "code": "x=01\nMDC    NFC\n00(0)  01(1)\n01(1)  00(0)\n10(2)  11(3)\n11(3)  10(2)\nans is 2 = 2*1*1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8063",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #189 - Codeforces - Code 22",
          "code": "x=01\nMDC    NFC\n00(0)  01(1)\n01(1)  00(0)\n10(2)  11(3)\n11(3)  10(2)\nans is 2 = 2*1*1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8063",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #189 - Codeforces - Code 23",
          "code": "x=11\nMDC    NFC\n00(0)  11(3)\n01(1)  10(2)\n10(2)  01(1)\n11(3)  00(0)\nans is 6 = 2*1*1 + 1*2*2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8063",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #189 - Codeforces - Code 24",
          "code": "x=11\nMDC    NFC\n00(0)  11(3)\n01(1)  10(2)\n10(2)  01(1)\n11(3)  00(0)\nans is 6 = 2*1*1 + 1*2*2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8063",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #189 - Codeforces - Code 25",
          "code": "foretell(d)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8063",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #189 - Codeforces - Code 26",
          "code": "foretell(d)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8063",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #189 - Codeforces - Code 27",
          "code": "vector <bool> &visited",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8063",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #189 - Codeforces - Code 28",
          "code": "20\n1 1208 1583\n1 -258 729\n1 -409 1201\n1 194 1938\n1 -958 1575\n1 -1466 1752\n2 1 2\n2 1 2\n2 6 5\n1 -1870 1881\n1 -2002 2749\n1 -2002 2984\n1 -2002 3293\n2 2 4\n2 8 10\n2 9 6\n1 -2002 3572\n1 -2002 4175\n1 -2002 4452\n1 -2002 4605",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8063",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #189 - Codeforces - Code 29",
          "code": "20\n1 1208 1583\n1 -258 729\n1 -409 1201\n1 194 1938\n1 -958 1575\n1 -1466 1752\n2 1 2\n2 1 2\n2 6 5\n1 -1870 1881\n1 -2002 2749\n1 -2002 2984\n1 -2002 3293\n2 2 4\n2 8 10\n2 9 6\n1 -2002 3572\n1 -2002 4175\n1 -2002 4452\n1 -2002 4605",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8063",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #189 — Editorial - Codeforces - Code 1",
          "code": "#include <iostream>\n#include <string>\n\nusing namespace std;\n\nbool is_magical(string number) {\n\tfor (int i = 0; i < (int)number.size(); i++)\n\t\tif (number[i] != '1' && number[i] != '4')\n\t\t\treturn false;\n\n\tif (number[0] == '4')\n\t\treturn false;\n\n\tif (number.find(\"444\") != number.npos)\n\t\treturn false;\n\n\treturn true;\n}\n\nint main() {\n\tstring number;\n\tcin >> number;\n\n\tif (is_magical(number))\n\t\tcout << \"YES\" << endl;\n\telse\n\t\tcout << \"NO\" << endl;\n\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/8166",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #189 — Editorial - Codeforces - Code 2",
          "code": "#include <iostream>\n#include <string>\n\nusing namespace std;\n\nbool is_magical(string number) {\n\tfor (int i = 0; i < (int)number.size(); i++)\n\t\tif (number[i] != '1' && number[i] != '4')\n\t\t\treturn false;\n\n\tif (number[0] == '4')\n\t\treturn false;\n\n\tif (number.find(\"444\") != number.npos)\n\t\treturn false;\n\n\treturn true;\n}\n\nint main() {\n\tstring number;\n\tcin >> number;\n\n\tif (is_magical(number))\n\t\tcout << \"YES\" << endl;\n\telse\n\t\tcout << \"NO\" << endl;\n\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/8166",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #189 — Editorial - Codeforces - Code 3",
          "code": "2\n1 1000000000\n1000000000 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8166",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #189 — Editorial - Codeforces - Code 4",
          "code": "2\n1 1000000000\n1000000000 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8166",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #189 — Editorial - Codeforces - Code 5",
          "code": "if (number[i] != '1' && number[i] != '4')\n\t\t\treturn false;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8166",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #189 — Editorial - Codeforces - Code 6",
          "code": "if (number[i] != '1' && number[i] != '4')\n\t\t\treturn false;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8166",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #189 — Editorial - Codeforces - Code 7",
          "code": "Heights:   [10 9 7 8 6 5 3 4 2 1]\nKillTimes: [-1 0 0 1 0 0 0 1 0 0]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8166",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #189 — Editorial - Codeforces - Code 8",
          "code": "Heights:   [10 9 7 8 6 5 3 4 2 1]\nKillTimes: [-1 0 0 1 0 0 0 1 0 0]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8166",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #189 — Editorial - Codeforces - Code 9",
          "code": "Heights:   [1 2 3 4 5 6]\nKillTimes: [-1 -1 -1 -1 -1 -1]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8166",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #189 — Editorial - Codeforces - Code 10",
          "code": "Heights:   [1 2 3 4 5 6]\nKillTimes: [-1 -1 -1 -1 -1 -1]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8166",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #189 — Editorial - Codeforces - Code 11",
          "code": "total number of rounds = 1 + max(KillTimes)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8166",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #189 — Editorial - Codeforces - Code 12",
          "code": "active_killers",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8166",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #189 — Editorial - Codeforces - Code 13",
          "code": "[10] -> Person 0 is the only active killer and their kill_time is -1[10 9] -> Both 0 and 1 are active killers and kill_time[1] = 0\n[10 9 7] -> All 0,1,2 are active killers and kill_time[2] = 0\n[10 9 7 8] -> Now, 7 fails to kill 8, which means that 8 will survive for atleast one more round in comparison to 8. Therefore, kill_time[3] = 1. Further, we notice that height 7 can no longer be the one to kill anyone to the right. Therefore, we can remove them from list of active killers. Further, we can see that the kill_time[1] = 0 which means that despite having a greater height (9) in comparison to current height (8), psycho at index 1 cannot be the one to kill psycho at index 3. Therefore, we can once again remove them list of active killers. So, the new active_killers are 0 and 3.\n[10 9 7 8 6] -> As height 6 is lower than 8, psycho 4 would be killed by psycho 3, and the list of active_killers would have 0, 3 and 4.\n.. the process continues so on.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8166",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #189 — Editorial - Codeforces - Code 14",
          "code": "[10] -> Person 0 is the only active killer and their kill_time is -1[10 9] -> Both 0 and 1 are active killers and kill_time[1] = 0\n[10 9 7] -> All 0,1,2 are active killers and kill_time[2] = 0\n[10 9 7 8] -> Now, 7 fails to kill 8, which means that 8 will survive for atleast one more round in comparison to 8. Therefore, kill_time[3] = 1. Further, we notice that height 7 can no longer be the one to kill anyone to the right. Therefore, we can remove them from list of active killers. Further, we can see that the kill_time[1] = 0 which means that despite having a greater height (9) in comparison to current height (8), psycho at index 1 cannot be the one to kill psycho at index 3. Therefore, we can once again remove them list of active killers. So, the new active_killers are 0 and 3.\n[10 9 7 8 6] -> As height 6 is lower than 8, psycho 4 would be killed by psycho 3, and the list of active_killers would have 0, 3 and 4.\n.. the process continues so on.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8166",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #189 — Editorial - Codeforces - Code 15",
          "code": "std::stack<int> killers;\n    std::vector<int> kill_time(num, 0);\n    kill_time[0] = -1;\n    killers.push(0);\n    for (int i = 1; i < num; ++i) {\n        while (!killers.empty()) {\n            int cur_killer = killers.top();\n            if (kill_time[cur_killer] != -1 && kill_time[cur_killer] < kill_time[i]) {\n                killers.pop();\n            } else if (height[cur_killer] < height[i]) {\n                kill_time[i] = std::max(kill_time[i], kill_time[cur_killer] + 1);\n                killers.pop();\n            } else break;\n        }\n        if (killers.empty()) kill_time[i] = -1;\n        killers.push(i);\n    }\n    std::cout << *std::max_element(kill_time.begin(), kill_time.end()) + 1 << std::endl;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8166",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #189 — Editorial - Codeforces - Code 16",
          "code": "std::stack<int> killers;\n    std::vector<int> kill_time(num, 0);\n    kill_time[0] = -1;\n    killers.push(0);\n    for (int i = 1; i < num; ++i) {\n        while (!killers.empty()) {\n            int cur_killer = killers.top();\n            if (kill_time[cur_killer] != -1 && kill_time[cur_killer] < kill_time[i]) {\n                killers.pop();\n            } else if (height[cur_killer] < height[i]) {\n                kill_time[i] = std::max(kill_time[i], kill_time[cur_killer] + 1);\n                killers.pop();\n            } else break;\n        }\n        if (killers.empty()) kill_time[i] = -1;\n        killers.push(i);\n    }\n    std::cout << *std::max_element(kill_time.begin(), kill_time.end()) + 1 << std::endl;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8166",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #189 — Editorial - Codeforces - Code 17",
          "code": "def ismagic(s: str) -> bool:\n    for i in [\"1\", \"14\", \"144\"]:\n        if s == i:\n            return True\n        elif s.endswith(i):\n            return ismagic(s[:-len(i)]) # remove the suffix\n    return False",
          "language": "Python",
          "source": "https://codeforces.com/blog/entry/8166",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #189 — Editorial - Codeforces - Code 18",
          "code": "def ismagic(s: str) -> bool:\n    for i in [\"1\", \"14\", \"144\"]:\n        if s == i:\n            return True\n        elif s.endswith(i):\n            return ismagic(s[:-len(i)]) # remove the suffix\n    return False",
          "language": "Python",
          "source": "https://codeforces.com/blog/entry/8166",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n \nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n    vector<int> ids = inf.readInts(n, 1, n);\n    inf.readEoln();\n    set<int> id_set(ids.begin(), ids.end());\n    ensuref((int)id_set.size() == n, \"All ids must be distinct\");\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n \nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n    vector<int> ids = inf.readInts(n, 1, n);\n    inf.readEoln();\n    set<int> id_set(ids.begin(), ids.end());\n    ensuref((int)id_set.size() == n, \"All ids must be distinct\");\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n \nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n    vector<int> ids = inf.readInts(n, 1, n);\n    inf.readEoln();\n    set<int> id_set(ids.begin(), ids.end());\n    ensuref((int)id_set.size() == n, \"All ids must be distinct\");\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> ids(n);\n\n    if (type == \"sorted_increasing\") {\n        // IDs from 1 to n\n        for (int i = 0; i < n; ++i)\n            ids[i] = i + 1;\n    } else if (type == \"sorted_decreasing\") {\n        // IDs from n to 1\n        for (int i = 0; i < n; ++i)\n            ids[i] = n - i;\n    } else if (type == \"random\") {\n        // Random permutation of IDs from 1 to n\n        for (int i = 0; i < n; ++i)\n            ids[i] = i + 1;\n        shuffle(ids.begin(), ids.end());\n    } else if (type == \"alternating_high_low\") {\n        // IDs alternate between high and low values\n        int left = 1, right = n;\n        for (int i = 0; i < n; ++i) {\n            if (i % 2 == 0)\n                ids[i] = right--;\n            else\n                ids[i] = left++;\n        }\n    } else if (type == \"max_steps\") {\n        // Attempt to create a sequence with maximum steps\n        // IDs increase up to n/2 and then decrease\n        int mid = n / 2;\n        for (int i = 0; i < mid; ++i)\n            ids[i] = i + 1;\n        for (int i = mid; i < n; ++i)\n            ids[i] = n - i + mid;\n    } else {\n        // Default: random permutation\n        for (int i = 0; i < n; ++i)\n            ids[i] = i + 1;\n        shuffle(ids.begin(), ids.end());\n    }\n\n    // Output the test case\n    printf(\"%d\\n\", n);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d\", ids[i]);\n        if (i < n - 1)\n            printf(\" \");\n    }\n    printf(\"\\n\");\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> ids(n);\n\n    if (type == \"sorted_increasing\") {\n        // IDs from 1 to n\n        for (int i = 0; i < n; ++i)\n            ids[i] = i + 1;\n    } else if (type == \"sorted_decreasing\") {\n        // IDs from n to 1\n        for (int i = 0; i < n; ++i)\n            ids[i] = n - i;\n    } else if (type == \"random\") {\n        // Random permutation of IDs from 1 to n\n        for (int i = 0; i < n; ++i)\n            ids[i] = i + 1;\n        shuffle(ids.begin(), ids.end());\n    } else if (type == \"alternating_high_low\") {\n        // IDs alternate between high and low values\n        int left = 1, right = n;\n        for (int i = 0; i < n; ++i) {\n            if (i % 2 == 0)\n                ids[i] = right--;\n            else\n                ids[i] = left++;\n        }\n    } else if (type == \"max_steps\") {\n        // Attempt to create a sequence with maximum steps\n        // IDs increase up to n/2 and then decrease\n        int mid = n / 2;\n        for (int i = 0; i < mid; ++i)\n            ids[i] = i + 1;\n        for (int i = mid; i < n; ++i)\n            ids[i] = n - i + mid;\n    } else {\n        // Default: random permutation\n        for (int i = 0; i < n; ++i)\n            ids[i] = i + 1;\n        shuffle(ids.begin(), ids.end());\n    }\n\n    // Output the test case\n    printf(\"%d\\n\", n);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d\", ids[i]);\n        if (i < n - 1)\n            printf(\" \");\n    }\n    printf(\"\\n\");\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -type sorted_increasing\n./gen -n 1 -type sorted_decreasing\n\n./gen -n 2 -type sorted_increasing\n./gen -n 2 -type sorted_decreasing\n./gen -n 2 -type random\n\n./gen -n 5 -type random\n./gen -n 5 -type alternating_high_low\n\n./gen -n 10 -type sorted_increasing\n./gen -n 10 -type sorted_decreasing\n./gen -n 10 -type random\n./gen -n 10 -type alternating_high_low\n./gen -n 10 -type max_steps\n\n./gen -n 100 -type sorted_increasing\n./gen -n 100 -type sorted_decreasing\n./gen -n 100 -type random\n./gen -n 100 -type alternating_high_low\n./gen -n 100 -type max_steps\n\n./gen -n 1000 -type random\n./gen -n 1000 -type alternating_high_low\n./gen -n 1000 -type max_steps\n\n./gen -n 5000 -type random\n./gen -n 5000 -type alternating_high_low\n./gen -n 5000 -type max_steps\n\n./gen -n 10000 -type sorted_increasing\n./gen -n 10000 -type sorted_decreasing\n./gen -n 10000 -type random\n./gen -n 10000 -type alternating_high_low\n./gen -n 10000 -type max_steps\n\n./gen -n 50000 -type random\n./gen -n 50000 -type alternating_high_low\n./gen -n 50000 -type max_steps\n\n./gen -n 100000 -type sorted_increasing\n./gen -n 100000 -type sorted_decreasing\n./gen -n 100000 -type random\n./gen -n 100000 -type alternating_high_low\n./gen -n 100000 -type max_steps\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:07:33.223868",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "319/C",
      "title": "C. Kalila and Dimna in the Logging Industry",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line of input contains an integer n (1 ≤ n ≤ 105). The second line of input contains n integers a1, a2, ..., an (1 ≤ ai ≤ 109). The third line of input contains n integers b1, b2, ..., bn (0 ≤ bi ≤ 109).It's guaranteed that a1 = 1, bn = 0, a1 < a2 < ... < an and b1 > b2 > ... > bn.",
      "output_spec": "OutputThe only line of output must contain the minimum cost of cutting all the trees completely.Please, do not write the %lld specifier to read or write 64-bit integers in С++. It is preferred to use the cin, cout streams or the %I64d specifier.",
      "sample_tests": "ExamplesInputCopy51 2 3 4 55 4 3 2 0OutputCopy25InputCopy61 2 3 10 20 306 5 4 3 2 0OutputCopy138",
      "description": "C. Kalila and Dimna in the Logging Industry\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line of input contains an integer n (1 ≤ n ≤ 105). The second line of input contains n integers a1, a2, ..., an (1 ≤ ai ≤ 109). The third line of input contains n integers b1, b2, ..., bn (0 ≤ bi ≤ 109).It's guaranteed that a1 = 1, bn = 0, a1 < a2 < ... < an and b1 > b2 > ... > bn.\n\nOutputThe only line of output must contain the minimum cost of cutting all the trees completely.Please, do not write the %lld specifier to read or write 64-bit integers in С++. It is preferred to use the cin, cout streams or the %I64d specifier.\n\nInputCopy51 2 3 4 55 4 3 2 0OutputCopy25InputCopy61 2 3 10 20 306 5 4 3 2 0OutputCopy138\n\nInputCopy51 2 3 4 55 4 3 2 0\n\nOutputCopy25\n\nInputCopy61 2 3 10 20 306 5 4 3 2 0\n\nOutputCopy138",
      "solutions": [
        {
          "title": "Codeforces Round #189 - Codeforces",
          "content": "Hello, Codeforces! :-{DAs two important events IOI and ACM ICPC are coming soon, me and my friends as the Iranian IOI team decided to prepare a gift for all the Codeforces users who'll soon participate in one of these events, and also everybody else. :)This round authored by me (havaliza), dani1373 and keivan with help from fab. I want to thank all the Codeforces team for their kind and great effort to maintain this website.Hope you enjoy solving the problems as much as we're enjoying preparing them! ^.^Update 1. The score distribution for Div. 1 is 500-1000-1500-2500-2500 and for Div. 2 its regular.Update 2. Special thanks to Aksenov239 who helped us so much to prepare this round.Update 3. Here is the editorial. To be completed soon :)",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/8063",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 746
        },
        {
          "title": "Codeforces Round #189 — Editorial - Codeforces",
          "content": "320A - Magic NumbersAlthough the input number is very small, solving the problem for arbitrary length numbers using strings is easier. It's easy to prove that a number meeting the following conditions is magical: The number should only consist of digits 1 and 4. The number should begin with digit 1. The number should not contain three consecutive fours (i.e. 444). Here is a sample implementation in C++: #include <iostream>\n#include <string>\n\nusing namespace std;\n\nbool is_magical(string number) {\n\tfor (int i = 0; i < (int)number.size(); i++)\n\t\tif (number[i] != '1' && number[i] != '4')\n\t\t\treturn false;\n\n\tif (number[0] == '4')\n\t\treturn false;\n\n\tif (number.find(\"444\") != number.npos)\n\t\treturn false;\n\n\treturn true;\n}\n\nint main() {\n\tstring number;\n\tcin >> number;\n\n\tif (is_magical(number))\n\t\tcout << \"YES\" << endl;\n\telse\n\t\tcout << \"NO\" << endl;\n\n\treturn 0;\n}320B - Ping-Pong (Easy Version)Imagine the intervals as nodes of a graph and draw directed edges between them as defined in the statement. Now answering the second query would be trivial if you are familiar with graph traversal algorithms like DFS or BFS or even Floyd-Warshall!Here's an implementation using DFS: 3951145And here's an implementation using BFS: 3947426Finally an implementation using Floyd-Warshall: 3945330319A - Malek Dance ClubSolving this problem was easy when you modeled the assignment with two sets of points numbered from 0 to 2n - 1 (inclusive) paired with 2n line segments. Each line segment corresponds to a dance pair. And each pair of intersecting lines increase the complexity by one.Imagine you now the solution for binary string x. Now we want to calculate the answer for 1x and 0x easily. Look at the figure below:The figure shows what happens in a simple case. Whenever you append 0 before x the same structure appears twice in the result. But whenever you append 1 before x the same structure appears twice but the first half of points in right column are swapped with the second half. This increases the number of intersections by size of first half times size of the second half.So if x has length n and f(x) is the complexity of the assignment then we have: f(0x) = 2f(x) f(1x) = 2f(x) + 22n An interesting fact is that f(x) is equal to x2n - 1.319B - Psychos in a LineWill be fixed :) Let's find the murderer! Well, if you look close you see that each psycho is murdered by the nearest psycho on his left which has a greater id. Now let ti be the number of the step which i-th psycho in the line is murdered (not the psycho with id equal to i). Assume j-th psycho in the line be the nearest psycho with a larger id than i-th psycho in the line in his left. As we know j-th psycho kills the i-th psycho. We also now that this happens when all psychos between j and i have been killed. So ti = max(tj + 1, ..., ti - 1) + 1. Now we have a simple O(n2) solution using the above observations. To make things run faster you should be familiar with a classic problem. This problem asks to find the nearest greater element to the left of each element in a array. This problem has a O(n) solution. You can solve it yourself or read about it here. After knowing about all these things it wouldn't be hard to figure out a way to solve this problem efficiently. Here is a cute implementation of what is described above: 3945963 319C - Kalila and Dimna in the Logging IndustryThis problem is equal to finding the minimum cost to cut the last tree completely. Because any cutting operation can be done with no cost afterward. Let dpi be the minimum cost to cut the i-th tree completely. It's easy to figure out that we can calculate dpi if we know the index of the last tree which has been cut completely (j-th tree). Knowing this dpi would be equal to dpj + bjai. So dpi = minj = 1..i - 1(dpj + bjai).Using the above information the problem has an easy dynamic programming solution in O(n2). There's a known method which can be used to improve recursive relations with similar form. It's called Convex Hull Trick. You can read about it here.319D - Have You Ever Heard About the Word?TODO319E - Ping-PongTODO",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/8166",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 319\\s*C"
          },
          "content_length": 4095
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #189 - Codeforces - Code 1",
          "code": "Psychos in a Line",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8063",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #189 - Codeforces - Code 2",
          "code": "100000\n100000 1 2 ... 99997 99999 99998",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8063",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #189 - Codeforces - Code 3",
          "code": "100000\n100000 1 2 ... 99997 99999 99998",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8063",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #189 - Codeforces - Code 4",
          "code": "Time limit exceeded",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8063",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #189 - Codeforces - Code 5",
          "code": "(8 9 10 11 12 13 14 15)(0 1 2 3 4 5 6 7)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8063",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #189 - Codeforces - Code 6",
          "code": "(8 9 10 11 12 13 14 15)(0 1 2 3 4 5 6 7)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8063",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #189 - Codeforces - Code 7",
          "code": "(4 5 6 7)(0 1 2 3)|(12 13 14 15)(8 9 10 11)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8063",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #189 - Codeforces - Code 8",
          "code": "(4 5 6 7)(0 1 2 3)|(12 13 14 15)(8 9 10 11)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8063",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #189 - Codeforces - Code 9",
          "code": "(2 3)(0 1)|(6 7)(4 5)|(10 11)(8 9)|(14 15)(12 13)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8063",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #189 - Codeforces - Code 10",
          "code": "(2 3)(0 1)|(6 7)(4 5)|(10 11)(8 9)|(14 15)(12 13)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8063",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #189 - Codeforces - Code 11",
          "code": "(1)(0)|(3)(2)|(5)(4)|(7)(6)|...",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8063",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #189 - Codeforces - Code 12",
          "code": "(1)(0)|(3)(2)|(5)(4)|(7)(6)|...",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8063",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #189 - Codeforces - Code 13",
          "code": "101\n\n000 101\n001 100\n010 111\n011 110\n100 001\n101 000\n110 011\n111 010\n\n1 * (4 * 4) + 2 * (0 * 0) + 4 * (1 * 1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8063",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #189 - Codeforces - Code 14",
          "code": "101\n\n000 101\n001 100\n010 111\n011 110\n100 001\n101 000\n110 011\n111 010\n\n1 * (4 * 4) + 2 * (0 * 0) + 4 * (1 * 1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8063",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #189 - Codeforces - Code 15",
          "code": "0 ^ 0 = 0\n1 ^ 0 = 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8063",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #189 - Codeforces - Code 16",
          "code": "0 ^ 0 = 0\n1 ^ 0 = 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8063",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #189 - Codeforces - Code 17",
          "code": "0 ^ 1 = 1\n1 ^ 1 = 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8063",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #189 - Codeforces - Code 18",
          "code": "0 ^ 1 = 1\n1 ^ 1 = 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8063",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #189 - Codeforces - Code 19",
          "code": "x=10\nMDC    NFC\n00(0)  10(2)\n01(1)  11(3)\n10(2)  00(0)\n11(3)  01(1)\nans is 4 = 1*2*2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8063",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #189 - Codeforces - Code 20",
          "code": "x=10\nMDC    NFC\n00(0)  10(2)\n01(1)  11(3)\n10(2)  00(0)\n11(3)  01(1)\nans is 4 = 1*2*2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8063",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #189 - Codeforces - Code 21",
          "code": "x=01\nMDC    NFC\n00(0)  01(1)\n01(1)  00(0)\n10(2)  11(3)\n11(3)  10(2)\nans is 2 = 2*1*1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8063",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #189 - Codeforces - Code 22",
          "code": "x=01\nMDC    NFC\n00(0)  01(1)\n01(1)  00(0)\n10(2)  11(3)\n11(3)  10(2)\nans is 2 = 2*1*1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8063",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #189 - Codeforces - Code 23",
          "code": "x=11\nMDC    NFC\n00(0)  11(3)\n01(1)  10(2)\n10(2)  01(1)\n11(3)  00(0)\nans is 6 = 2*1*1 + 1*2*2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8063",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #189 - Codeforces - Code 24",
          "code": "x=11\nMDC    NFC\n00(0)  11(3)\n01(1)  10(2)\n10(2)  01(1)\n11(3)  00(0)\nans is 6 = 2*1*1 + 1*2*2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8063",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #189 - Codeforces - Code 25",
          "code": "foretell(d)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8063",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #189 - Codeforces - Code 26",
          "code": "foretell(d)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8063",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #189 - Codeforces - Code 27",
          "code": "vector <bool> &visited",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8063",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #189 - Codeforces - Code 28",
          "code": "20\n1 1208 1583\n1 -258 729\n1 -409 1201\n1 194 1938\n1 -958 1575\n1 -1466 1752\n2 1 2\n2 1 2\n2 6 5\n1 -1870 1881\n1 -2002 2749\n1 -2002 2984\n1 -2002 3293\n2 2 4\n2 8 10\n2 9 6\n1 -2002 3572\n1 -2002 4175\n1 -2002 4452\n1 -2002 4605",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8063",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #189 - Codeforces - Code 29",
          "code": "20\n1 1208 1583\n1 -258 729\n1 -409 1201\n1 194 1938\n1 -958 1575\n1 -1466 1752\n2 1 2\n2 1 2\n2 6 5\n1 -1870 1881\n1 -2002 2749\n1 -2002 2984\n1 -2002 3293\n2 2 4\n2 8 10\n2 9 6\n1 -2002 3572\n1 -2002 4175\n1 -2002 4452\n1 -2002 4605",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8063",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #189 — Editorial - Codeforces - Code 1",
          "code": "#include <iostream>\n#include <string>\n\nusing namespace std;\n\nbool is_magical(string number) {\n\tfor (int i = 0; i < (int)number.size(); i++)\n\t\tif (number[i] != '1' && number[i] != '4')\n\t\t\treturn false;\n\n\tif (number[0] == '4')\n\t\treturn false;\n\n\tif (number.find(\"444\") != number.npos)\n\t\treturn false;\n\n\treturn true;\n}\n\nint main() {\n\tstring number;\n\tcin >> number;\n\n\tif (is_magical(number))\n\t\tcout << \"YES\" << endl;\n\telse\n\t\tcout << \"NO\" << endl;\n\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/8166",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #189 — Editorial - Codeforces - Code 2",
          "code": "#include <iostream>\n#include <string>\n\nusing namespace std;\n\nbool is_magical(string number) {\n\tfor (int i = 0; i < (int)number.size(); i++)\n\t\tif (number[i] != '1' && number[i] != '4')\n\t\t\treturn false;\n\n\tif (number[0] == '4')\n\t\treturn false;\n\n\tif (number.find(\"444\") != number.npos)\n\t\treturn false;\n\n\treturn true;\n}\n\nint main() {\n\tstring number;\n\tcin >> number;\n\n\tif (is_magical(number))\n\t\tcout << \"YES\" << endl;\n\telse\n\t\tcout << \"NO\" << endl;\n\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/8166",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #189 — Editorial - Codeforces - Code 3",
          "code": "2\n1 1000000000\n1000000000 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8166",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #189 — Editorial - Codeforces - Code 4",
          "code": "2\n1 1000000000\n1000000000 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8166",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #189 — Editorial - Codeforces - Code 5",
          "code": "if (number[i] != '1' && number[i] != '4')\n\t\t\treturn false;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8166",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #189 — Editorial - Codeforces - Code 6",
          "code": "if (number[i] != '1' && number[i] != '4')\n\t\t\treturn false;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8166",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #189 — Editorial - Codeforces - Code 7",
          "code": "Heights:   [10 9 7 8 6 5 3 4 2 1]\nKillTimes: [-1 0 0 1 0 0 0 1 0 0]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8166",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #189 — Editorial - Codeforces - Code 8",
          "code": "Heights:   [10 9 7 8 6 5 3 4 2 1]\nKillTimes: [-1 0 0 1 0 0 0 1 0 0]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8166",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #189 — Editorial - Codeforces - Code 9",
          "code": "Heights:   [1 2 3 4 5 6]\nKillTimes: [-1 -1 -1 -1 -1 -1]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8166",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #189 — Editorial - Codeforces - Code 10",
          "code": "Heights:   [1 2 3 4 5 6]\nKillTimes: [-1 -1 -1 -1 -1 -1]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8166",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #189 — Editorial - Codeforces - Code 11",
          "code": "total number of rounds = 1 + max(KillTimes)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8166",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #189 — Editorial - Codeforces - Code 12",
          "code": "active_killers",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8166",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #189 — Editorial - Codeforces - Code 13",
          "code": "[10] -> Person 0 is the only active killer and their kill_time is -1[10 9] -> Both 0 and 1 are active killers and kill_time[1] = 0\n[10 9 7] -> All 0,1,2 are active killers and kill_time[2] = 0\n[10 9 7 8] -> Now, 7 fails to kill 8, which means that 8 will survive for atleast one more round in comparison to 8. Therefore, kill_time[3] = 1. Further, we notice that height 7 can no longer be the one to kill anyone to the right. Therefore, we can remove them from list of active killers. Further, we can see that the kill_time[1] = 0 which means that despite having a greater height (9) in comparison to current height (8), psycho at index 1 cannot be the one to kill psycho at index 3. Therefore, we can once again remove them list of active killers. So, the new active_killers are 0 and 3.\n[10 9 7 8 6] -> As height 6 is lower than 8, psycho 4 would be killed by psycho 3, and the list of active_killers would have 0, 3 and 4.\n.. the process continues so on.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8166",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #189 — Editorial - Codeforces - Code 14",
          "code": "[10] -> Person 0 is the only active killer and their kill_time is -1[10 9] -> Both 0 and 1 are active killers and kill_time[1] = 0\n[10 9 7] -> All 0,1,2 are active killers and kill_time[2] = 0\n[10 9 7 8] -> Now, 7 fails to kill 8, which means that 8 will survive for atleast one more round in comparison to 8. Therefore, kill_time[3] = 1. Further, we notice that height 7 can no longer be the one to kill anyone to the right. Therefore, we can remove them from list of active killers. Further, we can see that the kill_time[1] = 0 which means that despite having a greater height (9) in comparison to current height (8), psycho at index 1 cannot be the one to kill psycho at index 3. Therefore, we can once again remove them list of active killers. So, the new active_killers are 0 and 3.\n[10 9 7 8 6] -> As height 6 is lower than 8, psycho 4 would be killed by psycho 3, and the list of active_killers would have 0, 3 and 4.\n.. the process continues so on.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8166",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #189 — Editorial - Codeforces - Code 15",
          "code": "std::stack<int> killers;\n    std::vector<int> kill_time(num, 0);\n    kill_time[0] = -1;\n    killers.push(0);\n    for (int i = 1; i < num; ++i) {\n        while (!killers.empty()) {\n            int cur_killer = killers.top();\n            if (kill_time[cur_killer] != -1 && kill_time[cur_killer] < kill_time[i]) {\n                killers.pop();\n            } else if (height[cur_killer] < height[i]) {\n                kill_time[i] = std::max(kill_time[i], kill_time[cur_killer] + 1);\n                killers.pop();\n            } else break;\n        }\n        if (killers.empty()) kill_time[i] = -1;\n        killers.push(i);\n    }\n    std::cout << *std::max_element(kill_time.begin(), kill_time.end()) + 1 << std::endl;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8166",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #189 — Editorial - Codeforces - Code 16",
          "code": "std::stack<int> killers;\n    std::vector<int> kill_time(num, 0);\n    kill_time[0] = -1;\n    killers.push(0);\n    for (int i = 1; i < num; ++i) {\n        while (!killers.empty()) {\n            int cur_killer = killers.top();\n            if (kill_time[cur_killer] != -1 && kill_time[cur_killer] < kill_time[i]) {\n                killers.pop();\n            } else if (height[cur_killer] < height[i]) {\n                kill_time[i] = std::max(kill_time[i], kill_time[cur_killer] + 1);\n                killers.pop();\n            } else break;\n        }\n        if (killers.empty()) kill_time[i] = -1;\n        killers.push(i);\n    }\n    std::cout << *std::max_element(kill_time.begin(), kill_time.end()) + 1 << std::endl;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/8166",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #189 — Editorial - Codeforces - Code 17",
          "code": "def ismagic(s: str) -> bool:\n    for i in [\"1\", \"14\", \"144\"]:\n        if s == i:\n            return True\n        elif s.endswith(i):\n            return ismagic(s[:-len(i)]) # remove the suffix\n    return False",
          "language": "Python",
          "source": "https://codeforces.com/blog/entry/8166",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #189 — Editorial - Codeforces - Code 18",
          "code": "def ismagic(s: str) -> bool:\n    for i in [\"1\", \"14\", \"144\"]:\n        if s == i:\n            return True\n        elif s.endswith(i):\n            return ismagic(s[:-len(i)]) # remove the suffix\n    return False",
          "language": "Python",
          "source": "https://codeforces.com/blog/entry/8166",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000);\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, 1, 1000000000);\n    inf.readEoln();\n\n    vector<int> b = inf.readInts(n, 0, 1000000000);\n    inf.readEoln();\n\n    ensuref(a[0] == 1, \"a1 must be 1, but it is %d\", a[0]);\n    ensuref(b[n-1] == 0, \"bn must be 0, but it is %d\", b[n-1]);\n\n    for (int i = 1; i < n; ++i) {\n        ensuref(a[i - 1] < a[i], \"a sequence must be strictly increasing at position %d: a[%d]=%d, a[%d]=%d\", i, i - 1, a[i - 1], i, a[i]);\n    }\n    for (int i = 1; i < n; ++i) {\n        ensuref(b[i - 1] > b[i], \"b sequence must be strictly decreasing at position %d: b[%d]=%d, b[%d]=%d\", i, i - 1, b[i - 1], i, b[i]);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000);\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, 1, 1000000000);\n    inf.readEoln();\n\n    vector<int> b = inf.readInts(n, 0, 1000000000);\n    inf.readEoln();\n\n    ensuref(a[0] == 1, \"a1 must be 1, but it is %d\", a[0]);\n    ensuref(b[n-1] == 0, \"bn must be 0, but it is %d\", b[n-1]);\n\n    for (int i = 1; i < n; ++i) {\n        ensuref(a[i - 1] < a[i], \"a sequence must be strictly increasing at position %d: a[%d]=%d, a[%d]=%d\", i, i - 1, a[i - 1], i, a[i]);\n    }\n    for (int i = 1; i < n; ++i) {\n        ensuref(b[i - 1] > b[i], \"b sequence must be strictly decreasing at position %d: b[%d]=%d, b[%d]=%d\", i, i - 1, b[i - 1], i, b[i]);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000);\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, 1, 1000000000);\n    inf.readEoln();\n\n    vector<int> b = inf.readInts(n, 0, 1000000000);\n    inf.readEoln();\n\n    ensuref(a[0] == 1, \"a1 must be 1, but it is %d\", a[0]);\n    ensuref(b[n-1] == 0, \"bn must be 0, but it is %d\", b[n-1]);\n\n    for (int i = 1; i < n; ++i) {\n        ensuref(a[i - 1] < a[i], \"a sequence must be strictly increasing at position %d: a[%d]=%d, a[%d]=%d\", i, i - 1, a[i - 1], i, a[i]);\n    }\n    for (int i = 1; i < n; ++i) {\n        ensuref(b[i - 1] > b[i], \"b sequence must be strictly decreasing at position %d: b[%d]=%d, b[%d]=%d\", i, i - 1, b[i - 1], i, b[i]);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\n/*\nThis generator creates test cases for the \"Kalila and Dimna in the Logging Industry\" problem.\nIt takes parameters to generate various types of inputs to test different scenarios,\nincluding corner cases and large datasets.\n*/\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> a(n), b(n);\n\n    if (type == \"min_case\") {\n        // Minimal case: n = 1\n        n = 1;\n        a.resize(n);\n        b.resize(n);\n        a[0] = 1;\n        b[0] = 0; // bn must be 0 since n = 1\n    } else if (type == \"max_case\") {\n        // Maximal case: n is large, heights and costs are at extremes\n        a[0] = 1;\n        int maxA = int(1e9);\n        int increment = (maxA - 1) / n + 1;\n        for (int i = 1; i < n; ++i) {\n            a[i] = a[i - 1] + increment;\n            if (a[i] > maxA) a[i] = maxA;\n        }\n        b[n - 1] = 0;\n        int maxB = int(1e9);\n        b[0] = maxB;\n        int decrement = maxB / n + 1;\n        for (int i = 1; i < n - 1; ++i) {\n            b[i] = b[i - 1] - decrement;\n            if (b[i] < 1) b[i] = b[i - 1] - 1;\n        }\n        b[n - 1] = 0;\n    } else if (type == \"max_height\") {\n        // Heights increase rapidly to maximum\n        a[0] = 1;\n        for (int i = 1; i < n; ++i) {\n            int maxIncrement = (int(1e9) - a[i-1]) / (n - i);\n            maxIncrement = max(maxIncrement, 1);\n            int delta = rnd.next(1, maxIncrement);\n            a[i] = a[i-1] + delta;\n        }\n        b[n - 1] = 0;\n        b[0] = int(1e9);\n        for (int i = 1; i < n - 1; ++i) {\n            b[i] = rnd.next(b[i - 1] - 1, b[i - 1] - 1);\n            if (b[i] < b[i + 1]) b[i] = b[i + 1] + 1;\n        }\n    } else if (type == \"constant_height\") {\n        // Heights increase by 1, costs decrease randomly\n        a[0] = 1;\n        for (int i = 1; i < n; ++i) {\n            a[i] = a[i - 1] + 1;\n        }\n        b[n - 1] = 0;\n        vector<int> tempB(n - 1);\n        for (int i = 0; i < n - 1; ++i) {\n            tempB[i] = rnd.next(1, int(1e9));\n        }\n        sort(tempB.begin(), tempB.end(), greater<int>());\n        for (int i = 0; i < n - 1; ++i) {\n            b[i] = tempB[i];\n        }\n        b[n - 1] = 0;\n    } else if (type == \"special\") {\n        // Special case where the last tree has height 1\n        a[0] = 1;\n        for (int i = 1; i < n - 1; ++i) {\n            a[i] = a[i - 1] + rnd.next(1, 1000);\n        }\n        a[n - 1] = a[n - 2] + 1; // Ensuring strict increase\n        a[n - 1] = 1; // Setting last tree height to 1\n        b[n - 1] = 0;\n        b[0] = int(1e9);\n        for (int i = 1; i < n - 1; ++i) {\n            b[i] = b[i - 1] - rnd.next(1, 1000);\n            if (b[i] <= b[i + 1]) b[i] = b[i + 1] + 1;\n        }\n        if (n >= 2) b[n - 2] = 1;\n    } else if (type == \"max_n\") {\n        // Maximal n case\n        n = 100000;\n        a.resize(n);\n        b.resize(n);\n        a[0] = 1;\n        for (int i = 1; i < n; ++i) {\n            a[i] = a[i - 1] + 1;\n        }\n        b[n - 1] = 0;\n        b[0] = int(1e9);\n        for (int i = 1; i < n - 1; ++i) {\n            b[i] = b[i - 1] - 1;\n        }\n    } else {\n        // Random case\n        a[0] = 1;\n        for (int i = 1; i < n; ++i) {\n            a[i] = a[i - 1] + rnd.next(1, 1000);\n        }\n        b[n - 1] = 0;\n        b[0] = int(1e9);\n        for (int i = 1; i < n - 1; ++i) {\n            b[i] = b[i - 1] - rnd.next(1, 1000);\n            if (b[i] <= b[i + 1]) b[i] = b[i + 1] + 1;\n        }\n    }\n\n    // Ensure ai < ai+1\n    for (int i = 1; i < n; ++i) {\n        if (a[i] <= a[i - 1]) a[i] = a[i - 1] + 1;\n    }\n    // Ensure bi > bi+1\n    for (int i = n - 2; i >= 0; --i) {\n        if (b[i] <= b[i + 1]) b[i] = b[i + 1] + 1;\n    }\n    // Ensure values are within constraints\n    for (int i = 0; i < n; ++i) {\n        if (a[i] < 1) a[i] = 1;\n        if (a[i] > int(1e9)) a[i] = int(1e9);\n        if (b[i] < 0) b[i] = 0;\n        if (b[i] > int(1e9)) b[i] = int(1e9);\n    }\n\n    // Output\n    printf(\"%d\\n\", n);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d%c\", a[i], i == n - 1 ? '\\n' : ' ');\n    }\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d%c\", b[i], i == n - 1 ? '\\n' : ' ');\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\n/*\nThis generator creates test cases for the \"Kalila and Dimna in the Logging Industry\" problem.\nIt takes parameters to generate various types of inputs to test different scenarios,\nincluding corner cases and large datasets.\n*/\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> a(n), b(n);\n\n    if (type == \"min_case\") {\n        // Minimal case: n = 1\n        n = 1;\n        a.resize(n);\n        b.resize(n);\n        a[0] = 1;\n        b[0] = 0; // bn must be 0 since n = 1\n    } else if (type == \"max_case\") {\n        // Maximal case: n is large, heights and costs are at extremes\n        a[0] = 1;\n        int maxA = int(1e9);\n        int increment = (maxA - 1) / n + 1;\n        for (int i = 1; i < n; ++i) {\n            a[i] = a[i - 1] + increment;\n            if (a[i] > maxA) a[i] = maxA;\n        }\n        b[n - 1] = 0;\n        int maxB = int(1e9);\n        b[0] = maxB;\n        int decrement = maxB / n + 1;\n        for (int i = 1; i < n - 1; ++i) {\n            b[i] = b[i - 1] - decrement;\n            if (b[i] < 1) b[i] = b[i - 1] - 1;\n        }\n        b[n - 1] = 0;\n    } else if (type == \"max_height\") {\n        // Heights increase rapidly to maximum\n        a[0] = 1;\n        for (int i = 1; i < n; ++i) {\n            int maxIncrement = (int(1e9) - a[i-1]) / (n - i);\n            maxIncrement = max(maxIncrement, 1);\n            int delta = rnd.next(1, maxIncrement);\n            a[i] = a[i-1] + delta;\n        }\n        b[n - 1] = 0;\n        b[0] = int(1e9);\n        for (int i = 1; i < n - 1; ++i) {\n            b[i] = rnd.next(b[i - 1] - 1, b[i - 1] - 1);\n            if (b[i] < b[i + 1]) b[i] = b[i + 1] + 1;\n        }\n    } else if (type == \"constant_height\") {\n        // Heights increase by 1, costs decrease randomly\n        a[0] = 1;\n        for (int i = 1; i < n; ++i) {\n            a[i] = a[i - 1] + 1;\n        }\n        b[n - 1] = 0;\n        vector<int> tempB(n - 1);\n        for (int i = 0; i < n - 1; ++i) {\n            tempB[i] = rnd.next(1, int(1e9));\n        }\n        sort(tempB.begin(), tempB.end(), greater<int>());\n        for (int i = 0; i < n - 1; ++i) {\n            b[i] = tempB[i];\n        }\n        b[n - 1] = 0;\n    } else if (type == \"special\") {\n        // Special case where the last tree has height 1\n        a[0] = 1;\n        for (int i = 1; i < n - 1; ++i) {\n            a[i] = a[i - 1] + rnd.next(1, 1000);\n        }\n        a[n - 1] = a[n - 2] + 1; // Ensuring strict increase\n        a[n - 1] = 1; // Setting last tree height to 1\n        b[n - 1] = 0;\n        b[0] = int(1e9);\n        for (int i = 1; i < n - 1; ++i) {\n            b[i] = b[i - 1] - rnd.next(1, 1000);\n            if (b[i] <= b[i + 1]) b[i] = b[i + 1] + 1;\n        }\n        if (n >= 2) b[n - 2] = 1;\n    } else if (type == \"max_n\") {\n        // Maximal n case\n        n = 100000;\n        a.resize(n);\n        b.resize(n);\n        a[0] = 1;\n        for (int i = 1; i < n; ++i) {\n            a[i] = a[i - 1] + 1;\n        }\n        b[n - 1] = 0;\n        b[0] = int(1e9);\n        for (int i = 1; i < n - 1; ++i) {\n            b[i] = b[i - 1] - 1;\n        }\n    } else {\n        // Random case\n        a[0] = 1;\n        for (int i = 1; i < n; ++i) {\n            a[i] = a[i - 1] + rnd.next(1, 1000);\n        }\n        b[n - 1] = 0;\n        b[0] = int(1e9);\n        for (int i = 1; i < n - 1; ++i) {\n            b[i] = b[i - 1] - rnd.next(1, 1000);\n            if (b[i] <= b[i + 1]) b[i] = b[i + 1] + 1;\n        }\n    }\n\n    // Ensure ai < ai+1\n    for (int i = 1; i < n; ++i) {\n        if (a[i] <= a[i - 1]) a[i] = a[i - 1] + 1;\n    }\n    // Ensure bi > bi+1\n    for (int i = n - 2; i >= 0; --i) {\n        if (b[i] <= b[i + 1]) b[i] = b[i + 1] + 1;\n    }\n    // Ensure values are within constraints\n    for (int i = 0; i < n; ++i) {\n        if (a[i] < 1) a[i] = 1;\n        if (a[i] > int(1e9)) a[i] = int(1e9);\n        if (b[i] < 0) b[i] = 0;\n        if (b[i] > int(1e9)) b[i] = int(1e9);\n    }\n\n    // Output\n    printf(\"%d\\n\", n);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d%c\", a[i], i == n - 1 ? '\\n' : ' ');\n    }\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d%c\", b[i], i == n - 1 ? '\\n' : ' ');\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -type min_case\n./gen -n 2 -type special\n./gen -n 5 -type random\n./gen -n 10 -type random\n./gen -n 50 -type random\n./gen -n 100 -type random\n./gen -n 500 -type random\n./gen -n 1000 -type random\n./gen -n 5000 -type random\n./gen -n 10000 -type random\n./gen -n 100000 -type max_n\n./gen -n 100000 -type random\n./gen -n 100000 -type max_case\n./gen -n 10 -type max_height\n./gen -n 50 -type max_height\n./gen -n 1000 -type max_height\n./gen -n 100000 -type max_height\n./gen -n 10 -type constant_height\n./gen -n 50 -type constant_height\n./gen -n 1000 -type constant_height\n./gen -n 100000 -type constant_height\n./gen -n 10 -type special\n./gen -n 50 -type special\n./gen -n 1000 -type special\n./gen -n 100000 -type special\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:07:35.393268",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    }
  ]
}